!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Bitcoin=e()}}(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(_dereq_,module,exports){var util=_dereq_("util/");var pSlice=Array.prototype.slice;var hasOwn=Object.prototype.hasOwnProperty;var assert=module.exports=ok;assert.AssertionError=function AssertionError(options){this.name="AssertionError";this.actual=options.actual;this.expected=options.expected;this.operator=options.operator;if(options.message){this.message=options.message;this.generatedMessage=false}else{this.message=getMessage(this);this.generatedMessage=true}var stackStartFunction=options.stackStartFunction||fail;if(Error.captureStackTrace){Error.captureStackTrace(this,stackStartFunction)}else{var err=new Error;if(err.stack){var out=err.stack;var fn_name=stackStartFunction.name;var idx=out.indexOf("\n"+fn_name);if(idx>=0){var next_line=out.indexOf("\n",idx+1);out=out.substring(next_line+1)}this.stack=out}}};util.inherits(assert.AssertionError,Error);function replacer(key,value){if(util.isUndefined(value)){return""+value}if(util.isNumber(value)&&(isNaN(value)||!isFinite(value))){return value.toString()}if(util.isFunction(value)||util.isRegExp(value)){return value.toString()}return value}function truncate(s,n){if(util.isString(s)){return s.length<n?s:s.slice(0,n)}else{return s}}function getMessage(self){return truncate(JSON.stringify(self.actual,replacer),128)+" "+self.operator+" "+truncate(JSON.stringify(self.expected,replacer),128)}function fail(actual,expected,message,operator,stackStartFunction){throw new assert.AssertionError({message:message,actual:actual,expected:expected,operator:operator,stackStartFunction:stackStartFunction})}assert.fail=fail;function ok(value,message){if(!value)fail(value,true,message,"==",assert.ok)}assert.ok=ok;assert.equal=function equal(actual,expected,message){if(actual!=expected)fail(actual,expected,message,"==",assert.equal)};assert.notEqual=function notEqual(actual,expected,message){if(actual==expected){fail(actual,expected,message,"!=",assert.notEqual)}};assert.deepEqual=function deepEqual(actual,expected,message){if(!_deepEqual(actual,expected)){fail(actual,expected,message,"deepEqual",assert.deepEqual)}};function _deepEqual(actual,expected){if(actual===expected){return true}else if(util.isBuffer(actual)&&util.isBuffer(expected)){if(actual.length!=expected.length)return false;for(var i=0;i<actual.length;i++){if(actual[i]!==expected[i])return false}return true}else if(util.isDate(actual)&&util.isDate(expected)){return actual.getTime()===expected.getTime()}else if(util.isRegExp(actual)&&util.isRegExp(expected)){return actual.source===expected.source&&actual.global===expected.global&&actual.multiline===expected.multiline&&actual.lastIndex===expected.lastIndex&&actual.ignoreCase===expected.ignoreCase}else if(!util.isObject(actual)&&!util.isObject(expected)){return actual==expected}else{return objEquiv(actual,expected)}}function isArguments(object){return Object.prototype.toString.call(object)=="[object Arguments]"}function objEquiv(a,b){if(util.isNullOrUndefined(a)||util.isNullOrUndefined(b))return false;if(a.prototype!==b.prototype)return false;if(isArguments(a)){if(!isArguments(b)){return false}a=pSlice.call(a);b=pSlice.call(b);return _deepEqual(a,b)}try{var ka=objectKeys(a),kb=objectKeys(b),key,i}catch(e){return false}if(ka.length!=kb.length)return false;ka.sort();kb.sort();for(i=ka.length-1;i>=0;i--){if(ka[i]!=kb[i])return false}for(i=ka.length-1;i>=0;i--){key=ka[i];if(!_deepEqual(a[key],b[key]))return false}return true}assert.notDeepEqual=function notDeepEqual(actual,expected,message){if(_deepEqual(actual,expected)){fail(actual,expected,message,"notDeepEqual",assert.notDeepEqual)}};assert.strictEqual=function strictEqual(actual,expected,message){if(actual!==expected){fail(actual,expected,message,"===",assert.strictEqual)}};assert.notStrictEqual=function notStrictEqual(actual,expected,message){if(actual===expected){fail(actual,expected,message,"!==",assert.notStrictEqual)}};function expectedException(actual,expected){if(!actual||!expected){return false}if(Object.prototype.toString.call(expected)=="[object RegExp]"){return expected.test(actual)}else if(actual instanceof expected){return true}else if(expected.call({},actual)===true){return true}return false}function _throws(shouldThrow,block,expected,message){var actual;if(util.isString(expected)){message=expected;expected=null}try{block()}catch(e){actual=e}message=(expected&&expected.name?" ("+expected.name+").":".")+(message?" "+message:".");if(shouldThrow&&!actual){fail(actual,expected,"Missing expected exception"+message)}if(!shouldThrow&&expectedException(actual,expected)){fail(actual,expected,"Got unwanted exception"+message)}if(shouldThrow&&actual&&expected&&!expectedException(actual,expected)||!shouldThrow&&actual){throw actual}}assert.throws=function(block,error,message){_throws.apply(this,[true].concat(pSlice.call(arguments)))};assert.doesNotThrow=function(block,message){_throws.apply(this,[false].concat(pSlice.call(arguments)))};assert.ifError=function(err){if(err){throw err}};var objectKeys=Object.keys||function(obj){var keys=[];for(var key in obj){if(hasOwn.call(obj,key))keys.push(key)}return keys}},{"util/":3}],2:[function(_dereq_,module,exports){module.exports=function isBuffer(arg){return arg&&typeof arg==="object"&&typeof arg.copy==="function"&&typeof arg.fill==="function"&&typeof arg.readUInt8==="function"}},{}],3:[function(_dereq_,module,exports){(function(process,global){var formatRegExp=/%[sdj%]/g;exports.format=function(f){if(!isString(f)){var objects=[];for(var i=0;i<arguments.length;i++){objects.push(inspect(arguments[i]))}return objects.join(" ")}var i=1;var args=arguments;var len=args.length;var str=String(f).replace(formatRegExp,function(x){if(x==="%%")return"%";if(i>=len)return x;switch(x){case"%s":return String(args[i++]);case"%d":return Number(args[i++]);case"%j":try{return JSON.stringify(args[i++])}catch(_){return"[Circular]"}default:return x}});for(var x=args[i];i<len;x=args[++i]){if(isNull(x)||!isObject(x)){str+=" "+x}else{str+=" "+inspect(x)}}return str};exports.deprecate=function(fn,msg){if(isUndefined(global.process)){return function(){return exports.deprecate(fn,msg).apply(this,arguments)}}if(process.noDeprecation===true){return fn}var warned=false;function deprecated(){if(!warned){if(process.throwDeprecation){throw new Error(msg)}else if(process.traceDeprecation){console.trace(msg)}else{console.error(msg)}warned=true}return fn.apply(this,arguments)}return deprecated};var debugs={};var debugEnviron;exports.debuglog=function(set){if(isUndefined(debugEnviron))debugEnviron=process.env.NODE_DEBUG||"";set=set.toUpperCase();if(!debugs[set]){if(new RegExp("\\b"+set+"\\b","i").test(debugEnviron)){var pid=process.pid;debugs[set]=function(){var msg=exports.format.apply(exports,arguments);console.error("%s %d: %s",set,pid,msg)}}else{debugs[set]=function(){}}}return debugs[set]};function inspect(obj,opts){var ctx={seen:[],stylize:stylizeNoColor};if(arguments.length>=3)ctx.depth=arguments[2];if(arguments.length>=4)ctx.colors=arguments[3];if(isBoolean(opts)){ctx.showHidden=opts}else if(opts){exports._extend(ctx,opts)}if(isUndefined(ctx.showHidden))ctx.showHidden=false;if(isUndefined(ctx.depth))ctx.depth=2;if(isUndefined(ctx.colors))ctx.colors=false;if(isUndefined(ctx.customInspect))ctx.customInspect=true;if(ctx.colors)ctx.stylize=stylizeWithColor;return formatValue(ctx,obj,ctx.depth)}exports.inspect=inspect;inspect.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]};inspect.styles={special:"cyan",number:"yellow","boolean":"yellow",undefined:"grey","null":"bold",string:"green",date:"magenta",regexp:"red"};function stylizeWithColor(str,styleType){var style=inspect.styles[styleType];if(style){return"["+inspect.colors[style][0]+"m"+str+"["+inspect.colors[style][1]+"m"}else{return str}}function stylizeNoColor(str,styleType){return str}function arrayToHash(array){var hash={};array.forEach(function(val,idx){hash[val]=true});return hash}function formatValue(ctx,value,recurseTimes){if(ctx.customInspect&&value&&isFunction(value.inspect)&&value.inspect!==exports.inspect&&!(value.constructor&&value.constructor.prototype===value)){var ret=value.inspect(recurseTimes,ctx);if(!isString(ret)){ret=formatValue(ctx,ret,recurseTimes)}return ret}var primitive=formatPrimitive(ctx,value);if(primitive){return primitive}var keys=Object.keys(value);var visibleKeys=arrayToHash(keys);if(ctx.showHidden){keys=Object.getOwnPropertyNames(value)}if(isError(value)&&(keys.indexOf("message")>=0||keys.indexOf("description")>=0)){return formatError(value)}if(keys.length===0){if(isFunction(value)){var name=value.name?": "+value.name:"";return ctx.stylize("[Function"+name+"]","special")}if(isRegExp(value)){return ctx.stylize(RegExp.prototype.toString.call(value),"regexp")}if(isDate(value)){return ctx.stylize(Date.prototype.toString.call(value),"date")}if(isError(value)){return formatError(value)}}var base="",array=false,braces=["{","}"];if(isArray(value)){array=true;braces=["[","]"]}if(isFunction(value)){var n=value.name?": "+value.name:"";base=" [Function"+n+"]"}if(isRegExp(value)){base=" "+RegExp.prototype.toString.call(value)}if(isDate(value)){base=" "+Date.prototype.toUTCString.call(value)}if(isError(value)){base=" "+formatError(value)}if(keys.length===0&&(!array||value.length==0)){return braces[0]+base+braces[1]}if(recurseTimes<0){if(isRegExp(value)){return ctx.stylize(RegExp.prototype.toString.call(value),"regexp")}else{return ctx.stylize("[Object]","special")}}ctx.seen.push(value);var output;if(array){output=formatArray(ctx,value,recurseTimes,visibleKeys,keys)}else{output=keys.map(function(key){return formatProperty(ctx,value,recurseTimes,visibleKeys,key,array)})}ctx.seen.pop();return reduceToSingleString(output,base,braces)}function formatPrimitive(ctx,value){if(isUndefined(value))return ctx.stylize("undefined","undefined");if(isString(value)){var simple="'"+JSON.stringify(value).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return ctx.stylize(simple,"string")}if(isNumber(value))return ctx.stylize(""+value,"number");if(isBoolean(value))return ctx.stylize(""+value,"boolean");if(isNull(value))return ctx.stylize("null","null")}function formatError(value){return"["+Error.prototype.toString.call(value)+"]"}function formatArray(ctx,value,recurseTimes,visibleKeys,keys){var output=[];for(var i=0,l=value.length;i<l;++i){if(hasOwnProperty(value,String(i))){output.push(formatProperty(ctx,value,recurseTimes,visibleKeys,String(i),true))}else{output.push("")}}keys.forEach(function(key){if(!key.match(/^\d+$/)){output.push(formatProperty(ctx,value,recurseTimes,visibleKeys,key,true))}});return output}function formatProperty(ctx,value,recurseTimes,visibleKeys,key,array){var name,str,desc;desc=Object.getOwnPropertyDescriptor(value,key)||{value:value[key]};if(desc.get){if(desc.set){str=ctx.stylize("[Getter/Setter]","special")}else{str=ctx.stylize("[Getter]","special")}}else{if(desc.set){str=ctx.stylize("[Setter]","special")}}if(!hasOwnProperty(visibleKeys,key)){name="["+key+"]"}if(!str){if(ctx.seen.indexOf(desc.value)<0){if(isNull(recurseTimes)){str=formatValue(ctx,desc.value,null)}else{str=formatValue(ctx,desc.value,recurseTimes-1)}if(str.indexOf("\n")>-1){if(array){str=str.split("\n").map(function(line){return"  "+line}).join("\n").substr(2)}else{str="\n"+str.split("\n").map(function(line){return"   "+line}).join("\n")}}}else{str=ctx.stylize("[Circular]","special")}}if(isUndefined(name)){if(array&&key.match(/^\d+$/)){return str}name=JSON.stringify(""+key);if(name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)){name=name.substr(1,name.length-2);name=ctx.stylize(name,"name")}else{name=name.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'");name=ctx.stylize(name,"string")}}return name+": "+str}function reduceToSingleString(output,base,braces){var numLinesEst=0;var length=output.reduce(function(prev,cur){numLinesEst++;if(cur.indexOf("\n")>=0)numLinesEst++;return prev+cur.replace(/\u001b\[\d\d?m/g,"").length+1},0);if(length>60){return braces[0]+(base===""?"":base+"\n ")+" "+output.join(",\n  ")+" "+braces[1]}return braces[0]+base+" "+output.join(", ")+" "+braces[1]}function isArray(ar){return Array.isArray(ar)}exports.isArray=isArray;function isBoolean(arg){return typeof arg==="boolean"}exports.isBoolean=isBoolean;function isNull(arg){return arg===null}exports.isNull=isNull;function isNullOrUndefined(arg){return arg==null}exports.isNullOrUndefined=isNullOrUndefined;function isNumber(arg){return typeof arg==="number"}exports.isNumber=isNumber;function isString(arg){return typeof arg==="string"}exports.isString=isString;function isSymbol(arg){return typeof arg==="symbol"}exports.isSymbol=isSymbol;function isUndefined(arg){return arg===void 0}exports.isUndefined=isUndefined;function isRegExp(re){return isObject(re)&&objectToString(re)==="[object RegExp]"}exports.isRegExp=isRegExp;function isObject(arg){return typeof arg==="object"&&arg!==null}exports.isObject=isObject;function isDate(d){return isObject(d)&&objectToString(d)==="[object Date]"}exports.isDate=isDate;function isError(e){return isObject(e)&&(objectToString(e)==="[object Error]"||e instanceof Error)}exports.isError=isError;function isFunction(arg){return typeof arg==="function"}exports.isFunction=isFunction;function isPrimitive(arg){return arg===null||typeof arg==="boolean"||typeof arg==="number"||typeof arg==="string"||typeof arg==="symbol"||typeof arg==="undefined"}exports.isPrimitive=isPrimitive;exports.isBuffer=_dereq_("./support/isBuffer");function objectToString(o){return Object.prototype.toString.call(o)}function pad(n){return n<10?"0"+n.toString(10):n.toString(10)}var months=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function timestamp(){var d=new Date;var time=[pad(d.getHours()),pad(d.getMinutes()),pad(d.getSeconds())].join(":");return[d.getDate(),months[d.getMonth()],time].join(" ")}exports.log=function(){console.log("%s - %s",timestamp(),exports.format.apply(exports,arguments))};exports.inherits=_dereq_("inherits");exports._extend=function(origin,add){if(!add||!isObject(add))return origin;var keys=Object.keys(add);var i=keys.length;while(i--){origin[keys[i]]=add[keys[i]]}return origin};function hasOwnProperty(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop)}}).call(this,_dereq_("FWaASH"),typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./support/isBuffer":2,FWaASH:15,inherits:14}],4:[function(_dereq_,module,exports){},{}],5:[function(_dereq_,module,exports){var base64=_dereq_("base64-js");var ieee754=_dereq_("ieee754");exports.Buffer=Buffer;exports.SlowBuffer=Buffer;exports.INSPECT_MAX_BYTES=50;Buffer.poolSize=8192;Buffer._useTypedArrays=function(){try{var buf=new ArrayBuffer(0);var arr=new Uint8Array(buf);arr.foo=function(){return 42};return 42===arr.foo()&&typeof arr.subarray==="function"}catch(e){return false}}();function Buffer(subject,encoding,noZero){if(!(this instanceof Buffer))return new Buffer(subject,encoding,noZero);var type=typeof subject;if(encoding==="base64"&&type==="string"){subject=stringtrim(subject);while(subject.length%4!==0){subject=subject+"="}}var length;if(type==="number")length=coerce(subject);else if(type==="string")length=Buffer.byteLength(subject,encoding);else if(type==="object")length=coerce(subject.length);else throw new Error("First argument needs to be a number, array or string.");var buf;if(Buffer._useTypedArrays){buf=Buffer._augment(new Uint8Array(length))}else{buf=this;buf.length=length;buf._isBuffer=true}var i;if(Buffer._useTypedArrays&&typeof subject.byteLength==="number"){buf._set(subject)}else if(isArrayish(subject)){if(Buffer.isBuffer(subject)){for(i=0;i<length;i++)buf[i]=subject.readUInt8(i)}else{for(i=0;i<length;i++)buf[i]=(subject[i]%256+256)%256}}else if(type==="string"){buf.write(subject,0,encoding)}else if(type==="number"&&!Buffer._useTypedArrays&&!noZero){for(i=0;i<length;i++){buf[i]=0}}return buf}Buffer.isEncoding=function(encoding){switch(String(encoding).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"raw":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return true;default:return false}};Buffer.isBuffer=function(b){return!!(b!==null&&b!==undefined&&b._isBuffer)};Buffer.byteLength=function(str,encoding){var ret;str=str.toString();switch(encoding||"utf8"){case"hex":ret=str.length/2;break;case"utf8":case"utf-8":ret=utf8ToBytes(str).length;break;case"ascii":case"binary":case"raw":ret=str.length;break;case"base64":ret=base64ToBytes(str).length;break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":ret=str.length*2;break;default:throw new Error("Unknown encoding")}return ret};Buffer.concat=function(list,totalLength){assert(isArray(list),"Usage: Buffer.concat(list[, length])");if(list.length===0){return new Buffer(0)}else if(list.length===1){return list[0]}var i;if(totalLength===undefined){totalLength=0;for(i=0;i<list.length;i++){totalLength+=list[i].length}}var buf=new Buffer(totalLength);var pos=0;for(i=0;i<list.length;i++){var item=list[i];item.copy(buf,pos);pos+=item.length}return buf};Buffer.compare=function(a,b){assert(Buffer.isBuffer(a)&&Buffer.isBuffer(b),"Arguments must be Buffers");var x=a.length;var y=b.length;for(var i=0,len=Math.min(x,y);i<len&&a[i]===b[i];i++){}if(i!==len){x=a[i];y=b[i]}if(x<y){return-1}if(y<x){return 1}return 0};function hexWrite(buf,string,offset,length){offset=Number(offset)||0;var remaining=buf.length-offset;if(!length){length=remaining}else{length=Number(length);if(length>remaining){length=remaining}}var strLen=string.length;assert(strLen%2===0,"Invalid hex string");if(length>strLen/2){length=strLen/2}for(var i=0;i<length;i++){var byte=parseInt(string.substr(i*2,2),16);assert(!isNaN(byte),"Invalid hex string");buf[offset+i]=byte}return i}function utf8Write(buf,string,offset,length){var charsWritten=blitBuffer(utf8ToBytes(string),buf,offset,length);return charsWritten}function asciiWrite(buf,string,offset,length){var charsWritten=blitBuffer(asciiToBytes(string),buf,offset,length);return charsWritten}function binaryWrite(buf,string,offset,length){return asciiWrite(buf,string,offset,length)}function base64Write(buf,string,offset,length){var charsWritten=blitBuffer(base64ToBytes(string),buf,offset,length);return charsWritten}function utf16leWrite(buf,string,offset,length){var charsWritten=blitBuffer(utf16leToBytes(string),buf,offset,length);return charsWritten}Buffer.prototype.write=function(string,offset,length,encoding){if(isFinite(offset)){if(!isFinite(length)){encoding=length;length=undefined}}else{var swap=encoding;encoding=offset;offset=length;length=swap}offset=Number(offset)||0;var remaining=this.length-offset;if(!length){length=remaining}else{length=Number(length);if(length>remaining){length=remaining}}encoding=String(encoding||"utf8").toLowerCase();var ret;switch(encoding){case"hex":ret=hexWrite(this,string,offset,length);break;case"utf8":case"utf-8":ret=utf8Write(this,string,offset,length);break;case"ascii":ret=asciiWrite(this,string,offset,length);break;case"binary":ret=binaryWrite(this,string,offset,length);break;case"base64":ret=base64Write(this,string,offset,length);break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":ret=utf16leWrite(this,string,offset,length);break;default:throw new Error("Unknown encoding")}return ret};Buffer.prototype.toString=function(encoding,start,end){var self=this;encoding=String(encoding||"utf8").toLowerCase();start=Number(start)||0;end=end===undefined?self.length:Number(end);if(end===start)return"";var ret;switch(encoding){case"hex":ret=hexSlice(self,start,end);break;case"utf8":case"utf-8":ret=utf8Slice(self,start,end);break;case"ascii":ret=asciiSlice(self,start,end);break;case"binary":ret=binarySlice(self,start,end);break;case"base64":ret=base64Slice(self,start,end);break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":ret=utf16leSlice(self,start,end);break;default:throw new Error("Unknown encoding")}return ret};Buffer.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};Buffer.prototype.equals=function(b){assert(Buffer.isBuffer(b),"Argument must be a Buffer");return Buffer.compare(this,b)===0};Buffer.prototype.compare=function(b){assert(Buffer.isBuffer(b),"Argument must be a Buffer");return Buffer.compare(this,b)};Buffer.prototype.copy=function(target,target_start,start,end){var source=this;if(!start)start=0;if(!end&&end!==0)end=this.length;if(!target_start)target_start=0;if(end===start)return;if(target.length===0||source.length===0)return;assert(end>=start,"sourceEnd < sourceStart");assert(target_start>=0&&target_start<target.length,"targetStart out of bounds");assert(start>=0&&start<source.length,"sourceStart out of bounds");assert(end>=0&&end<=source.length,"sourceEnd out of bounds");if(end>this.length)end=this.length;if(target.length-target_start<end-start)end=target.length-target_start+start;var len=end-start;if(len<100||!Buffer._useTypedArrays){for(var i=0;i<len;i++){target[i+target_start]=this[i+start]}}else{target._set(this.subarray(start,start+len),target_start)}};function base64Slice(buf,start,end){if(start===0&&end===buf.length){return base64.fromByteArray(buf)}else{return base64.fromByteArray(buf.slice(start,end))}}function utf8Slice(buf,start,end){var res="";var tmp="";end=Math.min(buf.length,end);for(var i=start;i<end;i++){if(buf[i]<=127){res+=decodeUtf8Char(tmp)+String.fromCharCode(buf[i]);tmp=""}else{tmp+="%"+buf[i].toString(16)}}return res+decodeUtf8Char(tmp)}function asciiSlice(buf,start,end){var ret="";end=Math.min(buf.length,end);for(var i=start;i<end;i++){ret+=String.fromCharCode(buf[i])}return ret}function binarySlice(buf,start,end){return asciiSlice(buf,start,end)}function hexSlice(buf,start,end){var len=buf.length;if(!start||start<0)start=0;if(!end||end<0||end>len)end=len;var out="";for(var i=start;i<end;i++){out+=toHex(buf[i])}return out}function utf16leSlice(buf,start,end){var bytes=buf.slice(start,end);var res="";for(var i=0;i<bytes.length;i+=2){res+=String.fromCharCode(bytes[i]+bytes[i+1]*256)}return res}Buffer.prototype.slice=function(start,end){var len=this.length;start=clamp(start,len,0);end=clamp(end,len,len);if(Buffer._useTypedArrays){return Buffer._augment(this.subarray(start,end))}else{var sliceLen=end-start;var newBuf=new Buffer(sliceLen,undefined,true);for(var i=0;i<sliceLen;i++){newBuf[i]=this[i+start]}return newBuf}};Buffer.prototype.get=function(offset){console.log(".get() is deprecated. Access using array indexes instead.");return this.readUInt8(offset)};Buffer.prototype.set=function(v,offset){console.log(".set() is deprecated. Access using array indexes instead.");return this.writeUInt8(v,offset)};Buffer.prototype.readUInt8=function(offset,noAssert){if(!noAssert){assert(offset!==undefined&&offset!==null,"missing offset");assert(offset<this.length,"Trying to read beyond buffer length")}if(offset>=this.length)return;return this[offset]};function readUInt16(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+1<buf.length,"Trying to read beyond buffer length")}var len=buf.length;if(offset>=len)return;var val;if(littleEndian){val=buf[offset];if(offset+1<len)val|=buf[offset+1]<<8}else{val=buf[offset]<<8;if(offset+1<len)val|=buf[offset+1]}return val}Buffer.prototype.readUInt16LE=function(offset,noAssert){return readUInt16(this,offset,true,noAssert)};Buffer.prototype.readUInt16BE=function(offset,noAssert){return readUInt16(this,offset,false,noAssert)};function readUInt32(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+3<buf.length,"Trying to read beyond buffer length")}var len=buf.length;if(offset>=len)return;var val;if(littleEndian){if(offset+2<len)val=buf[offset+2]<<16;if(offset+1<len)val|=buf[offset+1]<<8;val|=buf[offset];if(offset+3<len)val=val+(buf[offset+3]<<24>>>0)}else{if(offset+1<len)val=buf[offset+1]<<16;if(offset+2<len)val|=buf[offset+2]<<8;if(offset+3<len)val|=buf[offset+3];val=val+(buf[offset]<<24>>>0)}return val}Buffer.prototype.readUInt32LE=function(offset,noAssert){return readUInt32(this,offset,true,noAssert)};Buffer.prototype.readUInt32BE=function(offset,noAssert){return readUInt32(this,offset,false,noAssert)};Buffer.prototype.readInt8=function(offset,noAssert){if(!noAssert){assert(offset!==undefined&&offset!==null,"missing offset");assert(offset<this.length,"Trying to read beyond buffer length")}if(offset>=this.length)return;var neg=this[offset]&128;if(neg)return(255-this[offset]+1)*-1;else return this[offset]};function readInt16(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+1<buf.length,"Trying to read beyond buffer length")}var len=buf.length;if(offset>=len)return;var val=readUInt16(buf,offset,littleEndian,true);var neg=val&32768;if(neg)return(65535-val+1)*-1;else return val}Buffer.prototype.readInt16LE=function(offset,noAssert){return readInt16(this,offset,true,noAssert)};Buffer.prototype.readInt16BE=function(offset,noAssert){return readInt16(this,offset,false,noAssert)};function readInt32(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+3<buf.length,"Trying to read beyond buffer length")}var len=buf.length;if(offset>=len)return;var val=readUInt32(buf,offset,littleEndian,true);var neg=val&2147483648;if(neg)return(4294967295-val+1)*-1;else return val}Buffer.prototype.readInt32LE=function(offset,noAssert){return readInt32(this,offset,true,noAssert)};Buffer.prototype.readInt32BE=function(offset,noAssert){return readInt32(this,offset,false,noAssert)};function readFloat(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset+3<buf.length,"Trying to read beyond buffer length")}return ieee754.read(buf,offset,littleEndian,23,4)}Buffer.prototype.readFloatLE=function(offset,noAssert){return readFloat(this,offset,true,noAssert)};Buffer.prototype.readFloatBE=function(offset,noAssert){return readFloat(this,offset,false,noAssert)};function readDouble(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset+7<buf.length,"Trying to read beyond buffer length")}return ieee754.read(buf,offset,littleEndian,52,8)}Buffer.prototype.readDoubleLE=function(offset,noAssert){return readDouble(this,offset,true,noAssert)};Buffer.prototype.readDoubleBE=function(offset,noAssert){return readDouble(this,offset,false,noAssert)};Buffer.prototype.writeUInt8=function(value,offset,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset<this.length,"trying to write beyond buffer length");verifuint(value,255)}if(offset>=this.length)return;this[offset]=value;return offset+1};function writeUInt16(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+1<buf.length,"trying to write beyond buffer length");verifuint(value,65535)}var len=buf.length;if(offset>=len)return;for(var i=0,j=Math.min(len-offset,2);i<j;i++){buf[offset+i]=(value&255<<8*(littleEndian?i:1-i))>>>(littleEndian?i:1-i)*8}return offset+2}Buffer.prototype.writeUInt16LE=function(value,offset,noAssert){return writeUInt16(this,value,offset,true,noAssert)};Buffer.prototype.writeUInt16BE=function(value,offset,noAssert){return writeUInt16(this,value,offset,false,noAssert)};function writeUInt32(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+3<buf.length,"trying to write beyond buffer length");verifuint(value,4294967295)}var len=buf.length;if(offset>=len)return;for(var i=0,j=Math.min(len-offset,4);i<j;i++){buf[offset+i]=value>>>(littleEndian?i:3-i)*8&255}return offset+4}Buffer.prototype.writeUInt32LE=function(value,offset,noAssert){return writeUInt32(this,value,offset,true,noAssert)};Buffer.prototype.writeUInt32BE=function(value,offset,noAssert){return writeUInt32(this,value,offset,false,noAssert)};Buffer.prototype.writeInt8=function(value,offset,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset<this.length,"Trying to write beyond buffer length");verifsint(value,127,-128)}if(offset>=this.length)return;if(value>=0)this.writeUInt8(value,offset,noAssert);else this.writeUInt8(255+value+1,offset,noAssert);return offset+1};function writeInt16(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+1<buf.length,"Trying to write beyond buffer length");verifsint(value,32767,-32768)}var len=buf.length;if(offset>=len)return;if(value>=0)writeUInt16(buf,value,offset,littleEndian,noAssert);else writeUInt16(buf,65535+value+1,offset,littleEndian,noAssert);return offset+2}Buffer.prototype.writeInt16LE=function(value,offset,noAssert){return writeInt16(this,value,offset,true,noAssert)};Buffer.prototype.writeInt16BE=function(value,offset,noAssert){return writeInt16(this,value,offset,false,noAssert)};function writeInt32(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+3<buf.length,"Trying to write beyond buffer length");verifsint(value,2147483647,-2147483648)}var len=buf.length;if(offset>=len)return;if(value>=0)writeUInt32(buf,value,offset,littleEndian,noAssert);else writeUInt32(buf,4294967295+value+1,offset,littleEndian,noAssert);return offset+4}Buffer.prototype.writeInt32LE=function(value,offset,noAssert){return writeInt32(this,value,offset,true,noAssert)};Buffer.prototype.writeInt32BE=function(value,offset,noAssert){return writeInt32(this,value,offset,false,noAssert)};function writeFloat(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+3<buf.length,"Trying to write beyond buffer length");verifIEEE754(value,3.4028234663852886e38,-3.4028234663852886e38)}var len=buf.length;if(offset>=len)return;ieee754.write(buf,value,offset,littleEndian,23,4);return offset+4
}Buffer.prototype.writeFloatLE=function(value,offset,noAssert){return writeFloat(this,value,offset,true,noAssert)};Buffer.prototype.writeFloatBE=function(value,offset,noAssert){return writeFloat(this,value,offset,false,noAssert)};function writeDouble(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+7<buf.length,"Trying to write beyond buffer length");verifIEEE754(value,1.7976931348623157e308,-1.7976931348623157e308)}var len=buf.length;if(offset>=len)return;ieee754.write(buf,value,offset,littleEndian,52,8);return offset+8}Buffer.prototype.writeDoubleLE=function(value,offset,noAssert){return writeDouble(this,value,offset,true,noAssert)};Buffer.prototype.writeDoubleBE=function(value,offset,noAssert){return writeDouble(this,value,offset,false,noAssert)};Buffer.prototype.fill=function(value,start,end){if(!value)value=0;if(!start)start=0;if(!end)end=this.length;assert(end>=start,"end < start");if(end===start)return;if(this.length===0)return;assert(start>=0&&start<this.length,"start out of bounds");assert(end>=0&&end<=this.length,"end out of bounds");var i;if(typeof value==="number"){for(i=start;i<end;i++){this[i]=value}}else{var bytes=utf8ToBytes(value.toString());var len=bytes.length;for(i=start;i<end;i++){this[i]=bytes[i%len]}}return this};Buffer.prototype.inspect=function(){var out=[];var len=this.length;for(var i=0;i<len;i++){out[i]=toHex(this[i]);if(i===exports.INSPECT_MAX_BYTES){out[i+1]="...";break}}return"<Buffer "+out.join(" ")+">"};Buffer.prototype.toArrayBuffer=function(){if(typeof Uint8Array!=="undefined"){if(Buffer._useTypedArrays){return new Buffer(this).buffer}else{var buf=new Uint8Array(this.length);for(var i=0,len=buf.length;i<len;i+=1){buf[i]=this[i]}return buf.buffer}}else{throw new Error("Buffer.toArrayBuffer not supported in this browser")}};var BP=Buffer.prototype;Buffer._augment=function(arr){arr._isBuffer=true;arr._get=arr.get;arr._set=arr.set;arr.get=BP.get;arr.set=BP.set;arr.write=BP.write;arr.toString=BP.toString;arr.toLocaleString=BP.toString;arr.toJSON=BP.toJSON;arr.equals=BP.equals;arr.compare=BP.compare;arr.copy=BP.copy;arr.slice=BP.slice;arr.readUInt8=BP.readUInt8;arr.readUInt16LE=BP.readUInt16LE;arr.readUInt16BE=BP.readUInt16BE;arr.readUInt32LE=BP.readUInt32LE;arr.readUInt32BE=BP.readUInt32BE;arr.readInt8=BP.readInt8;arr.readInt16LE=BP.readInt16LE;arr.readInt16BE=BP.readInt16BE;arr.readInt32LE=BP.readInt32LE;arr.readInt32BE=BP.readInt32BE;arr.readFloatLE=BP.readFloatLE;arr.readFloatBE=BP.readFloatBE;arr.readDoubleLE=BP.readDoubleLE;arr.readDoubleBE=BP.readDoubleBE;arr.writeUInt8=BP.writeUInt8;arr.writeUInt16LE=BP.writeUInt16LE;arr.writeUInt16BE=BP.writeUInt16BE;arr.writeUInt32LE=BP.writeUInt32LE;arr.writeUInt32BE=BP.writeUInt32BE;arr.writeInt8=BP.writeInt8;arr.writeInt16LE=BP.writeInt16LE;arr.writeInt16BE=BP.writeInt16BE;arr.writeInt32LE=BP.writeInt32LE;arr.writeInt32BE=BP.writeInt32BE;arr.writeFloatLE=BP.writeFloatLE;arr.writeFloatBE=BP.writeFloatBE;arr.writeDoubleLE=BP.writeDoubleLE;arr.writeDoubleBE=BP.writeDoubleBE;arr.fill=BP.fill;arr.inspect=BP.inspect;arr.toArrayBuffer=BP.toArrayBuffer;return arr};function stringtrim(str){if(str.trim)return str.trim();return str.replace(/^\s+|\s+$/g,"")}function clamp(index,len,defaultValue){if(typeof index!=="number")return defaultValue;index=~~index;if(index>=len)return len;if(index>=0)return index;index+=len;if(index>=0)return index;return 0}function coerce(length){length=~~Math.ceil(+length);return length<0?0:length}function isArray(subject){return(Array.isArray||function(subject){return Object.prototype.toString.call(subject)==="[object Array]"})(subject)}function isArrayish(subject){return isArray(subject)||Buffer.isBuffer(subject)||subject&&typeof subject==="object"&&typeof subject.length==="number"}function toHex(n){if(n<16)return"0"+n.toString(16);return n.toString(16)}function utf8ToBytes(str){var byteArray=[];for(var i=0;i<str.length;i++){var b=str.charCodeAt(i);if(b<=127){byteArray.push(b)}else{var start=i;if(b>=55296&&b<=57343)i++;var h=encodeURIComponent(str.slice(start,i+1)).substr(1).split("%");for(var j=0;j<h.length;j++){byteArray.push(parseInt(h[j],16))}}}return byteArray}function asciiToBytes(str){var byteArray=[];for(var i=0;i<str.length;i++){byteArray.push(str.charCodeAt(i)&255)}return byteArray}function utf16leToBytes(str){var c,hi,lo;var byteArray=[];for(var i=0;i<str.length;i++){c=str.charCodeAt(i);hi=c>>8;lo=c%256;byteArray.push(lo);byteArray.push(hi)}return byteArray}function base64ToBytes(str){return base64.toByteArray(str)}function blitBuffer(src,dst,offset,length){for(var i=0;i<length;i++){if(i+offset>=dst.length||i>=src.length)break;dst[i+offset]=src[i]}return i}function decodeUtf8Char(str){try{return decodeURIComponent(str)}catch(err){return String.fromCharCode(65533)}}function verifuint(value,max){assert(typeof value==="number","cannot write a non-number as a number");assert(value>=0,"specified a negative value for writing an unsigned value");assert(value<=max,"value is larger than maximum value for type");assert(Math.floor(value)===value,"value has a fractional component")}function verifsint(value,max,min){assert(typeof value==="number","cannot write a non-number as a number");assert(value<=max,"value larger than maximum allowed value");assert(value>=min,"value smaller than minimum allowed value");assert(Math.floor(value)===value,"value has a fractional component")}function verifIEEE754(value,max,min){assert(typeof value==="number","cannot write a non-number as a number");assert(value<=max,"value larger than maximum allowed value");assert(value>=min,"value smaller than minimum allowed value")}function assert(test,message){if(!test)throw new Error(message||"Failed assertion")}},{"base64-js":6,ieee754:7}],6:[function(_dereq_,module,exports){var lookup="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";(function(exports){"use strict";var Arr=typeof Uint8Array!=="undefined"?Uint8Array:Array;var ZERO="0".charCodeAt(0);var PLUS="+".charCodeAt(0);var SLASH="/".charCodeAt(0);var NUMBER="0".charCodeAt(0);var LOWER="a".charCodeAt(0);var UPPER="A".charCodeAt(0);function decode(elt){var code=elt.charCodeAt(0);if(code===PLUS)return 62;if(code===SLASH)return 63;if(code<NUMBER)return-1;if(code<NUMBER+10)return code-NUMBER+26+26;if(code<UPPER+26)return code-UPPER;if(code<LOWER+26)return code-LOWER+26}function b64ToByteArray(b64){var i,j,l,tmp,placeHolders,arr;if(b64.length%4>0){throw new Error("Invalid string. Length must be a multiple of 4")}var len=b64.length;placeHolders="="===b64.charAt(len-2)?2:"="===b64.charAt(len-1)?1:0;arr=new Arr(b64.length*3/4-placeHolders);l=placeHolders>0?b64.length-4:b64.length;var L=0;function push(v){arr[L++]=v}for(i=0,j=0;i<l;i+=4,j+=3){tmp=decode(b64.charAt(i))<<18|decode(b64.charAt(i+1))<<12|decode(b64.charAt(i+2))<<6|decode(b64.charAt(i+3));push((tmp&16711680)>>16);push((tmp&65280)>>8);push(tmp&255)}if(placeHolders===2){tmp=decode(b64.charAt(i))<<2|decode(b64.charAt(i+1))>>4;push(tmp&255)}else if(placeHolders===1){tmp=decode(b64.charAt(i))<<10|decode(b64.charAt(i+1))<<4|decode(b64.charAt(i+2))>>2;push(tmp>>8&255);push(tmp&255)}return arr}function uint8ToBase64(uint8){var i,extraBytes=uint8.length%3,output="",temp,length;function encode(num){return lookup.charAt(num)}function tripletToBase64(num){return encode(num>>18&63)+encode(num>>12&63)+encode(num>>6&63)+encode(num&63)}for(i=0,length=uint8.length-extraBytes;i<length;i+=3){temp=(uint8[i]<<16)+(uint8[i+1]<<8)+uint8[i+2];output+=tripletToBase64(temp)}switch(extraBytes){case 1:temp=uint8[uint8.length-1];output+=encode(temp>>2);output+=encode(temp<<4&63);output+="==";break;case 2:temp=(uint8[uint8.length-2]<<8)+uint8[uint8.length-1];output+=encode(temp>>10);output+=encode(temp>>4&63);output+=encode(temp<<2&63);output+="=";break}return output}module.exports.toByteArray=b64ToByteArray;module.exports.fromByteArray=uint8ToBase64})()},{}],7:[function(_dereq_,module,exports){exports.read=function(buffer,offset,isLE,mLen,nBytes){var e,m,eLen=nBytes*8-mLen-1,eMax=(1<<eLen)-1,eBias=eMax>>1,nBits=-7,i=isLE?nBytes-1:0,d=isLE?-1:1,s=buffer[offset+i];i+=d;e=s&(1<<-nBits)-1;s>>=-nBits;nBits+=eLen;for(;nBits>0;e=e*256+buffer[offset+i],i+=d,nBits-=8);m=e&(1<<-nBits)-1;e>>=-nBits;nBits+=mLen;for(;nBits>0;m=m*256+buffer[offset+i],i+=d,nBits-=8);if(e===0){e=1-eBias}else if(e===eMax){return m?NaN:(s?-1:1)*Infinity}else{m=m+Math.pow(2,mLen);e=e-eBias}return(s?-1:1)*m*Math.pow(2,e-mLen)};exports.write=function(buffer,value,offset,isLE,mLen,nBytes){var e,m,c,eLen=nBytes*8-mLen-1,eMax=(1<<eLen)-1,eBias=eMax>>1,rt=mLen===23?Math.pow(2,-24)-Math.pow(2,-77):0,i=isLE?0:nBytes-1,d=isLE?1:-1,s=value<0||value===0&&1/value<0?1:0;value=Math.abs(value);if(isNaN(value)||value===Infinity){m=isNaN(value)?1:0;e=eMax}else{e=Math.floor(Math.log(value)/Math.LN2);if(value*(c=Math.pow(2,-e))<1){e--;c*=2}if(e+eBias>=1){value+=rt/c}else{value+=rt*Math.pow(2,1-eBias)}if(value*c>=2){e++;c/=2}if(e+eBias>=eMax){m=0;e=eMax}else if(e+eBias>=1){m=(value*c-1)*Math.pow(2,mLen);e=e+eBias}else{m=value*Math.pow(2,eBias-1)*Math.pow(2,mLen);e=0}}for(;mLen>=8;buffer[offset+i]=m&255,i+=d,m/=256,mLen-=8);e=e<<mLen|m;eLen+=mLen;for(;eLen>0;buffer[offset+i]=e&255,i+=d,e/=256,eLen-=8);buffer[offset+i-d]|=s*128}},{}],8:[function(_dereq_,module,exports){var Buffer=_dereq_("buffer").Buffer;var intSize=4;var zeroBuffer=new Buffer(intSize);zeroBuffer.fill(0);var chrsz=8;function toArray(buf,bigEndian){if(buf.length%intSize!==0){var len=buf.length+(intSize-buf.length%intSize);buf=Buffer.concat([buf,zeroBuffer],len)}var arr=[];var fn=bigEndian?buf.readInt32BE:buf.readInt32LE;for(var i=0;i<buf.length;i+=intSize){arr.push(fn.call(buf,i))}return arr}function toBuffer(arr,size,bigEndian){var buf=new Buffer(size);var fn=bigEndian?buf.writeInt32BE:buf.writeInt32LE;for(var i=0;i<arr.length;i++){fn.call(buf,arr[i],i*4,true)}return buf}function hash(buf,fn,hashSize,bigEndian){if(!Buffer.isBuffer(buf))buf=new Buffer(buf);var arr=fn(toArray(buf,bigEndian),buf.length*chrsz);return toBuffer(arr,hashSize,bigEndian)}module.exports={hash:hash}},{buffer:5}],9:[function(_dereq_,module,exports){var Buffer=_dereq_("buffer").Buffer;var sha=_dereq_("./sha");var sha256=_dereq_("./sha256");var rng=_dereq_("./rng");var md5=_dereq_("./md5");var algorithms={sha1:sha,sha256:sha256,md5:md5};var blocksize=64;var zeroBuffer=new Buffer(blocksize);zeroBuffer.fill(0);function hmac(fn,key,data){if(!Buffer.isBuffer(key))key=new Buffer(key);if(!Buffer.isBuffer(data))data=new Buffer(data);if(key.length>blocksize){key=fn(key)}else if(key.length<blocksize){key=Buffer.concat([key,zeroBuffer],blocksize)}var ipad=new Buffer(blocksize),opad=new Buffer(blocksize);for(var i=0;i<blocksize;i++){ipad[i]=key[i]^54;opad[i]=key[i]^92}var hash=fn(Buffer.concat([ipad,data]));return fn(Buffer.concat([opad,hash]))}function hash(alg,key){alg=alg||"sha1";var fn=algorithms[alg];var bufs=[];var length=0;if(!fn)error("algorithm:",alg,"is not yet supported");return{update:function(data){if(!Buffer.isBuffer(data))data=new Buffer(data);bufs.push(data);length+=data.length;return this},digest:function(enc){var buf=Buffer.concat(bufs);var r=key?hmac(fn,key,buf):fn(buf);bufs=null;return enc?r.toString(enc):r}}}function error(){var m=[].slice.call(arguments).join(" ");throw new Error([m,"we accept pull requests","http://github.com/dominictarr/crypto-browserify"].join("\n"))}exports.createHash=function(alg){return hash(alg)};exports.createHmac=function(alg,key){return hash(alg,key)};exports.randomBytes=function(size,callback){if(callback&&callback.call){try{callback.call(this,undefined,new Buffer(rng(size)))}catch(err){callback(err)}}else{return new Buffer(rng(size))}};function each(a,f){for(var i in a)f(a[i],i)}each(["createCredentials","createCipher","createCipheriv","createDecipher","createDecipheriv","createSign","createVerify","createDiffieHellman","pbkdf2"],function(name){exports[name]=function(){error("sorry,",name,"is not implemented yet")}})},{"./md5":10,"./rng":11,"./sha":12,"./sha256":13,buffer:5}],10:[function(_dereq_,module,exports){var helpers=_dereq_("./helpers");function md5_vm_test(){return hex_md5("abc")=="900150983cd24fb0d6963f7d28e17f72"}function core_md5(x,len){x[len>>5]|=128<<len%32;x[(len+64>>>9<<4)+14]=len;var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;a=md5_ff(a,b,c,d,x[i+0],7,-680876936);d=md5_ff(d,a,b,c,x[i+1],12,-389564586);c=md5_ff(c,d,a,b,x[i+2],17,606105819);b=md5_ff(b,c,d,a,x[i+3],22,-1044525330);a=md5_ff(a,b,c,d,x[i+4],7,-176418897);d=md5_ff(d,a,b,c,x[i+5],12,1200080426);c=md5_ff(c,d,a,b,x[i+6],17,-1473231341);b=md5_ff(b,c,d,a,x[i+7],22,-45705983);a=md5_ff(a,b,c,d,x[i+8],7,1770035416);d=md5_ff(d,a,b,c,x[i+9],12,-1958414417);c=md5_ff(c,d,a,b,x[i+10],17,-42063);b=md5_ff(b,c,d,a,x[i+11],22,-1990404162);a=md5_ff(a,b,c,d,x[i+12],7,1804603682);d=md5_ff(d,a,b,c,x[i+13],12,-40341101);c=md5_ff(c,d,a,b,x[i+14],17,-1502002290);b=md5_ff(b,c,d,a,x[i+15],22,1236535329);a=md5_gg(a,b,c,d,x[i+1],5,-165796510);d=md5_gg(d,a,b,c,x[i+6],9,-1069501632);c=md5_gg(c,d,a,b,x[i+11],14,643717713);b=md5_gg(b,c,d,a,x[i+0],20,-373897302);a=md5_gg(a,b,c,d,x[i+5],5,-701558691);d=md5_gg(d,a,b,c,x[i+10],9,38016083);c=md5_gg(c,d,a,b,x[i+15],14,-660478335);b=md5_gg(b,c,d,a,x[i+4],20,-405537848);a=md5_gg(a,b,c,d,x[i+9],5,568446438);d=md5_gg(d,a,b,c,x[i+14],9,-1019803690);c=md5_gg(c,d,a,b,x[i+3],14,-187363961);b=md5_gg(b,c,d,a,x[i+8],20,1163531501);a=md5_gg(a,b,c,d,x[i+13],5,-1444681467);d=md5_gg(d,a,b,c,x[i+2],9,-51403784);c=md5_gg(c,d,a,b,x[i+7],14,1735328473);b=md5_gg(b,c,d,a,x[i+12],20,-1926607734);a=md5_hh(a,b,c,d,x[i+5],4,-378558);d=md5_hh(d,a,b,c,x[i+8],11,-2022574463);c=md5_hh(c,d,a,b,x[i+11],16,1839030562);b=md5_hh(b,c,d,a,x[i+14],23,-35309556);a=md5_hh(a,b,c,d,x[i+1],4,-1530992060);d=md5_hh(d,a,b,c,x[i+4],11,1272893353);c=md5_hh(c,d,a,b,x[i+7],16,-155497632);b=md5_hh(b,c,d,a,x[i+10],23,-1094730640);a=md5_hh(a,b,c,d,x[i+13],4,681279174);d=md5_hh(d,a,b,c,x[i+0],11,-358537222);c=md5_hh(c,d,a,b,x[i+3],16,-722521979);b=md5_hh(b,c,d,a,x[i+6],23,76029189);a=md5_hh(a,b,c,d,x[i+9],4,-640364487);d=md5_hh(d,a,b,c,x[i+12],11,-421815835);c=md5_hh(c,d,a,b,x[i+15],16,530742520);b=md5_hh(b,c,d,a,x[i+2],23,-995338651);a=md5_ii(a,b,c,d,x[i+0],6,-198630844);d=md5_ii(d,a,b,c,x[i+7],10,1126891415);c=md5_ii(c,d,a,b,x[i+14],15,-1416354905);b=md5_ii(b,c,d,a,x[i+5],21,-57434055);a=md5_ii(a,b,c,d,x[i+12],6,1700485571);d=md5_ii(d,a,b,c,x[i+3],10,-1894986606);c=md5_ii(c,d,a,b,x[i+10],15,-1051523);b=md5_ii(b,c,d,a,x[i+1],21,-2054922799);a=md5_ii(a,b,c,d,x[i+8],6,1873313359);d=md5_ii(d,a,b,c,x[i+15],10,-30611744);c=md5_ii(c,d,a,b,x[i+6],15,-1560198380);b=md5_ii(b,c,d,a,x[i+13],21,1309151649);a=md5_ii(a,b,c,d,x[i+4],6,-145523070);d=md5_ii(d,a,b,c,x[i+11],10,-1120210379);c=md5_ii(c,d,a,b,x[i+2],15,718787259);b=md5_ii(b,c,d,a,x[i+9],21,-343485551);a=safe_add(a,olda);b=safe_add(b,oldb);c=safe_add(c,oldc);d=safe_add(d,oldd)}return Array(a,b,c,d)}function md5_cmn(q,a,b,x,s,t){return safe_add(bit_rol(safe_add(safe_add(a,q),safe_add(x,t)),s),b)}function md5_ff(a,b,c,d,x,s,t){return md5_cmn(b&c|~b&d,a,b,x,s,t)}function md5_gg(a,b,c,d,x,s,t){return md5_cmn(b&d|c&~d,a,b,x,s,t)}function md5_hh(a,b,c,d,x,s,t){return md5_cmn(b^c^d,a,b,x,s,t)}function md5_ii(a,b,c,d,x,s,t){return md5_cmn(c^(b|~d),a,b,x,s,t)}function safe_add(x,y){var lsw=(x&65535)+(y&65535);var msw=(x>>16)+(y>>16)+(lsw>>16);return msw<<16|lsw&65535}function bit_rol(num,cnt){return num<<cnt|num>>>32-cnt}module.exports=function md5(buf){return helpers.hash(buf,core_md5,16)}},{"./helpers":8}],11:[function(_dereq_,module,exports){(function(){var _global=this;var mathRNG,whatwgRNG;mathRNG=function(size){var bytes=new Array(size);var r;for(var i=0,r;i<size;i++){if((i&3)==0)r=Math.random()*4294967296;bytes[i]=r>>>((i&3)<<3)&255}return bytes};if(_global.crypto&&crypto.getRandomValues){whatwgRNG=function(size){var bytes=new Uint8Array(size);crypto.getRandomValues(bytes);return bytes}}module.exports=whatwgRNG||mathRNG})()},{}],12:[function(_dereq_,module,exports){var helpers=_dereq_("./helpers");function core_sha1(x,len){x[len>>5]|=128<<24-len%32;x[(len+64>>9<<4)+15]=len;var w=Array(80);var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;var e=-1009589776;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;var olde=e;for(var j=0;j<80;j++){if(j<16)w[j]=x[i+j];else w[j]=rol(w[j-3]^w[j-8]^w[j-14]^w[j-16],1);var t=safe_add(safe_add(rol(a,5),sha1_ft(j,b,c,d)),safe_add(safe_add(e,w[j]),sha1_kt(j)));e=d;d=c;c=rol(b,30);b=a;a=t}a=safe_add(a,olda);b=safe_add(b,oldb);c=safe_add(c,oldc);d=safe_add(d,oldd);e=safe_add(e,olde)}return Array(a,b,c,d,e)}function sha1_ft(t,b,c,d){if(t<20)return b&c|~b&d;if(t<40)return b^c^d;if(t<60)return b&c|b&d|c&d;return b^c^d}function sha1_kt(t){return t<20?1518500249:t<40?1859775393:t<60?-1894007588:-899497514}function safe_add(x,y){var lsw=(x&65535)+(y&65535);var msw=(x>>16)+(y>>16)+(lsw>>16);return msw<<16|lsw&65535}function rol(num,cnt){return num<<cnt|num>>>32-cnt}module.exports=function sha1(buf){return helpers.hash(buf,core_sha1,20,true)}},{"./helpers":8}],13:[function(_dereq_,module,exports){var helpers=_dereq_("./helpers");var safe_add=function(x,y){var lsw=(x&65535)+(y&65535);var msw=(x>>16)+(y>>16)+(lsw>>16);return msw<<16|lsw&65535};var S=function(X,n){return X>>>n|X<<32-n};var R=function(X,n){return X>>>n};var Ch=function(x,y,z){return x&y^~x&z};var Maj=function(x,y,z){return x&y^x&z^y&z};var Sigma0256=function(x){return S(x,2)^S(x,13)^S(x,22)};var Sigma1256=function(x){return S(x,6)^S(x,11)^S(x,25)};var Gamma0256=function(x){return S(x,7)^S(x,18)^R(x,3)};var Gamma1256=function(x){return S(x,17)^S(x,19)^R(x,10)};var core_sha256=function(m,l){var K=new Array(1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298);var HASH=new Array(1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225);var W=new Array(64);var a,b,c,d,e,f,g,h,i,j;var T1,T2;m[l>>5]|=128<<24-l%32;m[(l+64>>9<<4)+15]=l;for(var i=0;i<m.length;i+=16){a=HASH[0];b=HASH[1];c=HASH[2];d=HASH[3];e=HASH[4];f=HASH[5];g=HASH[6];h=HASH[7];for(var j=0;j<64;j++){if(j<16){W[j]=m[j+i]}else{W[j]=safe_add(safe_add(safe_add(Gamma1256(W[j-2]),W[j-7]),Gamma0256(W[j-15])),W[j-16])}T1=safe_add(safe_add(safe_add(safe_add(h,Sigma1256(e)),Ch(e,f,g)),K[j]),W[j]);T2=safe_add(Sigma0256(a),Maj(a,b,c));h=g;g=f;f=e;e=safe_add(d,T1);d=c;c=b;b=a;a=safe_add(T1,T2)}HASH[0]=safe_add(a,HASH[0]);HASH[1]=safe_add(b,HASH[1]);HASH[2]=safe_add(c,HASH[2]);HASH[3]=safe_add(d,HASH[3]);HASH[4]=safe_add(e,HASH[4]);HASH[5]=safe_add(f,HASH[5]);HASH[6]=safe_add(g,HASH[6]);HASH[7]=safe_add(h,HASH[7])}return HASH};module.exports=function sha256(buf){return helpers.hash(buf,core_sha256,32,true)}},{"./helpers":8}],14:[function(_dereq_,module,exports){if(typeof Object.create==="function"){module.exports=function inherits(ctor,superCtor){ctor.super_=superCtor;ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:false,writable:true,configurable:true}})}}else{module.exports=function inherits(ctor,superCtor){ctor.super_=superCtor;var TempCtor=function(){};TempCtor.prototype=superCtor.prototype;ctor.prototype=new TempCtor;ctor.prototype.constructor=ctor}}},{}],15:[function(_dereq_,module,exports){var process=module.exports={};process.nextTick=function(){var canSetImmediate=typeof window!=="undefined"&&window.setImmediate;var canPost=typeof window!=="undefined"&&window.postMessage&&window.addEventListener;if(canSetImmediate){return function(f){return window.setImmediate(f)}}if(canPost){var queue=[];window.addEventListener("message",function(ev){var source=ev.source;if((source===window||source===null)&&ev.data==="process-tick"){ev.stopPropagation();if(queue.length>0){var fn=queue.shift();fn()}}},true);return function nextTick(fn){queue.push(fn);window.postMessage("process-tick","*")}}return function nextTick(fn){setTimeout(fn,0)}}();process.title="browser";process.browser=true;process.env={};process.argv=[];function noop(){}process.on=noop;process.addListener=noop;process.once=noop;process.off=noop;process.removeListener=noop;process.removeAllListeners=noop;process.emit=noop;process.binding=function(name){throw new Error("process.binding is not supported")};process.cwd=function(){return"/"};process.chdir=function(dir){throw new Error("process.chdir is not supported")}},{}],16:[function(_dereq_,module,exports){module.exports=_dereq_(2)},{}],17:[function(_dereq_,module,exports){module.exports=_dereq_(3)},{"./support/isBuffer":16,FWaASH:15,inherits:14}],18:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./evpkdf"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var BlockCipher=C_lib.BlockCipher;var C_algo=C.algo;var SBOX=[];var INV_SBOX=[];var SUB_MIX_0=[];var SUB_MIX_1=[];var SUB_MIX_2=[];var SUB_MIX_3=[];var INV_SUB_MIX_0=[];var INV_SUB_MIX_1=[];var INV_SUB_MIX_2=[];var INV_SUB_MIX_3=[];(function(){var d=[];for(var i=0;i<256;i++){if(i<128){d[i]=i<<1}else{d[i]=i<<1^283}}var x=0;var xi=0;for(var i=0;i<256;i++){var sx=xi^xi<<1^xi<<2^xi<<3^xi<<4;sx=sx>>>8^sx&255^99;SBOX[x]=sx;INV_SBOX[sx]=x;var x2=d[x];var x4=d[x2];var x8=d[x4];var t=d[sx]*257^sx*16843008;SUB_MIX_0[x]=t<<24|t>>>8;SUB_MIX_1[x]=t<<16|t>>>16;SUB_MIX_2[x]=t<<8|t>>>24;SUB_MIX_3[x]=t;var t=x8*16843009^x4*65537^x2*257^x*16843008;INV_SUB_MIX_0[sx]=t<<24|t>>>8;INV_SUB_MIX_1[sx]=t<<16|t>>>16;INV_SUB_MIX_2[sx]=t<<8|t>>>24;INV_SUB_MIX_3[sx]=t;if(!x){x=xi=1}else{x=x2^d[d[d[x8^x2]]];xi^=d[d[xi]]}}})();var RCON=[0,1,2,4,8,16,32,64,128,27,54];var AES=C_algo.AES=BlockCipher.extend({_doReset:function(){var key=this._key;var keyWords=key.words;var keySize=key.sigBytes/4;var nRounds=this._nRounds=keySize+6;var ksRows=(nRounds+1)*4;var keySchedule=this._keySchedule=[];for(var ksRow=0;ksRow<ksRows;ksRow++){if(ksRow<keySize){keySchedule[ksRow]=keyWords[ksRow]}else{var t=keySchedule[ksRow-1];if(!(ksRow%keySize)){t=t<<8|t>>>24;t=SBOX[t>>>24]<<24|SBOX[t>>>16&255]<<16|SBOX[t>>>8&255]<<8|SBOX[t&255];t^=RCON[ksRow/keySize|0]<<24}else if(keySize>6&&ksRow%keySize==4){t=SBOX[t>>>24]<<24|SBOX[t>>>16&255]<<16|SBOX[t>>>8&255]<<8|SBOX[t&255]}keySchedule[ksRow]=keySchedule[ksRow-keySize]^t}}var invKeySchedule=this._invKeySchedule=[];for(var invKsRow=0;invKsRow<ksRows;invKsRow++){var ksRow=ksRows-invKsRow;if(invKsRow%4){var t=keySchedule[ksRow]}else{var t=keySchedule[ksRow-4]}if(invKsRow<4||ksRow<=4){invKeySchedule[invKsRow]=t}else{invKeySchedule[invKsRow]=INV_SUB_MIX_0[SBOX[t>>>24]]^INV_SUB_MIX_1[SBOX[t>>>16&255]]^INV_SUB_MIX_2[SBOX[t>>>8&255]]^INV_SUB_MIX_3[SBOX[t&255]]}}},encryptBlock:function(M,offset){this._doCryptBlock(M,offset,this._keySchedule,SUB_MIX_0,SUB_MIX_1,SUB_MIX_2,SUB_MIX_3,SBOX)},decryptBlock:function(M,offset){var t=M[offset+1];M[offset+1]=M[offset+3];M[offset+3]=t;this._doCryptBlock(M,offset,this._invKeySchedule,INV_SUB_MIX_0,INV_SUB_MIX_1,INV_SUB_MIX_2,INV_SUB_MIX_3,INV_SBOX);var t=M[offset+1];M[offset+1]=M[offset+3];M[offset+3]=t},_doCryptBlock:function(M,offset,keySchedule,SUB_MIX_0,SUB_MIX_1,SUB_MIX_2,SUB_MIX_3,SBOX){var nRounds=this._nRounds;var s0=M[offset]^keySchedule[0];var s1=M[offset+1]^keySchedule[1];var s2=M[offset+2]^keySchedule[2];var s3=M[offset+3]^keySchedule[3];var ksRow=4;for(var round=1;round<nRounds;round++){var t0=SUB_MIX_0[s0>>>24]^SUB_MIX_1[s1>>>16&255]^SUB_MIX_2[s2>>>8&255]^SUB_MIX_3[s3&255]^keySchedule[ksRow++];var t1=SUB_MIX_0[s1>>>24]^SUB_MIX_1[s2>>>16&255]^SUB_MIX_2[s3>>>8&255]^SUB_MIX_3[s0&255]^keySchedule[ksRow++];var t2=SUB_MIX_0[s2>>>24]^SUB_MIX_1[s3>>>16&255]^SUB_MIX_2[s0>>>8&255]^SUB_MIX_3[s1&255]^keySchedule[ksRow++];var t3=SUB_MIX_0[s3>>>24]^SUB_MIX_1[s0>>>16&255]^SUB_MIX_2[s1>>>8&255]^SUB_MIX_3[s2&255]^keySchedule[ksRow++];s0=t0;s1=t1;s2=t2;s3=t3}var t0=(SBOX[s0>>>24]<<24|SBOX[s1>>>16&255]<<16|SBOX[s2>>>8&255]<<8|SBOX[s3&255])^keySchedule[ksRow++];var t1=(SBOX[s1>>>24]<<24|SBOX[s2>>>16&255]<<16|SBOX[s3>>>8&255]<<8|SBOX[s0&255])^keySchedule[ksRow++];var t2=(SBOX[s2>>>24]<<24|SBOX[s3>>>16&255]<<16|SBOX[s0>>>8&255]<<8|SBOX[s1&255])^keySchedule[ksRow++];var t3=(SBOX[s3>>>24]<<24|SBOX[s0>>>16&255]<<16|SBOX[s1>>>8&255]<<8|SBOX[s2&255])^keySchedule[ksRow++];M[offset]=t0;M[offset+1]=t1;M[offset+2]=t2;M[offset+3]=t3},keySize:256/32});C.AES=BlockCipher._createHelper(AES)})();return CryptoJS.AES})},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":29}],19:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.lib.Cipher||function(undefined){var C=CryptoJS;var C_lib=C.lib;var Base=C_lib.Base;var WordArray=C_lib.WordArray;var BufferedBlockAlgorithm=C_lib.BufferedBlockAlgorithm;var C_enc=C.enc;var Utf8=C_enc.Utf8;var Base64=C_enc.Base64;var C_algo=C.algo;var EvpKDF=C_algo.EvpKDF;var Cipher=C_lib.Cipher=BufferedBlockAlgorithm.extend({cfg:Base.extend(),createEncryptor:function(key,cfg){return this.create(this._ENC_XFORM_MODE,key,cfg)},createDecryptor:function(key,cfg){return this.create(this._DEC_XFORM_MODE,key,cfg)},init:function(xformMode,key,cfg){this.cfg=this.cfg.extend(cfg);this._xformMode=xformMode;this._key=key;this.reset()},reset:function(){BufferedBlockAlgorithm.reset.call(this);this._doReset()},process:function(dataUpdate){this._append(dataUpdate);return this._process()},finalize:function(dataUpdate){if(dataUpdate){this._append(dataUpdate)}var finalProcessedData=this._doFinalize();return finalProcessedData},keySize:128/32,ivSize:128/32,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(){function selectCipherStrategy(key){if(typeof key=="string"){return PasswordBasedCipher}else{return SerializableCipher}}return function(cipher){return{encrypt:function(message,key,cfg){return selectCipherStrategy(key).encrypt(cipher,message,key,cfg)},decrypt:function(ciphertext,key,cfg){return selectCipherStrategy(key).decrypt(cipher,ciphertext,key,cfg)}}}}()});var StreamCipher=C_lib.StreamCipher=Cipher.extend({_doFinalize:function(){var finalProcessedBlocks=this._process(!!"flush");return finalProcessedBlocks},blockSize:1});var C_mode=C.mode={};var BlockCipherMode=C_lib.BlockCipherMode=Base.extend({createEncryptor:function(cipher,iv){return this.Encryptor.create(cipher,iv)},createDecryptor:function(cipher,iv){return this.Decryptor.create(cipher,iv)},init:function(cipher,iv){this._cipher=cipher;this._iv=iv}});var CBC=C_mode.CBC=function(){var CBC=BlockCipherMode.extend();CBC.Encryptor=CBC.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;xorBlock.call(this,words,offset,blockSize);cipher.encryptBlock(words,offset);this._prevBlock=words.slice(offset,offset+blockSize)}});CBC.Decryptor=CBC.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;var thisBlock=words.slice(offset,offset+blockSize);cipher.decryptBlock(words,offset);xorBlock.call(this,words,offset,blockSize);this._prevBlock=thisBlock}});function xorBlock(words,offset,blockSize){var iv=this._iv;if(iv){var block=iv;this._iv=undefined}else{var block=this._prevBlock}for(var i=0;i<blockSize;i++){words[offset+i]^=block[i]}}return CBC}();var C_pad=C.pad={};var Pkcs7=C_pad.Pkcs7={pad:function(data,blockSize){var blockSizeBytes=blockSize*4;var nPaddingBytes=blockSizeBytes-data.sigBytes%blockSizeBytes;var paddingWord=nPaddingBytes<<24|nPaddingBytes<<16|nPaddingBytes<<8|nPaddingBytes;var paddingWords=[];for(var i=0;i<nPaddingBytes;i+=4){paddingWords.push(paddingWord)}var padding=WordArray.create(paddingWords,nPaddingBytes);data.concat(padding)},unpad:function(data){var nPaddingBytes=data.words[data.sigBytes-1>>>2]&255;data.sigBytes-=nPaddingBytes}};var BlockCipher=C_lib.BlockCipher=Cipher.extend({cfg:Cipher.cfg.extend({mode:CBC,padding:Pkcs7}),reset:function(){Cipher.reset.call(this);var cfg=this.cfg;var iv=cfg.iv;var mode=cfg.mode;if(this._xformMode==this._ENC_XFORM_MODE){var modeCreator=mode.createEncryptor}else{var modeCreator=mode.createDecryptor;this._minBufferSize=1}this._mode=modeCreator.call(mode,this,iv&&iv.words)},_doProcessBlock:function(words,offset){this._mode.processBlock(words,offset)},_doFinalize:function(){var padding=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){padding.pad(this._data,this.blockSize);var finalProcessedBlocks=this._process(!!"flush")}else{var finalProcessedBlocks=this._process(!!"flush");padding.unpad(finalProcessedBlocks)}return finalProcessedBlocks},blockSize:128/32});var CipherParams=C_lib.CipherParams=Base.extend({init:function(cipherParams){this.mixIn(cipherParams)},toString:function(formatter){return(formatter||this.formatter).stringify(this)}});var C_format=C.format={};var OpenSSLFormatter=C_format.OpenSSL={stringify:function(cipherParams){var ciphertext=cipherParams.ciphertext;var salt=cipherParams.salt;if(salt){var wordArray=WordArray.create([1398893684,1701076831]).concat(salt).concat(ciphertext)}else{var wordArray=ciphertext}return wordArray.toString(Base64)},parse:function(openSSLStr){var ciphertext=Base64.parse(openSSLStr);var ciphertextWords=ciphertext.words;if(ciphertextWords[0]==1398893684&&ciphertextWords[1]==1701076831){var salt=WordArray.create(ciphertextWords.slice(2,4));ciphertextWords.splice(0,4);ciphertext.sigBytes-=16}return CipherParams.create({ciphertext:ciphertext,salt:salt})}};var SerializableCipher=C_lib.SerializableCipher=Base.extend({cfg:Base.extend({format:OpenSSLFormatter}),encrypt:function(cipher,message,key,cfg){cfg=this.cfg.extend(cfg);var encryptor=cipher.createEncryptor(key,cfg);var ciphertext=encryptor.finalize(message);var cipherCfg=encryptor.cfg;return CipherParams.create({ciphertext:ciphertext,key:key,iv:cipherCfg.iv,algorithm:cipher,mode:cipherCfg.mode,padding:cipherCfg.padding,blockSize:cipher.blockSize,formatter:cfg.format})},decrypt:function(cipher,ciphertext,key,cfg){cfg=this.cfg.extend(cfg);ciphertext=this._parse(ciphertext,cfg.format);var plaintext=cipher.createDecryptor(key,cfg).finalize(ciphertext.ciphertext);return plaintext},_parse:function(ciphertext,format){if(typeof ciphertext=="string"){return format.parse(ciphertext,this)}else{return ciphertext}}});var C_kdf=C.kdf={};var OpenSSLKdf=C_kdf.OpenSSL={execute:function(password,keySize,ivSize,salt){if(!salt){salt=WordArray.random(64/8)}var key=EvpKDF.create({keySize:keySize+ivSize}).compute(password,salt);var iv=WordArray.create(key.words.slice(keySize),ivSize*4);key.sigBytes=keySize*4;return CipherParams.create({key:key,iv:iv,salt:salt})}};var PasswordBasedCipher=C_lib.PasswordBasedCipher=SerializableCipher.extend({cfg:SerializableCipher.cfg.extend({kdf:OpenSSLKdf}),encrypt:function(cipher,message,password,cfg){cfg=this.cfg.extend(cfg);var derivedParams=cfg.kdf.execute(password,cipher.keySize,cipher.ivSize);cfg.iv=derivedParams.iv;var ciphertext=SerializableCipher.encrypt.call(this,cipher,message,derivedParams.key,cfg);
ciphertext.mixIn(derivedParams);return ciphertext},decrypt:function(cipher,ciphertext,password,cfg){cfg=this.cfg.extend(cfg);ciphertext=this._parse(ciphertext,cfg.format);var derivedParams=cfg.kdf.execute(password,cipher.keySize,cipher.ivSize,ciphertext.salt);cfg.iv=derivedParams.iv;var plaintext=SerializableCipher.decrypt.call(this,cipher,ciphertext,derivedParams.key,cfg);return plaintext}})}()})},{"./core":20}],20:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory()}else if(typeof define==="function"&&define.amd){define([],factory)}else{root.CryptoJS=factory()}})(this,function(){var CryptoJS=CryptoJS||function(Math,undefined){var C={};var C_lib=C.lib={};var Base=C_lib.Base=function(){function F(){}return{extend:function(overrides){F.prototype=this;var subtype=new F;if(overrides){subtype.mixIn(overrides)}if(!subtype.hasOwnProperty("init")){subtype.init=function(){subtype.$super.init.apply(this,arguments)}}subtype.init.prototype=subtype;subtype.$super=this;return subtype},create:function(){var instance=this.extend();instance.init.apply(instance,arguments);return instance},init:function(){},mixIn:function(properties){for(var propertyName in properties){if(properties.hasOwnProperty(propertyName)){this[propertyName]=properties[propertyName]}}if(properties.hasOwnProperty("toString")){this.toString=properties.toString}},clone:function(){return this.init.prototype.extend(this)}}}();var WordArray=C_lib.WordArray=Base.extend({init:function(words,sigBytes){words=this.words=words||[];if(sigBytes!=undefined){this.sigBytes=sigBytes}else{this.sigBytes=words.length*4}},toString:function(encoder){return(encoder||Hex).stringify(this)},concat:function(wordArray){var thisWords=this.words;var thatWords=wordArray.words;var thisSigBytes=this.sigBytes;var thatSigBytes=wordArray.sigBytes;this.clamp();if(thisSigBytes%4){for(var i=0;i<thatSigBytes;i++){var thatByte=thatWords[i>>>2]>>>24-i%4*8&255;thisWords[thisSigBytes+i>>>2]|=thatByte<<24-(thisSigBytes+i)%4*8}}else if(thatWords.length>256){for(var i=0;i<thatSigBytes;i+=4){thisWords[thisSigBytes+i>>>2]=thatWords[i>>>2]}}else{thisWords.push.apply(thisWords,thatWords)}this.sigBytes+=thatSigBytes;return this},clamp:function(){var words=this.words;var sigBytes=this.sigBytes;words[sigBytes>>>2]&=4294967295<<32-sigBytes%4*8;words.length=Math.ceil(sigBytes/4)},clone:function(){var clone=Base.clone.call(this);clone.words=this.words.slice(0);return clone},random:function(nBytes){var words=[];for(var i=0;i<nBytes;i+=4){words.push(Math.random()*4294967296|0)}return new WordArray.init(words,nBytes)}});var C_enc=C.enc={};var Hex=C_enc.Hex={stringify:function(wordArray){var words=wordArray.words;var sigBytes=wordArray.sigBytes;var hexChars=[];for(var i=0;i<sigBytes;i++){var bite=words[i>>>2]>>>24-i%4*8&255;hexChars.push((bite>>>4).toString(16));hexChars.push((bite&15).toString(16))}return hexChars.join("")},parse:function(hexStr){var hexStrLength=hexStr.length;var words=[];for(var i=0;i<hexStrLength;i+=2){words[i>>>3]|=parseInt(hexStr.substr(i,2),16)<<24-i%8*4}return new WordArray.init(words,hexStrLength/2)}};var Latin1=C_enc.Latin1={stringify:function(wordArray){var words=wordArray.words;var sigBytes=wordArray.sigBytes;var latin1Chars=[];for(var i=0;i<sigBytes;i++){var bite=words[i>>>2]>>>24-i%4*8&255;latin1Chars.push(String.fromCharCode(bite))}return latin1Chars.join("")},parse:function(latin1Str){var latin1StrLength=latin1Str.length;var words=[];for(var i=0;i<latin1StrLength;i++){words[i>>>2]|=(latin1Str.charCodeAt(i)&255)<<24-i%4*8}return new WordArray.init(words,latin1StrLength)}};var Utf8=C_enc.Utf8={stringify:function(wordArray){try{return decodeURIComponent(escape(Latin1.stringify(wordArray)))}catch(e){throw new Error("Malformed UTF-8 data")}},parse:function(utf8Str){return Latin1.parse(unescape(encodeURIComponent(utf8Str)))}};var BufferedBlockAlgorithm=C_lib.BufferedBlockAlgorithm=Base.extend({reset:function(){this._data=new WordArray.init;this._nDataBytes=0},_append:function(data){if(typeof data=="string"){data=Utf8.parse(data)}this._data.concat(data);this._nDataBytes+=data.sigBytes},_process:function(doFlush){var data=this._data;var dataWords=data.words;var dataSigBytes=data.sigBytes;var blockSize=this.blockSize;var blockSizeBytes=blockSize*4;var nBlocksReady=dataSigBytes/blockSizeBytes;if(doFlush){nBlocksReady=Math.ceil(nBlocksReady)}else{nBlocksReady=Math.max((nBlocksReady|0)-this._minBufferSize,0)}var nWordsReady=nBlocksReady*blockSize;var nBytesReady=Math.min(nWordsReady*4,dataSigBytes);if(nWordsReady){for(var offset=0;offset<nWordsReady;offset+=blockSize){this._doProcessBlock(dataWords,offset)}var processedWords=dataWords.splice(0,nWordsReady);data.sigBytes-=nBytesReady}return new WordArray.init(processedWords,nBytesReady)},clone:function(){var clone=Base.clone.call(this);clone._data=this._data.clone();return clone},_minBufferSize:0});var Hasher=C_lib.Hasher=BufferedBlockAlgorithm.extend({cfg:Base.extend(),init:function(cfg){this.cfg=this.cfg.extend(cfg);this.reset()},reset:function(){BufferedBlockAlgorithm.reset.call(this);this._doReset()},update:function(messageUpdate){this._append(messageUpdate);this._process();return this},finalize:function(messageUpdate){if(messageUpdate){this._append(messageUpdate)}var hash=this._doFinalize();return hash},blockSize:512/32,_createHelper:function(hasher){return function(message,cfg){return new hasher.init(cfg).finalize(message)}},_createHmacHelper:function(hasher){return function(message,key){return new C_algo.HMAC.init(hasher,key).finalize(message)}}});var C_algo=C.algo={};return C}(Math);return CryptoJS})},{}],21:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var C_enc=C.enc;var Base64=C_enc.Base64={stringify:function(wordArray){var words=wordArray.words;var sigBytes=wordArray.sigBytes;var map=this._map;wordArray.clamp();var base64Chars=[];for(var i=0;i<sigBytes;i+=3){var byte1=words[i>>>2]>>>24-i%4*8&255;var byte2=words[i+1>>>2]>>>24-(i+1)%4*8&255;var byte3=words[i+2>>>2]>>>24-(i+2)%4*8&255;var triplet=byte1<<16|byte2<<8|byte3;for(var j=0;j<4&&i+j*.75<sigBytes;j++){base64Chars.push(map.charAt(triplet>>>6*(3-j)&63))}}var paddingChar=map.charAt(64);if(paddingChar){while(base64Chars.length%4){base64Chars.push(paddingChar)}}return base64Chars.join("")},parse:function(base64Str){var base64StrLength=base64Str.length;var map=this._map;var paddingChar=map.charAt(64);if(paddingChar){var paddingIndex=base64Str.indexOf(paddingChar);if(paddingIndex!=-1){base64StrLength=paddingIndex}}var words=[];var nBytes=0;for(var i=0;i<base64StrLength;i++){if(i%4){var bits1=map.indexOf(base64Str.charAt(i-1))<<i%4*2;var bits2=map.indexOf(base64Str.charAt(i))>>>6-i%4*2;words[nBytes>>>2]|=(bits1|bits2)<<24-nBytes%4*8;nBytes++}}return WordArray.create(words,nBytes)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();return CryptoJS.enc.Base64})},{"./core":20}],22:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var C_enc=C.enc;var Utf16BE=C_enc.Utf16=C_enc.Utf16BE={stringify:function(wordArray){var words=wordArray.words;var sigBytes=wordArray.sigBytes;var utf16Chars=[];for(var i=0;i<sigBytes;i+=2){var codePoint=words[i>>>2]>>>16-i%4*8&65535;utf16Chars.push(String.fromCharCode(codePoint))}return utf16Chars.join("")},parse:function(utf16Str){var utf16StrLength=utf16Str.length;var words=[];for(var i=0;i<utf16StrLength;i++){words[i>>>1]|=utf16Str.charCodeAt(i)<<16-i%2*16}return WordArray.create(words,utf16StrLength*2)}};C_enc.Utf16LE={stringify:function(wordArray){var words=wordArray.words;var sigBytes=wordArray.sigBytes;var utf16Chars=[];for(var i=0;i<sigBytes;i+=2){var codePoint=swapEndian(words[i>>>2]>>>16-i%4*8&65535);utf16Chars.push(String.fromCharCode(codePoint))}return utf16Chars.join("")},parse:function(utf16Str){var utf16StrLength=utf16Str.length;var words=[];for(var i=0;i<utf16StrLength;i++){words[i>>>1]|=swapEndian(utf16Str.charCodeAt(i)<<16-i%2*16)}return WordArray.create(words,utf16StrLength*2)}};function swapEndian(word){return word<<8&4278255360|word>>>8&16711935}})();return CryptoJS.enc.Utf16})},{"./core":20}],23:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./sha1"),_dereq_("./hmac"))}else if(typeof define==="function"&&define.amd){define(["./core","./sha1","./hmac"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var Base=C_lib.Base;var WordArray=C_lib.WordArray;var C_algo=C.algo;var MD5=C_algo.MD5;var EvpKDF=C_algo.EvpKDF=Base.extend({cfg:Base.extend({keySize:128/32,hasher:MD5,iterations:1}),init:function(cfg){this.cfg=this.cfg.extend(cfg)},compute:function(password,salt){var cfg=this.cfg;var hasher=cfg.hasher.create();var derivedKey=WordArray.create();var derivedKeyWords=derivedKey.words;var keySize=cfg.keySize;var iterations=cfg.iterations;while(derivedKeyWords.length<keySize){if(block){hasher.update(block)}var block=hasher.update(password).finalize(salt);hasher.reset();for(var i=1;i<iterations;i++){block=hasher.finalize(block);hasher.reset()}derivedKey.concat(block)}derivedKey.sigBytes=keySize*4;return derivedKey}});C.EvpKDF=function(password,salt,cfg){return EvpKDF.create(cfg).compute(password,salt)}})();return CryptoJS.EvpKDF})},{"./core":20,"./hmac":26,"./sha1":45}],24:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(undefined){var C=CryptoJS;var C_lib=C.lib;var CipherParams=C_lib.CipherParams;var C_enc=C.enc;var Hex=C_enc.Hex;var C_format=C.format;var HexFormatter=C_format.Hex={stringify:function(cipherParams){return cipherParams.ciphertext.toString(Hex)},parse:function(input){var ciphertext=Hex.parse(input);return CipherParams.create({ciphertext:ciphertext})}}})();return CryptoJS.format.Hex})},{"./cipher-core":19,"./core":20}],25:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./sha256"),_dereq_("./hmac"))}else if(typeof define==="function"&&define.amd){define(["./core","./sha256","./hmac"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){return CryptoJS.HmacSHA256})},{"./core":20,"./hmac":26,"./sha256":47}],26:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var Base=C_lib.Base;var C_enc=C.enc;var Utf8=C_enc.Utf8;var C_algo=C.algo;var HMAC=C_algo.HMAC=Base.extend({init:function(hasher,key){hasher=this._hasher=new hasher.init;if(typeof key=="string"){key=Utf8.parse(key)}var hasherBlockSize=hasher.blockSize;var hasherBlockSizeBytes=hasherBlockSize*4;if(key.sigBytes>hasherBlockSizeBytes){key=hasher.finalize(key)}key.clamp();var oKey=this._oKey=key.clone();var iKey=this._iKey=key.clone();var oKeyWords=oKey.words;var iKeyWords=iKey.words;for(var i=0;i<hasherBlockSize;i++){oKeyWords[i]^=1549556828;iKeyWords[i]^=909522486}oKey.sigBytes=iKey.sigBytes=hasherBlockSizeBytes;this.reset()},reset:function(){var hasher=this._hasher;hasher.reset();hasher.update(this._iKey)},update:function(messageUpdate){this._hasher.update(messageUpdate);return this},finalize:function(messageUpdate){var hasher=this._hasher;var innerHash=hasher.finalize(messageUpdate);hasher.reset();var hmac=hasher.finalize(this._oKey.clone().concat(innerHash));return hmac}})})()})},{"./core":20}],27:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./x64-core"),_dereq_("./lib-typedarrays"),_dereq_("./enc-utf16"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./sha1"),_dereq_("./sha256"),_dereq_("./sha224"),_dereq_("./sha512"),_dereq_("./sha384"),_dereq_("./sha3"),_dereq_("./ripemd160"),_dereq_("./hmac"),_dereq_("./pbkdf2"),_dereq_("./evpkdf"),_dereq_("./cipher-core"),_dereq_("./mode-cfb"),_dereq_("./mode-ctr"),_dereq_("./mode-ctr-gladman"),_dereq_("./mode-ofb"),_dereq_("./mode-ecb"),_dereq_("./pad-ansix923"),_dereq_("./pad-iso10126"),_dereq_("./pad-iso97971"),_dereq_("./pad-zeropadding"),_dereq_("./pad-nopadding"),_dereq_("./format-hex"),_dereq_("./aes"),_dereq_("./tripledes"),_dereq_("./rc4"),_dereq_("./rabbit"),_dereq_("./rabbit-legacy"))}else if(typeof define==="function"&&define.amd){define(["./core","./x64-core","./lib-typedarrays","./enc-utf16","./enc-base64","./md5","./sha1","./sha256","./sha224","./sha512","./sha384","./sha3","./ripemd160","./hmac","./pbkdf2","./evpkdf","./cipher-core","./mode-cfb","./mode-ctr","./mode-ctr-gladman","./mode-ofb","./mode-ecb","./pad-ansix923","./pad-iso10126","./pad-iso97971","./pad-zeropadding","./pad-nopadding","./format-hex","./aes","./tripledes","./rc4","./rabbit","./rabbit-legacy"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){return CryptoJS})},{"./aes":18,"./cipher-core":19,"./core":20,"./enc-base64":21,"./enc-utf16":22,"./evpkdf":23,"./format-hex":24,"./hmac":26,"./lib-typedarrays":28,"./md5":29,"./mode-cfb":30,"./mode-ctr":32,"./mode-ctr-gladman":31,"./mode-ecb":33,"./mode-ofb":34,"./pad-ansix923":35,"./pad-iso10126":36,"./pad-iso97971":37,"./pad-nopadding":38,"./pad-zeropadding":39,"./pbkdf2":40,"./rabbit":42,"./rabbit-legacy":41,"./rc4":43,"./ripemd160":44,"./sha1":45,"./sha224":46,"./sha256":47,"./sha3":48,"./sha384":49,"./sha512":50,"./tripledes":51,"./x64-core":52}],28:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){if(typeof ArrayBuffer!="function"){return}var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var superInit=WordArray.init;var subInit=WordArray.init=function(typedArray){if(typedArray instanceof ArrayBuffer){typedArray=new Uint8Array(typedArray)}if(typedArray instanceof Int8Array||typedArray instanceof Uint8ClampedArray||typedArray instanceof Int16Array||typedArray instanceof Uint16Array||typedArray instanceof Int32Array||typedArray instanceof Uint32Array||typedArray instanceof Float32Array||typedArray instanceof Float64Array){typedArray=new Uint8Array(typedArray.buffer,typedArray.byteOffset,typedArray.byteLength)}if(typedArray instanceof Uint8Array){var typedArrayByteLength=typedArray.byteLength;var words=[];for(var i=0;i<typedArrayByteLength;i++){words[i>>>2]|=typedArray[i]<<24-i%4*8}superInit.call(this,words,typedArrayByteLength)}else{superInit.apply(this,arguments)}};subInit.prototype=WordArray})();return CryptoJS.lib.WordArray})},{"./core":20}],29:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(Math){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var Hasher=C_lib.Hasher;var C_algo=C.algo;var T=[];(function(){for(var i=0;i<64;i++){T[i]=Math.abs(Math.sin(i+1))*4294967296|0}})();var MD5=C_algo.MD5=Hasher.extend({_doReset:function(){this._hash=new WordArray.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(M,offset){for(var i=0;i<16;i++){var offset_i=offset+i;var M_offset_i=M[offset_i];M[offset_i]=(M_offset_i<<8|M_offset_i>>>24)&16711935|(M_offset_i<<24|M_offset_i>>>8)&4278255360}var H=this._hash.words;var M_offset_0=M[offset+0];var M_offset_1=M[offset+1];var M_offset_2=M[offset+2];var M_offset_3=M[offset+3];var M_offset_4=M[offset+4];var M_offset_5=M[offset+5];var M_offset_6=M[offset+6];var M_offset_7=M[offset+7];var M_offset_8=M[offset+8];var M_offset_9=M[offset+9];var M_offset_10=M[offset+10];var M_offset_11=M[offset+11];var M_offset_12=M[offset+12];var M_offset_13=M[offset+13];var M_offset_14=M[offset+14];var M_offset_15=M[offset+15];var a=H[0];var b=H[1];var c=H[2];var d=H[3];a=FF(a,b,c,d,M_offset_0,7,T[0]);d=FF(d,a,b,c,M_offset_1,12,T[1]);c=FF(c,d,a,b,M_offset_2,17,T[2]);b=FF(b,c,d,a,M_offset_3,22,T[3]);a=FF(a,b,c,d,M_offset_4,7,T[4]);d=FF(d,a,b,c,M_offset_5,12,T[5]);c=FF(c,d,a,b,M_offset_6,17,T[6]);b=FF(b,c,d,a,M_offset_7,22,T[7]);a=FF(a,b,c,d,M_offset_8,7,T[8]);d=FF(d,a,b,c,M_offset_9,12,T[9]);c=FF(c,d,a,b,M_offset_10,17,T[10]);b=FF(b,c,d,a,M_offset_11,22,T[11]);a=FF(a,b,c,d,M_offset_12,7,T[12]);d=FF(d,a,b,c,M_offset_13,12,T[13]);c=FF(c,d,a,b,M_offset_14,17,T[14]);b=FF(b,c,d,a,M_offset_15,22,T[15]);a=GG(a,b,c,d,M_offset_1,5,T[16]);d=GG(d,a,b,c,M_offset_6,9,T[17]);c=GG(c,d,a,b,M_offset_11,14,T[18]);b=GG(b,c,d,a,M_offset_0,20,T[19]);a=GG(a,b,c,d,M_offset_5,5,T[20]);d=GG(d,a,b,c,M_offset_10,9,T[21]);c=GG(c,d,a,b,M_offset_15,14,T[22]);b=GG(b,c,d,a,M_offset_4,20,T[23]);a=GG(a,b,c,d,M_offset_9,5,T[24]);d=GG(d,a,b,c,M_offset_14,9,T[25]);c=GG(c,d,a,b,M_offset_3,14,T[26]);b=GG(b,c,d,a,M_offset_8,20,T[27]);a=GG(a,b,c,d,M_offset_13,5,T[28]);d=GG(d,a,b,c,M_offset_2,9,T[29]);c=GG(c,d,a,b,M_offset_7,14,T[30]);b=GG(b,c,d,a,M_offset_12,20,T[31]);a=HH(a,b,c,d,M_offset_5,4,T[32]);d=HH(d,a,b,c,M_offset_8,11,T[33]);c=HH(c,d,a,b,M_offset_11,16,T[34]);b=HH(b,c,d,a,M_offset_14,23,T[35]);a=HH(a,b,c,d,M_offset_1,4,T[36]);d=HH(d,a,b,c,M_offset_4,11,T[37]);c=HH(c,d,a,b,M_offset_7,16,T[38]);b=HH(b,c,d,a,M_offset_10,23,T[39]);a=HH(a,b,c,d,M_offset_13,4,T[40]);d=HH(d,a,b,c,M_offset_0,11,T[41]);c=HH(c,d,a,b,M_offset_3,16,T[42]);b=HH(b,c,d,a,M_offset_6,23,T[43]);a=HH(a,b,c,d,M_offset_9,4,T[44]);d=HH(d,a,b,c,M_offset_12,11,T[45]);c=HH(c,d,a,b,M_offset_15,16,T[46]);b=HH(b,c,d,a,M_offset_2,23,T[47]);a=II(a,b,c,d,M_offset_0,6,T[48]);d=II(d,a,b,c,M_offset_7,10,T[49]);c=II(c,d,a,b,M_offset_14,15,T[50]);b=II(b,c,d,a,M_offset_5,21,T[51]);a=II(a,b,c,d,M_offset_12,6,T[52]);d=II(d,a,b,c,M_offset_3,10,T[53]);c=II(c,d,a,b,M_offset_10,15,T[54]);b=II(b,c,d,a,M_offset_1,21,T[55]);a=II(a,b,c,d,M_offset_8,6,T[56]);d=II(d,a,b,c,M_offset_15,10,T[57]);c=II(c,d,a,b,M_offset_6,15,T[58]);b=II(b,c,d,a,M_offset_13,21,T[59]);a=II(a,b,c,d,M_offset_4,6,T[60]);d=II(d,a,b,c,M_offset_11,10,T[61]);c=II(c,d,a,b,M_offset_2,15,T[62]);b=II(b,c,d,a,M_offset_9,21,T[63]);H[0]=H[0]+a|0;H[1]=H[1]+b|0;H[2]=H[2]+c|0;H[3]=H[3]+d|0},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;var nBitsTotalH=Math.floor(nBitsTotal/4294967296);var nBitsTotalL=nBitsTotal;dataWords[(nBitsLeft+64>>>9<<4)+15]=(nBitsTotalH<<8|nBitsTotalH>>>24)&16711935|(nBitsTotalH<<24|nBitsTotalH>>>8)&4278255360;dataWords[(nBitsLeft+64>>>9<<4)+14]=(nBitsTotalL<<8|nBitsTotalL>>>24)&16711935|(nBitsTotalL<<24|nBitsTotalL>>>8)&4278255360;data.sigBytes=(dataWords.length+1)*4;this._process();var hash=this._hash;var H=hash.words;for(var i=0;i<4;i++){var H_i=H[i];H[i]=(H_i<<8|H_i>>>24)&16711935|(H_i<<24|H_i>>>8)&4278255360}return hash},clone:function(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone}});function FF(a,b,c,d,x,s,t){var n=a+(b&c|~b&d)+x+t;return(n<<s|n>>>32-s)+b}function GG(a,b,c,d,x,s,t){var n=a+(b&d|c&~d)+x+t;return(n<<s|n>>>32-s)+b}function HH(a,b,c,d,x,s,t){var n=a+(b^c^d)+x+t;return(n<<s|n>>>32-s)+b}function II(a,b,c,d,x,s,t){var n=a+(c^(b|~d))+x+t;return(n<<s|n>>>32-s)+b}C.MD5=Hasher._createHelper(MD5);C.HmacMD5=Hasher._createHmacHelper(MD5)})(Math);return CryptoJS.MD5})},{"./core":20}],30:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.mode.CFB=function(){var CFB=CryptoJS.lib.BlockCipherMode.extend();CFB.Encryptor=CFB.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;generateKeystreamAndEncrypt.call(this,words,offset,blockSize,cipher);this._prevBlock=words.slice(offset,offset+blockSize)}});CFB.Decryptor=CFB.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;var thisBlock=words.slice(offset,offset+blockSize);generateKeystreamAndEncrypt.call(this,words,offset,blockSize,cipher);this._prevBlock=thisBlock}});function generateKeystreamAndEncrypt(words,offset,blockSize,cipher){var iv=this._iv;if(iv){var keystream=iv.slice(0);this._iv=undefined}else{var keystream=this._prevBlock}cipher.encryptBlock(keystream,0);for(var i=0;i<blockSize;i++){words[offset+i]^=keystream[i]}}return CFB}();return CryptoJS.mode.CFB})},{"./cipher-core":19,"./core":20}],31:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.mode.CTRGladman=function(){var CTRGladman=CryptoJS.lib.BlockCipherMode.extend();function incWord(word){if((word>>24&255)===255){var b1=word>>16&255;var b2=word>>8&255;var b3=word&255;if(b1===255){b1=0;if(b2===255){b2=0;if(b3===255){b3=0}else{++b3}}else{++b2}}else{++b1}word=0;word+=b1<<16;word+=b2<<8;word+=b3}else{word+=1<<24}return word}function incCounter(counter){if((counter[0]=incWord(counter[0]))===0){counter[1]=incWord(counter[1])}return counter}var Encryptor=CTRGladman.Encryptor=CTRGladman.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;var iv=this._iv;var counter=this._counter;if(iv){counter=this._counter=iv.slice(0);this._iv=undefined}incCounter(counter);var keystream=counter.slice(0);cipher.encryptBlock(keystream,0);for(var i=0;i<blockSize;i++){words[offset+i]^=keystream[i]}}});CTRGladman.Decryptor=Encryptor;return CTRGladman}();return CryptoJS.mode.CTRGladman})},{"./cipher-core":19,"./core":20}],32:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.mode.CTR=function(){var CTR=CryptoJS.lib.BlockCipherMode.extend();var Encryptor=CTR.Encryptor=CTR.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;var iv=this._iv;var counter=this._counter;if(iv){counter=this._counter=iv.slice(0);this._iv=undefined}var keystream=counter.slice(0);cipher.encryptBlock(keystream,0);counter[blockSize-1]=counter[blockSize-1]+1|0;for(var i=0;i<blockSize;i++){words[offset+i]^=keystream[i]}}});CTR.Decryptor=Encryptor;return CTR}();return CryptoJS.mode.CTR})},{"./cipher-core":19,"./core":20}],33:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.mode.ECB=function(){var ECB=CryptoJS.lib.BlockCipherMode.extend();ECB.Encryptor=ECB.extend({processBlock:function(words,offset){this._cipher.encryptBlock(words,offset)}});ECB.Decryptor=ECB.extend({processBlock:function(words,offset){this._cipher.decryptBlock(words,offset)}});return ECB}();return CryptoJS.mode.ECB})},{"./cipher-core":19,"./core":20}],34:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.mode.OFB=function(){var OFB=CryptoJS.lib.BlockCipherMode.extend();var Encryptor=OFB.Encryptor=OFB.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;var iv=this._iv;var keystream=this._keystream;if(iv){keystream=this._keystream=iv.slice(0);this._iv=undefined}cipher.encryptBlock(keystream,0);for(var i=0;i<blockSize;i++){words[offset+i]^=keystream[i]}}});OFB.Decryptor=Encryptor;return OFB}();return CryptoJS.mode.OFB})},{"./cipher-core":19,"./core":20}],35:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.pad.AnsiX923={pad:function(data,blockSize){var dataSigBytes=data.sigBytes;var blockSizeBytes=blockSize*4;var nPaddingBytes=blockSizeBytes-dataSigBytes%blockSizeBytes;var lastBytePos=dataSigBytes+nPaddingBytes-1;data.clamp();data.words[lastBytePos>>>2]|=nPaddingBytes<<24-lastBytePos%4*8;data.sigBytes+=nPaddingBytes},unpad:function(data){var nPaddingBytes=data.words[data.sigBytes-1>>>2]&255;data.sigBytes-=nPaddingBytes}};return CryptoJS.pad.Ansix923})},{"./cipher-core":19,"./core":20}],36:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.pad.Iso10126={pad:function(data,blockSize){var blockSizeBytes=blockSize*4;var nPaddingBytes=blockSizeBytes-data.sigBytes%blockSizeBytes;data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes-1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes<<24],1))},unpad:function(data){var nPaddingBytes=data.words[data.sigBytes-1>>>2]&255;data.sigBytes-=nPaddingBytes}};return CryptoJS.pad.Iso10126})},{"./cipher-core":19,"./core":20}],37:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.pad.Iso97971={pad:function(data,blockSize){data.concat(CryptoJS.lib.WordArray.create([2147483648],1));CryptoJS.pad.ZeroPadding.pad(data,blockSize)},unpad:function(data){CryptoJS.pad.ZeroPadding.unpad(data);data.sigBytes--}};return CryptoJS.pad.Iso97971})},{"./cipher-core":19,"./core":20}],38:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.pad.NoPadding={pad:function(){},unpad:function(){}};return CryptoJS.pad.NoPadding})},{"./cipher-core":19,"./core":20}],39:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.pad.ZeroPadding={pad:function(data,blockSize){var blockSizeBytes=blockSize*4;data.clamp();data.sigBytes+=blockSizeBytes-(data.sigBytes%blockSizeBytes||blockSizeBytes)},unpad:function(data){var dataWords=data.words;var i=data.sigBytes-1;while(!(dataWords[i>>>2]>>>24-i%4*8&255)){i--}data.sigBytes=i+1}};return CryptoJS.pad.ZeroPadding})},{"./cipher-core":19,"./core":20}],40:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./sha1"),_dereq_("./hmac"))}else if(typeof define==="function"&&define.amd){define(["./core","./sha1","./hmac"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var Base=C_lib.Base;var WordArray=C_lib.WordArray;var C_algo=C.algo;var SHA1=C_algo.SHA1;var HMAC=C_algo.HMAC;var PBKDF2=C_algo.PBKDF2=Base.extend({cfg:Base.extend({keySize:128/32,hasher:SHA1,iterations:1}),init:function(cfg){this.cfg=this.cfg.extend(cfg)},compute:function(password,salt){var cfg=this.cfg;var hmac=HMAC.create(cfg.hasher,password);var derivedKey=WordArray.create();var blockIndex=WordArray.create([1]);var derivedKeyWords=derivedKey.words;var blockIndexWords=blockIndex.words;var keySize=cfg.keySize;var iterations=cfg.iterations;while(derivedKeyWords.length<keySize){var block=hmac.update(salt).finalize(blockIndex);hmac.reset();var blockWords=block.words;var blockWordsLength=blockWords.length;var intermediate=block;for(var i=1;i<iterations;i++){intermediate=hmac.finalize(intermediate);hmac.reset();var intermediateWords=intermediate.words;for(var j=0;j<blockWordsLength;j++){blockWords[j]^=intermediateWords[j]}}derivedKey.concat(block);blockIndexWords[0]++}derivedKey.sigBytes=keySize*4;return derivedKey}});C.PBKDF2=function(password,salt,cfg){return PBKDF2.create(cfg).compute(password,salt)}})();return CryptoJS.PBKDF2})},{"./core":20,"./hmac":26,"./sha1":45}],41:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./evpkdf"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var StreamCipher=C_lib.StreamCipher;var C_algo=C.algo;var S=[];var C_=[];var G=[];var RabbitLegacy=C_algo.RabbitLegacy=StreamCipher.extend({_doReset:function(){var K=this._key.words;var iv=this.cfg.iv;var X=this._X=[K[0],K[3]<<16|K[2]>>>16,K[1],K[0]<<16|K[3]>>>16,K[2],K[1]<<16|K[0]>>>16,K[3],K[2]<<16|K[1]>>>16];var C=this._C=[K[2]<<16|K[2]>>>16,K[0]&4294901760|K[1]&65535,K[3]<<16|K[3]>>>16,K[1]&4294901760|K[2]&65535,K[0]<<16|K[0]>>>16,K[2]&4294901760|K[3]&65535,K[1]<<16|K[1]>>>16,K[3]&4294901760|K[0]&65535];this._b=0;for(var i=0;i<4;i++){nextState.call(this)}for(var i=0;i<8;i++){C[i]^=X[i+4&7]}if(iv){var IV=iv.words;var IV_0=IV[0];var IV_1=IV[1];var i0=(IV_0<<8|IV_0>>>24)&16711935|(IV_0<<24|IV_0>>>8)&4278255360;var i2=(IV_1<<8|IV_1>>>24)&16711935|(IV_1<<24|IV_1>>>8)&4278255360;var i1=i0>>>16|i2&4294901760;var i3=i2<<16|i0&65535;C[0]^=i0;C[1]^=i1;C[2]^=i2;C[3]^=i3;C[4]^=i0;C[5]^=i1;C[6]^=i2;C[7]^=i3;for(var i=0;i<4;i++){nextState.call(this)}}},_doProcessBlock:function(M,offset){var X=this._X;nextState.call(this);S[0]=X[0]^X[5]>>>16^X[3]<<16;S[1]=X[2]^X[7]>>>16^X[5]<<16;S[2]=X[4]^X[1]>>>16^X[7]<<16;S[3]=X[6]^X[3]>>>16^X[1]<<16;for(var i=0;i<4;i++){S[i]=(S[i]<<8|S[i]>>>24)&16711935|(S[i]<<24|S[i]>>>8)&4278255360;M[offset+i]^=S[i]}},blockSize:128/32,ivSize:64/32});
function nextState(){var X=this._X;var C=this._C;for(var i=0;i<8;i++){C_[i]=C[i]}C[0]=C[0]+1295307597+this._b|0;C[1]=C[1]+3545052371+(C[0]>>>0<C_[0]>>>0?1:0)|0;C[2]=C[2]+886263092+(C[1]>>>0<C_[1]>>>0?1:0)|0;C[3]=C[3]+1295307597+(C[2]>>>0<C_[2]>>>0?1:0)|0;C[4]=C[4]+3545052371+(C[3]>>>0<C_[3]>>>0?1:0)|0;C[5]=C[5]+886263092+(C[4]>>>0<C_[4]>>>0?1:0)|0;C[6]=C[6]+1295307597+(C[5]>>>0<C_[5]>>>0?1:0)|0;C[7]=C[7]+3545052371+(C[6]>>>0<C_[6]>>>0?1:0)|0;this._b=C[7]>>>0<C_[7]>>>0?1:0;for(var i=0;i<8;i++){var gx=X[i]+C[i];var ga=gx&65535;var gb=gx>>>16;var gh=((ga*ga>>>17)+ga*gb>>>15)+gb*gb;var gl=((gx&4294901760)*gx|0)+((gx&65535)*gx|0);G[i]=gh^gl}X[0]=G[0]+(G[7]<<16|G[7]>>>16)+(G[6]<<16|G[6]>>>16)|0;X[1]=G[1]+(G[0]<<8|G[0]>>>24)+G[7]|0;X[2]=G[2]+(G[1]<<16|G[1]>>>16)+(G[0]<<16|G[0]>>>16)|0;X[3]=G[3]+(G[2]<<8|G[2]>>>24)+G[1]|0;X[4]=G[4]+(G[3]<<16|G[3]>>>16)+(G[2]<<16|G[2]>>>16)|0;X[5]=G[5]+(G[4]<<8|G[4]>>>24)+G[3]|0;X[6]=G[6]+(G[5]<<16|G[5]>>>16)+(G[4]<<16|G[4]>>>16)|0;X[7]=G[7]+(G[6]<<8|G[6]>>>24)+G[5]|0}C.RabbitLegacy=StreamCipher._createHelper(RabbitLegacy)})();return CryptoJS.RabbitLegacy})},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":29}],42:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./evpkdf"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var StreamCipher=C_lib.StreamCipher;var C_algo=C.algo;var S=[];var C_=[];var G=[];var Rabbit=C_algo.Rabbit=StreamCipher.extend({_doReset:function(){var K=this._key.words;var iv=this.cfg.iv;for(var i=0;i<4;i++){K[i]=(K[i]<<8|K[i]>>>24)&16711935|(K[i]<<24|K[i]>>>8)&4278255360}var X=this._X=[K[0],K[3]<<16|K[2]>>>16,K[1],K[0]<<16|K[3]>>>16,K[2],K[1]<<16|K[0]>>>16,K[3],K[2]<<16|K[1]>>>16];var C=this._C=[K[2]<<16|K[2]>>>16,K[0]&4294901760|K[1]&65535,K[3]<<16|K[3]>>>16,K[1]&4294901760|K[2]&65535,K[0]<<16|K[0]>>>16,K[2]&4294901760|K[3]&65535,K[1]<<16|K[1]>>>16,K[3]&4294901760|K[0]&65535];this._b=0;for(var i=0;i<4;i++){nextState.call(this)}for(var i=0;i<8;i++){C[i]^=X[i+4&7]}if(iv){var IV=iv.words;var IV_0=IV[0];var IV_1=IV[1];var i0=(IV_0<<8|IV_0>>>24)&16711935|(IV_0<<24|IV_0>>>8)&4278255360;var i2=(IV_1<<8|IV_1>>>24)&16711935|(IV_1<<24|IV_1>>>8)&4278255360;var i1=i0>>>16|i2&4294901760;var i3=i2<<16|i0&65535;C[0]^=i0;C[1]^=i1;C[2]^=i2;C[3]^=i3;C[4]^=i0;C[5]^=i1;C[6]^=i2;C[7]^=i3;for(var i=0;i<4;i++){nextState.call(this)}}},_doProcessBlock:function(M,offset){var X=this._X;nextState.call(this);S[0]=X[0]^X[5]>>>16^X[3]<<16;S[1]=X[2]^X[7]>>>16^X[5]<<16;S[2]=X[4]^X[1]>>>16^X[7]<<16;S[3]=X[6]^X[3]>>>16^X[1]<<16;for(var i=0;i<4;i++){S[i]=(S[i]<<8|S[i]>>>24)&16711935|(S[i]<<24|S[i]>>>8)&4278255360;M[offset+i]^=S[i]}},blockSize:128/32,ivSize:64/32});function nextState(){var X=this._X;var C=this._C;for(var i=0;i<8;i++){C_[i]=C[i]}C[0]=C[0]+1295307597+this._b|0;C[1]=C[1]+3545052371+(C[0]>>>0<C_[0]>>>0?1:0)|0;C[2]=C[2]+886263092+(C[1]>>>0<C_[1]>>>0?1:0)|0;C[3]=C[3]+1295307597+(C[2]>>>0<C_[2]>>>0?1:0)|0;C[4]=C[4]+3545052371+(C[3]>>>0<C_[3]>>>0?1:0)|0;C[5]=C[5]+886263092+(C[4]>>>0<C_[4]>>>0?1:0)|0;C[6]=C[6]+1295307597+(C[5]>>>0<C_[5]>>>0?1:0)|0;C[7]=C[7]+3545052371+(C[6]>>>0<C_[6]>>>0?1:0)|0;this._b=C[7]>>>0<C_[7]>>>0?1:0;for(var i=0;i<8;i++){var gx=X[i]+C[i];var ga=gx&65535;var gb=gx>>>16;var gh=((ga*ga>>>17)+ga*gb>>>15)+gb*gb;var gl=((gx&4294901760)*gx|0)+((gx&65535)*gx|0);G[i]=gh^gl}X[0]=G[0]+(G[7]<<16|G[7]>>>16)+(G[6]<<16|G[6]>>>16)|0;X[1]=G[1]+(G[0]<<8|G[0]>>>24)+G[7]|0;X[2]=G[2]+(G[1]<<16|G[1]>>>16)+(G[0]<<16|G[0]>>>16)|0;X[3]=G[3]+(G[2]<<8|G[2]>>>24)+G[1]|0;X[4]=G[4]+(G[3]<<16|G[3]>>>16)+(G[2]<<16|G[2]>>>16)|0;X[5]=G[5]+(G[4]<<8|G[4]>>>24)+G[3]|0;X[6]=G[6]+(G[5]<<16|G[5]>>>16)+(G[4]<<16|G[4]>>>16)|0;X[7]=G[7]+(G[6]<<8|G[6]>>>24)+G[5]|0}C.Rabbit=StreamCipher._createHelper(Rabbit)})();return CryptoJS.Rabbit})},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":29}],43:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./evpkdf"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var StreamCipher=C_lib.StreamCipher;var C_algo=C.algo;var RC4=C_algo.RC4=StreamCipher.extend({_doReset:function(){var key=this._key;var keyWords=key.words;var keySigBytes=key.sigBytes;var S=this._S=[];for(var i=0;i<256;i++){S[i]=i}for(var i=0,j=0;i<256;i++){var keyByteIndex=i%keySigBytes;var keyByte=keyWords[keyByteIndex>>>2]>>>24-keyByteIndex%4*8&255;j=(j+S[i]+keyByte)%256;var t=S[i];S[i]=S[j];S[j]=t}this._i=this._j=0},_doProcessBlock:function(M,offset){M[offset]^=generateKeystreamWord.call(this)},keySize:256/32,ivSize:0});function generateKeystreamWord(){var S=this._S;var i=this._i;var j=this._j;var keystreamWord=0;for(var n=0;n<4;n++){i=(i+1)%256;j=(j+S[i])%256;var t=S[i];S[i]=S[j];S[j]=t;keystreamWord|=S[(S[i]+S[j])%256]<<24-n*8}this._i=i;this._j=j;return keystreamWord}C.RC4=StreamCipher._createHelper(RC4);var RC4Drop=C_algo.RC4Drop=RC4.extend({cfg:RC4.cfg.extend({drop:192}),_doReset:function(){RC4._doReset.call(this);for(var i=this.cfg.drop;i>0;i--){generateKeystreamWord.call(this)}}});C.RC4Drop=StreamCipher._createHelper(RC4Drop)})();return CryptoJS.RC4})},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":29}],44:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(Math){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var Hasher=C_lib.Hasher;var C_algo=C.algo;var _zl=WordArray.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]);var _zr=WordArray.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]);var _sl=WordArray.create([11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]);var _sr=WordArray.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]);var _hl=WordArray.create([0,1518500249,1859775393,2400959708,2840853838]);var _hr=WordArray.create([1352829926,1548603684,1836072691,2053994217,0]);var RIPEMD160=C_algo.RIPEMD160=Hasher.extend({_doReset:function(){this._hash=WordArray.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(M,offset){for(var i=0;i<16;i++){var offset_i=offset+i;var M_offset_i=M[offset_i];M[offset_i]=(M_offset_i<<8|M_offset_i>>>24)&16711935|(M_offset_i<<24|M_offset_i>>>8)&4278255360}var H=this._hash.words;var hl=_hl.words;var hr=_hr.words;var zl=_zl.words;var zr=_zr.words;var sl=_sl.words;var sr=_sr.words;var al,bl,cl,dl,el;var ar,br,cr,dr,er;ar=al=H[0];br=bl=H[1];cr=cl=H[2];dr=dl=H[3];er=el=H[4];var t;for(var i=0;i<80;i+=1){t=al+M[offset+zl[i]]|0;if(i<16){t+=f1(bl,cl,dl)+hl[0]}else if(i<32){t+=f2(bl,cl,dl)+hl[1]}else if(i<48){t+=f3(bl,cl,dl)+hl[2]}else if(i<64){t+=f4(bl,cl,dl)+hl[3]}else{t+=f5(bl,cl,dl)+hl[4]}t=t|0;t=rotl(t,sl[i]);t=t+el|0;al=el;el=dl;dl=rotl(cl,10);cl=bl;bl=t;t=ar+M[offset+zr[i]]|0;if(i<16){t+=f5(br,cr,dr)+hr[0]}else if(i<32){t+=f4(br,cr,dr)+hr[1]}else if(i<48){t+=f3(br,cr,dr)+hr[2]}else if(i<64){t+=f2(br,cr,dr)+hr[3]}else{t+=f1(br,cr,dr)+hr[4]}t=t|0;t=rotl(t,sr[i]);t=t+er|0;ar=er;er=dr;dr=rotl(cr,10);cr=br;br=t}t=H[1]+cl+dr|0;H[1]=H[2]+dl+er|0;H[2]=H[3]+el+ar|0;H[3]=H[4]+al+br|0;H[4]=H[0]+bl+cr|0;H[0]=t},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;dataWords[(nBitsLeft+64>>>9<<4)+14]=(nBitsTotal<<8|nBitsTotal>>>24)&16711935|(nBitsTotal<<24|nBitsTotal>>>8)&4278255360;data.sigBytes=(dataWords.length+1)*4;this._process();var hash=this._hash;var H=hash.words;for(var i=0;i<5;i++){var H_i=H[i];H[i]=(H_i<<8|H_i>>>24)&16711935|(H_i<<24|H_i>>>8)&4278255360}return hash},clone:function(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone}});function f1(x,y,z){return x^y^z}function f2(x,y,z){return x&y|~x&z}function f3(x,y,z){return(x|~y)^z}function f4(x,y,z){return x&z|y&~z}function f5(x,y,z){return x^(y|~z)}function rotl(x,n){return x<<n|x>>>32-n}C.RIPEMD160=Hasher._createHelper(RIPEMD160);C.HmacRIPEMD160=Hasher._createHmacHelper(RIPEMD160)})(Math);return CryptoJS.RIPEMD160})},{"./core":20}],45:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var Hasher=C_lib.Hasher;var C_algo=C.algo;var W=[];var SHA1=C_algo.SHA1=Hasher.extend({_doReset:function(){this._hash=new WordArray.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(M,offset){var H=this._hash.words;var a=H[0];var b=H[1];var c=H[2];var d=H[3];var e=H[4];for(var i=0;i<80;i++){if(i<16){W[i]=M[offset+i]|0}else{var n=W[i-3]^W[i-8]^W[i-14]^W[i-16];W[i]=n<<1|n>>>31}var t=(a<<5|a>>>27)+e+W[i];if(i<20){t+=(b&c|~b&d)+1518500249}else if(i<40){t+=(b^c^d)+1859775393}else if(i<60){t+=(b&c|b&d|c&d)-1894007588}else{t+=(b^c^d)-899497514}e=d;d=c;c=b<<30|b>>>2;b=a;a=t}H[0]=H[0]+a|0;H[1]=H[1]+b|0;H[2]=H[2]+c|0;H[3]=H[3]+d|0;H[4]=H[4]+e|0},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;dataWords[(nBitsLeft+64>>>9<<4)+14]=Math.floor(nBitsTotal/4294967296);dataWords[(nBitsLeft+64>>>9<<4)+15]=nBitsTotal;data.sigBytes=dataWords.length*4;this._process();return this._hash},clone:function(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone}});C.SHA1=Hasher._createHelper(SHA1);C.HmacSHA1=Hasher._createHmacHelper(SHA1)})();return CryptoJS.SHA1})},{"./core":20}],46:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./sha256"))}else if(typeof define==="function"&&define.amd){define(["./core","./sha256"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var C_algo=C.algo;var SHA256=C_algo.SHA256;var SHA224=C_algo.SHA224=SHA256.extend({_doReset:function(){this._hash=new WordArray.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var hash=SHA256._doFinalize.call(this);hash.sigBytes-=4;return hash}});C.SHA224=SHA256._createHelper(SHA224);C.HmacSHA224=SHA256._createHmacHelper(SHA224)})();return CryptoJS.SHA224})},{"./core":20,"./sha256":47}],47:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(Math){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var Hasher=C_lib.Hasher;var C_algo=C.algo;var H=[];var K=[];(function(){function isPrime(n){var sqrtN=Math.sqrt(n);for(var factor=2;factor<=sqrtN;factor++){if(!(n%factor)){return false}}return true}function getFractionalBits(n){return(n-(n|0))*4294967296|0}var n=2;var nPrime=0;while(nPrime<64){if(isPrime(n)){if(nPrime<8){H[nPrime]=getFractionalBits(Math.pow(n,1/2))}K[nPrime]=getFractionalBits(Math.pow(n,1/3));nPrime++}n++}})();var W=[];var SHA256=C_algo.SHA256=Hasher.extend({_doReset:function(){this._hash=new WordArray.init(H.slice(0))},_doProcessBlock:function(M,offset){var H=this._hash.words;var a=H[0];var b=H[1];var c=H[2];var d=H[3];var e=H[4];var f=H[5];var g=H[6];var h=H[7];for(var i=0;i<64;i++){if(i<16){W[i]=M[offset+i]|0}else{var gamma0x=W[i-15];var gamma0=(gamma0x<<25|gamma0x>>>7)^(gamma0x<<14|gamma0x>>>18)^gamma0x>>>3;var gamma1x=W[i-2];var gamma1=(gamma1x<<15|gamma1x>>>17)^(gamma1x<<13|gamma1x>>>19)^gamma1x>>>10;W[i]=gamma0+W[i-7]+gamma1+W[i-16]}var ch=e&f^~e&g;var maj=a&b^a&c^b&c;var sigma0=(a<<30|a>>>2)^(a<<19|a>>>13)^(a<<10|a>>>22);var sigma1=(e<<26|e>>>6)^(e<<21|e>>>11)^(e<<7|e>>>25);var t1=h+sigma1+ch+K[i]+W[i];var t2=sigma0+maj;h=g;g=f;f=e;e=d+t1|0;d=c;c=b;b=a;a=t1+t2|0}H[0]=H[0]+a|0;H[1]=H[1]+b|0;H[2]=H[2]+c|0;H[3]=H[3]+d|0;H[4]=H[4]+e|0;H[5]=H[5]+f|0;H[6]=H[6]+g|0;H[7]=H[7]+h|0},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;dataWords[(nBitsLeft+64>>>9<<4)+14]=Math.floor(nBitsTotal/4294967296);dataWords[(nBitsLeft+64>>>9<<4)+15]=nBitsTotal;data.sigBytes=dataWords.length*4;this._process();return this._hash},clone:function(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone}});C.SHA256=Hasher._createHelper(SHA256);C.HmacSHA256=Hasher._createHmacHelper(SHA256)})(Math);return CryptoJS.SHA256})},{"./core":20}],48:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./x64-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./x64-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(Math){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var Hasher=C_lib.Hasher;var C_x64=C.x64;var X64Word=C_x64.Word;var C_algo=C.algo;var RHO_OFFSETS=[];var PI_INDEXES=[];var ROUND_CONSTANTS=[];(function(){var x=1,y=0;for(var t=0;t<24;t++){RHO_OFFSETS[x+5*y]=(t+1)*(t+2)/2%64;var newX=y%5;var newY=(2*x+3*y)%5;x=newX;y=newY}for(var x=0;x<5;x++){for(var y=0;y<5;y++){PI_INDEXES[x+5*y]=y+(2*x+3*y)%5*5}}var LFSR=1;for(var i=0;i<24;i++){var roundConstantMsw=0;var roundConstantLsw=0;for(var j=0;j<7;j++){if(LFSR&1){var bitPosition=(1<<j)-1;if(bitPosition<32){roundConstantLsw^=1<<bitPosition}else{roundConstantMsw^=1<<bitPosition-32}}if(LFSR&128){LFSR=LFSR<<1^113}else{LFSR<<=1}}ROUND_CONSTANTS[i]=X64Word.create(roundConstantMsw,roundConstantLsw)}})();var T=[];(function(){for(var i=0;i<25;i++){T[i]=X64Word.create()}})();var SHA3=C_algo.SHA3=Hasher.extend({cfg:Hasher.cfg.extend({outputLength:512}),_doReset:function(){var state=this._state=[];for(var i=0;i<25;i++){state[i]=new X64Word.init}this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(M,offset){var state=this._state;var nBlockSizeLanes=this.blockSize/2;for(var i=0;i<nBlockSizeLanes;i++){var M2i=M[offset+2*i];var M2i1=M[offset+2*i+1];M2i=(M2i<<8|M2i>>>24)&16711935|(M2i<<24|M2i>>>8)&4278255360;M2i1=(M2i1<<8|M2i1>>>24)&16711935|(M2i1<<24|M2i1>>>8)&4278255360;var lane=state[i];lane.high^=M2i1;lane.low^=M2i}for(var round=0;round<24;round++){for(var x=0;x<5;x++){var tMsw=0,tLsw=0;for(var y=0;y<5;y++){var lane=state[x+5*y];tMsw^=lane.high;tLsw^=lane.low}var Tx=T[x];Tx.high=tMsw;Tx.low=tLsw}for(var x=0;x<5;x++){var Tx4=T[(x+4)%5];var Tx1=T[(x+1)%5];var Tx1Msw=Tx1.high;var Tx1Lsw=Tx1.low;var tMsw=Tx4.high^(Tx1Msw<<1|Tx1Lsw>>>31);var tLsw=Tx4.low^(Tx1Lsw<<1|Tx1Msw>>>31);for(var y=0;y<5;y++){var lane=state[x+5*y];lane.high^=tMsw;lane.low^=tLsw}}for(var laneIndex=1;laneIndex<25;laneIndex++){var lane=state[laneIndex];var laneMsw=lane.high;var laneLsw=lane.low;var rhoOffset=RHO_OFFSETS[laneIndex];if(rhoOffset<32){var tMsw=laneMsw<<rhoOffset|laneLsw>>>32-rhoOffset;var tLsw=laneLsw<<rhoOffset|laneMsw>>>32-rhoOffset}else{var tMsw=laneLsw<<rhoOffset-32|laneMsw>>>64-rhoOffset;var tLsw=laneMsw<<rhoOffset-32|laneLsw>>>64-rhoOffset}var TPiLane=T[PI_INDEXES[laneIndex]];TPiLane.high=tMsw;TPiLane.low=tLsw}var T0=T[0];var state0=state[0];T0.high=state0.high;T0.low=state0.low;for(var x=0;x<5;x++){for(var y=0;y<5;y++){var laneIndex=x+5*y;var lane=state[laneIndex];var TLane=T[laneIndex];var Tx1Lane=T[(x+1)%5+5*y];var Tx2Lane=T[(x+2)%5+5*y];lane.high=TLane.high^~Tx1Lane.high&Tx2Lane.high;lane.low=TLane.low^~Tx1Lane.low&Tx2Lane.low}}var lane=state[0];var roundConstant=ROUND_CONSTANTS[round];lane.high^=roundConstant.high;lane.low^=roundConstant.low}},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;var blockSizeBits=this.blockSize*32;dataWords[nBitsLeft>>>5]|=1<<24-nBitsLeft%32;dataWords[(Math.ceil((nBitsLeft+1)/blockSizeBits)*blockSizeBits>>>5)-1]|=128;data.sigBytes=dataWords.length*4;this._process();var state=this._state;var outputLengthBytes=this.cfg.outputLength/8;var outputLengthLanes=outputLengthBytes/8;var hashWords=[];for(var i=0;i<outputLengthLanes;i++){var lane=state[i];var laneMsw=lane.high;var laneLsw=lane.low;laneMsw=(laneMsw<<8|laneMsw>>>24)&16711935|(laneMsw<<24|laneMsw>>>8)&4278255360;laneLsw=(laneLsw<<8|laneLsw>>>24)&16711935|(laneLsw<<24|laneLsw>>>8)&4278255360;hashWords.push(laneLsw);hashWords.push(laneMsw)}return new WordArray.init(hashWords,outputLengthBytes)},clone:function(){var clone=Hasher.clone.call(this);var state=clone._state=this._state.slice(0);for(var i=0;i<25;i++){state[i]=state[i].clone()}return clone}});C.SHA3=Hasher._createHelper(SHA3);C.HmacSHA3=Hasher._createHmacHelper(SHA3)})(Math);return CryptoJS.SHA3})},{"./core":20,"./x64-core":52}],49:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./x64-core"),_dereq_("./sha512"))}else if(typeof define==="function"&&define.amd){define(["./core","./x64-core","./sha512"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_x64=C.x64;var X64Word=C_x64.Word;var X64WordArray=C_x64.WordArray;var C_algo=C.algo;var SHA512=C_algo.SHA512;var SHA384=C_algo.SHA384=SHA512.extend({_doReset:function(){this._hash=new X64WordArray.init([new X64Word.init(3418070365,3238371032),new X64Word.init(1654270250,914150663),new X64Word.init(2438529370,812702999),new X64Word.init(355462360,4144912697),new X64Word.init(1731405415,4290775857),new X64Word.init(2394180231,1750603025),new X64Word.init(3675008525,1694076839),new X64Word.init(1203062813,3204075428)])},_doFinalize:function(){var hash=SHA512._doFinalize.call(this);hash.sigBytes-=16;return hash}});C.SHA384=SHA512._createHelper(SHA384);C.HmacSHA384=SHA512._createHmacHelper(SHA384)})();return CryptoJS.SHA384})},{"./core":20,"./sha512":50,"./x64-core":52}],50:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./x64-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./x64-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var Hasher=C_lib.Hasher;var C_x64=C.x64;var X64Word=C_x64.Word;var X64WordArray=C_x64.WordArray;var C_algo=C.algo;function X64Word_create(){return X64Word.create.apply(X64Word,arguments)}var K=[X64Word_create(1116352408,3609767458),X64Word_create(1899447441,602891725),X64Word_create(3049323471,3964484399),X64Word_create(3921009573,2173295548),X64Word_create(961987163,4081628472),X64Word_create(1508970993,3053834265),X64Word_create(2453635748,2937671579),X64Word_create(2870763221,3664609560),X64Word_create(3624381080,2734883394),X64Word_create(310598401,1164996542),X64Word_create(607225278,1323610764),X64Word_create(1426881987,3590304994),X64Word_create(1925078388,4068182383),X64Word_create(2162078206,991336113),X64Word_create(2614888103,633803317),X64Word_create(3248222580,3479774868),X64Word_create(3835390401,2666613458),X64Word_create(4022224774,944711139),X64Word_create(264347078,2341262773),X64Word_create(604807628,2007800933),X64Word_create(770255983,1495990901),X64Word_create(1249150122,1856431235),X64Word_create(1555081692,3175218132),X64Word_create(1996064986,2198950837),X64Word_create(2554220882,3999719339),X64Word_create(2821834349,766784016),X64Word_create(2952996808,2566594879),X64Word_create(3210313671,3203337956),X64Word_create(3336571891,1034457026),X64Word_create(3584528711,2466948901),X64Word_create(113926993,3758326383),X64Word_create(338241895,168717936),X64Word_create(666307205,1188179964),X64Word_create(773529912,1546045734),X64Word_create(1294757372,1522805485),X64Word_create(1396182291,2643833823),X64Word_create(1695183700,2343527390),X64Word_create(1986661051,1014477480),X64Word_create(2177026350,1206759142),X64Word_create(2456956037,344077627),X64Word_create(2730485921,1290863460),X64Word_create(2820302411,3158454273),X64Word_create(3259730800,3505952657),X64Word_create(3345764771,106217008),X64Word_create(3516065817,3606008344),X64Word_create(3600352804,1432725776),X64Word_create(4094571909,1467031594),X64Word_create(275423344,851169720),X64Word_create(430227734,3100823752),X64Word_create(506948616,1363258195),X64Word_create(659060556,3750685593),X64Word_create(883997877,3785050280),X64Word_create(958139571,3318307427),X64Word_create(1322822218,3812723403),X64Word_create(1537002063,2003034995),X64Word_create(1747873779,3602036899),X64Word_create(1955562222,1575990012),X64Word_create(2024104815,1125592928),X64Word_create(2227730452,2716904306),X64Word_create(2361852424,442776044),X64Word_create(2428436474,593698344),X64Word_create(2756734187,3733110249),X64Word_create(3204031479,2999351573),X64Word_create(3329325298,3815920427),X64Word_create(3391569614,3928383900),X64Word_create(3515267271,566280711),X64Word_create(3940187606,3454069534),X64Word_create(4118630271,4000239992),X64Word_create(116418474,1914138554),X64Word_create(174292421,2731055270),X64Word_create(289380356,3203993006),X64Word_create(460393269,320620315),X64Word_create(685471733,587496836),X64Word_create(852142971,1086792851),X64Word_create(1017036298,365543100),X64Word_create(1126000580,2618297676),X64Word_create(1288033470,3409855158),X64Word_create(1501505948,4234509866),X64Word_create(1607167915,987167468),X64Word_create(1816402316,1246189591)];var W=[];(function(){for(var i=0;i<80;i++){W[i]=X64Word_create()}})();var SHA512=C_algo.SHA512=Hasher.extend({_doReset:function(){this._hash=new X64WordArray.init([new X64Word.init(1779033703,4089235720),new X64Word.init(3144134277,2227873595),new X64Word.init(1013904242,4271175723),new X64Word.init(2773480762,1595750129),new X64Word.init(1359893119,2917565137),new X64Word.init(2600822924,725511199),new X64Word.init(528734635,4215389547),new X64Word.init(1541459225,327033209)])},_doProcessBlock:function(M,offset){var H=this._hash.words;var H0=H[0];var H1=H[1];var H2=H[2];var H3=H[3];var H4=H[4];var H5=H[5];var H6=H[6];var H7=H[7];var H0h=H0.high;var H0l=H0.low;var H1h=H1.high;var H1l=H1.low;var H2h=H2.high;var H2l=H2.low;var H3h=H3.high;var H3l=H3.low;var H4h=H4.high;var H4l=H4.low;var H5h=H5.high;var H5l=H5.low;var H6h=H6.high;var H6l=H6.low;var H7h=H7.high;var H7l=H7.low;var ah=H0h;var al=H0l;var bh=H1h;var bl=H1l;var ch=H2h;var cl=H2l;var dh=H3h;var dl=H3l;var eh=H4h;var el=H4l;var fh=H5h;var fl=H5l;var gh=H6h;var gl=H6l;var hh=H7h;var hl=H7l;for(var i=0;i<80;i++){var Wi=W[i];if(i<16){var Wih=Wi.high=M[offset+i*2]|0;var Wil=Wi.low=M[offset+i*2+1]|0}else{var gamma0x=W[i-15];var gamma0xh=gamma0x.high;var gamma0xl=gamma0x.low;var gamma0h=(gamma0xh>>>1|gamma0xl<<31)^(gamma0xh>>>8|gamma0xl<<24)^gamma0xh>>>7;var gamma0l=(gamma0xl>>>1|gamma0xh<<31)^(gamma0xl>>>8|gamma0xh<<24)^(gamma0xl>>>7|gamma0xh<<25);var gamma1x=W[i-2];var gamma1xh=gamma1x.high;var gamma1xl=gamma1x.low;var gamma1h=(gamma1xh>>>19|gamma1xl<<13)^(gamma1xh<<3|gamma1xl>>>29)^gamma1xh>>>6;var gamma1l=(gamma1xl>>>19|gamma1xh<<13)^(gamma1xl<<3|gamma1xh>>>29)^(gamma1xl>>>6|gamma1xh<<26);var Wi7=W[i-7];var Wi7h=Wi7.high;var Wi7l=Wi7.low;var Wi16=W[i-16];var Wi16h=Wi16.high;var Wi16l=Wi16.low;var Wil=gamma0l+Wi7l;var Wih=gamma0h+Wi7h+(Wil>>>0<gamma0l>>>0?1:0);var Wil=Wil+gamma1l;var Wih=Wih+gamma1h+(Wil>>>0<gamma1l>>>0?1:0);var Wil=Wil+Wi16l;var Wih=Wih+Wi16h+(Wil>>>0<Wi16l>>>0?1:0);Wi.high=Wih;Wi.low=Wil}var chh=eh&fh^~eh&gh;var chl=el&fl^~el&gl;var majh=ah&bh^ah&ch^bh&ch;var majl=al&bl^al&cl^bl&cl;var sigma0h=(ah>>>28|al<<4)^(ah<<30|al>>>2)^(ah<<25|al>>>7);var sigma0l=(al>>>28|ah<<4)^(al<<30|ah>>>2)^(al<<25|ah>>>7);var sigma1h=(eh>>>14|el<<18)^(eh>>>18|el<<14)^(eh<<23|el>>>9);var sigma1l=(el>>>14|eh<<18)^(el>>>18|eh<<14)^(el<<23|eh>>>9);var Ki=K[i];var Kih=Ki.high;var Kil=Ki.low;var t1l=hl+sigma1l;var t1h=hh+sigma1h+(t1l>>>0<hl>>>0?1:0);var t1l=t1l+chl;var t1h=t1h+chh+(t1l>>>0<chl>>>0?1:0);var t1l=t1l+Kil;var t1h=t1h+Kih+(t1l>>>0<Kil>>>0?1:0);var t1l=t1l+Wil;var t1h=t1h+Wih+(t1l>>>0<Wil>>>0?1:0);var t2l=sigma0l+majl;var t2h=sigma0h+majh+(t2l>>>0<sigma0l>>>0?1:0);hh=gh;hl=gl;gh=fh;gl=fl;fh=eh;fl=el;el=dl+t1l|0;eh=dh+t1h+(el>>>0<dl>>>0?1:0)|0;dh=ch;dl=cl;ch=bh;cl=bl;bh=ah;bl=al;al=t1l+t2l|0;ah=t1h+t2h+(al>>>0<t1l>>>0?1:0)|0}H0l=H0.low=H0l+al;H0.high=H0h+ah+(H0l>>>0<al>>>0?1:0);H1l=H1.low=H1l+bl;H1.high=H1h+bh+(H1l>>>0<bl>>>0?1:0);H2l=H2.low=H2l+cl;H2.high=H2h+ch+(H2l>>>0<cl>>>0?1:0);H3l=H3.low=H3l+dl;H3.high=H3h+dh+(H3l>>>0<dl>>>0?1:0);H4l=H4.low=H4l+el;H4.high=H4h+eh+(H4l>>>0<el>>>0?1:0);H5l=H5.low=H5l+fl;H5.high=H5h+fh+(H5l>>>0<fl>>>0?1:0);H6l=H6.low=H6l+gl;H6.high=H6h+gh+(H6l>>>0<gl>>>0?1:0);H7l=H7.low=H7l+hl;H7.high=H7h+hh+(H7l>>>0<hl>>>0?1:0)},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;dataWords[(nBitsLeft+128>>>10<<5)+30]=Math.floor(nBitsTotal/4294967296);dataWords[(nBitsLeft+128>>>10<<5)+31]=nBitsTotal;data.sigBytes=dataWords.length*4;this._process();var hash=this._hash.toX32();return hash},clone:function(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone},blockSize:1024/32});C.SHA512=Hasher._createHelper(SHA512);C.HmacSHA512=Hasher._createHmacHelper(SHA512)})();return CryptoJS.SHA512})},{"./core":20,"./x64-core":52}],51:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./evpkdf"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var BlockCipher=C_lib.BlockCipher;var C_algo=C.algo;var PC1=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4];var PC2=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32];var BIT_SHIFTS=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28];var SBOX_P=[{0:8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{0:1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{0:260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{0:2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{0:128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{0:268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{0:1048576,16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{0:134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}];
var SBOX_MASK=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679];var DES=C_algo.DES=BlockCipher.extend({_doReset:function(){var key=this._key;var keyWords=key.words;var keyBits=[];for(var i=0;i<56;i++){var keyBitPos=PC1[i]-1;keyBits[i]=keyWords[keyBitPos>>>5]>>>31-keyBitPos%32&1}var subKeys=this._subKeys=[];for(var nSubKey=0;nSubKey<16;nSubKey++){var subKey=subKeys[nSubKey]=[];var bitShift=BIT_SHIFTS[nSubKey];for(var i=0;i<24;i++){subKey[i/6|0]|=keyBits[(PC2[i]-1+bitShift)%28]<<31-i%6;subKey[4+(i/6|0)]|=keyBits[28+(PC2[i+24]-1+bitShift)%28]<<31-i%6}subKey[0]=subKey[0]<<1|subKey[0]>>>31;for(var i=1;i<7;i++){subKey[i]=subKey[i]>>>(i-1)*4+3}subKey[7]=subKey[7]<<5|subKey[7]>>>27}var invSubKeys=this._invSubKeys=[];for(var i=0;i<16;i++){invSubKeys[i]=subKeys[15-i]}},encryptBlock:function(M,offset){this._doCryptBlock(M,offset,this._subKeys)},decryptBlock:function(M,offset){this._doCryptBlock(M,offset,this._invSubKeys)},_doCryptBlock:function(M,offset,subKeys){this._lBlock=M[offset];this._rBlock=M[offset+1];exchangeLR.call(this,4,252645135);exchangeLR.call(this,16,65535);exchangeRL.call(this,2,858993459);exchangeRL.call(this,8,16711935);exchangeLR.call(this,1,1431655765);for(var round=0;round<16;round++){var subKey=subKeys[round];var lBlock=this._lBlock;var rBlock=this._rBlock;var f=0;for(var i=0;i<8;i++){f|=SBOX_P[i][((rBlock^subKey[i])&SBOX_MASK[i])>>>0]}this._lBlock=rBlock;this._rBlock=lBlock^f}var t=this._lBlock;this._lBlock=this._rBlock;this._rBlock=t;exchangeLR.call(this,1,1431655765);exchangeRL.call(this,8,16711935);exchangeRL.call(this,2,858993459);exchangeLR.call(this,16,65535);exchangeLR.call(this,4,252645135);M[offset]=this._lBlock;M[offset+1]=this._rBlock},keySize:64/32,ivSize:64/32,blockSize:64/32});function exchangeLR(offset,mask){var t=(this._lBlock>>>offset^this._rBlock)&mask;this._rBlock^=t;this._lBlock^=t<<offset}function exchangeRL(offset,mask){var t=(this._rBlock>>>offset^this._lBlock)&mask;this._lBlock^=t;this._rBlock^=t<<offset}C.DES=BlockCipher._createHelper(DES);var TripleDES=C_algo.TripleDES=BlockCipher.extend({_doReset:function(){var key=this._key;var keyWords=key.words;this._des1=DES.createEncryptor(WordArray.create(keyWords.slice(0,2)));this._des2=DES.createEncryptor(WordArray.create(keyWords.slice(2,4)));this._des3=DES.createEncryptor(WordArray.create(keyWords.slice(4,6)))},encryptBlock:function(M,offset){this._des1.encryptBlock(M,offset);this._des2.decryptBlock(M,offset);this._des3.encryptBlock(M,offset)},decryptBlock:function(M,offset){this._des3.decryptBlock(M,offset);this._des2.encryptBlock(M,offset);this._des1.decryptBlock(M,offset)},keySize:192/32,ivSize:64/32,blockSize:64/32});C.TripleDES=BlockCipher._createHelper(TripleDES)})();return CryptoJS.TripleDES})},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":29}],52:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(undefined){var C=CryptoJS;var C_lib=C.lib;var Base=C_lib.Base;var X32WordArray=C_lib.WordArray;var C_x64=C.x64={};var X64Word=C_x64.Word=Base.extend({init:function(high,low){this.high=high;this.low=low}});var X64WordArray=C_x64.WordArray=Base.extend({init:function(words,sigBytes){words=this.words=words||[];if(sigBytes!=undefined){this.sigBytes=sigBytes}else{this.sigBytes=words.length*8}},toX32:function(){var x64Words=this.words;var x64WordsLength=x64Words.length;var x32Words=[];for(var i=0;i<x64WordsLength;i++){var x64Word=x64Words[i];x32Words.push(x64Word.high);x32Words.push(x64Word.low)}return X32WordArray.create(x32Words,this.sigBytes)},clone:function(){var clone=Base.clone.call(this);var words=clone.words=this.words.slice(0);var wordsLength=words.length;for(var i=0;i<wordsLength;i++){words[i]=words[i].clone()}return clone}})})();return CryptoJS})},{"./core":20}],53:[function(_dereq_,module,exports){(function(process){!function(globals){"use strict";if(typeof define!=="undefined"&&define.amd){define([],function(){return secureRandom})}else if(typeof module!=="undefined"&&module.exports){module.exports=secureRandom}else{globals.secureRandom=secureRandom}function secureRandom(count,options){options=options||{};if(typeof process!="undefined"&&typeof process.pid=="number"){return nodeRandom(count,options)}else{if(!window.crypto)throw new Error("Your browser does not support window.crypto.");return browserRandom(count,options)}}function nodeRandom(count,options){var crypto=_dereq_("crypto");var buf=crypto.randomBytes(count);if(options.array)var ret=[];else var ret=new Uint8Array(count);for(var i=0;i<count;++i){ret[i]=buf.readUInt8(i)}return ret}function browserRandom(count,options){var nativeArr=new Uint8Array(count);window.crypto.getRandomValues(nativeArr);if(options.array){var ret=[];for(var i=0;i<nativeArr.length;++i){ret[i]=nativeArr[i]}}else{ret=nativeArr}return ret}}(this)}).call(this,_dereq_("FWaASH"))},{FWaASH:15,crypto:4}],54:[function(_dereq_,module,exports){var base58=_dereq_("./base58");var base58check=_dereq_("./base58check");var convert=_dereq_("./convert");var error=_dereq_("./util").error;var mainnet=_dereq_("./network").mainnet.addressVersion;function Address(bytes,version){if(!(this instanceof Address)){return new Address(bytes,version)}if(bytes instanceof Address){this.hash=bytes.hash;this.version=bytes.version}else if(typeof bytes==="string"){if(bytes.length<=35){var decode=base58check.decode(bytes);this.hash=decode.payload;this.version=decode.version}else if(bytes.length<=40){this.hash=convert.hexToBytes(bytes);this.version=version||mainnet}else{error("invalid or unrecognized input")}}else{this.hash=bytes;this.version=version||mainnet}}Address.prototype.toString=function(){return base58check.encode(this.hash.slice(0),this.version)};Address.getVersion=function(address){return base58.decode(address)[0]};Address.validate=function(address){try{base58check.decode(address);return true}catch(e){return false}};module.exports=Address},{"./base58":55,"./base58check":56,"./convert":57,"./network":66,"./util":70}],55:[function(_dereq_,module,exports){(function(Buffer){var BigInteger=_dereq_("./jsbn/jsbn");var alphabet="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";var base=BigInteger.valueOf(58);var alphabetMap={};for(var i=0;i<alphabet.length;++i){var chr=alphabet[i];alphabetMap[chr]=BigInteger.valueOf(i)}function encode(buffer){var bi=BigInteger.fromByteArrayUnsigned(buffer);var chars=[];while(bi.compareTo(base)>=0){var mod=bi.mod(base);bi=bi.subtract(mod).divide(base);chars.push(alphabet[mod.intValue()])}chars.push(alphabet[bi.intValue()]);for(var i=0;i<buffer.length;i++){if(buffer[i]!==0)break;chars.push(alphabet[0])}return chars.reverse().join("")}function decode(str){var num=BigInteger.valueOf(0);var leading_zero=0;var seen_other=false;for(var i=0;i<str.length;++i){var chr=str[i];var bi=alphabetMap[chr];if(bi===undefined){throw new Error("invalid base58 string: "+str)}num=num.multiply(base).add(bi);if(chr==="1"&&!seen_other){++leading_zero}else{seen_other=true}}var bytes=num.toByteArrayUnsigned();while(leading_zero-->0){bytes.unshift(0)}return new Buffer(bytes)}module.exports={encode:encode,decode:decode}}).call(this,_dereq_("buffer").Buffer)},{"./jsbn/jsbn":63,buffer:5}],56:[function(_dereq_,module,exports){(function(Buffer){var assert=_dereq_("assert");var base58=_dereq_("./base58");var crypto=_dereq_("crypto");function sha256(buf){var hash=crypto.createHash("sha256");hash.update(buf);return hash.digest()}function encode(buffer,version){version=version||0;var version=new Buffer([version]);var payload=new Buffer(buffer);var message=Buffer.concat([version,payload]);var checksum=sha256(sha256(message)).slice(0,4);return base58.encode(Buffer.concat([message,checksum]))}function decode(string){var buffer=base58.decode(string);var message=buffer.slice(0,-4);var checksum=buffer.slice(-4);var newChecksum=sha256(sha256(message)).slice(0,4);assert.deepEqual(newChecksum,checksum);var version=message.readUInt8(0);var payload=message.slice(1);return{version:version,payload:payload,checksum:checksum}}module.exports={encode:encode,decode:decode}}).call(this,_dereq_("buffer").Buffer)},{"./base58":55,assert:1,buffer:5,crypto:9}],57:[function(_dereq_,module,exports){(function(Buffer){var Crypto=_dereq_("crypto-js");var WordArray=Crypto.lib.WordArray;var base64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";function lpad(str,padString,length){while(str.length<length)str=padString+str;return str}function bytesToHex(bytes){if(Buffer.isBuffer(bytes)){return bytes.toString("hex")}return bytes.map(function(x){return lpad(x.toString(16),"0",2)}).join("")}function hexToBytes(hex){return hex.match(/../g).map(function(x){return parseInt(x,16)})}function bytesToBase64(bytes){var base64=[];for(var i=0;i<bytes.length;i+=3){var triplet=bytes[i]<<16|bytes[i+1]<<8|bytes[i+2];for(var j=0;j<4;j++){if(i*8+j*6<=bytes.length*8){base64.push(base64map.charAt(triplet>>>6*(3-j)&63))}else{base64.push("=")}}}return base64.join("")}function base64ToBytes(base64){base64=base64.replace(/[^A-Z0-9+\/]/gi,"");var bytes=[];var imod4=0;for(var i=0;i<base64.length;imod4=++i%4){if(!imod4)continue;bytes.push((base64map.indexOf(base64.charAt(i-1))&Math.pow(2,-2*imod4+8)-1)<<imod4*2|base64map.indexOf(base64.charAt(i))>>>6-imod4*2)}return bytes}function coerceToBytes(input){if(typeof input!="string")return input;return hexToBytes(input)}function binToBytes(bin){return bin.match(/......../g).map(function(x){return parseInt(x,2)})}function bytesToBin(bytes){return bytes.map(function(x){return lpad(x.toString(2),"0",8)}).join("")}function bytesToString(bytes){return bytes.map(function(x){return String.fromCharCode(x)}).join("")}function stringToBytes(string){return string.split("").map(function(x){return x.charCodeAt(0)})}function numToBytes(num,bytes){if(bytes===undefined)bytes=8;if(bytes===0)return[];return[num%256].concat(numToBytes(Math.floor(num/256),bytes-1))}function bytesToNum(bytes){if(bytes.length===0)return 0;return bytes[0]+256*bytesToNum(bytes.slice(1))}function numToVarInt(num){if(num<253)return[num];if(num<65536)return[253].concat(numToBytes(num,2));if(num<4294967296)return[254].concat(numToBytes(num,4));return[255].concat(numToBytes(num,8))}function varIntToNum(bytes){var prefix=bytes[0];var viBytes=prefix<253?bytes.slice(0,1):prefix===253?bytes.slice(1,3):prefix===254?bytes.slice(1,5):bytes.slice(1,9);return{bytes:prefix<253?viBytes:bytes.slice(0,viBytes.length+1),number:bytesToNum(viBytes)}}function bytesToWords(bytes){var words=[];for(var i=0,b=0;i<bytes.length;i++,b+=8){words[b>>>5]|=bytes[i]<<24-b%32}return words}function wordsToBytes(words){var bytes=[];for(var b=0;b<words.length*32;b+=8){bytes.push(words[b>>>5]>>>24-b%32&255)}return bytes}function bytesToWordArray(bytes){return new WordArray.init(bytesToWords(bytes),bytes.length)}function wordArrayToBytes(wordArray){return wordsToBytes(wordArray.words)}function reverseEndian(hex){return bytesToHex(hexToBytes(hex).reverse())}module.exports={lpad:lpad,bytesToHex:bytesToHex,hexToBytes:hexToBytes,bytesToBase64:bytesToBase64,base64ToBytes:base64ToBytes,coerceToBytes:coerceToBytes,binToBytes:binToBytes,bytesToBin:bytesToBin,bytesToString:bytesToString,stringToBytes:stringToBytes,numToBytes:numToBytes,bytesToNum:bytesToNum,numToVarInt:numToVarInt,varIntToNum:varIntToNum,bytesToWords:bytesToWords,wordsToBytes:wordsToBytes,bytesToWordArray:bytesToWordArray,wordArrayToBytes:wordArrayToBytes,reverseEndian:reverseEndian}}).call(this,_dereq_("buffer").Buffer)},{buffer:5,"crypto-js":27}],58:[function(_dereq_,module,exports){var sec=_dereq_("./jsbn/sec");var rng=_dereq_("secure-random");var BigInteger=_dereq_("./jsbn/jsbn");var convert=_dereq_("./convert");var HmacSHA256=_dereq_("crypto-js/hmac-sha256");var ECPointFp=_dereq_("./jsbn/ec").ECPointFp;var ecparams=sec("secp256k1");var P_OVER_FOUR=null;function implShamirsTrick(P,k,Q,l){var m=Math.max(k.bitLength(),l.bitLength());var Z=P.add2D(Q);var R=P.curve.getInfinity();for(var i=m-1;i>=0;--i){R=R.twice2D();R.z=BigInteger.ONE;if(k.testBit(i)){if(l.testBit(i)){R=R.add2D(Z)}else{R=R.add2D(P)}}else{if(l.testBit(i)){R=R.add2D(Q)}}}return R}function deterministicGenerateK(hash,key){var vArr=[];var kArr=[];for(var i=0;i<32;i++)vArr.push(1);for(var i=0;i<32;i++)kArr.push(0);var v=convert.bytesToWordArray(vArr);var k=convert.bytesToWordArray(kArr);k=HmacSHA256(convert.bytesToWordArray(vArr.concat([0]).concat(key).concat(hash)),k);v=HmacSHA256(v,k);vArr=convert.wordArrayToBytes(v);k=HmacSHA256(convert.bytesToWordArray(vArr.concat([1]).concat(key).concat(hash)),k);v=HmacSHA256(v,k);v=HmacSHA256(v,k);vArr=convert.wordArrayToBytes(v);return BigInteger.fromByteArrayUnsigned(vArr)}var ECDSA={getBigRandom:function(limit){return new BigInteger(limit.bitLength(),rng).mod(limit.subtract(BigInteger.ONE)).add(BigInteger.ONE)},sign:function(hash,priv){var d=priv;var n=ecparams.getN();var e=BigInteger.fromByteArrayUnsigned(hash);var k=deterministicGenerateK(hash,priv.toByteArrayUnsigned());var G=ecparams.getG();var Q=G.multiply(k);var r=Q.getX().toBigInteger().mod(n);var s=k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);return ECDSA.serializeSig(r,s)},verify:function(hash,sig,pubkey){var r,s;if(Array.isArray(sig)){var obj=ECDSA.parseSig(sig);r=obj.r;s=obj.s}else if("object"===typeof sig&&sig.r&&sig.s){r=sig.r;s=sig.s}else{throw new Error("Invalid value for signature")}var Q;if(pubkey instanceof ECPointFp){Q=pubkey}else if(Array.isArray(pubkey)){Q=ECPointFp.decodeFrom(ecparams.getCurve(),pubkey)}else{throw new Error("Invalid format for pubkey value, must be byte array or ECPointFp")}var e=BigInteger.fromByteArrayUnsigned(hash);return ECDSA.verifyRaw(e,r,s,Q)},verifyRaw:function(e,r,s,Q){var n=ecparams.getN();var G=ecparams.getG();if(r.compareTo(BigInteger.ONE)<0||r.compareTo(n)>=0){return false}if(s.compareTo(BigInteger.ONE)<0||s.compareTo(n)>=0){return false}var c=s.modInverse(n);var u1=e.multiply(c).mod(n);var u2=r.multiply(c).mod(n);var point=G.multiply(u1).add(Q.multiply(u2));var v=point.getX().toBigInteger().mod(n);return v.equals(r)},serializeSig:function(r,s){var rBa=r.toByteArraySigned();var sBa=s.toByteArraySigned();var sequence=[];sequence.push(2);sequence.push(rBa.length);sequence=sequence.concat(rBa);sequence.push(2);sequence.push(sBa.length);sequence=sequence.concat(sBa);sequence.unshift(sequence.length);sequence.unshift(48);return sequence},parseSig:function(sig){var cursor;if(sig[0]!=48){throw new Error("Signature not a valid DERSequence")}cursor=2;if(sig[cursor]!=2){throw new Error("First element in signature must be a DERInteger")}var rBa=sig.slice(cursor+2,cursor+2+sig[cursor+1]);cursor+=2+sig[cursor+1];if(sig[cursor]!=2){throw new Error("Second element in signature must be a DERInteger")}var sBa=sig.slice(cursor+2,cursor+2+sig[cursor+1]);cursor+=2+sig[cursor+1];var r=BigInteger.fromByteArrayUnsigned(rBa);var s=BigInteger.fromByteArrayUnsigned(sBa);return{r:r,s:s}},parseSigCompact:function(sig){if(sig.length!==65){throw new Error("Signature has the wrong length")}var i=sig[0]-27;if(i<0||i>7){throw new Error("Invalid signature type")}var n=ecparams.getN();var r=BigInteger.fromByteArrayUnsigned(sig.slice(1,33)).mod(n);var s=BigInteger.fromByteArrayUnsigned(sig.slice(33,65)).mod(n);return{r:r,s:s,i:i}},recoverPubKey:function(r,s,hash,i){i=i&3;var isYEven=i&1;var isSecondKey=i>>1;var n=ecparams.getN();var G=ecparams.getG();var curve=ecparams.getCurve();var p=curve.getQ();var a=curve.getA().toBigInteger();var b=curve.getB().toBigInteger();if(!P_OVER_FOUR){P_OVER_FOUR=p.add(BigInteger.ONE).divide(BigInteger.valueOf(4))}var x=isSecondKey?r.add(n):r;var alpha=x.multiply(x).multiply(x).add(a.multiply(x)).add(b).mod(p);var beta=alpha.modPow(P_OVER_FOUR,p);var y=(beta.isEven()?!isYEven:isYEven)?beta:p.subtract(beta);var R=new ECPointFp(curve,curve.fromBigInteger(x),curve.fromBigInteger(y));R.validate();var e=BigInteger.fromByteArrayUnsigned(hash);var eNeg=BigInteger.ZERO.subtract(e).mod(n);var rInv=r.modInverse(n);var Q=implShamirsTrick(R,s,G,eNeg).multiply(rInv);Q.validate();if(!ECDSA.verifyRaw(e,r,s,Q)){throw new Error("Pubkey recovery unsuccessful")}return Q},calcPubKeyRecoveryParam:function(origPubKey,r,s,hash){for(var i=0;i<4;i++){var pubKey=ECDSA.recoverPubKey(r,s,hash,i);if(pubKey.equals(origPubKey)){return i}}throw new Error("Unable to find valid recovery factor")}};module.exports=ECDSA},{"./convert":57,"./jsbn/ec":62,"./jsbn/jsbn":63,"./jsbn/sec":64,"crypto-js/hmac-sha256":25,"secure-random":53}],59:[function(_dereq_,module,exports){var Address=_dereq_("./address");var assert=_dereq_("assert");var convert=_dereq_("./convert");var base58check=_dereq_("./base58check");var BigInteger=_dereq_("./jsbn/jsbn");var ecdsa=_dereq_("./ecdsa");var ECPointFp=_dereq_("./jsbn/ec").ECPointFp;var sec=_dereq_("./jsbn/sec");var Network=_dereq_("./network");var util=_dereq_("./util");var ecparams=sec("secp256k1");var ECKey=function(input,compressed){if(!(this instanceof ECKey)){return new ECKey(input,compressed)}if(!input){var n=ecparams.getN();this.priv=ecdsa.getBigRandom(n);this.compressed=compressed||false}else this.import(input,compressed)};ECKey.prototype.import=function(input,compressed){function has(li,v){return li.indexOf(v)>=0}function fromBin(x){return BigInteger.fromByteArrayUnsigned(x)}this.priv=input instanceof ECKey?input.priv:input instanceof BigInteger?input.mod(ecparams.getN()):Array.isArray(input)?fromBin(input.slice(0,32)):typeof input!="string"?null:input.length==44?fromBin(convert.base64ToBytes(input)):input.length==51&&input[0]=="5"?fromBin(base58check.decode(input).payload):input.length==51&&input[0]=="9"?fromBin(base58check.decode(input).payload):input.length==52&&has("LK",input[0])?fromBin(base58check.decode(input).payload.slice(0,32)):input.length==52&&input[0]=="c"?fromBin(base58check.decode(input).payload.slice(0,32)):has([64,65],input.length)?fromBin(convert.hexToBytes(input.slice(0,64))):null;assert(this.priv!==null);this.compressed=compressed!==undefined?compressed:input instanceof ECKey?input.compressed:input instanceof BigInteger?false:Array.isArray(input)?false:typeof input!="string"?null:input.length==44?false:input.length==51&&input[0]=="5"?false:input.length==51&&input[0]=="9"?false:input.length==52&&has("LK",input[0])?true:input.length==52&&input[0]=="c"?true:input.length==64?false:input.length==65?true:null;assert(this.compressed!==null)};ECKey.prototype.getPub=function(compressed){if(compressed===undefined)compressed=this.compressed;return ECPubKey(ecparams.getG().multiply(this.priv),compressed)};ECKey.prototype.toBin=function(){return convert.bytesToString(this.toBytes())};ECKey.version_bytes={0:128,111:239};ECKey.prototype.toWif=function(version){version=version||Network.mainnet.addressVersion;return base58check.encode(this.toBytes(),ECKey.version_bytes[version])};ECKey.prototype.toHex=function(){return convert.bytesToHex(this.toBytes())};ECKey.prototype.toBytes=function(){var bytes=this.priv.toByteArrayUnsigned();if(this.compressed)bytes.push(1);return bytes};ECKey.prototype.toBase64=function(){return convert.bytesToBase64(this.toBytes())};ECKey.prototype.toString=ECKey.prototype.toHex;ECKey.prototype.getAddress=function(version){return this.getPub().getAddress(version)};ECKey.prototype.add=function(key){return ECKey(this.priv.add(ECKey(key).priv),this.compressed)};ECKey.prototype.multiply=function(key){return ECKey(this.priv.multiply(ECKey(key).priv),this.compressed)};ECKey.prototype.sign=function(hash){return ecdsa.sign(hash,this.priv)};ECKey.prototype.verify=function(hash,sig){return this.getPub().verify(hash,sig)};var ECPubKey=function(input,compressed){if(!(this instanceof ECPubKey)){return new ECPubKey(input,compressed)}this.import(input,compressed)};ECPubKey.prototype.import=function(input,compressed){var decode=function(x){return ECPointFp.decodeFrom(ecparams.getCurve(),x)};this.pub=input instanceof ECPointFp?input:input instanceof ECKey?ecparams.getG().multiply(input.priv):input instanceof ECPubKey?input.pub:typeof input=="string"?decode(convert.hexToBytes(input)):Array.isArray(input)?decode(input):null;assert(this.pub!==null);this.compressed=compressed?compressed:input instanceof ECPointFp?input.compressed:input instanceof ECPubKey?input.compressed:this.pub[0]<4};ECPubKey.prototype.add=function(key){return ECPubKey(this.pub.add(ECPubKey(key).pub),this.compressed)};ECPubKey.prototype.multiply=function(key){return ECPubKey(this.pub.multiply(ECKey(key).priv),this.compressed)};ECPubKey.prototype.toBytes=function(compressed){if(compressed===undefined)compressed=this.compressed;return this.pub.getEncoded(compressed)};ECPubKey.prototype.toHex=function(compressed){return convert.bytesToHex(this.toBytes(compressed))};ECPubKey.prototype.toBin=function(compressed){return convert.bytesToString(this.toBytes(compressed))};ECPubKey.prototype.toWif=function(version){version=version||Network.mainnet.addressVersion;return base58check.encode(this.toBytes(),version)};ECPubKey.prototype.toString=ECPubKey.prototype.toHex;ECPubKey.prototype.getAddress=function(version){version=version||Network.mainnet.addressVersion;return new Address(util.sha256ripe160(this.toBytes()),version)};ECPubKey.prototype.verify=function(hash,sig){return ecdsa.verify(hash,sig,this.toBytes())};module.exports={ECKey:ECKey,ECPubKey:ECPubKey}},{"./address":54,"./base58check":56,"./convert":57,"./ecdsa":58,"./jsbn/ec":62,"./jsbn/jsbn":63,"./jsbn/sec":64,"./network":66,"./util":70,assert:1}],60:[function(_dereq_,module,exports){(function(Buffer){var convert=_dereq_("./convert.js");var base58=_dereq_("./base58.js");var assert=_dereq_("assert");var format=_dereq_("util").format;var util=_dereq_("./util.js");var Crypto=_dereq_("crypto-js");var HmacSHA512=Crypto.HmacSHA512;var HMAC=Crypto.algo.HMAC;var ECKey=_dereq_("./eckey.js").ECKey;var ECPubKey=_dereq_("./eckey.js").ECPubKey;var Address=_dereq_("./address.js");var Network=_dereq_("./network");var crypto=_dereq_("crypto");function sha256(buf){var hash=crypto.createHash("sha256");hash.update(buf);return hash.digest()}function HDWallet(seed,network){if(seed===undefined)return;var seedWords=convert.bytesToWordArray(seed);var I=convert.wordArrayToBytes(HmacSHA512(seedWords,"Bitcoin seed"));this.chaincode=I.slice(32);this.network=network||"mainnet";if(!Network.hasOwnProperty(this.network)){throw new Error("Unknown network: "+this.network)}this.priv=new ECKey(I.slice(0,32).concat([1]),true);this.pub=this.priv.getPub();this.index=0;this.depth=0}HDWallet.HIGHEST_BIT=2147483648;HDWallet.LENGTH=78;function arrayEqual(a,b){return!(a<b||a>b)}HDWallet.fromSeedHex=function(hex,network){return new HDWallet(convert.hexToBytes(hex),network)};HDWallet.fromSeedString=function(string,network){return new HDWallet(convert.stringToBytes(string),network)};HDWallet.fromBase58=function(string){var buffer=base58.decode(string);var payload=buffer.slice(0,-4);var checksum=buffer.slice(-4);var newChecksum=sha256(sha256(payload)).slice(0,4);assert.deepEqual(newChecksum,checksum);assert.equal(payload.length,HDWallet.LENGTH);return HDWallet.fromBytes(payload)};HDWallet.fromHex=function(input){return HDWallet.fromBytes(convert.hexToBytes(input))};HDWallet.fromBytes=function(input){if(input.length!=HDWallet.LENGTH){throw new Error(format("Invalid input length, %s. Expected %s.",input.length,HDWallet.LENGTH))}if(Buffer.isBuffer(input)){input=Array.prototype.map.bind(input,function(x){return x})()}var hd=new HDWallet;var versionBytes=input.slice(0,4);var versionWord=convert.bytesToWords(versionBytes)[0];var type;for(var name in Network){var network=Network[name];for(var t in network.hdVersions){if(versionWord!=network.hdVersions[t])continue;type=t;hd.network=name}}if(!hd.network){throw new Error(format("Could not find version %s",convert.bytesToHex(versionBytes)))}hd.depth=input[4];hd.parentFingerprint=input.slice(5,9);assert(hd.depth===0==arrayEqual(hd.parentFingerprint,[0,0,0,0]));hd.index=convert.bytesToNum(input.slice(9,13).reverse());assert(hd.depth>0||hd.index===0);hd.chaincode=input.slice(13,45);if(type=="priv"){hd.priv=new ECKey(input.slice(46,78).concat([1]),true);hd.pub=hd.priv.getPub()}else{hd.pub=new ECPubKey(input.slice(45,78),true)}return hd};HDWallet.prototype.getIdentifier=function(){return util.sha256ripe160(this.pub.toBytes())};HDWallet.prototype.getFingerprint=function(){return this.getIdentifier().slice(0,4)};HDWallet.prototype.getAddress=function(){return new Address(util.sha256ripe160(this.pub.toBytes()),this.getKeyVersion())};HDWallet.prototype.toBytes=function(priv){var buffer=[];var version=Network[this.network].hdVersions[priv?"priv":"pub"];var vBytes=convert.wordsToBytes([version]);buffer=buffer.concat(vBytes);assert.equal(buffer.length,4);buffer.push(this.depth);assert.equal(buffer.length,4+1);buffer=buffer.concat(this.depth?this.parentFingerprint:[0,0,0,0]);assert.equal(buffer.length,4+1+4);buffer=buffer.concat(convert.numToBytes(this.index,4).reverse());assert.equal(buffer.length,4+1+4+4);buffer=buffer.concat(this.chaincode);assert.equal(buffer.length,4+1+4+4+32);if(priv){assert(this.priv,"Cannot serialize to private without private key");buffer.push(0);buffer=buffer.concat(this.priv.toBytes().slice(0,32))}else{buffer=buffer.concat(this.pub.toBytes(true))}return buffer};HDWallet.prototype.toHex=function(priv){var bytes=this.toBytes(priv);return convert.bytesToHex(bytes)};HDWallet.prototype.toBase58=function(priv){var buffer=new Buffer(this.toBytes(priv));var checksum=sha256(sha256(buffer)).slice(0,4);return base58.encode(Buffer.concat([buffer,checksum]))};HDWallet.prototype.derive=function(i){var I,iBytes=convert.numToBytes(i,4).reverse(),cPar=this.chaincode,usePriv=i>=HDWallet.HIGHEST_BIT,SHA512=Crypto.algo.SHA512;if(usePriv){assert(this.priv,"Private derive on public key");var kPar=this.priv.toBytes().slice(0,32);I=HmacFromBytesToBytes(SHA512,[0].concat(kPar,iBytes),cPar)}else{var KPar=this.pub.toBytes(true);I=HmacFromBytesToBytes(SHA512,KPar.concat(iBytes),cPar)}var IL=I.slice(0,32),IR=I.slice(32);var hd=new HDWallet;hd.network=this.network;if(this.priv){hd.priv=this.priv.add(new ECKey(IL.concat([1])));hd.priv.compressed=true;hd.priv.version=this.getKeyVersion();hd.pub=hd.priv.getPub()}else{hd.pub=this.pub.add(new ECKey(IL.concat([1]),true).getPub())}hd.chaincode=IR;hd.parentFingerprint=this.getFingerprint();hd.depth=this.depth+1;hd.index=i;hd.pub.compressed=true;return hd};HDWallet.prototype.derivePrivate=function(index){return this.derive(index+HDWallet.HIGHEST_BIT)};HDWallet.prototype.getKeyVersion=function(){return Network[this.network].addressVersion};HDWallet.prototype.toString=HDWallet.prototype.toBase58;function HmacFromBytesToBytes(hasher,message,key){var hmac=HMAC.create(hasher,convert.bytesToWordArray(key));hmac.update(convert.bytesToWordArray(message));return convert.wordArrayToBytes(hmac.finalize())}module.exports=HDWallet}).call(this,_dereq_("buffer").Buffer)},{"./address.js":54,"./base58.js":55,"./convert.js":57,"./eckey.js":59,"./network":66,"./util.js":70,assert:1,buffer:5,crypto:9,"crypto-js":27,util:17}],61:[function(_dereq_,module,exports){var Key=_dereq_("./eckey");var T=_dereq_("./transaction");module.exports={Address:_dereq_("./address"),Key:Key.ECKey,ECKey:Key.ECKey,ECPubKey:Key.ECPubKey,Message:_dereq_("./message"),BigInteger:_dereq_("./jsbn/jsbn"),Crypto:_dereq_("crypto-js"),Script:_dereq_("./script"),Opcode:_dereq_("./opcode"),Transaction:T.Transaction,Util:_dereq_("./util"),TransactionIn:T.TransactionIn,TransactionOut:T.TransactionOut,ECPointFp:_dereq_("./jsbn/ec").ECPointFp,Wallet:_dereq_("./wallet"),network:_dereq_("./network"),ecdsa:_dereq_("./ecdsa"),HDWallet:_dereq_("./hdwallet.js"),base58:_dereq_("./base58"),base58check:_dereq_("./base58check"),convert:_dereq_("./convert")}},{"./address":54,"./base58":55,"./base58check":56,"./convert":57,"./ecdsa":58,"./eckey":59,"./hdwallet.js":60,"./jsbn/ec":62,"./jsbn/jsbn":63,"./message":65,"./network":66,"./opcode":67,"./script":68,"./transaction":69,"./util":70,"./wallet":71,"crypto-js":27}],62:[function(_dereq_,module,exports){var BigInteger=_dereq_("./jsbn"),sec=_dereq_("./sec");function ECFieldElementFp(q,x){this.x=x;this.q=q}function feFpEquals(other){if(other==this)return true;return this.q.equals(other.q)&&this.x.equals(other.x)}function feFpToBigInteger(){return this.x}function feFpNegate(){return new ECFieldElementFp(this.q,this.x.negate().mod(this.q))}function feFpAdd(b){return new ECFieldElementFp(this.q,this.x.add(b.toBigInteger()).mod(this.q))}function feFpSubtract(b){return new ECFieldElementFp(this.q,this.x.subtract(b.toBigInteger()).mod(this.q))}function feFpMultiply(b){return new ECFieldElementFp(this.q,this.x.multiply(b.toBigInteger()).mod(this.q))}function feFpSquare(){return new ECFieldElementFp(this.q,this.x.square().mod(this.q))}function feFpDivide(b){return new ECFieldElementFp(this.q,this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q))}ECFieldElementFp.prototype.equals=feFpEquals;ECFieldElementFp.prototype.toBigInteger=feFpToBigInteger;ECFieldElementFp.prototype.negate=feFpNegate;ECFieldElementFp.prototype.add=feFpAdd;ECFieldElementFp.prototype.subtract=feFpSubtract;ECFieldElementFp.prototype.multiply=feFpMultiply;ECFieldElementFp.prototype.square=feFpSquare;ECFieldElementFp.prototype.divide=feFpDivide;function ECPointFp(curve,x,y,z){this.curve=curve;this.x=x;this.y=y;if(z==null){this.z=BigInteger.ONE}else{this.z=z}this.zinv=null}function pointFpGetX(){if(this.zinv==null){this.zinv=this.z.modInverse(this.curve.q)}return this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q))}function pointFpGetY(){if(this.zinv==null){this.zinv=this.z.modInverse(this.curve.q)}return this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q))}function pointFpEquals(other){if(other==this)return true;if(this.isInfinity())return other.isInfinity();if(other.isInfinity())return this.isInfinity();var u,v;u=other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);if(!u.equals(BigInteger.ZERO))return false;v=other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);return v.equals(BigInteger.ZERO)}function pointFpIsInfinity(){if(this.x==null&&this.y==null)return true;return this.z.equals(BigInteger.ZERO)&&!this.y.toBigInteger().equals(BigInteger.ZERO)}function pointFpNegate(){return new ECPointFp(this.curve,this.x,this.y.negate(),this.z)}function pointFpAdd(b){if(this.isInfinity())return b;if(b.isInfinity())return this;var u=b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);var v=b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);if(BigInteger.ZERO.equals(v)){if(BigInteger.ZERO.equals(u)){return this.twice()}return this.curve.getInfinity()}var THREE=new BigInteger("3");var x1=this.x.toBigInteger();var y1=this.y.toBigInteger();var x2=b.x.toBigInteger();var y2=b.y.toBigInteger();var v2=v.square();var v3=v2.multiply(v);var x1v2=x1.multiply(v2);var zu2=u.square().multiply(this.z);var x3=zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);var y3=x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);var z3=v3.multiply(this.z).multiply(b.z).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(x3),this.curve.fromBigInteger(y3),z3)}function pointFpTwice(){if(this.isInfinity())return this;if(this.y.toBigInteger().signum()==0)return this.curve.getInfinity();var THREE=new BigInteger("3");var x1=this.x.toBigInteger();var y1=this.y.toBigInteger();var y1z1=y1.multiply(this.z);var y1sqz1=y1z1.multiply(y1).mod(this.curve.q);var a=this.curve.a.toBigInteger();
var w=x1.square().multiply(THREE);if(!BigInteger.ZERO.equals(a)){w=w.add(this.z.square().multiply(a))}w=w.mod(this.curve.q);var x3=w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);var y3=w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);var z3=y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(x3),this.curve.fromBigInteger(y3),z3)}function pointFpMultiply(k){if(this.isInfinity())return this;if(k.signum()==0)return this.curve.getInfinity();var e=k;var h=e.multiply(new BigInteger("3"));var neg=this.negate();var R=this;var i;for(i=h.bitLength()-2;i>0;--i){R=R.twice();var hBit=h.testBit(i);var eBit=e.testBit(i);if(hBit!=eBit){R=R.add(hBit?this:neg)}}return R}function pointFpMultiplyTwo(j,x,k){var i;if(j.bitLength()>k.bitLength())i=j.bitLength()-1;else i=k.bitLength()-1;var R=this.curve.getInfinity();var both=this.add(x);while(i>=0){R=R.twice();if(j.testBit(i)){if(k.testBit(i)){R=R.add(both)}else{R=R.add(this)}}else{if(k.testBit(i)){R=R.add(x)}}--i}return R}ECPointFp.prototype.getX=pointFpGetX;ECPointFp.prototype.getY=pointFpGetY;ECPointFp.prototype.equals=pointFpEquals;ECPointFp.prototype.isInfinity=pointFpIsInfinity;ECPointFp.prototype.negate=pointFpNegate;ECPointFp.prototype.add=pointFpAdd;ECPointFp.prototype.twice=pointFpTwice;ECPointFp.prototype.multiply=pointFpMultiply;ECPointFp.prototype.multiplyTwo=pointFpMultiplyTwo;function ECCurveFp(q,a,b){this.q=q;this.a=this.fromBigInteger(a);this.b=this.fromBigInteger(b);this.infinity=new ECPointFp(this,null,null)}function curveFpGetQ(){return this.q}function curveFpGetA(){return this.a}function curveFpGetB(){return this.b}function curveFpEquals(other){if(other==this)return true;return this.q.equals(other.q)&&this.a.equals(other.a)&&this.b.equals(other.b)}function curveFpGetInfinity(){return this.infinity}function curveFpFromBigInteger(x){return new ECFieldElementFp(this.q,x)}function curveFpDecodePointHex(s){switch(parseInt(s.substr(0,2),16)){case 0:return this.infinity;case 2:case 3:return null;case 4:case 6:case 7:var len=(s.length-2)/2;var xHex=s.substr(2,len);var yHex=s.substr(len+2,len);return new ECPointFp(this,this.fromBigInteger(new BigInteger(xHex,16)),this.fromBigInteger(new BigInteger(yHex,16)));default:return null}}ECCurveFp.prototype.getQ=curveFpGetQ;ECCurveFp.prototype.getA=curveFpGetA;ECCurveFp.prototype.getB=curveFpGetB;ECCurveFp.prototype.equals=curveFpEquals;ECCurveFp.prototype.getInfinity=curveFpGetInfinity;ECCurveFp.prototype.fromBigInteger=curveFpFromBigInteger;ECCurveFp.prototype.decodePointHex=curveFpDecodePointHex;function integerToBytes(i,len){var bytes=i.toByteArrayUnsigned();if(len<bytes.length){bytes=bytes.slice(bytes.length-len)}else while(len>bytes.length){bytes.unshift(0)}return bytes}ECFieldElementFp.prototype.getByteLength=function(){return Math.floor((this.toBigInteger().bitLength()+7)/8)};ECPointFp.prototype.getEncoded=function(compressed){var x=this.getX().toBigInteger();var y=this.getY().toBigInteger();var enc=integerToBytes(x,32);if(compressed){if(y.isEven()){enc.unshift(2)}else{enc.unshift(3)}}else{enc.unshift(4);enc=enc.concat(integerToBytes(y,32))}return enc};ECPointFp.decodeFrom=function(ecparams,enc){var type=enc[0];var dataLen=enc.length-1;if(type==4){var xBa=enc.slice(1,1+dataLen/2),yBa=enc.slice(1+dataLen/2,1+dataLen),x=BigInteger.fromByteArrayUnsigned(xBa),y=BigInteger.fromByteArrayUnsigned(yBa)}else{var xBa=enc.slice(1),x=BigInteger.fromByteArrayUnsigned(xBa),p=ecparams.getQ(),xCubedPlus7=x.multiply(x).multiply(x).add(new BigInteger("7")).mod(p),pPlus1Over4=p.add(new BigInteger("1")).divide(new BigInteger("4")),y=xCubedPlus7.modPow(pPlus1Over4,p);if(y.mod(new BigInteger("2")).toString()!=""+type%2){y=p.subtract(y)}}return new ECPointFp(ecparams,ecparams.fromBigInteger(x),ecparams.fromBigInteger(y))};ECPointFp.prototype.add2D=function(b){if(this.isInfinity())return b;if(b.isInfinity())return this;if(this.x.equals(b.x)){if(this.y.equals(b.y)){return this.twice()}return this.curve.getInfinity()}var x_x=b.x.subtract(this.x);var y_y=b.y.subtract(this.y);var gamma=y_y.divide(x_x);var x3=gamma.square().subtract(this.x).subtract(b.x);var y3=gamma.multiply(this.x.subtract(x3)).subtract(this.y);return new ECPointFp(this.curve,x3,y3)};ECPointFp.prototype.twice2D=function(){if(this.isInfinity())return this;if(this.y.toBigInteger().signum()==0){return this.curve.getInfinity()}var TWO=this.curve.fromBigInteger(BigInteger.valueOf(2));var THREE=this.curve.fromBigInteger(BigInteger.valueOf(3));var gamma=this.x.square().multiply(THREE).add(this.curve.a).divide(this.y.multiply(TWO));var x3=gamma.square().subtract(this.x.multiply(TWO));var y3=gamma.multiply(this.x.subtract(x3)).subtract(this.y);return new ECPointFp(this.curve,x3,y3)};ECPointFp.prototype.multiply2D=function(k){if(this.isInfinity())return this;if(k.signum()==0)return this.curve.getInfinity();var e=k;var h=e.multiply(new BigInteger("3"));var neg=this.negate();var R=this;var i;for(i=h.bitLength()-2;i>0;--i){R=R.twice();var hBit=h.testBit(i);var eBit=e.testBit(i);if(hBit!=eBit){R=R.add2D(hBit?this:neg)}}return R};ECPointFp.prototype.isOnCurve=function(){var x=this.getX().toBigInteger();var y=this.getY().toBigInteger();var a=this.curve.getA().toBigInteger();var b=this.curve.getB().toBigInteger();var n=this.curve.getQ();var lhs=y.multiply(y).mod(n);var rhs=x.multiply(x).multiply(x).add(a.multiply(x)).add(b).mod(n);return lhs.equals(rhs)};ECPointFp.prototype.toString=function(){return"("+this.getX().toBigInteger().toString()+","+this.getY().toBigInteger().toString()+")"};ECPointFp.prototype.validate=function(){var n=this.curve.getQ();if(this.isInfinity()){throw new Error("Point is at infinity.")}var x=this.getX().toBigInteger();var y=this.getY().toBigInteger();if(x.compareTo(BigInteger.ONE)<0||x.compareTo(n.subtract(BigInteger.ONE))>0){throw new Error("x coordinate out of bounds")}if(y.compareTo(BigInteger.ONE)<0||y.compareTo(n.subtract(BigInteger.ONE))>0){throw new Error("y coordinate out of bounds")}if(!this.isOnCurve()){throw new Error("Point is not on the curve.")}if(this.multiply(n).isInfinity()){throw new Error("Point is not a scalar multiple of G.")}return true};module.exports=ECCurveFp;module.exports.ECPointFp=ECPointFp},{"./jsbn":63,"./sec":64}],63:[function(_dereq_,module,exports){(function(Buffer){var dbits;var canary=0xdeadbeefcafe;var j_lm=(canary&16777215)==15715070;function BigInteger(a,b,c){if(!(this instanceof BigInteger)){return new BigInteger(a,b,c)}if(a!=null){if("number"==typeof a)this.fromNumber(a,b,c);else if(b==null&&"string"!=typeof a)this.fromString(a,256);else this.fromString(a,b)}}var proto=BigInteger.prototype;function nbi(){return new BigInteger(null)}function am1(i,x,w,j,c,n){while(--n>=0){var v=x*this[i++]+w[j]+c;c=Math.floor(v/67108864);w[j++]=v&67108863}return c}function am2(i,x,w,j,c,n){var xl=x&32767,xh=x>>15;while(--n>=0){var l=this[i]&32767;var h=this[i++]>>15;var m=xh*l+h*xl;l=xl*l+((m&32767)<<15)+w[j]+(c&1073741823);c=(l>>>30)+(m>>>15)+xh*h+(c>>>30);w[j++]=l&1073741823}return c}function am3(i,x,w,j,c,n){var xl=x&16383,xh=x>>14;while(--n>=0){var l=this[i]&16383;var h=this[i++]>>14;var m=xh*l+h*xl;l=xl*l+((m&16383)<<14)+w[j]+c;c=(l>>28)+(m>>14)+xh*h;w[j++]=l&268435455}return c}BigInteger.prototype.am=am1;dbits=26;BigInteger.prototype.DB=dbits;BigInteger.prototype.DM=(1<<dbits)-1;var DV=BigInteger.prototype.DV=1<<dbits;var BI_FP=52;BigInteger.prototype.FV=Math.pow(2,BI_FP);BigInteger.prototype.F1=BI_FP-dbits;BigInteger.prototype.F2=2*dbits-BI_FP;var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz";var BI_RC=new Array;var rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv)BI_RC[rr++]=vv;rr="a".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;rr="A".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;function int2char(n){return BI_RM.charAt(n)}function intAt(s,i){var c=BI_RC[s.charCodeAt(i)];return c==null?-1:c}function bnpCopyTo(r){for(var i=this.t-1;i>=0;--i)r[i]=this[i];r.t=this.t;r.s=this.s}function bnpFromInt(x){this.t=1;this.s=x<0?-1:0;if(x>0)this[0]=x;else if(x<-1)this[0]=x+DV;else this.t=0}function nbv(i){var r=nbi();r.fromInt(i);return r}function bnpFromString(s,b){var self=this;var k;if(b==16)k=4;else if(b==8)k=3;else if(b==256)k=8;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else{self.fromRadix(s,b);return}self.t=0;self.s=0;var i=s.length,mi=false,sh=0;while(--i>=0){var x=k==8?s[i]&255:intAt(s,i);if(x<0){if(s.charAt(i)=="-")mi=true;continue}mi=false;if(sh==0)self[self.t++]=x;else if(sh+k>self.DB){self[self.t-1]|=(x&(1<<self.DB-sh)-1)<<sh;self[self.t++]=x>>self.DB-sh}else self[self.t-1]|=x<<sh;sh+=k;if(sh>=self.DB)sh-=self.DB}if(k==8&&(s[0]&128)!=0){self.s=-1;if(sh>0)self[self.t-1]|=(1<<self.DB-sh)-1<<sh}self.clamp();if(mi)BigInteger.ZERO.subTo(self,self)}function bnpClamp(){var c=this.s&this.DM;while(this.t>0&&this[this.t-1]==c)--this.t}function bnToString(b){var self=this;if(self.s<0)return"-"+self.negate().toString(b);var k;if(b==16)k=4;else if(b==8)k=3;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else return self.toRadix(b);var km=(1<<k)-1,d,m=false,r="",i=self.t;var p=self.DB-i*self.DB%k;if(i-->0){if(p<self.DB&&(d=self[i]>>p)>0){m=true;r=int2char(d)}while(i>=0){if(p<k){d=(self[i]&(1<<p)-1)<<k-p;d|=self[--i]>>(p+=self.DB-k)}else{d=self[i]>>(p-=k)&km;if(p<=0){p+=self.DB;--i}}if(d>0)m=true;if(m)r+=int2char(d)}}return m?r:"0"}function bnNegate(){var r=nbi();BigInteger.ZERO.subTo(this,r);return r}function bnAbs(){return this.s<0?this.negate():this}function bnCompareTo(a){var r=this.s-a.s;if(r!=0)return r;var i=this.t;r=i-a.t;if(r!=0)return this.s<0?-r:r;while(--i>=0)if((r=this[i]-a[i])!=0)return r;return 0}function nbits(x){var r=1,t;if((t=x>>>16)!=0){x=t;r+=16}if((t=x>>8)!=0){x=t;r+=8}if((t=x>>4)!=0){x=t;r+=4}if((t=x>>2)!=0){x=t;r+=2}if((t=x>>1)!=0){x=t;r+=1}return r}function bnBitLength(){if(this.t<=0)return 0;return this.DB*(this.t-1)+nbits(this[this.t-1]^this.s&this.DM)}function bnpDLShiftTo(n,r){var i;for(i=this.t-1;i>=0;--i)r[i+n]=this[i];for(i=n-1;i>=0;--i)r[i]=0;r.t=this.t+n;r.s=this.s}function bnpDRShiftTo(n,r){for(var i=n;i<this.t;++i)r[i-n]=this[i];r.t=Math.max(this.t-n,0);r.s=this.s}function bnpLShiftTo(n,r){var self=this;var bs=n%self.DB;var cbs=self.DB-bs;var bm=(1<<cbs)-1;var ds=Math.floor(n/self.DB),c=self.s<<bs&self.DM,i;for(i=self.t-1;i>=0;--i){r[i+ds+1]=self[i]>>cbs|c;c=(self[i]&bm)<<bs}for(i=ds-1;i>=0;--i)r[i]=0;r[ds]=c;r.t=self.t+ds+1;r.s=self.s;r.clamp()}function bnpRShiftTo(n,r){var self=this;r.s=self.s;var ds=Math.floor(n/self.DB);if(ds>=self.t){r.t=0;return}var bs=n%self.DB;var cbs=self.DB-bs;var bm=(1<<bs)-1;r[0]=self[ds]>>bs;for(var i=ds+1;i<self.t;++i){r[i-ds-1]|=(self[i]&bm)<<cbs;r[i-ds]=self[i]>>bs}if(bs>0)r[self.t-ds-1]|=(self.s&bm)<<cbs;r.t=self.t-ds;r.clamp()}function bnpSubTo(a,r){var self=this;var i=0,c=0,m=Math.min(a.t,self.t);while(i<m){c+=self[i]-a[i];r[i++]=c&self.DM;c>>=self.DB}if(a.t<self.t){c-=a.s;while(i<self.t){c+=self[i];r[i++]=c&self.DM;c>>=self.DB}c+=self.s}else{c+=self.s;while(i<a.t){c-=a[i];r[i++]=c&self.DM;c>>=self.DB}c-=a.s}r.s=c<0?-1:0;if(c<-1)r[i++]=self.DV+c;else if(c>0)r[i++]=c;r.t=i;r.clamp()}function bnpMultiplyTo(a,r){var x=this.abs(),y=a.abs();var i=x.t;r.t=i+y.t;while(--i>=0)r[i]=0;for(i=0;i<y.t;++i)r[i+x.t]=x.am(0,y[i],r,i,0,x.t);r.s=0;r.clamp();if(this.s!=a.s)BigInteger.ZERO.subTo(r,r)}function bnpSquareTo(r){var x=this.abs();var i=r.t=2*x.t;while(--i>=0)r[i]=0;for(i=0;i<x.t-1;++i){var c=x.am(i,x[i],r,2*i,0,1);if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1))>=x.DV){r[i+x.t]-=x.DV;r[i+x.t+1]=1}}if(r.t>0)r[r.t-1]+=x.am(i,x[i],r,2*i,0,1);r.s=0;r.clamp()}function bnpDivRemTo(m,q,r){var self=this;var pm=m.abs();if(pm.t<=0)return;var pt=self.abs();if(pt.t<pm.t){if(q!=null)q.fromInt(0);if(r!=null)self.copyTo(r);return}if(r==null)r=nbi();var y=nbi(),ts=self.s,ms=m.s;var nsh=self.DB-nbits(pm[pm.t-1]);if(nsh>0){pm.lShiftTo(nsh,y);pt.lShiftTo(nsh,r)}else{pm.copyTo(y);pt.copyTo(r)}var ys=y.t;var y0=y[ys-1];if(y0==0)return;var yt=y0*(1<<self.F1)+(ys>1?y[ys-2]>>self.F2:0);var d1=self.FV/yt,d2=(1<<self.F1)/yt,e=1<<self.F2;var i=r.t,j=i-ys,t=q==null?nbi():q;y.dlShiftTo(j,t);if(r.compareTo(t)>=0){r[r.t++]=1;r.subTo(t,r)}BigInteger.ONE.dlShiftTo(ys,t);t.subTo(y,y);while(y.t<ys)y[y.t++]=0;while(--j>=0){var qd=r[--i]==y0?self.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);if((r[i]+=y.am(0,qd,r,j,0,ys))<qd){y.dlShiftTo(j,t);r.subTo(t,r);while(r[i]<--qd)r.subTo(t,r)}}if(q!=null){r.drShiftTo(ys,q);if(ts!=ms)BigInteger.ZERO.subTo(q,q)}r.t=ys;r.clamp();if(nsh>0)r.rShiftTo(nsh,r);if(ts<0)BigInteger.ZERO.subTo(r,r)}function bnMod(a){var r=nbi();this.abs().divRemTo(a,null,r);if(this.s<0&&r.compareTo(BigInteger.ZERO)>0)a.subTo(r,r);return r}function Classic(m){this.m=m}function cConvert(x){if(x.s<0||x.compareTo(this.m)>=0)return x.mod(this.m);else return x}function cRevert(x){return x}function cReduce(x){x.divRemTo(this.m,null,x)}function cMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r)}function cSqrTo(x,r){x.squareTo(r);this.reduce(r)}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;function bnpInvDigit(){if(this.t<1)return 0;var x=this[0];if((x&1)==0)return 0;var y=x&3;y=y*(2-(x&15)*y)&15;y=y*(2-(x&255)*y)&255;y=y*(2-((x&65535)*y&65535))&65535;y=y*(2-x*y%this.DV)%this.DV;return y>0?this.DV-y:-y}function Montgomery(m){this.m=m;this.mp=m.invDigit();this.mpl=this.mp&32767;this.mph=this.mp>>15;this.um=(1<<m.DB-15)-1;this.mt2=2*m.t}function montConvert(x){var r=nbi();x.abs().dlShiftTo(this.m.t,r);r.divRemTo(this.m,null,r);if(x.s<0&&r.compareTo(BigInteger.ZERO)>0)this.m.subTo(r,r);return r}function montRevert(x){var r=nbi();x.copyTo(r);this.reduce(r);return r}function montReduce(x){while(x.t<=this.mt2)x[x.t++]=0;for(var i=0;i<this.m.t;++i){var j=x[i]&32767;var u0=j*this.mpl+((j*this.mph+(x[i]>>15)*this.mpl&this.um)<<15)&x.DM;j=i+this.m.t;x[j]+=this.m.am(0,u0,x,i,0,this.m.t);while(x[j]>=x.DV){x[j]-=x.DV;x[++j]++}}x.clamp();x.drShiftTo(this.m.t,x);if(x.compareTo(this.m)>=0)x.subTo(this.m,x)}function montSqrTo(x,r){x.squareTo(r);this.reduce(r)}function montMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r)}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;function bnpIsEven(){return(this.t>0?this[0]&1:this.s)==0}function bnpExp(e,z){if(e>4294967295||e<1)return BigInteger.ONE;var r=nbi(),r2=nbi(),g=z.convert(this),i=nbits(e)-1;g.copyTo(r);while(--i>=0){z.sqrTo(r,r2);if((e&1<<i)>0)z.mulTo(r2,g,r);else{var t=r;r=r2;r2=t}}return z.revert(r)}function bnModPowInt(e,m){var z;if(e<256||m.isEven())z=new Classic(m);else z=new Montgomery(m);return this.exp(e,z)}proto.copyTo=bnpCopyTo;proto.fromInt=bnpFromInt;proto.fromString=bnpFromString;proto.clamp=bnpClamp;proto.dlShiftTo=bnpDLShiftTo;proto.drShiftTo=bnpDRShiftTo;proto.lShiftTo=bnpLShiftTo;proto.rShiftTo=bnpRShiftTo;proto.subTo=bnpSubTo;proto.multiplyTo=bnpMultiplyTo;proto.squareTo=bnpSquareTo;proto.divRemTo=bnpDivRemTo;proto.invDigit=bnpInvDigit;proto.isEven=bnpIsEven;proto.exp=bnpExp;proto.toString=bnToString;proto.negate=bnNegate;proto.abs=bnAbs;proto.compareTo=bnCompareTo;proto.bitLength=bnBitLength;proto.mod=bnMod;proto.modPowInt=bnModPowInt;function nbi(){return new BigInteger(null)}function bnClone(){var r=nbi();this.copyTo(r);return r}function bnIntValue(){if(this.s<0){if(this.t==1)return this[0]-this.DV;else if(this.t==0)return-1}else if(this.t==1)return this[0];else if(this.t==0)return 0;return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]}function bnByteValue(){return this.t==0?this.s:this[0]<<24>>24}function bnShortValue(){return this.t==0?this.s:this[0]<<16>>16}function bnpChunkSize(r){return Math.floor(Math.LN2*this.DB/Math.log(r))}function bnSigNum(){if(this.s<0)return-1;else if(this.t<=0||this.t==1&&this[0]<=0)return 0;else return 1}function bnpToRadix(b){if(b==null)b=10;if(this.signum()==0||b<2||b>36)return"0";var cs=this.chunkSize(b);var a=Math.pow(b,cs);var d=nbv(a),y=nbi(),z=nbi(),r="";this.divRemTo(d,y,z);while(y.signum()>0){r=(a+z.intValue()).toString(b).substr(1)+r;y.divRemTo(d,y,z)}return z.intValue().toString(b)+r}function bnpFromRadix(s,b){var self=this;self.fromInt(0);if(b==null)b=10;var cs=self.chunkSize(b);var d=Math.pow(b,cs),mi=false,j=0,w=0;for(var i=0;i<s.length;++i){var x=intAt(s,i);if(x<0){if(s.charAt(i)=="-"&&self.signum()==0)mi=true;continue}w=b*w+x;if(++j>=cs){self.dMultiply(d);self.dAddOffset(w,0);j=0;w=0}}if(j>0){self.dMultiply(Math.pow(b,j));self.dAddOffset(w,0)}if(mi)BigInteger.ZERO.subTo(self,self)}function bnpFromNumber(a,b,c){var self=this;if("number"==typeof b){if(a<2)self.fromInt(1);else{self.fromNumber(a,c);if(!self.testBit(a-1))self.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,self);if(self.isEven())self.dAddOffset(1,0);while(!self.isProbablePrime(b)){self.dAddOffset(2,0);if(self.bitLength()>a)self.subTo(BigInteger.ONE.shiftLeft(a-1),self)}}}else{var t=a&7;var length=(a>>3)+1;var x=b(length,{array:true});if(t>0)x[0]&=(1<<t)-1;else x[0]=0;self.fromString(x,256)}}function bnToByteArray(){var self=this;var i=self.t,r=new Array;r[0]=self.s;var p=self.DB-i*self.DB%8,d,k=0;if(i-->0){if(p<self.DB&&(d=self[i]>>p)!=(self.s&self.DM)>>p)r[k++]=d|self.s<<self.DB-p;while(i>=0){if(p<8){d=(self[i]&(1<<p)-1)<<8-p;d|=self[--i]>>(p+=self.DB-8)}else{d=self[i]>>(p-=8)&255;if(p<=0){p+=self.DB;--i}}if((d&128)!=0)d|=-256;if(k===0&&(self.s&128)!=(d&128))++k;if(k>0||d!=self.s)r[k++]=d}}return r}function bnEquals(a){return this.compareTo(a)==0}function bnMin(a){return this.compareTo(a)<0?this:a}function bnMax(a){return this.compareTo(a)>0?this:a}function bnpBitwiseTo(a,op,r){var self=this;var i,f,m=Math.min(a.t,self.t);for(i=0;i<m;++i)r[i]=op(self[i],a[i]);if(a.t<self.t){f=a.s&self.DM;for(i=m;i<self.t;++i)r[i]=op(self[i],f);r.t=self.t}else{f=self.s&self.DM;for(i=m;i<a.t;++i)r[i]=op(f,a[i]);r.t=a.t}r.s=op(self.s,a.s);r.clamp()}function op_and(x,y){return x&y}function bnAnd(a){var r=nbi();this.bitwiseTo(a,op_and,r);return r}function op_or(x,y){return x|y}function bnOr(a){var r=nbi();this.bitwiseTo(a,op_or,r);return r}function op_xor(x,y){return x^y}function bnXor(a){var r=nbi();this.bitwiseTo(a,op_xor,r);return r}function op_andnot(x,y){return x&~y}function bnAndNot(a){var r=nbi();this.bitwiseTo(a,op_andnot,r);return r}function bnNot(){var r=nbi();for(var i=0;i<this.t;++i)r[i]=this.DM&~this[i];r.t=this.t;r.s=~this.s;return r}function bnShiftLeft(n){var r=nbi();if(n<0)this.rShiftTo(-n,r);else this.lShiftTo(n,r);return r}function bnShiftRight(n){var r=nbi();if(n<0)this.lShiftTo(-n,r);else this.rShiftTo(n,r);return r}function lbit(x){if(x==0)return-1;var r=0;if((x&65535)==0){x>>=16;r+=16}if((x&255)==0){x>>=8;r+=8}if((x&15)==0){x>>=4;r+=4}if((x&3)==0){x>>=2;r+=2}if((x&1)==0)++r;return r}function bnGetLowestSetBit(){for(var i=0;i<this.t;++i)if(this[i]!=0)return i*this.DB+lbit(this[i]);if(this.s<0)return this.t*this.DB;return-1}function cbit(x){var r=0;while(x!=0){x&=x-1;++r}return r}function bnBitCount(){var r=0,x=this.s&this.DM;for(var i=0;i<this.t;++i)r+=cbit(this[i]^x);return r}function bnTestBit(n){var j=Math.floor(n/this.DB);if(j>=this.t)return this.s!=0;return(this[j]&1<<n%this.DB)!=0}function bnpChangeBit(n,op){var r=BigInteger.ONE.shiftLeft(n);this.bitwiseTo(r,op,r);return r}function bnSetBit(n){return this.changeBit(n,op_or)}function bnClearBit(n){return this.changeBit(n,op_andnot)}function bnFlipBit(n){return this.changeBit(n,op_xor)}function bnpAddTo(a,r){var self=this;var i=0,c=0,m=Math.min(a.t,self.t);while(i<m){c+=self[i]+a[i];r[i++]=c&self.DM;c>>=self.DB}if(a.t<self.t){c+=a.s;while(i<self.t){c+=self[i];r[i++]=c&self.DM;c>>=self.DB}c+=self.s}else{c+=self.s;while(i<a.t){c+=a[i];r[i++]=c&self.DM;c>>=self.DB}c+=a.s}r.s=c<0?-1:0;if(c>0)r[i++]=c;else if(c<-1)r[i++]=self.DV+c;r.t=i;r.clamp()}function bnAdd(a){var r=nbi();this.addTo(a,r);return r}function bnSubtract(a){var r=nbi();this.subTo(a,r);return r}function bnMultiply(a){var r=nbi();this.multiplyTo(a,r);return r}function bnSquare(){var r=nbi();this.squareTo(r);return r}function bnDivide(a){var r=nbi();this.divRemTo(a,r,null);return r}function bnRemainder(a){var r=nbi();this.divRemTo(a,null,r);return r}function bnDivideAndRemainder(a){var q=nbi(),r=nbi();this.divRemTo(a,q,r);return new Array(q,r)}function bnpDMultiply(n){this[this.t]=this.am(0,n-1,this,0,0,this.t);++this.t;this.clamp()}function bnpDAddOffset(n,w){if(n==0)return;while(this.t<=w)this[this.t++]=0;this[w]+=n;while(this[w]>=this.DV){this[w]-=this.DV;if(++w>=this.t)this[this.t++]=0;++this[w]}}function NullExp(){}function nNop(x){return x}function nMulTo(x,y,r){x.multiplyTo(y,r)}function nSqrTo(x,r){x.squareTo(r)}NullExp.prototype.convert=nNop;NullExp.prototype.revert=nNop;NullExp.prototype.mulTo=nMulTo;NullExp.prototype.sqrTo=nSqrTo;function bnPow(e){return this.exp(e,new NullExp)}function bnpMultiplyLowerTo(a,n,r){var i=Math.min(this.t+a.t,n);r.s=0;r.t=i;while(i>0)r[--i]=0;var j;for(j=r.t-this.t;i<j;++i)r[i+this.t]=this.am(0,a[i],r,i,0,this.t);for(j=Math.min(a.t,n);i<j;++i)this.am(0,a[i],r,i,0,n-i);r.clamp()}function bnpMultiplyUpperTo(a,n,r){--n;var i=r.t=this.t+a.t-n;r.s=0;while(--i>=0)r[i]=0;for(i=Math.max(n-this.t,0);i<a.t;++i)r[this.t+i-n]=this.am(n-i,a[i],r,0,0,this.t+i-n);r.clamp();r.drShiftTo(1,r)}function Barrett(m){this.r2=nbi();this.q3=nbi();BigInteger.ONE.dlShiftTo(2*m.t,this.r2);this.mu=this.r2.divide(m);this.m=m}function barrettConvert(x){if(x.s<0||x.t>2*this.m.t)return x.mod(this.m);else if(x.compareTo(this.m)<0)return x;else{var r=nbi();x.copyTo(r);this.reduce(r);return r}}function barrettRevert(x){return x}function barrettReduce(x){var self=this;x.drShiftTo(self.m.t-1,self.r2);if(x.t>self.m.t+1){x.t=self.m.t+1;x.clamp()}self.mu.multiplyUpperTo(self.r2,self.m.t+1,self.q3);self.m.multiplyLowerTo(self.q3,self.m.t+1,self.r2);while(x.compareTo(self.r2)<0)x.dAddOffset(1,self.m.t+1);x.subTo(self.r2,x);while(x.compareTo(self.m)>=0)x.subTo(self.m,x)}function barrettSqrTo(x,r){x.squareTo(r);this.reduce(r)}function barrettMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r)}Barrett.prototype.convert=barrettConvert;Barrett.prototype.revert=barrettRevert;Barrett.prototype.reduce=barrettReduce;Barrett.prototype.mulTo=barrettMulTo;Barrett.prototype.sqrTo=barrettSqrTo;function bnModPow(e,m){var i=e.bitLength(),k,r=nbv(1),z;if(i<=0)return r;else if(i<18)k=1;else if(i<48)k=3;else if(i<144)k=4;else if(i<768)k=5;else k=6;if(i<8)z=new Classic(m);else if(m.isEven())z=new Barrett(m);else z=new Montgomery(m);var g=new Array,n=3,k1=k-1,km=(1<<k)-1;g[1]=z.convert(this);if(k>1){var g2=nbi();z.sqrTo(g[1],g2);while(n<=km){g[n]=nbi();z.mulTo(g2,g[n-2],g[n]);n+=2}}var j=e.t-1,w,is1=true,r2=nbi(),t;i=nbits(e[j])-1;while(j>=0){if(i>=k1)w=e[j]>>i-k1&km;else{w=(e[j]&(1<<i+1)-1)<<k1-i;if(j>0)w|=e[j-1]>>this.DB+i-k1}n=k;while((w&1)==0){w>>=1;--n}if((i-=n)<0){i+=this.DB;--j}if(is1){g[w].copyTo(r);is1=false}else{while(n>1){z.sqrTo(r,r2);z.sqrTo(r2,r);n-=2}if(n>0)z.sqrTo(r,r2);else{t=r;r=r2;r2=t}z.mulTo(r2,g[w],r)}while(j>=0&&(e[j]&1<<i)==0){z.sqrTo(r,r2);t=r;r=r2;r2=t;if(--i<0){i=this.DB-1;--j}}}return z.revert(r)}function bnGCD(a){var x=this.s<0?this.negate():this.clone();var y=a.s<0?a.negate():a.clone();if(x.compareTo(y)<0){var t=x;x=y;y=t}var i=x.getLowestSetBit(),g=y.getLowestSetBit();if(g<0)return x;if(i<g)g=i;if(g>0){x.rShiftTo(g,x);y.rShiftTo(g,y)}while(x.signum()>0){if((i=x.getLowestSetBit())>0)x.rShiftTo(i,x);if((i=y.getLowestSetBit())>0)y.rShiftTo(i,y);if(x.compareTo(y)>=0){x.subTo(y,x);x.rShiftTo(1,x)}else{y.subTo(x,y);y.rShiftTo(1,y)}}if(g>0)y.lShiftTo(g,y);return y}function bnpModInt(n){if(n<=0)return 0;var d=this.DV%n,r=this.s<0?n-1:0;if(this.t>0)if(d==0)r=this[0]%n;else for(var i=this.t-1;i>=0;--i)r=(d*r+this[i])%n;return r}function bnModInverse(m){var ac=m.isEven();if(this.isEven()&&ac||m.signum()==0)return BigInteger.ZERO;var u=m.clone(),v=this.clone();var a=nbv(1),b=nbv(0),c=nbv(0),d=nbv(1);while(u.signum()!=0){while(u.isEven()){u.rShiftTo(1,u);if(ac){if(!a.isEven()||!b.isEven()){a.addTo(this,a);b.subTo(m,b)}a.rShiftTo(1,a)}else if(!b.isEven())b.subTo(m,b);b.rShiftTo(1,b)}while(v.isEven()){v.rShiftTo(1,v);if(ac){if(!c.isEven()||!d.isEven()){c.addTo(this,c);d.subTo(m,d)}c.rShiftTo(1,c)}else if(!d.isEven())d.subTo(m,d);d.rShiftTo(1,d)}if(u.compareTo(v)>=0){u.subTo(v,u);if(ac)a.subTo(c,a);b.subTo(d,b)}else{v.subTo(u,v);if(ac)c.subTo(a,c);d.subTo(b,d)}}if(v.compareTo(BigInteger.ONE)!=0)return BigInteger.ZERO;if(d.compareTo(m)>=0)return d.subtract(m);if(d.signum()<0)d.addTo(m,d);else return d;if(d.signum()<0)return d.add(m);else return d}proto.chunkSize=bnpChunkSize;proto.toRadix=bnpToRadix;proto.fromRadix=bnpFromRadix;proto.fromNumber=bnpFromNumber;proto.bitwiseTo=bnpBitwiseTo;proto.changeBit=bnpChangeBit;proto.addTo=bnpAddTo;proto.dMultiply=bnpDMultiply;proto.dAddOffset=bnpDAddOffset;proto.multiplyLowerTo=bnpMultiplyLowerTo;proto.multiplyUpperTo=bnpMultiplyUpperTo;proto.modInt=bnpModInt;proto.clone=bnClone;proto.intValue=bnIntValue;proto.byteValue=bnByteValue;proto.shortValue=bnShortValue;proto.signum=bnSigNum;proto.toByteArray=bnToByteArray;proto.equals=bnEquals;proto.min=bnMin;proto.max=bnMax;proto.and=bnAnd;proto.or=bnOr;proto.xor=bnXor;proto.andNot=bnAndNot;proto.not=bnNot;proto.shiftLeft=bnShiftLeft;proto.shiftRight=bnShiftRight;proto.getLowestSetBit=bnGetLowestSetBit;proto.bitCount=bnBitCount;proto.testBit=bnTestBit;proto.setBit=bnSetBit;proto.clearBit=bnClearBit;proto.flipBit=bnFlipBit;proto.add=bnAdd;proto.subtract=bnSubtract;proto.multiply=bnMultiply;proto.divide=bnDivide;proto.remainder=bnRemainder;proto.divideAndRemainder=bnDivideAndRemainder;proto.modPow=bnModPow;proto.modInverse=bnModInverse;proto.pow=bnPow;proto.gcd=bnGCD;proto.square=bnSquare;BigInteger.ZERO=nbv(0);BigInteger.ONE=nbv(1);BigInteger.valueOf=nbv;BigInteger.fromByteArrayUnsigned=function(ba){if(Buffer.isBuffer(ba)){ba=Array.prototype.map.bind(ba,function(x){return x})()}if(!ba.length){return new BigInteger.valueOf(0)}else if(ba[0]&128){return new BigInteger([0].concat(ba))}else{return new BigInteger(ba)}};BigInteger.fromByteArraySigned=function(ba){if(ba[0]&128){ba[0]&=127;return BigInteger.fromByteArrayUnsigned(ba).negate()}else{return BigInteger.fromByteArrayUnsigned(ba)}};BigInteger.prototype.toByteArrayUnsigned=function(){var ba=this.abs().toByteArray();if(!ba.length){return ba}if(ba[0]===0){ba=ba.slice(1)}for(var i=0;i<ba.length;++i){ba[i]=ba[i]<0?ba[i]+256:ba[i]}return ba};BigInteger.prototype.toByteArraySigned=function(){var val=this.toByteArrayUnsigned();var neg=this.s<0;if(val[0]&128){val.unshift(neg?128:0)}else if(neg){val[0]|=128}return val};module.exports=BigInteger}).call(this,_dereq_("buffer").Buffer)},{buffer:5}],64:[function(_dereq_,module,exports){var ECCurveFp=_dereq_("./ec");var BigInteger=_dereq_("./jsbn");function X9ECParameters(curve,g,n,h){this.curve=curve;this.g=g;this.n=n;this.h=h}function x9getCurve(){return this.curve}function x9getG(){return this.g}function x9getN(){return this.n}function x9getH(){return this.h}X9ECParameters.prototype.getCurve=x9getCurve;X9ECParameters.prototype.getG=x9getG;X9ECParameters.prototype.getN=x9getN;X9ECParameters.prototype.getH=x9getH;function fromHex(s){return new BigInteger(s,16)}function secp128r1(){var p=fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");var a=fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");var b=fromHex("E87579C11079F43DD824993C2CEE5ED3");var n=fromHex("FFFFFFFE0000000075A30D1B9038A115");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"161FF7528B899B2D0C28607CA52C5B86"+"CF5AC8395BAFEB13C02DA292DDED7A83");return new X9ECParameters(curve,G,n,h)}function secp160k1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");var a=BigInteger.ZERO;var b=fromHex("7");var n=fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"3B4C382CE37AA192A4019E763036F4F5DD4D7EBB"+"938CF935318FDCED6BC28286531733C3F03C4FEE");return new X9ECParameters(curve,G,n,h)}function secp160r1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");var a=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");var b=fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");var n=fromHex("0100000000000000000001F4C8F927AED3CA752257");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"4A96B5688EF573284664698968C38BB913CBFC82"+"23A628553168947D59DCC912042351377AC5FB32");return new X9ECParameters(curve,G,n,h)}function secp192k1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");var a=BigInteger.ZERO;var b=fromHex("3");var n=fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D"+"9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");return new X9ECParameters(curve,G,n,h)}function secp192r1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");var a=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");var b=fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");var n=fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012"+"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811");return new X9ECParameters(curve,G,n,h)}function secp224r1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");var a=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");var b=fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");var n=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21"+"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");return new X9ECParameters(curve,G,n,h)}function secp256k1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F");var a=BigInteger.ZERO;var b=fromHex("7");var n=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798"+"483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8");return new X9ECParameters(curve,G,n,h)}function secp256r1(){var p=fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");var a=fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");var b=fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");var n=fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296"+"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");return new X9ECParameters(curve,G,n,h)}function getSECCurveByName(name){if(name=="secp128r1")return secp128r1();if(name=="secp160k1")return secp160k1();if(name=="secp160r1")return secp160r1();if(name=="secp192k1")return secp192k1();if(name=="secp192r1")return secp192r1();if(name=="secp224r1")return secp224r1();if(name=="secp256k1")return secp256k1();if(name=="secp256r1")return secp256r1();return null}module.exports=getSECCurveByName},{"./ec":62,"./jsbn":63}],65:[function(_dereq_,module,exports){var Address=_dereq_("./address");var convert=_dereq_("./convert");var ecdsa=_dereq_("./ecdsa");var ECPubKey=_dereq_("./eckey").ECPubKey;var SHA256=_dereq_("crypto-js/sha256");var magicBytes=convert.stringToBytes("Bitcoin Signed Message:\n");function magicHash(message){var messageBytes=convert.stringToBytes(message);var buffer=[].concat(convert.numToVarInt(magicBytes.length),magicBytes,convert.numToVarInt(messageBytes.length),messageBytes);
return convert.wordArrayToBytes(SHA256(SHA256(convert.bytesToWordArray(buffer))))}function sign(key,message){var hash=magicHash(message);var sig=key.sign(hash);var obj=ecdsa.parseSig(sig);var i=ecdsa.calcPubKeyRecoveryParam(key.getPub().pub,obj.r,obj.s,hash);i+=27;if(key.compressed){i+=4}var rBa=obj.r.toByteArrayUnsigned();var sBa=obj.s.toByteArrayUnsigned();while(rBa.length<32)rBa.unshift(0);while(sBa.length<32)sBa.unshift(0);sig=[i].concat(rBa,sBa);return sig}function verify(address,sig,message){sig=ecdsa.parseSigCompact(sig);var pubKey=new ECPubKey(ecdsa.recoverPubKey(sig.r,sig.s,magicHash(message),sig.i));var isCompressed=!!(sig.i&4);pubKey.compressed=isCompressed;address=new Address(address);return pubKey.getAddress(address.version).toString()===address.toString()}module.exports={magicHash:magicHash,sign:sign,verify:verify}},{"./address":54,"./convert":57,"./ecdsa":58,"./eckey":59,"crypto-js/sha256":47}],66:[function(_dereq_,module,exports){module.exports={mainnet:{addressVersion:0,p2shVersion:5,hdVersions:{pub:76067358,priv:76066276}},testnet:{addressVersion:111,p2shVersion:196,hdVersions:{pub:70617039,priv:70615956}}}},{}],67:[function(_dereq_,module,exports){var Opcode={map:{OP_0:0,OP_FALSE:0,OP_PUSHDATA1:76,OP_PUSHDATA2:77,OP_PUSHDATA4:78,OP_1NEGATE:79,OP_RESERVED:80,OP_1:81,OP_TRUE:81,OP_2:82,OP_3:83,OP_4:84,OP_5:85,OP_6:86,OP_7:87,OP_8:88,OP_9:89,OP_10:90,OP_11:91,OP_12:92,OP_13:93,OP_14:94,OP_15:95,OP_16:96,OP_NOP:97,OP_VER:98,OP_IF:99,OP_NOTIF:100,OP_VERIF:101,OP_VERNOTIF:102,OP_ELSE:103,OP_ENDIF:104,OP_VERIFY:105,OP_RETURN:106,OP_TOALTSTACK:107,OP_FROMALTSTACK:108,OP_2DROP:109,OP_2DUP:110,OP_3DUP:111,OP_2OVER:112,OP_2ROT:113,OP_2SWAP:114,OP_IFDUP:115,OP_DEPTH:116,OP_DROP:117,OP_DUP:118,OP_NIP:119,OP_OVER:120,OP_PICK:121,OP_ROLL:122,OP_ROT:123,OP_SWAP:124,OP_TUCK:125,OP_CAT:126,OP_SUBSTR:127,OP_LEFT:128,OP_RIGHT:129,OP_SIZE:130,OP_INVERT:131,OP_AND:132,OP_OR:133,OP_XOR:134,OP_EQUAL:135,OP_EQUALVERIFY:136,OP_RESERVED1:137,OP_RESERVED2:138,OP_1ADD:139,OP_1SUB:140,OP_2MUL:141,OP_2DIV:142,OP_NEGATE:143,OP_ABS:144,OP_NOT:145,OP_0NOTEQUAL:146,OP_ADD:147,OP_SUB:148,OP_MUL:149,OP_DIV:150,OP_MOD:151,OP_LSHIFT:152,OP_RSHIFT:153,OP_BOOLAND:154,OP_BOOLOR:155,OP_NUMEQUAL:156,OP_NUMEQUALVERIFY:157,OP_NUMNOTEQUAL:158,OP_LESSTHAN:159,OP_GREATERTHAN:160,OP_LESSTHANOREQUAL:161,OP_GREATERTHANOREQUAL:162,OP_MIN:163,OP_MAX:164,OP_WITHIN:165,OP_RIPEMD160:166,OP_SHA1:167,OP_SHA256:168,OP_HASH160:169,OP_HASH256:170,OP_CODESEPARATOR:171,OP_CHECKSIG:172,OP_CHECKSIGVERIFY:173,OP_CHECKMULTISIG:174,OP_CHECKMULTISIGVERIFY:175,OP_NOP1:176,OP_NOP2:177,OP_NOP3:178,OP_NOP4:179,OP_NOP5:180,OP_NOP6:181,OP_NOP7:182,OP_NOP8:183,OP_NOP9:184,OP_NOP10:185,OP_PUBKEYHASH:253,OP_PUBKEY:254,OP_INVALIDOPCODE:255},reverseMap:[]};for(var i in Opcode.map){Opcode.reverseMap[Opcode.map[i]]=i}module.exports=Opcode},{}],68:[function(_dereq_,module,exports){(function(Buffer){var Opcode=_dereq_("./opcode");var util=_dereq_("./util");var convert=_dereq_("./convert");var Address=_dereq_("./address");var network=_dereq_("./network");var Script=function(data){this.buffer=data||[];if(!Array.isArray(this.buffer)){throw new Error("expect Script to be initialized with Array, but got "+data)}this.parse()};Script.fromHex=function(data){return new Script(convert.hexToBytes(data))};Script.fromPubKey=function(str){var script=new Script;var s=str.split(" ");for(var i in s){if(Opcode.map.hasOwnProperty(s[i])){script.writeOp(Opcode.map[s[i]])}else{script.writeBytes(convert.hexToBytes(s[i]))}}return script};Script.fromScriptSig=function(str){var script=new Script;var s=str.split(" ");for(var i in s){if(Opcode.map.hasOwnProperty(s[i])){script.writeOp(Opcode.map[s[i]])}else{script.writeBytes(convert.hexToBytes(s[i]))}}return script};Script.prototype.parse=function(){var self=this;this.chunks=[];var i=0;function readChunk(n){self.chunks.push(self.buffer.slice(i,i+n));i+=n}while(i<this.buffer.length){var opcode=this.buffer[i++];if(opcode>=240){opcode=opcode<<8|this.buffer[i++]}var len;if(opcode>0&&opcode<Opcode.map.OP_PUSHDATA1){readChunk(opcode)}else if(opcode==Opcode.map.OP_PUSHDATA1){len=this.buffer[i++];readChunk(len)}else if(opcode==Opcode.map.OP_PUSHDATA2){len=this.buffer[i++]<<8|this.buffer[i++];readChunk(len)}else if(opcode==Opcode.map.OP_PUSHDATA4){len=this.buffer[i++]<<24|this.buffer[i++]<<16|this.buffer[i++]<<8|this.buffer[i++];readChunk(len)}else{this.chunks.push(opcode)}}};Script.prototype.getOutType=function(){if(this.chunks[this.chunks.length-1]==Opcode.map.OP_EQUAL&&this.chunks[0]==Opcode.map.OP_HASH160&&this.chunks.length==3){return"P2SH"}else if(this.chunks.length==5&&this.chunks[0]==Opcode.map.OP_DUP&&this.chunks[1]==Opcode.map.OP_HASH160&&this.chunks[3]==Opcode.map.OP_EQUALVERIFY&&this.chunks[4]==Opcode.map.OP_CHECKSIG){return"Pubkey"}else{return"Strange"}};Script.prototype.toScriptHash=function(){var outType=this.getOutType();if(outType=="Pubkey"){return this.chunks[2]}if(outType=="P2SH"){return util.sha256ripe160(this.buffer)}return util.sha256ripe160(this.buffer)};Script.prototype.getToAddress=function(){var outType=this.getOutType();if(outType=="Pubkey"){return new Address(this.chunks[2])}if(outType=="P2SH"){return new Address(this.chunks[1],5)}return new Address(this.chunks[1],5)};Script.prototype.getFromAddress=function(){return new Address(this.simpleInHash())};Script.prototype.getInType=function(){if(this.chunks.length==1&&Array.isArray(this.chunks[0])){return"Pubkey"}else if(this.chunks.length==2&&Array.isArray(this.chunks[0])&&Array.isArray(this.chunks[1])){return"Address"}else if(this.chunks[0]==Opcode.map.OP_0&&this.chunks.slice(1).reduce(function(t,chunk,i){return t&&Array.isArray(chunk)&&(chunk[0]==48||i==this.chunks.length-1)},true)){return"Multisig"}else{return"Strange"}};Script.prototype.simpleInPubKey=function(){switch(this.getInType()){case"Address":return this.chunks[1];case"Pubkey":throw new Error("Script does not contain pubkey");default:throw new Error("Encountered non-standard scriptSig")}};Script.prototype.simpleInHash=function(){return util.sha256ripe160(this.simpleInPubKey())};Script.prototype.simpleInPubKeyHash=Script.prototype.simpleInHash;Script.prototype.writeOp=function(opcode){this.buffer.push(opcode);this.chunks.push(opcode)};Script.prototype.writeBytes=function(data){if(Buffer.isBuffer(data)){data=Array.prototype.map.bind(data,function(x){return x})()}if(data.length<Opcode.map.OP_PUSHDATA1){this.buffer.push(data.length)}else if(data.length<=255){this.buffer.push(Opcode.map.OP_PUSHDATA1);this.buffer.push(data.length)}else if(data.length<=65535){this.buffer.push(Opcode.map.OP_PUSHDATA2);this.buffer.push(data.length&255);this.buffer.push(data.length>>>8&255)}else{this.buffer.push(Opcode.map.OP_PUSHDATA4);this.buffer.push(data.length&255);this.buffer.push(data.length>>>8&255);this.buffer.push(data.length>>>16&255);this.buffer.push(data.length>>>24&255)}this.buffer=this.buffer.concat(data);this.chunks.push(data)};Script.createOutputScript=function(address){var script=new Script;address=new Address(address);if(address.version==network.mainnet.p2shVersion||address.version==network.testnet.p2shVersion){script.writeOp(Opcode.map.OP_HASH160);script.writeBytes(address.hash);script.writeOp(Opcode.map.OP_EQUAL)}else{script.writeOp(Opcode.map.OP_DUP);script.writeOp(Opcode.map.OP_HASH160);script.writeBytes(address.hash);script.writeOp(Opcode.map.OP_EQUALVERIFY);script.writeOp(Opcode.map.OP_CHECKSIG)}return script};Script.prototype.extractPubkeys=function(){return this.chunks.filter(function(chunk){return chunk[0]==4&&chunk.length==65||chunk[0]<4&&chunk.length==33})};Script.createMultiSigOutputScript=function(m,pubkeys){var script=new Script;pubkeys=pubkeys.sort();script.writeOp(Opcode.map.OP_1+m-1);for(var i=0;i<pubkeys.length;++i){script.writeBytes(pubkeys[i])}script.writeOp(Opcode.map.OP_1+pubkeys.length-1);script.writeOp(Opcode.map.OP_CHECKMULTISIG);return script};Script.createInputScript=function(signature,pubKey){var script=new Script;script.writeBytes(signature);script.writeBytes(pubKey);return script};Script.createMultiSigInputScript=function(signatures,script){script=new Script(script);var k=script.chunks[0][0];if(signatures.length<k)return false;var inScript=new Script;inScript.writeOp(Opcode.map.OP_0);signatures.map(function(sig){inScript.writeBytes(sig)});inScript.writeBytes(script.buffer);return inScript};Script.prototype.clone=function(){return new Script(this.buffer)};module.exports=Script}).call(this,_dereq_("buffer").Buffer)},{"./address":54,"./convert":57,"./network":66,"./opcode":67,"./util":70,buffer:5}],69:[function(_dereq_,module,exports){var BigInteger=_dereq_("./jsbn/jsbn");var Script=_dereq_("./script");var util=_dereq_("./util");var convert=_dereq_("./convert");var ECKey=_dereq_("./eckey").ECKey;var ECDSA=_dereq_("./ecdsa");var Address=_dereq_("./address");var SHA256=_dereq_("crypto-js/sha256");var Transaction=function(doc){if(!(this instanceof Transaction)){return new Transaction(doc)}this.version=1;this.locktime=0;this.ins=[];this.outs=[];this.defaultSequence=[255,255,255,255];if(doc){if(typeof doc=="string"||Array.isArray(doc)){doc=Transaction.deserialize(doc)}if(doc.hash)this.hash=doc.hash;if(doc.version)this.version=doc.version;if(doc.locktime)this.locktime=doc.locktime;if(doc.ins&&doc.ins.length){doc.ins.forEach(function(input){this.addInput(new TransactionIn(input))},this)}if(doc.outs&&doc.outs.length){doc.outs.forEach(function(output){this.addOutput(new TransactionOut(output))},this)}this.hash=this.hash||this.getHash()}};Transaction.prototype.addInput=function(tx,outIndex){if(arguments[0]instanceof TransactionIn){this.ins.push(arguments[0])}else if(arguments[0].length>65){var args=arguments[0].split(":");return this.addInput(args[0],args[1])}else{var hash=typeof tx==="string"?tx:tx.hash;hash=Array.isArray(hash)?convert.bytesToHex(hash):hash;this.ins.push(new TransactionIn({outpoint:{hash:hash,index:outIndex},script:new Script,sequence:this.defaultSequence}))}};Transaction.prototype.addOutput=function(address,value){if(arguments[0]instanceof TransactionOut){this.outs.push(arguments[0]);return}if(arguments[0].indexOf(":")>=0){var args=arguments[0].split(":");address=args[0];value=parseInt(args[1])}this.outs.push(new TransactionOut({value:value,script:Script.createOutputScript(address)}))};Transaction.prototype.serialize=function(){var buffer=[];buffer=buffer.concat(convert.numToBytes(parseInt(this.version),4));buffer=buffer.concat(convert.numToVarInt(this.ins.length));this.ins.forEach(function(txin){buffer=buffer.concat(convert.hexToBytes(txin.outpoint.hash).reverse());buffer=buffer.concat(convert.numToBytes(parseInt(txin.outpoint.index),4));var scriptBytes=txin.script.buffer;buffer=buffer.concat(convert.numToVarInt(scriptBytes.length));buffer=buffer.concat(scriptBytes);buffer=buffer.concat(txin.sequence)});buffer=buffer.concat(convert.numToVarInt(this.outs.length));this.outs.forEach(function(txout){buffer=buffer.concat(convert.numToBytes(txout.value,8));var scriptBytes=txout.script.buffer;buffer=buffer.concat(convert.numToVarInt(scriptBytes.length));buffer=buffer.concat(scriptBytes)});buffer=buffer.concat(convert.numToBytes(parseInt(this.locktime),4));return buffer};Transaction.prototype.serializeHex=function(){return convert.bytesToHex(this.serialize())};var SIGHASH_ALL=1;var SIGHASH_NONE=2;var SIGHASH_SINGLE=3;var SIGHASH_ANYONECANPAY=80;Transaction.prototype.hashTransactionForSignature=function(connectedScript,inIndex,hashType){var txTmp=this.clone();txTmp.ins.forEach(function(txin){txin.script=new Script});txTmp.ins[inIndex].script=connectedScript;if((hashType&31)==SIGHASH_NONE){txTmp.outs=[];txTmp.ins.forEach(function(txin,i){if(i!=inIndex){txTmp.ins[i].sequence=0}})}else if((hashType&31)==SIGHASH_SINGLE){}if(hashType&SIGHASH_ANYONECANPAY){txTmp.ins=[txTmp.ins[inIndex]]}var buffer=txTmp.serialize();buffer=buffer.concat(convert.numToBytes(parseInt(hashType),4));buffer=convert.bytesToWordArray(buffer);return convert.wordArrayToBytes(SHA256(SHA256(buffer)))};Transaction.prototype.getHash=function(){var buffer=convert.bytesToWordArray(this.serialize());return convert.wordArrayToBytes(SHA256(SHA256(buffer))).reverse()};Transaction.prototype.clone=function(){var newTx=new Transaction;newTx.version=this.version;newTx.locktime=this.locktime;this.ins.forEach(function(txin){newTx.addInput(txin.clone())});this.outs.forEach(function(txout){newTx.addOutput(txout.clone())});return newTx};Transaction.deserialize=function(buffer){if(typeof buffer=="string"){buffer=convert.hexToBytes(buffer)}var pos=0;var readAsInt=function(bytes){if(bytes===0)return 0;pos++;return buffer[pos-1]+readAsInt(bytes-1)*256};var readVarInt=function(){var bytes=buffer.slice(pos,pos+9);var result=convert.varIntToNum(bytes);pos+=result.bytes.length;return result.number};var readBytes=function(bytes){pos+=bytes;return buffer.slice(pos-bytes,pos)};var readVarString=function(){var size=readVarInt();return readBytes(size)};var obj={ins:[],outs:[]};obj.version=readAsInt(4);var ins=readVarInt();var i;for(i=0;i<ins;i++){obj.ins.push({outpoint:{hash:convert.bytesToHex(readBytes(32).reverse()),index:readAsInt(4)},script:new Script(readVarString()),sequence:readBytes(4)})}var outs=readVarInt();for(i=0;i<outs;i++){obj.outs.push({value:convert.bytesToNum(readBytes(8)),script:new Script(readVarString())})}obj.locktime=readAsInt(4);return new Transaction(obj)};Transaction.prototype.sign=function(index,key,type){type=type||SIGHASH_ALL;key=new ECKey(key);var pub=key.getPub().toBytes(),hash160=util.sha256ripe160(pub),script=Script.createOutputScript(new Address(hash160)),hash=this.hashTransactionForSignature(script,index,type),sig=key.sign(hash).concat([type]);this.ins[index].script=Script.createInputScript(sig,pub)};Transaction.prototype.signWithKeys=function(keys,outputs,type){type=type||SIGHASH_ALL;var addrdata=keys.map(function(key){key=new ECKey(key);return{key:key,address:key.getAddress().toString()}});var hmap={};outputs.forEach(function(o){hmap[o.output]=o});for(var i=0;i<this.ins.length;i++){var outpoint=this.ins[i].outpoint.hash+":"+this.ins[i].outpoint.index;var histItem=hmap[outpoint];if(!histItem)continue;var thisInputAddrdata=addrdata.filter(function(a){return a.address==histItem.address});if(thisInputAddrdata.length===0)continue;this.sign(i,thisInputAddrdata[0].key)}};Transaction.prototype.p2shsign=function(index,script,key,type){script=new Script(script);key=new ECKey(key);type=type||SIGHASH_ALL;var hash=this.hashTransactionForSignature(script,index,type),sig=key.sign(hash).concat([type]);return sig};Transaction.prototype.multisign=Transaction.prototype.p2shsign;Transaction.prototype.applyMultisigs=function(index,script,sigs){this.ins[index].script=Script.createMultiSigInputScript(sigs,script)};Transaction.prototype.validateSig=function(index,script,sig,pub){script=new Script(script);var hash=this.hashTransactionForSignature(script,index,1);return ECDSA.verify(hash,convert.coerceToBytes(sig),convert.coerceToBytes(pub))};Transaction.feePerKb=2e4;Transaction.prototype.estimateFee=function(feePerKb){var uncompressedInSize=180;var outSize=34;var fixedPadding=34;if(feePerKb==undefined)feePerKb=Transaction.feePerKb;var size=this.ins.length*uncompressedInSize+this.outs.length*outSize+fixedPadding;return feePerKb*Math.ceil(size/1e3)};var TransactionIn=function(data){if(typeof data=="string"){this.outpoint={hash:data.split(":")[0],index:data.split(":")[1]}}else if(data.outpoint){this.outpoint=data.outpoint}else{this.outpoint={hash:data.hash,index:data.index}}if(data.scriptSig){this.script=Script.fromScriptSig(data.scriptSig)}else if(data.script){this.script=data.script}else{this.script=new Script(data.script)}this.sequence=data.sequence||this.defaultSequence};TransactionIn.prototype.clone=function(){return new TransactionIn({outpoint:{hash:this.outpoint.hash,index:this.outpoint.index},script:this.script.clone(),sequence:this.sequence})};var TransactionOut=function(data){this.script=data.script instanceof Script?data.script.clone():Array.isArray(data.script)?new Script(data.script):typeof data.script=="string"?new Script(convert.hexToBytes(data.script)):data.scriptPubKey?Script.fromScriptSig(data.scriptPubKey):data.address?Script.createOutputScript(data.address):new Script;if(this.script.buffer.length>0)this.address=this.script.getToAddress();this.value=Array.isArray(data.value)?convert.bytesToNum(data.value):"string"==typeof data.value?parseInt(data.value):data.value instanceof BigInteger?parseInt(data.value.toString()):data.value};TransactionOut.prototype.clone=function(){var newTxout=new TransactionOut({script:this.script.clone(),value:this.value});return newTxout};TransactionOut.prototype.scriptPubKey=function(){return convert.bytesToHex(this.script.buffer)};module.exports={Transaction:Transaction,TransactionIn:TransactionIn,TransactionOut:TransactionOut}},{"./address":54,"./convert":57,"./ecdsa":58,"./eckey":59,"./jsbn/jsbn":63,"./script":68,"./util":70,"crypto-js/sha256":47}],70:[function(_dereq_,module,exports){var convert=_dereq_("./convert.js");var Crypto=_dereq_("crypto-js");var RIPEMD160=Crypto.RIPEMD160;var SHA256=Crypto.SHA256;exports.sha256ripe160=function(data){var wordArray=RIPEMD160(SHA256(convert.bytesToWordArray(data)));return convert.wordArrayToBytes(wordArray)};exports.error=function(msg){throw new Error(msg)}},{"./convert.js":57,"crypto-js":27}],71:[function(_dereq_,module,exports){(function(process){var convert=_dereq_("./convert");var Transaction=_dereq_("./transaction").Transaction;var HDNode=_dereq_("./hdwallet.js");var rng=_dereq_("secure-random");function Wallet(seed,options){if(!(this instanceof Wallet)){return new Wallet(seed,options)}var options=options||{};var network=options.network||"mainnet";var masterkey=null;var me=this;var accountZero=null;var internalAccount=null;var externalAccount=null;this.addresses=[];this.changeAddresses=[];this.outputs={};this.newMasterKey=function(seed,network){if(!seed)seed=rng(32,{array:true});masterkey=new HDNode(seed,network);accountZero=masterkey.derivePrivate(0);externalAccount=accountZero.derive(0);internalAccount=accountZero.derive(1);me.addresses=[];me.changeAddresses=[];me.outputs={}};this.newMasterKey(seed,network);this.generateAddress=function(){var key=externalAccount.derive(this.addresses.length);this.addresses.push(key.getAddress().toString());return this.addresses[this.addresses.length-1]};this.generateChangeAddress=function(){var key=internalAccount.derive(this.changeAddresses.length);this.changeAddresses.push(key.getAddress().toString());return this.changeAddresses[this.changeAddresses.length-1]};this.getBalance=function(){return this.getUnspentOutputs().reduce(function(memo,output){return memo+output.value},0)};this.getUnspentOutputs=function(){var utxo=[];for(var key in this.outputs){var output=this.outputs[key];if(!output.spend)utxo.push(outputToUnspentOutput(output))}return utxo};this.setUnspentOutputs=function(utxo){var outputs={};utxo.forEach(function(uo){validateUnspentOutput(uo);var o=unspentOutputToOutput(uo);outputs[o.receive]=o});this.outputs=outputs};this.setUnspentOutputsAsync=function(utxo,callback){var error=null;try{this.setUnspentOutputs(utxo)}catch(err){error=err}finally{process.nextTick(function(){callback(error)})}};function outputToUnspentOutput(output){var hashAndIndex=output.receive.split(":");return{hash:hashAndIndex[0],hashLittleEndian:convert.reverseEndian(hashAndIndex[0]),outputIndex:parseInt(hashAndIndex[1]),address:output.address,value:output.value}}function unspentOutputToOutput(o){var hash=o.hash||convert.reverseEndian(o.hashLittleEndian);var key=hash+":"+o.outputIndex;return{receive:key,address:o.address,value:o.value}}function validateUnspentOutput(uo){var missingField;if(isNullOrUndefined(uo.hash)&&isNullOrUndefined(uo.hashLittleEndian)){missingField="hash(or hashLittleEndian)"}var requiredKeys=["outputIndex","address","value"];requiredKeys.forEach(function(key){if(isNullOrUndefined(uo[key])){missingField=key}});if(missingField){var message=["Invalid unspent output: key",missingField,"is missing.","A valid unspent output must contain"];message.push(requiredKeys.join(", "));message.push("and hash(or hashLittleEndian)");throw new Error(message.join(" "))}}function isNullOrUndefined(value){return value==undefined}this.processTx=function(tx){var txhash=convert.bytesToHex(tx.getHash());tx.outs.forEach(function(txOut,i){var address=txOut.address.toString();if(isMyAddress(address)){var output=txhash+":"+i;me.outputs[output]={receive:output,value:txOut.value,address:address}}});tx.ins.forEach(function(txIn,i){var op=txIn.outpoint;var o=me.outputs[op.hash+":"+op.index];if(o){o.spend=txhash+":"+i}})};this.createTx=function(to,value,fixedFee){checkDust(value);var tx=new Transaction;tx.addOutput(to,value);var utxo=getCandidateOutputs(value);var totalInValue=0;for(var i=0;i<utxo.length;i++){var output=utxo[i];tx.addInput(output.receive);totalInValue+=output.value;if(totalInValue<value)continue;var fee=fixedFee==undefined?estimateFeePadChangeOutput(tx):fixedFee;if(totalInValue<value+fee)continue;var change=totalInValue-value-fee;if(change>0&&!isDust(change)){tx.addOutput(getChangeAddress(),change)}break}checkInsufficientFund(totalInValue,value,fee);this.sign(tx);return tx};this.createTxAsync=function(to,value,fixedFee,callback){if(fixedFee instanceof Function){callback=fixedFee;fixedFee=undefined}var tx=null;var error=null;try{tx=this.createTx(to,value,fixedFee)}catch(err){error=err}finally{process.nextTick(function(){callback(error,tx)})}};this.dustThreshold=5430;function isDust(amount){return amount<=me.dustThreshold}function checkDust(value){if(isNullOrUndefined(value)||isDust(value)){throw new Error("Value must be above dust threshold")}}function getCandidateOutputs(value){var unspent=[];for(var key in me.outputs){var output=me.outputs[key];if(!output.spend)unspent.push(output)}var sortByValueDesc=unspent.sort(function(o1,o2){return o2.value-o1.value});return sortByValueDesc}function estimateFeePadChangeOutput(tx){var tmpTx=tx.clone();tmpTx.addOutput(getChangeAddress(),0);return tmpTx.estimateFee()}function getChangeAddress(){if(me.changeAddresses.length===0)me.generateChangeAddress();return me.changeAddresses[me.changeAddresses.length-1]}function checkInsufficientFund(totalInValue,value,fee){if(totalInValue<value+fee){throw new Error("Not enough money to send funds including transaction fee. Have: "+totalInValue+", needed: "+(value+fee))}}this.sign=function(tx){tx.ins.forEach(function(inp,i){var output=me.outputs[inp.outpoint.hash+":"+inp.outpoint.index];if(output){tx.sign(i,me.getPrivateKeyForAddress(output.address))}});return tx};this.getMasterKey=function(){return masterkey};this.getAccountZero=function(){return accountZero};this.getInternalAccount=function(){return internalAccount};this.getExternalAccount=function(){return externalAccount};this.getPrivateKey=function(index){return externalAccount.derive(index).priv};this.getInternalPrivateKey=function(index){return internalAccount.derive(index).priv};this.getPrivateKeyForAddress=function(address){var index;if((index=this.addresses.indexOf(address))>-1){return this.getPrivateKey(index)}else if((index=this.changeAddresses.indexOf(address))>-1){return this.getInternalPrivateKey(index)}else{throw new Error("Unknown address. Make sure the address is from the keychain and has been generated.")}};function isReceiveAddress(address){return me.addresses.indexOf(address)>-1}function isChangeAddress(address){return me.changeAddresses.indexOf(address)>-1}function isMyAddress(address){return isReceiveAddress(address)||isChangeAddress(address)}}module.exports=Wallet}).call(this,_dereq_("FWaASH"))},{"./convert":57,"./hdwallet.js":60,"./transaction":69,FWaASH:15,"secure-random":53}]},{},[61])(61)});
/*! peerjs.js build:0.3.8, development. Copyright(c) 2013 Michelle Bu <michelle@michellebu.com> */
(function(exports){
  //Hack to get peer.js to work in a worker
  if(typeof window === "undefined") {
   var window={};
  }
var binaryFeatures = {};
binaryFeatures.useBlobBuilder = (function(){
  try {
    new Blob([]);
    return false;
  } catch (e) {
    return true;
  }
})();

binaryFeatures.useArrayBufferView = !binaryFeatures.useBlobBuilder && (function(){
  try {
    return (new Blob([new Uint8Array([])])).size === 0;
  } catch (e) {
    return true;
  }
})();

exports.binaryFeatures = binaryFeatures;


  exports.BlobBuilder = window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder;


  function BufferBuilder(){
  this._pieces = [];
  this._parts = [];
}

BufferBuilder.prototype.append = function(data) {
  if(typeof data === 'number') {
    this._pieces.push(data);
  } else {
    this.flush();
    this._parts.push(data);
  }
};

BufferBuilder.prototype.flush = function() {
  if (this._pieces.length > 0) {
    var buf = new Uint8Array(this._pieces);
    if(!binaryFeatures.useArrayBufferView) {
      buf = buf.buffer;
    }
    this._parts.push(buf);
    this._pieces = [];
  }
};

BufferBuilder.prototype.getBuffer = function() {
  this.flush();
  if(binaryFeatures.useBlobBuilder) {
    var builder = new BlobBuilder();
    for(var i = 0, ii = this._parts.length; i < ii; i++) {
      builder.append(this._parts[i]);
    }
    return builder.getBlob();
  } else {
    return new Blob(this._parts);
  }
};
exports.BinaryPack = {
  unpack: function(data){
    var unpacker = new Unpacker(data);
    return unpacker.unpack();
  },
  pack: function(data){
    var packer = new Packer();
    packer.pack(data);
    var buffer = packer.getBuffer();
    return buffer;
  }
};

function Unpacker (data){
  // Data is ArrayBuffer
  this.index = 0;
  this.dataBuffer = data;
  this.dataView = new Uint8Array(this.dataBuffer);
  this.length = this.dataBuffer.byteLength;
}


Unpacker.prototype.unpack = function(){
  var type = this.unpack_uint8();
  if (type < 0x80){
    var positive_fixnum = type;
    return positive_fixnum;
  } else if ((type ^ 0xe0) < 0x20){
    var negative_fixnum = (type ^ 0xe0) - 0x20;
    return negative_fixnum;
  }
  var size;
  if ((size = type ^ 0xa0) <= 0x0f){
    return this.unpack_raw(size);
  } else if ((size = type ^ 0xb0) <= 0x0f){
    return this.unpack_string(size);
  } else if ((size = type ^ 0x90) <= 0x0f){
    return this.unpack_array(size);
  } else if ((size = type ^ 0x80) <= 0x0f){
    return this.unpack_map(size);
  }
  switch(type){
    case 0xc0:
      return null;
    case 0xc1:
      return undefined;
    case 0xc2:
      return false;
    case 0xc3:
      return true;
    case 0xca:
      return this.unpack_float();
    case 0xcb:
      return this.unpack_double();
    case 0xcc:
      return this.unpack_uint8();
    case 0xcd:
      return this.unpack_uint16();
    case 0xce:
      return this.unpack_uint32();
    case 0xcf:
      return this.unpack_uint64();
    case 0xd0:
      return this.unpack_int8();
    case 0xd1:
      return this.unpack_int16();
    case 0xd2:
      return this.unpack_int32();
    case 0xd3:
      return this.unpack_int64();
    case 0xd4:
      return undefined;
    case 0xd5:
      return undefined;
    case 0xd6:
      return undefined;
    case 0xd7:
      return undefined;
    case 0xd8:
      size = this.unpack_uint16();
      return this.unpack_string(size);
    case 0xd9:
      size = this.unpack_uint32();
      return this.unpack_string(size);
    case 0xda:
      size = this.unpack_uint16();
      return this.unpack_raw(size);
    case 0xdb:
      size = this.unpack_uint32();
      return this.unpack_raw(size);
    case 0xdc:
      size = this.unpack_uint16();
      return this.unpack_array(size);
    case 0xdd:
      size = this.unpack_uint32();
      return this.unpack_array(size);
    case 0xde:
      size = this.unpack_uint16();
      return this.unpack_map(size);
    case 0xdf:
      size = this.unpack_uint32();
      return this.unpack_map(size);
  }
}

Unpacker.prototype.unpack_uint8 = function(){
  var byte = this.dataView[this.index] & 0xff;
  this.index++;
  return byte;
};

Unpacker.prototype.unpack_uint16 = function(){
  var bytes = this.read(2);
  var uint16 =
    ((bytes[0] & 0xff) * 256) + (bytes[1] & 0xff);
  this.index += 2;
  return uint16;
}

Unpacker.prototype.unpack_uint32 = function(){
  var bytes = this.read(4);
  var uint32 =
     ((bytes[0]  * 256 +
       bytes[1]) * 256 +
       bytes[2]) * 256 +
       bytes[3];
  this.index += 4;
  return uint32;
}

Unpacker.prototype.unpack_uint64 = function(){
  var bytes = this.read(8);
  var uint64 =
   ((((((bytes[0]  * 256 +
       bytes[1]) * 256 +
       bytes[2]) * 256 +
       bytes[3]) * 256 +
       bytes[4]) * 256 +
       bytes[5]) * 256 +
       bytes[6]) * 256 +
       bytes[7];
  this.index += 8;
  return uint64;
}


Unpacker.prototype.unpack_int8 = function(){
  var uint8 = this.unpack_uint8();
  return (uint8 < 0x80 ) ? uint8 : uint8 - (1 << 8);
};

Unpacker.prototype.unpack_int16 = function(){
  var uint16 = this.unpack_uint16();
  return (uint16 < 0x8000 ) ? uint16 : uint16 - (1 << 16);
}

Unpacker.prototype.unpack_int32 = function(){
  var uint32 = this.unpack_uint32();
  return (uint32 < Math.pow(2, 31) ) ? uint32 :
    uint32 - Math.pow(2, 32);
}

Unpacker.prototype.unpack_int64 = function(){
  var uint64 = this.unpack_uint64();
  return (uint64 < Math.pow(2, 63) ) ? uint64 :
    uint64 - Math.pow(2, 64);
}

Unpacker.prototype.unpack_raw = function(size){
  if ( this.length < this.index + size){
    throw new Error('BinaryPackFailure: index is out of range'
      + ' ' + this.index + ' ' + size + ' ' + this.length);
  }
  var buf = this.dataBuffer.slice(this.index, this.index + size);
  this.index += size;

    //buf = util.bufferToString(buf);

  return buf;
}

Unpacker.prototype.unpack_string = function(size){
  var bytes = this.read(size);
  var i = 0, str = '', c, code;
  while(i < size){
    c = bytes[i];
    if ( c < 128){
      str += String.fromCharCode(c);
      i++;
    } else if ((c ^ 0xc0) < 32){
      code = ((c ^ 0xc0) << 6) | (bytes[i+1] & 63);
      str += String.fromCharCode(code);
      i += 2;
    } else {
      code = ((c & 15) << 12) | ((bytes[i+1] & 63) << 6) |
        (bytes[i+2] & 63);
      str += String.fromCharCode(code);
      i += 3;
    }
  }
  this.index += size;
  return str;
}

Unpacker.prototype.unpack_array = function(size){
  var objects = new Array(size);
  for(var i = 0; i < size ; i++){
    objects[i] = this.unpack();
  }
  return objects;
}

Unpacker.prototype.unpack_map = function(size){
  var map = {};
  for(var i = 0; i < size ; i++){
    var key  = this.unpack();
    var value = this.unpack();
    map[key] = value;
  }
  return map;
}

Unpacker.prototype.unpack_float = function(){
  var uint32 = this.unpack_uint32();
  var sign = uint32 >> 31;
  var exp  = ((uint32 >> 23) & 0xff) - 127;
  var fraction = ( uint32 & 0x7fffff ) | 0x800000;
  return (sign == 0 ? 1 : -1) *
    fraction * Math.pow(2, exp - 23);
}

Unpacker.prototype.unpack_double = function(){
  var h32 = this.unpack_uint32();
  var l32 = this.unpack_uint32();
  var sign = h32 >> 31;
  var exp  = ((h32 >> 20) & 0x7ff) - 1023;
  var hfrac = ( h32 & 0xfffff ) | 0x100000;
  var frac = hfrac * Math.pow(2, exp - 20) +
    l32   * Math.pow(2, exp - 52);
  return (sign == 0 ? 1 : -1) * frac;
}

Unpacker.prototype.read = function(length){
  var j = this.index;
  if (j + length <= this.length) {
    return this.dataView.subarray(j, j + length);
  } else {
    throw new Error('BinaryPackFailure: read index out of range');
  }
}

function Packer(){
  this.bufferBuilder = new BufferBuilder();
}

Packer.prototype.getBuffer = function(){
  return this.bufferBuilder.getBuffer();
}

Packer.prototype.pack = function(value){
  var type = typeof(value);
  if (type == 'string'){
    this.pack_string(value);
  } else if (type == 'number'){
    if (Math.floor(value) === value){
      this.pack_integer(value);
    } else{
      this.pack_double(value);
    }
  } else if (type == 'boolean'){
    if (value === true){
      this.bufferBuilder.append(0xc3);
    } else if (value === false){
      this.bufferBuilder.append(0xc2);
    }
  } else if (type == 'undefined'){
    this.bufferBuilder.append(0xc0);
  } else if (type == 'object'){
    if (value === null){
      this.bufferBuilder.append(0xc0);
    } else {
      var constructor = value.constructor;
      if (constructor == Array){
        this.pack_array(value);
      } else if (constructor == Blob || constructor == File) {
        this.pack_bin(value);
      } else if (constructor == ArrayBuffer) {
        if(binaryFeatures.useArrayBufferView) {
          this.pack_bin(new Uint8Array(value));
        } else {
          this.pack_bin(value);
        }
      } else if ('BYTES_PER_ELEMENT' in value){
        if(binaryFeatures.useArrayBufferView) {
          this.pack_bin(new Uint8Array(value.buffer));
        } else {
          this.pack_bin(value.buffer);
        }
      } else if (constructor == Object){
        this.pack_object(value);
      } else if (constructor == Date){
        this.pack_string(value.toString());
      } else if (typeof value.toBinaryPack == 'function'){
        this.bufferBuilder.append(value.toBinaryPack());
      } else {
        throw new Error('Type "' + constructor.toString() + '" not yet supported');
      }
    }
  } else {
    throw new Error('Type "' + type + '" not yet supported');
  }
  this.bufferBuilder.flush();
}


Packer.prototype.pack_bin = function(blob){
  var length = blob.length || blob.byteLength || blob.size;
  if (length <= 0x0f){
    this.pack_uint8(0xa0 + length);
  } else if (length <= 0xffff){
    this.bufferBuilder.append(0xda) ;
    this.pack_uint16(length);
  } else if (length <= 0xffffffff){
    this.bufferBuilder.append(0xdb);
    this.pack_uint32(length);
  } else{
    throw new Error('Invalid length');
    return;
  }
  this.bufferBuilder.append(blob);
}

Packer.prototype.pack_string = function(str){
  var length = utf8Length(str);

  if (length <= 0x0f){
    this.pack_uint8(0xb0 + length);
  } else if (length <= 0xffff){
    this.bufferBuilder.append(0xd8) ;
    this.pack_uint16(length);
  } else if (length <= 0xffffffff){
    this.bufferBuilder.append(0xd9);
    this.pack_uint32(length);
  } else{
    throw new Error('Invalid length');
    return;
  }
  this.bufferBuilder.append(str);
}

Packer.prototype.pack_array = function(ary){
  var length = ary.length;
  if (length <= 0x0f){
    this.pack_uint8(0x90 + length);
  } else if (length <= 0xffff){
    this.bufferBuilder.append(0xdc)
    this.pack_uint16(length);
  } else if (length <= 0xffffffff){
    this.bufferBuilder.append(0xdd);
    this.pack_uint32(length);
  } else{
    throw new Error('Invalid length');
  }
  for(var i = 0; i < length ; i++){
    this.pack(ary[i]);
  }
}

Packer.prototype.pack_integer = function(num){
  if ( -0x20 <= num && num <= 0x7f){
    this.bufferBuilder.append(num & 0xff);
  } else if (0x00 <= num && num <= 0xff){
    this.bufferBuilder.append(0xcc);
    this.pack_uint8(num);
  } else if (-0x80 <= num && num <= 0x7f){
    this.bufferBuilder.append(0xd0);
    this.pack_int8(num);
  } else if ( 0x0000 <= num && num <= 0xffff){
    this.bufferBuilder.append(0xcd);
    this.pack_uint16(num);
  } else if (-0x8000 <= num && num <= 0x7fff){
    this.bufferBuilder.append(0xd1);
    this.pack_int16(num);
  } else if ( 0x00000000 <= num && num <= 0xffffffff){
    this.bufferBuilder.append(0xce);
    this.pack_uint32(num);
  } else if (-0x80000000 <= num && num <= 0x7fffffff){
    this.bufferBuilder.append(0xd2);
    this.pack_int32(num);
  } else if (-0x8000000000000000 <= num && num <= 0x7FFFFFFFFFFFFFFF){
    this.bufferBuilder.append(0xd3);
    this.pack_int64(num);
  } else if (0x0000000000000000 <= num && num <= 0xFFFFFFFFFFFFFFFF){
    this.bufferBuilder.append(0xcf);
    this.pack_uint64(num);
  } else{
    throw new Error('Invalid integer');
  }
}

Packer.prototype.pack_double = function(num){
  var sign = 0;
  if (num < 0){
    sign = 1;
    num = -num;
  }
  var exp  = Math.floor(Math.log(num) / Math.LN2);
  var frac0 = num / Math.pow(2, exp) - 1;
  var frac1 = Math.floor(frac0 * Math.pow(2, 52));
  var b32   = Math.pow(2, 32);
  var h32 = (sign << 31) | ((exp+1023) << 20) |
      (frac1 / b32) & 0x0fffff;
  var l32 = frac1 % b32;
  this.bufferBuilder.append(0xcb);
  this.pack_int32(h32);
  this.pack_int32(l32);
}

Packer.prototype.pack_object = function(obj){
  var keys = Object.keys(obj);
  var length = keys.length;
  if (length <= 0x0f){
    this.pack_uint8(0x80 + length);
  } else if (length <= 0xffff){
    this.bufferBuilder.append(0xde);
    this.pack_uint16(length);
  } else if (length <= 0xffffffff){
    this.bufferBuilder.append(0xdf);
    this.pack_uint32(length);
  } else{
    throw new Error('Invalid length');
  }
  for(var prop in obj){
    if (obj.hasOwnProperty(prop)){
      this.pack(prop);
      this.pack(obj[prop]);
    }
  }
}

Packer.prototype.pack_uint8 = function(num){
  this.bufferBuilder.append(num);
}

Packer.prototype.pack_uint16 = function(num){
  this.bufferBuilder.append(num >> 8);
  this.bufferBuilder.append(num & 0xff);
}

Packer.prototype.pack_uint32 = function(num){
  var n = num & 0xffffffff;
  this.bufferBuilder.append((n & 0xff000000) >>> 24);
  this.bufferBuilder.append((n & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((n & 0x0000ff00) >>>  8);
  this.bufferBuilder.append((n & 0x000000ff));
}

Packer.prototype.pack_uint64 = function(num){
  var high = num / Math.pow(2, 32);
  var low  = num % Math.pow(2, 32);
  this.bufferBuilder.append((high & 0xff000000) >>> 24);
  this.bufferBuilder.append((high & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((high & 0x0000ff00) >>>  8);
  this.bufferBuilder.append((high & 0x000000ff));
  this.bufferBuilder.append((low  & 0xff000000) >>> 24);
  this.bufferBuilder.append((low  & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((low  & 0x0000ff00) >>>  8);
  this.bufferBuilder.append((low  & 0x000000ff));
}

Packer.prototype.pack_int8 = function(num){
  this.bufferBuilder.append(num & 0xff);
}

Packer.prototype.pack_int16 = function(num){
  this.bufferBuilder.append((num & 0xff00) >> 8);
  this.bufferBuilder.append(num & 0xff);
}

Packer.prototype.pack_int32 = function(num){
  this.bufferBuilder.append((num >>> 24) & 0xff);
  this.bufferBuilder.append((num & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((num & 0x0000ff00) >>> 8);
  this.bufferBuilder.append((num & 0x000000ff));
}

Packer.prototype.pack_int64 = function(num){
  var high = Math.floor(num / Math.pow(2, 32));
  var low  = num % Math.pow(2, 32);
  this.bufferBuilder.append((high & 0xff000000) >>> 24);
  this.bufferBuilder.append((high & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((high & 0x0000ff00) >>>  8);
  this.bufferBuilder.append((high & 0x000000ff));
  this.bufferBuilder.append((low  & 0xff000000) >>> 24);
  this.bufferBuilder.append((low  & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((low  & 0x0000ff00) >>>  8);
  this.bufferBuilder.append((low  & 0x000000ff));
}

function _utf8Replace(m){
  var code = m.charCodeAt(0);

  if(code <= 0x7ff) return '00';
  if(code <= 0xffff) return '000';
  if(code <= 0x1fffff) return '0000';
  if(code <= 0x3ffffff) return '00000';
  return '000000';
}

function utf8Length(str){
  if (str.length > 600) {
    // Blob method faster for large strings
    return (new Blob([str])).size;
  } else {
    return str.replace(/[^\u0000-\u007F]/g, _utf8Replace).length;
  }
}
/**
 * Light EventEmitter. Ported from Node.js/events.js
 * Eric Zhang
 */

/**
 * EventEmitter class
 * Creates an object with event registering and firing methods
 */
function EventEmitter() {
  // Initialise required storage variables
  this._events = {};
}

var isArray = Array.isArray;


EventEmitter.prototype.addListener = function(type, listener, scope, once) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }
  
  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, typeof listener.listener === 'function' ?
            listener.listener : listener);
            
  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // If we've already got an array, just append.
    this._events[type].push(listener);

  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }
  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener, scope) {
  if ('function' !== typeof listener) {
    throw new Error('.once only takes instances of Function');
  }

  var self = this;
  function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  };

  g.listener = listener;
  self.on(type, g);

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener, scope) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var position = -1;
    for (var i = 0, length = list.length; i < length; i++) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener))
      {
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    list.splice(position, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (list === listener ||
             (list.listener && list.listener === listener))
  {
    delete this._events[type];
  }

  return this;
};


EventEmitter.prototype.off = EventEmitter.prototype.removeListener;


EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

EventEmitter.prototype.emit = function(type) {
  var type = arguments[0];
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var l = arguments.length;
        var args = new Array(l - 1);
        for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var l = arguments.length;
    var args = new Array(l - 1);
    for (var i = 1; i < l; i++) args[i - 1] = arguments[i];

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;
  } else {
    return false;
  }
};



/**
 * Reliable transfer for Chrome Canary DataChannel impl.
 * Author: @michellebu
 */
function Reliable(dc, debug) {
  if (!(this instanceof Reliable)) return new Reliable(dc);
  this._dc = dc;

  util.debug = debug;

  // Messages sent/received so far.
  // id: { ack: n, chunks: [...] }
  this._outgoing = {};
  // id: { ack: ['ack', id, n], chunks: [...] }
  this._incoming = {};
  this._received = {};

  // Window size.
  this._window = 1000;
  // MTU.
  this._mtu = 500;
  // Interval for setInterval. In ms.
  this._interval = 0;

  // Messages sent.
  this._count = 0;

  // Outgoing message queue.
  this._queue = [];

  this._setupDC();
};

// Send a message reliably.
Reliable.prototype.send = function(msg) {
  // Determine if chunking is necessary.
  var bl = util.pack(msg);
  if (bl.size < this._mtu) {
    this._handleSend(['no', bl]);
    return;
  }

  this._outgoing[this._count] = {
    ack: 0,
    chunks: this._chunk(bl)
  };

  if (util.debug) {
    this._outgoing[this._count].timer = new Date();
  }

  // Send prelim window.
  this._sendWindowedChunks(this._count);
  this._count += 1;
};

// Set up interval for processing queue.
Reliable.prototype._setupInterval = function() {
  // TODO: fail gracefully.

  var self = this;
  this._timeout = setInterval(function() {
    // FIXME: String stuff makes things terribly async.
    var msg = self._queue.shift();
    if (msg._multiple) {
      for (var i = 0, ii = msg.length; i < ii; i += 1) {
        self._intervalSend(msg[i]);
      }
    } else {
      self._intervalSend(msg);
    }
  }, this._interval);
};

Reliable.prototype._intervalSend = function(msg) {
  var self = this;
  msg = util.pack(msg);
  util.blobToBinaryString(msg, function(str) {
    self._dc.send(str);
  });
  if (self._queue.length === 0) {
    clearTimeout(self._timeout);
    self._timeout = null;
    //self._processAcks();
  }
};

// Go through ACKs to send missing pieces.
Reliable.prototype._processAcks = function() {
  for (var id in this._outgoing) {
    if (this._outgoing.hasOwnProperty(id)) {
      this._sendWindowedChunks(id);
    }
  }
};

// Handle sending a message.
// FIXME: Don't wait for interval time for all messages...
Reliable.prototype._handleSend = function(msg) {
  var push = true;
  for (var i = 0, ii = this._queue.length; i < ii; i += 1) {
    var item = this._queue[i];
    if (item === msg) {
      push = false;
    } else if (item._multiple && item.indexOf(msg) !== -1) {
      push = false;
    }
  }
  if (push) {
    this._queue.push(msg);
    if (!this._timeout) {
      this._setupInterval();
    }
  }
};

// Set up DataChannel handlers.
Reliable.prototype._setupDC = function() {
  // Handle various message types.
  var self = this;
  this._dc.onmessage = function(e) {
    var msg = e.data;
    var datatype = msg.constructor;
    // FIXME: msg is String until binary is supported.
    // Once that happens, this will have to be smarter.
    if (datatype === String) {
      var ab = util.binaryStringToArrayBuffer(msg);
      msg = util.unpack(ab);
      self._handleMessage(msg);
    }
  };
};

// Handles an incoming message.
Reliable.prototype._handleMessage = function(msg) {
  var id = msg[1];
  var idata = this._incoming[id];
  var odata = this._outgoing[id];
  var data;
  switch (msg[0]) {
    // No chunking was done.
    case 'no':
      var message = id;
      if (!!message) {
        this.onmessage(util.unpack(message));
      }
      break;
    // Reached the end of the message.
    case 'end':
      data = idata;

      // In case end comes first.
      this._received[id] = msg[2];

      if (!data) {
        break;
      }

      this._ack(id);
      break;
    case 'ack':
      data = odata;
      if (!!data) {
        var ack = msg[2];
        // Take the larger ACK, for out of order messages.
        data.ack = Math.max(ack, data.ack);

        // Clean up when all chunks are ACKed.
        if (data.ack >= data.chunks.length) {
          util.log('Time: ', new Date() - data.timer);
          delete this._outgoing[id];
        } else {
          this._processAcks();
        }
      }
      // If !data, just ignore.
      break;
    // Received a chunk of data.
    case 'chunk':
      // Create a new entry if none exists.
      data = idata;
      if (!data) {
        var end = this._received[id];
        if (end === true) {
          break;
        }
        data = {
          ack: ['ack', id, 0],
          chunks: []
        };
        this._incoming[id] = data;
      }

      var n = msg[2];
      var chunk = msg[3];
      data.chunks[n] = new Uint8Array(chunk);

      // If we get the chunk we're looking for, ACK for next missing.
      // Otherwise, ACK the same N again.
      if (n === data.ack[2]) {
        this._calculateNextAck(id);
      }
      this._ack(id);
      break;
    default:
      // Shouldn't happen, but would make sense for message to just go
      // through as is.
      this._handleSend(msg);
      break;
  }
};

// Chunks BL into smaller messages.
Reliable.prototype._chunk = function(bl) {
  var chunks = [];
  var size = bl.size;
  var start = 0;
  while (start < size) {
    var end = Math.min(size, start + this._mtu);
    var b = bl.slice(start, end);
    var chunk = {
      payload: b
    }
    chunks.push(chunk);
    start = end;
  }
  util.log('Created', chunks.length, 'chunks.');
  return chunks;
};

// Sends ACK N, expecting Nth blob chunk for message ID.
Reliable.prototype._ack = function(id) {
  var ack = this._incoming[id].ack;

  // if ack is the end value, then call _complete.
  if (this._received[id] === ack[2]) {
    this._complete(id);
    this._received[id] = true;
  }

  this._handleSend(ack);
};

// Calculates the next ACK number, given chunks.
Reliable.prototype._calculateNextAck = function(id) {
  var data = this._incoming[id];
  var chunks = data.chunks;
  for (var i = 0, ii = chunks.length; i < ii; i += 1) {
    // This chunk is missing!!! Better ACK for it.
    if (chunks[i] === undefined) {
      data.ack[2] = i;
      return;
    }
  }
  data.ack[2] = chunks.length;
};

// Sends the next window of chunks.
Reliable.prototype._sendWindowedChunks = function(id) {
  util.log('sendWindowedChunks for: ', id);
  var data = this._outgoing[id];
  var ch = data.chunks;
  var chunks = [];
  var limit = Math.min(data.ack + this._window, ch.length);
  for (var i = data.ack; i < limit; i += 1) {
    if (!ch[i].sent || i === data.ack) {
      ch[i].sent = true;
      chunks.push(['chunk', id, i, ch[i].payload]);
    }
  }
  if (data.ack + this._window >= ch.length) {
    chunks.push(['end', id, ch.length])
  }
  chunks._multiple = true;
  this._handleSend(chunks);
};

// Puts together a message from chunks.
Reliable.prototype._complete = function(id) {
  util.log('Completed called for', id);
  var self = this;
  var chunks = this._incoming[id].chunks;
  var bl = new Blob(chunks);
  util.blobToArrayBuffer(bl, function(ab) {
    self.onmessage(util.unpack(ab));
  });
  delete this._incoming[id];
};

// Ups bandwidth limit on SDP. Meant to be called during offer/answer.
Reliable.higherBandwidthSDP = function(sdp) {
  // AS stands for Application-Specific Maximum.
  // Bandwidth number is in kilobits / sec.
  // See RFC for more info: http://www.ietf.org/rfc/rfc2327.txt

  // Chrome 31+ doesn't want us munging the SDP, so we'll let them have their
  // way.
  var version = navigator.appVersion.match(/Chrome\/(.*?) /);
  if (version) {
    version = parseInt(version[1].split('.').shift());
    if (version < 31) {
      var parts = sdp.split('b=AS:30');
      var replace = 'b=AS:102400'; // 100 Mbps
      if (parts.length > 1) {
        return parts[0] + replace + parts[1];
      }
    }
  }

  return sdp;
};

// Overwritten, typically.
Reliable.prototype.onmessage = function(msg) {};

exports.Reliable = Reliable;
exports.RTCSessionDescription = window.mozRTCSessionDescription || window.RTCSessionDescription;
exports.RTCPeerConnection = window.mozRTCPeerConnection || window.webkitRTCPeerConnection || window.RTCPeerConnection;
exports.RTCIceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate;
var defaultConfig = {'iceServers': [{ 'url': 'stun:stun.l.google.com:19302' }]};
var dataCount = 1;

var util = {
  noop: function() {},

  CLOUD_HOST: '0.peerjs.com',
  CLOUD_PORT: 9000,

  // Browsers that need chunking:
  chunkedBrowsers: {'Chrome': 1},
  chunkedMTU: 16300, // The original 60000 bytes setting does not work when sending data from Firefox to Chrome, which is "cut off" after 16384 bytes and delivered individually.

  // Logging logic
  logLevel: 0,
  setLogLevel: function(level) {
    var debugLevel = parseInt(level, 10);
    if (!isNaN(parseInt(level, 10))) {
      util.logLevel = debugLevel;
    } else {
      // If they are using truthy/falsy values for debug
      util.logLevel = level ? 3 : 0;
    }
    util.log = util.warn = util.error = util.noop;
    if (util.logLevel > 0) {
      util.error = util._printWith('ERROR');
    }
    if (util.logLevel > 1) {
      util.warn = util._printWith('WARNING');
    }
    if (util.logLevel > 2) {
      util.log = util._print;
    }
  },
  setLogFunction: function(fn) {
    if (fn.constructor !== Function) {
      util.warn('The log function you passed in is not a function. Defaulting to regular logs.');
    } else {
      util._print = fn;
    }
  },

  _printWith: function(prefix) {
    return function() {
      var copy = Array.prototype.slice.call(arguments);
      copy.unshift(prefix);
      util._print.apply(util, copy);
    };
  },
  _print: function () {
    var err = false;
    var copy = Array.prototype.slice.call(arguments);
    copy.unshift('PeerJS: ');
    for (var i = 0, l = copy.length; i < l; i++){
      if (copy[i] instanceof Error) {
        copy[i] = '(' + copy[i].name + ') ' + copy[i].message;
        err = true;
      }
    }
    err ? console.error.apply(console, copy) : console.log.apply(console, copy);  
  },
  //

  // Returns browser-agnostic default config
  defaultConfig: defaultConfig,
  //

  // Returns the current browser.
  browser: (function() {
    if (window.mozRTCPeerConnection) {
      return 'Firefox';
    } else if (window.webkitRTCPeerConnection) {
      return 'Chrome';
    } else if (window.RTCPeerConnection) {
      return 'Supported';
    } else {
      return 'Unsupported';
    }
  })(),
  //

  // Lists which features are supported
  supports: (function() {
    if (typeof RTCPeerConnection === 'undefined') {
      return {};
    }

    var data = true;
    var audioVideo = true;

    var binaryBlob = false;
    var sctp = false;
    var onnegotiationneeded = !!window.webkitRTCPeerConnection;

    var pc, dc;
    try {
      pc = new RTCPeerConnection(defaultConfig, {optional: [{RtpDataChannels: true}]});
    } catch (e) {
      data = false;
      audioVideo = false;
    }

    if (data) {
      try {
        dc = pc.createDataChannel('_PEERJSTEST');
      } catch (e) {
        data = false;
      }
    }

    if (data) {
      // Binary test
      try {
        dc.binaryType = 'blob';
        binaryBlob = true;
      } catch (e) {
      }

      // Reliable test.
      // Unfortunately Chrome is a bit unreliable about whether or not they
      // support reliable.
      var reliablePC = new RTCPeerConnection(defaultConfig, {});
      try {
        var reliableDC = reliablePC.createDataChannel('_PEERJSRELIABLETEST', {});
        sctp = reliableDC.reliable;
      } catch (e) {
      }
      reliablePC.close();
    }

    // FIXME: not really the best check...
    if (audioVideo) {
      audioVideo = !!pc.addStream;
    }

    // FIXME: this is not great because in theory it doesn't work for
    // av-only browsers (?).
    if (!onnegotiationneeded && data) {
      // sync default check.
      var negotiationPC = new RTCPeerConnection(defaultConfig, {optional: [{RtpDataChannels: true}]});
      negotiationPC.onnegotiationneeded = function() {
        onnegotiationneeded = true;
        // async check.
        if (util && util.supports) {
          util.supports.onnegotiationneeded = true;
        }
      };
      var negotiationDC = negotiationPC.createDataChannel('_PEERJSNEGOTIATIONTEST');

      setTimeout(function() {
        negotiationPC.close();
      }, 1000);
    }

    if (pc) {
      pc.close();
    }

    return {
      audioVideo: audioVideo,
      data: data,
      binaryBlob: binaryBlob,
      binary: sctp, // deprecated; sctp implies binary support.
      reliable: sctp, // deprecated; sctp implies reliable data.
      sctp: sctp,
      onnegotiationneeded: onnegotiationneeded
    };
  }()),
  //

  // Ensure alphanumeric ids
  validateId: function(id) {
    // Allow empty ids
    return !id || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(id);
  },

  validateKey: function(key) {
    // Allow empty keys
    return !key || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(key);
  },


  debug: false,

  inherits: function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  },
  extend: function(dest, source) {
    for(var key in source) {
      if(source.hasOwnProperty(key)) {
        dest[key] = source[key];
      }
    }
    return dest;
  },
  pack: BinaryPack.pack,
  unpack: BinaryPack.unpack,

  log: function () {
    if (util.debug) {
      var err = false;
      var copy = Array.prototype.slice.call(arguments);
      copy.unshift('PeerJS: ');
      for (var i = 0, l = copy.length; i < l; i++){
        if (copy[i] instanceof Error) {
          copy[i] = '(' + copy[i].name + ') ' + copy[i].message;
          err = true;
        }
      }
      err ? console.error.apply(console, copy) : console.log.apply(console, copy);
    }
  },

  setZeroTimeout: (function(global) {
    var timeouts = [];
    var messageName = 'zero-timeout-message';

    // Like setTimeout, but only takes a function argument.	 There's
    // no time argument (always zero) and no arguments (you have to
    // use a closure).
    function setZeroTimeoutPostMessage(fn) {
      timeouts.push(fn);
      global.postMessage(messageName, '*');
    }

    function handleMessage(event) {
      if (event.source == global && event.data == messageName) {
        if (event.stopPropagation) {
          event.stopPropagation();
        }
        if (timeouts.length) {
          timeouts.shift()();
        }
      }
    }
    if (global.addEventListener) {
      global.addEventListener('message', handleMessage, true);
    } else if (global.attachEvent) {
      global.attachEvent('onmessage', handleMessage);
    }
    return setZeroTimeoutPostMessage;
  }(this)),

  // Binary stuff

  // chunks a blob.
  chunk: function(bl) {
    var chunks = [];
    var size = bl.size;
    var start = index = 0;
    var total = Math.ceil(size / util.chunkedMTU);
    while (start < size) {
      var end = Math.min(size, start + util.chunkedMTU);
      var b = bl.slice(start, end);

      var chunk = {
        __peerData: dataCount,
        n: index,
        data: b,
        total: total
      };

      chunks.push(chunk);

      start = end;
      index += 1;
    }
    dataCount += 1;
    return chunks;
  },

  blobToArrayBuffer: function(blob, cb){
    var fr = new FileReader();
    fr.onload = function(evt) {
      cb(evt.target.result);
    };
    fr.readAsArrayBuffer(blob);
  },
  blobToBinaryString: function(blob, cb){
    var fr = new FileReader();
    fr.onload = function(evt) {
      cb(evt.target.result);
    };
    fr.readAsBinaryString(blob);
  },
  binaryStringToArrayBuffer: function(binary) {
    var byteArray = new Uint8Array(binary.length);
    for (var i = 0; i < binary.length; i++) {
      byteArray[i] = binary.charCodeAt(i) & 0xff;
    }
    return byteArray.buffer;
  },
  randomToken: function () {
    return Math.random().toString(36).substr(2);
  },
  //

  isSecure: function() {
    return location.protocol === 'https:';
  }
};

exports.util = util;
/**
 * A peer who can initiate connections with other peers.
 */
function Peer(id, options) {
  if (!(this instanceof Peer)) return new Peer(id, options);
  EventEmitter.call(this);

  // Deal with overloading
  if (id && id.constructor == Object) {
    options = id;
    id = undefined;
  } else if (id) {
    // Ensure id is a string
    id = id.toString();
  }
  //

  // Configurize options
  options = util.extend({
    debug: 0, // 1: Errors, 2: Warnings, 3: All logs
    host: util.CLOUD_HOST,
    port: util.CLOUD_PORT,
    key: 'peerjs',
    path: '/',
    config: util.defaultConfig
  }, options);
  this.options = options;
  // Detect relative URL host.
  if (options.host === '/') {
    options.host = window.location.hostname;
  }
  // Set path correctly.
  if (options.path[0] !== '/') {
    options.path = '/' + options.path;
  }
  if (options.path[options.path.length - 1] !== '/') {
    options.path += '/';
  }

  // Set whether we use SSL to same as current host
  if (options.secure === undefined && options.host !== util.CLOUD_HOST) {
    options.secure = util.isSecure();
  }
  // Set a custom log function if present
  if (options.logFunction) {
    util.setLogFunction(options.logFunction);
  }
  util.setLogLevel(options.debug);
  //

  // Sanity checks
  // Ensure WebRTC supported
  if (!util.supports.audioVideo && !util.supports.data ) {
    this._delayedAbort('browser-incompatible', 'The current browser does not support WebRTC');
    return;
  }
  // Ensure alphanumeric id
  if (!util.validateId(id)) {
    this._delayedAbort('invalid-id', 'ID "' + id + '" is invalid');
    return;
  }
  // Ensure valid key
  if (!util.validateKey(options.key)) {
    this._delayedAbort('invalid-key', 'API KEY "' + options.key + '" is invalid');
    return;
  }
  // Ensure not using unsecure cloud server on SSL page
  if (options.secure && options.host === '0.peerjs.com') {
    this._delayedAbort('ssl-unavailable',
      'The cloud server currently does not support HTTPS. Please run your own PeerServer to use HTTPS.');
    return;
  }
  //

  // States.
  this.destroyed = false; // Connections have been killed
  this.disconnected = false; // Connection to PeerServer killed manually but P2P connections still active
  this.open = false; // Sockets and such are not yet open.
  //

  // References
  this.connections = {}; // DataConnections for this peer.
  this._lostMessages = {}; // src => [list of messages]
  //

  // Initialize the 'socket' (which is actually a mix of XHR streaming and
  // websockets.)
  var self = this;
  this.socket = new Socket(this.options.secure, this.options.host, this.options.port, this.options.path, this.options.key);
  this.socket.on('message', function(data) {
    self._handleMessage(data);
  });
  this.socket.on('error', function(error) {
    self._abort('socket-error', error);
  });
  this.socket.on('close', function() {
    if (!self.disconnected) { // If we haven't explicitly disconnected, emit error.
      self._abort('socket-closed', 'Underlying socket is already closed.');
    }
  });
  //

  // Start the connections
  if (id) {
    this._initialize(id);
  } else {
    this._retrieveId();
  }
  //
};

util.inherits(Peer, EventEmitter);

/** Get a unique ID from the server via XHR. */
Peer.prototype._retrieveId = function(cb) {
  var self = this;
  var http = new XMLHttpRequest();
  var protocol = this.options.secure ? 'https://' : 'http://';
  var url = protocol + this.options.host + ':' + this.options.port
    + this.options.path + this.options.key + '/id';
  var queryString = '?ts=' + new Date().getTime() + '' + Math.random();
  url += queryString;

  // If there's no ID we need to wait for one before trying to init socket.
  http.open('get', url, true);
  http.onerror = function(e) {
    util.error('Error retrieving ID', e);
    var pathError = '';
    if (self.options.path === '/' && self.options.host !== util.CLOUD_HOST) {
      pathError = ' If you passed in a `path` to your self-hosted PeerServer, '
        + 'you\'ll also need to pass in that same path when creating a new'
        + ' Peer.';
    }
    self._abort('server-error', 'Could not get an ID from the server.' + pathError);
  }
  http.onreadystatechange = function() {
    if (http.readyState !== 4) {
      return;
    }
    if (http.status !== 200) {
      http.onerror();
      return;
    }
    self._initialize(http.responseText);
  };
  http.send(null);
};

/** Initialize a connection with the server. */
Peer.prototype._initialize = function(id) {
  var self = this;
  this.id = id;
  this.socket.start(this.id);
}

/** Handles messages from the server. */
Peer.prototype._handleMessage = function(message) {
  var type = message.type;
  var payload = message.payload;
  var peer = message.src;

  switch (type) {
    case 'OPEN': // The connection to the server is open.
      this.emit('open', this.id);
      this.open = true;
      break;
    case 'ERROR': // Server error.
      this._abort('server-error', payload.msg);
      break;
    case 'ID-TAKEN': // The selected ID is taken.
      this._abort('unavailable-id', 'ID `' + this.id + '` is taken');
      break;
    case 'INVALID-KEY': // The given API key cannot be found.
      this._abort('invalid-key', 'API KEY "' + this.options.key + '" is invalid');
      break;

    //
    case 'LEAVE': // Another peer has closed its connection to this peer.
      util.log('Received leave message from', peer);
      this._cleanupPeer(peer);
      break;

    case 'EXPIRE': // The offer sent to a peer has expired without response.
      this.emit('error', new Error('Could not connect to peer ' + peer));
      break;
    case 'OFFER': // we should consider switching this to CALL/CONNECT, but this is the least breaking option.
      var connectionId = payload.connectionId;
      var connection = this.getConnection(peer, connectionId);

      if (connection) {
        util.warn('Offer received for existing Connection ID:', connectionId);
        //connection.handleMessage(message);
      } else {
        // Create a new connection.
        if (payload.type === 'media') {
          var connection = new MediaConnection(peer, this, {
            connectionId: connectionId,
            _payload: payload,
            metadata: payload.metadata
          });
          this._addConnection(peer, connection);
          this.emit('call', connection);
        } else if (payload.type === 'data') {
          connection = new DataConnection(peer, this, {
            connectionId: connectionId,
            _payload: payload,
            metadata: payload.metadata,
            label: payload.label,
            serialization: payload.serialization,
            reliable: payload.reliable
          });
          this._addConnection(peer, connection);
          this.emit('connection', connection);
        } else {
          util.warn('Received malformed connection type:', payload.type);
          return;
        }
        // Find messages.
        var messages = this._getMessages(connectionId);
        for (var i = 0, ii = messages.length; i < ii; i += 1) {
          connection.handleMessage(messages[i]);
        }
      }
      break;
    default:
      if (!payload) {
        util.warn('You received a malformed message from ' + peer + ' of type ' + type);
        return;
      }

      var id = payload.connectionId;
      var connection = this.getConnection(peer, id);

      if (connection && connection.pc) {
        // Pass it on.
        connection.handleMessage(message);
      } else if (id) {
        // Store for possible later use
        this._storeMessage(id, message);
      } else {
        util.warn('You received an unrecognized message:', message);
      }
      break;
  }
}

/** Stores messages without a set up connection, to be claimed later. */
Peer.prototype._storeMessage = function(connectionId, message) {
  if (!this._lostMessages[connectionId]) {
    this._lostMessages[connectionId] = [];
  }
  this._lostMessages[connectionId].push(message);
}

/** Retrieve messages from lost message store */
Peer.prototype._getMessages = function(connectionId) {
  var messages = this._lostMessages[connectionId];
  if (messages) {
    delete this._lostMessages[connectionId];
    return messages;
  } else {
    return [];
  }
}

/**
 * Returns a DataConnection to the specified peer. See documentation for a
 * complete list of options.
 */
Peer.prototype.connect = function(peer, options) {
  if (this.disconnected) {
    util.warn('You cannot connect to a new Peer because you called '
        + '.disconnect() on this Peer and ended your connection with the'
        + ' server. You can create a new Peer to reconnect.');
    this.emit('error', new Error('Cannot connect to new Peer after disconnecting from server.'));
    return;
  }
  var connection = new DataConnection(peer, this, options);
  this._addConnection(peer, connection);
  return connection;
}

/**
 * Returns a MediaConnection to the specified peer. See documentation for a
 * complete list of options.
 */
Peer.prototype.call = function(peer, stream, options) {
  if (this.disconnected) {
    util.warn('You cannot connect to a new Peer because you called '
        + '.disconnect() on this Peer and ended your connection with the'
        + ' server. You can create a new Peer to reconnect.');
    this.emit('error', new Error('Cannot connect to new Peer after disconnecting from server.'));
    return;
  }
  if (!stream) {
    util.error('To call a peer, you must provide a stream from your browser\'s `getUserMedia`.');
    return;
  }
  options = options || {};
  options._stream = stream;
  var call = new MediaConnection(peer, this, options);
  this._addConnection(peer, call);
  return call;
}

/** Add a data/media connection to this peer. */
Peer.prototype._addConnection = function(peer, connection) {
  if (!this.connections[peer]) {
    this.connections[peer] = [];
  }
  this.connections[peer].push(connection);
}

/** Retrieve a data/media connection for this peer. */
Peer.prototype.getConnection = function(peer, id) {
  var connections = this.connections[peer];
  if (!connections) {
    return null;
  }
  for (var i = 0, ii = connections.length; i < ii; i++) {
    if (connections[i].id === id) {
      return connections[i];
    }
  }
  return null;
}

Peer.prototype._delayedAbort = function(type, message) {
  var self = this;
  util.setZeroTimeout(function(){
    self._abort(type, message);
  });
}

/** Destroys the Peer and emits an error message. */
Peer.prototype._abort = function(type, message) {
  util.error('Aborting. Error:', message);
  var err = new Error(message);
  err.type = type;
  this.destroy();
  this.emit('error', err);
};

/**
 * Destroys the Peer: closes all active connections as well as the connection
 *  to the server.
 * Warning: The peer can no longer create or accept connections after being
 *  destroyed.
 */
Peer.prototype.destroy = function() {
  if (!this.destroyed) {
    this._cleanup();
    this.disconnect();
    this.destroyed = true;
  }
}


/** Disconnects every connection on this peer. */
Peer.prototype._cleanup = function() {
  if (this.connections) {
    var peers = Object.keys(this.connections);
    for (var i = 0, ii = peers.length; i < ii; i++) {
      this._cleanupPeer(peers[i]);
    }
  }
  this.emit('close');
}

/** Closes all connections to this peer. */
Peer.prototype._cleanupPeer = function(peer) {
  var connections = this.connections[peer];
  for (var j = 0, jj = connections.length; j < jj; j += 1) {
    connections[j].close();
  }
}

/**
 * Disconnects the Peer's connection to the PeerServer. Does not close any
 *  active connections.
 * Warning: The peer can no longer create or accept connections after being
 *  disconnected. It also cannot reconnect to the server.
 */
Peer.prototype.disconnect = function() {
  var self = this;
  util.setZeroTimeout(function(){
    if (!self.disconnected) {
      self.disconnected = true;
      self.open = false;
      if (self.socket) {
        self.socket.close();
      }
      self.id = null;
    }
  });
}

/**
 * Get a list of available peer IDs. If you're running your own server, you'll
 * want to set allow_discovery: true in the PeerServer options. If you're using
 * the cloud server, email team@peerjs.com to get the functionality enabled for
 * your key.
 */
Peer.prototype.listAllPeers = function(cb) {
  cb = cb || function() {};
  var self = this;
  var http = new XMLHttpRequest();
  var protocol = this.options.secure ? 'https://' : 'http://';
  var url = protocol + this.options.host + ':' + this.options.port
    + this.options.path + this.options.key + '/peers';
  var queryString = '?ts=' + new Date().getTime() + '' + Math.random();
  url += queryString;

  // If there's no ID we need to wait for one before trying to init socket.
  http.open('get', url, true);
  http.onerror = function(e) {
    self._abort('server-error', 'Could not get peers from the server.');
    cb([]);
  }
  http.onreadystatechange = function() {
    if (http.readyState !== 4) {
      return;
    }
    if (http.status === 401) {
      var helpfulError = '';
      if (self.options.host !== util.CLOUD_HOST) {
        helpfulError = 'It looks like you\'re using the cloud server. You can email '
          + 'team@peerjs.com to enable peer listing for your API key.';
      } else {
        helpfulError = 'You need to enable `allow_discovery` on your self-hosted'
          + ' PeerServer to use this feature.';
      }
      throw new Error('It doesn\'t look like you have permission to list peers IDs. ' + helpfulError);
      cb([]);
    } else if (http.status !== 200) {
      cb([]);
    } else {
      cb(JSON.parse(http.responseText));
    }
  };
  http.send(null);
}

exports.Peer = Peer;
/**
 * Wraps a DataChannel between two Peers.
 */
function DataConnection(peer, provider, options) {
  if (!(this instanceof DataConnection)) return new DataConnection(peer, provider, options);
  EventEmitter.call(this);

  this.options = util.extend({
    serialization: 'binary',
    reliable: false
  }, options);

  // Connection is not open yet.
  this.open = false;
  this.type = 'data';
  this.peer = peer;
  this.provider = provider;

  this.id = this.options.connectionId || DataConnection._idPrefix + util.randomToken();

  this.label = this.options.label || this.id;
  this.metadata = this.options.metadata;
  this.serialization = this.options.serialization;
  this.reliable = this.options.reliable;

  // Data channel buffering.
  this._buffer = [];
  this._buffering = false;
  this.bufferSize = 0;

  // For storing large data.
  this._chunkedData = {};

  if (this.options._payload) {
    this._peerBrowser = this.options._payload.browser;
  }

  Negotiator.startConnection(
    this,
    this.options._payload || {
      originator: true
    }
  );
}

util.inherits(DataConnection, EventEmitter);

DataConnection._idPrefix = 'dc_';

/** Called by the Negotiator when the DataChannel is ready. */
DataConnection.prototype.initialize = function(dc) {
  this._dc = this.dataChannel = dc;
  this._configureDataChannel();
}

DataConnection.prototype._configureDataChannel = function() {
  var self = this;
  if (util.supports.sctp) {
    this._dc.binaryType = 'arraybuffer';
  }
  this._dc.onopen = function() {
    util.log('Data channel connection success');
    self.open = true;
    self.emit('open');
  }

  // Use the Reliable shim for non Firefox browsers
  if (!util.supports.sctp && this.reliable) {
    this._reliable = new Reliable(this._dc, util.debug);
  }

  if (this._reliable) {
    this._reliable.onmessage = function(msg) {
      self.emit('data', msg);
    };
  } else {
    this._dc.onmessage = function(e) {
      self._handleDataMessage(e);
    };
  }
  this._dc.onclose = function(e) {
    util.log('DataChannel closed for:', self.peer);
    self.close();
  };
}

// Handles a DataChannel message.
DataConnection.prototype._handleDataMessage = function(e) {
  var self = this;
  var data = e.data;
  var datatype = data.constructor;
  if (this.serialization === 'binary' || this.serialization === 'binary-utf8') {
    if (datatype === Blob) {
      // Datatype should never be blob
      util.blobToArrayBuffer(data, function(ab) {
        data = util.unpack(ab);
        self.emit('data', data);
      });
      return;
    } else if (datatype === ArrayBuffer) {
      data = util.unpack(data);
    } else if (datatype === String) {
      // String fallback for binary data for browsers that don't support binary yet
      var ab = util.binaryStringToArrayBuffer(data);
      data = util.unpack(ab);
    }
  } else if (this.serialization === 'json') {
    data = JSON.parse(data);
  }

  // Check if we've chunked--if so, piece things back together.
  // We're guaranteed that this isn't 0.
  if (data.__peerData) {
    var id = data.__peerData;
    var chunkInfo = this._chunkedData[id] || {data: [], count: 0, total: data.total};

    chunkInfo.data[data.n] = data.data;
    chunkInfo.count += 1;

    if (chunkInfo.total === chunkInfo.count) {
      // We've received all the chunks--time to construct the complete data.
      data = new Blob(chunkInfo.data);
      this._handleDataMessage({data: data});

      // We can also just delete the chunks now.
      delete this._chunkedData[id];
    }

    this._chunkedData[id] = chunkInfo;
    return;
  }

  this.emit('data', data);
}

/**
 * Exposed functionality for users.
 */

/** Allows user to close connection. */
DataConnection.prototype.close = function() {
  if (!this.open) {
    return;
  }
  this.open = false;
  Negotiator.cleanup(this);
  this.emit('close');
}

/** Allows user to send data. */
DataConnection.prototype.send = function(data, chunked) {
  if (!this.open) {
    this.emit('error', new Error('Connection is not open. You should listen for the `open` event before sending messages.'));
    return;
  }
  if (this._reliable) {
    // Note: reliable shim sending will make it so that you cannot customize
    // serialization.
    this._reliable.send(data);
    return;
  }
  var self = this;
  if (this.serialization === 'json') {
    this._bufferedSend(JSON.stringify(data));
  } else if (this.serialization === 'binary' || this.serialization === 'binary-utf8') {
    var blob = util.pack(data);

    // For Chrome-Firefox interoperability, we need to make Firefox "chunk"
    // the data it sends out.
    var needsChunking = util.chunkedBrowsers[this._peerBrowser] || util.chunkedBrowsers[util.browser];
    if (needsChunking && !chunked && blob.size > util.chunkedMTU) {
      this._sendChunks(blob);
      return;
    }

    // DataChannel currently only supports strings.
    if (!util.supports.sctp) {
      util.blobToBinaryString(blob, function(str) {
        self._bufferedSend(str);
      });
    } else if (!util.supports.binaryBlob) {
      // We only do this if we really need to (e.g. blobs are not supported),
      // because this conversion is costly.
      util.blobToArrayBuffer(blob, function(ab) {
        self._bufferedSend(ab);
      });
    } else {
      this._bufferedSend(blob);
    }
  } else {
    this._bufferedSend(data);
  }
}

DataConnection.prototype._bufferedSend = function(msg) {
  if (this._buffering || !this._trySend(msg)) {
    this._buffer.push(msg);
    this.bufferSize = this._buffer.length;
  }
}

// Returns true if the send succeeds.
DataConnection.prototype._trySend = function(msg) {
  try {
    this._dc.send(msg);
  } catch (e) {
    this._buffering = true;

    var self = this;
    setTimeout(function() {
      // Try again.
      self._buffering = false;
      self._tryBuffer();
    }, 100);
    return false;
  }
  return true;
}

// Try to send the first message in the buffer.
DataConnection.prototype._tryBuffer = function() {
  if (this._buffer.length === 0) {
    return;
  }

  var msg = this._buffer[0];

  if (this._trySend(msg)) {
    this._buffer.shift();
    this.bufferSize = this._buffer.length;
    this._tryBuffer();
  }
}

DataConnection.prototype._sendChunks = function(blob) {
  var blobs = util.chunk(blob);
  for (var i = 0, ii = blobs.length; i < ii; i += 1) {
    var blob = blobs[i];
    this.send(blob, true);
  }
}

DataConnection.prototype.handleMessage = function(message) {
  var payload = message.payload;

  switch (message.type) {
    case 'ANSWER':
      this._peerBrowser = payload.browser;

      // Forward to negotiator
      Negotiator.handleSDP(message.type, this, payload.sdp);
      break;
    case 'CANDIDATE':
      Negotiator.handleCandidate(this, payload.candidate);
      break;
    default:
      util.warn('Unrecognized message type:', message.type, 'from peer:', this.peer);
      break;
  }
}
/**
 * Wraps the streaming interface between two Peers.
 */
function MediaConnection(peer, provider, options) {
  if (!(this instanceof MediaConnection)) return new MediaConnection(peer, provider, options);
  EventEmitter.call(this);

  this.options = util.extend({}, options);

  this.open = false;
  this.type = 'media';
  this.peer = peer;
  this.provider = provider;
  this.metadata = this.options.metadata;
  this.localStream = this.options._stream;

  this.id = this.options.connectionId || MediaConnection._idPrefix + util.randomToken();
  if (this.localStream) {
    Negotiator.startConnection(
      this,
      {_stream: this.localStream, originator: true}
    );
  }
};

util.inherits(MediaConnection, EventEmitter);

MediaConnection._idPrefix = 'mc_';

MediaConnection.prototype.addStream = function(remoteStream) {
  util.log('Receiving stream', remoteStream);

  this.remoteStream = remoteStream;
  this.emit('stream', remoteStream); // Should we call this `open`?

};

MediaConnection.prototype.handleMessage = function(message) {
  var payload = message.payload;

  switch (message.type) {
    case 'ANSWER':
      // Forward to negotiator
      Negotiator.handleSDP(message.type, this, payload.sdp);
      this.open = true;
      break;
    case 'CANDIDATE':
      Negotiator.handleCandidate(this, payload.candidate);
      break;
    default:
      util.warn('Unrecognized message type:', message.type, 'from peer:', this.peer);
      break;
  }
}

MediaConnection.prototype.answer = function(stream) {
  if (this.localStream) {
    util.warn('Local stream already exists on this MediaConnection. Are you answering a call twice?');
    return;
  }

  this.options._payload._stream = stream;

  this.localStream = stream;
  Negotiator.startConnection(
    this,
    this.options._payload
  )
  // Retrieve lost messages stored because PeerConnection not set up.
  var messages = this.provider._getMessages(this.id);
  for (var i = 0, ii = messages.length; i < ii; i += 1) {
    this.handleMessage(messages[i]);
  }
  this.open = true;
};

/**
 * Exposed functionality for users.
 */

/** Allows user to close connection. */
MediaConnection.prototype.close = function() {
  if (!this.open) {
    return;
  }
  this.open = false;
  Negotiator.cleanup(this);
  this.emit('close')
};
/**
 * Manages all negotiations between Peers.
 */
var Negotiator = {
  pcs: {
    data: {},
    media: {}
  }, // type => {peerId: {pc_id: pc}}.
  //providers: {}, // provider's id => providers (there may be multiple providers/client.
  queue: [] // connections that are delayed due to a PC being in use.
}

Negotiator._idPrefix = 'pc_';

/** Returns a PeerConnection object set up correctly (for data, media). */
Negotiator.startConnection = function(connection, options) {
  var pc = Negotiator._getPeerConnection(connection, options);

  if (connection.type === 'media' && options._stream) {
    // Add the stream.
    pc.addStream(options._stream);
  }

  // Set the connection's PC.
  connection.pc = connection.peerConnection = pc;
  // What do we need to do now?
  if (options.originator) {
    if (connection.type === 'data') {
      // Create the datachannel.
      var config = {};
      // Dropping reliable:false support, since it seems to be crashing
      // Chrome.
      /*if (util.supports.sctp && !options.reliable) {
        // If we have canonical reliable support...
        config = {maxRetransmits: 0};
      }*/
      // Fallback to ensure older browsers don't crash.
      if (!util.supports.sctp) {
        config = {reliable: options.reliable};
      }
      var dc = pc.createDataChannel(connection.label, config);
      connection.initialize(dc);
    }

    if (!util.supports.onnegotiationneeded) {
      Negotiator._makeOffer(connection);
    }
  } else {
    Negotiator.handleSDP('OFFER', connection, options.sdp);
  }
}

Negotiator._getPeerConnection = function(connection, options) {
  if (!Negotiator.pcs[connection.type]) {
    util.error(connection.type + ' is not a valid connection type. Maybe you overrode the `type` property somewhere.');
  }

  if (!Negotiator.pcs[connection.type][connection.peer]) {
    Negotiator.pcs[connection.type][connection.peer] = {};
  }
  var peerConnections = Negotiator.pcs[connection.type][connection.peer];

  var pc;
  // Not multiplexing while FF and Chrome have not-great support for it.
  /*if (options.multiplex) {
    ids = Object.keys(peerConnections);
    for (var i = 0, ii = ids.length; i < ii; i += 1) {
      pc = peerConnections[ids[i]];
      if (pc.signalingState === 'stable') {
        break; // We can go ahead and use this PC.
      }
    }
  } else */
  if (options.pc) { // Simplest case: PC id already provided for us.
    pc = Negotiator.pcs[connection.type][connection.peer][options.pc];
  }

  if (!pc || pc.signalingState !== 'stable') {
    pc = Negotiator._startPeerConnection(connection);
  }
  return pc;
}

/*
Negotiator._addProvider = function(provider) {
  if ((!provider.id && !provider.disconnected) || !provider.socket.open) {
    // Wait for provider to obtain an ID.
    provider.on('open', function(id) {
      Negotiator._addProvider(provider);
    });
  } else {
    Negotiator.providers[provider.id] = provider;
  }
}*/


/** Start a PC. */
Negotiator._startPeerConnection = function(connection) {
  util.log('Creating RTCPeerConnection.');

  var id = Negotiator._idPrefix + util.randomToken();
  var optional = {};

  if (connection.type === 'data' && !util.supports.sctp) {
    optional = {optional: [{RtpDataChannels: true}]};
  } else if (connection.type === 'media') {
    // Interop req for chrome.
    optional = {optional: [{DtlsSrtpKeyAgreement: true}]};
  }

  var pc = new RTCPeerConnection(connection.provider.options.config, optional);
  Negotiator.pcs[connection.type][connection.peer][id] = pc;

  Negotiator._setupListeners(connection, pc, id);

  return pc;
}

/** Set up various WebRTC listeners. */
Negotiator._setupListeners = function(connection, pc, pc_id) {
  var peerId = connection.peer;
  var connectionId = connection.id;
  var provider = connection.provider;

  // ICE CANDIDATES.
  util.log('Listening for ICE candidates.');
  pc.onicecandidate = function(evt) {
    if (evt.candidate) {
      util.log('Received ICE candidates for:', connection.peer);
      provider.socket.send({
        type: 'CANDIDATE',
        payload: {
          candidate: evt.candidate,
          type: connection.type,
          connectionId: connection.id
        },
        dst: peerId
      });
    }
  };

  pc.oniceconnectionstatechange = function() {
    switch (pc.iceConnectionState) {
      case 'disconnected':
      case 'failed':
        util.log('iceConnectionState is disconnected, closing connections to ' + peerId);
        connection.close();
        break;
      case 'completed':
        pc.onicecandidate = util.noop;
        break;
    }
  };

  // Fallback for older Chrome impls.
  pc.onicechange = pc.oniceconnectionstatechange;

  // ONNEGOTIATIONNEEDED (Chrome)
  util.log('Listening for `negotiationneeded`');
  pc.onnegotiationneeded = function() {
    util.log('`negotiationneeded` triggered');
    if (pc.signalingState == 'stable') {
      Negotiator._makeOffer(connection);
    } else {
      util.log('onnegotiationneeded triggered when not stable. Is another connection being established?');
    }
  };

  // DATACONNECTION.
  util.log('Listening for data channel');
  // Fired between offer and answer, so options should already be saved
  // in the options hash.
  pc.ondatachannel = function(evt) {
    util.log('Received data channel');
    var dc = evt.channel;
    var connection = provider.getConnection(peerId, connectionId);
    connection.initialize(dc);
  };

  // MEDIACONNECTION.
  util.log('Listening for remote stream');
  pc.onaddstream = function(evt) {
    util.log('Received remote stream');
    var stream = evt.stream;
    provider.getConnection(peerId, connectionId).addStream(stream);
  };
}

Negotiator.cleanup = function(connection) {
  util.log('Cleaning up PeerConnection to ' + connection.peer);

  var pc = connection.pc;

  if (!!pc && (pc.readyState !== 'closed' || pc.signalingState !== 'closed')) {
    pc.close();
    connection.pc = null;
  }
}

Negotiator._makeOffer = function(connection) {
  var pc = connection.pc;
  pc.createOffer(function(offer) {
    util.log('Created offer.');

    if (!util.supports.sctp && connection.type === 'data' && connection.reliable) {
      offer.sdp = Reliable.higherBandwidthSDP(offer.sdp);
    }

    pc.setLocalDescription(offer, function() {
      util.log('Set localDescription: offer', 'for:', connection.peer);
      connection.provider.socket.send({
        type: 'OFFER',
        payload: {
          sdp: offer,
          type: connection.type,
          label: connection.label,
          connectionId: connection.id,
          reliable: connection.reliable,
          serialization: connection.serialization,
          metadata: connection.metadata,
          browser: util.browser
        },
        dst: connection.peer
      });
    }, function(err) {
      connection.provider.emit('error', err);
      util.log('Failed to setLocalDescription, ', err);
    });
  }, function(err) {
    connection.provider.emit('error', err);
    util.log('Failed to createOffer, ', err);
  }, connection.options.constraints);
}

Negotiator._makeAnswer = function(connection) {
  var pc = connection.pc;

  pc.createAnswer(function(answer) {
    util.log('Created answer.');

    if (!util.supports.sctp && connection.type === 'data' && connection.reliable) {
      answer.sdp = Reliable.higherBandwidthSDP(answer.sdp);
    }

    pc.setLocalDescription(answer, function() {
      util.log('Set localDescription: answer', 'for:', connection.peer);
      connection.provider.socket.send({
        type: 'ANSWER',
        payload: {
          sdp: answer,
          type: connection.type,
          connectionId: connection.id,
          browser: util.browser
        },
        dst: connection.peer
      });
    }, function(err) {
      connection.provider.emit('error', err);
      util.log('Failed to setLocalDescription, ', err);
    });
  }, function(err) {
    connection.provider.emit('error', err);
    util.log('Failed to create answer, ', err);
  });
}

/** Handle an SDP. */
Negotiator.handleSDP = function(type, connection, sdp) {
  sdp = new RTCSessionDescription(sdp);
  var pc = connection.pc;

  util.log('Setting remote description', sdp);
  pc.setRemoteDescription(sdp, function() {
    util.log('Set remoteDescription:', type, 'for:', connection.peer);

    if (type === 'OFFER') {
      Negotiator._makeAnswer(connection);
    }
  }, function(err) {
    connection.provider.emit('error', err);
    util.log('Failed to setRemoteDescription, ', err);
  });
}

/** Handle a candidate. */
Negotiator.handleCandidate = function(connection, ice) {
  var candidate = ice.candidate;
  var sdpMLineIndex = ice.sdpMLineIndex;
  connection.pc.addIceCandidate(new RTCIceCandidate({
    sdpMLineIndex: sdpMLineIndex,
    candidate: candidate
  }));
  util.log('Added ICE candidate for:', connection.peer);
}
/**
 * An abstraction on top of WebSockets and XHR streaming to provide fastest
 * possible connection for peers.
 */
function Socket(secure, host, port, path, key) {
  if (!(this instanceof Socket)) return new Socket(secure, host, port, path, key);

  EventEmitter.call(this);

  // Disconnected manually.
  this.disconnected = false;
  this._queue = [];

  var httpProtocol = secure ? 'https://' : 'http://';
  var wsProtocol = secure ? 'wss://' : 'ws://';
  this._httpUrl = httpProtocol + host + ':' + port + path + key;
  this._wsUrl = wsProtocol + host + ':' + port + path + 'peerjs?key=' + key;
}

util.inherits(Socket, EventEmitter);


/** Check in with ID or get one from server. */
Socket.prototype.start = function(id) {  
  this.id = id;

  var token = util.randomToken();
  this._httpUrl += '/' + id + '/' + token;
  this._wsUrl += '&id='+id+'&token='+token;

  this._startXhrStream();
  this._startWebSocket();
}


/** Start up websocket communications. */
Socket.prototype._startWebSocket = function(id) {
  var self = this;

  if (this._socket) {
    return;
  }

  this._socket = new WebSocket(this._wsUrl);

  this._socket.onmessage = function(event) {
    var data;
    try {
      data = JSON.parse(event.data);
    } catch(e) {
      util.log('Invalid server message', event.data);
      return;
    }
    try {
      self.emit('message', data);
    } catch ($e) {
      console.log('peer error', $e)
    }
  };

  // Take care of the queue of connections if necessary and make sure Peer knows
  // socket is open.
  this._socket.onopen = function() {
    if (self._timeout) {
      clearTimeout(self._timeout);
      setTimeout(function(){
        self._http.abort();
        self._http = null;
      }, 5000);
    }
    self._sendQueuedMessages();
    util.log('Socket open');
  };
}

/** Start XHR streaming. */
Socket.prototype._startXhrStream = function(n) {
  try {
    var self = this;
    this._http = new XMLHttpRequest();
    this._http._index = 1;
    this._http._streamIndex = n || 0;
    this._http.open('post', this._httpUrl + '/id?i=' + this._http._streamIndex, true);
    this._http.onreadystatechange = function() {
      if (this.readyState == 2 && this.old) {
        this.old.abort();
        delete this.old;
      }
      if (this.readyState > 2 && this.status == 200 && this.responseText) {
        self._handleStream(this);
      }
    };
    this._http.send(null);
    this._setHTTPTimeout();
  } catch(e) {
    util.log('XMLHttpRequest not available; defaulting to WebSockets');
  }
}


/** Handles onreadystatechange response as a stream. */
Socket.prototype._handleStream = function(http) {
  // 3 and 4 are loading/done state. All others are not relevant.
  var messages = http.responseText.split('\n');

  // Check to see if anything needs to be processed on buffer.
  if (http._buffer) {
    while (http._buffer.length > 0) {
      var index = http._buffer.shift();
      var bufferedMessage = messages[index];
      try {
        bufferedMessage = JSON.parse(bufferedMessage);
      } catch(e) {
        http._buffer.shift(index);
        break;
      }
      this.emit('message', bufferedMessage);
    }
  }

  var message = messages[http._index];
  if (message) {
    http._index += 1;
    // Buffering--this message is incomplete and we'll get to it next time.
    // This checks if the httpResponse ended in a `\n`, in which case the last
    // element of messages should be the empty string.
    if (http._index === messages.length) {
      if (!http._buffer) {
        http._buffer = [];
      }
      http._buffer.push(http._index - 1);
    } else {
      try {
        message = JSON.parse(message);
      } catch(e) {
        util.log('Invalid server message', message);
        return;
      }
      this.emit('message', message);
    }
  }
}

Socket.prototype._setHTTPTimeout = function() {
  var self = this;
  this._timeout = setTimeout(function() {
    var old = self._http;
    if (!self._wsOpen()) {
      self._startXhrStream(old._streamIndex + 1);
      self._http.old = old;
    } else {
      old.abort();
    }
  }, 25000);
}

/** Is the websocket currently open? */
Socket.prototype._wsOpen = function() {
  return this._socket && this._socket.readyState == 1;
}

/** Send queued messages. */
Socket.prototype._sendQueuedMessages = function() {
  for (var i = 0, ii = this._queue.length; i < ii; i += 1) {
    this.send(this._queue[i]);
  }
}

/** Exposed send for DC & Peer. */
Socket.prototype.send = function(data) {
  if (this.disconnected) {
    return;
  }

  // If we didn't get an ID yet, we can't yet send anything so we should queue
  // up these messages.
  if (!this.id) {
    this._queue.push(data);
    return;
  }

  if (!data.type) {
    this.emit('error', 'Invalid message');
    return;
  }

  var message = JSON.stringify(data);
  if (this._wsOpen()) {
    this._socket.send(message);
  } else {
    var http = new XMLHttpRequest();
    var url = this._httpUrl + '/' + data.type.toLowerCase();
    http.open('post', url, true);
    http.setRequestHeader('Content-Type', 'application/json');
    http.send(message);
  }
}

Socket.prototype.close = function() {
  if (!this.disconnected && this._wsOpen()) {
    this._socket.close();
    this.disconnected = true;
  }
}

})(this);
/* https://github.com/jakearchibald/es6-promise */
!function(){var a,b,c,d;!function(){var e={},f={};a=function(a,b,c){e[a]={deps:b,callback:c}},d=c=b=function(a){function c(b){if("."!==b.charAt(0))return b;for(var c=b.split("/"),d=a.split("/").slice(0,-1),e=0,f=c.length;f>e;e++){var g=c[e];if(".."===g)d.pop();else{if("."===g)continue;d.push(g)}}return d.join("/")}if(d._eak_seen=e,f[a])return f[a];if(f[a]={},!e[a])throw new Error("Could not find module "+a);for(var g,h=e[a],i=h.deps,j=h.callback,k=[],l=0,m=i.length;m>l;l++)"exports"===i[l]?k.push(g={}):k.push(b(c(i[l])));var n=j.apply(this,k);return f[a]=g||n}}(),a("promise/all",["./utils","exports"],function(a,b){"use strict";function c(a){var b=this;if(!d(a))throw new TypeError("You must pass an array to all.");return new b(function(b,c){function d(a){return function(b){f(a,b)}}function f(a,c){h[a]=c,0===--i&&b(h)}var g,h=[],i=a.length;0===i&&b([]);for(var j=0;j<a.length;j++)g=a[j],g&&e(g.then)?g.then(d(j),c):f(j,g)})}var d=a.isArray,e=a.isFunction;b.all=c}),a("promise/asap",["exports"],function(a){"use strict";function b(){return function(){process.nextTick(e)}}function c(){var a=0,b=new i(e),c=document.createTextNode("");return b.observe(c,{characterData:!0}),function(){c.data=a=++a%2}}function d(){return function(){j.setTimeout(e,1)}}function e(){for(var a=0;a<k.length;a++){var b=k[a],c=b[0],d=b[1];c(d)}k=[]}function f(a,b){var c=k.push([a,b]);1===c&&g()}var g,h="undefined"!=typeof window?window:{},i=h.MutationObserver||h.WebKitMutationObserver,j="undefined"!=typeof global?global:void 0===this?window:this,k=[];g="undefined"!=typeof process&&"[object process]"==={}.toString.call(process)?b():i?c():d(),a.asap=f}),a("promise/config",["exports"],function(a){"use strict";function b(a,b){return 2!==arguments.length?c[a]:(c[a]=b,void 0)}var c={instrument:!1};a.config=c,a.configure=b}),a("promise/polyfill",["./promise","./utils","exports"],function(a,b,c){"use strict";function d(){var a;a="undefined"!=typeof global?global:"undefined"!=typeof window&&window.document?window:self;var b="Promise"in a&&"resolve"in a.Promise&&"reject"in a.Promise&&"all"in a.Promise&&"race"in a.Promise&&function(){var b;return new a.Promise(function(a){b=a}),f(b)}();b||(a.Promise=e)}var e=a.Promise,f=b.isFunction;c.polyfill=d}),a("promise/promise",["./config","./utils","./all","./race","./resolve","./reject","./asap","exports"],function(a,b,c,d,e,f,g,h){"use strict";function i(a){if(!v(a))throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");if(!(this instanceof i))throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");this._subscribers=[],j(a,this)}function j(a,b){function c(a){o(b,a)}function d(a){q(b,a)}try{a(c,d)}catch(e){d(e)}}function k(a,b,c,d){var e,f,g,h,i=v(c);if(i)try{e=c(d),g=!0}catch(j){h=!0,f=j}else e=d,g=!0;n(b,e)||(i&&g?o(b,e):h?q(b,f):a===D?o(b,e):a===E&&q(b,e))}function l(a,b,c,d){var e=a._subscribers,f=e.length;e[f]=b,e[f+D]=c,e[f+E]=d}function m(a,b){for(var c,d,e=a._subscribers,f=a._detail,g=0;g<e.length;g+=3)c=e[g],d=e[g+b],k(b,c,d,f);a._subscribers=null}function n(a,b){var c,d=null;try{if(a===b)throw new TypeError("A promises callback cannot return that same promise.");if(u(b)&&(d=b.then,v(d)))return d.call(b,function(d){return c?!0:(c=!0,b!==d?o(a,d):p(a,d),void 0)},function(b){return c?!0:(c=!0,q(a,b),void 0)}),!0}catch(e){return c?!0:(q(a,e),!0)}return!1}function o(a,b){a===b?p(a,b):n(a,b)||p(a,b)}function p(a,b){a._state===B&&(a._state=C,a._detail=b,t.async(r,a))}function q(a,b){a._state===B&&(a._state=C,a._detail=b,t.async(s,a))}function r(a){m(a,a._state=D)}function s(a){m(a,a._state=E)}var t=a.config,u=(a.configure,b.objectOrFunction),v=b.isFunction,w=(b.now,c.all),x=d.race,y=e.resolve,z=f.reject,A=g.asap;t.async=A;var B=void 0,C=0,D=1,E=2;i.prototype={constructor:i,_state:void 0,_detail:void 0,_subscribers:void 0,then:function(a,b){var c=this,d=new this.constructor(function(){});if(this._state){var e=arguments;t.async(function(){k(c._state,d,e[c._state-1],c._detail)})}else l(this,d,a,b);return d},"catch":function(a){return this.then(null,a)}},i.all=w,i.race=x,i.resolve=y,i.reject=z,h.Promise=i}),a("promise/race",["./utils","exports"],function(a,b){"use strict";function c(a){var b=this;if(!d(a))throw new TypeError("You must pass an array to race.");return new b(function(b,c){for(var d,e=0;e<a.length;e++)d=a[e],d&&"function"==typeof d.then?d.then(b,c):b(d)})}var d=a.isArray;b.race=c}),a("promise/reject",["exports"],function(a){"use strict";function b(a){var b=this;return new b(function(b,c){c(a)})}a.reject=b}),a("promise/resolve",["exports"],function(a){"use strict";function b(a){if(a&&"object"==typeof a&&a.constructor===this)return a;var b=this;return new b(function(b){b(a)})}a.resolve=b}),a("promise/utils",["exports"],function(a){"use strict";function b(a){return c(a)||"object"==typeof a&&null!==a}function c(a){return"function"==typeof a}function d(a){return"[object Array]"===Object.prototype.toString.call(a)}var e=Date.now||function(){return(new Date).getTime()};a.objectOrFunction=b,a.isFunction=c,a.isArray=d,a.now=e}),b("promise/polyfill").polyfill()}();
/*
Copyright (C) 2011 Patrick Gillespie, http://patorjk.com/

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

/*
    Extendible BBCode Parser v1.0.0
    By Patrick Gillespie (patorjk@gmail.com)
    Website: http://patorjk.com/

    This module allows you to parse BBCode and to extend to the mark-up language
    to add in your own tags.
*/

"use strict";

var XBBCODE = (function() {

    // -----------------------------------------------------------------------------
    // Set up private variables
    // -----------------------------------------------------------------------------

    var me = {},
        urlPattern = /^(?:https?|file|c):(?:\/{1,3}|\\{1})[-a-zA-Z0-9:@#%&()~_?\+=\/\\\.]*$/,
        colorNamePattern = /^(?:red|green|blue|orange|yellow|black|white|brown|gray|silver|purple|maroon|fushsia|lime|olive|navy|teal|aqua)$/,
        colorCodePattern = /^#?[a-fA-F0-9]{6}$/,
        tags,
        tagList,
        tagsNoParseList = [],
        bbRegExp,
        pbbRegExp,
        pbbRegExp2,
        openTags,
        closeTags;
        
    /* -----------------------------------------------------------------------------
     * tags
     * This object contains a list of tags that your code will be able to understand.
     * Each tag object has the following properties:
     *
     *   openTag - A function that takes in the tag's parameters (if any) and its
     *             contents, and returns what its HTML open tag should be. 
     *             Example: [color=red]test[/color] would take in "=red" as a
     *             parameter input, and "test" as a content input.
     *             It should be noted that any BBCode inside of "content" will have 
     *             been processed by the time it enter the openTag function.
     *
     *   closeTag - A function that takes in the tag's parameters (if any) and its
     *              contents, and returns what its HTML close tag should be.
     *
     *   displayContent - Defaults to true. If false, the content for the tag will
     *                    not be displayed. This is useful for tags like IMG where
     *                    its contents are actually a parameter input.
     *
     *   restrictChildrenTo - A list of BBCode tags which are allowed to be nested
     *                        within this BBCode tag. If this property is omitted,
     *                        any BBCode tag may be nested within the tag.
     *
     *   restrictParentsTo - A list of BBCode tags which are allowed to be parents of
     *                       this BBCode tag. If this property is omitted, any BBCode 
     *                       tag may be a parent of the tag.
     *
     *   noParse - true or false. If true, none of the content WITHIN this tag will be
     *             parsed by the XBBCode parser.
     *       
     *
     *
     * LIMITIONS on adding NEW TAGS:
     *  - Tag names should be alphanumeric (including underscores) and all tags should have an opening tag
     *    and a closing tag. 
     *    The [*] tag is an exception because it was already a standard
     *    bbcode tag. Technecially tags don't *have* to be alphanumeric, but since 
     *    regular expressions are used to parse the text, if you use a non-alphanumeric 
     *    tag names, just make sure the tag name gets escaped properly (if needed).
     * --------------------------------------------------------------------------- */
        
    tags = {
        "b": {
            openTag: function(params,content) {
                return '<span class="xbbcode-b">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        /*
            This tag does nothing and is here mostly to be used as a classification for
            the bbcode input when evaluating parent-child tag relationships
        */
        "bbcode": {
            openTag: function(params,content) {
                return '';
            },
            closeTag: function(params,content) {
                return '';
            }
        },
        "code": {
            openTag: function(params,content) {
                return '<span class="xbbcode-code">';
            },
            closeTag: function(params,content) {
                return '</span>';
            },
            noParse: true
        },
        "color": {
            openTag: function(params,content) {
            
                var colorCode = params.substr(1) || "black";
                colorNamePattern.lastIndex = 0;
                colorCodePattern.lastIndex = 0;
                if ( !colorNamePattern.test( colorCode ) ) {
                    if ( !colorCodePattern.test( colorCode ) ) {
                        colorCode = "black";
                    } else {
                        if (colorCode.substr(0,1) !== "#") {
                            colorCode = "#" + colorCode;
                        }
                    }
                }
            
                return '<span style="color:' + colorCode + '">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        "i": {
            openTag: function(params,content) {
                return '<span class="xbbcode-i">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        "img": {
            openTag: function(params,content) {
            
                var myUrl = content;
                
                urlPattern.lastIndex = 0;
                if ( !urlPattern.test( myUrl ) ) {
                    myUrl = "";
                }
            
                return '<img src="' + myUrl + '" />';
            },
            closeTag: function(params,content) {
                return '';
            },
            displayContent: false
        },
        "list": {
            openTag: function(params,content) {
                return '<ul>';
            },
            closeTag: function(params,content) {
                return '</ul>';
            },
            restrictChildrenTo: ["*", "li"]
        },
        "noparse": {
            openTag: function(params,content) {
                return '';
            },
            closeTag: function(params,content) {
                return '';
            },
            noParse: true
        },
        "php": {
            openTag: function(params,content) {
                return '<span class="xbbcode-code">';
            },
            closeTag: function(params,content) {
                return '</span>';
            },
            noParse: true
        },
        "quote": {
            openTag: function(params,content) {
                return '<blockquote class="xbbcode-blockquote">';
            },
            closeTag: function(params,content) {
                return '</blockquote>';
            }
        },
        "s": {
            openTag: function(params,content) {
                return '<span class="xbbcode-s">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        "size": {
            openTag: function(params,content) {
            
                var mySize = parseInt(params.substr(1),10) || 0;
                if (mySize < 4 || mySize > 40) {
                    mySize = 14;
                }
            
                return '<span class="xbbcode-size-' + mySize + '">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        "table": {
            openTag: function(params,content) {
                return '<table class="xbbcode-table">';
            },
            closeTag: function(params,content) {
                return '</table>';
            },
            restrictChildrenTo: ["tbody","thead", "tfoot", "tr"]
        },
        "tbody": {
            openTag: function(params,content) {
                return '<tbody>';
            },
            closeTag: function(params,content) {
                return '</tbody>';
            },
            restrictChildrenTo: ["tr"],
            restrictParentsTo: ["table"]
        },
        "tfoot": {
            openTag: function(params,content) {
                return '<tfoot>';
            },
            closeTag: function(params,content) {
                return '</tfoot>';
            },
            restrictChildrenTo: ["tr"],
            restrictParentsTo: ["table"]
        },
        "thead": {
            openTag: function(params,content) {
                return '<thead class="xbbcode-thead">';
            },
            closeTag: function(params,content) {
                return '</thead>';
            },
            restrictChildrenTo: ["tr"],
            restrictParentsTo: ["table"]
        },
        "td": {
            openTag: function(params,content) {
                return '<td class="xbbcode-td">';
            },
            closeTag: function(params,content) {
                return '</td>';
            },
            restrictParentsTo: ["tr"]
        },
        "th": {
            openTag: function(params,content) {
                return '<td class="xbbcode-th">';
            },
            closeTag: function(params,content) {
                return '</td>';
            },
            restrictParentsTo: ["tr"]
        },
        "tr": {
            openTag: function(params,content) {
                return '<tr class="xbbcode-tr">';
            },
            closeTag: function(params,content) {
                return '</tr>';
            },
            restrictChildrenTo: ["td","th"],
            restrictParentsTo: ["table","tbody","tfoot","thead"]
        },
        "u": {
            openTag: function(params,content) {
                return '<span class="xbbcode-u">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        "url": {
            openTag: function(params,content) {
            
                var myUrl;
            
                if (!params) {
                    myUrl = content.replace(/<.*?>/g,"");
                } else {
                    myUrl = params.substr(1);
                }
                
                urlPattern.lastIndex = 0;
                if ( !urlPattern.test( myUrl ) ) {
                    myUrl = "#";
                }
            
                return '<a href="' + myUrl + '">';
            },
            closeTag: function(params,content) {
                return '</a>';
            }
        },
        /*
            The [*] tag is special since the user does not define a closing [/*] tag when writing their bbcode.
            Instead this module parses the code and adds the closing [/*] tag in for them. None of the tags you
            add will act like this and this tag is an exception to the others.
        */
        "*": {
            openTag: function(params,content) {
                return "<li>";
            },
            closeTag: function(params,content) {
                return "</li>";
            },
            restrictParentsTo: ["list"]
        }
    };
    
    // create tag list and lookup fields
    tagList = [];
    (function() {
        var prop,
            ii,
            len;
        for (prop in tags) {
            if (tags.hasOwnProperty(prop)) {
                if (prop === "*") {
                    tagList.push("\\" + prop);
                } else {
                    tagList.push(prop);
                    if ( tags[prop].noParse ) {
                        tagsNoParseList.push(prop);
                    }
                }
                
                tags[prop].validChildLookup = {};
                tags[prop].validParentLookup = {};
                tags[prop].restrictParentsTo = tags[prop].restrictParentsTo || [];
                tags[prop].restrictChildrenTo = tags[prop].restrictChildrenTo || [];
                
                len = tags[prop].restrictChildrenTo.length;
                for (ii = 0; ii < len; ii++) {
                    tags[prop].validChildLookup[ tags[prop].restrictChildrenTo[ii] ] = true;
                }
                len = tags[prop].restrictParentsTo.length;
                for (ii = 0; ii < len; ii++) {
                    tags[prop].validParentLookup[ tags[prop].restrictParentsTo[ii] ] = true;
                }
            }
        }
    })();
    
    bbRegExp = new RegExp("<bbcl=([0-9]+) (" + tagList.join("|") + ")([ =][^>]*?)?>((?:.|[\\r\\n])*?)<bbcl=\\1 /\\2>", "gi"); 
    pbbRegExp = new RegExp("\\[(" + tagList.join("|") + ")([ =][^\\]]*?)?\\]([^\\[]*?)\\[/\\1\\]", "gi"); 
    pbbRegExp2 = new RegExp("\\[(" + tagsNoParseList.join("|") + ")([ =][^\\]]*?)?\\]([\\s\\S]*?)\\[/\\1\\]", "gi");    

    // create the regex for escaping ['s that aren't apart of tags
    (function() {
        var closeTagList = [];
        for (var ii = 0; ii < tagList.length; ii++) {
            if ( tagList[ii] !== "\\*" ) { // the * tag doesn't have an offical closing tag
                closeTagList.push ( "/" + tagList[ii] );
            }
        }

        openTags = new RegExp("(\\[)((?:" + tagList.join("|") + ")(?:[ =][^\\]]*?)?)(\\])", "gi"); 
        closeTags = new RegExp("(\\[)(" + closeTagList.join("|") + ")(\\])", "gi"); 
    })();
    
    // -----------------------------------------------------------------------------
    // private functions
    // -----------------------------------------------------------------------------
    
    function checkParentChildRestrictions(parentTag, bbcode, bbcodeLevel, tagName, tagParams, tagContents, errQueue) {
        
        errQueue = errQueue || [];
        bbcodeLevel++;
        
        // get a list of all of the child tags to this tag
        var reTagNames = new RegExp("(<bbcl=" + bbcodeLevel + " )(" + tagList.join("|") + ")([ =>])","gi"),
            reTagNamesParts = new RegExp("(<bbcl=" + bbcodeLevel + " )(" + tagList.join("|") + ")([ =>])","i"),
            matchingTags = tagContents.match(reTagNames) || [],
            cInfo,
            errStr,
            ii,
            childTag,
            pInfo = tags[parentTag] || {};
        
        reTagNames.lastIndex = 0;
        
        if (!matchingTags) {
            tagContents = "";
        }
        
        for (ii = 0; ii < matchingTags.length; ii++) {
            reTagNamesParts.lastIndex = 0;
            childTag = (matchingTags[ii].match(reTagNamesParts))[2].toLowerCase();
            
            if ( pInfo.restrictChildrenTo.length > 0 ) {
                if ( !pInfo.validChildLookup[childTag] ) {
                    errStr = "The tag \"" + childTag + "\" is not allowed as a child of the tag \"" + parentTag + "\".";
                    errQueue.push(errStr);
                }
            }
            cInfo = tags[childTag] || {};
            if ( cInfo.restrictParentsTo.length > 0 ) {
                if ( !cInfo.validParentLookup[parentTag] ) {
                    errStr = "The tag \"" + parentTag + "\" is not allowed as a parent of the tag \"" + childTag + "\".";
                    errQueue.push(errStr);
                }
            }
            
        }
        
        tagContents = tagContents.replace(bbRegExp, function(matchStr, bbcodeLevel, tagName, tagParams, tagContents ) {
            errQueue = checkParentChildRestrictions(tagName, matchStr, bbcodeLevel, tagName, tagParams, tagContents, errQueue);
            return matchStr;
        });
        return errQueue;
    }
    
    /*
        This function updates or adds a piece of metadata to each tag called "bbcl" which 
        indicates how deeply nested a particular tag was in the bbcode. This property is removed
        from the HTML code tags at the end of the processing.
    */
    function updateTagDepths(tagContents) {
        tagContents = tagContents.replace(/\<([^\>][^\>]*?)\>/gi, function(matchStr, subMatchStr) {
            var bbCodeLevel = subMatchStr.match(/^bbcl=([0-9]+) /);
            if (bbCodeLevel === null) {
                return "<bbcl=0 " + subMatchStr + ">";
            } else {
                return "<" + subMatchStr.replace(/^(bbcl=)([0-9]+)/, function(matchStr, m1, m2) {
                    return m1 + (parseInt(m2, 10) + 1);
                }) + ">";
            }
        });
        return tagContents;
    }
    
    /*
        This function removes the metadata added by the updateTagDepths function
    */
    function unprocess(tagContent) {
        return tagContent.replace(/<bbcl=[0-9]+ \/\*>/gi,"").replace(/<bbcl=[0-9]+ /gi,"&#91;").replace(/>/gi,"&#93;");
    }
    
    var replaceFunct = function(matchStr, bbcodeLevel, tagName, tagParams, tagContents) {
    
        tagName = tagName.toLowerCase();

        var processedContent = tags[tagName].noParse ? unprocess(tagContents) : tagContents.replace(bbRegExp, replaceFunct),
            openTag = tags[tagName].openTag(tagParams,processedContent),
            closeTag = tags[tagName].closeTag(tagParams,processedContent);
            
        if ( tags[tagName].displayContent === false) {
            processedContent = "";
        }
        
        return openTag + processedContent + closeTag;
    };

    function parse(config) {
        var output = config.text;
        output = output.replace(bbRegExp, replaceFunct);
        return output;
    }
    
    /*
        The star tag [*] is special in that it does not use a closing tag. Since this parser requires that tags to have a closing
        tag, we must pre-process the input and add in closing tags [/*] for the star tag.
        We have a little levaridge in that we know the text we're processing wont contain the <> characters (they have been
        changed into their HTML entity form to prevent XSS and code injection), so we can use those characters as markers to
        help us define boundaries and figure out where to place the [/*] tags.
    */
    function fixStarTag(text) {
        text = text.replace(/\[(?!\*[ =\]]|list([ =][^\]]*)?\]|\/list[\]])/ig, "<");
        text = text.replace(/\[(?=list([ =][^\]]*)?\]|\/list[\]])/ig, ">");

        while (text !== (text = text.replace(/>list([ =][^\]]*)?\]([^>]*?)(>\/list])/gi, function(matchStr,contents,endTag) {
            
            var innerListTxt = matchStr;
            while (innerListTxt !== (innerListTxt = innerListTxt.replace(/\[\*\]([^\[]*?)(\[\*\]|>\/list])/i, function(matchStr,contents,endTag) {
                if (endTag === ">/list]") {
                    endTag = "</*]</list]";
                } else {
                    endTag = "</*][*]";
                }
                var tmp = "<*]" + contents + endTag;
                return tmp;
            })));
            
            innerListTxt = innerListTxt.replace(/>/g, "<");            
            return innerListTxt;
        })));
        
        // add ['s for our tags back in
        text = text.replace(/</g, "[");
        return text;
    };
    
    function addBbcodeLevels(text) {
        while ( text !== (text = text.replace(pbbRegExp, function(matchStr, tagName, tagParams, tagContents) {
            matchStr = matchStr.replace(/\[/g, "<");
            matchStr = matchStr.replace(/\]/g, ">");
            return updateTagDepths(matchStr);
        })) );
        return text;
    }
    
    // -----------------------------------------------------------------------------
    // public functions
    // -----------------------------------------------------------------------------
    
    me.process = function(config) {
    
        var ret = {html: "", error: false},
            errQueue = [];

        config.text = config.text.replace(/</g, "&lt;"); // escape HTML tag brackets
        config.text = config.text.replace(/>/g, "&gt;"); // escape HTML tag brackets
        
        config.text = config.text.replace(openTags, function(matchStr, openB, contents, closeB) {
            return "<" + contents + ">";
        });
        config.text = config.text.replace(closeTags, function(matchStr, openB, contents, closeB) {
            return "<" + contents + ">";
        });
        
        config.text = config.text.replace(/\[/g, "&#91;"); // escape ['s that aren't apart of tags
        config.text = config.text.replace(/\]/g, "&#93;"); // escape ['s that aren't apart of tags
        config.text = config.text.replace(/</g, "["); // escape ['s that aren't apart of tags
        config.text = config.text.replace(/>/g, "]"); // escape ['s that aren't apart of tags

        // process tags that don't have their content parsed
        while ( config.text !== (config.text = config.text.replace(pbbRegExp2, function(matchStr, tagName, tagParams, tagContents) {
            tagContents = tagContents.replace(/\[/g, "&#91;");
            tagContents = tagContents.replace(/\]/g, "&#93;");
            tagParams = tagParams || "";
            tagContents = tagContents || "";
            return "[" + tagName + tagParams + "]" + tagContents + "[/" + tagName + "]";
        })) );

        config.text = fixStarTag(config.text); // add in closing tags for the [*] tag
        config.text = addBbcodeLevels(config.text); // add in level metadata

        errQueue = checkParentChildRestrictions("bbcode", config.text, -1, "", "", config.text);
        
        ret.html = parse(config);

        if ( ret.html.indexOf("[") !== -1 || ret.html.indexOf("]") !== -1) {
            errQueue.push("Some tags appear to be misaligned.");
        }
    
        if (config.removeMisalignedTags) {
            ret.html = ret.html.replace(/\[.*?\]/g,"");
        }
        if (config.addInLineBreaks) {
            ret.html = ret.html.replace(/\r\n/g, "\n");
            ret.html = ret.html.replace(/(\r|\n)/g, "$1<br/>");
        }
    
        ret.html = ret.html.replace("&#91;", "["); // put ['s back in
        ret.html = ret.html.replace("&#93;", "]"); // put ['s back in
        
        ret.error = (errQueue.length === 0) ? false : true;
        ret.errorQueue = errQueue;
        
        return ret;
    }
    
    return me;
})();
/*
    boron: some utilities for immutability
*/


Boron = {}

Boron.persistent_merge = function(props, data) {
    /// merges a 'flattened' data array into props in a persistent fashion
    /// the new object reuses old data where possible, so requires ~log N additional space
    
    /// given props {fun: {yay:123, ok:123}, cat:{dog:123}}    
    ///   and  data {'fun.yay':0, 'cat.ant.bear':0}}          
    ///     returns {fun: {yay:0, ok:123}, cat:{ant:{bear:0}}}
    
    data = data || []
    
    if(Array.isArray(data) || Array.isArray(data)) {
        // THINK: what do we do with arrays?
        if(Array.isArray(data) !== Array.isArray(props)) {
            // THINK: how to deal with array / object mismatch?
        }
    }
    
    // THINK: what about when data is {cat:{'ant.bear':0}} ?
    
    return Object.keys(data).reduce(function(props, key) {              // OPT: combine these instead of doing them separately
        return Boron.set_deep_value(props, key, data[key])
    }, props)
}

Boron.set_deep_value = function(props, path, value) {
    /// set a value from a flattened path
    
    /// given props {fun: {yay:123, ok:123}, cat:{dog:123}}
    ///   and  path 'fun.ok' 
    ///   and value 456
    ///     returns {fun: {yay:123, ok:456}, cat:{dog:123}}
    
    // var segs = path.split('.')
    // THINK: this is vaguely awful, but without lookbehind it's hard to say "only split on dots that aren't slashed"
    // var segs = path.split('').reverse().join('')
    //                .split(/\.(?!\\)/).reverse()
    //                .map(function(chunk) {return chunk.split('').reverse().join('')})
    //                .map(function(chunk) {return chunk.replace(/[\\]$/, '')})
    
    // THINK: this is vaguely awfuller, but works and is fairly fast and readable. 
    var magic = "___MAGIC___"
    var magic_regex = new RegExp(magic, 'g');
    var path = path.replace(/\\\./g, magic)
    var segs = path.split('.').map(function(chunk) {return chunk.replace(magic_regex, '.')})
    
    var last = segs.pop()
    var final = next = Boron.shallow_copy(props)

    segs.forEach(function(seg) {
        next[seg] = Boron.shallow_copy(next[seg])
        next = next[seg]
    })

    next[last] = value
    return final
}

Boron.shallow_copy = function(obj) {
    if(Array.isArray(obj)) return obj.slice()
    return Object.keys(obj || {}).reduce(function(acc, key) {acc[key] = obj[key]; return acc}, {})
}

Boron.shallow_diff = function(oldObj, newObj) { // results come from newObj
    return Object.keys(oldObj).reduce(function(acc, key) {
        if(JSON.stringify(oldObj[key]) != JSON.stringify(newObj[key]))
            acc[key] = newObj[key] // this pointer copies deep data
        return acc
    }, oldObj.constructor())
}

Boron.deep_diff = function(oldObj, newObj) { // results come from newObj
    return Object.keys(newObj).reduce(function(acc, key) {
        var oldtype = typeof oldObj[key]
        var newtype = typeof newObj[key]
        
        if(oldtype != newtype) {
            acc[key] = newObj[key] // this pointer copies deep data
            return acc
        }
        
        if(oldtype == 'object') {
            var diff = Boron.deep_diff(oldObj[key], newObj[key])
            if(Object.keys(diff).length)
                acc[key] = diff
            return acc
        }
        
        if(oldObj[key] !== newObj[key])
            acc[key] = newObj[key]
        return acc
    }, newObj.constructor())
}

Boron.flatten = function(obj, prefix) {
    /// convert {fun: {yay: 123}} into {'fun.yay': 123}
    
    if(!Boron.proper_object(obj)) return {}
    
    var newobj = {}
    prefix = prefix ? prefix + '.' : ''
    
    for(var key in obj) {
        if(!Boron.proper_object(obj[key])) {
            newobj[prefix+key] = obj[key]
        } else {
            newobj = Boron.extend(newobj, Boron.flatten(obj[key], prefix+key)) // OPT: lotsa GC here
        }
    }
    
    return newobj
}

Boron.unflatten = function(obj) {
    /// convert {'fun.yay': 123} into {fun: {yay: 123}}
    
    return Boron.persistent_merge({}, obj) // OPT: GC
    // return Object.keys(obj||{}).reduce(function(acc, key) {return Boron.set_deep_value(acc, key, obj[key])}, {}) // OPT: GC
}

Boron.proper_object = function(obj) { return typeof obj == 'object' && !Array.isArray(obj) } 

Boron.extend = function() {
    /// given ({fun:123, yay:123}, {yay:456, ok:789}) as args, returns a new object {fun:123, yay:456, ok:789}
    
    var newobj = {}
    Array.prototype.slice.call(arguments).forEach(function(arg) {
        for(var prop in arg) {
            newobj[prop] = arg[prop] } })
    return newobj
}


Boron.memoize = function(f) {
    var table = {}
    return function() {
        var args = Array.prototype.slice.call(arguments)
        var key = args.toString()
        return table[key] ? table[key] : (table[key] = f.apply(null, args))
    } 
}

PBFiles = {}

PBFiles.oldFile = null

PBFiles.createPuff = function(content, type) {
    var payload = {}
    
    var type   = type || 'file'
    var routes = ['local'];

    var userRecord = PB.getCurrentUserRecord()
    var userRecordsForWhomToEncrypt = [userRecord]
    var previous, puff
    
    puff = PB.simpleBuildPuff(type, content, payload, routes, userRecordsForWhomToEncrypt)
    

    // PB.useSecureInfo(function(identities, currentUsername, privateRootKey, privateAdminKey, privateDefaultKey) {
    //     var privateEnvelopeAlias
    //     puff = PB.buildPuff(currentUsername, privateDefaultKey, routes, type, content, payload, previous, userRecordsForWhomToEncrypt, privateEnvelopeAlias)
    // })

    return puff
}

PBFiles.prepBlob = function(str, type) {
    if (typeof str != 'string')
        str = JSON.stringify(str)

    var blob

    if (type == 'file')
        blob = PBFiles.dataURItoBlob(str)
    else
        blob = new Blob([str], {type: 'text/plain'})


    // IE needs to directly save the blob object
    if (navigator.appVersion.toString().indexOf('.NET') > 0)
        return blob

    if(PBFiles.oldFile)
       window.URL.revokeObjectURL(PBFiles.oldFile)

    PBFiles.oldFile = window.URL.createObjectURL(blob)

    return PBFiles.oldFile
}

PBFiles.extractLetterPuff = function(content) {
    var puff = PB.parseJSON(content)
    if(!puff) 
        return PB.emptyPromise('Envelope was not JSON encoded')
    
    // var userRecord = PB.getCurrentUserRecord()
    // var pubkey = userRecord.defaultKey
    
    var letter = PB.Data.getDecryptedPuffPromise(puff)
    
    return letter
}

PBFiles.openPuffFile = function(element) {                
    return PBFiles.handleFileOpen(element)
}

PBFiles.openTextFile = function(element) {                
    return PBFiles.handleFileOpen(element)
}

PBFiles.openBinaryFile = function(element) {                
    return PBFiles.handleFileOpen(element, 'asDataURI')
}

PBFiles.handleFileOpen = function(element, asDataURI) {                
    return new Promise(function(resolve, reject) {
        var reader = new FileReader()

        reader.onload = function(event) {
            // console.log(reader)
            var dataURIContent = event.target.result
            // var blob = PBFiles.dataURItoBlob(dataURIContent)
            resolve(dataURIContent)
        }
        
        if(!element.files[0]) // THINK: is false the right response?
            return reject('No file selected')
            
        if(asDataURI)
            reader.readAsDataURL(element.files[0])
        else
            reader.readAsText(element.files[0])
    })
}

// via http://stackoverflow.com/questions/4998908/convert-data-uri-to-file-then-append-to-formdata
PBFiles.dataURItoBlob = function(dataURI) {
    // convert base64/URLEncoded data component to raw binary data held in a Blob
    var byteString;
    if (dataURI.split(',')[0].indexOf('base64') >= 0)
        byteString = atob(dataURI.split(',')[1]);
    else
        byteString = unescape(dataURI.split(',')[1]);

    // separate out the mime component
    var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]

    // write the bytes of the string to a typed array
    var ia = new Uint8Array(byteString.length);
    for (var i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }

    return new Blob([ia], {type:mimeString});
}

/*
    events: a pub/sub system with wildcard paths
*/


Events = {}
Events.subs = {}

Events.pub = function(path, data) {
    return setImmediate(function() {Events.start_pub(path, data)})              // do it next tick
}

Events.sub = function(path, handler) {
    path = Events.scrub_path(path).join('/')
    if(!Events.subs[path]) Events.subs[path] = []
    Events.subs[path].push(handler)
}

Events.unsub = function(path, handler) {
    path = Events.scrub_path(path).join('/')

    var subs = Events.subs[path]
    if(!subs) return false

    var index = subs.indexOf(handler)
    if(index == -1) return false

    subs.splice(index, 1)
}

Events.start_pub = function(path, data) {
    //// pub to * at each level and then to path itself
    var pathlist = Events.scrub_path(path)
    var realpath = pathlist.join('/')

    Events.try_pub('*', data, realpath)                                         // global catchall

    pathlist.reduce(function(acc, seg) {                                        // channel catchalls
        var newacc = acc + seg + '/'
        Events.try_pub(newacc + '*', data, realpath)
        return newacc
    }, '')

    Events.try_pub(realpath, data, realpath)                                    // actual channel
}

Events.try_pub = function(path, data, realpath) {
    var handlers = Events.subs[path]
    if(!handlers || !handlers.length) return false
    handlers.forEach(function(handler) {handler(data, realpath)})
    // THINK: use setImmediate here?
}


Events.scrub_path = function(path) {
    return path.replace(/^[^\w*-]+/, '')                                        // trim leading slashes etc
        .replace(/[^\w*-]+$/, '')                                               // trim trailing gunk
        .split('/')                                                             // break out the path segments
        .map(function(item) {return item.replace(/[^\w*-]/g, '')})              // scrub each segment
}


// maybe later
// eventlog = []
// Events.sub('*', function(data, path) {
//     eventlog.push([path, data])
// })


/*
    gridbox: a simple system for putting things in places
*/

Gridbox = {}

Gridbox.getGridCoordBox = function(rows, cols, outerwidth, outerheight, verticalPadding) {
    var min = function(a, b) {return Math.min(a, b)}
    var max = function(a, b) {return Math.max(a, b)}
    var gridwidth  = outerwidth  / cols
    var gridheight = outerheight / rows
    var eq = function(a, b) {return a == b}
    var grid = Array.apply(0, Array(rows))
        .map(function() {return Array.apply(0, Array(cols))
            .map(function() {return 0})}) // build 2D array

    return { get: function() {return grid}
        , set_eq: function(new_eq) {eq = new_eq}
        , add: function(width, height, miny, minx, maxy, maxx, pointer) {
            maxy = min(maxy||rows-height, rows-height), maxx = min(maxx||cols-width, cols-width)
            miny = min(miny||0, maxy), minx = min(minx||0, maxx)
            if(maxx<0 || maxy<0) return PB.onError('Block is too big for the grid')

            top: for(var y = miny; y <= maxy; y++) {
                bot: for(var x = minx; x <= maxx;  x++) {
                    for(var dy = 0; dy < height; dy++) {
                        for(var dx = 0; dx < width; dx++) {
                            if(grid[y+dy][x+dx]) continue bot }}
                    break top }}
            if(x == maxx+1 && y == maxy+1) return PB.onError('No room in the grid')
            if(x == null || y == null) return PB.onError('Block too big for the grid')
            for(var dy = 0; dy < height; dy++) {
                for(var dx = 0; dx < width; dx++) {
                    grid[y+dy][x+dx] = pointer || 1 } }
            return {width: width*gridwidth, height: height*gridheight, x: x*gridwidth, y: y*gridheight+(verticalPadding/1.5)} // THINK: generalize verticalPadding 
        }
    }
}

Gridbox.findNeighbor = function(grid, pointer, dir) {
    var boxCoords = Gridbox.findBoxInGrid(grid, pointer)
    if(!boxCoords) return false

    // TODO: need to indicate if dirBox is outside of grid, versus pointer not found

    var dirBox = Gridbox.makeDirBox(boxCoords, dir)
    if(!dirBox) return false

    return Gridbox.firstThingInBox(grid, dirBox[0], dirBox[1])
}

Gridbox.findBoxInGrid = function(grid, target, eq) {
    /// find something in a grid box and return coords
    /// NOTE: this assumes rectilinear shapes
    eq = eq || function(a, b) {return a === b}
    eq = function(a, b) {return a.sig === b.sig} // TODO: encapsulate eq in gridBox // OPT: don't look inside

    top: for(var y = 0, ly = grid.length; y < ly; y++)
        for(var x = 0, lx = grid[y].length; x < lx; x++)
            if(eq(grid[y][x], target)) break top                        // find top and left coords

    if(y == grid.length && x == grid[0].length) return false            // target not in box

    for(var dy = 0, ly = grid.length-y; dy < ly; dy++)
        if(!eq(grid[y+dy][x], target)) break                            // find bottom coord

    for(var dx = 0, lx = grid[y].length-x; dx < lx; dx++)
        if(!eq(grid[y][x+dx], target)) break                            // find right coord

    return [[x, y], [x+dx-1, y+dy-1]]                                   // minus one because deltas always overshoot
}

Gridbox.firstThingInBox = function(grid, topleft, botright) {
    for(var y = Math.max(topleft[1], 0), ly = Math.min(botright[1], grid.length-1); y <= ly; y++)
        for(var x = Math.max(topleft[0], 0), lx = Math.min(botright[0], grid[0].length-1); x <= lx; x++)
            if(grid[y][x]) return grid[y][x]                            // lteq because our boxes are inclusive;
}                                                                       // boundaries are built in.

Gridbox.makeDirBox = function(boxCoords, dir) {
    var top   = boxCoords[0][1]
    var left  = boxCoords[0][0]
    var bot   = boxCoords[1][1]
    var right = boxCoords[1][0]

    if(dir == 'up')    return [[left, top-1],  [right, top-1]]
    if(dir == 'down')  return [[left, bot+1],  [right, bot+1]]
    if(dir == 'left')  return [[left-1, top],  [left-1, bot]]
    if(dir == 'right') return [[right+1, top], [right+1, bot]]
}

/*
     ____  _____ _____ _____ _____ _____ 
    |    \|  _  |   __|     | __  |  _  |
    |  |  |     |  |  |  |  | __ -|     |
    |____/|__|__|_____|_____|_____|__|__|
    
    dagoba: a tiny in-memory graph database

    ex: 
    V = [ {name: 'alice'}                                         // alice gets auto-_id (prolly 1)
        , {_id: 10, name: 'bob', hobbies: ['asdf', {x:3}]}] 
    E = [ {_out: 1, _in: 10, _label: 'knows'} ]
    g = Dagoba.graph(V, E)
    
    g.addVertex({name: 'charlie', _id: 'charlie'})                // string ids are fine
    g.addVertex({name: 'delta', _id: '30'})                       // actually they're all strings

    g.addEdge({_out: 10, _in: 30, _label: 'parent'})
    g.addEdge({_out: 10, _in: 'charlie', _label: 'knows'})

    g.v(1).out('knows').out().run()                               // returns [charlie, delta]
    
    q = g.v(1).out('knows').out().take(1)
    q.run()                                                       // returns [charlie]
    q.run()                                                       // returns [delta]    (but don't rely on result order!)
    q.run()                                                       // returns []
*/


Dagoba = {}                                                       // the namespace

Dagoba.G = {}                                                     // the prototype

Dagoba.graph = function(V, E) {                                   // the factory
  var graph = Object.create( Dagoba.G )
  graph.vertices = []                                             // fresh copies so they're not shared
  graph.edges = []
  graph.vertexIndex = {}
  if(V && Array.isArray(V)) graph.addVertices(V)                  // arrays only, because you wouldn't
  if(E && Array.isArray(E)) graph.addEdges(E)                     // call this with singular V and E
  return graph
}

Dagoba.G.v = function() {                                         // a query initializer: g.v() -> query
  var query = Dagoba.query(this)
  query.add(['vertex'].concat( [].slice.call(arguments) ))
  return query
}

Dagoba.G.addVertex = function(vertex) {
  if(!vertex._id) 
    vertex._id = this.vertices.length+1
  // TODO: ensure unique _id
  this.vertices.push(vertex) // THINK: the user may retain a pointer to vertex, which they might mutate later >.<
  // can take away user's ability to set _id and lose the index cache hash, because building it causes big rebalancing slowdowns and runs the GC hard. (or does it?) [this was with a million items, indexed by consecutive ints. generally we need settable _id because we need to grab vertices quickly by external key]
  this.vertexIndex[vertex._id] = vertex
  vertex._out = []; vertex._in = []
}

Dagoba.G.addEdge = function(edge) {
  if(!edge._label) return false
  edge._in  = this.findVertexById(edge._in)
  edge._out = this.findVertexById(edge._out)
  if(!(edge._in && edge._out)) return false
  edge._out._out.push(edge)
  edge._in._in.push(edge)
  this.edges.push(edge)
}

Dagoba.G.addVertices = function(vertices) { vertices.forEach(this.addVertex.bind(this)) }
Dagoba.G.addEdges    = function(edges)    { edges   .forEach(this.addEdge  .bind(this)) }

Dagoba.G.findVertexById = function(vertex_id) {
  return this.vertexIndex[vertex_id] }

Dagoba.G.findVerticesByIds = function(ids) {
  return ids.length == 1 ? [].concat( this.findVertexById(ids[0]) || [] )
       : ids.map( this.findVertexById.bind(this) ).filter(Boolean) }

Dagoba.G.findVertices = function(ids) {
  return typeof ids[0] == 'object' ? this.searchVertices(ids[0])
       : ids.length == 0 ? this.vertices.slice()                  // OPT: do we need the slice?
       : this.findVerticesByIds(ids) }

Dagoba.G.searchVertices = function(obj) {
  return this.vertices.filter(
    function(vertex) {
      return Object.keys(obj).reduce(
        function(acc, key) {
          return acc && obj[key] == vertex[key] }, true ) } ) }

Dagoba.G.findEdgeById = function(edge_id) {
  return Dagoba.find(this.edges, function(edge) {return edge._id == edge_id} ) }

Dagoba.G.findOutEdges = function(vertex) { return vertex._out; }
Dagoba.G.findInEdges  = function(vertex) { return vertex._in;  }

Dagoba.G.toString = function() {                                  // kids, don't hand code JSON
  return '{"V":' + JSON.stringify(this.vertices, Dagoba.cleanvertex)
       + ',"E":' + JSON.stringify(this.edges,    Dagoba.cleanedge) 
       + '}' }

Dagoba.fromString = function(str) {                               // another graph constructor
  var obj = JSON.parse(str)
  return Dagoba.graph(obj.V, obj.E) 
}



Dagoba.Q = {}                                                     // prototype

Dagoba.query = function(graph) {                                  // factory (only called by a graph's query initializers)
  var query = Object.create( Dagoba.Q )
  
  query.   graph = graph                                          // the graph itself
  query.   state = []                                             // state for each step
  query. program = []                                             // list of steps to take  
  query.gremlins = []                                             // gremlins for each step
  
  return query
}

Dagoba.Q.run = function() {                                       // the magic lives here
  
  var graph = this.graph                                          // these are closed over in the helpers
  var state = this.state                                          // so we give them a spot in the frame
  var program  = this.program
  var gremlins = this.gremlins

  var max = program.length-1                                      // work backwards
  var pc = max                                                    // program counter
  var done = -1                                                   // behindwhich things have finished
  var results = []                                                // results for this run
  var maybe_gremlin = false                                       // a mythical beast

  if(!program.length) return []                                   // don't bother
  
  
  // driver loop
  while(done < max) {
    maybe_gremlin = try_step(pc, maybe_gremlin)                   // maybe_gremlin is a gremlin or (string | false)
    
    if(maybe_gremlin == 'pull') {
      maybe_gremlin = false
      if(pc-1 > done) {
        pc--
        continue
      } else {
        done = pc
      }
    }
    
    if(maybe_gremlin == 'done') {
      done = pc
      maybe_gremlin = false
    }
    
    pc++
    
    if(pc > max) {                                                // a gremlin is popping out of the pipeline. catch it!
      if(maybe_gremlin)
        results.push(maybe_gremlin)
      maybe_gremlin = false
      pc--
    }
  }

  // TODO: deal with gremlin paths / history and gremlin "collisions"
  
  results = results.map(function(gremlin) {                       // make this a query component (or posthook)
    return gremlin.result ? gremlin.result : gremlin.vertex } )

  results = Dagoba.firehooks('postquery', this, results)[0] 
  
  return results
  
  // NAMED HELPERS
  
  function try_step(pc, maybe_gremlin) {
    var step = program[pc]
    var my_state = (state[pc] = state[pc] || {})
    if(!Dagoba.QFuns[step[0]]) return Dagoba.onError('Unrecognized function call: ' + step[0]) || maybe_gremlin || 'pull'
    return Dagoba.QFuns[step[0]](graph, step.slice(1) || {}, maybe_gremlin, my_state)
  }
    
  function gremlin_boxer(step_index) { return function(gremlin) { return [step_index, gremlin] } }
  
  function stepper(step_index, gremlin) {
    var step = program[step_index]
    if(!Dagoba.QFuns[step[0]]) return Dagoba.onError('Unrecognized function call: ' + step[0]) || {}
    return Dagoba.QFuns[step[0]](graph, step.slice(1) || {}, gremlin || {}, state[step_index] || {})
  }
  
  function eat_gremlins(gremlins, step_index, result) {
    return gremlins.concat( (result.stay || []).map(gremlin_boxer(step_index))   )
                   .concat( (result.go   || []).map(gremlin_boxer(step_index+1)) ) }
  
  function setbang_gremlins(step_index, result) {gremlins = eat_gremlins(gremlins, step_index, result)}
}


Dagoba.Q.add = function(list) {                                  // add a new traversal to the query
  this.program.push(list)
  return this
}

Dagoba.addQFun = function(name, fun) {                            // add a new traversal type
  Dagoba.QFuns[name] = fun
  Dagoba.Q[name] = function() { return this.add([name].concat([].slice.apply(arguments))) } 
  // TODO: accept string fun and allow extra params, for building quick aliases like
  //       Dagoba.addQFun('children', 'out') <-- if all out edges are kids
  //       Dagoba.addQFun('nthGGP', 'inN', 'parent')
  // var methods = ['out', 'in', 'take', 'property', 'outAllN', 'inAllN', 'unique', 'filter', 'outV', 'outE', 'inV', 'inE', 'both', 'bothV', 'bothE']
}


Dagoba.QFuns = {}                                                 // all traversal types

Dagoba.addQFun('vertex', function(graph, args, gremlin, state) {
  if(!state.vertices) state.vertices = graph.findVertices(args)
  if(!state.vertices.length) return 'done'
  var vertex = state.vertices.pop() 
  return Dagoba.make_gremlin(vertex)
})
  
Dagoba.addQFun('out', function(graph, args, gremlin, state) {
  if(!gremlin && (!state.edges || !state.edges.length)) return 'pull'
  if(!state.edges || !state.edges.length) 
    state.edges = graph.findOutEdges(gremlin.vertex).filter(Dagoba.filterThings(args[0]))
  if(!state.edges.length) return 'pull'
  var vertex = state.edges.pop()._in // what?
  var clone = Dagoba.make_gremlin(vertex) // we lose history here: use clone_gremlin(gremlin).goto(vertex) instead
  return clone
})

Dagoba.addQFun('outAllN', function(graph, args, gremlin, state) {
  var filter = args[0]
  var limit = args[1]-1
  
  if(!state.edgeList) { // initialize
    if(!gremlin) return 'pull'
    state.edgeList = []
    state.current = 0
    state.edgeList[0] = graph.findOutEdges(gremlin.vertex).filter(Dagoba.filterThings(filter))
  }
  
  if(!state.edgeList[state.current].length) { // finished this round
    if(state.current >= limit || !state.edgeList[state.current+1]   // totally done, or the next round has no items
                              || !state.edgeList[state.current+1].length) {
      state.edgeList = false
      return 'pull'
    }
    state.current++ // go to next round
    state.edgeList[state.current+1] = [] 
  }
  
  var vertex = state.edgeList[state.current].pop()._in
  
  if(state.current < limit) { // add all our matching edges to the next level
    if(!state.edgeList[state.current+1]) state.edgeList[state.current+1] = []
    state.edgeList[state.current+1] = state.edgeList[state.current+1].concat(
      graph.findOutEdges(vertex).filter(Dagoba.filterThings(filter))
    )
  }
  
  var clone = Dagoba.make_gremlin(vertex) // we lose history here: use clone_gremlin(gremlin).goto(vertex) instead
  return clone
})
  
Dagoba.addQFun('inAllN', function(graph, args, gremlin, state) {
  var filter = args[0]
  var limit = args[1]-1
  
  if(!state.edgeList) {                                           // initialize
    if(!gremlin) return 'pull'
    state.edgeList = []
    state.current = 0
    state.edgeList[0] = graph.findInEdges(gremlin.vertex).filter(Dagoba.filterThings(filter))
  }
  
  if(!state.edgeList[state.current].length) {                     // finished this round
    if(state.current >= limit || !state.edgeList[state.current+1] // totally done, or the next round has no items
                              || !state.edgeList[state.current+1].length) {
      state.edgeList = false
      return 'pull'
    }
    state.current++                                               // go to next round
    state.edgeList[state.current+1] = [] 
  }
  
  var vertex = state.edgeList[state.current].pop()._out
  
  if(state.current < limit) {                                     // add all our matching edges to the next level
    if(!state.edgeList[state.current+1]) state.edgeList[state.current+1] = []
    state.edgeList[state.current+1] = state.edgeList[state.current+1].concat(
      graph.findInEdges(vertex).filter(Dagoba.filterThings(filter))
    )
  }
  
  var clone = Dagoba.make_gremlin(vertex) // we lose history here: use clone_gremlin(gremlin).goto(vertex) instead
  return clone
})
  
Dagoba.addQFun('in', function(graph, args, gremlin, state) {
  if(!gremlin && (!state.edges || !state.edges.length)) return 'pull'
  if(!state.edges || !state.edges.length) 
    state.edges = graph.findInEdges(gremlin.vertex).filter(Dagoba.filterThings(args[0]))
  if(!state.edges.length) return 'pull'
  var vertex = state.edges.pop()._out // what? // also, abstract this...
  var clone = Dagoba.make_gremlin(vertex) // we lose history here: use clone_gremlin(gremlin).goto(vertex) instead
  return clone
})
  
Dagoba.addQFun('property', function(graph, args, gremlin, state) {
  if(!gremlin) return 'pull'
  gremlin.result = gremlin.vertex[args[0]]
  return gremlin
})
  
Dagoba.addQFun('unique', function(graph, args, gremlin, state) {
  if(!gremlin) return 'pull'
  if(state[gremlin.vertex._id]) return 'pull'                     // we've seen this gremlin, so get another instead
  state[gremlin.vertex._id] = true
  return gremlin
})
  
Dagoba.addQFun('filter', function(graph, args, gremlin, state) {
  if(!gremlin) return 'pull'
  if(typeof args[0] != 'function') return Dagoba.onError('Filter arg is not a function: ' + args[0]) || gremlin
  if(!args[0](gremlin.vertex)) return 'pull'                      // gremlin fails filter function 
  // THINK: would we ever want to filter by other parts of the gremlin?
  return gremlin
})
  
Dagoba.addQFun('take', function(graph, args, gremlin, state) {
  state.taken = state.taken ? state.taken : 0
  if(state.taken == args[0]) {
    state.taken = 0
    return 'done'
  }
  if(!gremlin) return 'pull'
  state.taken++ // THINK: mutating state
  return gremlin
})



// hi! 
// - tune gremlins (collisions, history, etc)
// - interface: show query pieces and params,
// - interface: resumable queries
// - generational queries
// - intersections
// - adverbs
// - you are great!



Dagoba.hooks = {}

Dagoba.addhook = function(type, callback) {
  if(!Dagoba.hooks[type]) Dagoba.hooks[type] = []
  Dagoba.hooks[type].push(callback)
}

Dagoba.firehooks = function(type, query) {
  var args = [].slice.call(arguments, 2)
  return ((Dagoba.hooks || {})[type] || []).reduce(function(acc, callback) {return callback.apply(query, acc)}, args)
}

Dagoba.make_gremlin = function(vertex, state) { return {vertex: vertex, state: state} }

Dagoba.filterThings = function(arg) {
  return function(thing) {
    return !arg ? true                                                                           // nothing is true
         : arg+'' === arg ? thing._label == arg                                                  // check the label
         : Array.isArray(arg) ? !!~arg.indexOf(thing._label) : Dagoba.objFilter(thing, arg) } }  // or a list of labels

Dagoba.objFilter = function(thing, obj) {
  for(var key in obj)
    if(thing[key] != obj[key])
      return false; return true }

Dagoba.find = function(arr, fun) {
  for (var i = 0, len = arr.length; i < len; i++)
    if(fun(arr[i], i, arr))
      return arr[i] }

Dagoba.cleanvertex = function(key, value) {return (key == '_in' || key == '_out') ? undefined : value} // for JSON.stringify
Dagoba.cleanedge   = function(key, value) {return key == '_in' ? value._id : key == '_out' ? value._id : value}

Dagoba.uniqueify = function (results) { // OPT: do this in the query via gremlin collision counting
  return [results.filter(function(item, index, array) {return array.indexOf(item) == index})]}

Dagoba.cleanclone = function (results) { // remove all _-prefixed properties
 return [results.map(function(item) {return JSON.parse(JSON.stringify(item, function(key, value) {return key[0]=='_' ? undefined : value}))})]}

// NOTE: add these hooks if you need them. (our vertex payloads are immutable, and we uniqueify prior to taking.)

// Dagoba.addhook('postquery', Dagoba.uniqueify)
// Dagoba.addhook('postquery', Dagoba.cleanclone)

// THINK: the uniquify hook happens after the take component so it smushes results down, possibly returning fewer than you wanted...
  
Dagoba.onError = function(msg) {
  console.log(msg)
  return false 
}
/*
       _______  __   __  _______  _______  _______  _______  ___      ___     
      |       ||  | |  ||       ||       ||  _    ||   _   ||   |    |   |    
      |    _  ||  | |  ||    ___||    ___|| |_|   ||  |_|  ||   |    |   |    
      |   |_| ||  |_|  ||   |___ |   |___ |       ||       ||   |    |   |    
      |    ___||       ||    ___||    ___||  _   | |       ||   |___ |   |___ 
      |   |    |       ||   |    |   |    | |_|   ||   _   ||       ||       |
      |___|    |_______||___|    |___|    |_______||__| |__||_______||_______|                                                
 
  
    The main interface for the puffball platform. 
    
    Most calls to the platform should go through here, 
    rather than accessing core systems like PB.Data and PB.Crypto directly.

    In addition to the public-facing API many general helper functions 
    are established here for use by the deeper layers.

    Copyright 2014 EveryBit. See README for license information.

 */

if(typeof PB === 'undefined') PB = {}                   // we might load config.js first
if(!PB.CONFIG) PB.CONFIG = {}                           // or we might not

PB.Modules = {}                                         // supplementary extensions live here
PB.M = PB.Modules

PB.version = '0.7.2'

////////////// STANDARD API FUNCTIONS //////////////////


PB.init = function(options) {
    //// initializes all available modules and the platform subsystems.
    //// options is an object of configuration options that is passed to each module and subsystem.
    
    options = options || {}
    
    // BEGIN CONFIG AND OPTIONS //
    
    setDefault('zone', '')
    setDefault('puffApi', 'https://i.cx/api/puffs/api.php')
    setDefault('userApi', 'https://i.cx/api/users/api.php')
    setDefault('eventsApi', 'https://i.cx/api/puffs/api.php')
    setDefault('enableP2P', false)
    setDefault('pageBatchSize', 10)
    setDefault('initLoadGiveup', 200)
    setDefault('networkTimeout', 20000)         // twenty second timeout
    setDefault('noLocalStorage', false)
    setDefault('netblockSuffix', 'local')
    setDefault('cryptoworkerURL', '')           // point to cryptoworker.js to enable worker thread
    setDefault('ephemeralKeychain', false)      // prevents keychain from being saved to localStorage
    setDefault('initLoadBatchSize', 20)
    setDefault('inMemoryShellLimit', 10000)     // shells are removed to compensate
    setDefault('globalBigBatchLimit', 2000)     // maximum number of shells to receive at once // TODO: align with API
    setDefault('inMemoryMemoryLimit', 300E6)    // ~300MB
    setDefault('anonPrivateAdminKey', '5KdVjQwjhMchrZudFVfeRiiPMdrN6rc4CouNh7KPZmh8iHEiWMx') // Used to register anon. users
    setDefault('disableSendToServer', false)    // so you can work locally
    setDefault('disableReceivePublic', false)   // no public puffs except profiles
    setDefault('disableCloudIdentity', false)   // don't store encrypted identity in the cloud
    setDefault('supportedContentTypes', false)  // whitelist of context types; false loads all
    setDefault('shellContentThreshold', 1000)   // size of uncompacted content
    setDefault('localStorageShellLimit', 1000)  // maximum number of shells
    setDefault('localStorageMemoryLimit', 3E6)  // ~3MB
    
    function setDefault(key, val) {
        PB.CONFIG[key] = options[key] || PB.CONFIG[key] || val
    }
    
    // END CONFIG AND OPTIONS //
        
    PB.Users.init(options)                              // initialize the user record subsystem
    PB.Data.init(options)                               // initialize the data subsystem
    PB.Net.init(options)                                // initialize the network subsystem
    
    var moduleKeys = Object.keys(PB.M)
    moduleKeys.forEach(function(key) {                  // call all module initializers
        if(PB.M[key].init) 
            PB.M[key].init(options)
    })
    
    popMods()                                           // deflate any machine prefs
    function popMods() {                                // THINK: maybe move this to PB.Persist.init
        var mods = PB.Persist.get('CONFIG')
        if(!mods) return false
    
        PB.CONFIG.mods = mods
        Object.keys(PB.CONFIG.mods).forEach(function(key) { PB.CONFIG[key] = mods[key] })
    }
    
    PB.buildCryptoworker(options)
}


PB.getPuffBySig = function(sig) {
    //// get a particular puff
    var shell = PB.Data.getCachedShellBySig(sig)        // check in regular cache
    
    if(!shell)
        shell = PB.Data.getDecryptedLetterBySig(sig)    // check in private cache
    
    if(shell)
        return PB.Data.getPuffFromShell(shell)          // get a puff from the shell
        
    return PB.Data.getPuffBySig(sig)                    // get the puff
}

PB.postPublicMessage = function(content, type) {
    //// post a public puff. type is optional and defaults to 'text'
    type = type || 'text'
    
    var myUsername = PB.getCurrentUsername()
    if(!myUsername)
        return PB.emptyPromise('You must have a current identity to post a public message')
    
    var puff = PB.simpleBuildPuff(type, content)
    return PB.addPuffToSystem(puff)
}

PB.postPrivateMessage = function(content, usernames, type) {
    //// post an encrypted puff. type is optional and defaults to 'text'. usernames is an array of usernames.
    type = type || 'text'

    usernames = usernames || []
    if(!Array.isArray(usernames))
        usernames = [usernames]
    
    var myUsername = PB.getCurrentUsername()
    if(!myUsername)
        return PB.emptyPromise('You must have a current identity to post a private message')
    
    usernames.push(myUsername)
    usernames = PB.uniquify(usernames)
    var prom = PB.Users.usernamesToUserRecordsPromise(usernames)
    
    return prom.then(function(userRecords) {        
        var puff = PB.simpleBuildPuff(type, content, null, usernames, userRecords)
        return PB.addPuffToSystem(puff)
    })
    
    return prom
}

PB.getMyMessages = true

PB.createIdentity = function(username, passphrase) {
    // TODO: validations and error handling (lots of it)
    
    var prependedPassphrase = username + passphrase
        var privateKey = PB.Crypto.passphraseToPrivateKeyWif(prependedPassphrase)
    
    var prom = PB.registerTopLevelUser(username, privateKey, privateKey, privateKey)
    
    prom.then(function(userRecord) {
        var capa = 1 // THINK: does capa always start at 1? where should that knowledge live?
        PB.addAlias(username, username, capa, privateKey, privateKey, privateKey, {passphrase: passphrase})
        PB.switchIdentityTo(username)
    })
    
    // TODO: on switchIdentityTo false change undefined to ''
    
    return prom
}

PB.registerTopLevelUser = function(username, privateRootKey, privateAdminKey, privateDefaultKey) {
    //// create a brand new top-level user

    // OPT: privateToPublic is expensive -- we could reduce the number of calls if the private keys are identical
    var rootKeyPublic    = PB.Crypto.privateToPublic(privateRootKey)
    var adminKeyPublic   = PB.Crypto.privateToPublic(privateAdminKey)
    var defaultKeyPublic = PB.Crypto.privateToPublic(privateDefaultKey)

    var payload = { requestedUsername: username
                  ,           rootKey: rootKeyPublic
                  ,          adminKey: adminKeyPublic
                  ,        defaultKey: defaultKeyPublic
                  }

    var routes  = []
    var content = 'requestUsername'
    var type    = 'updateUserRecord'

    var puff = PB.buildPuff(username, privateAdminKey, routes, type, content, payload)
    
    var prom = PB.Net.updateUserRecord(puff)
    
    return prom
}

/**
 * register a subuser for the currently active identity
 * @param  {string} newUsername     desired new subuser name
 * @param  {string} rootKey         public root key for the new subuser
 * @param  {string} adminKey        public admin key for the new subuser
 * @param  {string} defaultKey      public default key for the new subuser
 * @return {object}                user record for the newly created subuser
 */
PB.registerSubuser = function(newUsername, rootKey, adminKey, defaultKey) {
    //// registers a subuser for the currently active identity
    
    var signingUsername = PB.getCurrentUsername()
    var prom
    
    PB.useSecureInfo(function(_, _, _, privateAdminKey, _) {
        prom = PB.registerSubuserForUser(signingUsername, privateAdminKey, newUsername, rootKey, adminKey, defaultKey)
    })
    
    return prom
}


PB.updatePrivateKey = function(keyToModify, newPrivateKey, secrets) {
    //// attempts to update a private key for the current user. 
    //// if successful it adds the new alias to the current identity.
    //// returns a promise for the new userRecord.
    
    var username = PB.getCurrentUsername()
    var newPublicKey = PB.Crypto.privateToPublic(newPrivateKey)

    if(['defaultKey', 'adminKey', 'rootKey'].indexOf(keyToModify) == -1)
        return PB.emptyPromise('That is not a valid key to modify')

    var payload = {}
    var routes  = []
    var content = 'modifyUserKey'
    var type    = 'updateUserRecord'

    payload.keyToModify = keyToModify
    payload.newKey = newPublicKey
    payload.time = Date.now()

    var prom = new Promise(function(resolve, reject) {
        var puff

        PB.useSecureInfo(function(_, _, privateRootKey, privateAdminKey, privateDefaultKey) {
            // NOTE: puff leaks, but only contains publicly accessible data
        
            var signingUserKey = 'privateRootKey'  // changing admin or root keys requires root privileges
            var privateKey = privateRootKey

            if (keyToModify == 'defaultKey') { 
                signingUserKey = 'privateAdminKey' // changing the default key only requires admin privileges
                privateKey = privateAdminKey
            }

            if(!privateKey) {
                return reject(PB.makeError("You need the " + signingUserKey + " to change the " + keyToModify + " key."))
            } else {
                puff = PB.buildPuff(username, privateKey, routes, type, content, payload)
            }
        })

        var userRecordPromise = PB.Net.updateUserRecord(puff)

        userRecordPromise.then(function(userRecord) {
            if(keyToModify == 'defaultKey') {
                PB.useSecureInfo(function(_, username, privateRootKey, privateAdminKey, _) {
                    PB.addAlias(username, username, userRecord.capa, privateRootKey, privateAdminKey, newPrivateKey, secrets)
                })
            }

            if(keyToModify == 'adminKey') {
                PB.useSecureInfo(function(_, username, privateRootKey, _, privateDefaultKey) {
                    PB.addAlias(username, username, userRecord.capa, privateRootKey, newPrivateKey, privateDefaultKey, secrets)
                })
            }

            if(keyToModify == 'rootKey') {
                PB.useSecureInfo(function(_, username, _, privateAdminKey, privateDefaultKey) {
                    PB.addAlias(username, username, userRecord.capa, newPrivateKey, privateAdminKey,  privateDefaultKey, secrets)
                })
            }

            return resolve(userRecord)
        })
        .catch(function(err) {
            return reject(PB.makeError(err))
        })
    })

    return prom
}

PB.getProfilePuff = function(username) {
    var cached_profile = PB.Data.profiles[username]
    
    if(cached_profile)
        return Promise.resolve(cached_profile)

    var prom = PB.Net.getProfilePuff(username)

    prom = prom.then(function(puffs) {
        var puff = puffs[0]
    
        // NOTE: Setting this prevents us from re-trying to collect profiles from users who don't have them.
        //       This is good, because it prevents network noise, but requires a refresh to see new profile info.
        if(!puff)
            puff = {payload:{}} // TODO: get a proper empty puff from somewhere
        
        PB.Data.profiles[PB.Users.justUsername(puff.username || username)] = puff
    
        return puff
    })

    return prom
}


////////////// END STANDARD API //////////////////


////////////// Handler Handlers //////////////////

PB.handlers = {}

PB.addHandler = function(type, callback) {
  if(!PB.handlers[type]) PB.handlers[type] = []
  PB.handlers[type].push(callback)
}

PB.runHandlers = function(type) {
  var args = [].slice.call(arguments, 1)
  return (PB.handlers[type] || []).reduce(
      function(acc, callback) {
          return callback.apply(null, acc == null ? args : Array.isArray(acc) ? acc : [acc])}, args)
}

PB.makeHandlerHandler = function(type) {
    return function(callback) {return PB.addHandler(type, callback)}
}

// USEFUL HANDLERS:

PB.addErrorHandler           = PB.makeHandlerHandler('error')           // receives all error messages

PB.addNewPuffHandler         = PB.makeHandlerHandler('newPuffs')        // called when new puffs are available

PB.addDHTErrorHandler        = PB.makeHandlerHandler('DHTError')        // receives DHT error messages

PB.addRelationshipHandler    = PB.makeHandlerHandler('relationship')    // manage relationships between puffs

PB.addTimeoutErrorHandler    = PB.makeHandlerHandler('timeoutError')    // receives timeout error messages

PB.addNetworkErrorHandler    = PB.makeHandlerHandler('networkError')    // receives network error messages

PB.addNewPuffReportHandler   = PB.makeHandlerHandler('newPuffReport')   // handles reports on incoming puffs

PB.addIdentityUpdateHandler  = PB.makeHandlerHandler('identityUpdate')  // general GUI update trigger

PB.addNetworkResponseHandler = PB.makeHandlerHandler('networkresponse') // receives all network response

PB.addPayloadModifierHandler = PB.makeHandlerHandler('payloadModifier') // decorate puff payloads 

// PB.addClearPuffCacheHandler = PB.makeHandlerHandler('clearpuffcache')

// beforeSwitchIdentity is called prior to switchIdentity and removeIdentity, while the old identity is active
// afterSwitchIdentity is called after switchIdentity, once the new identity is active
PB.addBeforeSwitchIdentityHandler = PB.makeHandlerHandler('beforeSwitchIdentity')
PB.addAfterSwitchIdentityHandler  = PB.makeHandlerHandler('afterSwitchIdentity')

////////////// End Handler Handlers //////////////




//// PUFF HELPERS ////


PB.simpleBuildPuff = function(type, content, payload, routes, userRecordsForWhomToEncrypt, privateEnvelopeAlias) {
    //// build a puff for the 'current user', as determined by the key manager (by default PB.M.Wardrobe)
    var puff 

    payload = PB.runHandlers('payloadModifier', payload)

    PB.useSecureInfo(function(identities, currentUsername, privateRootKey, privateAdminKey, privateDefaultKey) {
        // THINK: should we confirm that our local capa matches the DHT's latest capa for the current user here? it turns the output into a promise...
        var previous = false // TODO: get the sig of this user's latest puff
        var versionedUsername = PB.getCurrentVersionedUsername()
        
        puff = PB.buildPuff(versionedUsername, privateDefaultKey, routes, type, content, payload, previous, userRecordsForWhomToEncrypt, privateEnvelopeAlias)
    })
    
    return puff
}


/**
 * build a new puff object based on the parameters  
 * does not hit the network, hence does no real verification whatsoever
 * @param  {string} username                    user who sign the puff
 * @param  {string} privateKey                  private default key for the user
 * @param  {string} routes                      routes of the puff
 * @param  {string} type                        type of the puff
 * @param  {string} content                     content of the puff
 * @param  {object} payload                     other payload information for the puff
 * @param  {string} previous                    most recently published content by the user
 * @param  {object} userRecordsForWhomToEncrypt
 * @param  {object} privateEnvelopeAlias
 * @return {object}                             the new puff object
 */
PB.buildPuff = function(versionedUsername, privateKey, routes, type, content, payload, previous, userRecordsForWhomToEncrypt, privateEnvelopeAlias) {
    var puff = PB.Data.packagePuffStructure(versionedUsername, routes, type, content, payload, previous)

    puff.sig = PB.Crypto.signPuff(puff, privateKey)
    
    if(userRecordsForWhomToEncrypt) {
        puff = PB.Data.encryptPuff(puff, privateKey, userRecordsForWhomToEncrypt, privateEnvelopeAlias)
    }
    
    return puff
}


/**
 * handle a newly created puff: add to our local cache and fire new content callbacks
 * @param {object} puff
 */
PB.addPuffToSystem = function(puff) {
    if(PB.Data.getCachedShellBySig(puff.sig)) return false
    
    PB.Data.addShellsThenMakeAvailable(puff)

    PB.Net.distributePuff(puff)
    
    return puff
}


PB.decryptPuffForReals = function(envelope, yourPublicWif, myVersionedUsername, myPrivateWif) {
    //// interface with PB.Crypto for decrypting a message
    // TODO: this should be in PB.Data, but is in PB for cryptoworker's sake
    if(!envelope.keys) return false
    var keyForMe = envelope.keys[myVersionedUsername]
    var puffkey  = PB.Crypto.decryptPrivateMessage(keyForMe, yourPublicWif, myPrivateWif)
    var letterCipher = envelope.payload.content
    var letterString = PB.Crypto.decryptWithAES(letterCipher, puffkey)
    var betterString = PB.tryDecodeURIComponent(escape(letterString))   // try decoding
    return PB.parseJSON(betterString)                                   // try parsing
}



//// ID FILE (LOGIN + FORMAT) ////


PB.login = function(username, privateKey) {
    //// privateKey is the key for your identity file
    
    // TODO: handle offline case...
    // TODO: encrypted localStorage identity files
    // TODO: cache encrypted puffs in localStorage
    // TODO: grab the user record from PB.loginWithPassphrase
    
    userprom = PB.Users.getUserRecordNoCache(username)
    
    return userprom.then(function(userRecord) {
        var identitySig = userRecord.identity
            
        if(!identitySig) 
            return PB.onError('That user record has no identity')
        
        puffprom = PB.Net.getPuffBySig(identitySig)
    
        return puffprom.then(function(puffs) {
            var envelope = puffs[0]
            var senderPublicKey = userRecord.defaultKey
            var recipientUsername = PB.Users.makeVersioned(userRecord.username, userRecord.capa)
            var recipientPrivateKey = privateKey

            var decryptprom = PB.Data.decryptPuffAlmostForReals(envelope, senderPublicKey, recipientUsername, recipientPrivateKey)

            return decryptprom.then(function(letter) {
                if(letter && letter.payload && letter.payload.content)
                    return PB.loginWithIdentityFile(letter.payload.content)
            })
        })        
    })
}

PB.loginWithIdentityFile = function(object) {
    //// takes a canonical identity file object, adds it to the wardrobe, and signs you in
    
    var username = object.username
    var aliases  = object.aliases
    var preferences = object.preferences
    
    if(!username || !aliases || !preferences)
        return PB.onError('That is not a valid identity object')
    
    PB.currentIdentityHash = PB.Crypto.createMessageHash(JSON.stringify(object))
    
    PB.addIdentity(username, aliases, preferences)
    
    return PB.switchIdentityTo(username)
}

PB.loginWithPassphrase = function(username, passphrase, legacy) {
    // First attempt to prepend username to passphrase
    // If fails, then try just using the passphrase
    var pass = legacy ? passphrase : username + passphrase

    var privateKey = PB.Crypto.passphraseToPrivateKeyWif(pass)
    var publicKey = PB.Crypto.privateToPublic(privateKey)

    var userprom = PB.Users.getUserRecordNoCache(username)

    return userprom.then(function(userRecord) {
        if( (userRecord.defaultKey != publicKey) 
         && (userRecord.adminKey   != publicKey) 
         && (userRecord.rootKey    != publicKey) )
            return (legacy) ? false : PB.loginWithPassphrase(username, passphrase, true)

        return PB.login(username, privateKey)
    })
}


PB.storeIdentityFileInCloud = function() {
    if(!PB.currentIdentityHash) {
        // THINK: user did not log in with identity file... so what should we do here?
    }

    // get identity file
    var content = PB.formatIdentityFile()
    if(!content) return false
    
    // check against latest
    var newIdentityHash = PB.Crypto.createMessageHash(JSON.stringify(content))
    if(PB.currentIdentityHash == newIdentityHash) return false
    PB.currentIdentityHash = newIdentityHash
    
    // package as encrypted puff
    var payload = {}
    var routes  = []
    var type    = 'identity'
        
    var userRecord = PB.getCurrentUserRecord()
    var userRecordsForWhomToEncrypt = [userRecord]

    if(!userRecord) return false

    // THINK: using simpleBuildPuff puts a timestamp in the identity file...
    var puff = PB.simpleBuildPuff(type, content, payload, routes, userRecordsForWhomToEncrypt)
    
    if(!puff) return false
        
    // if(puff.sig == userRecord.identity) return false // always false, because of the timestamp -- if you remove it, add this back
    
    PB.Net.distributePuff(puff)                         // send it to the server
    
    // update user record
    var payload = {}                                    // NOTE: the double "var"s don't hurt, and help keep us focused
    var routes  = []
    var type    = 'updateUserRecord'
    var content = 'setIdentity'
    var update_puff

    payload.identity = puff.sig

    PB.useSecureInfo(function(_, currentUsername, _, privateAdminKey, _) {
        if(!privateAdminKey)
            return PB.onError('You must have an administrative key to upload your identity file')
        
        update_puff = PB.buildPuff(currentUsername, privateAdminKey, routes, type, content, payload)
    })
    
    if(!update_puff)
        return false
    
    var update_prom = PB.Net.updateUserRecord(update_puff)
        
    return update_prom
}

PB.formatIdentityFile = function(username) {
    // THINK: consider passphrase protecting the identity file by default
    // TODO: add authFromIdFile -- need consistency both ways
    
    username = username || PB.getCurrentUsername()
    
    if(!username) return false

    var idFile = {}

    PB.useSecureInfo(function(identities, currentUsername, privateRootKey, privateAdminKey, privateDefaultKey) {
        // this leaks all of the identity information back to the caller
        // if we passphrase protect the file, do it here to prevent that leakage

        var identity = identities[username]

        // assemble idFile manually to keep everything in the right order
        // idFile.comment = "This file contains your private passphrase. It was generated at i.cx. The information here can be used to login to websites on the puffball.io platform. Keep this file safe and secure!"

        idFile.username = username
        // idFile.primary  = identity.primary // NOTE: primary is automatically gathered from aliases
        idFile.aliases  = identity.aliases
        idFile.preferences = identity.preferences
        idFile.version  = "1.1"
    })

    return idFile
}



//// USER CREATION ////

/**
 * register a subuser
 * @param  {string} signingUsername username of existed user
 * @param  {string} privateAdminKey private admin key for existed user
 * @param  {string} newUsername     desired new subuser name
 * @param  {string} rootKey         public root key for the new subuser
 * @param  {string} adminKey        public admin key for the new subuser
 * @param  {string} defaultKey      public default key for the new subuser
 * @return {object}                user record for the newly created subuser
 */
PB.registerSubuserForUser = function(signingUsername, privateAdminKey, newUsername, rootKey, adminKey, defaultKey) {

    // build our DHT update puff
    var payload = { requestedUsername: newUsername
                  ,        defaultKey: defaultKey
                  ,          adminKey: adminKey
                  ,           rootKey: rootKey
                  ,              time: Date.now()
                  }

    var routing = [] // THINK: DHT?
    var content = 'requestUsername'
    var type    = 'updateUserRecord'

    var puff = PB.buildPuff(signingUsername, privateAdminKey, routing, type, content, payload)
    // NOTE: we're skipping previous, because requestUsername-style puffs don't use it.

    return PB.Net.updateUserRecord(puff)
}




//// BUILD CRYPTO WORKER ////

PB.buildCryptoworker = function(options) {
    var cryptoworkerURL = options.cryptoworkerURL || PB.CONFIG.cryptoworkerURL // || 'cryptoworker.js'
    
    if(!cryptoworkerURL) return false
    
    PB.cryptoworker = new Worker(cryptoworkerURL)
    PB.cryptoworker.addEventListener("message", PB.workerreceive)
}

PB.workerqueue = []
PB.workerautoid = 0

PB.workerreceive = function(msg) {
    var id = msg.data.id
    if(!id) return false // TODO: add onError here

    var fun = PB.workerqueue[id]
    if(!fun) return false // TODO: add onError here

    fun(msg.data.evaluated)

    delete PB.workerqueue[id] // THINK: this leaves a sparse array, but is probably faster than splicing
}

PB.workersend = function(funstr, args, resolve, reject) {
    PB.workerautoid += 1
    PB.workerqueue[PB.workerautoid] = resolve
    if(!Array.isArray(args))
        args = [args]
    PB.cryptoworker.postMessage({fun: funstr, args: args, id: PB.workerautoid})
}

//// END BUILD CRYPTO WORKER ////




////////////// SECURE INFORMATION INTERFACE ////////////////////

PB.implementSecureInterface = function(useSecureInfo, addIdentity, addAlias, setPrimaryAlias, setPreference, switchIdentityTo, removeIdentity) {
    // useSecureInfo    = function( function(identities, username, privateRootKey, privateAdminKey, privateDefaultKey) )
    // addIdentity      = function(username, aliases, preferences)
    // addAlias         = function(identityUsername, aliasUsername, capa, privateRootKey, privateAdminKey, privateDefaultKey, secrets)
    // setPrimaryAlias  = function(identityUsername, aliasUsername)
    // removeIdentity   = function(username)
    // setPreference    = function(key, value) // for current identity
    // switchIdentityTo = function(username)

    // THINK: consider ensuring all functions are present first, so it's harder to mix and match wardrobe implementations
    
    if(typeof useSecureInfo == 'function') {
        PB.useSecureInfo = function(callback) {
            // NOTE: useSecureInfo returns true if there is a current identity, and false otherwise
            return useSecureInfo( function(identities, username, privateRootKey, privateAdminKey, privateDefaultKey) {
                var clonedIdentities = JSON.parse(JSON.stringify(identities)) // prevent accidental mutation
                callback(clonedIdentities, username, privateRootKey, privateAdminKey, privateDefaultKey)
            })
        }
    }
    
    if(typeof addIdentity == 'function')
        PB.addIdentity = addIdentity
        
    if(typeof addAlias == 'function')
        PB.addAlias = addAlias
        
    if(typeof setPrimaryAlias == 'function')
        PB.setPrimaryAlias = setPrimaryAlias
        
    if(typeof setPreference == 'function')
        PB.setPreference = setPreference
        
    if(typeof switchIdentityTo == 'function')
        PB.switchIdentityTo = function(username) {
            PB.runHandlers('beforeSwitchIdentity', username)
            var output = switchIdentityTo(username)
            PB.runHandlers('afterSwitchIdentity', username)
            return output
        }
        
    if(typeof removeIdentity == 'function')
        PB.removeIdentity = removeIdentity
        
    PB.getCurrentUsername = function() {
        // yes, this technique allows you to leak data out of useSecureInfo. no, you should not use it.
        var output
        PB.useSecureInfo(function(identities, username) { output = username })
        return output
    }
    
    PB.getCurrentCapa = function() {
        // yes, this technique allows you to leak data out of useSecureInfo. no, you should not use it.
        var output
        PB.useSecureInfo(function(identities, username) { output = ((identities[username]||{}).primary||{}).capa||0 })
        return output
    }
    
    PB.getCurrentVersionedUsername = function() {
        var username = PB.getCurrentUsername()
        if(!username)
            return PB.onError('No current user in wardrobe')
        
        return PB.Users.makeVersioned(username, PB.getCurrentCapa())
    }
    
    PB.getCurrentUserRecord = function() {
        var versionedUsername = PB.getCurrentVersionedUsername()
        if(!versionedUsername)
            return false
        
        // THINK: it's weird to hit the cache directly from here, but if we don't then we always get a promise,
        //        even if we hit the cache, and this should return a proper userRecord, not a promise, 
        //        since after all we have stored the userRecord in our wardrobe, haven't we?
    
        var userRecord = PB.Users.records[versionedUsername]
        if(!userRecord)
            return PB.onError('That user does not exist in our records')
    
        return userRecord
    }

    PB.getAllIdentityUsernames = function() {
        // yes, this technique allows you to leak data out of useSecureInfo. no, you should not use it.
        var output
        PB.useSecureInfo(function(identities, username) { output = Object.keys(identities) })
        return output
    }
    
}

////////////// END SECURE INFORMATION ZONE ////////////////////






//// VALIDATIONS

// TODO: merge these into PB.Spec

/**
 * check if a username is valid
 *     a username must be shorter than 256 characters, all lowercase and contains only alphanumeric and . sign
 * @param  {string} username the string to be check
 * @return {boolean}          return true if  the parameter string is a valid username, otherwise throw error
 */
PB.validateUsername = function(username) {
    if(!username) 
        return PB.onError('Username is required', username)

    if(username.length > 256) 
        return PB.onError('Usernames must be shorter than 256 characters', username)

    if(username != username.toLowerCase()) 
        return PB.onError('Usernames must be lowercase', username)
    
    if(!/^[0-9a-z.]+$/.test(username))
        return PB.onError('Usernames must be alphanumeric', username)
    
    return true
}


/**
 * determine if it is a good shell, checks for the existence of required fields
 * @param {Shell[]}
 * @returns {boolean}
 */
PB.isValidShell = function(shell) {
    //// this just checks for the existence of required fields
    if(!shell.sig) return false
    if(!shell.routes) return false
    if(!shell.username) return false
    if(typeof shell.payload != 'object') return false
    if(!shell.payload.type) return false
        
    return true
}

/**
 * to verify a puff
 * @param  {object} puff
 * @return {(string|boolean)}
 */
PB.isGoodPuff = function(puff) {
    // CURRENTLY UNUSED
    // TODO: check previous sig, maybe
    // TODO: check for well-formed-ness
    // TODO: use this to verify incoming puffs
    // TODO: if prom doesn't match, try again with getUserRecordNoCache
    
    // TODO: rewrite this function to give a consistent return value
    
    if (!PB.M.Forum.contentTypes[shell.payload.type]) {
        // TODO: this needs to include 'encryptedpuff' as a valid type
        Events.pub('track/unsupported-content-type', {type: shell.payload.type, sig: shell.sig})
        return false
    }
    
    var prom = PB.Users.getUserRecordPromise(puff.username) // NOTE: versionedUsername
    
    return prom.then(function(user) {
        return PB.Crypto.verifyPuffSig(puff, user.defaultKey)
    })
}



//// ERROR HELPERS

// TODO: build a more general error handling system for GUI integration

PB.onError = function(msg, obj, trigger) {
    //// override this for custom error behavior
    
    var composite = {msg: msg, obj: obj}

    PB.runHandlers('error', composite)
    
    if(trigger)
        PB.runHandlers(trigger, composite)
        
    // for debugging help, run this in the console:
    // PB.addErrorHandler(function(composite) {console.log(composite)})

    return false
}

PB.catchError = function(msg) {
    //// ex: prom.catch( PB.catchError('invalid foo') ).then(function(foo) {...})
    return function(err) {
        PB.onError(msg, err)
        throw err
    }
}

PB.throwError = function(msg, errmsg) {
    //// ex: prom.then(function(foo) {if(!foo) PB.throwError('no foo'); ...})
    var err = errmsg ? Error(errmsg) : ''
    throw PB.makeError(msg, err)
}

PB.makeError = function(msg, err, trigger) {
    //// ex: new Promise(function(resolve, reject) { if(!foo) reject( PB.makeError('no foo') ) ... })
    PB.onError(msg, err, trigger)
    return Error(msg)
}

PB.emptyPromise = function(msg) {
    //// ex: function(foo) { if(!foo) return PB.emptyPromise('no foo'); return getFooPromise(foo) }
    if(msg) PB.onError(msg)
    return Promise.reject(msg)
}

PB.throwNetError = function(msg, errmsg) {
    //// like throw error but triggers the networkError handler
    var trigger = 'networkError'
    var err = errmsg ? Error(errmsg) : ''
    throw PB.makeError(msg, err, trigger)
}

PB.throwDHTError = function(msg, errmsg) {
    //// like throw error but triggers the DHTError handler
    var trigger = 'DHTError'
    var err = errmsg ? Error(errmsg) : ''
    throw PB.makeError(msg, err, trigger)
}


//// Exceptional API wrappers

PB.parseJSON = function(str) {
    //// JSON.parse throws, so we catch it. throw/catch borks the JS VM optimizer, so we box it.
    try {
        return JSON.parse(str)
    } catch(err) {
        return PB.onError('Invalid JSON string', err)
    }
}

PB.stringifyJSON = function(obj) {
    //// JSON.stringify throws on dumb DOM objects, so we catch it. throw/catch borks the JS VM optimizer, so we box it.
    try {
        return JSON.stringify(obj)
    } catch(err) {
        return PB.onError('Invalid object', err)
    }
}

PB.tryDecodeURIComponent = function(str) {
    //// decodeURIComponent throws, so we wrap it. try/catch kills the optimizer, so we isolate it.
    try {
        return decodeURIComponent(str)
    } catch(err) {
        return PB.onError('Invalid URI string', err)
    }
}


//// something different

PB.promisesPending = {}

// Major jujitsu here
PB.promiseMemoize = function(fun, ohboy) {
    if(!ohboy) ohboy = PB.removePromisePending
    
    return function() {
        var key = JSON.stringify([fun.toString(),arguments])
        
        if(PB.promisesPending[key])
            return PB.promisesPending[key]
        
        var prom = fun.apply(fun, arguments)
        prom = prom.then(function(value) {
            ohboy(key, value)
            return value                                        // deliver successes
        }, function(value) {
            ohboy(key, value)
            throw value                                         // propagate failures
        })
        
        PB.promisesPending[key] = prom
        return prom
    }
}

PB.removePromisePending = function(key) {
    delete PB.promisesPending[key]
}

//// TIMING HELPERS


// TODO: move these into a library

~function() {
    //// postpone until next tick
    // inspired by http://dbaron.org/log/20100309-faster-timeouts
    var later = []
    var messageName = 12345
    var gimme_a_tick = true

    function setImmediate(fun) {
        later.push(fun)
        
        if(gimme_a_tick) {
            gimme_a_tick = false
            window.postMessage(messageName, "*")
        }
        
        return false
    }

    function handleMessage(event) {
        if(event.data != messageName) return false

        event.stopPropagation()
        gimme_a_tick = true

        var now = later
        later = []

        for(var i=0, l=now.length; i < l; i++)
            now[i]()
    }
  
    if(typeof window != 'undefined') {
        window.addEventListener('message', handleMessage, true)
        window.setImmediate = setImmediate
    }
}()

PB.queuer = function() {
    //// do something after some other things
    var queue = []
    
    var nexttime = function(invoker) {
        invoker(function() {
            if(!queue.length) return false
            queue.shift()()
            nexttime(invoker)
        })
    }
            
    var queuer = function(invoker, fun) {
        queue.push(fun)
        if(queue.length > 1) return false // THINK: possible race condition
        nexttime(invoker) 
    }
    
    return queuer
}

PB.once = function() {
    //// do something later, but only once
    var later = []

    var step = function() {
        var now = later
        later = []
        for(var i=0, l=now.length; i < l; i++)
            now[i]()
    }
            
    var once = function(invoker, fun) {
        if(~later.indexOf(fun)) return false
        later.push(fun)
        if(later.length > 1) return false // THINK: possible race condition
        invoker(step) 
    }
    
    return once
}

~function() {
    if(typeof window != 'undefined') {
        window.queueImmediate = PB.queuer().bind(null, setImmediate)
        window.onceImmediate  = PB.once().bind(null, setImmediate)
        window.queueRAF = PB.queuer().bind(null, requestAnimationFrame)
        window.onceRAF  = PB.once().bind(null, requestAnimationFrame)
    
        var timefunbind = {}
        window.onceInAwhile = function(fun, time) {
            //// NOTE: don't use the same fun with different times
            if(timefunbind[fun]) return false
            timefunbind[fun] = setTimeout(function() {fun(); timefunbind[fun] = false}, time)
        }
    }
}()




////////////// A few small helpers for building functional pipelines ///////////////

PB.prop = function(p, obj) { // THINK: consider importing all of Rambda.js
    return arguments.length < 2 ? function (obj) { return obj[p]; } : obj[p]
}

PB.uniquify = function(list) {
    return list.filter(PB.unique)
}

PB.unique = function(item, index, array) {return array.indexOf(item) == index}

/*

    Network library for the EveryBit platform.

    Contains a peer.js-based p2p layer, a promise-based XHR implementation, 
    helper functions for accessing various server-based APIs, 
    and helper functions for handling puff distribution and acquisition.

    Copyright 2014 EveryBit. See README for license information.

 */

PB.Net = {}

/**
 * Fire up networks (currently just the peer connections)
 */
PB.Net.init = function() {
    PB.Net.P2P.init()
}

/**
 * Given a signature, return puff with that signature
 * @param  {string} sig signature of a puff
 * @return {object}     puff corresponds to the specified signature
 */
PB.Net.getPuffBySig = function(sig) {
    var url  = PB.CONFIG.puffApi
    var data = {type: 'getPuffBySig', sig: sig}
    
    return PB.Net.PBgetJSON(url, data)
}

PB.Net.getKidSigs = function(sig) {
    var url  = PB.CONFIG.puffApi
    var data = {type: 'getChildrenBySig', sig: sig}
    
    return PB.Net.PBgetJSON(url, data)
}

PB.Net.getKidSigs = Boron.memoize(PB.Net.getKidSigs) // THINK: this assumes we'll get all new things over the P2P network, which won't always be true.



PB.Net.getStarShells = function() {
    var url  = PB.CONFIG.puffApi
    var data = {type: 'getPuffs', contentType: 'star', numb: PB.CONFIG.globalBigBatchLimit}
    
    return PB.Net.PBgetJSON(url, data)
}

PB.Net.getConversationPuffs = function(convoId, batchsize, offset, fullOrShell) {
    convoId  = convoId.replace('&',',')

    var url  = PB.CONFIG.puffApi
    var data = { type: 'getPuffs', contentType: 'encryptedpuff'
               , conversationPartners: convoId
               , numb: batchsize
               , offset: offset
               }
    
    return PB.Net.PBgetJSON(url, data)
}

PB.Net.getMyPrivatePuffs = function(username, batchsize, offset, fullOrShell) {
    if(!username) return PB.emptyPromise()
    batchsize = batchsize || PB.CONFIG.globalBigBatchLimit
    
    var url  = PB.CONFIG.puffApi
    var data = { route: username, username: username, fromAndTo: 1
               , type: 'getPuffs', contentType: 'encryptedpuff'
               , fullOrShell: fullOrShell || 'full'
               , numb: batchsize
               , offset: offset
               }
    
    return PB.Net.PBgetJSON(url, data)
    
/*

    So something like:

    PB.getSomePuffs(query, limit, etc)

    helper.js:
    tryGettingMorePuffs(visibleLimit) {
        // figure out how many we've requested already (ICX.currentOffset)
        // figure out how many we actually have (PB.Data.getDecryptedPuffs)
        var delta = visibleLimit - PB.Data.getDecryptedPuffs().length
        ICX.currentOffset += delta
        return PB.getSomePuffs(query, ICX.currentOffset)
    }


*/ 

    // TODO: chain this in to the table view
    
}


PB.Net.getProfilePuff = function(username) {
    var url  = PB.CONFIG.puffApi
    var data = { username: username
               , fullOrShell: 'full'
               , contentType: 'profile'
               , type: 'getPuffs'
               , sort: 'DESC'
               , numb: 1
               }
    
    return PB.Net.PBgetJSON(url, data)
}
PB.Net.getProfilePuff = PB.promiseMemoize(PB.Net.getProfilePuff)

/**
 * to get some shells
 * @param {string} query
 * @param {string} filters
 * @param {number} limit
 * @param {number} offset
 * @returns {Shell[]}
 */
PB.Net.getSomeShells = function(query, filters, limit, offset) {
    // TODO: switching by query 'mode' will need to be changed when the network api matches our local api (i.e. once we use browser p2p & headless clients to service requests)
    
    var mode = query.mode
    if(mode == 'ancestors')   return PB.Net.getAncestors  ([query.focus], limit)
    if(mode == 'descendants') return PB.Net.getDescendants([query.focus], limit)
    // if(mode == 'siblings')    return PB.Net.getSiblings   ([query.focus], limit)

    // "normal" mode (just ask for shells from lists or something)
    var url  = PB.CONFIG.puffApi

    //  if(filters.types)   data.type       = filters.types      // filter by types

    var data = {type: 'getPuffs', contentType: 'plain'}
    // var data = {type: 'getPuffs', contentType: '["image"]'}


    if(limit)  data.numb    = limit                         // defaults to 20 on the server
    if(offset) data.offset  = offset                        // defaults to 0, which is latest
    
    if(query.sort)      data.sort        = query.sort       // ASC or DESC
    if(filters.users)   data.username    = filters.users    // filter by username
    if(filters.routes)  data.route       = filters.routes   // filter by route
    if(filters.tags)    data.tags        = filters.tags     // filter by tags
    if(filters.types)   data.contentType = filters.types    // filter by types
    if(query.ancestors) data.maxParents  = query.ancestors  // defaults to all shells 
                                                            // 0 is roots, 1 is single parent, etc
    // data.flagged = false
    
    // data.focus
    // data.ancestors
    // data.descendants
    
    var filterstring = JSON.stringify(filters.types)
    var profile_request = (filterstring == '["profile"]')
    
    if(PB.CONFIG.disableReceivePublic && !profile_request)
        return PB.emptyPromise()
                 .then(function() {return []})
    
    return PB.Net.PBgetJSON(url, data)                      // always returns a valid array
                 .then(function(x) {return x || []}, function() {return []})
}


PB.Net.getAncestors = function(start, limit) {
    getEm(start, [], limit)
    return PB.emptyPromise()
    
    function getEm(todo, done, remaining) {
        if(!todo.length) return false                       // all done
        if(!remaining) return false                         // all done
    
        var sig = todo[0]
    
        if(~done.indexOf(sig)) {
            return getEm(todo.slice(1), done, remaining)    // we've already done this one
        }
        
        // TODO: set a callback in PB.Net instead of calling PB.Data directly
        var puff = PB.Data.getPuffBySig(sig)                // effectful
    
        if(puff) 
            return getEm(todo.slice(1).concat(puff.payload.parents), done.concat(sig), remaining)

        // no puff? that's ok. attach a then clause to its pending promise.
        // TODO: find better method to do this
        remaining-- // because we're adding a new puff, or at least new content
        var prom = PB.Data.pendingPuffPromises[sig]
        prom.then(function(puffs) {
            getEm(todo.slice(1).concat(((puffs[0]||{}).payload||{}).parents), done.concat(sig), remaining)
        })
    }
    
    //
    // if(!todo.length)
    //     return Promise.resolve(results)             // all done
    // if(results.length >= limit)
    //     return Promise.resolve(results)             // all done
    //
    // var sig = todo[0]
    // var shell = PB.Data.getCachedShellBySig(sig)   // TODO: set a callback in PB.Net instead of calling this directly
    //          || results.filter(function(result) {return result.sig == sig})[0]
    //
    // // if we already have a puff for sig, then we just need to put its parents on the todo stack
    // if(shell) {
    //     todo.shift() // take off the shell we just worked on
    //     return PB.Net.getAncestors(todo.concat(shell.payload.parents), limit, results)
    // }
    //
    // // otherwise, get a promise for the shell, then add it to results
    // var prom = PB.Net.getPuffBySig(sig)
    // return prom.then(function(puffs) {
    //     return PB.Net.getAncestors(todo, limit, results.concat(puffs))
    // })
}

PB.Net.getDescendants = function(start, limit) {
    getEm(start, [], limit)
    return PB.emptyPromise()
    
    function getEm(todo, done, remaining) {
        if(!todo.length) return false                       // all done
        if(!remaining) return false                         // all done
        
        var sig = todo[0]
        
        if(~done.indexOf(sig)) {
            return getEm(todo.slice(1), done, remaining)    // we've already done this one
        }
        
        // TODO: set a callback in PB.Net instead of calling PB.Data directly
        var haveShell = PB.Data.getCachedShellBySig(sig) 
        
        if(!haveShell) {                                    // we don't have the shell yet, so go get it
            // TODO: use above callback to PB.Data
            PB.Data.getPuffBySig(sig)                       // effectful
            remaining--
        }
        
        var kidsigprom = PB.Net.getKidSigs(sig)             // get all its children
        return kidsigprom.then(function(kidsigs) {
            getEm(todo.slice(1).concat(kidsigs), done.concat(sig), remaining)
        })
    }
}

PB.Net.getSiblings = function() {
    // this case is ugly, so we're leaving it until the client api can answer questions for us
    return PB.emptyPromise() 
}

/**
 * add puff to the server and broadcast to peers
 * @param  {object} puff the puff to be added to the server
 */
PB.Net.distributePuff = function(puff) {
    //// distribute a puff to the network

    if(PB.CONFIG.disableSendToServer) return false          // so you can work locally

    if(PB.CONFIG.netblockSuffix) {                          // block distribution of local puffs
        var usernames = [puff.username]
        if(puff.keys)
            usernames = usernames.concat(Object.keys(puff.keys))

        usernames = usernames.map(PB.Users.justUsername)
        var suffixes = usernames.map(function(username) {
            var chunks = username.split('.')
            return chunks[chunks.length-1]
        })
        
        if(suffixes.indexOf(PB.CONFIG.netblockSuffix) > -1)
            return false
    }

    PB.Net.sendPuffToServer(puff)                           // add it to the server's pufflist

    PB.Net.P2P.sendPuffToPeers(puff)                        // broadcast it to peers
}

/**
 * add a puff to the server's pufflist
 * @param  {object} puff
 * @return {object}
 */
PB.Net.sendPuffToServer = function(puff) {
    // THINK: this is fire-and-forget, but we should do something smart if the network is offline or it otherwise fails. 
    //        on the other hand, we'll probably want to do this with sockets instead of ajax ultimately...
    //        or manage it entirely with routing, even for server-sent puffs?
    
    var data = { type: 'addPuff'
               , puff: JSON.stringify(puff) }
               
    return PB.Net.PBpost(PB.CONFIG.puffApi, data)
                 .catch(PB.catchError('Could not send puff to server'))
}

/**
 * fetch a particular userRecord
 * @param  {string}  username 
 * @param  {string}  capa 
 * @return {promise} on fulfilled passes the user record as object, otherwise re-throw error
 */
PB.Net.getUserRecord = function(username, capa) {
    var url   = PB.CONFIG.userApi
    
    var versionedUsername = PB.Users.makeVersioned(username, capa)
    username = PB.Users.justUsername(versionedUsername)
    
    if(capa !== 0) // 0 signals that we need to fetch the latest userRecord
        capa = PB.Users.justCapa(versionedUsername)
    
    var data  = { type: 'getUser'
                , username: username
                }

    if(capa)
        data.capa = capa

    return PB.Net.PBgetJSON(url, data)
}


/**
 * modify a user record
 * @param  {puff}   puff a signed puff containing information of modified user record
 * @return {object} promise for new userRecord or error when the update fails
 */
PB.Net.updateUserRecord = function(puff) {
    var data = { type: 'updateUsingPuff'
               , puff: puff
               }

    var prom = PB.Net.PBpost(PB.CONFIG.userApi, data)
    
    return prom.catch(PB.catchError('Sending user record modification puff failed'))
               .then(JSON.parse) // THINK: this throws on invalid JSON
               .then(function(userRecord) {
                   return PB.Users.process(userRecord)
                       || PB.throwError('Invalid user record', JSON.stringify(userRecord))
               })
}



/**
 * PB.Net promise-based XHR layer
 * 
 * We use promises as our default concurrency construct, 
 * because ultimately this platform is composed of a 
 * huge set of interdependent async calls which mostly 
 * each resolve to a single immutable entity 
 * -- aka the promise sweet spot.
 * 
 * @param  {string} url     requested url
 * @param  {object} options 
 * @param  {object} data    
 * @return {object}
 */
PB.Net.xhr = function(url, options, data) {
    //// very simple promise-based XHR implementation
    
    return new Promise(function(resolve, reject) {
        var req = new XMLHttpRequest()
        req.open(options.method || 'GET', url)
        
        Object.keys(options.headers || {}).forEach(function (key) {
            req.setRequestHeader(key, options.headers[key])
        })
        
        var formdata = new FormData()
        Object.keys(data || {}).forEach(function (key) {
            var datum = typeof data[key] == 'object' ? PB.stringifyJSON(data[key]) : data[key]
            formdata.append(key, datum)
        })
        
        if(options && options.type)
            req.responseType = options.type
                
        req.onload = function() {
            if(req.status != 200) // silly safari
                return reject(PB.makeError(req.statusText))
            
            if(req.responseType == 'json' && req.response === null) // NOTE: traps JSONified 'null' responses also: use empty string or [] to indicate an empty result
                return reject(PB.makeError("Invalid JSON in response", req.response))
            
            resolve( (req.responseType != options.type) // manually convert json for old browsers
                  && options.type == 'json' ? PB.parseJSON(req.response) : req.response)
        }

        req.onerror = function(event) {
            reject(PB.makeError("Network Error", event, 'networkError'))
        }
        
        req.ontimeout = function(event) {
            reject(PB.makeError("Timeout Error", event, 'timeoutError'))
        }
        
        req.timeout = PB.CONFIG.networkTimeout

        req.send(formdata)
    })
}

/**
 * request an url, get result in JSON
 * @param  {string} url    
 * @param  {object} params 
 * @return {object}
 */
PB.Net.getJSON = function(url, params) {
    var options = { headers: { 'Accept': 'application/json' }
                  ,  method: 'GET'
                  ,    type: 'json'
                  }

    var params = params || {}
    var enc = function(param) {return !param && param!==0 ? '' : encodeURIComponent(param)}
    var qstring = Object.keys(params).reduce(function(acc, key) {return acc + enc(key) +'='+ enc(params[key]) +'&'}, '?')

    return PB.Net.xhr(url + qstring, options) 
}


/**
 * send a post request
 * @param  {string} url  requested url
 * @param  {object} data 
 * @return {object}
 */
PB.Net.post = function(url, data) {
    var options = { headers: {   
//         'Content-type': 'application/x-www-form-urlencoded' 
//                           , 'Content-length': params.length
//                           ,     'Connection': 'close'  
                             }
                  ,  method: 'POST'
                  }

    return PB.Net.xhr(url, options, data)
}



/**
 * A customized wrapper over the base xhr promise wrapper
 * @param  {string} url    
 * @param  {object} params 
 * @return {object}
 */
PB.Net.PBxhr = function(url, options, data) {
    var prom = PB.Net.xhr(url, options, data)
        
    return prom.then(function(response) {
        if(response.FAIL)
            return PB.throwDHTError(response.FAIL)

        if(typeof response == 'string' && response.slice(0,6) == '{"FAIL')
            return PB.throwDHTError((PB.parseJSON(response)||{}).FAIL)

        PB.runHandlers('networkresponse', response)
        
        return response
    })
}

PB.Net.PBpost = function(url, data) {
    // THINK: should we parametrize over the dispatch function?
    var options = { headers: {}
                  ,  method: 'POST'
                  }
                  
    return PB.Net.PBxhr(url, options, data)
}

PB.Net.PBgetJSON = function(url, params) {
    // THINK: should we parametrize over the dispatch function?
    var options = { headers: { 'Accept': 'application/json' }
                  ,  method: 'GET'
                  ,    type: 'json'
                  }

    var params = params || {}
    var enc = function(param) {return !param && param!==0 ? '' : encodeURIComponent(param)}
    var qstring = Object.keys(params).reduce(function(acc, key) {return acc + enc(key) +'='+ enc(params[key]) +'&'}, '?')

    return PB.Net.PBxhr(url + qstring, options) 
}








/*

    PB.Net Peer-to-Peer layer

    We're currently using peer.js to negotiate the WebRTC connection. There's a lot of work left to be done here.

*/


PB.Net.P2P = {}
PB.Net.P2P.peers = {}

/**
 * initialize the peer-to-peer layer
 */
PB.Net.P2P.init = function() {
    // NOTE: you have to manually enable the P2P layer via config or init options
    // e.g. PB.init({enableP2P: true})
    // or   PB.CONFIG.enableP2P = true
    if(!PB.CONFIG.enableP2P) return false
    
    PB.Net.P2P.Peer = new Peer({ host:  '162.219.162.56'
                               , port:  9000
                               , path:  '/'
                               , debug: 1
                               })
    
    PB.Net.P2P.Peer.on('open', PB.Net.P2P.openPeerConnection)
    PB.Net.P2P.Peer.on('connection', PB.Net.P2P.connection)
}

/**
 * to reload peers
 * @return {object} 
 */
PB.Net.P2P.reloadPeers = function() {
    return PB.Net.P2P.Peer.listAllPeers(PB.Net.P2P.handlePeers)
}

/**
 * open peer connection
 * @param  {string} id 
 * @return {object[]}
 */
PB.Net.P2P.openPeerConnection = function(id) {
    // OPT: do we really need this? 
    // THINK: why not just call PB.Net.P2P.reloadPeers?
    return PB.Net.P2P.Peer.listAllPeers(PB.Net.P2P.handlePeers)
}

/**
 * connection
 * @param connection
 * @returns {*}
 */
PB.Net.P2P.connection = function(connection) {
    PB.Net.P2P.reloadPeers() // OPT: do we really need this? 

    return connection.on('data', function(data) {
        PB.Data.addShellsThenMakeAvailable(data) // TODO: pass a callback in to PB.Net instead of calling this directly
    })
}

/**
 * to handle peers
 * @param  {object} peers 
 * @return {boolean}   
 */
PB.Net.P2P.handlePeers = function(peers) {
    peers.forEach(function(peer) {
        if(PB.Net.P2P.peers[peer]) 
            return false
        PB.Net.P2P.peers[peer] = PB.Net.P2P.Peer.connect(peer)
    })
}

/**
 * to send puff to peers
 * @param  {object} puff
 */
PB.Net.P2P.sendPuffToPeers = function(puff) {
    for(var peer in PB.Net.P2P.peers) {
        PB.Net.P2P.peers[peer].send(puff)
    }
}
/*

    Data management for the EveryBit platform.
    
    All puff-related data flows through here:
    caching, persistence, optimizations and network access are  handled within this module.

    Copyright 2014 EveryBit. See README for license information.

 */

PB.Data = {}
// PB.Data.puffs = []
PB.Data.bonii = {}
PB.Data.shells = []
PB.Data.shellSort = {}
// PB.Data.shelf = []
PB.Data.pendingPuffPromises = {}

PB.Data.profiles = {}

PB.Data.init = function(options) {
    if(!options.disablePublicPuffs)
        PB.Data.importShells()                                          // preload relevant shells
    PB.addBeforeSwitchIdentityHandler(PB.Data.removeAllPrivateShells)   // clear private caches
}


///////////////// new graph stuff ////////////////////

PB.Data.addSigAsVertex = function(sig) {
    var matches = PB.Data.graph.v(sig).run()
    
    if(matches.length) return false         // returns false if nothing happens
    
    return PB.Data.graph.addVertex({_id: sig, name: sig, type: 'shell'}) || true
}

PB.Data.addShellAsVertex = function(shell) {
    var matches = PB.Data.graph.v(shell.sig).run()
    
    if(!matches.length)
        return PB.Data.graph.addVertex({ _id: shell.sig, name: shell.sig, shell: shell, type: 'shell' }) || true
    
    var vertex = matches[0]
    if(vertex.shell) return false           // NOTE: returns false if it does nothing
    
    return vertex.shell = shell             // NOTE: mutation & pointer setting
}

PB.Data.addShellUsernameAsVertex = function(shell) {
    //// add shell.username to graph and connect them up
    
    var username = shell.username
    var matches = PB.Data.graph.v(username).run()
    var vertex = matches[0]
    
    if(!vertex)                             // THINK: make usernames unique like USERNAME::<username> or something
        vertex = PB.Data.graph.addVertex({ _id: username, name: username, type: 'username' })
    else
        if(PB.Data.graph.v(shell.sig).out('author').property('name').run()[0] == username)
            return false
        
    // TODO: add easy filtering by vertex type for both 'v' and also outV etc
    PB.Data.graph.addEdge({ _out: shell.sig, _in: shell.username, _label: 'author'})
}

PB.Data.graph = Dagoba.graph()

PB.Data.addToGraph = function(shells) {
    shells.forEach(PB.Data.addShellAsVertex)
    shells.forEach(PB.Data.addShellUsernameAsVertex)
    PB.runHandlers('relationship', shells)
}

// TODO: alias children() as .in('parent') and parents() as .out('parent') and use those instead (halves # of edges)

///////////////// end new graph stuff ////////////////////



PB.Data.getAllMyShells = function() {
    var publicShells = PB.Data.getPublicShells()
    var privateShells = PB.Data.getCurrentDecryptedLetters()
    return publicShells.concat(privateShells)
}


/**
 * get all currently known shells
 * @return {Shell[]}
 */
PB.Data.getShells = function() {
    //// Get all currently known shells
    // NOTE: always use this accessor instead of referencing PB.Data.shells directly, as what this function does will change.
    return PB.Data.shells
}

/**
 * get all public shells
 * @returns {Shell[]}
 */
PB.Data.getPublicShells = function() {
    //// Get all public shells
    var shells = PB.Data.getShells()
    return shells.filter(function(shell) {return !shell.keys})
}

/**
 * Get cached shells by sig
 * @param {string} sig
 * @returns {shell[]}
 */
PB.Data.getCachedShellBySig = function(sig) {
    return PB.Data.shellSort[sig]
    // return PB.Data.getShells().filter(function(shell) { return sig === shell.sig })[0]
}

/**
 * adds bonus
 * @param {object} puff
 * @param {string} key
 * @param {string} value
 */
PB.Data.addBonus = function(puff, key, value) {
    //// this simulates a WeakMap
    // THINK: we'll need to provide some GC here
    var id = puff.sig
    
    if(!PB.Data.bonii[id])
        PB.Data.bonii[id] = {}
    
    PB.Data.bonii[id][key] = value
}

/**
 * gets bonus
 * @param puff
 * @param key
 * @returns {object}
 */
PB.Data.getBonus = function(puff, key) {
    //// pull from our FauxWeakMap
    var id = puff.sig
    var puffBonii = PB.Data.bonii[id]
    return puffBonii && puffBonii[key]
}








PB.Data.addStar = function(sig, username, starsig) {
    // TODO: consider moving this to a module
    
    var fauxshell = {sig: sig} // THINK: can we formalize this?
    var starStats = PB.Data.getBonus(fauxshell, 'starStats') || {score: 0, from: {}}
    
    starStats.from[username] = starsig                                  // admittedly strange, but helpful when unstarring
    starStats.score = PB.Data.scoreStars(Object.keys(starStats.from))  // OPT: O(n^2) in stars-per-puff
    
    PB.Data.addBonus(fauxshell, 'starStats', starStats)
}

PB.Data.removeStar = function(sig, username) {
    // TODO: consider moving this to a module
    
    var fauxshell = {sig: sig} // THINK: ye gads is this ugly
    var starStats = PB.Data.getBonus(fauxshell, 'starStats') || {score: 0, from: {}}
    
    delete starStats.from[username]
    
    starStats.score = PB.Data.scoreStars(Object.keys(starStats.from))  // OPT: O(n^2) in stars-per-puff
    
    PB.Data.addBonus(fauxshell, 'starStats', starStats)
}

PB.Data.scoreStars = function(usernames) {
    
    return 0
    
    // TODO: move this into a module
    /*
    var tluScore = 0;
    var suScore = 0;
    var scorePref = Boron.shallow_copy(puffworldprops.view.score);
    for (var k in scorePref) {
        if (scorePref[k]) {
            var s = parseFloat(scorePref[k]);
            if (isNaN(s))
                s = parseFloat(puffworlddefaults.view.score[k]);
            scorePref[k] = s;
        }
    }
    
    usernames.forEach(function(username) {
        if (username.indexOf('.') == -1) {
            tluScore += scorePref.tluValue;
        } else {
            suScore += scorePref.suValue;
        }
    })
    
    var score = tluScore + Math.min(scorePref.maxSuValue, suScore);
    score = score.toFixed(1);
    if (score == parseInt(score)) score = parseInt(score);
    return score
    */
}








/*
    Some new shell handling equipment. Need to integrate this more deeply and clean and test.
*/

PB.Data.addShellsThenMakeAvailable = function(shells) {
    //// adds shells to the system, then returns a report on its progress
    
    // report.delivered: 10
    // report.valid: 8
    // report.new_shells: 7
    // report.new_puffs: 5
    // report.GC: 0
    
    // report.public: 2
    // report.stars: 0
    
    // report.private_promise: {sigs:[], failed: }
    
    // report.public_puff_sigs: []
    
    function not(fun) {return function(x) {return !fun(x)}}
    
    var report = {counts: {}}
    
    shells = Array.isArray(shells) ? shells : [shells]
    report.counts.delivered = shells.length
    
    shells = shells.filter(PB.isValidShell)
    report.counts.valid = shells.length
    
    report.meta = PB.Data.handleMetaPuffs(shells)
    
    shells = shells.filter(not(PB.Data.isMetaPuff))
    report.counts.nonmeta = shells.length
    
    report.private_promise = PB.Data.handlePrivatePuffs(shells)
    
    shells = shells.filter(not(PB.Data.isPrivatePuff))
    report.counts.public = shells.length
    
    shells = PB.Data.handleAndFilterExistingShells(shells)
    report.counts.new_public = report.counts.public - shells.length
    
    PB.Data.handleNewPublicShells(shells)
    
    shells = PB.Data.handleAndFilterByGC(shells)
    report.counts.gc = report.counts.new_public - shells.length

    report.public_puff_sigs = shells.map(PB.prop('sig'))
    
    PB.runHandlers('newPuffs', shells)
    PB.runHandlers('newPuffReport', report)
    
    return report
}


PB.Data.handleMetaPuffs = function(shells) {
    // TODO: move this to a module
    var metapuffs = shells.filter(PB.Data.isMetaPuff)
    
    metapuffs.forEach(function(shell) {
        var sig = shell.payload.content
        PB.Data.addStar(sig, shell.username, shell.sig)
    })
    
    return {stars: metapuffs.length}
}

PB.Data.isMetaPuff = function(shell) {
    // TODO: move this to a module
    return shell.payload.type == 'star'    
}


PB.Data.handlePrivatePuffs = function(shells) {
    var privatepuffs = shells.filter(PB.Data.isPrivatePuff)    
    return PB.Data.ingestEncryptedShells(privatepuffs) // TODO: this returns our promise report
}


PB.Data.isPrivatePuff = function(shell) {
    return shell.payload.type == 'encryptedpuff'
}


PB.Data.handleAndFilterExistingShells = function(shells) {
    // THINK: this can't answer the question of "did we updated an existing shell with content"?
    return shells.filter(function(shell) {
        var existing = PB.Data.getCachedShellBySig(shell.sig)

        if(existing) {
            if(existing.payload.content) return false
            if(shell.payload.content === undefined) return false    // it's an empty shell
            existing.payload.content = shell.payload.content        // add the missing content
            return true // true because we changed it
        }
    })
}


PB.Data.handleNewPublicShells = function(shells) {
    shells.forEach(function(shell) {
        PB.Data.shells.push(shell)
        PB.Data.shellSort[shell.sig] = shell
    })

    PB.Data.addToGraph(shells)
    PB.Data.rateSomePuffs(shells)
    PB.Data.persistShells()                                     // drop new stuff into localStorage
}


PB.Data.handleAndFilterByGC = function(shells) {
    var compacted = PB.Data.garbageCompactor()                  // OPT: call this earlier
    if(!compacted) return shells
    
    return shells.map(PB.prop('sig'))                            // if GC eats puffs this spits them out
                 .map(PB.Data.getCachedShellBySig)
                 .filter(Boolean)
}


/**
 * to persist shells
 * @param {Shell[]}
 * @returns {(boolean|*)}
 */
PB.Data.persistShells = function(shells) {
    if(PB.CONFIG.noLocalStorage) return false                      // THINK: this is only for debugging and development
    
    // THINK: when we receive shells directly we should compact them too
    if(!shells) 
        shells = function() {return PB.Data.getShellsForLocalStorage()} // thunked for perf
    
    // when you save shells, GC older "uninteresting" shells and just save the latest ones
    // THINK: is this my puff? then save it. otherwise, if the content is >1k strip it down.
    // THINK: we need knowledge of our user records here... how do we get that? 
    // PB.Data.interesting_usernames?
    
    // shells = shells.filter(function(shell) { return !shell.payload.content || (shell.payload.content.length < 1000) })
    
    PB.Persist.save('shells', shells)
}



PB.Data.getConversationPuffs = function(convoId, offset, batchsize) {
    offset = offset || 0
    batchsize = batchsize || PB.CONFIG.pageBatchSize || 10
    
    var prom
    prom = PB.Net.getConversationPuffs(convoId, batchsize, offset)
    prom = prom.then(PB.Data.addShellsThenMakeAvailable)
    return prom
}

PB.Data.getConversationPuffs = PB.promiseMemoize(PB.Data.getConversationPuffs, function(key, report) {
    report.private_promise.then(function() {
        PB.removePromisePending(key)
    })
})


/**
 * to import shells from local and remote sources
 */
PB.Data.importShells = function() {
    //// fetch shells from local and remote sources
    
    // THINK: this should take a set of routes so we can pass them to importRemoteShells
    
    // grab the local shells and add them to the system
    // then grab some remote shells (latest 100) and compare them
    // go back until we fill in the gaps, or hit the threshold (500?)
    
    // when you want to look at shells that don't exist, like when scrolling, grab them as a batch
    
    PB.Data.importLocalShells()
    // PB.Data.getMoreShells()
    PB.Data.importRemoteShells()
    // PB.Data.importAllStars()
}

/**
 * to import local shells
 */
PB.Data.importLocalShells = function() {   // callback) {
    // PB.Data.shells = PB.Persist.get('shells') || []
    var localShells = PB.Persist.get('shells') || []
    
    PB.Data.addShellsThenMakeAvailable(localShells)
}


PB.Data.importAllStars = function() {
    // TODO: consider moving this to a module
    var prom = PB.Net.getStarShells()
    prom.then(PB.Data.addShellsThenMakeAvailable)
}


PB.Data.horridStash = {}

PB.Data.isBadEnvelope = function(sig) {
    return PB.Data.horridStash[sig]
}

PB.Data.addBadEnvelope = function(sig) {
    PB.Data.horridStash[sig] = true
}


PB.Data.currentDecryptedLetters = []
PB.Data.currentDecryptedLetterMap = {}

PB.Data.getCurrentDecryptedLetters = function() {
    //// NOTE: always use this instead of hitting currentDecryptedLetters directly, as this function may change
    return PB.Data.currentDecryptedLetters
}

PB.Data.getDecryptedLetterBySig = function(sig) {
    if(PB.Data.currentDecryptedLetterMap[sig])
        return PB.Data.currentDecryptedLetterMap[sig]
}


PB.Data.addDecryptedLetter = function(letter, envelope) {
    // THINK: how can we avoid doing this 'existing letter' check twice?
    var maybeLetter = PB.Data.getDecryptedLetterBySig(envelope.sig)
    if(maybeLetter) return false
    
    if(letter.payload.type == 'identity') return false             // THINK: where should this live?
    
    PB.Data.currentDecryptedLetters.push(letter)
    
    PB.Data.currentDecryptedLetterMap[envelope.sig] = letter       // letter is a puff too
    PB.Data.currentDecryptedLetterMap[letter.sig] = letter         // stash it both ways
    PB.Data.addBonus(letter, 'envelope', envelope)                 // mark it for later
    
    PB.Data.addToGraph([letter])

    return true
}

PB.Data.removeAllPrivateShells = function() {
    PB.Data.currentDecryptedLetters.forEach(function(shell) {
        PB.Data.removeShellFromCache(shell.sig)
    })
    
    PB.Data.currentDecryptedLetterMap = {}
    PB.Data.currentDecryptedLetters = [] 
}



PB.Data.encryptPuff = function(letter, myPrivateWif, userRecords, privateEnvelopeAlias) {
    //// stick a letter in an envelope. userRecords must be fully instantiated.
    var puffkey = PB.Crypto.getRandomKey()                                        // get a new random key
    
    var letterCipher = PB.Crypto.encryptWithAES(JSON.stringify(letter), puffkey)  // encrypt the letter
    var versionedUsername = letter.username
    
    if(privateEnvelopeAlias) {
        myPrivateWif = privateEnvelopeAlias.default
        versionedUsername = PB.Users.makeVersioned(privateEnvelopeAlias.username, privateEnvelopeAlias.capa)
    }
    
    var envelope = PB.Data.packagePuffStructure(versionedUsername, letter.routes  // envelope is also a puff
                           , 'encryptedpuff', letterCipher, {}, letter.previous)  // it includes the letter
    
    envelope.keys = PB.Crypto.createKeyPairs(puffkey, myPrivateWif, userRecords)  // add decryption keys
    envelope.sig = PB.Crypto.signPuff(envelope, myPrivateWif)                     // sign the envelope
    
    return envelope
}

PB.Data.extractLetterFromEnvelope = function(envelope) {                // the envelope is a puff
    if(PB.Data.isBadEnvelope(envelope.sig)) 
        return Promise.reject('Bad envelope')                           // flagged as invalid envelope

    var maybeLetter = PB.Data.getDecryptedLetterBySig(envelope.sig)     // have we already opened it?
    
    if(maybeLetter)
        return Promise.resolve(maybeLetter)                             // resolve to existing letter
    
    var prom = PB.Data.getDecryptedPuffPromise(envelope)                // do the decryption
    
    return prom.catch(function(err) { return false })
               .then(function(letter) {
                   if(!letter) {
                       PB.Data.addBadEnvelope(envelope.sig)             // decryption failed: flag envelope
                       return PB.throwError('Invalid envelope')         // bail out
                   }

                   return letter
               })
    
}

PB.Data.getDecryptedPuffPromise = function(envelope) {
    //// pull a letter out of the envelope -- returns a promise!

    if(!envelope || !envelope.keys) 
        return PB.emptyPromise('Envelope does not contain an encrypted letter')
    
    var senderVersionedUsername = envelope.username
    var userProm = PB.Users.getUserRecordPromise(senderVersionedUsername)
    
    var puffprom = userProm
    .catch(PB.catchError('User record acquisition failed'))
    .then(function(senderVersionedUserRecord) {
        var prom // used for leaking secure promise

        PB.useSecureInfo(function(identities, currentUsername) {
            // NOTE: leaks a promise which resolves to unencrypted puff
        
            var identity = identities[currentUsername]
            var aliases  = identity.aliases
            var matchingUsername = ''
                
            top: for(var keykey in envelope.keys) {             // match our aliases against all recipients
                for (var i = 0; i < aliases.length; i++) {
                    var alias = aliases[i]
                    
                    if(alias.username == keykey) {              // only for old, unversioned usernames
                        matchingUsername = alias.username
                        break top
                    }
                    
                    var versionUsername = PB.Users.makeVersioned(alias.username, alias.capa)
                    if(versionUsername == keykey) {
                        matchingUsername = versionUsername
                        break top
                    }
                }
            }

            if(!matchingUsername)
                return PB.throwError('No key found for current user')

            var recipientPrivateKey = alias.privateDefaultKey
            var senderPublicKey = senderVersionedUserRecord.defaultKey
            
            prom = PB.Data.decryptPuffAlmostForReals(envelope, senderPublicKey, matchingUsername, recipientPrivateKey)
        })

        return prom
    })
    
    return puffprom
}

PB.Data.decryptPuffAlmostForReals = function(envelope, senderPublicKey, recipientUsername, recipientPrivateKey) {
    return new Promise(function(resolve, reject) {
        return PB.cryptoworker
             ? PB.workersend( 'decryptPuffForReals'
                            , [ envelope
                              , senderPublicKey
                              , recipientUsername
                              , recipientPrivateKey ]
                            , resolve, reject )
             : resolve( PB.decryptPuffForReals( envelope
                                              , senderPublicKey
                                              , recipientUsername
                                              , recipientPrivateKey ) )
    })
}


PB.Data.packagePuffStructure = function(versionedUsername, routes, type, content, payload, previous) {
    //// pack all the parameters into an object with puff structure (without signature)
    
    payload = payload || {}                     // TODO: check all of these values more carefully
    payload.content = content
    payload.type = type

    routes = routes || []
    previous = previous || false                // false for DHT requests and beginning of blockchain, else valid sig

    var puff = { username: versionedUsername
               ,   routes: routes
               , previous: previous
               ,  version: '0.1.0'              // version accounts for crypto type and puff shape
               ,  payload: payload              // early versions will be aggressively deprecated and unsupported
               }
    
    return puff
}











PB.Data.getMorePrivatePuffs = function(username, offset, batchsize) {
    // THINK: race condition while toggling identities?
    if(!username) username = PB.getCurrentUsername()
    
    offset = offset || 0
    // offset = offset || PB.CONFIG.initLoadBatchSize || 20
    batchsize = batchsize || PB.CONFIG.pageBatchSize || 10
    
    var prom
    prom = PB.Net.getMyPrivatePuffs(PB.getCurrentUsername(), batchsize, offset) // THINK: why switched param order?
    prom = prom.then(PB.Data.addShellsThenMakeAvailable)
    return prom
}


PB.Data.updatePrivateShells = function(offset) {
    var username = PB.getCurrentUsername()
    var batchsize = 1
    var fullOrShell = 'full' // OPT: just gather the shell (or sig) here when checking latest
    offset = offset || 0     //      actually... we need a list of all sigs we've encountered (not just good ones)
                             //      otherwise bad envelopes (etc) could block prior good content.

    PB.Net.getMyPrivatePuffs(username, batchsize, offset, fullOrShell)
          .then(function(shells) {
              var shell = shells[0]
              if(!shell) return false
              
              var prom = PB.Data.ingestAnEncryptedShell(shell) // manual because we need the decryption promise
              
              prom.then(function(fresh) {
                  if(fresh)
                      PB.Data.updatePrivateShells(1+offset)
              })
          })
}


PB.Data.ingestEncryptedShells = function(shells) {
    var proms = shells.map(PB.Data.ingestAnEncryptedShell)
    
    // NOTE: Promise.all rejects immediately upon any rejection, so we have to do this manually
    
    return new Promise(function(resolve, reject) {
        var remaining = proms.length
        var report = {good: 0, bad: 0, goodsigs: []}
        
        // TODO: add more information about what went wrong to the report
        
        function unhappy_path() {
            report.bad++
            if(!--remaining) resolve(report)
        }
        
        proms.forEach(function(prom) {
            prom.then(function(letter) {
                if(!letter) return unhappy_path()                       // catches old or weird puffs 
                report.good++                                           // TODO: differentiate above cases
                report.goodsigs.push(letter.sig)
                if(!--remaining) resolve(report)
            }, unhappy_path )                                           // catches decryption errors
        })
    })
}


PB.Data.ingestAnEncryptedShell = function(envelope) {
    var prom = PB.Data.extractLetterFromEnvelope(envelope)

    prom = prom.then(function(letter) {
        if(!letter) return false
        
        var fresh = PB.Data.addDecryptedLetter(letter, envelope)        // add the letter to our system
        if(!fresh) return false
        
        PB.runHandlers('newPuffs', [letter])                            // always receives an array of puffs
        return letter
    })
    
    return prom
    
    // NOTE: this doesn't appear to do much, mostly because extractLetterFromEnvelope is quite effectful.
    //       it calls PB.Data.addDecryptedLetter as part of its processing, which does all the real work.
    
    // THINK: consider adding this back in, though remember that each decryption pushes its own errors...
    // if (letters.length != privateShells.length) {
    //     Events.pub('track/decrypt/some-decrypt-fails',
    //                 {letters: letters.map(function(p){return p.sig}),
    //                  privateShells: privateShells.map(function(p){return p.sig})})
    // }
}




// the slot locker contains information on queries made to fill slots. 
// in particular it holds the offset, which will be -1 when [] is returned.
// it keeps queries from re-requesting the same shells over and over, 
// and provides some concurrency / flow control by allowing a query
// to set it to -1 when it is running and then replace it when done.
PB.Data.slotLocker = {}

// THINK: we're calling this from the 'refresh' button now...


PB.Data.importRemoteShells = function() {
    //// only called during initial application bootup. handles both cold loads and hot loads.
    
    var offset = 0
    var giveup = PB.CONFIG.initLoadGiveup
    var limit  = PB.CONFIG.initLoadBatchSize
    var new_shells = []
    var keep_going = true
    
    var key = '[{"sort":"DESC"},{"tags":[],"types":[],"users":[],"routes":[]}]' // TODO: upgrade this default query
    PB.Data.slotLocker[key] = -1
    
    // TODO: index by username
    // TODO: if duplicate check update times for latest
    // TODO: persist to LS (maybe only sometimes? onunload? probabilistic?)
         
    function getMeSomeShells(puffs) {
        if(puffs) {
            var delta = PB.Data.addShellsThenMakeAvailable(puffs)
            // new_shells = new_shells.concat(my_new_shells)
            // var delta = my_new_shells.length
            
            if(delta != limit) // some shells were already in our cache
                keep_going = false
        }
        
        if(offset > giveup)
            keep_going = false

        if(!keep_going) {
            PB.Data.slotLocker[key] = 1
            // PB.Data.stupidHorribleGlobalThing = true
            // PB.Data.makeShellsAvailable(new_shells)
            return false
        }
        
        var prom = PB.Net.getSomeShells({}, {}, limit, offset)
        prom.then(getMeSomeShells)

        offset += limit
    }
    
    getMeSomeShells()
}


/**
 * to fill some slots
 * @param {number} need
 * @param {number} have
 * @param {string} query
 * @param {string} filters
 * @returns {boolean}
 */
PB.Data.fillSomeSlotsPlease = function(need, have, query, filters) {
    //// we have empty slots on screen. fill them with puffs.
    
    if(have >= need) return false
    
    // -- redraw screen on new puffs being ingested (w/o looping)
    // -- cycle all new puffs through graph stuff
    // -- call fillSomeSlotsPlease every time we have slots to fill
    // -- get focused puff immediately
    
    // - perform GC on in-memory puffs (can remove content also)
    // - use GC funs for persisting shells
    // - store size of each shell/puff for GC
    // - manage empty vertices better (different type?)

    var args = [query, filters]
    // var args = [query, filters, need]
    // if(!query.mode) args.push(have) // hack for alternate query modes

    var key = JSON.stringify(args)
    var my_offset = PB.Data.slotLocker[key] || 0
    
    if(my_offset < 0)
        return false // slot is locked, go elsewhere
    
    PB.Data.slotLocker[key] = -1 // prevent concurrent versions of the same request
    
    //////

    // var limit = need - have + 3 // 3 for luck
    
    var limit = need // so... if we only do this once, and we have half the puffs already, we might only grab that half again. this is true even if we send an offset of 'have' to the server, because what we have might map to that slice (or to anything else -- our offsets are totally different than the servers). so we have to grab enough to cover the difference, which means grabbing the same shells multiple times... (but only empty shells, fortunately. but still.)
    
    // var received_shells = 0
    
    var prom = PB.Net.getSomeShells(query, filters, limit, query.offset)
    // prom.then(function(shells) {received_shells = shells.length; return shells})
    prom.then(PB.Data.addShellsThenMakeAvailable)
        .then(function(delta) { 
            PB.Data.slotLocker[key] = delta ? 1 : -1}) 
            // if the request is fruitful, unlock it (but be careful of offsets here).
            // also, this locks when we received data but chose not to keep it (either dups or GC),
            // so we could have an issue with locked queries that would be fruitful w/ different offset / limits...
    
    
    // TODO: the slotLocker really should keep track of what 'slices' of the server you've seen, so we know not to re-request those over and over. this is... complicated. 
    //       so send query.offset+have to getSomeShells, and store that same offset as part of the slotLocker.
    //       then you can track how much of some type of stuff is on the server... except that doesn't work for the P2P network.
    
    return true
    
    //////


    // OLD STUFF SAVE FOR REFERENCE

    // var batchSize = PB.CONFIG.fillSlotsBatchSize
    // var giveup = PB.CONFIG.fillSlotsGiveup
    // var new_shells = []
    //
    // giveup = giveup + my_offset
    //
    // function getMeSomeShells(puffs) {
    //     if(puffs) {
    //         var my_new_shells = PB.Data.hereHaveSomeNewShells(puffs)
    //         new_shells = new_shells.concat(my_new_shells)
    //         var delta = my_new_shells.length
    //         // THINK: but do they pass the filter?
    //         // TODO: can we make available here now that we're locking?
    //         have += delta || 0
    //     }
    //
    //     if(have >= need || my_offset > giveup || (query.mode && (my_offset - giveup < 0))) {
    //         PB.Data.makeShellsAvailable(new_shells)
    //         PB.Data.slotLocker[key] = my_offset-limit
    //         return false
    //     }
    //
    //     var limit = need - have
    //     // if(!query.mode) limit += 50 // grab a few extras to help work through bare patches
    //
    //     var prom = PB.Net.getSomeShells(query, filters, limit, my_offset)
    //     prom.then(getMeSomeShells)
    //
    //     my_offset += limit
    // }
    //
    // getMeSomeShells()
}


/*
    End shell collection intake equipment
*/


/**
 * returns a puff from a shell
 * @param  {(string|object)} shell 
 * @return {object} returns a puff based on the shell; returns false if the shell is empty
 */
PB.Data.getPuffFromShell = function(shell) {
    if(!shell)
        return false // so we can filter empty shells out easily, while still loading them on demand
    
    if(shell.payload && shell.payload.content !== undefined)
        return shell // it's actually a full blown puff
    
    return PB.Data.getPuffBySig(shell.sig) // returns a puff, or asks the network and returns false
}

/**
 * to get puff by its sig
 * @param {string} sig
 * @returns {(object|false)}
 */
PB.Data.getPuffBySig = function(sig) {
    var shell = PB.Data.getCachedShellBySig(sig) // OPT: this happens twice almost always
    
    if(shell && shell.payload && typeof shell.payload.content != 'undefined')
        return shell
    
    if(PB.Data.pendingPuffPromises[sig])
        return false
        
    // locally cached shells that are missing content on the network prevent slotfills from resolving,
    // so we clear it from our cache if we can't find it.
    function badShellClearCache(shells) {
        if(!shells.length) {
            var fauxshell = {sig: sig}
            if(!PB.Data.getBonus(fauxshell, 'envelope')) {
                PB.Data.removeShellFromCache(sig)
                return PB.onError("Content can not be found for shell '" + sig + "'") // THINK: why was this throwError?
                // THINK: unlock PB.Data.pendingPuffPromises[sig]? probably not, but it might re-appear later...
            }
        }
        return shells
    }
    
    PB.Data.pendingPuffPromises[sig] = PB.Net.getPuffBySig(sig)      // TODO: drop this down in to PB.Net instead
    PB.Data.pendingPuffPromises[sig].then(badShellClearCache)
                        .then(PB.Data.addShellsThenMakeAvailable)
                        .then(function() {                           // delay GC to stop runaway network requests
                            setTimeout(function() { delete PB.Data.pendingPuffPromises[sig] }, 10000) })
    
    return false
}

PB.Data.removeShellFromCache = function(sig) {
    // remove from PB.Data.shells
    var shell = PB.Data.getCachedShellBySig(sig)
    PB.Data.shells.splice( PB.Data.shells.indexOf(shell), 1 )
    
    // remove from PB.Data.shellSort
    delete PB.Data.shellSort[sig]
    
    // remove shell's bonii
    delete PB.Data.bonii[sig]
    
    PB.Data.purgeShellFromGraph(sig)
    
    PB.Data.removeCachedPuffScore(shell)
}

PB.Data.purgeShellFromGraph = function(sig) {
    // change graph vertex to 'pseudo-shell' type (or 'purged' type?)
    //   and remove the content of the 'shell' property
    // TODO: this is icky make it better
    var vertex = PB.Data.graph.v(sig).run()[0]
    if(vertex) {
        vertex.type = 'purged'
        vertex.shell = undefined
    }
}


/**
 * to get my puff chain
 * @param  {string} username 
 * @return {object}
 */
PB.Data.getMyPuffChain = function(username) {
    // CURRENTLY UNUSED
    // TODO: this should grab my puffs from a file or localStorage or wherever my identity's puffs get stored
    // TODO: that collection should be updated automatically with new puffs created through other devices
    // TODO: the puffchain should also be sorted in chain order, not general collection order
    
    var shells = PB.Data.getShells()
    
    return shells.filter(function(puff) { return puff && puff.username == username }) // TODO: use the graph
    // return PB.M.Forum.getByUser(username) // TODO: test this 
}



///////////////////////////////////////////
//                                       //
//       Garbage Collector Thing         //
//                                       //
///////////////////////////////////////////



PB.Data.runningSizeTally = 0
PB.Data.scoreSort = {}

PB.Data.heuristics = []
PB.Data.addHeuristics = function(fun) {
    PB.Data.heuristics.push(fun)
}

PB.Data.addHeuristics(function(shell) {
    return parseFloat( (PB.Data.getBonus(shell, 'starStats') || {}).score || 0 ) * 100
})

// TODO: add heuristics for: my puffs (which go elsewhere, ultimately), replies to my puffs, my puff's parents, 
//       friend's puffs (whatever that means), puff freshness, last seen, etc


PB.Data.rateMyPuff = function(puff) {
    var scores = PB.Data.heuristics.map(function(h) {return h(puff)})           // apply heuristics
    var total  = scores.reduce(function(acc, score) {return acc+(score||0)}, 0) // get total // TODO: improve algo
    return total
}

PB.Data.rateSomePuffs = function(puffs) {
    puffs.forEach(function(puff) {                                              // rate each puff
        var score = PB.Data.rateMyPuff(puff)
        PB.Data.doStuffWithScore(puff, score)
        PB.Data.doStuffWithPuff (puff)
    })
    // THINK: some heuristics rely on scores of related puffs... possible feedback loop? topological ordering?
    //        a toposort is easy-ish w/ graph db...
}

// TODO: when you switch identities, rescore the puffs


PB.Data.doStuffWithScore = function(puff, score) {
    PB.Data.removeCachedPuffScore(puff)                                         // NOTE: has to come before bonii
    PB.Data.addBonus(puff, 'rating', score)                                     // add rating to bonii
    PB.Data.cachePuffScore(puff, score)    
    // OPT: cache sorted version
    // maybe bins[score.floor].push(puff) or something...
}

PB.Data.doStuffWithPuff = function(puff) {
    var puffsize = JSON.stringify(puff).length
    PB.Data.addBonus(puff, 'size', puffsize)
    PB.Data.runningSizeTally += puffsize || 0                                  // block NaNs
}

PB.Data.cachePuffScore = function(puff, score) {
    var key = PB.Data.convertScoreToKey(score)
    PB.Data.scoreSort[key] = PB.Data.scoreSort[key] || []
    PB.Data.scoreSort[key].push(puff)
}

PB.Data.removeCachedPuffScore = function(puff) {
    if(!puff) return false
    
    var score = PB.Data.getBonus(puff, 'score')
    var key = PB.Data.convertScoreToKey(score)
    var bin = PB.Data.scoreSort[key]
    if(!bin) return false
    if(!bin.length) return false
    
    for(var i = bin.length - 1; i >= 0; i--) {
        if(bin[i].sig == puff.sig) {
            bin.splice(i, 1)
            var puffsize = PB.Data.getBonus(puff, 'size')
            PB.Data.runningSizeTally -= puffsize || 0                          // block NaNs
            return false
        }
    }
}

PB.Data.getCachedPuffs = function(limit, bottom) {
    var seen = 0
    var result = []
    var keys = Object.keys(PB.Data.scoreSort).map(parseFloat).sort()
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i]
        var puffs = PB.Data.scoreSort[key] // OPT: short-circuit on !bottom
        
        puffs.reduce(function(seen, puff) {
            if(seen > limit == !!bottom) result.push(puff)
            return seen+1
        }, 0)
    }
    
    return result
}

PB.Data.convertScoreToKey = function(score) {
    return Math.floor(score / 10) || 0 // TODO: make this smarter
}


PB.Data.getTopPuffs = function(limit) {
    return PB.Data.getCachedPuffs(limit)
}

PB.Data.getNotTopPuffs = function(limit) {
    // grab the puffs below the limit threshold (w/ 300 puffs and limit=100 this returns the 200 worst puffs)
    return PB.Data.getCachedPuffs(limit, 'bottom')
}

// PB.Data.getTopPuffs = function(options) {
//     var numberLimit =  options.number || 0
//     var sizeLimit   =    options.size || 0
//     var compact     = options.compact || false  // whether to allow compaction of returned puffs
//     var reverse     = options.reverse || false  // return bottom puffs instead of top puffs
// }

PB.Data.garbageCompactor = function() {
    // are we over the limits?
    var limit     = PB.CONFIG.inMemoryShellLimit
    var memlimit  = PB.CONFIG.inMemoryMemoryLimit
    var sizelimit = PB.CONFIG.shellContentThreshold
    var didStuff  = false

    if(PB.Data.shells.length > limit) {
        didStuff = true
        PB.Data.shells.slice(limit).map(PB.prop('sig')).forEach(PB.Data.removeShellFromCache)
    }
    
    if(PB.Data.runningSizeTally > memlimit) {
        didStuff = true
        for (var i = PB.Data.shells.length - 1; i >= 0; i--) {
            var shell = PB.Data.shells[i]
            var content_size = (shell.payload.content||"").toString().length // THINK: non-flat content borks this
            if (content_size > sizelimit) {
                delete shell.payload.content // THINK: this is hardcore
                total -= content_size + 13 // NOTE: magic number == '"content":"",'.length
                if(total <= memlimit) break
            }
        }
    }
    
    return didStuff
}


PB.Data.getShellsForLocalStorage = function() {
    var limit     = PB.CONFIG.localStorageShellLimit
    var memlimit  = PB.CONFIG.localStorageMemoryLimit
    var sizelimit = PB.CONFIG.shellContentThreshold
    
    var shells = PB.Data.getTopPuffs(limit)
    var total = shells.reduce(function(size, shell) {
        return size + (PB.Data.getBonus(shell, 'size') || 0)
    }, 0)
    
    if (total <= memlimit) return shells
    
    // compact the puffs
    for (var i = shells.length - 1; i >= 0; i--) {
        var shell = shells[i]
        var content_size = (shell.payload.content||"").toString().length // THINK: non-flat content borks this
        if (content_size > sizelimit) {
            var new_shell = PB.Data.compactPuff(shell)
            shells[i] = new_shell
            total -= content_size + 13 // NOTE: magic number == '"content":"",'.length
            if(total <= memlimit) break
        }
    }
    
    if (total <= memlimit) return shells
    
    // remove shells until under memlimit
    for (var i = shells.length - 1; i >= 0; i--) {
        var content_size = JSON.stringify(shell).length
        total -= content_size
        if(total <= memlimit) break
    }
    
    shells = shells.slice(0, Math.max(i, 1)) // prevent -1 
    
    return shells
}


PB.Data.compactPuff = function(puff) {
    // THINK: instead of rebuilding the puff, use a JSON.stringify reducer that strips out the content
    var new_shell = Boron.extend(puff)
    var new_payload = {}
    for(var prop in puff.payload)
        if(prop != 'content')
            new_payload[prop] = puff.payload[prop] 

    new_shell.payload = new_payload
    return new_shell
}

/*

    User management for the EveryBit platform.

    Most functions related to userRecords live here.
    Note that userRecords are entirely public;
    private key identities are handled elsewhere.

    Copyright 2014 EveryBit. See README for license information.

 */

PB.Users = {}

PB.Users.records  = {}                              // maps versioned username to an array of DHT userRecords
PB.Users.promises = {}                              // pending userRecord requests


PB.Users.init = function(options) {
    PB.Users.depersist()                            // pop userRecords out of localStorage
}


PB.Users.process = function(userRecord) {
    //// Processes all incoming userRecords
    
    userRecord = PB.Users.build( userRecord.username, userRecord.defaultKey, userRecord.adminKey
                               , userRecord.rootKey,  userRecord.latest,     userRecord.created
                               , userRecord.updated,  userRecord.profile,    userRecord.identity
                               , userRecord.capa )
    
    if(!userRecord)
        return PB.onError('That is not an acceptable user record', userRecord)
    
    PB.Users.cache(userRecord)
    
    return userRecord
}


PB.Users.getCachedUserRecord = function(username) {
    if(PB.Users.makeVersioned(username) == username)    // username is versioned
        return PB.Users.records[username]
    
    return PB.Users.findFreshest(username)              // username isn't versioned
}


/**
 * Checks the cache, and always returns a promise
 * @param {string} username
 * @param {int} capa is the version of the username keys
 * @returns {object} Promise for a user record
 * Looks first in the cache, then grabs from the network
 */
PB.Users.getUserRecordPromise = function(username, capa) {
    //// This always checks the cache, and always returns a promise
    
    var versionedUsername = PB.Users.makeVersioned(username, capa)
    
    var userRecord = PB.Users.getCachedUserRecord(versionedUsername)
    
    if(userRecord)
        return Promise.resolve(userRecord)
    
    var userPromise = PB.Users.promises[versionedUsername]
    
    if(userPromise)
        return userPromise
    
    return PB.Users.getUserRecordNoCache(versionedUsername)
}


/**
 * Forces a request to the network, ignores cached
 * @param {string} username
 * @param {int} capa is the version of the username keys
 * @returns {object} Promise for a user record
 */
PB.Users.getUserRecordNoCache = function(username, capa) {
    //// This never checks the cache
    
    capa = capa || 0 // 0 signals PB.Net.getUserRecord to get the latest userRecord
    
    var prom = PB.Net.getUserRecord(username, capa) 
    
    prom = prom.then(
                function(userRecord) {
                    var userRecord = PB.Users.process(userRecord)
                    if(!userRecord)  PB.throwError('Invalid user record returned')
                    return userRecord
                }
                , PB.catchError('Unable to access user information from the DHT'))
    
    var versionedUsername = PB.Users.makeVersioned(username, capa)
    PB.Users.promises[versionedUsername] = prom
    
    return prom
}

PB.Users.doesUserExist = function(username) {
    return PB.Net.getUserRecord(username).then(
                function(userRecord) {
                    if(!userRecord || userRecord.FAIL) 
                        throw 'User does not exist'
                    return true
                }
                , PB.catchError('Unable to access user information from the DHT'))
}


//
// USERNAME HELPERS
//

PB.Users.userRecordToVersionedUsername = function(userRecord) {
    return PB.Users.makeVersioned(userRecord.username, userRecord.capa)
}

PB.Users.justUsername = function(versionedUsername) {
    var uc = PB.Users.breakVersionedUsername(versionedUsername)
    return uc.username
}

PB.Users.justCapa = function(versionedUsername) {
    var uc = PB.Users.breakVersionedUsername(versionedUsername)
    return uc.capa
}

PB.Users.makeVersioned = function(username, capa) {
    if(!username || !username.indexOf)
        return ''
    
    if(capa)
        return actuallyVersionThisUsernameOkay(username, capa)
    
    if(username.indexOf(':') > 0)
        return username
    
    return actuallyVersionThisUsernameOkay(username)
    
    function actuallyVersionThisUsernameOkay(username, capa) {
        capa = capa || 1 // NOTE: default capa
        return username + ':' + capa
    }
}

PB.Users.breakVersionedUsername = function(versionedUsername) {
    var list = (versionedUsername||'').split(':')

    return { username: list[0]
           , capa:     list[1] || 1 // NOTE: default capa
           }
}


//
// GENERAL HELPERS
//


PB.Users.build = function(username, defaultKey, adminKey, rootKey, latest, created, updated, profile, identity, capa) {
    //// returns a canonical user object: use this everywhere user objects are needed (DHT, identities, etc)

    latest   = latest   || ""                       // signature of the most recent puff published by the user
    updated  = updated  || ""                       // date of the most recent update to the username
    profile  = profile  || ""                       // profile puff signature
    identity = identity || ""                       // identity puff signature
    capa     = capa     || 1                        // version of the username
    
    // THINK: should we check for valid keys? valid timestamp for updated? what if you want a partially invalid user like anon?
    
    // THINK: split username and capa if it's a versionedUsername?

    if(!PB.validateUsername(username))
        return false                                // error is logged inside PB.validateUsername
    
    return {   username: username                   // unversioned username
           ,       capa: capa
           ,    rootKey: rootKey                    // public root key
           ,   adminKey: adminKey                   // public admin key
           , defaultKey: defaultKey                 // public default key
           ,    created: created                    // Date the record was created
           ,     latest: latest
           ,    updated: updated
           ,    profile: profile
           ,   identity: identity
           }
}


PB.Users.usernamesToUserRecordsPromise = function(usernames) {
    //// returns a promise of userRecords. thanks to capa we usually don't need the latest and can use cached versions.
    if(!usernames || !usernames.length)
        return Promise.resolve([])
    
    if(!Array.isArray(usernames))
        usernames = [usernames]
        
    var userRecords = usernames.map(PB.Users.getCachedUserRecord).filter(Boolean)
    
    if (userRecords.length == usernames.length)
        return Promise.resolve(userRecords) // got 'em all!
    
    var prom = Promise.resolve() // a promise we use to string everything along

    var userRecordUsernames = userRecords.map(function (userRecord) {
        return userRecord.username
    })
    
    usernames.forEach(function (username) {
        if (!~userRecordUsernames.indexOf(username)) { // we need this one
            prom = prom.then(function() {
                return PB.Users.getUserRecordNoCache(username).then(function (userRecord) {
                    userRecords.push(userRecord)
                })
            })
        }
    })
    
    return prom.then(function() { return userRecords }) // when it's all done, give back the userRecords
}

PB.Users.cache = function(userRecord) {
    //// This caches with no validation: use PB.Users.process instead
    
    var versionedUsername = PB.Users.userRecordToVersionedUsername(userRecord)
    
    PB.Users.records[versionedUsername] = userRecord
    
    delete PB.Users.promises[versionedUsername]
    
    PB.Persist.save('userRecords', PB.Users.records)
    
    return userRecord
}

PB.Users.depersist = function() {
    //// grab userRecords from local storage. this smashes the current userRecords in memory, so don't call it after init!
    PB.Users.records = PB.Persist.get('userRecords') || {}
}


PB.Users.findFreshest = function(username) {
    username = PB.Users.justUsername(username)
    
    var keys = Object.keys(PB.Users.records)
    var capa = 0
    
    keys.filter(function(versionedUsername) {
        return PB.Users.justUsername(versionedUsername) == username
    }).forEach( function(versionedUsername) {
        var this_capa = +PB.Users.justCapa(versionedUsername)
        if(this_capa > capa)
            capa = this_capa
    })
    
    var versionedUsername = PB.Users.makeVersioned(username, capa)
    return PB.Users.records[versionedUsername]
}




//
// CLEANUP REQUIRED
//


/**
 * Get the current user's DHT record, or create a new anon user, or die trying
 * @return {string}
 */
PB.Users.getUpToDateUserAtAnyCost = function() {
    //// Either get the current user's DHT record, or create a new anon user, or die trying

    var username = PB.getCurrentUsername()

    if(username)
        return PB.Users.getUserRecordNoCache(username, 0) // 0 tells PB.Net.getUserRecord to fetch the latest
    
    var prom = PB.Users.addNewAnonUser()
    
    return prom.then(function(userRecord) {
        PB.switchIdentityTo(userRecord.username)
        console.log("Setting current user to " + userRecord.username)
        return userRecord
    })
}


/**
 * Generate a random username
 * @return {string}
 */
PB.Users.generateRandomUsername = function(len) {

    // Set a default value for length
    if(!len || len != Math.round(len))
        len=10

    var generatedName = ''
    var alphabet = 'abcdefghijklmnopqrstuvwxyz0123456789'
    for(var i=0; i<10; i++) {
        generatedName += PB.Crypto.getRandomItem(alphabet)
    }
    return generatedName
}

/**
 *
 * Register a new anonymous user
 * @param {string} passphrase optional if included then used
 * @param {string} attachToUsername
 * @returns {Promise} a promise that resolves to the user record or fails
 */
PB.Users.addNewAnonUser = function(passphrase, attachToUsername) {
    //// create a new anonymous alias. if attachToUsername is provided it becomes an alias for that identity.
    //// if attachToUsername is false the alias becomes primary for its own identity.
    // TODO: make attachToUsername work
    // THINK: Don't want to switch to this user, but what about alias issue and saving bonus info?
    // TODO: Split this into two functions, one that registers an anon user based on given info
    // another that registers anon user AND switches current to that user. Or flag in function to switch to that user.

    var newUsername = 'anon.' + PB.Users.generateRandomUsername(12)

    if(typeof passphrase !== undefined && passphrase) {
        var prependedPassphrase = newUsername + passphrase
        var privateKey = PB.Crypto.passphraseToPrivateKeyWif(prependedPassphrase)
    } else {
        var privateKey = PB.Crypto.generatePrivateKey()
    }

    // Set private keys
    var privateRootKey =    privateKey
    var privateAdminKey =   privateKey
    var privateDefaultKey = privateKey

    // Generate public keys
    var rootKey    = PB.Crypto.privateToPublic(privateKey)
    var adminKey   = PB.Crypto.privateToPublic(privateKey)
    var defaultKey = PB.Crypto.privateToPublic(privateKey)

    // build our DHT update puff
    var payload = {
        requestedUsername: newUsername,
        defaultKey: defaultKey,
        adminKey: adminKey,
        rootKey: rootKey,
        time: Date.now()
    }

    var routing = [] // THINK: DHT?
    var content = 'requestUsername'
    var type    = 'updateUserRecord'

    var puff = PB.buildPuff('anon', PB.CONFIG.anonPrivateAdminKey, routing, type, content, payload)

    return PB.Net.updateUserRecord(puff)

}

PB.Users.createAnonUserAndMakeCurrent = function() {
    var newUsername = 'anon.' + PB.Users.generateRandomUsername(12)
    var passphrase = PB.Crypto.generatePrivateKey().slice(-12)
    var prependedPassphrase = newUsername + passphrase
    var privateKey = PB.Crypto.passphraseToPrivateKeyWif(prependedPassphrase)
    var publicKey = PB.Crypto.privateToPublic(privateKey)

    // Build puff to register this user
    var payload = {
        requestedUsername: newUsername,
        defaultKey: publicKey,
        adminKey: publicKey,
        rootKey: publicKey,
        time: Date.now()
    }

    var routing = [] // THINK: DHT?
    var content = 'requestUsername'
    var type    = 'updateUserRecord'

    var puff = PB.buildPuff('anon', PB.CONFIG.anonPrivateAdminKey, routing, type, content, payload)

    var prom = PB.Net.updateUserRecord(puff)

    // Works?
    return prom.then(function(userRecord) {
        // Switch to this user
        PB.addAlias(userRecord.username, userRecord.username, 1, privateKey, privateKey, privateKey, {passphrase: passphrase})

        PB.switchIdentityTo(userRecord.username)

    })
}


/*
    Cryptographic management for the EveryBit platform.

    Contains various functions that rely on bitcoin-lib.js for their cryptographic functionality,
    an ECDH implementation, a random number shim for older browsers, and random helper functions.

    Copyright 2014 EveryBit. See README for license information.

*/

PB.Crypto = {};

/**
 * Generate private key
 * @return {string} 
 */
PB.Crypto.generatePrivateKey = function() {
    // OPT: remove this test once Bitcoin.ECKey no longer generates invalid keys (about 1 in 1,000 right now)
    var prikey = new Bitcoin.ECKey().toWif()
    if(PB.Crypto.wifToPriKey(prikey))
        return prikey
    else
        return PB.Crypto.generatePrivateKey()  // THINK: this could generate an eternal error explosion
}


/**
 * Convert public key from private key
 * @param  {string} privateKeyWIF
 * @return {string}
 */
PB.Crypto.privateToPublic = function(privateKeyWIF) {
    // TODO: This should return false if string is empty
    if(!privateKeyWIF)
        return PB.onError('That private key contained no data')
        
    try {
        return PB.Crypto.wifToPriKey(privateKeyWIF).getPub(true).toWif()
    } catch(err) {
        return PB.onError('Invalid private key: could not convert to public key', [privateKeyWIF, err])
    }
}


/**
 * Sign the hash of some data with a private key and return the sig in base 58
 * @param  {object} unsignedPuff
 * @param  {string} privateKeyWIF
 * @return {(boolean|error)}
 */
PB.Crypto.signPuff = function(unsignedPuff, privateKeyWIF) {
    //// sign the hash of some data with a private key and return the sig in base 58

    var prikey = PB.Crypto.wifToPriKey(privateKeyWIF)
    var message = PB.Crypto.puffToSiglessString(unsignedPuff)
    var messageHash = PB.Crypto.createMessageHash(message)
    
    try {
        return Bitcoin.base58.encode(prikey.sign(messageHash))
    } catch(err) {
        return PB.onError('Could not properly encode signature', [prikey, messageHash, err])
    }
}


/**
 * to verify puff sig
 * @param  {object} puff
 * @param  {string} defaultKey
 * @return {boolean}
 */
PB.Crypto.verifyPuffSig = function(puff, defaultKey) {
    var puffString = PB.Crypto.puffToSiglessString(puff);
    return PB.Crypto.verifyMessage(puffString, puff.sig, defaultKey);
}

/**
 * accept a base 58 sig, a message (must be a string) and a base 58 public key. returns true if they match, false otherwise
 * @param  {string} message
 * @param  {string} sig
 * @param  {string} publicKeyWIF
 * @return {boolean}
 */
PB.Crypto.verifyMessage = function(message, sig, publicKeyWIF) {
    //// accept a base 58 sig, a message (must be a string) and a base 58 public key. returns true if they match, false otherwise
  
    try {
        var pubkey = PB.Crypto.wifToPubKey(publicKeyWIF)
        
        var sigBytes = Bitcoin.base58.decode(sig).toJSON()
        sigBytes = sigBytes.data || sigBytes
        
        var messageHash = PB.Crypto.createMessageHash(message)
        
        return pubkey.verify(messageHash, sigBytes)
    } catch(err) {
        return PB.onError('Invalid key or sig: could not verify message', [messageHash, sig, publicKeyWIF, err])
    }
}

/**
 * to create message hash
 * @param  {string} message
 * @return {string}
 */
PB.Crypto.createMessageHash = function(message) {
    return Bitcoin.Crypto.SHA256(message).toString()
}

/**
 * crypt wif to private key
 * @param  {string} privateKeyWIF
 * @return {boolean}
 */
PB.Crypto.wifToPriKey = function(privateKeyWIF) {
    if(!privateKeyWIF)
        return PB.onError('That private key wif contains no data')

    try {
        return new Bitcoin.ECKey(privateKeyWIF, true)
    } catch(err) {
        return PB.onError('Invalid private key: are you sure it is properly WIFfed?', [privateKeyWIF, err])
    }
}

/**
 * crypt wif to public try
 * @param  {string} publicKeyWIF
 * @return {boolean}
 */
PB.Crypto.wifToPubKey = function(publicKeyWIF) {
    if(!publicKeyWIF)
        return PB.onError('That public key wif contains no data')

    try {
        var pubkeyBytes = Bitcoin.base58check.decode(publicKeyWIF).payload.toJSON()
        pubkeyBytes = pubkeyBytes.data || pubkeyBytes
        return new Bitcoin.ECPubKey(pubkeyBytes, true)
    } catch(err) {
        return PB.onError('Invalid public key: are you sure it is properly WIFfed?', [publicKeyWIF, err])
    }
}

/**
 * crypt puff to string without sig
 * @param  {object} puff
 * @return {string}
 */
PB.Crypto.puffToSiglessString = function(puff) {
    return JSON.stringify(puff, function(key, value) {if(key == 'sig') return undefined; return value})
}


PB.Crypto.passphraseToPrivateKeyWif = function(passphrase) {
    var hashStr = Bitcoin.Crypto.SHA256(passphrase).toString()
    hash = Bitcoin.convert.hexToBytes(hashStr)
    return Bitcoin.ECKey(hash).toWif()
}


/**
 * to encrypt with AES
 * @param  {string} message
 * @param  {string} key
 * @return {string}
 */
PB.Crypto.encryptWithAES = function(message, key) {
    var enc = Bitcoin.Crypto.AES.encrypt(message, key)
    return Bitcoin.Crypto.format.OpenSSL.stringify(enc)
}

/**
 * to decrypt with AES
 * @param  {string} message
 * @param  {string} key
 * @return {string}
 */
PB.Crypto.decryptWithAES = function(enc, key) {
    if(!key || !enc) return false
    var message = Bitcoin.Crypto.format.OpenSSL.parse(enc)
    var words = Bitcoin.Crypto.AES.decrypt(message, key)
    var bytes = Bitcoin.convert.wordsToBytes(words.words) 
    // var uglyRegex = /[\u0002\u0004\u0007\u000e]+$/g
    var uglyRegex = /[\u0000-\u0010]+$/g // TODO: contain AES padding
    return bytes.map(function(x) {return String.fromCharCode(x)}).join('').replace(uglyRegex, '')
}

/**
 * Get the shared secret of two users
 * @param  {string} yourPublicWif
 * @param  {string} myPrivateWif
 * @return {string}
 */
PB.Crypto.getOurSharedSecret = function(yourPublicWif, myPrivateWif) {
    // TODO: unit testing for ECDH maths
    var pubkey = PB.Crypto.wifToPubKey(yourPublicWif)
    var prikey = PB.Crypto.wifToPriKey(myPrivateWif)
    if(!pubkey || !prikey) return false  
    var secret = pubkey.multiply(prikey).toWif()
    var key = Bitcoin.Crypto.SHA256(secret).toString()
    
    return key
}

/**
 * Encode private message
 * @param  {string} plaintext
 * @param  {string} yourPublicWif
 * @param  {string} myPrivateWif
 * @return {string}
 */
PB.Crypto.encryptPrivateMessage = function(plaintext, yourPublicWif, myPrivateWif) {
    var key = PB.Crypto.getOurSharedSecret(yourPublicWif, myPrivateWif)
    if(!key) return false
    var ciphertext = PB.Crypto.encryptWithAES(plaintext, key)
    return ciphertext
}

/**
 * to decode private message
 * @param  {string} plaintext
 * @param  {string} yourPublicWif
 * @param  {string} myPrivateWif
 * @return {string}
 */
PB.Crypto.decryptPrivateMessage = function(ciphertext, yourPublicWif, myPrivateWif) {
    var key = PB.Crypto.getOurSharedSecret(yourPublicWif, myPrivateWif)
    if(!key || !ciphertext) return false
    var plaintext = PB.Crypto.decryptWithAES(ciphertext, key)
    return plaintext // .replace(/\n+$/g, '')
}


PB.Crypto.random = function() { // just like Math.random, but better
    // via http://stackoverflow.com/questions/13694626/generating-random-numbers-0-to-1-with-crypto-generatevalues

    var list = PB.Crypto.getRandomValues(2, 32)

    // keep all 32 bits of the the first, top 20 of the second for 52 random bits
    var mantissa = (list[0] * Math.pow(2,20)) + (list[1] >> 12)

    // shift all 52 bits to the right of the decimal point
    var result = mantissa * Math.pow(2,-52)
    
    return result
    
    // var log2 = Math.log(max) / Math.LN2
    // var size = Math.ceil(log2) + 1 // NOTE: this is about 8 times higher than necessary
}

PB.Crypto.getRandomInteger = function(max, min) { // NOTE: min is inclusive, max is exclusive
    // TODO: error if max and min are not proper (non-NaN) numbers
    min = Math.floor(min || 0)
    max = Math.floor(max || 0x7fffffff) // 0x7fffffff == Math.pow(2, 31) - 1 // the largest bitop safe int
    var range = max - min
    var randFloat = PB.Crypto.random()
    return Math.floor(randFloat*range + min)
}

PB.Crypto.getRandomItem = function(list) {
    // TODO: error if list is not an array or string
    var index = PB.Crypto.getRandomInteger(list.length)
    return list[index]
}

/**
 * Get a new AES key
 * @param  {number} len Length in bytes (defaults to 256 bits)
 * @return {string} AES key
 */
PB.Crypto.getRandomKey = function(len) {
    len = len || 256/8                                      // AES key size is 256 bits
    var bytes = PB.Crypto.getRandomValues(len, 8)
    // var bytes = new Uint8Array(size)
    // crypto.getRandomValues(bytes)
    return Bitcoin.convert.bytesToBase64(bytes)
}

PB.Crypto.getRandomValues = function(number, size) {
    if(window.crypto && window.crypto.getRandomValues) {
        var bytes
        if(size == 32)
            bytes = new Uint32Array(size)
        else
            bytes = new Uint8Array(size)
    
        return window.crypto.getRandomValues(bytes)
    }

    return PB.Crypto.getRandomValuesShim(number, size)
}

PB.Crypto.getRandomValuesShim = function(number, size) {
    // via https://github.com/evanvosberg/crypto-js/issues/7
    // fallback for old browsers that don't support crypto.getRandomValues
    // better than plain Math.random(), worse than crypto.getRandomValues()
    var words = [];

    var r = (function (m_w) {
        var m_w = m_w;
        var m_z = 0x3ade68b1;
        var mask = 0xffffffff;

        return function () {
            m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
            m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
            var result = ((m_z << 0x10) + m_w) & mask;
            result /= 0x100000000;
            result += 0.5;
            return result * (Math.random() > .5 ? 1 : -1);
        }
    });

    for (var i = 0, rcache; i < number; i += 4) {
        var _r = r((rcache || Math.random()) * 0x100000000);

        rcache = _r() * 0x3ade67b7;

        if(size == 32) {
            words.push(Math.abs( (_r() * 0x100000000) | 0 ));
        } else {
            // in case we want bytes instead of 32-bit chunks
            var int32 = (_r() * 0x100000000) | 0;
            words.push(Math.abs(int32 & 0xFF000000) >> 24);
            words.push(Math.abs(int32 & 0x00FF0000) >> 16);
            words.push(Math.abs(int32 & 0x0000FF00) >> 8);
            words.push(Math.abs(int32 & 0x000000FF));
        }
    }

    return words;
}


/**
 * to create key pairs
 * @param  {string} puffkey
 * @param  {string} myPrivateWif
 * @param  {object} userRecords
 * @return {object}
 */
PB.Crypto.createKeyPairs = function(puffkey, myPrivateWif, userRecords) {
    if(!Array.isArray(userRecords))
        return PB.throwError('Invalid userRecords')
    
    return userRecords.reduce(function(acc, userRecord) {
        var versionedUsername = PB.Users.userRecordToVersionedUsername(userRecord)
        acc[versionedUsername] = PB.Crypto.encryptPrivateMessage(puffkey, userRecord.defaultKey, myPrivateWif)
        return acc
    }, {})
}


// PB.Crypto.verifyBlock = function(block, publicKeyBase58) {
//     return PB.Crypto.verifyMessage(block.blockPayload, block.blockSig.replace(/\*/g, ""), publicKeyBase58);
// }

// PB.Crypto.signBlock = function(blockPayload, privateKeyWIF) {
//     return PB.Crypto.signPayload(blockPayload, privateKeyWIF);
// }

/*

    Persistence layer for the EveryBit platform.

    It's like a network on your hard drive... which means this could be part of PB.Net.

    Copyright 2014 EveryBit. See README for license information.

 */

PB.Persist = {};
PB.Persist.todo = {}
PB.Persist.todoflag = false

/**
 * to save key/value
 * @param  {string} key
 * @param  {string} value
 */
PB.Persist.save = function(key, value) {
    if(value == null)
        value = false
    PB.Persist.todo[key] = value
    if(!PB.Persist.todoflag) {
        onceInAwhile(function() {
            for(var key in PB.Persist.todo) {
                var realkey = 'PUFF::' + key;                           // prepend PUFF:: so we're good neighbors
                var value = PB.Persist.todo[key];
                if(typeof value == 'function')                          // in case we're passed a thunk
                    value = value();
                var str = JSON.stringify(value);                
                localStorage.setItem(realkey, str);
            }
            PB.Persist.todo = {};
            PB.Persist.todoflag = false;
        }, 100);                                                        // call at most every 100ms
    }
    PB.Persist.todoflag = true
}

/**
 * get the parsed JSON info from the given key
 * @param  {string} key
 * @return {anything}
 */
PB.Persist.get = function(key) {
    // TODO: return empty string instead of false

    var realkey = 'PUFF::' + key;
    var str = localStorage.getItem(realkey);
    if(!str) return false;
    return PB.parseJSON(str);
}

/**
 * to remove the item according to the given key
 * @param  {string} key
 */
PB.Persist.remove = function(key) {
    var realkey = 'PUFF::' + key;
    localStorage.removeItem(realkey);
}

/*
    Comprehensive (in progress!), canonical set of functions defining and validating a puff.

    All of these are STRICTLY FORMAL validations: they don't depend on the state of the universe.

    Copyright 2014 EveryBit. See README for license information.

 */


PB.Spec = {}


/**
 * Validate the username
 * @param  {string} username
 */
PB.Spec.isValidUsername = function(username) {
    /*
    RULES:
    - Minimum length is 1
    - Maximum length of full username (including subusers and .) is 255 characters
    - Only alphanumeric
    - Only lowercase
    - Cannot begin or end with a .
     */

    PB.Spec.isValidUsername.rulesStatement = 'Usernames can only contain lowercase letters, numbers, and periods. They cannot ' +
        'be longer than 255 characters, or begin or end with a period.'

    if(!username)
        return false

    if(username.length > 255)
        return false

    if(!username.match(/^[a-z0-9.]+$/))
        return false

    if(username.slice(0, 1) == '.')
        return false

    if(username.slice(-1) == '.')
        return false

    return true
}


/**
 * Does everything possible to make a username valid
 * Note: This may have unintended consequences for the user
 */
PB.Spec.sanitizeUsername = function(username) {
    /*
     TRANSFORMATIONS:
     - Remove leading and trailing space
     - Convert to lowercase
     - Remove all illegal characters, including leading and trailing .
     */
    username = username.trim()

    username = username.toLowerCase()

    if(username.slice(0, 1) == '.')
        username = username.slice(1)

    if(username.slice(-1) == '.')
        username = username.slice(0,-1)

    username = username.replace(/[^a-z0-9.]+/g, '')

    return username
}


/**
 * check if it is a valid public key
 * @param {string} publicKey
 * @returns {boolean}
 */
PB.Spec.isValidPublicKey = function(publicKey) {
    // TODO: do "checksum" validation

    if(!isset(publicKey)) {
        return false;
    } else {
        return true;
    }

}

/**
 * check if it is a valid private key
 * @param {string} privateKey
 * @returns {boolean}
 */
PB.Spec.isValidPrivateKey = function(privateKey) {
    // TODO: Validate by testing if can be converted to public key

    if(!isset(privateKey)) {
        return false;
    } else {
        return true;
    }
}

/**
 * Check if this is a valid capa
 * @param capa
 * @returns {boolean}
 */
PB.Spec.isValidCapa = function(capa) {

    /*
     RULES:
     - Must be a natural number (1 or greater)
     */

    PB.Spec.isValidCapa.rulesStatement = 'capa must be a natural number.';


    capa = capa.toString(); // Convert to string
    var n1 = Math.abs(n);
    var n2 = parseInt(n, 10);

    if(n2 < 1)
        return false

    return !isNaN(n1) && n2 === n1 && n1.toString() === n;
}
/* 
                   _____  _____  _____                           
    ______  __ ___/ ____\/ ____\/ ____\___________ __ __  _____  
    \____ \|  |  \   __\\   __\\   __\/  _ \_  __ \  |  \/     \ 
    |  |_> >  |  /|  |   |  |   |  | (  <_> )  | \/  |  /  Y Y  \
    |   __/|____/ |__|   |__|   |__|  \____/|__|  |____/|__|_|  /
    |__|                                                      \/ 
  
  
  A Puffball module for managing forum-style puffs. Wraps the core Puffball API in a fluffy layer of syntactic spun sugar.

  Usage example:
  PB.M.Forum.init()
  ...

*/

PB.M.Forum = {};

PB.M.Forum.contentTypes = {}


/**
 * Bootstrap the forum module
 */
PB.M.Forum.init = function() {
    PB.addRelationshipHandler(PB.M.Forum.addFamilialEdges)              // manages parent-child relationships
    PB.addBeforeSwitchIdentityHandler(PB.M.Forum.clearPuffContentStash)    // clear private caches 
    PB.addPayloadModifierHandler(PB.M.Forum.addTimestamp)               // add timestamp to all new puffs
}


/**
 * Inject a timestamp into the payload
 * the "time" field is optional for puffs, but mandatory for "forum style" puffs
 *
 * @param {Object} payload
 * @returns {Object|{}}
 */
PB.M.Forum.addTimestamp = function(payload) {
    payload = payload || {}
    payload.time = Date.now()
    return payload
}


/**
 * Filter puffs by prop filters
 * @param  {string} filters
 * @return {boolean}
 */
PB.M.Forum.filterByFilters = function(filters) {

    if(!filters) return function() {return true}
    
    //// get a filtering function
    return function(shell) {

        // ROUTES
        if (filters.routes && filters.routes.length > 0) {
            var routeMatch = false;
            for (var i = 0; i < filters.routes.length; i++) {
                if (shell.routes.indexOf(filters.routes[i]) > -1) routeMatch = true;
            }
            if (!routeMatch) return false;
        }

        // TAGS
        if (filters.tags && filters.tags.length > 0) {
            if (!shell.payload.tags || !shell.payload.tags.length) {
                return false;
            }
            var tagMatch = false;
            for (var i = 0; i < filters.tags.length; i++) {
                if (shell.payload.tags.indexOf(filters.tags[i]) > -1) tagMatch = true;
            }
            if (!tagMatch) return false;
        }

        // TYPES
        if (filters.types && filters.types.length > 0) {
            if (!~filters.types.indexOf(shell.payload.type)) {
                // console.log(shell.type)
                return false
            }
        }

        // USERS
        if(filters.users && filters.users.length > 0)
            if(!~filters.users.indexOf(PB.Users.justUsername(shell.username))) return false


        if(filters.roots)
            if((shell.payload.parents||[]).length) return false

        if(filters.ancestors && filters.focus) {
            var focus = PB.getPuffBySig(filters.focus) // TODO: find better way to do this
            if(focus.payload && !~focus.payload.parents.indexOf(shell.sig)) return false
        }

        if(filters.descendants && filters.focus)
            if(!~shell.payload.parents.indexOf(filters.focus)) return false

        // TODO: deprecate this, as it's handled above:
        if (filters.type && filters.type.length)
            if (!~filters.type.indexOf(shell.payload.type)) return false

        return true
    }
}



/**
 * Helper for sorting by payload.time
 * @param  {Object} a
 * @param  {object} b
 * @return {number} based on desired sorting order
 */
PB.M.Forum.sortByPayload = function(a,b) {
    //// helper for sorting by payload.time
    if(puffworldprops.view.query.sort == 'DESC')
        return b.payload.time - a.payload.time;
    else
        return a.payload.time - b.payload.time;
}



/**
 * Get the current puff's parents
 * @param  {Object} puff
 * @param  {Object} props
 * @return {number} The number of parents
 */
PB.M.Forum.getParentCount = function(puff, props) {
    if(!puff) return 0
    
    var sig = puff.sig || puff
    
    return PB.Data.graph.v(sig).out('parent').run().length
}


/**
 * Get a count of the current puff's children
 * @param  {Object} puff
 * @return {number} The number of children
 */
PB.M.Forum.getChildCount = function(puff) {
    if(!puff) return 0
    
    var sig = puff.sig || puff
    
    return PB.Data.graph.v(sig).out('child').run().length
}


/**
 * Filter puffs according to criteria
 * @param  {string} query
 * @param  {string} filters
 * @param  {number} limit
 * @return {array} An array of puffs
 */
PB.M.Forum.getPuffList = function(query, filters, limit) {
    //// returns a list of puffs

    // THINK: the graph can help us here, but only if we're more clever about forming relationships and using those in our filters.

    limit = limit || Infinity
    var offset = +query.offset||0

    // var shells = PB.M.Forum.getShells(query, filters)
    var shells = PB.Data.getAllMyShells()
    
    var filtered_shells = shells.filter(PB.M.Forum.filterByFilters(Boron.extend({}, query, filters)))
                                .sort(PB.M.Forum.sortByPayload) // TODO: sort by query

    var sliced_shells = filtered_shells.slice(offset, offset+limit)
    
    var puffs = sliced_shells.map(PB.Data.getPuffFromShell)
                             .filter(Boolean)

    var have = sliced_shells.length
    // var have = puffs.length
    if(have >= limit)
        return puffs  // as long as we have enough filtered shells the puffs will eventually fill in empty spots

    PB.Data.fillSomeSlotsPlease(limit, have, query, filters)
    
    return puffs;
}


/**
 * Takes a string of content, create a puff and push it into the system
 * @param {string} type
 * @param {string} content
 * @param {array} parents
 * @param {Object} metadata
 * @param {string[]} userRecordsForWhomToEncrypt
 * @param {string[]} privateEnvelopeAlias
 * @returns {promise}
 */
PB.M.Forum.addPost = function(type, content, parents, metadata, userRecordsForWhomToEncrypt, privateEnvelopeAlias) {
    //// Given a string of content, create a puff and push it into the system
    
    // ensure parents is an array
    if(!parents) parents = []
    if(!Array.isArray(parents)) parents = [parents]
    
    // ensure parents contains only puff ids
    if(parents.map(PB.getPuffBySig).filter(function(x) { return x != null }).length != parents.length)
        return PB.emptyPromise('Those are not good parents')
    
    // ensure parents are unique
    parents = PB.uniquify(parents)

    // find the routes using parents
    var routes = parents.map(function(id) {
        return PB.getPuffBySig(id).username
    });
    if (metadata.routes) {
        routes = metadata.routes // THINK: this should probably merge with above instead of replacing it...
        delete metadata['routes']
    }
    
    // ensure all routes are unique
    routes = PB.uniquify(routes)
    
    var takeUserMakePuff = PB.M.Forum.partiallyApplyPuffMaker(type, content, parents, metadata, routes, userRecordsForWhomToEncrypt, privateEnvelopeAlias)
    
    // get a user promise
    var userprom = PB.Users.getUpToDateUserAtAnyCost()
    
    var prom = userprom.catch(PB.catchError('Failed to add post: could not access or create a valid user'))
                       .then(takeUserMakePuff)
                       .catch(PB.catchError('Posting failed'))
    
    return prom
    
    // NOTE: any puff that has 'time' and 'parents' fields fulfills the forum interface
    // TODO: make an official interface fulfillment thing
}


/**
 * Make a puff... except the parts that require a user
 * @param {string} type
 * @param {string} content
 * @param {array} parents
 * @param {object} metadata
 * @param {array} routes
 * @param {array} userRecordsForWhomToEncrypt
 * @param {array} privateEnvelopeAlias
 * @returns {Function}
 */
PB.M.Forum.partiallyApplyPuffMaker = function(type, content, parents, metadata, routes, userRecordsForWhomToEncrypt, privateEnvelopeAlias) {
    //// Make a puff... except the parts that require a user
    
    // THINK: if you use the same metadata object for multiple puffs your cached version of the older puffs will get messed up
    
    var payload = metadata || {}                            // metadata becomes the basis of payload
    payload.parents = payload.parents || parents            // ids of the parent puffs
    payload.time = metadata.time || Date.now()              // time is always a unix timestamp
    payload.tags = metadata.tags || []                      // an array of tags // TODO: make these work

    var type  = type || 'text'
    var routes = routes ? routes : [];
    routes = routes.concat(PB.CONFIG.zone);
    
    return function(userRecord) {
        // userRecord is always an up-to-date record from the DHT, so we can use its 'latest' value here 

        var previous = userRecord.latest
        var puff = PB.simpleBuildPuff(type, content, payload, routes, userRecordsForWhomToEncrypt, privateEnvelopeAlias)

        return PB.addPuffToSystem(puff) // THINK: this fails silently if the sig exists already
    }
}

/// graph relationships ///

PB.M.Forum.addFamilialEdges = function(shells) {
    shells.forEach(PB.M.Forum.addFamilialEdgesForShell)
}

PB.M.Forum.addFamilialEdgesForShell = function(child) {
    var addParentEdges = PB.M.Forum.addFamilialEdgesForParent(child);
    (child.payload.parents||[]).forEach(addParentEdges);
}

PB.M.Forum.addFamilialEdgesForParent = function(child) {
    var existingParents = PB.Data.graph.v(child.sig).out('parent').property('shell').run().map(PB.prop('sig'))
    
    return function(parentSig) {
        if(~existingParents.indexOf(parentSig)) return false                       // done?
        PB.Data.addSigAsVertex(parentSig)                                          // idempotent
        PB.Data.graph.addEdge({_label: 'parent', _in: parentSig, _out: child.sig}) // not idempotent
        PB.Data.graph.addEdge({_label: 'child', _out: parentSig,  _in: child.sig})
    }
}

/// end graph relationships ///


/**
 * to process the content
 * @param  {string} type
 * @param  {string} content
 * @param  {puff} puff
 * @return {string}
 */
PB.M.Forum.processContent = function(type, content, puff) {
    var typeObj = PB.M.Forum.contentTypes[type]
    
    if(!typeObj)
        typeObj = PB.M.Forum.contentTypes['text']

    return typeObj.toHtml(content, puff)
}


// TODO: this might get big, need some GC here
PB.M.Forum.puffContentStash = {}

PB.M.Forum.clearPuffContentStash = function() {
    PB.M.Forum.puffContentStash = {}
}

/**
 * Get the content of a puff
 * @param  {puff} puff
 * @return {string}
 */
PB.M.Forum.getProcessedPuffContent = function(puff) {
    // THINK: we've already ensured these are proper puffs, so we don't have to check for payload... right?
    if(PB.M.Forum.puffContentStash[puff.sig])
        return PB.M.Forum.puffContentStash[puff.sig]
    
    var content = PB.M.Forum.processContent(puff.payload.type, puff.payload.content, puff)
    PB.M.Forum.puffContentStash[puff.sig] = content
    
    return content
}

/**
 * Add support for types of content to the system
 * @param {string} name
 * @param {string} type
 */
PB.M.Forum.addContentType = function(name, type) {
    // THINK: move this down into PB?
    
    if(!name) 
        return PB.onError('Invalid content type name')
    if(PB.CONFIG.supportedContentTypes && PB.CONFIG.supportedContentTypes.indexOf(name) == -1)
        return PB.onError('Unsupported content type: ' + name)
    if(!type.toHtml) 
        return PB.onError('Invalid content type: object is missing toHtml method', name)
    
    PB.M.Forum.contentTypes[name] = type
}


// DEFAULT CONTENT TYPES

PB.M.Forum.addContentType('text', {
    toHtml: function(content) {
        var safe_content = XBBCODE.process({ text: content })   // not ideal, but it does seem to strip out raw html
        safe_content.html = safe_content.html.replace(/\n/g, '</br>');  // Set line breaks
        return '<span>' + safe_content.html + '</span>'
    }
})

PB.M.Forum.addContentType('bbcode', {
    toHtml: function(content) {
        var bbcodeParse = XBBCODE.process({ text: content });
        var parsedText  = bbcodeParse.html.replace(/\n/g, '<br />'); 
        return parsedText;
    }
})

PB.M.Forum.addContentType('image', {
    toHtml: function(content) {
        if(puffworldprops.view.mode == "tableView")
            return '<img src=' + content + ' />';
        else
            return '<img class="imgInBox" src=' + content + ' />';
    }
})

PB.M.Forum.addContentType('markdown', {
    toHtml: function(content) {
        var converter = new Markdown.Converter();
        return '<span>'+converter.makeHtml(content)+'</span>';
    }
})

// Used to display chess boards
PB.M.Forum.addContentType('PGN', {
    toHtml: function(content) {
        return chessBoard(content);
    }
})

PB.M.Forum.addContentType('identity', {
    toHtml: function() {
        return ''
    }
})

PB.M.Forum.addContentType('profile', {
    toHtml: function(content, puff) {
        if(puffworldprops.view.mode == "tableView")
            return '<img src=' + content + ' />';
        else
            return '<img class="imgInBox" src=' + content + ' />';
        /*var keysNotShow = ['content', 'type'];
        for (var key in puff.payload) {
            var value = puff.payload[key];
            if (keysNotShow.indexOf(key)==-1 && value && value.length) {
                toRet += '<div><span class="profileKey">' + key + ': </span><span class="profileValue">' + value + '</span></div>';
            }
        }*/
    }
})

PB.M.Forum.addContentType('file', {
    toHtml: function(content, puff) {
        return (
            puff.payload.filename
            )
    }

})

// TODO: Add support for LaTex
/*PB.M.Forum.addContentType('LaTex', {
    toHtml: function(content) {
        var safe_content = XBBCODE.process({ text: content }) 
        return '<p>' + safe_content.html + '</p>'
    }
}) */


// Flag a puff
PB.M.Forum.flagPuff = function (sig) {

    var payload = {};
    var routes = [];
    var type = 'flagPuff';
    var content = sig;
    
    payload.time = Date.now();

    PB.useSecureInfo(function(identities, currentUsername, privateRootKey, privateAdminKey, privateDefaultKey) {    

        if(!currentUsername) {
            alert("You must first set your username before you can flag content");
            return false;
        }
        /*if(!currentUsername == PB.getPuffBySig(sig).username) {
            alert("You must set your identity to the author of the puff you want to flag");
        }*/
        if(!privateAdminKey) {
            alert("You must first set your private admin key before you can flag content");
            return false;
        }
    
        var puff = PB.buildPuff(currentUsername, privateAdminKey, routes, type, content, payload);
    })

    var data = { type: 'flagPuff'
               , puff: puff
               };

    var prom = PB.Net.PBpost(PB.CONFIG.puffApi, data);
    
    prom = prom.then(function(result){
        // var storedShells = PB.Persist.get('shells');
        // var filteredShells = storedShells.filter(function(s){return s.sig != content && s.content != content});
        var flaggedSig = PB.Persist.get('flagged') || [];
        flaggedSig.push(content);

        // PB.Persist.save('shells', filteredShells);
        PB.Persist.save('flagged', flaggedSig);
        // reload?
        // document.location.reload();
        Events.pub('ui/flag', {});
        return result;
    })
    return prom;
}


// Adding default metafields to included in a puff
PB.M.Forum.metaFields = []
PB.M.Forum.context = {};
PB.M.Forum.addMetaFields = function(fieldInfo, context, excludeContext) {
    // NOTE: this isn't used outside of publishEmbed.js, but it might provide a good basis for generic/required metadata
    
    if (!fieldInfo.name) return console.log('Invalid meta field name.');

    // supported type: text, textarea, pulldown, array
    if (!fieldInfo.type) return console.log('Invalid meta field type.');

    if (!fieldInfo.validator || typeof fieldInfo.validator != 'function') {
        fieldInfo.validator = false;
    }

    context = context || Object.keys(PB.M.Forum.contentTypes);
    if (typeof context == 'string') {
        context = [context];
    } else if (!Array.isArray(context)) {
        return PB.onError('Invalid context.')
    }

    excludeContext = excludeContext || [];
    if (typeof excludeContext == 'string') {
        excludeContext = [excludeContext];
    }else if (!Array.isArray(excludeContext)) {
        return PB.onError('Invalid context.')
    }

    PB.M.Forum.metaFields.push(fieldInfo);
    for (var i=0; i<context.length; i++) {
        if (excludeContext.indexOf(context[i]) != -1)
            continue;
        var contextFields = PB.M.Forum.context[context[i]] || [];
        contextFields.push(fieldInfo.name);
        PB.M.Forum.context[context[i]] = contextFields;
    }
}

PB.M.Forum.addMetaFields(
    {name: 'reply privacy',
     type: 'pulldown',
     enum: ['', 'public', 'private', 'anonymous', 'invisible'],
     defaultValue: ''});

PB.M.Forum.addMetaFields(
    {name: 'content license',
     type: 'pulldown',
     enum: ['', 'CreativeCommonsAttribution', 'GNUPublicLicense', 'Publicdomain', 'Rights-managed', 'Royalty-free'],
     defaultValue: ''});

PB.M.Forum.addMetaFields(
    {name: 'tags',
     type: 'array',
     validator: function(v){return /^[a-z0-9]+$/i.test(v)}
     },
    false, 'profile');

PB.M.Forum.addMetaFields(
    {name: 'language',
     type: 'text',
     defaultValue: function(){return puffworldprops.view.language}});

PB.M.Forum.addMetaFields(
    {name: 'name',
     type: 'text'},
    'profile');
/* 
                   _____  _____                          .___            ___.           
    ______  __ ___/ ____\/ ____\_  _  _______ _______  __| _/______  ____\_ |__   ____  
    \____ \|  |  \   __\\   __\\ \/ \/ /\__  \\_  __ \/ __ |\_  __ \/  _ \| __ \_/ __ \ 
    |  |_> >  |  /|  |   |  |   \     /  / __ \|  | \/ /_/ | |  | \(  <_> ) \_\ \  ___/ 
    |   __/|____/ |__|   |__|    \/\_/  (____  /__|  \____ | |__|   \____/|___  /\___  >
    |__|                                     \/           \/                  \/     \/ 
  
  A Puffball module for managing identities and private data locally.
  ==================================================

  The Wardrobe manages identities, aliases, and private data.

  An identity is a username and a list of all known aliases. The identity also lists the last known primary alias, if there is one, and the identity's private preferences. 

  An alias is a username, a 'capa', and a set of private keys. Additional private information (like a passphrase) may be stored in the alias's 'secrets' field.

  Aliases generally correspond either to previous versions of the identity's username (previous primaries), or to anonymous usernames created for one-time encrypted transfer. 

  Username and capa define a unique alias. The capa field references a specific moment in the username's lifecycle, and correlates to the userRecord with the same username and capa whose public keys match the alias's private keys. In other words, capa == version.

  Currently capa counts by consecutive integers. This may change in the future. Any set deriving Eq and Ord will work.

  An identity file can be exported to the local filesystem and imported back in to the system.

  Private data is a black box for 

  Usage examples:
      PB.switchIdentityTo(username)

*/

/*
  THINK:
    - register callback handlers for user record creation and modification
    - PB.M.Wardrobe.init registers those with PB.onUserCreation and PB.onUserModification
    - identity file encryption using a passphrase
*/


PB.M.Wardrobe = {}

~function() { // begin the closure

    var identities = {}
    var aliases = {}
    // {asdf: { username: 'asdf', primary: asdf-12, aliases: [asdf-11, asdf-10], preferences: {} } }

    // an alias: { username: 'asdf', capa: 12, privateRootKey: '123', privateAdminKey: '333', privateDefaultKey: '444', secrets: {} }

    var currentUsername = false


    // TODO: integrate capa with userRecords and puffs everywhere
    // TODO: use capa returned from server on update passphrase
    // TODO: get anon creation working


    PB.M.Wardrobe.init = init
    
    function init() {
        PB.implementSecureInterface(useSecureInfo, addIdentity, addAlias, setPrimaryAlias, setPreference, switchIdentityTo, removeIdentity)
        
        PB.addIdentityUpdateHandler(function() { // THINK: where should this live?
            if(!PB.CONFIG.disableCloudIdentity)
                PB.storeIdentityFileInCloud()
        })
        
        // TODO: find a better way to do this
        var oldConfigValue = PB.CONFIG.disableCloudIdentity
        PB.CONFIG.disableCloudIdentity = true
        
        var storedIdentities = PB.Persist.get('identities') || {}
    
        Object.keys(storedIdentities).forEach(function(username) {
            var identity = storedIdentities[username]
            addIdentity(username, identity.aliases, identity.preferences, true)
        })
        
        PB.CONFIG.disableCloudIdentity = oldConfigValue
        
        var lastUsername = PB.Persist.get('currentUsername')
        
        if (lastUsername)
            PB.switchIdentityTo(lastUsername) // NOTE: call wrapped version to get handlers
    }
    
    
    //// exported via implementSecureInterface

    var useSecureInfo = function(callback) {
        var identity = getCurrentIdentity() || {}
        var primary = identity.primary || {}

        // we have to return all the identities because the user might be trying to list them
        callback(identities, currentUsername, primary.privateRootKey, primary.privateAdminKey, primary.privateDefaultKey)
        
        return true
    }

    var addIdentity = function(username, aliases, preferences, nosave) { // TODO: check if nosave is needed
        // TODO: validation on all available values
        // TODO: check for existing identity
        // TODO: add any unknown aliases
        // THINK: what about aliases that belong to other identities?
        // THINK: ensure primary alias exists?
        // TODO: remove primary (use username+maxcapa instead)

        var identity = { username: username
                       , primary: {}
                       , aliases: []
                       , preferences: preferences || {}
                       }

        identities[username] = identity
        
        if(!Array.isArray(aliases))
            aliases = aliases ? [aliases] : []
        
        aliases.forEach(
            function(alias) {
                addAlias(username, alias.username, alias.capa, alias.privateRootKey, alias.privateAdminKey, alias.privateDefaultKey, alias.secrets)})
        
        // TODO: handle prefs
        
        if(!nosave) // TODO: change processUpdates so it only saves if we're not busy opening all identities? or just let the 100ms throttle handle it...
            processUpdates()
            
        return true
    }

    var addAlias = function(identityUsername, aliasUsername, capa, privateRootKey, privateAdminKey, privateDefaultKey, secrets) {
        // TODO: validation on all available values
        // TODO: check for existing username/capa
        // THINK: hit network for confirmation?
        // THINK: maybe only include viable values?

        var alias = { username: aliasUsername
                    , capa: capa || 1 // NOTE: default capa
                    , privateRootKey: privateRootKey || false
                    , privateAdminKey: privateAdminKey || false
                    , privateDefaultKey: privateDefaultKey || false
                    , secrets: secrets || {}
                    }

        var identity = getIdentity(identityUsername)
        
        if(!identity) {
            addIdentity(identityUsername)                   // creates an empty identity
            identity = getIdentity(identityUsername)
        }
        
        // merge alias
        var old_alias = getOldAlias(identity, alias)
        if(old_alias) {
            alias.secrets = Boron.extend(old_alias.secrets, alias.secrets)
            for(var key in alias) 
                if(alias[key])
                    old_alias[key] = alias[key]
        } else {
            identity.aliases.push(alias)
        }
        
        if(aliasUsername == identityUsername && alias.capa >= (identity.capa||0)) {
            identity.primary = alias                        // set primary for identity (which may have been empty)
        }
        
        aliases[aliasUsername] = identity                   // add this to the alias-identity mapping

        processUpdates()

        return true
    }

    var setPrimaryAlias = function(identityUsername, aliasUsername) {
        var identity = getIdentity(identityUsername)
        
        if(!identity)
            return PB.onError('Primary alias can only be set for known identities')
            
        var alias = getLatestAlias(identity, aliasUsername)
        
        if(!alias)
            return PB.onError('That alias is not associated with that identity')
    
        // all clear!
        
        identity.username = aliasUsername
        identity.primary = alias

        delete identities[identityUsername]
        identities[aliasUsername] = identity
        
        if(identityUsername == currentUsername)
            switchIdentityTo(aliasUsername)
        
        return true
    }
     
    var setPreference = function(key, value) {
        // NOTE: this only works for the current identity
        var identity = getCurrentIdentity()
    
        if(!identity)
            return PB.onError('Preferences can only be set for an active identity')
    
        identity.preferences[key] = value

        processUpdates()
    }
    
    var switchIdentityTo = function(username) {
        if(username) {
            var identity = getIdentity(username)

            if(!identity)
                return PB.onError('No identity found with username "' + username + '"')
        }
        
        currentUsername = username || false

        if(!PB.currentIdentityHash) // THINK: what are the cases?
            PB.currentIdentityHash = PB.Crypto.createMessageHash(JSON.stringify(PB.formatIdentityFile()))
        
        processUpdates()
        
        if(username && identity && identity.primary)
            PB.Users.getUserRecordPromise(username, identity.primary.capa) // fetch our userRecord 

        return true
    }
    
    var removeIdentity = function(username) {
        var identity = getIdentity(username)

        if(!identity)
            return PB.onError('Could not find that identity for removal')

        delete identities[username]

        if(currentUsername == username)
            currentUsername = false

        processUpdates()
    }

    ////
    //// internal helper functions. not exported.
    ////

    function getLatestAlias(identity, aliasUsername) {
        var maxcapa = 0
        var alias = false
        
        for(var i=0, l=identity.aliases.length; i<l; i++) {
            var test = identity.aliases[i]
            if(test.username == aliasUsername && test.capa > maxcapa) {
                alias = test
                maxcapa = test.capa
            }
        }
        
        return alias
    }

    function getOldAlias(identity, alias) {
        for(var i=0, l=identity.aliases.length; i<l; i++) {
            var test = identity.aliases[i]
            if(alias.username == test.username && alias.capa == test.capa)
                return test
        }
    }

    function validatePrivateKeys(username, capa, privateRootKey, privateAdminKey, privateDefaultKey) {
        // CURRENTLY UNUSED
        //// Ensure keys match the userRecord
    
        var prom = PB.Users.getUserRecordPromise(username, capa)
    
        return prom
            .then(function(userRecord) {
                // validate any provided private keys against the userRecord's public keys
                if(   privateRootKey && PB.Crypto.privateToPublic(privateRootKey) != userRecord.rootKey)
                    PB.throwError('That private root key does not match the public root key on record')
                if(  privateAdminKey && PB.Crypto.privateToPublic(privateAdminKey) != userRecord.adminKey)
                    PB.throwError('That private admin key does not match the public admin key on record')
                if(privateDefaultKey && PB.Crypto.privateToPublic(privateDefaultKey) != userRecord.defaultKey)
                    PB.throwError('That private default key does not match the public default key on record')
        
                return userRecord
            }
            , PB.catchError('Could not store private keys due to faulty user record'))
    }

    function processUpdates() {
        if(!PB.CONFIG.ephemeralKeychain)
            PB.Persist.save('identities', identities)

        // THINK: consider zipping identities in localStorage to prevent shoulder-surfing and save space (same for puffs)
        // THINK: consider passphrase protecting identities and private puffs in localStorage
        // TODO: don't persist primary -- regenerate it at load time, so we don't duplicate the alias
        PB.Persist.save('currentUsername', currentUsername)

        PB.runHandlers('identityUpdate')
    }

    function getCurrentIdentity() {
        return getIdentity(currentUsername)
    }

    function getIdentity(username) {
        if(!username) 
            return false

        var identity = identities[username]

        // THINK: we could check the aliases map here in case the username isn't primary

        if(!identity) 
            return false

        return identity
    }

}() // end the closure
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImJpdGNvaW5qcy1taW4uanMiLCJwZWVyLmpzIiwicHJvbWlzZS5taW4uanMiLCJ4YmJjb2RlLmpzIiwiYm9yb24uanMiLCJmaWxlc3R1ZmYuanMiLCJldmVudHMuanMiLCJncmlkYm94LmpzIiwiZGFnb2JhLmpzIiwiUEIuanMiLCJQQi5OZXQuanMiLCJQQi5EYXRhLmpzIiwiUEIuVXNlcnMuanMiLCJQQi5DcnlwdG8uanMiLCJQQi5QZXJzaXN0LmpzIiwiUEIuU3BlYy5qcyIsIlBCLk0uRm9ydW0uanMiLCJQQi5NLldhcmRyb2JlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzbUZBO0FBQ0E7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2prQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeGtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImV2ZXJ5Yml0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYuQml0Y29pbj1lKCl9fShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIHV0aWw9X2RlcmVxXyhcInV0aWwvXCIpO3ZhciBwU2xpY2U9QXJyYXkucHJvdG90eXBlLnNsaWNlO3ZhciBoYXNPd249T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTt2YXIgYXNzZXJ0PW1vZHVsZS5leHBvcnRzPW9rO2Fzc2VydC5Bc3NlcnRpb25FcnJvcj1mdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKXt0aGlzLm5hbWU9XCJBc3NlcnRpb25FcnJvclwiO3RoaXMuYWN0dWFsPW9wdGlvbnMuYWN0dWFsO3RoaXMuZXhwZWN0ZWQ9b3B0aW9ucy5leHBlY3RlZDt0aGlzLm9wZXJhdG9yPW9wdGlvbnMub3BlcmF0b3I7aWYob3B0aW9ucy5tZXNzYWdlKXt0aGlzLm1lc3NhZ2U9b3B0aW9ucy5tZXNzYWdlO3RoaXMuZ2VuZXJhdGVkTWVzc2FnZT1mYWxzZX1lbHNle3RoaXMubWVzc2FnZT1nZXRNZXNzYWdlKHRoaXMpO3RoaXMuZ2VuZXJhdGVkTWVzc2FnZT10cnVlfXZhciBzdGFja1N0YXJ0RnVuY3Rpb249b3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb258fGZhaWw7aWYoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2Upe0Vycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsc3RhY2tTdGFydEZ1bmN0aW9uKX1lbHNle3ZhciBlcnI9bmV3IEVycm9yO2lmKGVyci5zdGFjayl7dmFyIG91dD1lcnIuc3RhY2s7dmFyIGZuX25hbWU9c3RhY2tTdGFydEZ1bmN0aW9uLm5hbWU7dmFyIGlkeD1vdXQuaW5kZXhPZihcIlxcblwiK2ZuX25hbWUpO2lmKGlkeD49MCl7dmFyIG5leHRfbGluZT1vdXQuaW5kZXhPZihcIlxcblwiLGlkeCsxKTtvdXQ9b3V0LnN1YnN0cmluZyhuZXh0X2xpbmUrMSl9dGhpcy5zdGFjaz1vdXR9fX07dXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsRXJyb3IpO2Z1bmN0aW9uIHJlcGxhY2VyKGtleSx2YWx1ZSl7aWYodXRpbC5pc1VuZGVmaW5lZCh2YWx1ZSkpe3JldHVyblwiXCIrdmFsdWV9aWYodXRpbC5pc051bWJlcih2YWx1ZSkmJihpc05hTih2YWx1ZSl8fCFpc0Zpbml0ZSh2YWx1ZSkpKXtyZXR1cm4gdmFsdWUudG9TdHJpbmcoKX1pZih1dGlsLmlzRnVuY3Rpb24odmFsdWUpfHx1dGlsLmlzUmVnRXhwKHZhbHVlKSl7cmV0dXJuIHZhbHVlLnRvU3RyaW5nKCl9cmV0dXJuIHZhbHVlfWZ1bmN0aW9uIHRydW5jYXRlKHMsbil7aWYodXRpbC5pc1N0cmluZyhzKSl7cmV0dXJuIHMubGVuZ3RoPG4/czpzLnNsaWNlKDAsbil9ZWxzZXtyZXR1cm4gc319ZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKXtyZXR1cm4gdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5hY3R1YWwscmVwbGFjZXIpLDEyOCkrXCIgXCIrc2VsZi5vcGVyYXRvcitcIiBcIit0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmV4cGVjdGVkLHJlcGxhY2VyKSwxMjgpfWZ1bmN0aW9uIGZhaWwoYWN0dWFsLGV4cGVjdGVkLG1lc3NhZ2Usb3BlcmF0b3Isc3RhY2tTdGFydEZ1bmN0aW9uKXt0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHttZXNzYWdlOm1lc3NhZ2UsYWN0dWFsOmFjdHVhbCxleHBlY3RlZDpleHBlY3RlZCxvcGVyYXRvcjpvcGVyYXRvcixzdGFja1N0YXJ0RnVuY3Rpb246c3RhY2tTdGFydEZ1bmN0aW9ufSl9YXNzZXJ0LmZhaWw9ZmFpbDtmdW5jdGlvbiBvayh2YWx1ZSxtZXNzYWdlKXtpZighdmFsdWUpZmFpbCh2YWx1ZSx0cnVlLG1lc3NhZ2UsXCI9PVwiLGFzc2VydC5vayl9YXNzZXJ0Lm9rPW9rO2Fzc2VydC5lcXVhbD1mdW5jdGlvbiBlcXVhbChhY3R1YWwsZXhwZWN0ZWQsbWVzc2FnZSl7aWYoYWN0dWFsIT1leHBlY3RlZClmYWlsKGFjdHVhbCxleHBlY3RlZCxtZXNzYWdlLFwiPT1cIixhc3NlcnQuZXF1YWwpfTthc3NlcnQubm90RXF1YWw9ZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLGV4cGVjdGVkLG1lc3NhZ2Upe2lmKGFjdHVhbD09ZXhwZWN0ZWQpe2ZhaWwoYWN0dWFsLGV4cGVjdGVkLG1lc3NhZ2UsXCIhPVwiLGFzc2VydC5ub3RFcXVhbCl9fTthc3NlcnQuZGVlcEVxdWFsPWZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsZXhwZWN0ZWQsbWVzc2FnZSl7aWYoIV9kZWVwRXF1YWwoYWN0dWFsLGV4cGVjdGVkKSl7ZmFpbChhY3R1YWwsZXhwZWN0ZWQsbWVzc2FnZSxcImRlZXBFcXVhbFwiLGFzc2VydC5kZWVwRXF1YWwpfX07ZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsZXhwZWN0ZWQpe2lmKGFjdHVhbD09PWV4cGVjdGVkKXtyZXR1cm4gdHJ1ZX1lbHNlIGlmKHV0aWwuaXNCdWZmZXIoYWN0dWFsKSYmdXRpbC5pc0J1ZmZlcihleHBlY3RlZCkpe2lmKGFjdHVhbC5sZW5ndGghPWV4cGVjdGVkLmxlbmd0aClyZXR1cm4gZmFsc2U7Zm9yKHZhciBpPTA7aTxhY3R1YWwubGVuZ3RoO2krKyl7aWYoYWN0dWFsW2ldIT09ZXhwZWN0ZWRbaV0pcmV0dXJuIGZhbHNlfXJldHVybiB0cnVlfWVsc2UgaWYodXRpbC5pc0RhdGUoYWN0dWFsKSYmdXRpbC5pc0RhdGUoZXhwZWN0ZWQpKXtyZXR1cm4gYWN0dWFsLmdldFRpbWUoKT09PWV4cGVjdGVkLmdldFRpbWUoKX1lbHNlIGlmKHV0aWwuaXNSZWdFeHAoYWN0dWFsKSYmdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpe3JldHVybiBhY3R1YWwuc291cmNlPT09ZXhwZWN0ZWQuc291cmNlJiZhY3R1YWwuZ2xvYmFsPT09ZXhwZWN0ZWQuZ2xvYmFsJiZhY3R1YWwubXVsdGlsaW5lPT09ZXhwZWN0ZWQubXVsdGlsaW5lJiZhY3R1YWwubGFzdEluZGV4PT09ZXhwZWN0ZWQubGFzdEluZGV4JiZhY3R1YWwuaWdub3JlQ2FzZT09PWV4cGVjdGVkLmlnbm9yZUNhc2V9ZWxzZSBpZighdXRpbC5pc09iamVjdChhY3R1YWwpJiYhdXRpbC5pc09iamVjdChleHBlY3RlZCkpe3JldHVybiBhY3R1YWw9PWV4cGVjdGVkfWVsc2V7cmV0dXJuIG9iakVxdWl2KGFjdHVhbCxleHBlY3RlZCl9fWZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpPT1cIltvYmplY3QgQXJndW1lbnRzXVwifWZ1bmN0aW9uIG9iakVxdWl2KGEsYil7aWYodXRpbC5pc051bGxPclVuZGVmaW5lZChhKXx8dXRpbC5pc051bGxPclVuZGVmaW5lZChiKSlyZXR1cm4gZmFsc2U7aWYoYS5wcm90b3R5cGUhPT1iLnByb3RvdHlwZSlyZXR1cm4gZmFsc2U7aWYoaXNBcmd1bWVudHMoYSkpe2lmKCFpc0FyZ3VtZW50cyhiKSl7cmV0dXJuIGZhbHNlfWE9cFNsaWNlLmNhbGwoYSk7Yj1wU2xpY2UuY2FsbChiKTtyZXR1cm4gX2RlZXBFcXVhbChhLGIpfXRyeXt2YXIga2E9b2JqZWN0S2V5cyhhKSxrYj1vYmplY3RLZXlzKGIpLGtleSxpfWNhdGNoKGUpe3JldHVybiBmYWxzZX1pZihrYS5sZW5ndGghPWtiLmxlbmd0aClyZXR1cm4gZmFsc2U7a2Euc29ydCgpO2tiLnNvcnQoKTtmb3IoaT1rYS5sZW5ndGgtMTtpPj0wO2ktLSl7aWYoa2FbaV0hPWtiW2ldKXJldHVybiBmYWxzZX1mb3IoaT1rYS5sZW5ndGgtMTtpPj0wO2ktLSl7a2V5PWthW2ldO2lmKCFfZGVlcEVxdWFsKGFba2V5XSxiW2tleV0pKXJldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX1hc3NlcnQubm90RGVlcEVxdWFsPWZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsZXhwZWN0ZWQsbWVzc2FnZSl7aWYoX2RlZXBFcXVhbChhY3R1YWwsZXhwZWN0ZWQpKXtmYWlsKGFjdHVhbCxleHBlY3RlZCxtZXNzYWdlLFwibm90RGVlcEVxdWFsXCIsYXNzZXJ0Lm5vdERlZXBFcXVhbCl9fTthc3NlcnQuc3RyaWN0RXF1YWw9ZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLGV4cGVjdGVkLG1lc3NhZ2Upe2lmKGFjdHVhbCE9PWV4cGVjdGVkKXtmYWlsKGFjdHVhbCxleHBlY3RlZCxtZXNzYWdlLFwiPT09XCIsYXNzZXJ0LnN0cmljdEVxdWFsKX19O2Fzc2VydC5ub3RTdHJpY3RFcXVhbD1mdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsZXhwZWN0ZWQsbWVzc2FnZSl7aWYoYWN0dWFsPT09ZXhwZWN0ZWQpe2ZhaWwoYWN0dWFsLGV4cGVjdGVkLG1lc3NhZ2UsXCIhPT1cIixhc3NlcnQubm90U3RyaWN0RXF1YWwpfX07ZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLGV4cGVjdGVkKXtpZighYWN0dWFsfHwhZXhwZWN0ZWQpe3JldHVybiBmYWxzZX1pZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpPT1cIltvYmplY3QgUmVnRXhwXVwiKXtyZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpfWVsc2UgaWYoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpe3JldHVybiB0cnVlfWVsc2UgaWYoZXhwZWN0ZWQuY2FsbCh7fSxhY3R1YWwpPT09dHJ1ZSl7cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlfWZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csYmxvY2ssZXhwZWN0ZWQsbWVzc2FnZSl7dmFyIGFjdHVhbDtpZih1dGlsLmlzU3RyaW5nKGV4cGVjdGVkKSl7bWVzc2FnZT1leHBlY3RlZDtleHBlY3RlZD1udWxsfXRyeXtibG9jaygpfWNhdGNoKGUpe2FjdHVhbD1lfW1lc3NhZ2U9KGV4cGVjdGVkJiZleHBlY3RlZC5uYW1lP1wiIChcIitleHBlY3RlZC5uYW1lK1wiKS5cIjpcIi5cIikrKG1lc3NhZ2U/XCIgXCIrbWVzc2FnZTpcIi5cIik7aWYoc2hvdWxkVGhyb3cmJiFhY3R1YWwpe2ZhaWwoYWN0dWFsLGV4cGVjdGVkLFwiTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb25cIittZXNzYWdlKX1pZighc2hvdWxkVGhyb3cmJmV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCxleHBlY3RlZCkpe2ZhaWwoYWN0dWFsLGV4cGVjdGVkLFwiR290IHVud2FudGVkIGV4Y2VwdGlvblwiK21lc3NhZ2UpfWlmKHNob3VsZFRocm93JiZhY3R1YWwmJmV4cGVjdGVkJiYhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLGV4cGVjdGVkKXx8IXNob3VsZFRocm93JiZhY3R1YWwpe3Rocm93IGFjdHVhbH19YXNzZXJ0LnRocm93cz1mdW5jdGlvbihibG9jayxlcnJvcixtZXNzYWdlKXtfdGhyb3dzLmFwcGx5KHRoaXMsW3RydWVdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSl9O2Fzc2VydC5kb2VzTm90VGhyb3c9ZnVuY3Rpb24oYmxvY2ssbWVzc2FnZSl7X3Rocm93cy5hcHBseSh0aGlzLFtmYWxzZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKX07YXNzZXJ0LmlmRXJyb3I9ZnVuY3Rpb24oZXJyKXtpZihlcnIpe3Rocm93IGVycn19O3ZhciBvYmplY3RLZXlzPU9iamVjdC5rZXlzfHxmdW5jdGlvbihvYmope3ZhciBrZXlzPVtdO2Zvcih2YXIga2V5IGluIG9iail7aWYoaGFzT3duLmNhbGwob2JqLGtleSkpa2V5cy5wdXNoKGtleSl9cmV0dXJuIGtleXN9fSx7XCJ1dGlsL1wiOjN9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1mdW5jdGlvbiBpc0J1ZmZlcihhcmcpe3JldHVybiBhcmcmJnR5cGVvZiBhcmc9PT1cIm9iamVjdFwiJiZ0eXBlb2YgYXJnLmNvcHk9PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBhcmcuZmlsbD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIGFyZy5yZWFkVUludDg9PT1cImZ1bmN0aW9uXCJ9fSx7fV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHByb2Nlc3MsZ2xvYmFsKXt2YXIgZm9ybWF0UmVnRXhwPS8lW3NkaiVdL2c7ZXhwb3J0cy5mb3JtYXQ9ZnVuY3Rpb24oZil7aWYoIWlzU3RyaW5nKGYpKXt2YXIgb2JqZWN0cz1bXTtmb3IodmFyIGk9MDtpPGFyZ3VtZW50cy5sZW5ndGg7aSsrKXtvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKX1yZXR1cm4gb2JqZWN0cy5qb2luKFwiIFwiKX12YXIgaT0xO3ZhciBhcmdzPWFyZ3VtZW50czt2YXIgbGVuPWFyZ3MubGVuZ3RoO3ZhciBzdHI9U3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLGZ1bmN0aW9uKHgpe2lmKHg9PT1cIiUlXCIpcmV0dXJuXCIlXCI7aWYoaT49bGVuKXJldHVybiB4O3N3aXRjaCh4KXtjYXNlXCIlc1wiOnJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtjYXNlXCIlZFwiOnJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtjYXNlXCIlalwiOnRyeXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKX1jYXRjaChfKXtyZXR1cm5cIltDaXJjdWxhcl1cIn1kZWZhdWx0OnJldHVybiB4fX0pO2Zvcih2YXIgeD1hcmdzW2ldO2k8bGVuO3g9YXJnc1srK2ldKXtpZihpc051bGwoeCl8fCFpc09iamVjdCh4KSl7c3RyKz1cIiBcIit4fWVsc2V7c3RyKz1cIiBcIitpbnNwZWN0KHgpfX1yZXR1cm4gc3RyfTtleHBvcnRzLmRlcHJlY2F0ZT1mdW5jdGlvbihmbixtc2cpe2lmKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLG1zZykuYXBwbHkodGhpcyxhcmd1bWVudHMpfX1pZihwcm9jZXNzLm5vRGVwcmVjYXRpb249PT10cnVlKXtyZXR1cm4gZm59dmFyIHdhcm5lZD1mYWxzZTtmdW5jdGlvbiBkZXByZWNhdGVkKCl7aWYoIXdhcm5lZCl7aWYocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKXt0aHJvdyBuZXcgRXJyb3IobXNnKX1lbHNlIGlmKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbil7Y29uc29sZS50cmFjZShtc2cpfWVsc2V7Y29uc29sZS5lcnJvcihtc2cpfXdhcm5lZD10cnVlfXJldHVybiBmbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIGRlcHJlY2F0ZWR9O3ZhciBkZWJ1Z3M9e307dmFyIGRlYnVnRW52aXJvbjtleHBvcnRzLmRlYnVnbG9nPWZ1bmN0aW9uKHNldCl7aWYoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlkZWJ1Z0Vudmlyb249cHJvY2Vzcy5lbnYuTk9ERV9ERUJVR3x8XCJcIjtzZXQ9c2V0LnRvVXBwZXJDYXNlKCk7aWYoIWRlYnVnc1tzZXRdKXtpZihuZXcgUmVnRXhwKFwiXFxcXGJcIitzZXQrXCJcXFxcYlwiLFwiaVwiKS50ZXN0KGRlYnVnRW52aXJvbikpe3ZhciBwaWQ9cHJvY2Vzcy5waWQ7ZGVidWdzW3NldF09ZnVuY3Rpb24oKXt2YXIgbXNnPWV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKTtjb25zb2xlLmVycm9yKFwiJXMgJWQ6ICVzXCIsc2V0LHBpZCxtc2cpfX1lbHNle2RlYnVnc1tzZXRdPWZ1bmN0aW9uKCl7fX19cmV0dXJuIGRlYnVnc1tzZXRdfTtmdW5jdGlvbiBpbnNwZWN0KG9iaixvcHRzKXt2YXIgY3R4PXtzZWVuOltdLHN0eWxpemU6c3R5bGl6ZU5vQ29sb3J9O2lmKGFyZ3VtZW50cy5sZW5ndGg+PTMpY3R4LmRlcHRoPWFyZ3VtZW50c1syXTtpZihhcmd1bWVudHMubGVuZ3RoPj00KWN0eC5jb2xvcnM9YXJndW1lbnRzWzNdO2lmKGlzQm9vbGVhbihvcHRzKSl7Y3R4LnNob3dIaWRkZW49b3B0c31lbHNlIGlmKG9wdHMpe2V4cG9ydHMuX2V4dGVuZChjdHgsb3B0cyl9aWYoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKWN0eC5zaG93SGlkZGVuPWZhbHNlO2lmKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpY3R4LmRlcHRoPTI7aWYoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpY3R4LmNvbG9ycz1mYWxzZTtpZihpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpY3R4LmN1c3RvbUluc3BlY3Q9dHJ1ZTtpZihjdHguY29sb3JzKWN0eC5zdHlsaXplPXN0eWxpemVXaXRoQ29sb3I7cmV0dXJuIGZvcm1hdFZhbHVlKGN0eCxvYmosY3R4LmRlcHRoKX1leHBvcnRzLmluc3BlY3Q9aW5zcGVjdDtpbnNwZWN0LmNvbG9ycz17Ym9sZDpbMSwyMl0saXRhbGljOlszLDIzXSx1bmRlcmxpbmU6WzQsMjRdLGludmVyc2U6WzcsMjddLHdoaXRlOlszNywzOV0sZ3JleTpbOTAsMzldLGJsYWNrOlszMCwzOV0sYmx1ZTpbMzQsMzldLGN5YW46WzM2LDM5XSxncmVlbjpbMzIsMzldLG1hZ2VudGE6WzM1LDM5XSxyZWQ6WzMxLDM5XSx5ZWxsb3c6WzMzLDM5XX07aW5zcGVjdC5zdHlsZXM9e3NwZWNpYWw6XCJjeWFuXCIsbnVtYmVyOlwieWVsbG93XCIsXCJib29sZWFuXCI6XCJ5ZWxsb3dcIix1bmRlZmluZWQ6XCJncmV5XCIsXCJudWxsXCI6XCJib2xkXCIsc3RyaW5nOlwiZ3JlZW5cIixkYXRlOlwibWFnZW50YVwiLHJlZ2V4cDpcInJlZFwifTtmdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0cixzdHlsZVR5cGUpe3ZhciBzdHlsZT1pbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO2lmKHN0eWxlKXtyZXR1cm5cIlx1MDAxYltcIitpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0rXCJtXCIrc3RyK1wiXHUwMDFiW1wiK2luc3BlY3QuY29sb3JzW3N0eWxlXVsxXStcIm1cIn1lbHNle3JldHVybiBzdHJ9fWZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0cixzdHlsZVR5cGUpe3JldHVybiBzdHJ9ZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpe3ZhciBoYXNoPXt9O2FycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLGlkeCl7aGFzaFt2YWxdPXRydWV9KTtyZXR1cm4gaGFzaH1mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsdmFsdWUscmVjdXJzZVRpbWVzKXtpZihjdHguY3VzdG9tSW5zcGVjdCYmdmFsdWUmJmlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkmJnZhbHVlLmluc3BlY3QhPT1leHBvcnRzLmluc3BlY3QmJiEodmFsdWUuY29uc3RydWN0b3ImJnZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZT09PXZhbHVlKSl7dmFyIHJldD12YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcyxjdHgpO2lmKCFpc1N0cmluZyhyZXQpKXtyZXQ9Zm9ybWF0VmFsdWUoY3R4LHJldCxyZWN1cnNlVGltZXMpfXJldHVybiByZXR9dmFyIHByaW1pdGl2ZT1mb3JtYXRQcmltaXRpdmUoY3R4LHZhbHVlKTtpZihwcmltaXRpdmUpe3JldHVybiBwcmltaXRpdmV9dmFyIGtleXM9T2JqZWN0LmtleXModmFsdWUpO3ZhciB2aXNpYmxlS2V5cz1hcnJheVRvSGFzaChrZXlzKTtpZihjdHguc2hvd0hpZGRlbil7a2V5cz1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSl9aWYoaXNFcnJvcih2YWx1ZSkmJihrZXlzLmluZGV4T2YoXCJtZXNzYWdlXCIpPj0wfHxrZXlzLmluZGV4T2YoXCJkZXNjcmlwdGlvblwiKT49MCkpe3JldHVybiBmb3JtYXRFcnJvcih2YWx1ZSl9aWYoa2V5cy5sZW5ndGg9PT0wKXtpZihpc0Z1bmN0aW9uKHZhbHVlKSl7dmFyIG5hbWU9dmFsdWUubmFtZT9cIjogXCIrdmFsdWUubmFtZTpcIlwiO3JldHVybiBjdHguc3R5bGl6ZShcIltGdW5jdGlvblwiK25hbWUrXCJdXCIsXCJzcGVjaWFsXCIpfWlmKGlzUmVnRXhwKHZhbHVlKSl7cmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksXCJyZWdleHBcIil9aWYoaXNEYXRlKHZhbHVlKSl7cmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLFwiZGF0ZVwiKX1pZihpc0Vycm9yKHZhbHVlKSl7cmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKX19dmFyIGJhc2U9XCJcIixhcnJheT1mYWxzZSxicmFjZXM9W1wie1wiLFwifVwiXTtpZihpc0FycmF5KHZhbHVlKSl7YXJyYXk9dHJ1ZTticmFjZXM9W1wiW1wiLFwiXVwiXX1pZihpc0Z1bmN0aW9uKHZhbHVlKSl7dmFyIG49dmFsdWUubmFtZT9cIjogXCIrdmFsdWUubmFtZTpcIlwiO2Jhc2U9XCIgW0Z1bmN0aW9uXCIrbitcIl1cIn1pZihpc1JlZ0V4cCh2YWx1ZSkpe2Jhc2U9XCIgXCIrUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKX1pZihpc0RhdGUodmFsdWUpKXtiYXNlPVwiIFwiK0RhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpfWlmKGlzRXJyb3IodmFsdWUpKXtiYXNlPVwiIFwiK2Zvcm1hdEVycm9yKHZhbHVlKX1pZihrZXlzLmxlbmd0aD09PTAmJighYXJyYXl8fHZhbHVlLmxlbmd0aD09MCkpe3JldHVybiBicmFjZXNbMF0rYmFzZSticmFjZXNbMV19aWYocmVjdXJzZVRpbWVzPDApe2lmKGlzUmVnRXhwKHZhbHVlKSl7cmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksXCJyZWdleHBcIil9ZWxzZXtyZXR1cm4gY3R4LnN0eWxpemUoXCJbT2JqZWN0XVwiLFwic3BlY2lhbFwiKX19Y3R4LnNlZW4ucHVzaCh2YWx1ZSk7dmFyIG91dHB1dDtpZihhcnJheSl7b3V0cHV0PWZvcm1hdEFycmF5KGN0eCx2YWx1ZSxyZWN1cnNlVGltZXMsdmlzaWJsZUtleXMsa2V5cyl9ZWxzZXtvdXRwdXQ9a2V5cy5tYXAoZnVuY3Rpb24oa2V5KXtyZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LHZhbHVlLHJlY3Vyc2VUaW1lcyx2aXNpYmxlS2V5cyxrZXksYXJyYXkpfSl9Y3R4LnNlZW4ucG9wKCk7cmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCxiYXNlLGJyYWNlcyl9ZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCx2YWx1ZSl7aWYoaXNVbmRlZmluZWQodmFsdWUpKXJldHVybiBjdHguc3R5bGl6ZShcInVuZGVmaW5lZFwiLFwidW5kZWZpbmVkXCIpO2lmKGlzU3RyaW5nKHZhbHVlKSl7dmFyIHNpbXBsZT1cIidcIitKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLFwiXCIpLnJlcGxhY2UoLycvZyxcIlxcXFwnXCIpLnJlcGxhY2UoL1xcXFxcIi9nLCdcIicpK1wiJ1wiO3JldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsXCJzdHJpbmdcIil9aWYoaXNOdW1iZXIodmFsdWUpKXJldHVybiBjdHguc3R5bGl6ZShcIlwiK3ZhbHVlLFwibnVtYmVyXCIpO2lmKGlzQm9vbGVhbih2YWx1ZSkpcmV0dXJuIGN0eC5zdHlsaXplKFwiXCIrdmFsdWUsXCJib29sZWFuXCIpO2lmKGlzTnVsbCh2YWx1ZSkpcmV0dXJuIGN0eC5zdHlsaXplKFwibnVsbFwiLFwibnVsbFwiKX1mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSl7cmV0dXJuXCJbXCIrRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpK1wiXVwifWZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCx2YWx1ZSxyZWN1cnNlVGltZXMsdmlzaWJsZUtleXMsa2V5cyl7dmFyIG91dHB1dD1bXTtmb3IodmFyIGk9MCxsPXZhbHVlLmxlbmd0aDtpPGw7KytpKXtpZihoYXNPd25Qcm9wZXJ0eSh2YWx1ZSxTdHJpbmcoaSkpKXtvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsdmFsdWUscmVjdXJzZVRpbWVzLHZpc2libGVLZXlzLFN0cmluZyhpKSx0cnVlKSl9ZWxzZXtvdXRwdXQucHVzaChcIlwiKX19a2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7aWYoIWtleS5tYXRjaCgvXlxcZCskLykpe291dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCx2YWx1ZSxyZWN1cnNlVGltZXMsdmlzaWJsZUtleXMsa2V5LHRydWUpKX19KTtyZXR1cm4gb3V0cHV0fWZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCx2YWx1ZSxyZWN1cnNlVGltZXMsdmlzaWJsZUtleXMsa2V5LGFycmF5KXt2YXIgbmFtZSxzdHIsZGVzYztkZXNjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsa2V5KXx8e3ZhbHVlOnZhbHVlW2tleV19O2lmKGRlc2MuZ2V0KXtpZihkZXNjLnNldCl7c3RyPWN0eC5zdHlsaXplKFwiW0dldHRlci9TZXR0ZXJdXCIsXCJzcGVjaWFsXCIpfWVsc2V7c3RyPWN0eC5zdHlsaXplKFwiW0dldHRlcl1cIixcInNwZWNpYWxcIil9fWVsc2V7aWYoZGVzYy5zZXQpe3N0cj1jdHguc3R5bGl6ZShcIltTZXR0ZXJdXCIsXCJzcGVjaWFsXCIpfX1pZighaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsa2V5KSl7bmFtZT1cIltcIitrZXkrXCJdXCJ9aWYoIXN0cil7aWYoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKTwwKXtpZihpc051bGwocmVjdXJzZVRpbWVzKSl7c3RyPWZvcm1hdFZhbHVlKGN0eCxkZXNjLnZhbHVlLG51bGwpfWVsc2V7c3RyPWZvcm1hdFZhbHVlKGN0eCxkZXNjLnZhbHVlLHJlY3Vyc2VUaW1lcy0xKX1pZihzdHIuaW5kZXhPZihcIlxcblwiKT4tMSl7aWYoYXJyYXkpe3N0cj1zdHIuc3BsaXQoXCJcXG5cIikubWFwKGZ1bmN0aW9uKGxpbmUpe3JldHVyblwiICBcIitsaW5lfSkuam9pbihcIlxcblwiKS5zdWJzdHIoMil9ZWxzZXtzdHI9XCJcXG5cIitzdHIuc3BsaXQoXCJcXG5cIikubWFwKGZ1bmN0aW9uKGxpbmUpe3JldHVyblwiICAgXCIrbGluZX0pLmpvaW4oXCJcXG5cIil9fX1lbHNle3N0cj1jdHguc3R5bGl6ZShcIltDaXJjdWxhcl1cIixcInNwZWNpYWxcIil9fWlmKGlzVW5kZWZpbmVkKG5hbWUpKXtpZihhcnJheSYma2V5Lm1hdGNoKC9eXFxkKyQvKSl7cmV0dXJuIHN0cn1uYW1lPUpTT04uc3RyaW5naWZ5KFwiXCIra2V5KTtpZihuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSl7bmFtZT1uYW1lLnN1YnN0cigxLG5hbWUubGVuZ3RoLTIpO25hbWU9Y3R4LnN0eWxpemUobmFtZSxcIm5hbWVcIil9ZWxzZXtuYW1lPW5hbWUucmVwbGFjZSgvJy9nLFwiXFxcXCdcIikucmVwbGFjZSgvXFxcXFwiL2csJ1wiJykucmVwbGFjZSgvKF5cInxcIiQpL2csXCInXCIpO25hbWU9Y3R4LnN0eWxpemUobmFtZSxcInN0cmluZ1wiKX19cmV0dXJuIG5hbWUrXCI6IFwiK3N0cn1mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsYmFzZSxicmFjZXMpe3ZhciBudW1MaW5lc0VzdD0wO3ZhciBsZW5ndGg9b3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LGN1cil7bnVtTGluZXNFc3QrKztpZihjdXIuaW5kZXhPZihcIlxcblwiKT49MCludW1MaW5lc0VzdCsrO3JldHVybiBwcmV2K2N1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZyxcIlwiKS5sZW5ndGgrMX0sMCk7aWYobGVuZ3RoPjYwKXtyZXR1cm4gYnJhY2VzWzBdKyhiYXNlPT09XCJcIj9cIlwiOmJhc2UrXCJcXG4gXCIpK1wiIFwiK291dHB1dC5qb2luKFwiLFxcbiAgXCIpK1wiIFwiK2JyYWNlc1sxXX1yZXR1cm4gYnJhY2VzWzBdK2Jhc2UrXCIgXCIrb3V0cHV0LmpvaW4oXCIsIFwiKStcIiBcIiticmFjZXNbMV19ZnVuY3Rpb24gaXNBcnJheShhcil7cmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpfWV4cG9ydHMuaXNBcnJheT1pc0FycmF5O2Z1bmN0aW9uIGlzQm9vbGVhbihhcmcpe3JldHVybiB0eXBlb2YgYXJnPT09XCJib29sZWFuXCJ9ZXhwb3J0cy5pc0Jvb2xlYW49aXNCb29sZWFuO2Z1bmN0aW9uIGlzTnVsbChhcmcpe3JldHVybiBhcmc9PT1udWxsfWV4cG9ydHMuaXNOdWxsPWlzTnVsbDtmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpe3JldHVybiBhcmc9PW51bGx9ZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZD1pc051bGxPclVuZGVmaW5lZDtmdW5jdGlvbiBpc051bWJlcihhcmcpe3JldHVybiB0eXBlb2YgYXJnPT09XCJudW1iZXJcIn1leHBvcnRzLmlzTnVtYmVyPWlzTnVtYmVyO2Z1bmN0aW9uIGlzU3RyaW5nKGFyZyl7cmV0dXJuIHR5cGVvZiBhcmc9PT1cInN0cmluZ1wifWV4cG9ydHMuaXNTdHJpbmc9aXNTdHJpbmc7ZnVuY3Rpb24gaXNTeW1ib2woYXJnKXtyZXR1cm4gdHlwZW9mIGFyZz09PVwic3ltYm9sXCJ9ZXhwb3J0cy5pc1N5bWJvbD1pc1N5bWJvbDtmdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpe3JldHVybiBhcmc9PT12b2lkIDB9ZXhwb3J0cy5pc1VuZGVmaW5lZD1pc1VuZGVmaW5lZDtmdW5jdGlvbiBpc1JlZ0V4cChyZSl7cmV0dXJuIGlzT2JqZWN0KHJlKSYmb2JqZWN0VG9TdHJpbmcocmUpPT09XCJbb2JqZWN0IFJlZ0V4cF1cIn1leHBvcnRzLmlzUmVnRXhwPWlzUmVnRXhwO2Z1bmN0aW9uIGlzT2JqZWN0KGFyZyl7cmV0dXJuIHR5cGVvZiBhcmc9PT1cIm9iamVjdFwiJiZhcmchPT1udWxsfWV4cG9ydHMuaXNPYmplY3Q9aXNPYmplY3Q7ZnVuY3Rpb24gaXNEYXRlKGQpe3JldHVybiBpc09iamVjdChkKSYmb2JqZWN0VG9TdHJpbmcoZCk9PT1cIltvYmplY3QgRGF0ZV1cIn1leHBvcnRzLmlzRGF0ZT1pc0RhdGU7ZnVuY3Rpb24gaXNFcnJvcihlKXtyZXR1cm4gaXNPYmplY3QoZSkmJihvYmplY3RUb1N0cmluZyhlKT09PVwiW29iamVjdCBFcnJvcl1cInx8ZSBpbnN0YW5jZW9mIEVycm9yKX1leHBvcnRzLmlzRXJyb3I9aXNFcnJvcjtmdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZyl7cmV0dXJuIHR5cGVvZiBhcmc9PT1cImZ1bmN0aW9uXCJ9ZXhwb3J0cy5pc0Z1bmN0aW9uPWlzRnVuY3Rpb247ZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKXtyZXR1cm4gYXJnPT09bnVsbHx8dHlwZW9mIGFyZz09PVwiYm9vbGVhblwifHx0eXBlb2YgYXJnPT09XCJudW1iZXJcInx8dHlwZW9mIGFyZz09PVwic3RyaW5nXCJ8fHR5cGVvZiBhcmc9PT1cInN5bWJvbFwifHx0eXBlb2YgYXJnPT09XCJ1bmRlZmluZWRcIn1leHBvcnRzLmlzUHJpbWl0aXZlPWlzUHJpbWl0aXZlO2V4cG9ydHMuaXNCdWZmZXI9X2RlcmVxXyhcIi4vc3VwcG9ydC9pc0J1ZmZlclwiKTtmdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pfWZ1bmN0aW9uIHBhZChuKXtyZXR1cm4gbjwxMD9cIjBcIituLnRvU3RyaW5nKDEwKTpuLnRvU3RyaW5nKDEwKX12YXIgbW9udGhzPVtcIkphblwiLFwiRmViXCIsXCJNYXJcIixcIkFwclwiLFwiTWF5XCIsXCJKdW5cIixcIkp1bFwiLFwiQXVnXCIsXCJTZXBcIixcIk9jdFwiLFwiTm92XCIsXCJEZWNcIl07ZnVuY3Rpb24gdGltZXN0YW1wKCl7dmFyIGQ9bmV3IERhdGU7dmFyIHRpbWU9W3BhZChkLmdldEhvdXJzKCkpLHBhZChkLmdldE1pbnV0ZXMoKSkscGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbihcIjpcIik7cmV0dXJuW2QuZ2V0RGF0ZSgpLG1vbnRoc1tkLmdldE1vbnRoKCldLHRpbWVdLmpvaW4oXCIgXCIpfWV4cG9ydHMubG9nPWZ1bmN0aW9uKCl7Y29uc29sZS5sb2coXCIlcyAtICVzXCIsdGltZXN0YW1wKCksZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpKX07ZXhwb3J0cy5pbmhlcml0cz1fZGVyZXFfKFwiaW5oZXJpdHNcIik7ZXhwb3J0cy5fZXh0ZW5kPWZ1bmN0aW9uKG9yaWdpbixhZGQpe2lmKCFhZGR8fCFpc09iamVjdChhZGQpKXJldHVybiBvcmlnaW47dmFyIGtleXM9T2JqZWN0LmtleXMoYWRkKTt2YXIgaT1rZXlzLmxlbmd0aDt3aGlsZShpLS0pe29yaWdpbltrZXlzW2ldXT1hZGRba2V5c1tpXV19cmV0dXJuIG9yaWdpbn07ZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLHByb3Ape3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLHByb3ApfX0pLmNhbGwodGhpcyxfZGVyZXFfKFwiRldhQVNIXCIpLHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSl9LHtcIi4vc3VwcG9ydC9pc0J1ZmZlclwiOjIsRldhQVNIOjE1LGluaGVyaXRzOjE0fV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7fSx7fV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIGJhc2U2ND1fZGVyZXFfKFwiYmFzZTY0LWpzXCIpO3ZhciBpZWVlNzU0PV9kZXJlcV8oXCJpZWVlNzU0XCIpO2V4cG9ydHMuQnVmZmVyPUJ1ZmZlcjtleHBvcnRzLlNsb3dCdWZmZXI9QnVmZmVyO2V4cG9ydHMuSU5TUEVDVF9NQVhfQllURVM9NTA7QnVmZmVyLnBvb2xTaXplPTgxOTI7QnVmZmVyLl91c2VUeXBlZEFycmF5cz1mdW5jdGlvbigpe3RyeXt2YXIgYnVmPW5ldyBBcnJheUJ1ZmZlcigwKTt2YXIgYXJyPW5ldyBVaW50OEFycmF5KGJ1Zik7YXJyLmZvbz1mdW5jdGlvbigpe3JldHVybiA0Mn07cmV0dXJuIDQyPT09YXJyLmZvbygpJiZ0eXBlb2YgYXJyLnN1YmFycmF5PT09XCJmdW5jdGlvblwifWNhdGNoKGUpe3JldHVybiBmYWxzZX19KCk7ZnVuY3Rpb24gQnVmZmVyKHN1YmplY3QsZW5jb2Rpbmcsbm9aZXJvKXtpZighKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKXJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsZW5jb2Rpbmcsbm9aZXJvKTt2YXIgdHlwZT10eXBlb2Ygc3ViamVjdDtpZihlbmNvZGluZz09PVwiYmFzZTY0XCImJnR5cGU9PT1cInN0cmluZ1wiKXtzdWJqZWN0PXN0cmluZ3RyaW0oc3ViamVjdCk7d2hpbGUoc3ViamVjdC5sZW5ndGglNCE9PTApe3N1YmplY3Q9c3ViamVjdCtcIj1cIn19dmFyIGxlbmd0aDtpZih0eXBlPT09XCJudW1iZXJcIilsZW5ndGg9Y29lcmNlKHN1YmplY3QpO2Vsc2UgaWYodHlwZT09PVwic3RyaW5nXCIpbGVuZ3RoPUJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsZW5jb2RpbmcpO2Vsc2UgaWYodHlwZT09PVwib2JqZWN0XCIpbGVuZ3RoPWNvZXJjZShzdWJqZWN0Lmxlbmd0aCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgYXJyYXkgb3Igc3RyaW5nLlwiKTt2YXIgYnVmO2lmKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpe2J1Zj1CdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSl9ZWxzZXtidWY9dGhpcztidWYubGVuZ3RoPWxlbmd0aDtidWYuX2lzQnVmZmVyPXRydWV9dmFyIGk7aWYoQnVmZmVyLl91c2VUeXBlZEFycmF5cyYmdHlwZW9mIHN1YmplY3QuYnl0ZUxlbmd0aD09PVwibnVtYmVyXCIpe2J1Zi5fc2V0KHN1YmplY3QpfWVsc2UgaWYoaXNBcnJheWlzaChzdWJqZWN0KSl7aWYoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKXtmb3IoaT0wO2k8bGVuZ3RoO2krKylidWZbaV09c3ViamVjdC5yZWFkVUludDgoaSl9ZWxzZXtmb3IoaT0wO2k8bGVuZ3RoO2krKylidWZbaV09KHN1YmplY3RbaV0lMjU2KzI1NiklMjU2fX1lbHNlIGlmKHR5cGU9PT1cInN0cmluZ1wiKXtidWYud3JpdGUoc3ViamVjdCwwLGVuY29kaW5nKX1lbHNlIGlmKHR5cGU9PT1cIm51bWJlclwiJiYhQnVmZmVyLl91c2VUeXBlZEFycmF5cyYmIW5vWmVybyl7Zm9yKGk9MDtpPGxlbmd0aDtpKyspe2J1ZltpXT0wfX1yZXR1cm4gYnVmfUJ1ZmZlci5pc0VuY29kaW5nPWZ1bmN0aW9uKGVuY29kaW5nKXtzd2l0Y2goU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInJhd1wiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0cnVlO2RlZmF1bHQ6cmV0dXJuIGZhbHNlfX07QnVmZmVyLmlzQnVmZmVyPWZ1bmN0aW9uKGIpe3JldHVybiEhKGIhPT1udWxsJiZiIT09dW5kZWZpbmVkJiZiLl9pc0J1ZmZlcil9O0J1ZmZlci5ieXRlTGVuZ3RoPWZ1bmN0aW9uKHN0cixlbmNvZGluZyl7dmFyIHJldDtzdHI9c3RyLnRvU3RyaW5nKCk7c3dpdGNoKGVuY29kaW5nfHxcInV0ZjhcIil7Y2FzZVwiaGV4XCI6cmV0PXN0ci5sZW5ndGgvMjticmVhaztjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXQ9dXRmOFRvQnl0ZXMoc3RyKS5sZW5ndGg7YnJlYWs7Y2FzZVwiYXNjaWlcIjpjYXNlXCJiaW5hcnlcIjpjYXNlXCJyYXdcIjpyZXQ9c3RyLmxlbmd0aDticmVhaztjYXNlXCJiYXNlNjRcIjpyZXQ9YmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aDticmVhaztjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXQ9c3RyLmxlbmd0aCoyO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBlbmNvZGluZ1wiKX1yZXR1cm4gcmV0fTtCdWZmZXIuY29uY2F0PWZ1bmN0aW9uKGxpc3QsdG90YWxMZW5ndGgpe2Fzc2VydChpc0FycmF5KGxpc3QpLFwiVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdFssIGxlbmd0aF0pXCIpO2lmKGxpc3QubGVuZ3RoPT09MCl7cmV0dXJuIG5ldyBCdWZmZXIoMCl9ZWxzZSBpZihsaXN0Lmxlbmd0aD09PTEpe3JldHVybiBsaXN0WzBdfXZhciBpO2lmKHRvdGFsTGVuZ3RoPT09dW5kZWZpbmVkKXt0b3RhbExlbmd0aD0wO2ZvcihpPTA7aTxsaXN0Lmxlbmd0aDtpKyspe3RvdGFsTGVuZ3RoKz1saXN0W2ldLmxlbmd0aH19dmFyIGJ1Zj1uZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKTt2YXIgcG9zPTA7Zm9yKGk9MDtpPGxpc3QubGVuZ3RoO2krKyl7dmFyIGl0ZW09bGlzdFtpXTtpdGVtLmNvcHkoYnVmLHBvcyk7cG9zKz1pdGVtLmxlbmd0aH1yZXR1cm4gYnVmfTtCdWZmZXIuY29tcGFyZT1mdW5jdGlvbihhLGIpe2Fzc2VydChCdWZmZXIuaXNCdWZmZXIoYSkmJkJ1ZmZlci5pc0J1ZmZlcihiKSxcIkFyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnNcIik7dmFyIHg9YS5sZW5ndGg7dmFyIHk9Yi5sZW5ndGg7Zm9yKHZhciBpPTAsbGVuPU1hdGgubWluKHgseSk7aTxsZW4mJmFbaV09PT1iW2ldO2krKyl7fWlmKGkhPT1sZW4pe3g9YVtpXTt5PWJbaV19aWYoeDx5KXtyZXR1cm4tMX1pZih5PHgpe3JldHVybiAxfXJldHVybiAwfTtmdW5jdGlvbiBoZXhXcml0ZShidWYsc3RyaW5nLG9mZnNldCxsZW5ndGgpe29mZnNldD1OdW1iZXIob2Zmc2V0KXx8MDt2YXIgcmVtYWluaW5nPWJ1Zi5sZW5ndGgtb2Zmc2V0O2lmKCFsZW5ndGgpe2xlbmd0aD1yZW1haW5pbmd9ZWxzZXtsZW5ndGg9TnVtYmVyKGxlbmd0aCk7aWYobGVuZ3RoPnJlbWFpbmluZyl7bGVuZ3RoPXJlbWFpbmluZ319dmFyIHN0ckxlbj1zdHJpbmcubGVuZ3RoO2Fzc2VydChzdHJMZW4lMj09PTAsXCJJbnZhbGlkIGhleCBzdHJpbmdcIik7aWYobGVuZ3RoPnN0ckxlbi8yKXtsZW5ndGg9c3RyTGVuLzJ9Zm9yKHZhciBpPTA7aTxsZW5ndGg7aSsrKXt2YXIgYnl0ZT1wYXJzZUludChzdHJpbmcuc3Vic3RyKGkqMiwyKSwxNik7YXNzZXJ0KCFpc05hTihieXRlKSxcIkludmFsaWQgaGV4IHN0cmluZ1wiKTtidWZbb2Zmc2V0K2ldPWJ5dGV9cmV0dXJuIGl9ZnVuY3Rpb24gdXRmOFdyaXRlKGJ1ZixzdHJpbmcsb2Zmc2V0LGxlbmd0aCl7dmFyIGNoYXJzV3JpdHRlbj1ibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksYnVmLG9mZnNldCxsZW5ndGgpO3JldHVybiBjaGFyc1dyaXR0ZW59ZnVuY3Rpb24gYXNjaWlXcml0ZShidWYsc3RyaW5nLG9mZnNldCxsZW5ndGgpe3ZhciBjaGFyc1dyaXR0ZW49YmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSxidWYsb2Zmc2V0LGxlbmd0aCk7cmV0dXJuIGNoYXJzV3JpdHRlbn1mdW5jdGlvbiBiaW5hcnlXcml0ZShidWYsc3RyaW5nLG9mZnNldCxsZW5ndGgpe3JldHVybiBhc2NpaVdyaXRlKGJ1ZixzdHJpbmcsb2Zmc2V0LGxlbmd0aCl9ZnVuY3Rpb24gYmFzZTY0V3JpdGUoYnVmLHN0cmluZyxvZmZzZXQsbGVuZ3RoKXt2YXIgY2hhcnNXcml0dGVuPWJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLGJ1ZixvZmZzZXQsbGVuZ3RoKTtyZXR1cm4gY2hhcnNXcml0dGVufWZ1bmN0aW9uIHV0ZjE2bGVXcml0ZShidWYsc3RyaW5nLG9mZnNldCxsZW5ndGgpe3ZhciBjaGFyc1dyaXR0ZW49YmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcpLGJ1ZixvZmZzZXQsbGVuZ3RoKTtyZXR1cm4gY2hhcnNXcml0dGVufUJ1ZmZlci5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24oc3RyaW5nLG9mZnNldCxsZW5ndGgsZW5jb2Rpbmcpe2lmKGlzRmluaXRlKG9mZnNldCkpe2lmKCFpc0Zpbml0ZShsZW5ndGgpKXtlbmNvZGluZz1sZW5ndGg7bGVuZ3RoPXVuZGVmaW5lZH19ZWxzZXt2YXIgc3dhcD1lbmNvZGluZztlbmNvZGluZz1vZmZzZXQ7b2Zmc2V0PWxlbmd0aDtsZW5ndGg9c3dhcH1vZmZzZXQ9TnVtYmVyKG9mZnNldCl8fDA7dmFyIHJlbWFpbmluZz10aGlzLmxlbmd0aC1vZmZzZXQ7aWYoIWxlbmd0aCl7bGVuZ3RoPXJlbWFpbmluZ31lbHNle2xlbmd0aD1OdW1iZXIobGVuZ3RoKTtpZihsZW5ndGg+cmVtYWluaW5nKXtsZW5ndGg9cmVtYWluaW5nfX1lbmNvZGluZz1TdHJpbmcoZW5jb2Rpbmd8fFwidXRmOFwiKS50b0xvd2VyQ2FzZSgpO3ZhciByZXQ7c3dpdGNoKGVuY29kaW5nKXtjYXNlXCJoZXhcIjpyZXQ9aGV4V3JpdGUodGhpcyxzdHJpbmcsb2Zmc2V0LGxlbmd0aCk7YnJlYWs7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0PXV0ZjhXcml0ZSh0aGlzLHN0cmluZyxvZmZzZXQsbGVuZ3RoKTticmVhaztjYXNlXCJhc2NpaVwiOnJldD1hc2NpaVdyaXRlKHRoaXMsc3RyaW5nLG9mZnNldCxsZW5ndGgpO2JyZWFrO2Nhc2VcImJpbmFyeVwiOnJldD1iaW5hcnlXcml0ZSh0aGlzLHN0cmluZyxvZmZzZXQsbGVuZ3RoKTticmVhaztjYXNlXCJiYXNlNjRcIjpyZXQ9YmFzZTY0V3JpdGUodGhpcyxzdHJpbmcsb2Zmc2V0LGxlbmd0aCk7YnJlYWs7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0PXV0ZjE2bGVXcml0ZSh0aGlzLHN0cmluZyxvZmZzZXQsbGVuZ3RoKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVua25vd24gZW5jb2RpbmdcIil9cmV0dXJuIHJldH07QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbihlbmNvZGluZyxzdGFydCxlbmQpe3ZhciBzZWxmPXRoaXM7ZW5jb2Rpbmc9U3RyaW5nKGVuY29kaW5nfHxcInV0ZjhcIikudG9Mb3dlckNhc2UoKTtzdGFydD1OdW1iZXIoc3RhcnQpfHwwO2VuZD1lbmQ9PT11bmRlZmluZWQ/c2VsZi5sZW5ndGg6TnVtYmVyKGVuZCk7aWYoZW5kPT09c3RhcnQpcmV0dXJuXCJcIjt2YXIgcmV0O3N3aXRjaChlbmNvZGluZyl7Y2FzZVwiaGV4XCI6cmV0PWhleFNsaWNlKHNlbGYsc3RhcnQsZW5kKTticmVhaztjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXQ9dXRmOFNsaWNlKHNlbGYsc3RhcnQsZW5kKTticmVhaztjYXNlXCJhc2NpaVwiOnJldD1hc2NpaVNsaWNlKHNlbGYsc3RhcnQsZW5kKTticmVhaztjYXNlXCJiaW5hcnlcIjpyZXQ9YmluYXJ5U2xpY2Uoc2VsZixzdGFydCxlbmQpO2JyZWFrO2Nhc2VcImJhc2U2NFwiOnJldD1iYXNlNjRTbGljZShzZWxmLHN0YXJ0LGVuZCk7YnJlYWs7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0PXV0ZjE2bGVTbGljZShzZWxmLHN0YXJ0LGVuZCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVuY29kaW5nXCIpfXJldHVybiByZXR9O0J1ZmZlci5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6XCJCdWZmZXJcIixkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2Fycnx8dGhpcywwKX19O0J1ZmZlci5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKGIpe2Fzc2VydChCdWZmZXIuaXNCdWZmZXIoYiksXCJBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyXCIpO3JldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLGIpPT09MH07QnVmZmVyLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uKGIpe2Fzc2VydChCdWZmZXIuaXNCdWZmZXIoYiksXCJBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyXCIpO3JldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLGIpfTtCdWZmZXIucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24odGFyZ2V0LHRhcmdldF9zdGFydCxzdGFydCxlbmQpe3ZhciBzb3VyY2U9dGhpcztpZighc3RhcnQpc3RhcnQ9MDtpZighZW5kJiZlbmQhPT0wKWVuZD10aGlzLmxlbmd0aDtpZighdGFyZ2V0X3N0YXJ0KXRhcmdldF9zdGFydD0wO2lmKGVuZD09PXN0YXJ0KXJldHVybjtpZih0YXJnZXQubGVuZ3RoPT09MHx8c291cmNlLmxlbmd0aD09PTApcmV0dXJuO2Fzc2VydChlbmQ+PXN0YXJ0LFwic291cmNlRW5kIDwgc291cmNlU3RhcnRcIik7YXNzZXJ0KHRhcmdldF9zdGFydD49MCYmdGFyZ2V0X3N0YXJ0PHRhcmdldC5sZW5ndGgsXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpO2Fzc2VydChzdGFydD49MCYmc3RhcnQ8c291cmNlLmxlbmd0aCxcInNvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHNcIik7YXNzZXJ0KGVuZD49MCYmZW5kPD1zb3VyY2UubGVuZ3RoLFwic291cmNlRW5kIG91dCBvZiBib3VuZHNcIik7aWYoZW5kPnRoaXMubGVuZ3RoKWVuZD10aGlzLmxlbmd0aDtpZih0YXJnZXQubGVuZ3RoLXRhcmdldF9zdGFydDxlbmQtc3RhcnQpZW5kPXRhcmdldC5sZW5ndGgtdGFyZ2V0X3N0YXJ0K3N0YXJ0O3ZhciBsZW49ZW5kLXN0YXJ0O2lmKGxlbjwxMDB8fCFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKXtmb3IodmFyIGk9MDtpPGxlbjtpKyspe3RhcmdldFtpK3RhcmdldF9zdGFydF09dGhpc1tpK3N0YXJ0XX19ZWxzZXt0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LHN0YXJ0K2xlbiksdGFyZ2V0X3N0YXJ0KX19O2Z1bmN0aW9uIGJhc2U2NFNsaWNlKGJ1ZixzdGFydCxlbmQpe2lmKHN0YXJ0PT09MCYmZW5kPT09YnVmLmxlbmd0aCl7cmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zil9ZWxzZXtyZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LGVuZCkpfX1mdW5jdGlvbiB1dGY4U2xpY2UoYnVmLHN0YXJ0LGVuZCl7dmFyIHJlcz1cIlwiO3ZhciB0bXA9XCJcIjtlbmQ9TWF0aC5taW4oYnVmLmxlbmd0aCxlbmQpO2Zvcih2YXIgaT1zdGFydDtpPGVuZDtpKyspe2lmKGJ1ZltpXTw9MTI3KXtyZXMrPWRlY29kZVV0ZjhDaGFyKHRtcCkrU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO3RtcD1cIlwifWVsc2V7dG1wKz1cIiVcIitidWZbaV0udG9TdHJpbmcoMTYpfX1yZXR1cm4gcmVzK2RlY29kZVV0ZjhDaGFyKHRtcCl9ZnVuY3Rpb24gYXNjaWlTbGljZShidWYsc3RhcnQsZW5kKXt2YXIgcmV0PVwiXCI7ZW5kPU1hdGgubWluKGJ1Zi5sZW5ndGgsZW5kKTtmb3IodmFyIGk9c3RhcnQ7aTxlbmQ7aSsrKXtyZXQrPVN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKX1yZXR1cm4gcmV0fWZ1bmN0aW9uIGJpbmFyeVNsaWNlKGJ1ZixzdGFydCxlbmQpe3JldHVybiBhc2NpaVNsaWNlKGJ1ZixzdGFydCxlbmQpfWZ1bmN0aW9uIGhleFNsaWNlKGJ1ZixzdGFydCxlbmQpe3ZhciBsZW49YnVmLmxlbmd0aDtpZighc3RhcnR8fHN0YXJ0PDApc3RhcnQ9MDtpZighZW5kfHxlbmQ8MHx8ZW5kPmxlbillbmQ9bGVuO3ZhciBvdXQ9XCJcIjtmb3IodmFyIGk9c3RhcnQ7aTxlbmQ7aSsrKXtvdXQrPXRvSGV4KGJ1ZltpXSl9cmV0dXJuIG91dH1mdW5jdGlvbiB1dGYxNmxlU2xpY2UoYnVmLHN0YXJ0LGVuZCl7dmFyIGJ5dGVzPWJ1Zi5zbGljZShzdGFydCxlbmQpO3ZhciByZXM9XCJcIjtmb3IodmFyIGk9MDtpPGJ5dGVzLmxlbmd0aDtpKz0yKXtyZXMrPVN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0rYnl0ZXNbaSsxXSoyNTYpfXJldHVybiByZXN9QnVmZmVyLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbihzdGFydCxlbmQpe3ZhciBsZW49dGhpcy5sZW5ndGg7c3RhcnQ9Y2xhbXAoc3RhcnQsbGVuLDApO2VuZD1jbGFtcChlbmQsbGVuLGxlbik7aWYoQnVmZmVyLl91c2VUeXBlZEFycmF5cyl7cmV0dXJuIEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LGVuZCkpfWVsc2V7dmFyIHNsaWNlTGVuPWVuZC1zdGFydDt2YXIgbmV3QnVmPW5ldyBCdWZmZXIoc2xpY2VMZW4sdW5kZWZpbmVkLHRydWUpO2Zvcih2YXIgaT0wO2k8c2xpY2VMZW47aSsrKXtuZXdCdWZbaV09dGhpc1tpK3N0YXJ0XX1yZXR1cm4gbmV3QnVmfX07QnVmZmVyLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24ob2Zmc2V0KXtjb25zb2xlLmxvZyhcIi5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLlwiKTtyZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KX07QnVmZmVyLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odixvZmZzZXQpe2NvbnNvbGUubG9nKFwiLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuXCIpO3JldHVybiB0aGlzLndyaXRlVUludDgodixvZmZzZXQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OD1mdW5jdGlvbihvZmZzZXQsbm9Bc3NlcnQpe2lmKCFub0Fzc2VydCl7YXNzZXJ0KG9mZnNldCE9PXVuZGVmaW5lZCYmb2Zmc2V0IT09bnVsbCxcIm1pc3Npbmcgb2Zmc2V0XCIpO2Fzc2VydChvZmZzZXQ8dGhpcy5sZW5ndGgsXCJUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1pZihvZmZzZXQ+PXRoaXMubGVuZ3RoKXJldHVybjtyZXR1cm4gdGhpc1tvZmZzZXRdfTtmdW5jdGlvbiByZWFkVUludDE2KGJ1ZixvZmZzZXQsbGl0dGxlRW5kaWFuLG5vQXNzZXJ0KXtpZighbm9Bc3NlcnQpe2Fzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuPT09XCJib29sZWFuXCIsXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXCIpO2Fzc2VydChvZmZzZXQhPT11bmRlZmluZWQmJm9mZnNldCE9PW51bGwsXCJtaXNzaW5nIG9mZnNldFwiKTthc3NlcnQob2Zmc2V0KzE8YnVmLmxlbmd0aCxcIlRyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfXZhciBsZW49YnVmLmxlbmd0aDtpZihvZmZzZXQ+PWxlbilyZXR1cm47dmFyIHZhbDtpZihsaXR0bGVFbmRpYW4pe3ZhbD1idWZbb2Zmc2V0XTtpZihvZmZzZXQrMTxsZW4pdmFsfD1idWZbb2Zmc2V0KzFdPDw4fWVsc2V7dmFsPWJ1ZltvZmZzZXRdPDw4O2lmKG9mZnNldCsxPGxlbil2YWx8PWJ1ZltvZmZzZXQrMV19cmV0dXJuIHZhbH1CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRT1mdW5jdGlvbihvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiByZWFkVUludDE2KHRoaXMsb2Zmc2V0LHRydWUsbm9Bc3NlcnQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRT1mdW5jdGlvbihvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiByZWFkVUludDE2KHRoaXMsb2Zmc2V0LGZhbHNlLG5vQXNzZXJ0KX07ZnVuY3Rpb24gcmVhZFVJbnQzMihidWYsb2Zmc2V0LGxpdHRsZUVuZGlhbixub0Fzc2VydCl7aWYoIW5vQXNzZXJ0KXthc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbj09PVwiYm9vbGVhblwiLFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblwiKTthc3NlcnQob2Zmc2V0IT09dW5kZWZpbmVkJiZvZmZzZXQhPT1udWxsLFwibWlzc2luZyBvZmZzZXRcIik7YXNzZXJ0KG9mZnNldCszPGJ1Zi5sZW5ndGgsXCJUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX12YXIgbGVuPWJ1Zi5sZW5ndGg7aWYob2Zmc2V0Pj1sZW4pcmV0dXJuO3ZhciB2YWw7aWYobGl0dGxlRW5kaWFuKXtpZihvZmZzZXQrMjxsZW4pdmFsPWJ1ZltvZmZzZXQrMl08PDE2O2lmKG9mZnNldCsxPGxlbil2YWx8PWJ1ZltvZmZzZXQrMV08PDg7dmFsfD1idWZbb2Zmc2V0XTtpZihvZmZzZXQrMzxsZW4pdmFsPXZhbCsoYnVmW29mZnNldCszXTw8MjQ+Pj4wKX1lbHNle2lmKG9mZnNldCsxPGxlbil2YWw9YnVmW29mZnNldCsxXTw8MTY7aWYob2Zmc2V0KzI8bGVuKXZhbHw9YnVmW29mZnNldCsyXTw8ODtpZihvZmZzZXQrMzxsZW4pdmFsfD1idWZbb2Zmc2V0KzNdO3ZhbD12YWwrKGJ1ZltvZmZzZXRdPDwyND4+PjApfXJldHVybiB2YWx9QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24ob2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gcmVhZFVJbnQzMih0aGlzLG9mZnNldCx0cnVlLG5vQXNzZXJ0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkU9ZnVuY3Rpb24ob2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gcmVhZFVJbnQzMih0aGlzLG9mZnNldCxmYWxzZSxub0Fzc2VydCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24ob2Zmc2V0LG5vQXNzZXJ0KXtpZighbm9Bc3NlcnQpe2Fzc2VydChvZmZzZXQhPT11bmRlZmluZWQmJm9mZnNldCE9PW51bGwsXCJtaXNzaW5nIG9mZnNldFwiKTthc3NlcnQob2Zmc2V0PHRoaXMubGVuZ3RoLFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIil9aWYob2Zmc2V0Pj10aGlzLmxlbmd0aClyZXR1cm47dmFyIG5lZz10aGlzW29mZnNldF0mMTI4O2lmKG5lZylyZXR1cm4oMjU1LXRoaXNbb2Zmc2V0XSsxKSotMTtlbHNlIHJldHVybiB0aGlzW29mZnNldF19O2Z1bmN0aW9uIHJlYWRJbnQxNihidWYsb2Zmc2V0LGxpdHRsZUVuZGlhbixub0Fzc2VydCl7aWYoIW5vQXNzZXJ0KXthc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbj09PVwiYm9vbGVhblwiLFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblwiKTthc3NlcnQob2Zmc2V0IT09dW5kZWZpbmVkJiZvZmZzZXQhPT1udWxsLFwibWlzc2luZyBvZmZzZXRcIik7YXNzZXJ0KG9mZnNldCsxPGJ1Zi5sZW5ndGgsXCJUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX12YXIgbGVuPWJ1Zi5sZW5ndGg7aWYob2Zmc2V0Pj1sZW4pcmV0dXJuO3ZhciB2YWw9cmVhZFVJbnQxNihidWYsb2Zmc2V0LGxpdHRsZUVuZGlhbix0cnVlKTt2YXIgbmVnPXZhbCYzMjc2ODtpZihuZWcpcmV0dXJuKDY1NTM1LXZhbCsxKSotMTtlbHNlIHJldHVybiB2YWx9QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbihvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiByZWFkSW50MTYodGhpcyxvZmZzZXQsdHJ1ZSxub0Fzc2VydCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkU9ZnVuY3Rpb24ob2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gcmVhZEludDE2KHRoaXMsb2Zmc2V0LGZhbHNlLG5vQXNzZXJ0KX07ZnVuY3Rpb24gcmVhZEludDMyKGJ1ZixvZmZzZXQsbGl0dGxlRW5kaWFuLG5vQXNzZXJ0KXtpZighbm9Bc3NlcnQpe2Fzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuPT09XCJib29sZWFuXCIsXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXCIpO2Fzc2VydChvZmZzZXQhPT11bmRlZmluZWQmJm9mZnNldCE9PW51bGwsXCJtaXNzaW5nIG9mZnNldFwiKTthc3NlcnQob2Zmc2V0KzM8YnVmLmxlbmd0aCxcIlRyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfXZhciBsZW49YnVmLmxlbmd0aDtpZihvZmZzZXQ+PWxlbilyZXR1cm47dmFyIHZhbD1yZWFkVUludDMyKGJ1ZixvZmZzZXQsbGl0dGxlRW5kaWFuLHRydWUpO3ZhciBuZWc9dmFsJjIxNDc0ODM2NDg7aWYobmVnKXJldHVybig0Mjk0OTY3Mjk1LXZhbCsxKSotMTtlbHNlIHJldHVybiB2YWx9QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRT1mdW5jdGlvbihvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiByZWFkSW50MzIodGhpcyxvZmZzZXQsdHJ1ZSxub0Fzc2VydCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkU9ZnVuY3Rpb24ob2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gcmVhZEludDMyKHRoaXMsb2Zmc2V0LGZhbHNlLG5vQXNzZXJ0KX07ZnVuY3Rpb24gcmVhZEZsb2F0KGJ1ZixvZmZzZXQsbGl0dGxlRW5kaWFuLG5vQXNzZXJ0KXtpZighbm9Bc3NlcnQpe2Fzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuPT09XCJib29sZWFuXCIsXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXCIpO2Fzc2VydChvZmZzZXQrMzxidWYubGVuZ3RoLFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIil9cmV0dXJuIGllZWU3NTQucmVhZChidWYsb2Zmc2V0LGxpdHRsZUVuZGlhbiwyMyw0KX1CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFPWZ1bmN0aW9uKG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHJlYWRGbG9hdCh0aGlzLG9mZnNldCx0cnVlLG5vQXNzZXJ0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbihvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiByZWFkRmxvYXQodGhpcyxvZmZzZXQsZmFsc2Usbm9Bc3NlcnQpfTtmdW5jdGlvbiByZWFkRG91YmxlKGJ1ZixvZmZzZXQsbGl0dGxlRW5kaWFuLG5vQXNzZXJ0KXtpZighbm9Bc3NlcnQpe2Fzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuPT09XCJib29sZWFuXCIsXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXCIpO2Fzc2VydChvZmZzZXQrNzxidWYubGVuZ3RoLFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIil9cmV0dXJuIGllZWU3NTQucmVhZChidWYsb2Zmc2V0LGxpdHRsZUVuZGlhbiw1Miw4KX1CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRT1mdW5jdGlvbihvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiByZWFkRG91YmxlKHRoaXMsb2Zmc2V0LHRydWUsbm9Bc3NlcnQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRT1mdW5jdGlvbihvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiByZWFkRG91YmxlKHRoaXMsb2Zmc2V0LGZhbHNlLG5vQXNzZXJ0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4PWZ1bmN0aW9uKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7aWYoIW5vQXNzZXJ0KXthc3NlcnQodmFsdWUhPT11bmRlZmluZWQmJnZhbHVlIT09bnVsbCxcIm1pc3NpbmcgdmFsdWVcIik7YXNzZXJ0KG9mZnNldCE9PXVuZGVmaW5lZCYmb2Zmc2V0IT09bnVsbCxcIm1pc3Npbmcgb2Zmc2V0XCIpO2Fzc2VydChvZmZzZXQ8dGhpcy5sZW5ndGgsXCJ0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIik7dmVyaWZ1aW50KHZhbHVlLDI1NSl9aWYob2Zmc2V0Pj10aGlzLmxlbmd0aClyZXR1cm47dGhpc1tvZmZzZXRdPXZhbHVlO3JldHVybiBvZmZzZXQrMX07ZnVuY3Rpb24gd3JpdGVVSW50MTYoYnVmLHZhbHVlLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpe2lmKCFub0Fzc2VydCl7YXNzZXJ0KHZhbHVlIT09dW5kZWZpbmVkJiZ2YWx1ZSE9PW51bGwsXCJtaXNzaW5nIHZhbHVlXCIpO2Fzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuPT09XCJib29sZWFuXCIsXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXCIpO2Fzc2VydChvZmZzZXQhPT11bmRlZmluZWQmJm9mZnNldCE9PW51bGwsXCJtaXNzaW5nIG9mZnNldFwiKTthc3NlcnQob2Zmc2V0KzE8YnVmLmxlbmd0aCxcInRyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKTt2ZXJpZnVpbnQodmFsdWUsNjU1MzUpfXZhciBsZW49YnVmLmxlbmd0aDtpZihvZmZzZXQ+PWxlbilyZXR1cm47Zm9yKHZhciBpPTAsaj1NYXRoLm1pbihsZW4tb2Zmc2V0LDIpO2k8ajtpKyspe2J1ZltvZmZzZXQraV09KHZhbHVlJjI1NTw8OCoobGl0dGxlRW5kaWFuP2k6MS1pKSk+Pj4obGl0dGxlRW5kaWFuP2k6MS1pKSo4fXJldHVybiBvZmZzZXQrMn1CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEU9ZnVuY3Rpb24odmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gd3JpdGVVSW50MTYodGhpcyx2YWx1ZSxvZmZzZXQsdHJ1ZSxub0Fzc2VydCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRT1mdW5jdGlvbih2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiB3cml0ZVVJbnQxNih0aGlzLHZhbHVlLG9mZnNldCxmYWxzZSxub0Fzc2VydCl9O2Z1bmN0aW9uIHdyaXRlVUludDMyKGJ1Zix2YWx1ZSxvZmZzZXQsbGl0dGxlRW5kaWFuLG5vQXNzZXJ0KXtpZighbm9Bc3NlcnQpe2Fzc2VydCh2YWx1ZSE9PXVuZGVmaW5lZCYmdmFsdWUhPT1udWxsLFwibWlzc2luZyB2YWx1ZVwiKTthc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbj09PVwiYm9vbGVhblwiLFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblwiKTthc3NlcnQob2Zmc2V0IT09dW5kZWZpbmVkJiZvZmZzZXQhPT1udWxsLFwibWlzc2luZyBvZmZzZXRcIik7YXNzZXJ0KG9mZnNldCszPGJ1Zi5sZW5ndGgsXCJ0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIik7dmVyaWZ1aW50KHZhbHVlLDQyOTQ5NjcyOTUpfXZhciBsZW49YnVmLmxlbmd0aDtpZihvZmZzZXQ+PWxlbilyZXR1cm47Zm9yKHZhciBpPTAsaj1NYXRoLm1pbihsZW4tb2Zmc2V0LDQpO2k8ajtpKyspe2J1ZltvZmZzZXQraV09dmFsdWU+Pj4obGl0dGxlRW5kaWFuP2k6My1pKSo4JjI1NX1yZXR1cm4gb2Zmc2V0KzR9QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFPWZ1bmN0aW9uKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHdyaXRlVUludDMyKHRoaXMsdmFsdWUsb2Zmc2V0LHRydWUsbm9Bc3NlcnQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkU9ZnVuY3Rpb24odmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gd3JpdGVVSW50MzIodGhpcyx2YWx1ZSxvZmZzZXQsZmFsc2Usbm9Bc3NlcnQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbih2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe2lmKCFub0Fzc2VydCl7YXNzZXJ0KHZhbHVlIT09dW5kZWZpbmVkJiZ2YWx1ZSE9PW51bGwsXCJtaXNzaW5nIHZhbHVlXCIpO2Fzc2VydChvZmZzZXQhPT11bmRlZmluZWQmJm9mZnNldCE9PW51bGwsXCJtaXNzaW5nIG9mZnNldFwiKTthc3NlcnQob2Zmc2V0PHRoaXMubGVuZ3RoLFwiVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpO3Zlcmlmc2ludCh2YWx1ZSwxMjcsLTEyOCl9aWYob2Zmc2V0Pj10aGlzLmxlbmd0aClyZXR1cm47aWYodmFsdWU+PTApdGhpcy53cml0ZVVJbnQ4KHZhbHVlLG9mZnNldCxub0Fzc2VydCk7ZWxzZSB0aGlzLndyaXRlVUludDgoMjU1K3ZhbHVlKzEsb2Zmc2V0LG5vQXNzZXJ0KTtyZXR1cm4gb2Zmc2V0KzF9O2Z1bmN0aW9uIHdyaXRlSW50MTYoYnVmLHZhbHVlLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpe2lmKCFub0Fzc2VydCl7YXNzZXJ0KHZhbHVlIT09dW5kZWZpbmVkJiZ2YWx1ZSE9PW51bGwsXCJtaXNzaW5nIHZhbHVlXCIpO2Fzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuPT09XCJib29sZWFuXCIsXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXCIpO2Fzc2VydChvZmZzZXQhPT11bmRlZmluZWQmJm9mZnNldCE9PW51bGwsXCJtaXNzaW5nIG9mZnNldFwiKTthc3NlcnQob2Zmc2V0KzE8YnVmLmxlbmd0aCxcIlRyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKTt2ZXJpZnNpbnQodmFsdWUsMzI3NjcsLTMyNzY4KX12YXIgbGVuPWJ1Zi5sZW5ndGg7aWYob2Zmc2V0Pj1sZW4pcmV0dXJuO2lmKHZhbHVlPj0wKXdyaXRlVUludDE2KGJ1Zix2YWx1ZSxvZmZzZXQsbGl0dGxlRW5kaWFuLG5vQXNzZXJ0KTtlbHNlIHdyaXRlVUludDE2KGJ1Ziw2NTUzNSt2YWx1ZSsxLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpO3JldHVybiBvZmZzZXQrMn1CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbih2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiB3cml0ZUludDE2KHRoaXMsdmFsdWUsb2Zmc2V0LHRydWUsbm9Bc3NlcnQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRT1mdW5jdGlvbih2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiB3cml0ZUludDE2KHRoaXMsdmFsdWUsb2Zmc2V0LGZhbHNlLG5vQXNzZXJ0KX07ZnVuY3Rpb24gd3JpdGVJbnQzMihidWYsdmFsdWUsb2Zmc2V0LGxpdHRsZUVuZGlhbixub0Fzc2VydCl7aWYoIW5vQXNzZXJ0KXthc3NlcnQodmFsdWUhPT11bmRlZmluZWQmJnZhbHVlIT09bnVsbCxcIm1pc3NpbmcgdmFsdWVcIik7YXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW49PT1cImJvb2xlYW5cIixcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cIik7YXNzZXJ0KG9mZnNldCE9PXVuZGVmaW5lZCYmb2Zmc2V0IT09bnVsbCxcIm1pc3Npbmcgb2Zmc2V0XCIpO2Fzc2VydChvZmZzZXQrMzxidWYubGVuZ3RoLFwiVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpO3Zlcmlmc2ludCh2YWx1ZSwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KX12YXIgbGVuPWJ1Zi5sZW5ndGg7aWYob2Zmc2V0Pj1sZW4pcmV0dXJuO2lmKHZhbHVlPj0wKXdyaXRlVUludDMyKGJ1Zix2YWx1ZSxvZmZzZXQsbGl0dGxlRW5kaWFuLG5vQXNzZXJ0KTtlbHNlIHdyaXRlVUludDMyKGJ1Ziw0Mjk0OTY3Mjk1K3ZhbHVlKzEsb2Zmc2V0LGxpdHRsZUVuZGlhbixub0Fzc2VydCk7cmV0dXJuIG9mZnNldCs0fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFPWZ1bmN0aW9uKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHdyaXRlSW50MzIodGhpcyx2YWx1ZSxvZmZzZXQsdHJ1ZSxub0Fzc2VydCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHdyaXRlSW50MzIodGhpcyx2YWx1ZSxvZmZzZXQsZmFsc2Usbm9Bc3NlcnQpfTtmdW5jdGlvbiB3cml0ZUZsb2F0KGJ1Zix2YWx1ZSxvZmZzZXQsbGl0dGxlRW5kaWFuLG5vQXNzZXJ0KXtpZighbm9Bc3NlcnQpe2Fzc2VydCh2YWx1ZSE9PXVuZGVmaW5lZCYmdmFsdWUhPT1udWxsLFwibWlzc2luZyB2YWx1ZVwiKTthc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbj09PVwiYm9vbGVhblwiLFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblwiKTthc3NlcnQob2Zmc2V0IT09dW5kZWZpbmVkJiZvZmZzZXQhPT1udWxsLFwibWlzc2luZyBvZmZzZXRcIik7YXNzZXJ0KG9mZnNldCszPGJ1Zi5sZW5ndGgsXCJUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIik7dmVyaWZJRUVFNzU0KHZhbHVlLDMuNDAyODIzNDY2Mzg1Mjg4NmUzOCwtMy40MDI4MjM0NjYzODUyODg2ZTM4KX12YXIgbGVuPWJ1Zi5sZW5ndGg7aWYob2Zmc2V0Pj1sZW4pcmV0dXJuO2llZWU3NTQud3JpdGUoYnVmLHZhbHVlLG9mZnNldCxsaXR0bGVFbmRpYW4sMjMsNCk7cmV0dXJuIG9mZnNldCs0XG59QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEU9ZnVuY3Rpb24odmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gd3JpdGVGbG9hdCh0aGlzLHZhbHVlLG9mZnNldCx0cnVlLG5vQXNzZXJ0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24odmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gd3JpdGVGbG9hdCh0aGlzLHZhbHVlLG9mZnNldCxmYWxzZSxub0Fzc2VydCl9O2Z1bmN0aW9uIHdyaXRlRG91YmxlKGJ1Zix2YWx1ZSxvZmZzZXQsbGl0dGxlRW5kaWFuLG5vQXNzZXJ0KXtpZighbm9Bc3NlcnQpe2Fzc2VydCh2YWx1ZSE9PXVuZGVmaW5lZCYmdmFsdWUhPT1udWxsLFwibWlzc2luZyB2YWx1ZVwiKTthc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbj09PVwiYm9vbGVhblwiLFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblwiKTthc3NlcnQob2Zmc2V0IT09dW5kZWZpbmVkJiZvZmZzZXQhPT1udWxsLFwibWlzc2luZyBvZmZzZXRcIik7YXNzZXJ0KG9mZnNldCs3PGJ1Zi5sZW5ndGgsXCJUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIik7dmVyaWZJRUVFNzU0KHZhbHVlLDEuNzk3NjkzMTM0ODYyMzE1N2UzMDgsLTEuNzk3NjkzMTM0ODYyMzE1N2UzMDgpfXZhciBsZW49YnVmLmxlbmd0aDtpZihvZmZzZXQ+PWxlbilyZXR1cm47aWVlZTc1NC53cml0ZShidWYsdmFsdWUsb2Zmc2V0LGxpdHRsZUVuZGlhbiw1Miw4KTtyZXR1cm4gb2Zmc2V0Kzh9QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFPWZ1bmN0aW9uKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsdmFsdWUsb2Zmc2V0LHRydWUsbm9Bc3NlcnQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkU9ZnVuY3Rpb24odmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gd3JpdGVEb3VibGUodGhpcyx2YWx1ZSxvZmZzZXQsZmFsc2Usbm9Bc3NlcnQpfTtCdWZmZXIucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24odmFsdWUsc3RhcnQsZW5kKXtpZighdmFsdWUpdmFsdWU9MDtpZighc3RhcnQpc3RhcnQ9MDtpZighZW5kKWVuZD10aGlzLmxlbmd0aDthc3NlcnQoZW5kPj1zdGFydCxcImVuZCA8IHN0YXJ0XCIpO2lmKGVuZD09PXN0YXJ0KXJldHVybjtpZih0aGlzLmxlbmd0aD09PTApcmV0dXJuO2Fzc2VydChzdGFydD49MCYmc3RhcnQ8dGhpcy5sZW5ndGgsXCJzdGFydCBvdXQgb2YgYm91bmRzXCIpO2Fzc2VydChlbmQ+PTAmJmVuZDw9dGhpcy5sZW5ndGgsXCJlbmQgb3V0IG9mIGJvdW5kc1wiKTt2YXIgaTtpZih0eXBlb2YgdmFsdWU9PT1cIm51bWJlclwiKXtmb3IoaT1zdGFydDtpPGVuZDtpKyspe3RoaXNbaV09dmFsdWV9fWVsc2V7dmFyIGJ5dGVzPXV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpO3ZhciBsZW49Ynl0ZXMubGVuZ3RoO2ZvcihpPXN0YXJ0O2k8ZW5kO2krKyl7dGhpc1tpXT1ieXRlc1tpJWxlbl19fXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24oKXt2YXIgb3V0PVtdO3ZhciBsZW49dGhpcy5sZW5ndGg7Zm9yKHZhciBpPTA7aTxsZW47aSsrKXtvdXRbaV09dG9IZXgodGhpc1tpXSk7aWYoaT09PWV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpe291dFtpKzFdPVwiLi4uXCI7YnJlYWt9fXJldHVyblwiPEJ1ZmZlciBcIitvdXQuam9pbihcIiBcIikrXCI+XCJ9O0J1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlcj1mdW5jdGlvbigpe2lmKHR5cGVvZiBVaW50OEFycmF5IT09XCJ1bmRlZmluZWRcIil7aWYoQnVmZmVyLl91c2VUeXBlZEFycmF5cyl7cmV0dXJuIG5ldyBCdWZmZXIodGhpcykuYnVmZmVyfWVsc2V7dmFyIGJ1Zj1uZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCk7Zm9yKHZhciBpPTAsbGVuPWJ1Zi5sZW5ndGg7aTxsZW47aSs9MSl7YnVmW2ldPXRoaXNbaV19cmV0dXJuIGJ1Zi5idWZmZXJ9fWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIil9fTt2YXIgQlA9QnVmZmVyLnByb3RvdHlwZTtCdWZmZXIuX2F1Z21lbnQ9ZnVuY3Rpb24oYXJyKXthcnIuX2lzQnVmZmVyPXRydWU7YXJyLl9nZXQ9YXJyLmdldDthcnIuX3NldD1hcnIuc2V0O2Fyci5nZXQ9QlAuZ2V0O2Fyci5zZXQ9QlAuc2V0O2Fyci53cml0ZT1CUC53cml0ZTthcnIudG9TdHJpbmc9QlAudG9TdHJpbmc7YXJyLnRvTG9jYWxlU3RyaW5nPUJQLnRvU3RyaW5nO2Fyci50b0pTT049QlAudG9KU09OO2Fyci5lcXVhbHM9QlAuZXF1YWxzO2Fyci5jb21wYXJlPUJQLmNvbXBhcmU7YXJyLmNvcHk9QlAuY29weTthcnIuc2xpY2U9QlAuc2xpY2U7YXJyLnJlYWRVSW50OD1CUC5yZWFkVUludDg7YXJyLnJlYWRVSW50MTZMRT1CUC5yZWFkVUludDE2TEU7YXJyLnJlYWRVSW50MTZCRT1CUC5yZWFkVUludDE2QkU7YXJyLnJlYWRVSW50MzJMRT1CUC5yZWFkVUludDMyTEU7YXJyLnJlYWRVSW50MzJCRT1CUC5yZWFkVUludDMyQkU7YXJyLnJlYWRJbnQ4PUJQLnJlYWRJbnQ4O2Fyci5yZWFkSW50MTZMRT1CUC5yZWFkSW50MTZMRTthcnIucmVhZEludDE2QkU9QlAucmVhZEludDE2QkU7YXJyLnJlYWRJbnQzMkxFPUJQLnJlYWRJbnQzMkxFO2Fyci5yZWFkSW50MzJCRT1CUC5yZWFkSW50MzJCRTthcnIucmVhZEZsb2F0TEU9QlAucmVhZEZsb2F0TEU7YXJyLnJlYWRGbG9hdEJFPUJQLnJlYWRGbG9hdEJFO2Fyci5yZWFkRG91YmxlTEU9QlAucmVhZERvdWJsZUxFO2Fyci5yZWFkRG91YmxlQkU9QlAucmVhZERvdWJsZUJFO2Fyci53cml0ZVVJbnQ4PUJQLndyaXRlVUludDg7YXJyLndyaXRlVUludDE2TEU9QlAud3JpdGVVSW50MTZMRTthcnIud3JpdGVVSW50MTZCRT1CUC53cml0ZVVJbnQxNkJFO2Fyci53cml0ZVVJbnQzMkxFPUJQLndyaXRlVUludDMyTEU7YXJyLndyaXRlVUludDMyQkU9QlAud3JpdGVVSW50MzJCRTthcnIud3JpdGVJbnQ4PUJQLndyaXRlSW50ODthcnIud3JpdGVJbnQxNkxFPUJQLndyaXRlSW50MTZMRTthcnIud3JpdGVJbnQxNkJFPUJQLndyaXRlSW50MTZCRTthcnIud3JpdGVJbnQzMkxFPUJQLndyaXRlSW50MzJMRTthcnIud3JpdGVJbnQzMkJFPUJQLndyaXRlSW50MzJCRTthcnIud3JpdGVGbG9hdExFPUJQLndyaXRlRmxvYXRMRTthcnIud3JpdGVGbG9hdEJFPUJQLndyaXRlRmxvYXRCRTthcnIud3JpdGVEb3VibGVMRT1CUC53cml0ZURvdWJsZUxFO2Fyci53cml0ZURvdWJsZUJFPUJQLndyaXRlRG91YmxlQkU7YXJyLmZpbGw9QlAuZmlsbDthcnIuaW5zcGVjdD1CUC5pbnNwZWN0O2Fyci50b0FycmF5QnVmZmVyPUJQLnRvQXJyYXlCdWZmZXI7cmV0dXJuIGFycn07ZnVuY3Rpb24gc3RyaW5ndHJpbShzdHIpe2lmKHN0ci50cmltKXJldHVybiBzdHIudHJpbSgpO3JldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZyxcIlwiKX1mdW5jdGlvbiBjbGFtcChpbmRleCxsZW4sZGVmYXVsdFZhbHVlKXtpZih0eXBlb2YgaW5kZXghPT1cIm51bWJlclwiKXJldHVybiBkZWZhdWx0VmFsdWU7aW5kZXg9fn5pbmRleDtpZihpbmRleD49bGVuKXJldHVybiBsZW47aWYoaW5kZXg+PTApcmV0dXJuIGluZGV4O2luZGV4Kz1sZW47aWYoaW5kZXg+PTApcmV0dXJuIGluZGV4O3JldHVybiAwfWZ1bmN0aW9uIGNvZXJjZShsZW5ndGgpe2xlbmd0aD1+fk1hdGguY2VpbCgrbGVuZ3RoKTtyZXR1cm4gbGVuZ3RoPDA/MDpsZW5ndGh9ZnVuY3Rpb24gaXNBcnJheShzdWJqZWN0KXtyZXR1cm4oQXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oc3ViamVjdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdWJqZWN0KT09PVwiW29iamVjdCBBcnJheV1cIn0pKHN1YmplY3QpfWZ1bmN0aW9uIGlzQXJyYXlpc2goc3ViamVjdCl7cmV0dXJuIGlzQXJyYXkoc3ViamVjdCl8fEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KXx8c3ViamVjdCYmdHlwZW9mIHN1YmplY3Q9PT1cIm9iamVjdFwiJiZ0eXBlb2Ygc3ViamVjdC5sZW5ndGg9PT1cIm51bWJlclwifWZ1bmN0aW9uIHRvSGV4KG4pe2lmKG48MTYpcmV0dXJuXCIwXCIrbi50b1N0cmluZygxNik7cmV0dXJuIG4udG9TdHJpbmcoMTYpfWZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cil7dmFyIGJ5dGVBcnJheT1bXTtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7aSsrKXt2YXIgYj1zdHIuY2hhckNvZGVBdChpKTtpZihiPD0xMjcpe2J5dGVBcnJheS5wdXNoKGIpfWVsc2V7dmFyIHN0YXJ0PWk7aWYoYj49NTUyOTYmJmI8PTU3MzQzKWkrKzt2YXIgaD1lbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LGkrMSkpLnN1YnN0cigxKS5zcGxpdChcIiVcIik7Zm9yKHZhciBqPTA7ajxoLmxlbmd0aDtqKyspe2J5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sMTYpKX19fXJldHVybiBieXRlQXJyYXl9ZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cil7dmFyIGJ5dGVBcnJheT1bXTtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7aSsrKXtieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSYyNTUpfXJldHVybiBieXRlQXJyYXl9ZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMoc3RyKXt2YXIgYyxoaSxsbzt2YXIgYnl0ZUFycmF5PVtdO2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDtpKyspe2M9c3RyLmNoYXJDb2RlQXQoaSk7aGk9Yz4+ODtsbz1jJTI1NjtieXRlQXJyYXkucHVzaChsbyk7Ynl0ZUFycmF5LnB1c2goaGkpfXJldHVybiBieXRlQXJyYXl9ZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyhzdHIpe3JldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKX1mdW5jdGlvbiBibGl0QnVmZmVyKHNyYyxkc3Qsb2Zmc2V0LGxlbmd0aCl7Zm9yKHZhciBpPTA7aTxsZW5ndGg7aSsrKXtpZihpK29mZnNldD49ZHN0Lmxlbmd0aHx8aT49c3JjLmxlbmd0aClicmVhaztkc3RbaStvZmZzZXRdPXNyY1tpXX1yZXR1cm4gaX1mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhcihzdHIpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cil9Y2F0Y2goZXJyKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg2NTUzMyl9fWZ1bmN0aW9uIHZlcmlmdWludCh2YWx1ZSxtYXgpe2Fzc2VydCh0eXBlb2YgdmFsdWU9PT1cIm51bWJlclwiLFwiY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlclwiKTthc3NlcnQodmFsdWU+PTAsXCJzcGVjaWZpZWQgYSBuZWdhdGl2ZSB2YWx1ZSBmb3Igd3JpdGluZyBhbiB1bnNpZ25lZCB2YWx1ZVwiKTthc3NlcnQodmFsdWU8PW1heCxcInZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGVcIik7YXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpPT09dmFsdWUsXCJ2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudFwiKX1mdW5jdGlvbiB2ZXJpZnNpbnQodmFsdWUsbWF4LG1pbil7YXNzZXJ0KHR5cGVvZiB2YWx1ZT09PVwibnVtYmVyXCIsXCJjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyXCIpO2Fzc2VydCh2YWx1ZTw9bWF4LFwidmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlXCIpO2Fzc2VydCh2YWx1ZT49bWluLFwidmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZVwiKTthc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSk9PT12YWx1ZSxcInZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50XCIpfWZ1bmN0aW9uIHZlcmlmSUVFRTc1NCh2YWx1ZSxtYXgsbWluKXthc3NlcnQodHlwZW9mIHZhbHVlPT09XCJudW1iZXJcIixcImNhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXJcIik7YXNzZXJ0KHZhbHVlPD1tYXgsXCJ2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWVcIik7YXNzZXJ0KHZhbHVlPj1taW4sXCJ2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlXCIpfWZ1bmN0aW9uIGFzc2VydCh0ZXN0LG1lc3NhZ2Upe2lmKCF0ZXN0KXRocm93IG5ldyBFcnJvcihtZXNzYWdlfHxcIkZhaWxlZCBhc3NlcnRpb25cIil9fSx7XCJiYXNlNjQtanNcIjo2LGllZWU3NTQ6N31dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBsb29rdXA9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7KGZ1bmN0aW9uKGV4cG9ydHMpe1widXNlIHN0cmljdFwiO3ZhciBBcnI9dHlwZW9mIFVpbnQ4QXJyYXkhPT1cInVuZGVmaW5lZFwiP1VpbnQ4QXJyYXk6QXJyYXk7dmFyIFpFUk89XCIwXCIuY2hhckNvZGVBdCgwKTt2YXIgUExVUz1cIitcIi5jaGFyQ29kZUF0KDApO3ZhciBTTEFTSD1cIi9cIi5jaGFyQ29kZUF0KDApO3ZhciBOVU1CRVI9XCIwXCIuY2hhckNvZGVBdCgwKTt2YXIgTE9XRVI9XCJhXCIuY2hhckNvZGVBdCgwKTt2YXIgVVBQRVI9XCJBXCIuY2hhckNvZGVBdCgwKTtmdW5jdGlvbiBkZWNvZGUoZWx0KXt2YXIgY29kZT1lbHQuY2hhckNvZGVBdCgwKTtpZihjb2RlPT09UExVUylyZXR1cm4gNjI7aWYoY29kZT09PVNMQVNIKXJldHVybiA2MztpZihjb2RlPE5VTUJFUilyZXR1cm4tMTtpZihjb2RlPE5VTUJFUisxMClyZXR1cm4gY29kZS1OVU1CRVIrMjYrMjY7aWYoY29kZTxVUFBFUisyNilyZXR1cm4gY29kZS1VUFBFUjtpZihjb2RlPExPV0VSKzI2KXJldHVybiBjb2RlLUxPV0VSKzI2fWZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5KGI2NCl7dmFyIGksaixsLHRtcCxwbGFjZUhvbGRlcnMsYXJyO2lmKGI2NC5sZW5ndGglND4wKXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpfXZhciBsZW49YjY0Lmxlbmd0aDtwbGFjZUhvbGRlcnM9XCI9XCI9PT1iNjQuY2hhckF0KGxlbi0yKT8yOlwiPVwiPT09YjY0LmNoYXJBdChsZW4tMSk/MTowO2Fycj1uZXcgQXJyKGI2NC5sZW5ndGgqMy80LXBsYWNlSG9sZGVycyk7bD1wbGFjZUhvbGRlcnM+MD9iNjQubGVuZ3RoLTQ6YjY0Lmxlbmd0aDt2YXIgTD0wO2Z1bmN0aW9uIHB1c2godil7YXJyW0wrK109dn1mb3IoaT0wLGo9MDtpPGw7aSs9NCxqKz0zKXt0bXA9ZGVjb2RlKGI2NC5jaGFyQXQoaSkpPDwxOHxkZWNvZGUoYjY0LmNoYXJBdChpKzEpKTw8MTJ8ZGVjb2RlKGI2NC5jaGFyQXQoaSsyKSk8PDZ8ZGVjb2RlKGI2NC5jaGFyQXQoaSszKSk7cHVzaCgodG1wJjE2NzExNjgwKT4+MTYpO3B1c2goKHRtcCY2NTI4MCk+PjgpO3B1c2godG1wJjI1NSl9aWYocGxhY2VIb2xkZXJzPT09Mil7dG1wPWRlY29kZShiNjQuY2hhckF0KGkpKTw8MnxkZWNvZGUoYjY0LmNoYXJBdChpKzEpKT4+NDtwdXNoKHRtcCYyNTUpfWVsc2UgaWYocGxhY2VIb2xkZXJzPT09MSl7dG1wPWRlY29kZShiNjQuY2hhckF0KGkpKTw8MTB8ZGVjb2RlKGI2NC5jaGFyQXQoaSsxKSk8PDR8ZGVjb2RlKGI2NC5jaGFyQXQoaSsyKSk+PjI7cHVzaCh0bXA+PjgmMjU1KTtwdXNoKHRtcCYyNTUpfXJldHVybiBhcnJ9ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCh1aW50OCl7dmFyIGksZXh0cmFCeXRlcz11aW50OC5sZW5ndGglMyxvdXRwdXQ9XCJcIix0ZW1wLGxlbmd0aDtmdW5jdGlvbiBlbmNvZGUobnVtKXtyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pfWZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NChudW0pe3JldHVybiBlbmNvZGUobnVtPj4xOCY2MykrZW5jb2RlKG51bT4+MTImNjMpK2VuY29kZShudW0+PjYmNjMpK2VuY29kZShudW0mNjMpfWZvcihpPTAsbGVuZ3RoPXVpbnQ4Lmxlbmd0aC1leHRyYUJ5dGVzO2k8bGVuZ3RoO2krPTMpe3RlbXA9KHVpbnQ4W2ldPDwxNikrKHVpbnQ4W2krMV08PDgpK3VpbnQ4W2krMl07b3V0cHV0Kz10cmlwbGV0VG9CYXNlNjQodGVtcCl9c3dpdGNoKGV4dHJhQnl0ZXMpe2Nhc2UgMTp0ZW1wPXVpbnQ4W3VpbnQ4Lmxlbmd0aC0xXTtvdXRwdXQrPWVuY29kZSh0ZW1wPj4yKTtvdXRwdXQrPWVuY29kZSh0ZW1wPDw0JjYzKTtvdXRwdXQrPVwiPT1cIjticmVhaztjYXNlIDI6dGVtcD0odWludDhbdWludDgubGVuZ3RoLTJdPDw4KSt1aW50OFt1aW50OC5sZW5ndGgtMV07b3V0cHV0Kz1lbmNvZGUodGVtcD4+MTApO291dHB1dCs9ZW5jb2RlKHRlbXA+PjQmNjMpO291dHB1dCs9ZW5jb2RlKHRlbXA8PDImNjMpO291dHB1dCs9XCI9XCI7YnJlYWt9cmV0dXJuIG91dHB1dH1tb2R1bGUuZXhwb3J0cy50b0J5dGVBcnJheT1iNjRUb0J5dGVBcnJheTttb2R1bGUuZXhwb3J0cy5mcm9tQnl0ZUFycmF5PXVpbnQ4VG9CYXNlNjR9KSgpfSx7fV0sNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7ZXhwb3J0cy5yZWFkPWZ1bmN0aW9uKGJ1ZmZlcixvZmZzZXQsaXNMRSxtTGVuLG5CeXRlcyl7dmFyIGUsbSxlTGVuPW5CeXRlcyo4LW1MZW4tMSxlTWF4PSgxPDxlTGVuKS0xLGVCaWFzPWVNYXg+PjEsbkJpdHM9LTcsaT1pc0xFP25CeXRlcy0xOjAsZD1pc0xFPy0xOjEscz1idWZmZXJbb2Zmc2V0K2ldO2krPWQ7ZT1zJigxPDwtbkJpdHMpLTE7cz4+PS1uQml0cztuQml0cys9ZUxlbjtmb3IoO25CaXRzPjA7ZT1lKjI1NitidWZmZXJbb2Zmc2V0K2ldLGkrPWQsbkJpdHMtPTgpO209ZSYoMTw8LW5CaXRzKS0xO2U+Pj0tbkJpdHM7bkJpdHMrPW1MZW47Zm9yKDtuQml0cz4wO209bSoyNTYrYnVmZmVyW29mZnNldCtpXSxpKz1kLG5CaXRzLT04KTtpZihlPT09MCl7ZT0xLWVCaWFzfWVsc2UgaWYoZT09PWVNYXgpe3JldHVybiBtP05hTjoocz8tMToxKSpJbmZpbml0eX1lbHNle209bStNYXRoLnBvdygyLG1MZW4pO2U9ZS1lQmlhc31yZXR1cm4ocz8tMToxKSptKk1hdGgucG93KDIsZS1tTGVuKX07ZXhwb3J0cy53cml0ZT1mdW5jdGlvbihidWZmZXIsdmFsdWUsb2Zmc2V0LGlzTEUsbUxlbixuQnl0ZXMpe3ZhciBlLG0sYyxlTGVuPW5CeXRlcyo4LW1MZW4tMSxlTWF4PSgxPDxlTGVuKS0xLGVCaWFzPWVNYXg+PjEscnQ9bUxlbj09PTIzP01hdGgucG93KDIsLTI0KS1NYXRoLnBvdygyLC03Nyk6MCxpPWlzTEU/MDpuQnl0ZXMtMSxkPWlzTEU/MTotMSxzPXZhbHVlPDB8fHZhbHVlPT09MCYmMS92YWx1ZTwwPzE6MDt2YWx1ZT1NYXRoLmFicyh2YWx1ZSk7aWYoaXNOYU4odmFsdWUpfHx2YWx1ZT09PUluZmluaXR5KXttPWlzTmFOKHZhbHVlKT8xOjA7ZT1lTWF4fWVsc2V7ZT1NYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKS9NYXRoLkxOMik7aWYodmFsdWUqKGM9TWF0aC5wb3coMiwtZSkpPDEpe2UtLTtjKj0yfWlmKGUrZUJpYXM+PTEpe3ZhbHVlKz1ydC9jfWVsc2V7dmFsdWUrPXJ0Kk1hdGgucG93KDIsMS1lQmlhcyl9aWYodmFsdWUqYz49Mil7ZSsrO2MvPTJ9aWYoZStlQmlhcz49ZU1heCl7bT0wO2U9ZU1heH1lbHNlIGlmKGUrZUJpYXM+PTEpe209KHZhbHVlKmMtMSkqTWF0aC5wb3coMixtTGVuKTtlPWUrZUJpYXN9ZWxzZXttPXZhbHVlKk1hdGgucG93KDIsZUJpYXMtMSkqTWF0aC5wb3coMixtTGVuKTtlPTB9fWZvcig7bUxlbj49ODtidWZmZXJbb2Zmc2V0K2ldPW0mMjU1LGkrPWQsbS89MjU2LG1MZW4tPTgpO2U9ZTw8bUxlbnxtO2VMZW4rPW1MZW47Zm9yKDtlTGVuPjA7YnVmZmVyW29mZnNldCtpXT1lJjI1NSxpKz1kLGUvPTI1NixlTGVuLT04KTtidWZmZXJbb2Zmc2V0K2ktZF18PXMqMTI4fX0se31dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBCdWZmZXI9X2RlcmVxXyhcImJ1ZmZlclwiKS5CdWZmZXI7dmFyIGludFNpemU9NDt2YXIgemVyb0J1ZmZlcj1uZXcgQnVmZmVyKGludFNpemUpO3plcm9CdWZmZXIuZmlsbCgwKTt2YXIgY2hyc3o9ODtmdW5jdGlvbiB0b0FycmF5KGJ1ZixiaWdFbmRpYW4pe2lmKGJ1Zi5sZW5ndGglaW50U2l6ZSE9PTApe3ZhciBsZW49YnVmLmxlbmd0aCsoaW50U2l6ZS1idWYubGVuZ3RoJWludFNpemUpO2J1Zj1CdWZmZXIuY29uY2F0KFtidWYsemVyb0J1ZmZlcl0sbGVuKX12YXIgYXJyPVtdO3ZhciBmbj1iaWdFbmRpYW4/YnVmLnJlYWRJbnQzMkJFOmJ1Zi5yZWFkSW50MzJMRTtmb3IodmFyIGk9MDtpPGJ1Zi5sZW5ndGg7aSs9aW50U2l6ZSl7YXJyLnB1c2goZm4uY2FsbChidWYsaSkpfXJldHVybiBhcnJ9ZnVuY3Rpb24gdG9CdWZmZXIoYXJyLHNpemUsYmlnRW5kaWFuKXt2YXIgYnVmPW5ldyBCdWZmZXIoc2l6ZSk7dmFyIGZuPWJpZ0VuZGlhbj9idWYud3JpdGVJbnQzMkJFOmJ1Zi53cml0ZUludDMyTEU7Zm9yKHZhciBpPTA7aTxhcnIubGVuZ3RoO2krKyl7Zm4uY2FsbChidWYsYXJyW2ldLGkqNCx0cnVlKX1yZXR1cm4gYnVmfWZ1bmN0aW9uIGhhc2goYnVmLGZuLGhhc2hTaXplLGJpZ0VuZGlhbil7aWYoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKWJ1Zj1uZXcgQnVmZmVyKGJ1Zik7dmFyIGFycj1mbih0b0FycmF5KGJ1ZixiaWdFbmRpYW4pLGJ1Zi5sZW5ndGgqY2hyc3opO3JldHVybiB0b0J1ZmZlcihhcnIsaGFzaFNpemUsYmlnRW5kaWFuKX1tb2R1bGUuZXhwb3J0cz17aGFzaDpoYXNofX0se2J1ZmZlcjo1fV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIEJ1ZmZlcj1fZGVyZXFfKFwiYnVmZmVyXCIpLkJ1ZmZlcjt2YXIgc2hhPV9kZXJlcV8oXCIuL3NoYVwiKTt2YXIgc2hhMjU2PV9kZXJlcV8oXCIuL3NoYTI1NlwiKTt2YXIgcm5nPV9kZXJlcV8oXCIuL3JuZ1wiKTt2YXIgbWQ1PV9kZXJlcV8oXCIuL21kNVwiKTt2YXIgYWxnb3JpdGhtcz17c2hhMTpzaGEsc2hhMjU2OnNoYTI1NixtZDU6bWQ1fTt2YXIgYmxvY2tzaXplPTY0O3ZhciB6ZXJvQnVmZmVyPW5ldyBCdWZmZXIoYmxvY2tzaXplKTt6ZXJvQnVmZmVyLmZpbGwoMCk7ZnVuY3Rpb24gaG1hYyhmbixrZXksZGF0YSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihrZXkpKWtleT1uZXcgQnVmZmVyKGtleSk7aWYoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSlkYXRhPW5ldyBCdWZmZXIoZGF0YSk7aWYoa2V5Lmxlbmd0aD5ibG9ja3NpemUpe2tleT1mbihrZXkpfWVsc2UgaWYoa2V5Lmxlbmd0aDxibG9ja3NpemUpe2tleT1CdWZmZXIuY29uY2F0KFtrZXksemVyb0J1ZmZlcl0sYmxvY2tzaXplKX12YXIgaXBhZD1uZXcgQnVmZmVyKGJsb2Nrc2l6ZSksb3BhZD1uZXcgQnVmZmVyKGJsb2Nrc2l6ZSk7Zm9yKHZhciBpPTA7aTxibG9ja3NpemU7aSsrKXtpcGFkW2ldPWtleVtpXV41NDtvcGFkW2ldPWtleVtpXV45Mn12YXIgaGFzaD1mbihCdWZmZXIuY29uY2F0KFtpcGFkLGRhdGFdKSk7cmV0dXJuIGZuKEJ1ZmZlci5jb25jYXQoW29wYWQsaGFzaF0pKX1mdW5jdGlvbiBoYXNoKGFsZyxrZXkpe2FsZz1hbGd8fFwic2hhMVwiO3ZhciBmbj1hbGdvcml0aG1zW2FsZ107dmFyIGJ1ZnM9W107dmFyIGxlbmd0aD0wO2lmKCFmbillcnJvcihcImFsZ29yaXRobTpcIixhbGcsXCJpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtyZXR1cm57dXBkYXRlOmZ1bmN0aW9uKGRhdGEpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpZGF0YT1uZXcgQnVmZmVyKGRhdGEpO2J1ZnMucHVzaChkYXRhKTtsZW5ndGgrPWRhdGEubGVuZ3RoO3JldHVybiB0aGlzfSxkaWdlc3Q6ZnVuY3Rpb24oZW5jKXt2YXIgYnVmPUJ1ZmZlci5jb25jYXQoYnVmcyk7dmFyIHI9a2V5P2htYWMoZm4sa2V5LGJ1Zik6Zm4oYnVmKTtidWZzPW51bGw7cmV0dXJuIGVuYz9yLnRvU3RyaW5nKGVuYyk6cn19fWZ1bmN0aW9uIGVycm9yKCl7dmFyIG09W10uc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO3Rocm93IG5ldyBFcnJvcihbbSxcIndlIGFjY2VwdCBwdWxsIHJlcXVlc3RzXCIsXCJodHRwOi8vZ2l0aHViLmNvbS9kb21pbmljdGFyci9jcnlwdG8tYnJvd3NlcmlmeVwiXS5qb2luKFwiXFxuXCIpKX1leHBvcnRzLmNyZWF0ZUhhc2g9ZnVuY3Rpb24oYWxnKXtyZXR1cm4gaGFzaChhbGcpfTtleHBvcnRzLmNyZWF0ZUhtYWM9ZnVuY3Rpb24oYWxnLGtleSl7cmV0dXJuIGhhc2goYWxnLGtleSl9O2V4cG9ydHMucmFuZG9tQnl0ZXM9ZnVuY3Rpb24oc2l6ZSxjYWxsYmFjayl7aWYoY2FsbGJhY2smJmNhbGxiYWNrLmNhbGwpe3RyeXtjYWxsYmFjay5jYWxsKHRoaXMsdW5kZWZpbmVkLG5ldyBCdWZmZXIocm5nKHNpemUpKSl9Y2F0Y2goZXJyKXtjYWxsYmFjayhlcnIpfX1lbHNle3JldHVybiBuZXcgQnVmZmVyKHJuZyhzaXplKSl9fTtmdW5jdGlvbiBlYWNoKGEsZil7Zm9yKHZhciBpIGluIGEpZihhW2ldLGkpfWVhY2goW1wiY3JlYXRlQ3JlZGVudGlhbHNcIixcImNyZWF0ZUNpcGhlclwiLFwiY3JlYXRlQ2lwaGVyaXZcIixcImNyZWF0ZURlY2lwaGVyXCIsXCJjcmVhdGVEZWNpcGhlcml2XCIsXCJjcmVhdGVTaWduXCIsXCJjcmVhdGVWZXJpZnlcIixcImNyZWF0ZURpZmZpZUhlbGxtYW5cIixcInBia2RmMlwiXSxmdW5jdGlvbihuYW1lKXtleHBvcnRzW25hbWVdPWZ1bmN0aW9uKCl7ZXJyb3IoXCJzb3JyeSxcIixuYW1lLFwiaXMgbm90IGltcGxlbWVudGVkIHlldFwiKX19KX0se1wiLi9tZDVcIjoxMCxcIi4vcm5nXCI6MTEsXCIuL3NoYVwiOjEyLFwiLi9zaGEyNTZcIjoxMyxidWZmZXI6NX1dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgaGVscGVycz1fZGVyZXFfKFwiLi9oZWxwZXJzXCIpO2Z1bmN0aW9uIG1kNV92bV90ZXN0KCl7cmV0dXJuIGhleF9tZDUoXCJhYmNcIik9PVwiOTAwMTUwOTgzY2QyNGZiMGQ2OTYzZjdkMjhlMTdmNzJcIn1mdW5jdGlvbiBjb3JlX21kNSh4LGxlbil7eFtsZW4+PjVdfD0xMjg8PGxlbiUzMjt4WyhsZW4rNjQ+Pj45PDw0KSsxNF09bGVuO3ZhciBhPTE3MzI1ODQxOTM7dmFyIGI9LTI3MTczMzg3OTt2YXIgYz0tMTczMjU4NDE5NDt2YXIgZD0yNzE3MzM4Nzg7Zm9yKHZhciBpPTA7aTx4Lmxlbmd0aDtpKz0xNil7dmFyIG9sZGE9YTt2YXIgb2xkYj1iO3ZhciBvbGRjPWM7dmFyIG9sZGQ9ZDthPW1kNV9mZihhLGIsYyxkLHhbaSswXSw3LC02ODA4NzY5MzYpO2Q9bWQ1X2ZmKGQsYSxiLGMseFtpKzFdLDEyLC0zODk1NjQ1ODYpO2M9bWQ1X2ZmKGMsZCxhLGIseFtpKzJdLDE3LDYwNjEwNTgxOSk7Yj1tZDVfZmYoYixjLGQsYSx4W2krM10sMjIsLTEwNDQ1MjUzMzApO2E9bWQ1X2ZmKGEsYixjLGQseFtpKzRdLDcsLTE3NjQxODg5Nyk7ZD1tZDVfZmYoZCxhLGIsYyx4W2krNV0sMTIsMTIwMDA4MDQyNik7Yz1tZDVfZmYoYyxkLGEsYix4W2krNl0sMTcsLTE0NzMyMzEzNDEpO2I9bWQ1X2ZmKGIsYyxkLGEseFtpKzddLDIyLC00NTcwNTk4Myk7YT1tZDVfZmYoYSxiLGMsZCx4W2krOF0sNywxNzcwMDM1NDE2KTtkPW1kNV9mZihkLGEsYixjLHhbaSs5XSwxMiwtMTk1ODQxNDQxNyk7Yz1tZDVfZmYoYyxkLGEsYix4W2krMTBdLDE3LC00MjA2Myk7Yj1tZDVfZmYoYixjLGQsYSx4W2krMTFdLDIyLC0xOTkwNDA0MTYyKTthPW1kNV9mZihhLGIsYyxkLHhbaSsxMl0sNywxODA0NjAzNjgyKTtkPW1kNV9mZihkLGEsYixjLHhbaSsxM10sMTIsLTQwMzQxMTAxKTtjPW1kNV9mZihjLGQsYSxiLHhbaSsxNF0sMTcsLTE1MDIwMDIyOTApO2I9bWQ1X2ZmKGIsYyxkLGEseFtpKzE1XSwyMiwxMjM2NTM1MzI5KTthPW1kNV9nZyhhLGIsYyxkLHhbaSsxXSw1LC0xNjU3OTY1MTApO2Q9bWQ1X2dnKGQsYSxiLGMseFtpKzZdLDksLTEwNjk1MDE2MzIpO2M9bWQ1X2dnKGMsZCxhLGIseFtpKzExXSwxNCw2NDM3MTc3MTMpO2I9bWQ1X2dnKGIsYyxkLGEseFtpKzBdLDIwLC0zNzM4OTczMDIpO2E9bWQ1X2dnKGEsYixjLGQseFtpKzVdLDUsLTcwMTU1ODY5MSk7ZD1tZDVfZ2coZCxhLGIsYyx4W2krMTBdLDksMzgwMTYwODMpO2M9bWQ1X2dnKGMsZCxhLGIseFtpKzE1XSwxNCwtNjYwNDc4MzM1KTtiPW1kNV9nZyhiLGMsZCxhLHhbaSs0XSwyMCwtNDA1NTM3ODQ4KTthPW1kNV9nZyhhLGIsYyxkLHhbaSs5XSw1LDU2ODQ0NjQzOCk7ZD1tZDVfZ2coZCxhLGIsYyx4W2krMTRdLDksLTEwMTk4MDM2OTApO2M9bWQ1X2dnKGMsZCxhLGIseFtpKzNdLDE0LC0xODczNjM5NjEpO2I9bWQ1X2dnKGIsYyxkLGEseFtpKzhdLDIwLDExNjM1MzE1MDEpO2E9bWQ1X2dnKGEsYixjLGQseFtpKzEzXSw1LC0xNDQ0NjgxNDY3KTtkPW1kNV9nZyhkLGEsYixjLHhbaSsyXSw5LC01MTQwMzc4NCk7Yz1tZDVfZ2coYyxkLGEsYix4W2krN10sMTQsMTczNTMyODQ3Myk7Yj1tZDVfZ2coYixjLGQsYSx4W2krMTJdLDIwLC0xOTI2NjA3NzM0KTthPW1kNV9oaChhLGIsYyxkLHhbaSs1XSw0LC0zNzg1NTgpO2Q9bWQ1X2hoKGQsYSxiLGMseFtpKzhdLDExLC0yMDIyNTc0NDYzKTtjPW1kNV9oaChjLGQsYSxiLHhbaSsxMV0sMTYsMTgzOTAzMDU2Mik7Yj1tZDVfaGgoYixjLGQsYSx4W2krMTRdLDIzLC0zNTMwOTU1Nik7YT1tZDVfaGgoYSxiLGMsZCx4W2krMV0sNCwtMTUzMDk5MjA2MCk7ZD1tZDVfaGgoZCxhLGIsYyx4W2krNF0sMTEsMTI3Mjg5MzM1Myk7Yz1tZDVfaGgoYyxkLGEsYix4W2krN10sMTYsLTE1NTQ5NzYzMik7Yj1tZDVfaGgoYixjLGQsYSx4W2krMTBdLDIzLC0xMDk0NzMwNjQwKTthPW1kNV9oaChhLGIsYyxkLHhbaSsxM10sNCw2ODEyNzkxNzQpO2Q9bWQ1X2hoKGQsYSxiLGMseFtpKzBdLDExLC0zNTg1MzcyMjIpO2M9bWQ1X2hoKGMsZCxhLGIseFtpKzNdLDE2LC03MjI1MjE5NzkpO2I9bWQ1X2hoKGIsYyxkLGEseFtpKzZdLDIzLDc2MDI5MTg5KTthPW1kNV9oaChhLGIsYyxkLHhbaSs5XSw0LC02NDAzNjQ0ODcpO2Q9bWQ1X2hoKGQsYSxiLGMseFtpKzEyXSwxMSwtNDIxODE1ODM1KTtjPW1kNV9oaChjLGQsYSxiLHhbaSsxNV0sMTYsNTMwNzQyNTIwKTtiPW1kNV9oaChiLGMsZCxhLHhbaSsyXSwyMywtOTk1MzM4NjUxKTthPW1kNV9paShhLGIsYyxkLHhbaSswXSw2LC0xOTg2MzA4NDQpO2Q9bWQ1X2lpKGQsYSxiLGMseFtpKzddLDEwLDExMjY4OTE0MTUpO2M9bWQ1X2lpKGMsZCxhLGIseFtpKzE0XSwxNSwtMTQxNjM1NDkwNSk7Yj1tZDVfaWkoYixjLGQsYSx4W2krNV0sMjEsLTU3NDM0MDU1KTthPW1kNV9paShhLGIsYyxkLHhbaSsxMl0sNiwxNzAwNDg1NTcxKTtkPW1kNV9paShkLGEsYixjLHhbaSszXSwxMCwtMTg5NDk4NjYwNik7Yz1tZDVfaWkoYyxkLGEsYix4W2krMTBdLDE1LC0xMDUxNTIzKTtiPW1kNV9paShiLGMsZCxhLHhbaSsxXSwyMSwtMjA1NDkyMjc5OSk7YT1tZDVfaWkoYSxiLGMsZCx4W2krOF0sNiwxODczMzEzMzU5KTtkPW1kNV9paShkLGEsYixjLHhbaSsxNV0sMTAsLTMwNjExNzQ0KTtjPW1kNV9paShjLGQsYSxiLHhbaSs2XSwxNSwtMTU2MDE5ODM4MCk7Yj1tZDVfaWkoYixjLGQsYSx4W2krMTNdLDIxLDEzMDkxNTE2NDkpO2E9bWQ1X2lpKGEsYixjLGQseFtpKzRdLDYsLTE0NTUyMzA3MCk7ZD1tZDVfaWkoZCxhLGIsYyx4W2krMTFdLDEwLC0xMTIwMjEwMzc5KTtjPW1kNV9paShjLGQsYSxiLHhbaSsyXSwxNSw3MTg3ODcyNTkpO2I9bWQ1X2lpKGIsYyxkLGEseFtpKzldLDIxLC0zNDM0ODU1NTEpO2E9c2FmZV9hZGQoYSxvbGRhKTtiPXNhZmVfYWRkKGIsb2xkYik7Yz1zYWZlX2FkZChjLG9sZGMpO2Q9c2FmZV9hZGQoZCxvbGRkKX1yZXR1cm4gQXJyYXkoYSxiLGMsZCl9ZnVuY3Rpb24gbWQ1X2NtbihxLGEsYix4LHMsdCl7cmV0dXJuIHNhZmVfYWRkKGJpdF9yb2woc2FmZV9hZGQoc2FmZV9hZGQoYSxxKSxzYWZlX2FkZCh4LHQpKSxzKSxiKX1mdW5jdGlvbiBtZDVfZmYoYSxiLGMsZCx4LHMsdCl7cmV0dXJuIG1kNV9jbW4oYiZjfH5iJmQsYSxiLHgscyx0KX1mdW5jdGlvbiBtZDVfZ2coYSxiLGMsZCx4LHMsdCl7cmV0dXJuIG1kNV9jbW4oYiZkfGMmfmQsYSxiLHgscyx0KX1mdW5jdGlvbiBtZDVfaGgoYSxiLGMsZCx4LHMsdCl7cmV0dXJuIG1kNV9jbW4oYl5jXmQsYSxiLHgscyx0KX1mdW5jdGlvbiBtZDVfaWkoYSxiLGMsZCx4LHMsdCl7cmV0dXJuIG1kNV9jbW4oY14oYnx+ZCksYSxiLHgscyx0KX1mdW5jdGlvbiBzYWZlX2FkZCh4LHkpe3ZhciBsc3c9KHgmNjU1MzUpKyh5JjY1NTM1KTt2YXIgbXN3PSh4Pj4xNikrKHk+PjE2KSsobHN3Pj4xNik7cmV0dXJuIG1zdzw8MTZ8bHN3JjY1NTM1fWZ1bmN0aW9uIGJpdF9yb2wobnVtLGNudCl7cmV0dXJuIG51bTw8Y250fG51bT4+PjMyLWNudH1tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbiBtZDUoYnVmKXtyZXR1cm4gaGVscGVycy5oYXNoKGJ1Zixjb3JlX21kNSwxNil9fSx7XCIuL2hlbHBlcnNcIjo4fV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbigpe3ZhciBfZ2xvYmFsPXRoaXM7dmFyIG1hdGhSTkcsd2hhdHdnUk5HO21hdGhSTkc9ZnVuY3Rpb24oc2l6ZSl7dmFyIGJ5dGVzPW5ldyBBcnJheShzaXplKTt2YXIgcjtmb3IodmFyIGk9MCxyO2k8c2l6ZTtpKyspe2lmKChpJjMpPT0wKXI9TWF0aC5yYW5kb20oKSo0Mjk0OTY3Mjk2O2J5dGVzW2ldPXI+Pj4oKGkmMyk8PDMpJjI1NX1yZXR1cm4gYnl0ZXN9O2lmKF9nbG9iYWwuY3J5cHRvJiZjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt3aGF0d2dSTkc9ZnVuY3Rpb24oc2l6ZSl7dmFyIGJ5dGVzPW5ldyBVaW50OEFycmF5KHNpemUpO2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpO3JldHVybiBieXRlc319bW9kdWxlLmV4cG9ydHM9d2hhdHdnUk5HfHxtYXRoUk5HfSkoKX0se31dLDEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgaGVscGVycz1fZGVyZXFfKFwiLi9oZWxwZXJzXCIpO2Z1bmN0aW9uIGNvcmVfc2hhMSh4LGxlbil7eFtsZW4+PjVdfD0xMjg8PDI0LWxlbiUzMjt4WyhsZW4rNjQ+Pjk8PDQpKzE1XT1sZW47dmFyIHc9QXJyYXkoODApO3ZhciBhPTE3MzI1ODQxOTM7dmFyIGI9LTI3MTczMzg3OTt2YXIgYz0tMTczMjU4NDE5NDt2YXIgZD0yNzE3MzM4Nzg7dmFyIGU9LTEwMDk1ODk3NzY7Zm9yKHZhciBpPTA7aTx4Lmxlbmd0aDtpKz0xNil7dmFyIG9sZGE9YTt2YXIgb2xkYj1iO3ZhciBvbGRjPWM7dmFyIG9sZGQ9ZDt2YXIgb2xkZT1lO2Zvcih2YXIgaj0wO2o8ODA7aisrKXtpZihqPDE2KXdbal09eFtpK2pdO2Vsc2Ugd1tqXT1yb2wod1tqLTNdXndbai04XV53W2otMTRdXndbai0xNl0sMSk7dmFyIHQ9c2FmZV9hZGQoc2FmZV9hZGQocm9sKGEsNSksc2hhMV9mdChqLGIsYyxkKSksc2FmZV9hZGQoc2FmZV9hZGQoZSx3W2pdKSxzaGExX2t0KGopKSk7ZT1kO2Q9YztjPXJvbChiLDMwKTtiPWE7YT10fWE9c2FmZV9hZGQoYSxvbGRhKTtiPXNhZmVfYWRkKGIsb2xkYik7Yz1zYWZlX2FkZChjLG9sZGMpO2Q9c2FmZV9hZGQoZCxvbGRkKTtlPXNhZmVfYWRkKGUsb2xkZSl9cmV0dXJuIEFycmF5KGEsYixjLGQsZSl9ZnVuY3Rpb24gc2hhMV9mdCh0LGIsYyxkKXtpZih0PDIwKXJldHVybiBiJmN8fmImZDtpZih0PDQwKXJldHVybiBiXmNeZDtpZih0PDYwKXJldHVybiBiJmN8YiZkfGMmZDtyZXR1cm4gYl5jXmR9ZnVuY3Rpb24gc2hhMV9rdCh0KXtyZXR1cm4gdDwyMD8xNTE4NTAwMjQ5OnQ8NDA/MTg1OTc3NTM5Mzp0PDYwPy0xODk0MDA3NTg4Oi04OTk0OTc1MTR9ZnVuY3Rpb24gc2FmZV9hZGQoeCx5KXt2YXIgbHN3PSh4JjY1NTM1KSsoeSY2NTUzNSk7dmFyIG1zdz0oeD4+MTYpKyh5Pj4xNikrKGxzdz4+MTYpO3JldHVybiBtc3c8PDE2fGxzdyY2NTUzNX1mdW5jdGlvbiByb2wobnVtLGNudCl7cmV0dXJuIG51bTw8Y250fG51bT4+PjMyLWNudH1tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbiBzaGExKGJ1Zil7cmV0dXJuIGhlbHBlcnMuaGFzaChidWYsY29yZV9zaGExLDIwLHRydWUpfX0se1wiLi9oZWxwZXJzXCI6OH1dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgaGVscGVycz1fZGVyZXFfKFwiLi9oZWxwZXJzXCIpO3ZhciBzYWZlX2FkZD1mdW5jdGlvbih4LHkpe3ZhciBsc3c9KHgmNjU1MzUpKyh5JjY1NTM1KTt2YXIgbXN3PSh4Pj4xNikrKHk+PjE2KSsobHN3Pj4xNik7cmV0dXJuIG1zdzw8MTZ8bHN3JjY1NTM1fTt2YXIgUz1mdW5jdGlvbihYLG4pe3JldHVybiBYPj4+bnxYPDwzMi1ufTt2YXIgUj1mdW5jdGlvbihYLG4pe3JldHVybiBYPj4+bn07dmFyIENoPWZ1bmN0aW9uKHgseSx6KXtyZXR1cm4geCZ5Xn54Jnp9O3ZhciBNYWo9ZnVuY3Rpb24oeCx5LHope3JldHVybiB4JnleeCZ6Xnkmen07dmFyIFNpZ21hMDI1Nj1mdW5jdGlvbih4KXtyZXR1cm4gUyh4LDIpXlMoeCwxMyleUyh4LDIyKX07dmFyIFNpZ21hMTI1Nj1mdW5jdGlvbih4KXtyZXR1cm4gUyh4LDYpXlMoeCwxMSleUyh4LDI1KX07dmFyIEdhbW1hMDI1Nj1mdW5jdGlvbih4KXtyZXR1cm4gUyh4LDcpXlMoeCwxOCleUih4LDMpfTt2YXIgR2FtbWExMjU2PWZ1bmN0aW9uKHgpe3JldHVybiBTKHgsMTcpXlMoeCwxOSleUih4LDEwKX07dmFyIGNvcmVfc2hhMjU2PWZ1bmN0aW9uKG0sbCl7dmFyIEs9bmV3IEFycmF5KDExMTYzNTI0MDgsMTg5OTQ0NzQ0MSwzMDQ5MzIzNDcxLDM5MjEwMDk1NzMsOTYxOTg3MTYzLDE1MDg5NzA5OTMsMjQ1MzYzNTc0OCwyODcwNzYzMjIxLDM2MjQzODEwODAsMzEwNTk4NDAxLDYwNzIyNTI3OCwxNDI2ODgxOTg3LDE5MjUwNzgzODgsMjE2MjA3ODIwNiwyNjE0ODg4MTAzLDMyNDgyMjI1ODAsMzgzNTM5MDQwMSw0MDIyMjI0Nzc0LDI2NDM0NzA3OCw2MDQ4MDc2MjgsNzcwMjU1OTgzLDEyNDkxNTAxMjIsMTU1NTA4MTY5MiwxOTk2MDY0OTg2LDI1NTQyMjA4ODIsMjgyMTgzNDM0OSwyOTUyOTk2ODA4LDMyMTAzMTM2NzEsMzMzNjU3MTg5MSwzNTg0NTI4NzExLDExMzkyNjk5MywzMzgyNDE4OTUsNjY2MzA3MjA1LDc3MzUyOTkxMiwxMjk0NzU3MzcyLDEzOTYxODIyOTEsMTY5NTE4MzcwMCwxOTg2NjYxMDUxLDIxNzcwMjYzNTAsMjQ1Njk1NjAzNywyNzMwNDg1OTIxLDI4MjAzMDI0MTEsMzI1OTczMDgwMCwzMzQ1NzY0NzcxLDM1MTYwNjU4MTcsMzYwMDM1MjgwNCw0MDk0NTcxOTA5LDI3NTQyMzM0NCw0MzAyMjc3MzQsNTA2OTQ4NjE2LDY1OTA2MDU1Niw4ODM5OTc4NzcsOTU4MTM5NTcxLDEzMjI4MjIyMTgsMTUzNzAwMjA2MywxNzQ3ODczNzc5LDE5NTU1NjIyMjIsMjAyNDEwNDgxNSwyMjI3NzMwNDUyLDIzNjE4NTI0MjQsMjQyODQzNjQ3NCwyNzU2NzM0MTg3LDMyMDQwMzE0NzksMzMyOTMyNTI5OCk7dmFyIEhBU0g9bmV3IEFycmF5KDE3NzkwMzM3MDMsMzE0NDEzNDI3NywxMDEzOTA0MjQyLDI3NzM0ODA3NjIsMTM1OTg5MzExOSwyNjAwODIyOTI0LDUyODczNDYzNSwxNTQxNDU5MjI1KTt2YXIgVz1uZXcgQXJyYXkoNjQpO3ZhciBhLGIsYyxkLGUsZixnLGgsaSxqO3ZhciBUMSxUMjttW2w+PjVdfD0xMjg8PDI0LWwlMzI7bVsobCs2ND4+OTw8NCkrMTVdPWw7Zm9yKHZhciBpPTA7aTxtLmxlbmd0aDtpKz0xNil7YT1IQVNIWzBdO2I9SEFTSFsxXTtjPUhBU0hbMl07ZD1IQVNIWzNdO2U9SEFTSFs0XTtmPUhBU0hbNV07Zz1IQVNIWzZdO2g9SEFTSFs3XTtmb3IodmFyIGo9MDtqPDY0O2orKyl7aWYoajwxNil7V1tqXT1tW2oraV19ZWxzZXtXW2pdPXNhZmVfYWRkKHNhZmVfYWRkKHNhZmVfYWRkKEdhbW1hMTI1NihXW2otMl0pLFdbai03XSksR2FtbWEwMjU2KFdbai0xNV0pKSxXW2otMTZdKX1UMT1zYWZlX2FkZChzYWZlX2FkZChzYWZlX2FkZChzYWZlX2FkZChoLFNpZ21hMTI1NihlKSksQ2goZSxmLGcpKSxLW2pdKSxXW2pdKTtUMj1zYWZlX2FkZChTaWdtYTAyNTYoYSksTWFqKGEsYixjKSk7aD1nO2c9ZjtmPWU7ZT1zYWZlX2FkZChkLFQxKTtkPWM7Yz1iO2I9YTthPXNhZmVfYWRkKFQxLFQyKX1IQVNIWzBdPXNhZmVfYWRkKGEsSEFTSFswXSk7SEFTSFsxXT1zYWZlX2FkZChiLEhBU0hbMV0pO0hBU0hbMl09c2FmZV9hZGQoYyxIQVNIWzJdKTtIQVNIWzNdPXNhZmVfYWRkKGQsSEFTSFszXSk7SEFTSFs0XT1zYWZlX2FkZChlLEhBU0hbNF0pO0hBU0hbNV09c2FmZV9hZGQoZixIQVNIWzVdKTtIQVNIWzZdPXNhZmVfYWRkKGcsSEFTSFs2XSk7SEFTSFs3XT1zYWZlX2FkZChoLEhBU0hbN10pfXJldHVybiBIQVNIfTttb2R1bGUuZXhwb3J0cz1mdW5jdGlvbiBzaGEyNTYoYnVmKXtyZXR1cm4gaGVscGVycy5oYXNoKGJ1Zixjb3JlX3NoYTI1NiwzMix0cnVlKX19LHtcIi4vaGVscGVyc1wiOjh9XSwxNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7aWYodHlwZW9mIE9iamVjdC5jcmVhdGU9PT1cImZ1bmN0aW9uXCIpe21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uIGluaGVyaXRzKGN0b3Isc3VwZXJDdG9yKXtjdG9yLnN1cGVyXz1zdXBlckN0b3I7Y3Rvci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6Y3RvcixlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9fSl9fWVsc2V7bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24gaW5oZXJpdHMoY3RvcixzdXBlckN0b3Ipe2N0b3Iuc3VwZXJfPXN1cGVyQ3Rvcjt2YXIgVGVtcEN0b3I9ZnVuY3Rpb24oKXt9O1RlbXBDdG9yLnByb3RvdHlwZT1zdXBlckN0b3IucHJvdG90eXBlO2N0b3IucHJvdG90eXBlPW5ldyBUZW1wQ3RvcjtjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1jdG9yfX19LHt9XSwxNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIHByb2Nlc3M9bW9kdWxlLmV4cG9ydHM9e307cHJvY2Vzcy5uZXh0VGljaz1mdW5jdGlvbigpe3ZhciBjYW5TZXRJbW1lZGlhdGU9dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCImJndpbmRvdy5zZXRJbW1lZGlhdGU7dmFyIGNhblBvc3Q9dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCImJndpbmRvdy5wb3N0TWVzc2FnZSYmd2luZG93LmFkZEV2ZW50TGlzdGVuZXI7aWYoY2FuU2V0SW1tZWRpYXRlKXtyZXR1cm4gZnVuY3Rpb24oZil7cmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZil9fWlmKGNhblBvc3Qpe3ZhciBxdWV1ZT1bXTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixmdW5jdGlvbihldil7dmFyIHNvdXJjZT1ldi5zb3VyY2U7aWYoKHNvdXJjZT09PXdpbmRvd3x8c291cmNlPT09bnVsbCkmJmV2LmRhdGE9PT1cInByb2Nlc3MtdGlja1wiKXtldi5zdG9wUHJvcGFnYXRpb24oKTtpZihxdWV1ZS5sZW5ndGg+MCl7dmFyIGZuPXF1ZXVlLnNoaWZ0KCk7Zm4oKX19fSx0cnVlKTtyZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pe3F1ZXVlLnB1c2goZm4pO3dpbmRvdy5wb3N0TWVzc2FnZShcInByb2Nlc3MtdGlja1wiLFwiKlwiKX19cmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKXtzZXRUaW1lb3V0KGZuLDApfX0oKTtwcm9jZXNzLnRpdGxlPVwiYnJvd3NlclwiO3Byb2Nlc3MuYnJvd3Nlcj10cnVlO3Byb2Nlc3MuZW52PXt9O3Byb2Nlc3MuYXJndj1bXTtmdW5jdGlvbiBub29wKCl7fXByb2Nlc3Mub249bm9vcDtwcm9jZXNzLmFkZExpc3RlbmVyPW5vb3A7cHJvY2Vzcy5vbmNlPW5vb3A7cHJvY2Vzcy5vZmY9bm9vcDtwcm9jZXNzLnJlbW92ZUxpc3RlbmVyPW5vb3A7cHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcDtwcm9jZXNzLmVtaXQ9bm9vcDtwcm9jZXNzLmJpbmRpbmc9ZnVuY3Rpb24obmFtZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3Byb2Nlc3MuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O3Byb2Nlc3MuY2hkaXI9ZnVuY3Rpb24oZGlyKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9fSx7fV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPV9kZXJlcV8oMil9LHt9XSwxNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9X2RlcmVxXygzKX0se1wiLi9zdXBwb3J0L2lzQnVmZmVyXCI6MTYsRldhQVNIOjE1LGluaGVyaXRzOjE0fV0sMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vZW5jLWJhc2U2NFwiKSxfZGVyZXFfKFwiLi9tZDVcIiksX2RlcmVxXyhcIi4vZXZwa2RmXCIpLF9kZXJlcV8oXCIuL2NpcGhlci1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vZW5jLWJhc2U2NFwiLFwiLi9tZDVcIixcIi4vZXZwa2RmXCIsXCIuL2NpcGhlci1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIEJsb2NrQ2lwaGVyPUNfbGliLkJsb2NrQ2lwaGVyO3ZhciBDX2FsZ289Qy5hbGdvO3ZhciBTQk9YPVtdO3ZhciBJTlZfU0JPWD1bXTt2YXIgU1VCX01JWF8wPVtdO3ZhciBTVUJfTUlYXzE9W107dmFyIFNVQl9NSVhfMj1bXTt2YXIgU1VCX01JWF8zPVtdO3ZhciBJTlZfU1VCX01JWF8wPVtdO3ZhciBJTlZfU1VCX01JWF8xPVtdO3ZhciBJTlZfU1VCX01JWF8yPVtdO3ZhciBJTlZfU1VCX01JWF8zPVtdOyhmdW5jdGlvbigpe3ZhciBkPVtdO2Zvcih2YXIgaT0wO2k8MjU2O2krKyl7aWYoaTwxMjgpe2RbaV09aTw8MX1lbHNle2RbaV09aTw8MV4yODN9fXZhciB4PTA7dmFyIHhpPTA7Zm9yKHZhciBpPTA7aTwyNTY7aSsrKXt2YXIgc3g9eGleeGk8PDFeeGk8PDJeeGk8PDNeeGk8PDQ7c3g9c3g+Pj44XnN4JjI1NV45OTtTQk9YW3hdPXN4O0lOVl9TQk9YW3N4XT14O3ZhciB4Mj1kW3hdO3ZhciB4ND1kW3gyXTt2YXIgeDg9ZFt4NF07dmFyIHQ9ZFtzeF0qMjU3XnN4KjE2ODQzMDA4O1NVQl9NSVhfMFt4XT10PDwyNHx0Pj4+ODtTVUJfTUlYXzFbeF09dDw8MTZ8dD4+PjE2O1NVQl9NSVhfMlt4XT10PDw4fHQ+Pj4yNDtTVUJfTUlYXzNbeF09dDt2YXIgdD14OCoxNjg0MzAwOV54NCo2NTUzN154MioyNTdeeCoxNjg0MzAwODtJTlZfU1VCX01JWF8wW3N4XT10PDwyNHx0Pj4+ODtJTlZfU1VCX01JWF8xW3N4XT10PDwxNnx0Pj4+MTY7SU5WX1NVQl9NSVhfMltzeF09dDw8OHx0Pj4+MjQ7SU5WX1NVQl9NSVhfM1tzeF09dDtpZigheCl7eD14aT0xfWVsc2V7eD14Ml5kW2RbZFt4OF54Ml1dXTt4aV49ZFtkW3hpXV19fX0pKCk7dmFyIFJDT049WzAsMSwyLDQsOCwxNiwzMiw2NCwxMjgsMjcsNTRdO3ZhciBBRVM9Q19hbGdvLkFFUz1CbG9ja0NpcGhlci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dmFyIGtleT10aGlzLl9rZXk7dmFyIGtleVdvcmRzPWtleS53b3Jkczt2YXIga2V5U2l6ZT1rZXkuc2lnQnl0ZXMvNDt2YXIgblJvdW5kcz10aGlzLl9uUm91bmRzPWtleVNpemUrNjt2YXIga3NSb3dzPShuUm91bmRzKzEpKjQ7dmFyIGtleVNjaGVkdWxlPXRoaXMuX2tleVNjaGVkdWxlPVtdO2Zvcih2YXIga3NSb3c9MDtrc1Jvdzxrc1Jvd3M7a3NSb3crKyl7aWYoa3NSb3c8a2V5U2l6ZSl7a2V5U2NoZWR1bGVba3NSb3ddPWtleVdvcmRzW2tzUm93XX1lbHNle3ZhciB0PWtleVNjaGVkdWxlW2tzUm93LTFdO2lmKCEoa3NSb3cla2V5U2l6ZSkpe3Q9dDw8OHx0Pj4+MjQ7dD1TQk9YW3Q+Pj4yNF08PDI0fFNCT1hbdD4+PjE2JjI1NV08PDE2fFNCT1hbdD4+PjgmMjU1XTw8OHxTQk9YW3QmMjU1XTt0Xj1SQ09OW2tzUm93L2tleVNpemV8MF08PDI0fWVsc2UgaWYoa2V5U2l6ZT42JiZrc1JvdyVrZXlTaXplPT00KXt0PVNCT1hbdD4+PjI0XTw8MjR8U0JPWFt0Pj4+MTYmMjU1XTw8MTZ8U0JPWFt0Pj4+OCYyNTVdPDw4fFNCT1hbdCYyNTVdfWtleVNjaGVkdWxlW2tzUm93XT1rZXlTY2hlZHVsZVtrc1Jvdy1rZXlTaXplXV50fX12YXIgaW52S2V5U2NoZWR1bGU9dGhpcy5faW52S2V5U2NoZWR1bGU9W107Zm9yKHZhciBpbnZLc1Jvdz0wO2ludktzUm93PGtzUm93cztpbnZLc1JvdysrKXt2YXIga3NSb3c9a3NSb3dzLWludktzUm93O2lmKGludktzUm93JTQpe3ZhciB0PWtleVNjaGVkdWxlW2tzUm93XX1lbHNle3ZhciB0PWtleVNjaGVkdWxlW2tzUm93LTRdfWlmKGludktzUm93PDR8fGtzUm93PD00KXtpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd109dH1lbHNle2ludktleVNjaGVkdWxlW2ludktzUm93XT1JTlZfU1VCX01JWF8wW1NCT1hbdD4+PjI0XV1eSU5WX1NVQl9NSVhfMVtTQk9YW3Q+Pj4xNiYyNTVdXV5JTlZfU1VCX01JWF8yW1NCT1hbdD4+PjgmMjU1XV1eSU5WX1NVQl9NSVhfM1tTQk9YW3QmMjU1XV19fX0sZW5jcnlwdEJsb2NrOmZ1bmN0aW9uKE0sb2Zmc2V0KXt0aGlzLl9kb0NyeXB0QmxvY2soTSxvZmZzZXQsdGhpcy5fa2V5U2NoZWR1bGUsU1VCX01JWF8wLFNVQl9NSVhfMSxTVUJfTUlYXzIsU1VCX01JWF8zLFNCT1gpfSxkZWNyeXB0QmxvY2s6ZnVuY3Rpb24oTSxvZmZzZXQpe3ZhciB0PU1bb2Zmc2V0KzFdO01bb2Zmc2V0KzFdPU1bb2Zmc2V0KzNdO01bb2Zmc2V0KzNdPXQ7dGhpcy5fZG9DcnlwdEJsb2NrKE0sb2Zmc2V0LHRoaXMuX2ludktleVNjaGVkdWxlLElOVl9TVUJfTUlYXzAsSU5WX1NVQl9NSVhfMSxJTlZfU1VCX01JWF8yLElOVl9TVUJfTUlYXzMsSU5WX1NCT1gpO3ZhciB0PU1bb2Zmc2V0KzFdO01bb2Zmc2V0KzFdPU1bb2Zmc2V0KzNdO01bb2Zmc2V0KzNdPXR9LF9kb0NyeXB0QmxvY2s6ZnVuY3Rpb24oTSxvZmZzZXQsa2V5U2NoZWR1bGUsU1VCX01JWF8wLFNVQl9NSVhfMSxTVUJfTUlYXzIsU1VCX01JWF8zLFNCT1gpe3ZhciBuUm91bmRzPXRoaXMuX25Sb3VuZHM7dmFyIHMwPU1bb2Zmc2V0XV5rZXlTY2hlZHVsZVswXTt2YXIgczE9TVtvZmZzZXQrMV1ea2V5U2NoZWR1bGVbMV07dmFyIHMyPU1bb2Zmc2V0KzJdXmtleVNjaGVkdWxlWzJdO3ZhciBzMz1NW29mZnNldCszXV5rZXlTY2hlZHVsZVszXTt2YXIga3NSb3c9NDtmb3IodmFyIHJvdW5kPTE7cm91bmQ8blJvdW5kcztyb3VuZCsrKXt2YXIgdDA9U1VCX01JWF8wW3MwPj4+MjRdXlNVQl9NSVhfMVtzMT4+PjE2JjI1NV1eU1VCX01JWF8yW3MyPj4+OCYyNTVdXlNVQl9NSVhfM1tzMyYyNTVdXmtleVNjaGVkdWxlW2tzUm93KytdO3ZhciB0MT1TVUJfTUlYXzBbczE+Pj4yNF1eU1VCX01JWF8xW3MyPj4+MTYmMjU1XV5TVUJfTUlYXzJbczM+Pj44JjI1NV1eU1VCX01JWF8zW3MwJjI1NV1ea2V5U2NoZWR1bGVba3NSb3crK107dmFyIHQyPVNVQl9NSVhfMFtzMj4+PjI0XV5TVUJfTUlYXzFbczM+Pj4xNiYyNTVdXlNVQl9NSVhfMltzMD4+PjgmMjU1XV5TVUJfTUlYXzNbczEmMjU1XV5rZXlTY2hlZHVsZVtrc1JvdysrXTt2YXIgdDM9U1VCX01JWF8wW3MzPj4+MjRdXlNVQl9NSVhfMVtzMD4+PjE2JjI1NV1eU1VCX01JWF8yW3MxPj4+OCYyNTVdXlNVQl9NSVhfM1tzMiYyNTVdXmtleVNjaGVkdWxlW2tzUm93KytdO3MwPXQwO3MxPXQxO3MyPXQyO3MzPXQzfXZhciB0MD0oU0JPWFtzMD4+PjI0XTw8MjR8U0JPWFtzMT4+PjE2JjI1NV08PDE2fFNCT1hbczI+Pj44JjI1NV08PDh8U0JPWFtzMyYyNTVdKV5rZXlTY2hlZHVsZVtrc1JvdysrXTt2YXIgdDE9KFNCT1hbczE+Pj4yNF08PDI0fFNCT1hbczI+Pj4xNiYyNTVdPDwxNnxTQk9YW3MzPj4+OCYyNTVdPDw4fFNCT1hbczAmMjU1XSlea2V5U2NoZWR1bGVba3NSb3crK107dmFyIHQyPShTQk9YW3MyPj4+MjRdPDwyNHxTQk9YW3MzPj4+MTYmMjU1XTw8MTZ8U0JPWFtzMD4+PjgmMjU1XTw8OHxTQk9YW3MxJjI1NV0pXmtleVNjaGVkdWxlW2tzUm93KytdO3ZhciB0Mz0oU0JPWFtzMz4+PjI0XTw8MjR8U0JPWFtzMD4+PjE2JjI1NV08PDE2fFNCT1hbczE+Pj44JjI1NV08PDh8U0JPWFtzMiYyNTVdKV5rZXlTY2hlZHVsZVtrc1JvdysrXTtNW29mZnNldF09dDA7TVtvZmZzZXQrMV09dDE7TVtvZmZzZXQrMl09dDI7TVtvZmZzZXQrM109dDN9LGtleVNpemU6MjU2LzMyfSk7Qy5BRVM9QmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihBRVMpfSkoKTtyZXR1cm4gQ3J5cHRvSlMuQUVTfSl9LHtcIi4vY2lwaGVyLWNvcmVcIjoxOSxcIi4vY29yZVwiOjIwLFwiLi9lbmMtYmFzZTY0XCI6MjEsXCIuL2V2cGtkZlwiOjIzLFwiLi9tZDVcIjoyOX1dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5KXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpe0NyeXB0b0pTLmxpYi5DaXBoZXJ8fGZ1bmN0aW9uKHVuZGVmaW5lZCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBCYXNlPUNfbGliLkJhc2U7dmFyIFdvcmRBcnJheT1DX2xpYi5Xb3JkQXJyYXk7dmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG09Q19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobTt2YXIgQ19lbmM9Qy5lbmM7dmFyIFV0Zjg9Q19lbmMuVXRmODt2YXIgQmFzZTY0PUNfZW5jLkJhc2U2NDt2YXIgQ19hbGdvPUMuYWxnbzt2YXIgRXZwS0RGPUNfYWxnby5FdnBLREY7dmFyIENpcGhlcj1DX2xpYi5DaXBoZXI9QnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe2NmZzpCYXNlLmV4dGVuZCgpLGNyZWF0ZUVuY3J5cHRvcjpmdW5jdGlvbihrZXksY2ZnKXtyZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fRU5DX1hGT1JNX01PREUsa2V5LGNmZyl9LGNyZWF0ZURlY3J5cHRvcjpmdW5jdGlvbihrZXksY2ZnKXtyZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fREVDX1hGT1JNX01PREUsa2V5LGNmZyl9LGluaXQ6ZnVuY3Rpb24oeGZvcm1Nb2RlLGtleSxjZmcpe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZChjZmcpO3RoaXMuX3hmb3JtTW9kZT14Zm9ybU1vZGU7dGhpcy5fa2V5PWtleTt0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7QnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO3RoaXMuX2RvUmVzZXQoKX0scHJvY2VzczpmdW5jdGlvbihkYXRhVXBkYXRlKXt0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7cmV0dXJuIHRoaXMuX3Byb2Nlc3MoKX0sZmluYWxpemU6ZnVuY3Rpb24oZGF0YVVwZGF0ZSl7aWYoZGF0YVVwZGF0ZSl7dGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpfXZhciBmaW5hbFByb2Nlc3NlZERhdGE9dGhpcy5fZG9GaW5hbGl6ZSgpO3JldHVybiBmaW5hbFByb2Nlc3NlZERhdGF9LGtleVNpemU6MTI4LzMyLGl2U2l6ZToxMjgvMzIsX0VOQ19YRk9STV9NT0RFOjEsX0RFQ19YRk9STV9NT0RFOjIsX2NyZWF0ZUhlbHBlcjpmdW5jdGlvbigpe2Z1bmN0aW9uIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSl7aWYodHlwZW9mIGtleT09XCJzdHJpbmdcIil7cmV0dXJuIFBhc3N3b3JkQmFzZWRDaXBoZXJ9ZWxzZXtyZXR1cm4gU2VyaWFsaXphYmxlQ2lwaGVyfX1yZXR1cm4gZnVuY3Rpb24oY2lwaGVyKXtyZXR1cm57ZW5jcnlwdDpmdW5jdGlvbihtZXNzYWdlLGtleSxjZmcpe3JldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmVuY3J5cHQoY2lwaGVyLG1lc3NhZ2Usa2V5LGNmZyl9LGRlY3J5cHQ6ZnVuY3Rpb24oY2lwaGVydGV4dCxrZXksY2ZnKXtyZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5kZWNyeXB0KGNpcGhlcixjaXBoZXJ0ZXh0LGtleSxjZmcpfX19fSgpfSk7dmFyIFN0cmVhbUNpcGhlcj1DX2xpYi5TdHJlYW1DaXBoZXI9Q2lwaGVyLmV4dGVuZCh7X2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3M9dGhpcy5fcHJvY2VzcyghIVwiZmx1c2hcIik7cmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzfSxibG9ja1NpemU6MX0pO3ZhciBDX21vZGU9Qy5tb2RlPXt9O3ZhciBCbG9ja0NpcGhlck1vZGU9Q19saWIuQmxvY2tDaXBoZXJNb2RlPUJhc2UuZXh0ZW5kKHtjcmVhdGVFbmNyeXB0b3I6ZnVuY3Rpb24oY2lwaGVyLGl2KXtyZXR1cm4gdGhpcy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlcixpdil9LGNyZWF0ZURlY3J5cHRvcjpmdW5jdGlvbihjaXBoZXIsaXYpe3JldHVybiB0aGlzLkRlY3J5cHRvci5jcmVhdGUoY2lwaGVyLGl2KX0saW5pdDpmdW5jdGlvbihjaXBoZXIsaXYpe3RoaXMuX2NpcGhlcj1jaXBoZXI7dGhpcy5faXY9aXZ9fSk7dmFyIENCQz1DX21vZGUuQ0JDPWZ1bmN0aW9uKCl7dmFyIENCQz1CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7Q0JDLkVuY3J5cHRvcj1DQkMuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24od29yZHMsb2Zmc2V0KXt2YXIgY2lwaGVyPXRoaXMuX2NpcGhlcjt2YXIgYmxvY2tTaXplPWNpcGhlci5ibG9ja1NpemU7eG9yQmxvY2suY2FsbCh0aGlzLHdvcmRzLG9mZnNldCxibG9ja1NpemUpO2NpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsb2Zmc2V0KTt0aGlzLl9wcmV2QmxvY2s9d29yZHMuc2xpY2Uob2Zmc2V0LG9mZnNldCtibG9ja1NpemUpfX0pO0NCQy5EZWNyeXB0b3I9Q0JDLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHdvcmRzLG9mZnNldCl7dmFyIGNpcGhlcj10aGlzLl9jaXBoZXI7dmFyIGJsb2NrU2l6ZT1jaXBoZXIuYmxvY2tTaXplO3ZhciB0aGlzQmxvY2s9d29yZHMuc2xpY2Uob2Zmc2V0LG9mZnNldCtibG9ja1NpemUpO2NpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsb2Zmc2V0KTt4b3JCbG9jay5jYWxsKHRoaXMsd29yZHMsb2Zmc2V0LGJsb2NrU2l6ZSk7dGhpcy5fcHJldkJsb2NrPXRoaXNCbG9ja319KTtmdW5jdGlvbiB4b3JCbG9jayh3b3JkcyxvZmZzZXQsYmxvY2tTaXplKXt2YXIgaXY9dGhpcy5faXY7aWYoaXYpe3ZhciBibG9jaz1pdjt0aGlzLl9pdj11bmRlZmluZWR9ZWxzZXt2YXIgYmxvY2s9dGhpcy5fcHJldkJsb2NrfWZvcih2YXIgaT0wO2k8YmxvY2tTaXplO2krKyl7d29yZHNbb2Zmc2V0K2ldXj1ibG9ja1tpXX19cmV0dXJuIENCQ30oKTt2YXIgQ19wYWQ9Qy5wYWQ9e307dmFyIFBrY3M3PUNfcGFkLlBrY3M3PXtwYWQ6ZnVuY3Rpb24oZGF0YSxibG9ja1NpemUpe3ZhciBibG9ja1NpemVCeXRlcz1ibG9ja1NpemUqNDt2YXIgblBhZGRpbmdCeXRlcz1ibG9ja1NpemVCeXRlcy1kYXRhLnNpZ0J5dGVzJWJsb2NrU2l6ZUJ5dGVzO3ZhciBwYWRkaW5nV29yZD1uUGFkZGluZ0J5dGVzPDwyNHxuUGFkZGluZ0J5dGVzPDwxNnxuUGFkZGluZ0J5dGVzPDw4fG5QYWRkaW5nQnl0ZXM7dmFyIHBhZGRpbmdXb3Jkcz1bXTtmb3IodmFyIGk9MDtpPG5QYWRkaW5nQnl0ZXM7aSs9NCl7cGFkZGluZ1dvcmRzLnB1c2gocGFkZGluZ1dvcmQpfXZhciBwYWRkaW5nPVdvcmRBcnJheS5jcmVhdGUocGFkZGluZ1dvcmRzLG5QYWRkaW5nQnl0ZXMpO2RhdGEuY29uY2F0KHBhZGRpbmcpfSx1bnBhZDpmdW5jdGlvbihkYXRhKXt2YXIgblBhZGRpbmdCeXRlcz1kYXRhLndvcmRzW2RhdGEuc2lnQnl0ZXMtMT4+PjJdJjI1NTtkYXRhLnNpZ0J5dGVzLT1uUGFkZGluZ0J5dGVzfX07dmFyIEJsb2NrQ2lwaGVyPUNfbGliLkJsb2NrQ2lwaGVyPUNpcGhlci5leHRlbmQoe2NmZzpDaXBoZXIuY2ZnLmV4dGVuZCh7bW9kZTpDQkMscGFkZGluZzpQa2NzN30pLHJlc2V0OmZ1bmN0aW9uKCl7Q2lwaGVyLnJlc2V0LmNhbGwodGhpcyk7dmFyIGNmZz10aGlzLmNmZzt2YXIgaXY9Y2ZnLml2O3ZhciBtb2RlPWNmZy5tb2RlO2lmKHRoaXMuX3hmb3JtTW9kZT09dGhpcy5fRU5DX1hGT1JNX01PREUpe3ZhciBtb2RlQ3JlYXRvcj1tb2RlLmNyZWF0ZUVuY3J5cHRvcn1lbHNle3ZhciBtb2RlQ3JlYXRvcj1tb2RlLmNyZWF0ZURlY3J5cHRvcjt0aGlzLl9taW5CdWZmZXJTaXplPTF9dGhpcy5fbW9kZT1tb2RlQ3JlYXRvci5jYWxsKG1vZGUsdGhpcyxpdiYmaXYud29yZHMpfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24od29yZHMsb2Zmc2V0KXt0aGlzLl9tb2RlLnByb2Nlc3NCbG9jayh3b3JkcyxvZmZzZXQpfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciBwYWRkaW5nPXRoaXMuY2ZnLnBhZGRpbmc7aWYodGhpcy5feGZvcm1Nb2RlPT10aGlzLl9FTkNfWEZPUk1fTU9ERSl7cGFkZGluZy5wYWQodGhpcy5fZGF0YSx0aGlzLmJsb2NrU2l6ZSk7dmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzPXRoaXMuX3Byb2Nlc3MoISFcImZsdXNoXCIpfWVsc2V7dmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzPXRoaXMuX3Byb2Nlc3MoISFcImZsdXNoXCIpO3BhZGRpbmcudW5wYWQoZmluYWxQcm9jZXNzZWRCbG9ja3MpfXJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2Nrc30sYmxvY2tTaXplOjEyOC8zMn0pO3ZhciBDaXBoZXJQYXJhbXM9Q19saWIuQ2lwaGVyUGFyYW1zPUJhc2UuZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKGNpcGhlclBhcmFtcyl7dGhpcy5taXhJbihjaXBoZXJQYXJhbXMpfSx0b1N0cmluZzpmdW5jdGlvbihmb3JtYXR0ZXIpe3JldHVybihmb3JtYXR0ZXJ8fHRoaXMuZm9ybWF0dGVyKS5zdHJpbmdpZnkodGhpcyl9fSk7dmFyIENfZm9ybWF0PUMuZm9ybWF0PXt9O3ZhciBPcGVuU1NMRm9ybWF0dGVyPUNfZm9ybWF0Lk9wZW5TU0w9e3N0cmluZ2lmeTpmdW5jdGlvbihjaXBoZXJQYXJhbXMpe3ZhciBjaXBoZXJ0ZXh0PWNpcGhlclBhcmFtcy5jaXBoZXJ0ZXh0O3ZhciBzYWx0PWNpcGhlclBhcmFtcy5zYWx0O2lmKHNhbHQpe3ZhciB3b3JkQXJyYXk9V29yZEFycmF5LmNyZWF0ZShbMTM5ODg5MzY4NCwxNzAxMDc2ODMxXSkuY29uY2F0KHNhbHQpLmNvbmNhdChjaXBoZXJ0ZXh0KX1lbHNle3ZhciB3b3JkQXJyYXk9Y2lwaGVydGV4dH1yZXR1cm4gd29yZEFycmF5LnRvU3RyaW5nKEJhc2U2NCl9LHBhcnNlOmZ1bmN0aW9uKG9wZW5TU0xTdHIpe3ZhciBjaXBoZXJ0ZXh0PUJhc2U2NC5wYXJzZShvcGVuU1NMU3RyKTt2YXIgY2lwaGVydGV4dFdvcmRzPWNpcGhlcnRleHQud29yZHM7aWYoY2lwaGVydGV4dFdvcmRzWzBdPT0xMzk4ODkzNjg0JiZjaXBoZXJ0ZXh0V29yZHNbMV09PTE3MDEwNzY4MzEpe3ZhciBzYWx0PVdvcmRBcnJheS5jcmVhdGUoY2lwaGVydGV4dFdvcmRzLnNsaWNlKDIsNCkpO2NpcGhlcnRleHRXb3Jkcy5zcGxpY2UoMCw0KTtjaXBoZXJ0ZXh0LnNpZ0J5dGVzLT0xNn1yZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7Y2lwaGVydGV4dDpjaXBoZXJ0ZXh0LHNhbHQ6c2FsdH0pfX07dmFyIFNlcmlhbGl6YWJsZUNpcGhlcj1DX2xpYi5TZXJpYWxpemFibGVDaXBoZXI9QmFzZS5leHRlbmQoe2NmZzpCYXNlLmV4dGVuZCh7Zm9ybWF0Ok9wZW5TU0xGb3JtYXR0ZXJ9KSxlbmNyeXB0OmZ1bmN0aW9uKGNpcGhlcixtZXNzYWdlLGtleSxjZmcpe2NmZz10aGlzLmNmZy5leHRlbmQoY2ZnKTt2YXIgZW5jcnlwdG9yPWNpcGhlci5jcmVhdGVFbmNyeXB0b3Ioa2V5LGNmZyk7dmFyIGNpcGhlcnRleHQ9ZW5jcnlwdG9yLmZpbmFsaXplKG1lc3NhZ2UpO3ZhciBjaXBoZXJDZmc9ZW5jcnlwdG9yLmNmZztyZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7Y2lwaGVydGV4dDpjaXBoZXJ0ZXh0LGtleTprZXksaXY6Y2lwaGVyQ2ZnLml2LGFsZ29yaXRobTpjaXBoZXIsbW9kZTpjaXBoZXJDZmcubW9kZSxwYWRkaW5nOmNpcGhlckNmZy5wYWRkaW5nLGJsb2NrU2l6ZTpjaXBoZXIuYmxvY2tTaXplLGZvcm1hdHRlcjpjZmcuZm9ybWF0fSl9LGRlY3J5cHQ6ZnVuY3Rpb24oY2lwaGVyLGNpcGhlcnRleHQsa2V5LGNmZyl7Y2ZnPXRoaXMuY2ZnLmV4dGVuZChjZmcpO2NpcGhlcnRleHQ9dGhpcy5fcGFyc2UoY2lwaGVydGV4dCxjZmcuZm9ybWF0KTt2YXIgcGxhaW50ZXh0PWNpcGhlci5jcmVhdGVEZWNyeXB0b3Ioa2V5LGNmZykuZmluYWxpemUoY2lwaGVydGV4dC5jaXBoZXJ0ZXh0KTtyZXR1cm4gcGxhaW50ZXh0fSxfcGFyc2U6ZnVuY3Rpb24oY2lwaGVydGV4dCxmb3JtYXQpe2lmKHR5cGVvZiBjaXBoZXJ0ZXh0PT1cInN0cmluZ1wiKXtyZXR1cm4gZm9ybWF0LnBhcnNlKGNpcGhlcnRleHQsdGhpcyl9ZWxzZXtyZXR1cm4gY2lwaGVydGV4dH19fSk7dmFyIENfa2RmPUMua2RmPXt9O3ZhciBPcGVuU1NMS2RmPUNfa2RmLk9wZW5TU0w9e2V4ZWN1dGU6ZnVuY3Rpb24ocGFzc3dvcmQsa2V5U2l6ZSxpdlNpemUsc2FsdCl7aWYoIXNhbHQpe3NhbHQ9V29yZEFycmF5LnJhbmRvbSg2NC84KX12YXIga2V5PUV2cEtERi5jcmVhdGUoe2tleVNpemU6a2V5U2l6ZStpdlNpemV9KS5jb21wdXRlKHBhc3N3b3JkLHNhbHQpO3ZhciBpdj1Xb3JkQXJyYXkuY3JlYXRlKGtleS53b3Jkcy5zbGljZShrZXlTaXplKSxpdlNpemUqNCk7a2V5LnNpZ0J5dGVzPWtleVNpemUqNDtyZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7a2V5OmtleSxpdjppdixzYWx0OnNhbHR9KX19O3ZhciBQYXNzd29yZEJhc2VkQ2lwaGVyPUNfbGliLlBhc3N3b3JkQmFzZWRDaXBoZXI9U2VyaWFsaXphYmxlQ2lwaGVyLmV4dGVuZCh7Y2ZnOlNlcmlhbGl6YWJsZUNpcGhlci5jZmcuZXh0ZW5kKHtrZGY6T3BlblNTTEtkZn0pLGVuY3J5cHQ6ZnVuY3Rpb24oY2lwaGVyLG1lc3NhZ2UscGFzc3dvcmQsY2ZnKXtjZmc9dGhpcy5jZmcuZXh0ZW5kKGNmZyk7dmFyIGRlcml2ZWRQYXJhbXM9Y2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLGNpcGhlci5rZXlTaXplLGNpcGhlci5pdlNpemUpO2NmZy5pdj1kZXJpdmVkUGFyYW1zLml2O3ZhciBjaXBoZXJ0ZXh0PVNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0LmNhbGwodGhpcyxjaXBoZXIsbWVzc2FnZSxkZXJpdmVkUGFyYW1zLmtleSxjZmcpO1xuY2lwaGVydGV4dC5taXhJbihkZXJpdmVkUGFyYW1zKTtyZXR1cm4gY2lwaGVydGV4dH0sZGVjcnlwdDpmdW5jdGlvbihjaXBoZXIsY2lwaGVydGV4dCxwYXNzd29yZCxjZmcpe2NmZz10aGlzLmNmZy5leHRlbmQoY2ZnKTtjaXBoZXJ0ZXh0PXRoaXMuX3BhcnNlKGNpcGhlcnRleHQsY2ZnLmZvcm1hdCk7dmFyIGRlcml2ZWRQYXJhbXM9Y2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLGNpcGhlci5rZXlTaXplLGNpcGhlci5pdlNpemUsY2lwaGVydGV4dC5zYWx0KTtjZmcuaXY9ZGVyaXZlZFBhcmFtcy5pdjt2YXIgcGxhaW50ZXh0PVNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0LmNhbGwodGhpcyxjaXBoZXIsY2lwaGVydGV4dCxkZXJpdmVkUGFyYW1zLmtleSxjZmcpO3JldHVybiBwbGFpbnRleHR9fSl9KCl9KX0se1wiLi9jb3JlXCI6MjB9XSwyMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSl7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmYWN0b3J5KX1lbHNle3Jvb3QuQ3J5cHRvSlM9ZmFjdG9yeSgpfX0pKHRoaXMsZnVuY3Rpb24oKXt2YXIgQ3J5cHRvSlM9Q3J5cHRvSlN8fGZ1bmN0aW9uKE1hdGgsdW5kZWZpbmVkKXt2YXIgQz17fTt2YXIgQ19saWI9Qy5saWI9e307dmFyIEJhc2U9Q19saWIuQmFzZT1mdW5jdGlvbigpe2Z1bmN0aW9uIEYoKXt9cmV0dXJue2V4dGVuZDpmdW5jdGlvbihvdmVycmlkZXMpe0YucHJvdG90eXBlPXRoaXM7dmFyIHN1YnR5cGU9bmV3IEY7aWYob3ZlcnJpZGVzKXtzdWJ0eXBlLm1peEluKG92ZXJyaWRlcyl9aWYoIXN1YnR5cGUuaGFzT3duUHJvcGVydHkoXCJpbml0XCIpKXtzdWJ0eXBlLmluaXQ9ZnVuY3Rpb24oKXtzdWJ0eXBlLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX19c3VidHlwZS5pbml0LnByb3RvdHlwZT1zdWJ0eXBlO3N1YnR5cGUuJHN1cGVyPXRoaXM7cmV0dXJuIHN1YnR5cGV9LGNyZWF0ZTpmdW5jdGlvbigpe3ZhciBpbnN0YW5jZT10aGlzLmV4dGVuZCgpO2luc3RhbmNlLmluaXQuYXBwbHkoaW5zdGFuY2UsYXJndW1lbnRzKTtyZXR1cm4gaW5zdGFuY2V9LGluaXQ6ZnVuY3Rpb24oKXt9LG1peEluOmZ1bmN0aW9uKHByb3BlcnRpZXMpe2Zvcih2YXIgcHJvcGVydHlOYW1lIGluIHByb3BlcnRpZXMpe2lmKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSl7dGhpc1twcm9wZXJ0eU5hbWVdPXByb3BlcnRpZXNbcHJvcGVydHlOYW1lXX19aWYocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcInRvU3RyaW5nXCIpKXt0aGlzLnRvU3RyaW5nPXByb3BlcnRpZXMudG9TdHJpbmd9fSxjbG9uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKX19fSgpO3ZhciBXb3JkQXJyYXk9Q19saWIuV29yZEFycmF5PUJhc2UuZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKHdvcmRzLHNpZ0J5dGVzKXt3b3Jkcz10aGlzLndvcmRzPXdvcmRzfHxbXTtpZihzaWdCeXRlcyE9dW5kZWZpbmVkKXt0aGlzLnNpZ0J5dGVzPXNpZ0J5dGVzfWVsc2V7dGhpcy5zaWdCeXRlcz13b3Jkcy5sZW5ndGgqNH19LHRvU3RyaW5nOmZ1bmN0aW9uKGVuY29kZXIpe3JldHVybihlbmNvZGVyfHxIZXgpLnN0cmluZ2lmeSh0aGlzKX0sY29uY2F0OmZ1bmN0aW9uKHdvcmRBcnJheSl7dmFyIHRoaXNXb3Jkcz10aGlzLndvcmRzO3ZhciB0aGF0V29yZHM9d29yZEFycmF5LndvcmRzO3ZhciB0aGlzU2lnQnl0ZXM9dGhpcy5zaWdCeXRlczt2YXIgdGhhdFNpZ0J5dGVzPXdvcmRBcnJheS5zaWdCeXRlczt0aGlzLmNsYW1wKCk7aWYodGhpc1NpZ0J5dGVzJTQpe2Zvcih2YXIgaT0wO2k8dGhhdFNpZ0J5dGVzO2krKyl7dmFyIHRoYXRCeXRlPXRoYXRXb3Jkc1tpPj4+Ml0+Pj4yNC1pJTQqOCYyNTU7dGhpc1dvcmRzW3RoaXNTaWdCeXRlcytpPj4+Ml18PXRoYXRCeXRlPDwyNC0odGhpc1NpZ0J5dGVzK2kpJTQqOH19ZWxzZSBpZih0aGF0V29yZHMubGVuZ3RoPjI1Nil7Zm9yKHZhciBpPTA7aTx0aGF0U2lnQnl0ZXM7aSs9NCl7dGhpc1dvcmRzW3RoaXNTaWdCeXRlcytpPj4+Ml09dGhhdFdvcmRzW2k+Pj4yXX19ZWxzZXt0aGlzV29yZHMucHVzaC5hcHBseSh0aGlzV29yZHMsdGhhdFdvcmRzKX10aGlzLnNpZ0J5dGVzKz10aGF0U2lnQnl0ZXM7cmV0dXJuIHRoaXN9LGNsYW1wOmZ1bmN0aW9uKCl7dmFyIHdvcmRzPXRoaXMud29yZHM7dmFyIHNpZ0J5dGVzPXRoaXMuc2lnQnl0ZXM7d29yZHNbc2lnQnl0ZXM+Pj4yXSY9NDI5NDk2NzI5NTw8MzItc2lnQnl0ZXMlNCo4O3dvcmRzLmxlbmd0aD1NYXRoLmNlaWwoc2lnQnl0ZXMvNCl9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGNsb25lPUJhc2UuY2xvbmUuY2FsbCh0aGlzKTtjbG9uZS53b3Jkcz10aGlzLndvcmRzLnNsaWNlKDApO3JldHVybiBjbG9uZX0scmFuZG9tOmZ1bmN0aW9uKG5CeXRlcyl7dmFyIHdvcmRzPVtdO2Zvcih2YXIgaT0wO2k8bkJ5dGVzO2krPTQpe3dvcmRzLnB1c2goTWF0aC5yYW5kb20oKSo0Mjk0OTY3Mjk2fDApfXJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsbkJ5dGVzKX19KTt2YXIgQ19lbmM9Qy5lbmM9e307dmFyIEhleD1DX2VuYy5IZXg9e3N0cmluZ2lmeTpmdW5jdGlvbih3b3JkQXJyYXkpe3ZhciB3b3Jkcz13b3JkQXJyYXkud29yZHM7dmFyIHNpZ0J5dGVzPXdvcmRBcnJheS5zaWdCeXRlczt2YXIgaGV4Q2hhcnM9W107Zm9yKHZhciBpPTA7aTxzaWdCeXRlcztpKyspe3ZhciBiaXRlPXdvcmRzW2k+Pj4yXT4+PjI0LWklNCo4JjI1NTtoZXhDaGFycy5wdXNoKChiaXRlPj4+NCkudG9TdHJpbmcoMTYpKTtoZXhDaGFycy5wdXNoKChiaXRlJjE1KS50b1N0cmluZygxNikpfXJldHVybiBoZXhDaGFycy5qb2luKFwiXCIpfSxwYXJzZTpmdW5jdGlvbihoZXhTdHIpe3ZhciBoZXhTdHJMZW5ndGg9aGV4U3RyLmxlbmd0aDt2YXIgd29yZHM9W107Zm9yKHZhciBpPTA7aTxoZXhTdHJMZW5ndGg7aSs9Mil7d29yZHNbaT4+PjNdfD1wYXJzZUludChoZXhTdHIuc3Vic3RyKGksMiksMTYpPDwyNC1pJTgqNH1yZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLGhleFN0ckxlbmd0aC8yKX19O3ZhciBMYXRpbjE9Q19lbmMuTGF0aW4xPXtzdHJpbmdpZnk6ZnVuY3Rpb24od29yZEFycmF5KXt2YXIgd29yZHM9d29yZEFycmF5LndvcmRzO3ZhciBzaWdCeXRlcz13b3JkQXJyYXkuc2lnQnl0ZXM7dmFyIGxhdGluMUNoYXJzPVtdO2Zvcih2YXIgaT0wO2k8c2lnQnl0ZXM7aSsrKXt2YXIgYml0ZT13b3Jkc1tpPj4+Ml0+Pj4yNC1pJTQqOCYyNTU7bGF0aW4xQ2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJpdGUpKX1yZXR1cm4gbGF0aW4xQ2hhcnMuam9pbihcIlwiKX0scGFyc2U6ZnVuY3Rpb24obGF0aW4xU3RyKXt2YXIgbGF0aW4xU3RyTGVuZ3RoPWxhdGluMVN0ci5sZW5ndGg7dmFyIHdvcmRzPVtdO2Zvcih2YXIgaT0wO2k8bGF0aW4xU3RyTGVuZ3RoO2krKyl7d29yZHNbaT4+PjJdfD0obGF0aW4xU3RyLmNoYXJDb2RlQXQoaSkmMjU1KTw8MjQtaSU0Kjh9cmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcyxsYXRpbjFTdHJMZW5ndGgpfX07dmFyIFV0Zjg9Q19lbmMuVXRmOD17c3RyaW5naWZ5OmZ1bmN0aW9uKHdvcmRBcnJheSl7dHJ5e3JldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKExhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KSkpfWNhdGNoKGUpe3Rocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBVVEYtOCBkYXRhXCIpfX0scGFyc2U6ZnVuY3Rpb24odXRmOFN0cil7cmV0dXJuIExhdGluMS5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodXRmOFN0cikpKX19O3ZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtPUNfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG09QmFzZS5leHRlbmQoe3Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5fZGF0YT1uZXcgV29yZEFycmF5LmluaXQ7dGhpcy5fbkRhdGFCeXRlcz0wfSxfYXBwZW5kOmZ1bmN0aW9uKGRhdGEpe2lmKHR5cGVvZiBkYXRhPT1cInN0cmluZ1wiKXtkYXRhPVV0ZjgucGFyc2UoZGF0YSl9dGhpcy5fZGF0YS5jb25jYXQoZGF0YSk7dGhpcy5fbkRhdGFCeXRlcys9ZGF0YS5zaWdCeXRlc30sX3Byb2Nlc3M6ZnVuY3Rpb24oZG9GbHVzaCl7dmFyIGRhdGE9dGhpcy5fZGF0YTt2YXIgZGF0YVdvcmRzPWRhdGEud29yZHM7dmFyIGRhdGFTaWdCeXRlcz1kYXRhLnNpZ0J5dGVzO3ZhciBibG9ja1NpemU9dGhpcy5ibG9ja1NpemU7dmFyIGJsb2NrU2l6ZUJ5dGVzPWJsb2NrU2l6ZSo0O3ZhciBuQmxvY2tzUmVhZHk9ZGF0YVNpZ0J5dGVzL2Jsb2NrU2l6ZUJ5dGVzO2lmKGRvRmx1c2gpe25CbG9ja3NSZWFkeT1NYXRoLmNlaWwobkJsb2Nrc1JlYWR5KX1lbHNle25CbG9ja3NSZWFkeT1NYXRoLm1heCgobkJsb2Nrc1JlYWR5fDApLXRoaXMuX21pbkJ1ZmZlclNpemUsMCl9dmFyIG5Xb3Jkc1JlYWR5PW5CbG9ja3NSZWFkeSpibG9ja1NpemU7dmFyIG5CeXRlc1JlYWR5PU1hdGgubWluKG5Xb3Jkc1JlYWR5KjQsZGF0YVNpZ0J5dGVzKTtpZihuV29yZHNSZWFkeSl7Zm9yKHZhciBvZmZzZXQ9MDtvZmZzZXQ8bldvcmRzUmVhZHk7b2Zmc2V0Kz1ibG9ja1NpemUpe3RoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3JkcyxvZmZzZXQpfXZhciBwcm9jZXNzZWRXb3Jkcz1kYXRhV29yZHMuc3BsaWNlKDAsbldvcmRzUmVhZHkpO2RhdGEuc2lnQnl0ZXMtPW5CeXRlc1JlYWR5fXJldHVybiBuZXcgV29yZEFycmF5LmluaXQocHJvY2Vzc2VkV29yZHMsbkJ5dGVzUmVhZHkpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciBjbG9uZT1CYXNlLmNsb25lLmNhbGwodGhpcyk7Y2xvbmUuX2RhdGE9dGhpcy5fZGF0YS5jbG9uZSgpO3JldHVybiBjbG9uZX0sX21pbkJ1ZmZlclNpemU6MH0pO3ZhciBIYXNoZXI9Q19saWIuSGFzaGVyPUJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtjZmc6QmFzZS5leHRlbmQoKSxpbml0OmZ1bmN0aW9uKGNmZyl7dGhpcy5jZmc9dGhpcy5jZmcuZXh0ZW5kKGNmZyk7dGhpcy5yZXNldCgpfSxyZXNldDpmdW5jdGlvbigpe0J1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTt0aGlzLl9kb1Jlc2V0KCl9LHVwZGF0ZTpmdW5jdGlvbihtZXNzYWdlVXBkYXRlKXt0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7dGhpcy5fcHJvY2VzcygpO3JldHVybiB0aGlzfSxmaW5hbGl6ZTpmdW5jdGlvbihtZXNzYWdlVXBkYXRlKXtpZihtZXNzYWdlVXBkYXRlKXt0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSl9dmFyIGhhc2g9dGhpcy5fZG9GaW5hbGl6ZSgpO3JldHVybiBoYXNofSxibG9ja1NpemU6NTEyLzMyLF9jcmVhdGVIZWxwZXI6ZnVuY3Rpb24oaGFzaGVyKXtyZXR1cm4gZnVuY3Rpb24obWVzc2FnZSxjZmcpe3JldHVybiBuZXcgaGFzaGVyLmluaXQoY2ZnKS5maW5hbGl6ZShtZXNzYWdlKX19LF9jcmVhdGVIbWFjSGVscGVyOmZ1bmN0aW9uKGhhc2hlcil7cmV0dXJuIGZ1bmN0aW9uKG1lc3NhZ2Usa2V5KXtyZXR1cm4gbmV3IENfYWxnby5ITUFDLmluaXQoaGFzaGVyLGtleSkuZmluYWxpemUobWVzc2FnZSl9fX0pO3ZhciBDX2FsZ289Qy5hbGdvPXt9O3JldHVybiBDfShNYXRoKTtyZXR1cm4gQ3J5cHRvSlN9KX0se31dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5KXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbigpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgV29yZEFycmF5PUNfbGliLldvcmRBcnJheTt2YXIgQ19lbmM9Qy5lbmM7dmFyIEJhc2U2ND1DX2VuYy5CYXNlNjQ9e3N0cmluZ2lmeTpmdW5jdGlvbih3b3JkQXJyYXkpe3ZhciB3b3Jkcz13b3JkQXJyYXkud29yZHM7dmFyIHNpZ0J5dGVzPXdvcmRBcnJheS5zaWdCeXRlczt2YXIgbWFwPXRoaXMuX21hcDt3b3JkQXJyYXkuY2xhbXAoKTt2YXIgYmFzZTY0Q2hhcnM9W107Zm9yKHZhciBpPTA7aTxzaWdCeXRlcztpKz0zKXt2YXIgYnl0ZTE9d29yZHNbaT4+PjJdPj4+MjQtaSU0KjgmMjU1O3ZhciBieXRlMj13b3Jkc1tpKzE+Pj4yXT4+PjI0LShpKzEpJTQqOCYyNTU7dmFyIGJ5dGUzPXdvcmRzW2krMj4+PjJdPj4+MjQtKGkrMiklNCo4JjI1NTt2YXIgdHJpcGxldD1ieXRlMTw8MTZ8Ynl0ZTI8PDh8Ynl0ZTM7Zm9yKHZhciBqPTA7ajw0JiZpK2oqLjc1PHNpZ0J5dGVzO2orKyl7YmFzZTY0Q2hhcnMucHVzaChtYXAuY2hhckF0KHRyaXBsZXQ+Pj42KigzLWopJjYzKSl9fXZhciBwYWRkaW5nQ2hhcj1tYXAuY2hhckF0KDY0KTtpZihwYWRkaW5nQ2hhcil7d2hpbGUoYmFzZTY0Q2hhcnMubGVuZ3RoJTQpe2Jhc2U2NENoYXJzLnB1c2gocGFkZGluZ0NoYXIpfX1yZXR1cm4gYmFzZTY0Q2hhcnMuam9pbihcIlwiKX0scGFyc2U6ZnVuY3Rpb24oYmFzZTY0U3RyKXt2YXIgYmFzZTY0U3RyTGVuZ3RoPWJhc2U2NFN0ci5sZW5ndGg7dmFyIG1hcD10aGlzLl9tYXA7dmFyIHBhZGRpbmdDaGFyPW1hcC5jaGFyQXQoNjQpO2lmKHBhZGRpbmdDaGFyKXt2YXIgcGFkZGluZ0luZGV4PWJhc2U2NFN0ci5pbmRleE9mKHBhZGRpbmdDaGFyKTtpZihwYWRkaW5nSW5kZXghPS0xKXtiYXNlNjRTdHJMZW5ndGg9cGFkZGluZ0luZGV4fX12YXIgd29yZHM9W107dmFyIG5CeXRlcz0wO2Zvcih2YXIgaT0wO2k8YmFzZTY0U3RyTGVuZ3RoO2krKyl7aWYoaSU0KXt2YXIgYml0czE9bWFwLmluZGV4T2YoYmFzZTY0U3RyLmNoYXJBdChpLTEpKTw8aSU0KjI7dmFyIGJpdHMyPW1hcC5pbmRleE9mKGJhc2U2NFN0ci5jaGFyQXQoaSkpPj4+Ni1pJTQqMjt3b3Jkc1tuQnl0ZXM+Pj4yXXw9KGJpdHMxfGJpdHMyKTw8MjQtbkJ5dGVzJTQqODtuQnl0ZXMrK319cmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsbkJ5dGVzKX0sX21hcDpcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCJ9fSkoKTtyZXR1cm4gQ3J5cHRvSlMuZW5jLkJhc2U2NH0pfSx7XCIuL2NvcmVcIjoyMH1dLDIyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5KXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbigpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgV29yZEFycmF5PUNfbGliLldvcmRBcnJheTt2YXIgQ19lbmM9Qy5lbmM7dmFyIFV0ZjE2QkU9Q19lbmMuVXRmMTY9Q19lbmMuVXRmMTZCRT17c3RyaW5naWZ5OmZ1bmN0aW9uKHdvcmRBcnJheSl7dmFyIHdvcmRzPXdvcmRBcnJheS53b3Jkczt2YXIgc2lnQnl0ZXM9d29yZEFycmF5LnNpZ0J5dGVzO3ZhciB1dGYxNkNoYXJzPVtdO2Zvcih2YXIgaT0wO2k8c2lnQnl0ZXM7aSs9Mil7dmFyIGNvZGVQb2ludD13b3Jkc1tpPj4+Ml0+Pj4xNi1pJTQqOCY2NTUzNTt1dGYxNkNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKX1yZXR1cm4gdXRmMTZDaGFycy5qb2luKFwiXCIpfSxwYXJzZTpmdW5jdGlvbih1dGYxNlN0cil7dmFyIHV0ZjE2U3RyTGVuZ3RoPXV0ZjE2U3RyLmxlbmd0aDt2YXIgd29yZHM9W107Zm9yKHZhciBpPTA7aTx1dGYxNlN0ckxlbmd0aDtpKyspe3dvcmRzW2k+Pj4xXXw9dXRmMTZTdHIuY2hhckNvZGVBdChpKTw8MTYtaSUyKjE2fXJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLHV0ZjE2U3RyTGVuZ3RoKjIpfX07Q19lbmMuVXRmMTZMRT17c3RyaW5naWZ5OmZ1bmN0aW9uKHdvcmRBcnJheSl7dmFyIHdvcmRzPXdvcmRBcnJheS53b3Jkczt2YXIgc2lnQnl0ZXM9d29yZEFycmF5LnNpZ0J5dGVzO3ZhciB1dGYxNkNoYXJzPVtdO2Zvcih2YXIgaT0wO2k8c2lnQnl0ZXM7aSs9Mil7dmFyIGNvZGVQb2ludD1zd2FwRW5kaWFuKHdvcmRzW2k+Pj4yXT4+PjE2LWklNCo4JjY1NTM1KTt1dGYxNkNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKX1yZXR1cm4gdXRmMTZDaGFycy5qb2luKFwiXCIpfSxwYXJzZTpmdW5jdGlvbih1dGYxNlN0cil7dmFyIHV0ZjE2U3RyTGVuZ3RoPXV0ZjE2U3RyLmxlbmd0aDt2YXIgd29yZHM9W107Zm9yKHZhciBpPTA7aTx1dGYxNlN0ckxlbmd0aDtpKyspe3dvcmRzW2k+Pj4xXXw9c3dhcEVuZGlhbih1dGYxNlN0ci5jaGFyQ29kZUF0KGkpPDwxNi1pJTIqMTYpfXJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLHV0ZjE2U3RyTGVuZ3RoKjIpfX07ZnVuY3Rpb24gc3dhcEVuZGlhbih3b3JkKXtyZXR1cm4gd29yZDw8OCY0Mjc4MjU1MzYwfHdvcmQ+Pj44JjE2NzExOTM1fX0pKCk7cmV0dXJuIENyeXB0b0pTLmVuYy5VdGYxNn0pfSx7XCIuL2NvcmVcIjoyMH1dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL3NoYTFcIiksX2RlcmVxXyhcIi4vaG1hY1wiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL3NoYTFcIixcIi4vaG1hY1wiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBCYXNlPUNfbGliLkJhc2U7dmFyIFdvcmRBcnJheT1DX2xpYi5Xb3JkQXJyYXk7dmFyIENfYWxnbz1DLmFsZ287dmFyIE1ENT1DX2FsZ28uTUQ1O3ZhciBFdnBLREY9Q19hbGdvLkV2cEtERj1CYXNlLmV4dGVuZCh7Y2ZnOkJhc2UuZXh0ZW5kKHtrZXlTaXplOjEyOC8zMixoYXNoZXI6TUQ1LGl0ZXJhdGlvbnM6MX0pLGluaXQ6ZnVuY3Rpb24oY2ZnKXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQoY2ZnKX0sY29tcHV0ZTpmdW5jdGlvbihwYXNzd29yZCxzYWx0KXt2YXIgY2ZnPXRoaXMuY2ZnO3ZhciBoYXNoZXI9Y2ZnLmhhc2hlci5jcmVhdGUoKTt2YXIgZGVyaXZlZEtleT1Xb3JkQXJyYXkuY3JlYXRlKCk7dmFyIGRlcml2ZWRLZXlXb3Jkcz1kZXJpdmVkS2V5LndvcmRzO3ZhciBrZXlTaXplPWNmZy5rZXlTaXplO3ZhciBpdGVyYXRpb25zPWNmZy5pdGVyYXRpb25zO3doaWxlKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGg8a2V5U2l6ZSl7aWYoYmxvY2spe2hhc2hlci51cGRhdGUoYmxvY2spfXZhciBibG9jaz1oYXNoZXIudXBkYXRlKHBhc3N3b3JkKS5maW5hbGl6ZShzYWx0KTtoYXNoZXIucmVzZXQoKTtmb3IodmFyIGk9MTtpPGl0ZXJhdGlvbnM7aSsrKXtibG9jaz1oYXNoZXIuZmluYWxpemUoYmxvY2spO2hhc2hlci5yZXNldCgpfWRlcml2ZWRLZXkuY29uY2F0KGJsb2NrKX1kZXJpdmVkS2V5LnNpZ0J5dGVzPWtleVNpemUqNDtyZXR1cm4gZGVyaXZlZEtleX19KTtDLkV2cEtERj1mdW5jdGlvbihwYXNzd29yZCxzYWx0LGNmZyl7cmV0dXJuIEV2cEtERi5jcmVhdGUoY2ZnKS5jb21wdXRlKHBhc3N3b3JkLHNhbHQpfX0pKCk7cmV0dXJuIENyeXB0b0pTLkV2cEtERn0pfSx7XCIuL2NvcmVcIjoyMCxcIi4vaG1hY1wiOjI2LFwiLi9zaGExXCI6NDV9XSwyNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9jaXBoZXItY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL2NpcGhlci1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24odW5kZWZpbmVkKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIENpcGhlclBhcmFtcz1DX2xpYi5DaXBoZXJQYXJhbXM7dmFyIENfZW5jPUMuZW5jO3ZhciBIZXg9Q19lbmMuSGV4O3ZhciBDX2Zvcm1hdD1DLmZvcm1hdDt2YXIgSGV4Rm9ybWF0dGVyPUNfZm9ybWF0LkhleD17c3RyaW5naWZ5OmZ1bmN0aW9uKGNpcGhlclBhcmFtcyl7cmV0dXJuIGNpcGhlclBhcmFtcy5jaXBoZXJ0ZXh0LnRvU3RyaW5nKEhleCl9LHBhcnNlOmZ1bmN0aW9uKGlucHV0KXt2YXIgY2lwaGVydGV4dD1IZXgucGFyc2UoaW5wdXQpO3JldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHtjaXBoZXJ0ZXh0OmNpcGhlcnRleHR9KX19fSkoKTtyZXR1cm4gQ3J5cHRvSlMuZm9ybWF0LkhleH0pfSx7XCIuL2NpcGhlci1jb3JlXCI6MTksXCIuL2NvcmVcIjoyMH1dLDI1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL3NoYTI1NlwiKSxfZGVyZXFfKFwiLi9obWFjXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vc2hhMjU2XCIsXCIuL2htYWNcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpe3JldHVybiBDcnlwdG9KUy5IbWFjU0hBMjU2fSl9LHtcIi4vY29yZVwiOjIwLFwiLi9obWFjXCI6MjYsXCIuL3NoYTI1NlwiOjQ3fV0sMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3Rvcnkpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBCYXNlPUNfbGliLkJhc2U7dmFyIENfZW5jPUMuZW5jO3ZhciBVdGY4PUNfZW5jLlV0Zjg7dmFyIENfYWxnbz1DLmFsZ287dmFyIEhNQUM9Q19hbGdvLkhNQUM9QmFzZS5leHRlbmQoe2luaXQ6ZnVuY3Rpb24oaGFzaGVyLGtleSl7aGFzaGVyPXRoaXMuX2hhc2hlcj1uZXcgaGFzaGVyLmluaXQ7aWYodHlwZW9mIGtleT09XCJzdHJpbmdcIil7a2V5PVV0ZjgucGFyc2Uoa2V5KX12YXIgaGFzaGVyQmxvY2tTaXplPWhhc2hlci5ibG9ja1NpemU7dmFyIGhhc2hlckJsb2NrU2l6ZUJ5dGVzPWhhc2hlckJsb2NrU2l6ZSo0O2lmKGtleS5zaWdCeXRlcz5oYXNoZXJCbG9ja1NpemVCeXRlcyl7a2V5PWhhc2hlci5maW5hbGl6ZShrZXkpfWtleS5jbGFtcCgpO3ZhciBvS2V5PXRoaXMuX29LZXk9a2V5LmNsb25lKCk7dmFyIGlLZXk9dGhpcy5faUtleT1rZXkuY2xvbmUoKTt2YXIgb0tleVdvcmRzPW9LZXkud29yZHM7dmFyIGlLZXlXb3Jkcz1pS2V5LndvcmRzO2Zvcih2YXIgaT0wO2k8aGFzaGVyQmxvY2tTaXplO2krKyl7b0tleVdvcmRzW2ldXj0xNTQ5NTU2ODI4O2lLZXlXb3Jkc1tpXV49OTA5NTIyNDg2fW9LZXkuc2lnQnl0ZXM9aUtleS5zaWdCeXRlcz1oYXNoZXJCbG9ja1NpemVCeXRlczt0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7dmFyIGhhc2hlcj10aGlzLl9oYXNoZXI7aGFzaGVyLnJlc2V0KCk7aGFzaGVyLnVwZGF0ZSh0aGlzLl9pS2V5KX0sdXBkYXRlOmZ1bmN0aW9uKG1lc3NhZ2VVcGRhdGUpe3RoaXMuX2hhc2hlci51cGRhdGUobWVzc2FnZVVwZGF0ZSk7cmV0dXJuIHRoaXN9LGZpbmFsaXplOmZ1bmN0aW9uKG1lc3NhZ2VVcGRhdGUpe3ZhciBoYXNoZXI9dGhpcy5faGFzaGVyO3ZhciBpbm5lckhhc2g9aGFzaGVyLmZpbmFsaXplKG1lc3NhZ2VVcGRhdGUpO2hhc2hlci5yZXNldCgpO3ZhciBobWFjPWhhc2hlci5maW5hbGl6ZSh0aGlzLl9vS2V5LmNsb25lKCkuY29uY2F0KGlubmVySGFzaCkpO3JldHVybiBobWFjfX0pfSkoKX0pfSx7XCIuL2NvcmVcIjoyMH1dLDI3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL3g2NC1jb3JlXCIpLF9kZXJlcV8oXCIuL2xpYi10eXBlZGFycmF5c1wiKSxfZGVyZXFfKFwiLi9lbmMtdXRmMTZcIiksX2RlcmVxXyhcIi4vZW5jLWJhc2U2NFwiKSxfZGVyZXFfKFwiLi9tZDVcIiksX2RlcmVxXyhcIi4vc2hhMVwiKSxfZGVyZXFfKFwiLi9zaGEyNTZcIiksX2RlcmVxXyhcIi4vc2hhMjI0XCIpLF9kZXJlcV8oXCIuL3NoYTUxMlwiKSxfZGVyZXFfKFwiLi9zaGEzODRcIiksX2RlcmVxXyhcIi4vc2hhM1wiKSxfZGVyZXFfKFwiLi9yaXBlbWQxNjBcIiksX2RlcmVxXyhcIi4vaG1hY1wiKSxfZGVyZXFfKFwiLi9wYmtkZjJcIiksX2RlcmVxXyhcIi4vZXZwa2RmXCIpLF9kZXJlcV8oXCIuL2NpcGhlci1jb3JlXCIpLF9kZXJlcV8oXCIuL21vZGUtY2ZiXCIpLF9kZXJlcV8oXCIuL21vZGUtY3RyXCIpLF9kZXJlcV8oXCIuL21vZGUtY3RyLWdsYWRtYW5cIiksX2RlcmVxXyhcIi4vbW9kZS1vZmJcIiksX2RlcmVxXyhcIi4vbW9kZS1lY2JcIiksX2RlcmVxXyhcIi4vcGFkLWFuc2l4OTIzXCIpLF9kZXJlcV8oXCIuL3BhZC1pc28xMDEyNlwiKSxfZGVyZXFfKFwiLi9wYWQtaXNvOTc5NzFcIiksX2RlcmVxXyhcIi4vcGFkLXplcm9wYWRkaW5nXCIpLF9kZXJlcV8oXCIuL3BhZC1ub3BhZGRpbmdcIiksX2RlcmVxXyhcIi4vZm9ybWF0LWhleFwiKSxfZGVyZXFfKFwiLi9hZXNcIiksX2RlcmVxXyhcIi4vdHJpcGxlZGVzXCIpLF9kZXJlcV8oXCIuL3JjNFwiKSxfZGVyZXFfKFwiLi9yYWJiaXRcIiksX2RlcmVxXyhcIi4vcmFiYml0LWxlZ2FjeVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL3g2NC1jb3JlXCIsXCIuL2xpYi10eXBlZGFycmF5c1wiLFwiLi9lbmMtdXRmMTZcIixcIi4vZW5jLWJhc2U2NFwiLFwiLi9tZDVcIixcIi4vc2hhMVwiLFwiLi9zaGEyNTZcIixcIi4vc2hhMjI0XCIsXCIuL3NoYTUxMlwiLFwiLi9zaGEzODRcIixcIi4vc2hhM1wiLFwiLi9yaXBlbWQxNjBcIixcIi4vaG1hY1wiLFwiLi9wYmtkZjJcIixcIi4vZXZwa2RmXCIsXCIuL2NpcGhlci1jb3JlXCIsXCIuL21vZGUtY2ZiXCIsXCIuL21vZGUtY3RyXCIsXCIuL21vZGUtY3RyLWdsYWRtYW5cIixcIi4vbW9kZS1vZmJcIixcIi4vbW9kZS1lY2JcIixcIi4vcGFkLWFuc2l4OTIzXCIsXCIuL3BhZC1pc28xMDEyNlwiLFwiLi9wYWQtaXNvOTc5NzFcIixcIi4vcGFkLXplcm9wYWRkaW5nXCIsXCIuL3BhZC1ub3BhZGRpbmdcIixcIi4vZm9ybWF0LWhleFwiLFwiLi9hZXNcIixcIi4vdHJpcGxlZGVzXCIsXCIuL3JjNFwiLFwiLi9yYWJiaXRcIixcIi4vcmFiYml0LWxlZ2FjeVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7cmV0dXJuIENyeXB0b0pTfSl9LHtcIi4vYWVzXCI6MTgsXCIuL2NpcGhlci1jb3JlXCI6MTksXCIuL2NvcmVcIjoyMCxcIi4vZW5jLWJhc2U2NFwiOjIxLFwiLi9lbmMtdXRmMTZcIjoyMixcIi4vZXZwa2RmXCI6MjMsXCIuL2Zvcm1hdC1oZXhcIjoyNCxcIi4vaG1hY1wiOjI2LFwiLi9saWItdHlwZWRhcnJheXNcIjoyOCxcIi4vbWQ1XCI6MjksXCIuL21vZGUtY2ZiXCI6MzAsXCIuL21vZGUtY3RyXCI6MzIsXCIuL21vZGUtY3RyLWdsYWRtYW5cIjozMSxcIi4vbW9kZS1lY2JcIjozMyxcIi4vbW9kZS1vZmJcIjozNCxcIi4vcGFkLWFuc2l4OTIzXCI6MzUsXCIuL3BhZC1pc28xMDEyNlwiOjM2LFwiLi9wYWQtaXNvOTc5NzFcIjozNyxcIi4vcGFkLW5vcGFkZGluZ1wiOjM4LFwiLi9wYWQtemVyb3BhZGRpbmdcIjozOSxcIi4vcGJrZGYyXCI6NDAsXCIuL3JhYmJpdFwiOjQyLFwiLi9yYWJiaXQtbGVnYWN5XCI6NDEsXCIuL3JjNFwiOjQzLFwiLi9yaXBlbWQxNjBcIjo0NCxcIi4vc2hhMVwiOjQ1LFwiLi9zaGEyMjRcIjo0NixcIi4vc2hhMjU2XCI6NDcsXCIuL3NoYTNcIjo0OCxcIi4vc2hhMzg0XCI6NDksXCIuL3NoYTUxMlwiOjUwLFwiLi90cmlwbGVkZXNcIjo1MSxcIi4veDY0LWNvcmVcIjo1Mn1dLDI4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5KXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbigpe2lmKHR5cGVvZiBBcnJheUJ1ZmZlciE9XCJmdW5jdGlvblwiKXtyZXR1cm59dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBXb3JkQXJyYXk9Q19saWIuV29yZEFycmF5O3ZhciBzdXBlckluaXQ9V29yZEFycmF5LmluaXQ7dmFyIHN1YkluaXQ9V29yZEFycmF5LmluaXQ9ZnVuY3Rpb24odHlwZWRBcnJheSl7aWYodHlwZWRBcnJheSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXt0eXBlZEFycmF5PW5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkpfWlmKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXl8fHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheXx8dHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXl8fHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheXx8dHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXl8fHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheXx8dHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8dHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSl7dHlwZWRBcnJheT1uZXcgVWludDhBcnJheSh0eXBlZEFycmF5LmJ1ZmZlcix0eXBlZEFycmF5LmJ5dGVPZmZzZXQsdHlwZWRBcnJheS5ieXRlTGVuZ3RoKX1pZih0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSl7dmFyIHR5cGVkQXJyYXlCeXRlTGVuZ3RoPXR5cGVkQXJyYXkuYnl0ZUxlbmd0aDt2YXIgd29yZHM9W107Zm9yKHZhciBpPTA7aTx0eXBlZEFycmF5Qnl0ZUxlbmd0aDtpKyspe3dvcmRzW2k+Pj4yXXw9dHlwZWRBcnJheVtpXTw8MjQtaSU0Kjh9c3VwZXJJbml0LmNhbGwodGhpcyx3b3Jkcyx0eXBlZEFycmF5Qnl0ZUxlbmd0aCl9ZWxzZXtzdXBlckluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfX07c3ViSW5pdC5wcm90b3R5cGU9V29yZEFycmF5fSkoKTtyZXR1cm4gQ3J5cHRvSlMubGliLldvcmRBcnJheX0pfSx7XCIuL2NvcmVcIjoyMH1dLDI5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5KXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbihNYXRoKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIFdvcmRBcnJheT1DX2xpYi5Xb3JkQXJyYXk7dmFyIEhhc2hlcj1DX2xpYi5IYXNoZXI7dmFyIENfYWxnbz1DLmFsZ287dmFyIFQ9W107KGZ1bmN0aW9uKCl7Zm9yKHZhciBpPTA7aTw2NDtpKyspe1RbaV09TWF0aC5hYnMoTWF0aC5zaW4oaSsxKSkqNDI5NDk2NzI5NnwwfX0pKCk7dmFyIE1ENT1DX2FsZ28uTUQ1PUhhc2hlci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgV29yZEFycmF5LmluaXQoWzE3MzI1ODQxOTMsNDAyMzIzMzQxNywyNTYyMzgzMTAyLDI3MTczMzg3OF0pfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24oTSxvZmZzZXQpe2Zvcih2YXIgaT0wO2k8MTY7aSsrKXt2YXIgb2Zmc2V0X2k9b2Zmc2V0K2k7dmFyIE1fb2Zmc2V0X2k9TVtvZmZzZXRfaV07TVtvZmZzZXRfaV09KE1fb2Zmc2V0X2k8PDh8TV9vZmZzZXRfaT4+PjI0KSYxNjcxMTkzNXwoTV9vZmZzZXRfaTw8MjR8TV9vZmZzZXRfaT4+PjgpJjQyNzgyNTUzNjB9dmFyIEg9dGhpcy5faGFzaC53b3Jkczt2YXIgTV9vZmZzZXRfMD1NW29mZnNldCswXTt2YXIgTV9vZmZzZXRfMT1NW29mZnNldCsxXTt2YXIgTV9vZmZzZXRfMj1NW29mZnNldCsyXTt2YXIgTV9vZmZzZXRfMz1NW29mZnNldCszXTt2YXIgTV9vZmZzZXRfND1NW29mZnNldCs0XTt2YXIgTV9vZmZzZXRfNT1NW29mZnNldCs1XTt2YXIgTV9vZmZzZXRfNj1NW29mZnNldCs2XTt2YXIgTV9vZmZzZXRfNz1NW29mZnNldCs3XTt2YXIgTV9vZmZzZXRfOD1NW29mZnNldCs4XTt2YXIgTV9vZmZzZXRfOT1NW29mZnNldCs5XTt2YXIgTV9vZmZzZXRfMTA9TVtvZmZzZXQrMTBdO3ZhciBNX29mZnNldF8xMT1NW29mZnNldCsxMV07dmFyIE1fb2Zmc2V0XzEyPU1bb2Zmc2V0KzEyXTt2YXIgTV9vZmZzZXRfMTM9TVtvZmZzZXQrMTNdO3ZhciBNX29mZnNldF8xND1NW29mZnNldCsxNF07dmFyIE1fb2Zmc2V0XzE1PU1bb2Zmc2V0KzE1XTt2YXIgYT1IWzBdO3ZhciBiPUhbMV07dmFyIGM9SFsyXTt2YXIgZD1IWzNdO2E9RkYoYSxiLGMsZCxNX29mZnNldF8wLDcsVFswXSk7ZD1GRihkLGEsYixjLE1fb2Zmc2V0XzEsMTIsVFsxXSk7Yz1GRihjLGQsYSxiLE1fb2Zmc2V0XzIsMTcsVFsyXSk7Yj1GRihiLGMsZCxhLE1fb2Zmc2V0XzMsMjIsVFszXSk7YT1GRihhLGIsYyxkLE1fb2Zmc2V0XzQsNyxUWzRdKTtkPUZGKGQsYSxiLGMsTV9vZmZzZXRfNSwxMixUWzVdKTtjPUZGKGMsZCxhLGIsTV9vZmZzZXRfNiwxNyxUWzZdKTtiPUZGKGIsYyxkLGEsTV9vZmZzZXRfNywyMixUWzddKTthPUZGKGEsYixjLGQsTV9vZmZzZXRfOCw3LFRbOF0pO2Q9RkYoZCxhLGIsYyxNX29mZnNldF85LDEyLFRbOV0pO2M9RkYoYyxkLGEsYixNX29mZnNldF8xMCwxNyxUWzEwXSk7Yj1GRihiLGMsZCxhLE1fb2Zmc2V0XzExLDIyLFRbMTFdKTthPUZGKGEsYixjLGQsTV9vZmZzZXRfMTIsNyxUWzEyXSk7ZD1GRihkLGEsYixjLE1fb2Zmc2V0XzEzLDEyLFRbMTNdKTtjPUZGKGMsZCxhLGIsTV9vZmZzZXRfMTQsMTcsVFsxNF0pO2I9RkYoYixjLGQsYSxNX29mZnNldF8xNSwyMixUWzE1XSk7YT1HRyhhLGIsYyxkLE1fb2Zmc2V0XzEsNSxUWzE2XSk7ZD1HRyhkLGEsYixjLE1fb2Zmc2V0XzYsOSxUWzE3XSk7Yz1HRyhjLGQsYSxiLE1fb2Zmc2V0XzExLDE0LFRbMThdKTtiPUdHKGIsYyxkLGEsTV9vZmZzZXRfMCwyMCxUWzE5XSk7YT1HRyhhLGIsYyxkLE1fb2Zmc2V0XzUsNSxUWzIwXSk7ZD1HRyhkLGEsYixjLE1fb2Zmc2V0XzEwLDksVFsyMV0pO2M9R0coYyxkLGEsYixNX29mZnNldF8xNSwxNCxUWzIyXSk7Yj1HRyhiLGMsZCxhLE1fb2Zmc2V0XzQsMjAsVFsyM10pO2E9R0coYSxiLGMsZCxNX29mZnNldF85LDUsVFsyNF0pO2Q9R0coZCxhLGIsYyxNX29mZnNldF8xNCw5LFRbMjVdKTtjPUdHKGMsZCxhLGIsTV9vZmZzZXRfMywxNCxUWzI2XSk7Yj1HRyhiLGMsZCxhLE1fb2Zmc2V0XzgsMjAsVFsyN10pO2E9R0coYSxiLGMsZCxNX29mZnNldF8xMyw1LFRbMjhdKTtkPUdHKGQsYSxiLGMsTV9vZmZzZXRfMiw5LFRbMjldKTtjPUdHKGMsZCxhLGIsTV9vZmZzZXRfNywxNCxUWzMwXSk7Yj1HRyhiLGMsZCxhLE1fb2Zmc2V0XzEyLDIwLFRbMzFdKTthPUhIKGEsYixjLGQsTV9vZmZzZXRfNSw0LFRbMzJdKTtkPUhIKGQsYSxiLGMsTV9vZmZzZXRfOCwxMSxUWzMzXSk7Yz1ISChjLGQsYSxiLE1fb2Zmc2V0XzExLDE2LFRbMzRdKTtiPUhIKGIsYyxkLGEsTV9vZmZzZXRfMTQsMjMsVFszNV0pO2E9SEgoYSxiLGMsZCxNX29mZnNldF8xLDQsVFszNl0pO2Q9SEgoZCxhLGIsYyxNX29mZnNldF80LDExLFRbMzddKTtjPUhIKGMsZCxhLGIsTV9vZmZzZXRfNywxNixUWzM4XSk7Yj1ISChiLGMsZCxhLE1fb2Zmc2V0XzEwLDIzLFRbMzldKTthPUhIKGEsYixjLGQsTV9vZmZzZXRfMTMsNCxUWzQwXSk7ZD1ISChkLGEsYixjLE1fb2Zmc2V0XzAsMTEsVFs0MV0pO2M9SEgoYyxkLGEsYixNX29mZnNldF8zLDE2LFRbNDJdKTtiPUhIKGIsYyxkLGEsTV9vZmZzZXRfNiwyMyxUWzQzXSk7YT1ISChhLGIsYyxkLE1fb2Zmc2V0XzksNCxUWzQ0XSk7ZD1ISChkLGEsYixjLE1fb2Zmc2V0XzEyLDExLFRbNDVdKTtjPUhIKGMsZCxhLGIsTV9vZmZzZXRfMTUsMTYsVFs0Nl0pO2I9SEgoYixjLGQsYSxNX29mZnNldF8yLDIzLFRbNDddKTthPUlJKGEsYixjLGQsTV9vZmZzZXRfMCw2LFRbNDhdKTtkPUlJKGQsYSxiLGMsTV9vZmZzZXRfNywxMCxUWzQ5XSk7Yz1JSShjLGQsYSxiLE1fb2Zmc2V0XzE0LDE1LFRbNTBdKTtiPUlJKGIsYyxkLGEsTV9vZmZzZXRfNSwyMSxUWzUxXSk7YT1JSShhLGIsYyxkLE1fb2Zmc2V0XzEyLDYsVFs1Ml0pO2Q9SUkoZCxhLGIsYyxNX29mZnNldF8zLDEwLFRbNTNdKTtjPUlJKGMsZCxhLGIsTV9vZmZzZXRfMTAsMTUsVFs1NF0pO2I9SUkoYixjLGQsYSxNX29mZnNldF8xLDIxLFRbNTVdKTthPUlJKGEsYixjLGQsTV9vZmZzZXRfOCw2LFRbNTZdKTtkPUlJKGQsYSxiLGMsTV9vZmZzZXRfMTUsMTAsVFs1N10pO2M9SUkoYyxkLGEsYixNX29mZnNldF82LDE1LFRbNThdKTtiPUlJKGIsYyxkLGEsTV9vZmZzZXRfMTMsMjEsVFs1OV0pO2E9SUkoYSxiLGMsZCxNX29mZnNldF80LDYsVFs2MF0pO2Q9SUkoZCxhLGIsYyxNX29mZnNldF8xMSwxMCxUWzYxXSk7Yz1JSShjLGQsYSxiLE1fb2Zmc2V0XzIsMTUsVFs2Ml0pO2I9SUkoYixjLGQsYSxNX29mZnNldF85LDIxLFRbNjNdKTtIWzBdPUhbMF0rYXwwO0hbMV09SFsxXStifDA7SFsyXT1IWzJdK2N8MDtIWzNdPUhbM10rZHwwfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciBkYXRhPXRoaXMuX2RhdGE7dmFyIGRhdGFXb3Jkcz1kYXRhLndvcmRzO3ZhciBuQml0c1RvdGFsPXRoaXMuX25EYXRhQnl0ZXMqODt2YXIgbkJpdHNMZWZ0PWRhdGEuc2lnQnl0ZXMqODtkYXRhV29yZHNbbkJpdHNMZWZ0Pj4+NV18PTEyODw8MjQtbkJpdHNMZWZ0JTMyO3ZhciBuQml0c1RvdGFsSD1NYXRoLmZsb29yKG5CaXRzVG90YWwvNDI5NDk2NzI5Nik7dmFyIG5CaXRzVG90YWxMPW5CaXRzVG90YWw7ZGF0YVdvcmRzWyhuQml0c0xlZnQrNjQ+Pj45PDw0KSsxNV09KG5CaXRzVG90YWxIPDw4fG5CaXRzVG90YWxIPj4+MjQpJjE2NzExOTM1fChuQml0c1RvdGFsSDw8MjR8bkJpdHNUb3RhbEg+Pj44KSY0Mjc4MjU1MzYwO2RhdGFXb3Jkc1sobkJpdHNMZWZ0KzY0Pj4+OTw8NCkrMTRdPShuQml0c1RvdGFsTDw8OHxuQml0c1RvdGFsTD4+PjI0KSYxNjcxMTkzNXwobkJpdHNUb3RhbEw8PDI0fG5CaXRzVG90YWxMPj4+OCkmNDI3ODI1NTM2MDtkYXRhLnNpZ0J5dGVzPShkYXRhV29yZHMubGVuZ3RoKzEpKjQ7dGhpcy5fcHJvY2VzcygpO3ZhciBoYXNoPXRoaXMuX2hhc2g7dmFyIEg9aGFzaC53b3Jkcztmb3IodmFyIGk9MDtpPDQ7aSsrKXt2YXIgSF9pPUhbaV07SFtpXT0oSF9pPDw4fEhfaT4+PjI0KSYxNjcxMTkzNXwoSF9pPDwyNHxIX2k+Pj44KSY0Mjc4MjU1MzYwfXJldHVybiBoYXNofSxjbG9uZTpmdW5jdGlvbigpe3ZhciBjbG9uZT1IYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtjbG9uZS5faGFzaD10aGlzLl9oYXNoLmNsb25lKCk7cmV0dXJuIGNsb25lfX0pO2Z1bmN0aW9uIEZGKGEsYixjLGQseCxzLHQpe3ZhciBuPWErKGImY3x+YiZkKSt4K3Q7cmV0dXJuKG48PHN8bj4+PjMyLXMpK2J9ZnVuY3Rpb24gR0coYSxiLGMsZCx4LHMsdCl7dmFyIG49YSsoYiZkfGMmfmQpK3grdDtyZXR1cm4objw8c3xuPj4+MzItcykrYn1mdW5jdGlvbiBISChhLGIsYyxkLHgscyx0KXt2YXIgbj1hKyhiXmNeZCkreCt0O3JldHVybihuPDxzfG4+Pj4zMi1zKStifWZ1bmN0aW9uIElJKGEsYixjLGQseCxzLHQpe3ZhciBuPWErKGNeKGJ8fmQpKSt4K3Q7cmV0dXJuKG48PHN8bj4+PjMyLXMpK2J9Qy5NRDU9SGFzaGVyLl9jcmVhdGVIZWxwZXIoTUQ1KTtDLkhtYWNNRDU9SGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKE1ENSl9KShNYXRoKTtyZXR1cm4gQ3J5cHRvSlMuTUQ1fSl9LHtcIi4vY29yZVwiOjIwfV0sMzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vY2lwaGVyLWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9jaXBoZXItY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7Q3J5cHRvSlMubW9kZS5DRkI9ZnVuY3Rpb24oKXt2YXIgQ0ZCPUNyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7Q0ZCLkVuY3J5cHRvcj1DRkIuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24od29yZHMsb2Zmc2V0KXt2YXIgY2lwaGVyPXRoaXMuX2NpcGhlcjt2YXIgYmxvY2tTaXplPWNpcGhlci5ibG9ja1NpemU7Z2VuZXJhdGVLZXlzdHJlYW1BbmRFbmNyeXB0LmNhbGwodGhpcyx3b3JkcyxvZmZzZXQsYmxvY2tTaXplLGNpcGhlcik7dGhpcy5fcHJldkJsb2NrPXdvcmRzLnNsaWNlKG9mZnNldCxvZmZzZXQrYmxvY2tTaXplKX19KTtDRkIuRGVjcnlwdG9yPUNGQi5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih3b3JkcyxvZmZzZXQpe3ZhciBjaXBoZXI9dGhpcy5fY2lwaGVyO3ZhciBibG9ja1NpemU9Y2lwaGVyLmJsb2NrU2l6ZTt2YXIgdGhpc0Jsb2NrPXdvcmRzLnNsaWNlKG9mZnNldCxvZmZzZXQrYmxvY2tTaXplKTtnZW5lcmF0ZUtleXN0cmVhbUFuZEVuY3J5cHQuY2FsbCh0aGlzLHdvcmRzLG9mZnNldCxibG9ja1NpemUsY2lwaGVyKTt0aGlzLl9wcmV2QmxvY2s9dGhpc0Jsb2NrfX0pO2Z1bmN0aW9uIGdlbmVyYXRlS2V5c3RyZWFtQW5kRW5jcnlwdCh3b3JkcyxvZmZzZXQsYmxvY2tTaXplLGNpcGhlcil7dmFyIGl2PXRoaXMuX2l2O2lmKGl2KXt2YXIga2V5c3RyZWFtPWl2LnNsaWNlKDApO3RoaXMuX2l2PXVuZGVmaW5lZH1lbHNle3ZhciBrZXlzdHJlYW09dGhpcy5fcHJldkJsb2NrfWNpcGhlci5lbmNyeXB0QmxvY2soa2V5c3RyZWFtLDApO2Zvcih2YXIgaT0wO2k8YmxvY2tTaXplO2krKyl7d29yZHNbb2Zmc2V0K2ldXj1rZXlzdHJlYW1baV19fXJldHVybiBDRkJ9KCk7cmV0dXJuIENyeXB0b0pTLm1vZGUuQ0ZCfSl9LHtcIi4vY2lwaGVyLWNvcmVcIjoxOSxcIi4vY29yZVwiOjIwfV0sMzE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vY2lwaGVyLWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9jaXBoZXItY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7Q3J5cHRvSlMubW9kZS5DVFJHbGFkbWFuPWZ1bmN0aW9uKCl7dmFyIENUUkdsYWRtYW49Q3J5cHRvSlMubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtmdW5jdGlvbiBpbmNXb3JkKHdvcmQpe2lmKCh3b3JkPj4yNCYyNTUpPT09MjU1KXt2YXIgYjE9d29yZD4+MTYmMjU1O3ZhciBiMj13b3JkPj44JjI1NTt2YXIgYjM9d29yZCYyNTU7aWYoYjE9PT0yNTUpe2IxPTA7aWYoYjI9PT0yNTUpe2IyPTA7aWYoYjM9PT0yNTUpe2IzPTB9ZWxzZXsrK2IzfX1lbHNleysrYjJ9fWVsc2V7KytiMX13b3JkPTA7d29yZCs9YjE8PDE2O3dvcmQrPWIyPDw4O3dvcmQrPWIzfWVsc2V7d29yZCs9MTw8MjR9cmV0dXJuIHdvcmR9ZnVuY3Rpb24gaW5jQ291bnRlcihjb3VudGVyKXtpZigoY291bnRlclswXT1pbmNXb3JkKGNvdW50ZXJbMF0pKT09PTApe2NvdW50ZXJbMV09aW5jV29yZChjb3VudGVyWzFdKX1yZXR1cm4gY291bnRlcn12YXIgRW5jcnlwdG9yPUNUUkdsYWRtYW4uRW5jcnlwdG9yPUNUUkdsYWRtYW4uZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24od29yZHMsb2Zmc2V0KXt2YXIgY2lwaGVyPXRoaXMuX2NpcGhlcjt2YXIgYmxvY2tTaXplPWNpcGhlci5ibG9ja1NpemU7dmFyIGl2PXRoaXMuX2l2O3ZhciBjb3VudGVyPXRoaXMuX2NvdW50ZXI7aWYoaXYpe2NvdW50ZXI9dGhpcy5fY291bnRlcj1pdi5zbGljZSgwKTt0aGlzLl9pdj11bmRlZmluZWR9aW5jQ291bnRlcihjb3VudGVyKTt2YXIga2V5c3RyZWFtPWNvdW50ZXIuc2xpY2UoMCk7Y2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sMCk7Zm9yKHZhciBpPTA7aTxibG9ja1NpemU7aSsrKXt3b3Jkc1tvZmZzZXQraV1ePWtleXN0cmVhbVtpXX19fSk7Q1RSR2xhZG1hbi5EZWNyeXB0b3I9RW5jcnlwdG9yO3JldHVybiBDVFJHbGFkbWFufSgpO3JldHVybiBDcnlwdG9KUy5tb2RlLkNUUkdsYWRtYW59KX0se1wiLi9jaXBoZXItY29yZVwiOjE5LFwiLi9jb3JlXCI6MjB9XSwzMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9jaXBoZXItY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL2NpcGhlci1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXtDcnlwdG9KUy5tb2RlLkNUUj1mdW5jdGlvbigpe3ZhciBDVFI9Q3J5cHRvSlMubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTt2YXIgRW5jcnlwdG9yPUNUUi5FbmNyeXB0b3I9Q1RSLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHdvcmRzLG9mZnNldCl7dmFyIGNpcGhlcj10aGlzLl9jaXBoZXI7dmFyIGJsb2NrU2l6ZT1jaXBoZXIuYmxvY2tTaXplO3ZhciBpdj10aGlzLl9pdjt2YXIgY291bnRlcj10aGlzLl9jb3VudGVyO2lmKGl2KXtjb3VudGVyPXRoaXMuX2NvdW50ZXI9aXYuc2xpY2UoMCk7dGhpcy5faXY9dW5kZWZpbmVkfXZhciBrZXlzdHJlYW09Y291bnRlci5zbGljZSgwKTtjaXBoZXIuZW5jcnlwdEJsb2NrKGtleXN0cmVhbSwwKTtjb3VudGVyW2Jsb2NrU2l6ZS0xXT1jb3VudGVyW2Jsb2NrU2l6ZS0xXSsxfDA7Zm9yKHZhciBpPTA7aTxibG9ja1NpemU7aSsrKXt3b3Jkc1tvZmZzZXQraV1ePWtleXN0cmVhbVtpXX19fSk7Q1RSLkRlY3J5cHRvcj1FbmNyeXB0b3I7cmV0dXJuIENUUn0oKTtyZXR1cm4gQ3J5cHRvSlMubW9kZS5DVFJ9KX0se1wiLi9jaXBoZXItY29yZVwiOjE5LFwiLi9jb3JlXCI6MjB9XSwzMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9jaXBoZXItY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL2NpcGhlci1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXtDcnlwdG9KUy5tb2RlLkVDQj1mdW5jdGlvbigpe3ZhciBFQ0I9Q3J5cHRvSlMubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtFQ0IuRW5jcnlwdG9yPUVDQi5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih3b3JkcyxvZmZzZXQpe3RoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsb2Zmc2V0KX19KTtFQ0IuRGVjcnlwdG9yPUVDQi5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih3b3JkcyxvZmZzZXQpe3RoaXMuX2NpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsb2Zmc2V0KX19KTtyZXR1cm4gRUNCfSgpO3JldHVybiBDcnlwdG9KUy5tb2RlLkVDQn0pfSx7XCIuL2NpcGhlci1jb3JlXCI6MTksXCIuL2NvcmVcIjoyMH1dLDM0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL2NpcGhlci1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vY2lwaGVyLWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpe0NyeXB0b0pTLm1vZGUuT0ZCPWZ1bmN0aW9uKCl7dmFyIE9GQj1DcnlwdG9KUy5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO3ZhciBFbmNyeXB0b3I9T0ZCLkVuY3J5cHRvcj1PRkIuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24od29yZHMsb2Zmc2V0KXt2YXIgY2lwaGVyPXRoaXMuX2NpcGhlcjt2YXIgYmxvY2tTaXplPWNpcGhlci5ibG9ja1NpemU7dmFyIGl2PXRoaXMuX2l2O3ZhciBrZXlzdHJlYW09dGhpcy5fa2V5c3RyZWFtO2lmKGl2KXtrZXlzdHJlYW09dGhpcy5fa2V5c3RyZWFtPWl2LnNsaWNlKDApO3RoaXMuX2l2PXVuZGVmaW5lZH1jaXBoZXIuZW5jcnlwdEJsb2NrKGtleXN0cmVhbSwwKTtmb3IodmFyIGk9MDtpPGJsb2NrU2l6ZTtpKyspe3dvcmRzW29mZnNldCtpXV49a2V5c3RyZWFtW2ldfX19KTtPRkIuRGVjcnlwdG9yPUVuY3J5cHRvcjtyZXR1cm4gT0ZCfSgpO3JldHVybiBDcnlwdG9KUy5tb2RlLk9GQn0pfSx7XCIuL2NpcGhlci1jb3JlXCI6MTksXCIuL2NvcmVcIjoyMH1dLDM1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL2NpcGhlci1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vY2lwaGVyLWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpe0NyeXB0b0pTLnBhZC5BbnNpWDkyMz17cGFkOmZ1bmN0aW9uKGRhdGEsYmxvY2tTaXplKXt2YXIgZGF0YVNpZ0J5dGVzPWRhdGEuc2lnQnl0ZXM7dmFyIGJsb2NrU2l6ZUJ5dGVzPWJsb2NrU2l6ZSo0O3ZhciBuUGFkZGluZ0J5dGVzPWJsb2NrU2l6ZUJ5dGVzLWRhdGFTaWdCeXRlcyVibG9ja1NpemVCeXRlczt2YXIgbGFzdEJ5dGVQb3M9ZGF0YVNpZ0J5dGVzK25QYWRkaW5nQnl0ZXMtMTtkYXRhLmNsYW1wKCk7ZGF0YS53b3Jkc1tsYXN0Qnl0ZVBvcz4+PjJdfD1uUGFkZGluZ0J5dGVzPDwyNC1sYXN0Qnl0ZVBvcyU0Kjg7ZGF0YS5zaWdCeXRlcys9blBhZGRpbmdCeXRlc30sdW5wYWQ6ZnVuY3Rpb24oZGF0YSl7dmFyIG5QYWRkaW5nQnl0ZXM9ZGF0YS53b3Jkc1tkYXRhLnNpZ0J5dGVzLTE+Pj4yXSYyNTU7ZGF0YS5zaWdCeXRlcy09blBhZGRpbmdCeXRlc319O3JldHVybiBDcnlwdG9KUy5wYWQuQW5zaXg5MjN9KX0se1wiLi9jaXBoZXItY29yZVwiOjE5LFwiLi9jb3JlXCI6MjB9XSwzNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9jaXBoZXItY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL2NpcGhlci1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXtDcnlwdG9KUy5wYWQuSXNvMTAxMjY9e3BhZDpmdW5jdGlvbihkYXRhLGJsb2NrU2l6ZSl7dmFyIGJsb2NrU2l6ZUJ5dGVzPWJsb2NrU2l6ZSo0O3ZhciBuUGFkZGluZ0J5dGVzPWJsb2NrU2l6ZUJ5dGVzLWRhdGEuc2lnQnl0ZXMlYmxvY2tTaXplQnl0ZXM7ZGF0YS5jb25jYXQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oblBhZGRpbmdCeXRlcy0xKSkuY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFtuUGFkZGluZ0J5dGVzPDwyNF0sMSkpfSx1bnBhZDpmdW5jdGlvbihkYXRhKXt2YXIgblBhZGRpbmdCeXRlcz1kYXRhLndvcmRzW2RhdGEuc2lnQnl0ZXMtMT4+PjJdJjI1NTtkYXRhLnNpZ0J5dGVzLT1uUGFkZGluZ0J5dGVzfX07cmV0dXJuIENyeXB0b0pTLnBhZC5Jc28xMDEyNn0pfSx7XCIuL2NpcGhlci1jb3JlXCI6MTksXCIuL2NvcmVcIjoyMH1dLDM3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL2NpcGhlci1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vY2lwaGVyLWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpe0NyeXB0b0pTLnBhZC5Jc285Nzk3MT17cGFkOmZ1bmN0aW9uKGRhdGEsYmxvY2tTaXplKXtkYXRhLmNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMjE0NzQ4MzY0OF0sMSkpO0NyeXB0b0pTLnBhZC5aZXJvUGFkZGluZy5wYWQoZGF0YSxibG9ja1NpemUpfSx1bnBhZDpmdW5jdGlvbihkYXRhKXtDcnlwdG9KUy5wYWQuWmVyb1BhZGRpbmcudW5wYWQoZGF0YSk7ZGF0YS5zaWdCeXRlcy0tfX07cmV0dXJuIENyeXB0b0pTLnBhZC5Jc285Nzk3MX0pfSx7XCIuL2NpcGhlci1jb3JlXCI6MTksXCIuL2NvcmVcIjoyMH1dLDM4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL2NpcGhlci1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vY2lwaGVyLWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpe0NyeXB0b0pTLnBhZC5Ob1BhZGRpbmc9e3BhZDpmdW5jdGlvbigpe30sdW5wYWQ6ZnVuY3Rpb24oKXt9fTtyZXR1cm4gQ3J5cHRvSlMucGFkLk5vUGFkZGluZ30pfSx7XCIuL2NpcGhlci1jb3JlXCI6MTksXCIuL2NvcmVcIjoyMH1dLDM5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL2NpcGhlci1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vY2lwaGVyLWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpe0NyeXB0b0pTLnBhZC5aZXJvUGFkZGluZz17cGFkOmZ1bmN0aW9uKGRhdGEsYmxvY2tTaXplKXt2YXIgYmxvY2tTaXplQnl0ZXM9YmxvY2tTaXplKjQ7ZGF0YS5jbGFtcCgpO2RhdGEuc2lnQnl0ZXMrPWJsb2NrU2l6ZUJ5dGVzLShkYXRhLnNpZ0J5dGVzJWJsb2NrU2l6ZUJ5dGVzfHxibG9ja1NpemVCeXRlcyl9LHVucGFkOmZ1bmN0aW9uKGRhdGEpe3ZhciBkYXRhV29yZHM9ZGF0YS53b3Jkczt2YXIgaT1kYXRhLnNpZ0J5dGVzLTE7d2hpbGUoIShkYXRhV29yZHNbaT4+PjJdPj4+MjQtaSU0KjgmMjU1KSl7aS0tfWRhdGEuc2lnQnl0ZXM9aSsxfX07cmV0dXJuIENyeXB0b0pTLnBhZC5aZXJvUGFkZGluZ30pfSx7XCIuL2NpcGhlci1jb3JlXCI6MTksXCIuL2NvcmVcIjoyMH1dLDQwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL3NoYTFcIiksX2RlcmVxXyhcIi4vaG1hY1wiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL3NoYTFcIixcIi4vaG1hY1wiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBCYXNlPUNfbGliLkJhc2U7dmFyIFdvcmRBcnJheT1DX2xpYi5Xb3JkQXJyYXk7dmFyIENfYWxnbz1DLmFsZ287dmFyIFNIQTE9Q19hbGdvLlNIQTE7dmFyIEhNQUM9Q19hbGdvLkhNQUM7dmFyIFBCS0RGMj1DX2FsZ28uUEJLREYyPUJhc2UuZXh0ZW5kKHtjZmc6QmFzZS5leHRlbmQoe2tleVNpemU6MTI4LzMyLGhhc2hlcjpTSEExLGl0ZXJhdGlvbnM6MX0pLGluaXQ6ZnVuY3Rpb24oY2ZnKXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQoY2ZnKX0sY29tcHV0ZTpmdW5jdGlvbihwYXNzd29yZCxzYWx0KXt2YXIgY2ZnPXRoaXMuY2ZnO3ZhciBobWFjPUhNQUMuY3JlYXRlKGNmZy5oYXNoZXIscGFzc3dvcmQpO3ZhciBkZXJpdmVkS2V5PVdvcmRBcnJheS5jcmVhdGUoKTt2YXIgYmxvY2tJbmRleD1Xb3JkQXJyYXkuY3JlYXRlKFsxXSk7dmFyIGRlcml2ZWRLZXlXb3Jkcz1kZXJpdmVkS2V5LndvcmRzO3ZhciBibG9ja0luZGV4V29yZHM9YmxvY2tJbmRleC53b3Jkczt2YXIga2V5U2l6ZT1jZmcua2V5U2l6ZTt2YXIgaXRlcmF0aW9ucz1jZmcuaXRlcmF0aW9uczt3aGlsZShkZXJpdmVkS2V5V29yZHMubGVuZ3RoPGtleVNpemUpe3ZhciBibG9jaz1obWFjLnVwZGF0ZShzYWx0KS5maW5hbGl6ZShibG9ja0luZGV4KTtobWFjLnJlc2V0KCk7dmFyIGJsb2NrV29yZHM9YmxvY2sud29yZHM7dmFyIGJsb2NrV29yZHNMZW5ndGg9YmxvY2tXb3Jkcy5sZW5ndGg7dmFyIGludGVybWVkaWF0ZT1ibG9jaztmb3IodmFyIGk9MTtpPGl0ZXJhdGlvbnM7aSsrKXtpbnRlcm1lZGlhdGU9aG1hYy5maW5hbGl6ZShpbnRlcm1lZGlhdGUpO2htYWMucmVzZXQoKTt2YXIgaW50ZXJtZWRpYXRlV29yZHM9aW50ZXJtZWRpYXRlLndvcmRzO2Zvcih2YXIgaj0wO2o8YmxvY2tXb3Jkc0xlbmd0aDtqKyspe2Jsb2NrV29yZHNbal1ePWludGVybWVkaWF0ZVdvcmRzW2pdfX1kZXJpdmVkS2V5LmNvbmNhdChibG9jayk7YmxvY2tJbmRleFdvcmRzWzBdKyt9ZGVyaXZlZEtleS5zaWdCeXRlcz1rZXlTaXplKjQ7cmV0dXJuIGRlcml2ZWRLZXl9fSk7Qy5QQktERjI9ZnVuY3Rpb24ocGFzc3dvcmQsc2FsdCxjZmcpe3JldHVybiBQQktERjIuY3JlYXRlKGNmZykuY29tcHV0ZShwYXNzd29yZCxzYWx0KX19KSgpO3JldHVybiBDcnlwdG9KUy5QQktERjJ9KX0se1wiLi9jb3JlXCI6MjAsXCIuL2htYWNcIjoyNixcIi4vc2hhMVwiOjQ1fV0sNDE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vZW5jLWJhc2U2NFwiKSxfZGVyZXFfKFwiLi9tZDVcIiksX2RlcmVxXyhcIi4vZXZwa2RmXCIpLF9kZXJlcV8oXCIuL2NpcGhlci1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vZW5jLWJhc2U2NFwiLFwiLi9tZDVcIixcIi4vZXZwa2RmXCIsXCIuL2NpcGhlci1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIFN0cmVhbUNpcGhlcj1DX2xpYi5TdHJlYW1DaXBoZXI7dmFyIENfYWxnbz1DLmFsZ287dmFyIFM9W107dmFyIENfPVtdO3ZhciBHPVtdO3ZhciBSYWJiaXRMZWdhY3k9Q19hbGdvLlJhYmJpdExlZ2FjeT1TdHJlYW1DaXBoZXIuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3ZhciBLPXRoaXMuX2tleS53b3Jkczt2YXIgaXY9dGhpcy5jZmcuaXY7dmFyIFg9dGhpcy5fWD1bS1swXSxLWzNdPDwxNnxLWzJdPj4+MTYsS1sxXSxLWzBdPDwxNnxLWzNdPj4+MTYsS1syXSxLWzFdPDwxNnxLWzBdPj4+MTYsS1szXSxLWzJdPDwxNnxLWzFdPj4+MTZdO3ZhciBDPXRoaXMuX0M9W0tbMl08PDE2fEtbMl0+Pj4xNixLWzBdJjQyOTQ5MDE3NjB8S1sxXSY2NTUzNSxLWzNdPDwxNnxLWzNdPj4+MTYsS1sxXSY0Mjk0OTAxNzYwfEtbMl0mNjU1MzUsS1swXTw8MTZ8S1swXT4+PjE2LEtbMl0mNDI5NDkwMTc2MHxLWzNdJjY1NTM1LEtbMV08PDE2fEtbMV0+Pj4xNixLWzNdJjQyOTQ5MDE3NjB8S1swXSY2NTUzNV07dGhpcy5fYj0wO2Zvcih2YXIgaT0wO2k8NDtpKyspe25leHRTdGF0ZS5jYWxsKHRoaXMpfWZvcih2YXIgaT0wO2k8ODtpKyspe0NbaV1ePVhbaSs0JjddfWlmKGl2KXt2YXIgSVY9aXYud29yZHM7dmFyIElWXzA9SVZbMF07dmFyIElWXzE9SVZbMV07dmFyIGkwPShJVl8wPDw4fElWXzA+Pj4yNCkmMTY3MTE5MzV8KElWXzA8PDI0fElWXzA+Pj44KSY0Mjc4MjU1MzYwO3ZhciBpMj0oSVZfMTw8OHxJVl8xPj4+MjQpJjE2NzExOTM1fChJVl8xPDwyNHxJVl8xPj4+OCkmNDI3ODI1NTM2MDt2YXIgaTE9aTA+Pj4xNnxpMiY0Mjk0OTAxNzYwO3ZhciBpMz1pMjw8MTZ8aTAmNjU1MzU7Q1swXV49aTA7Q1sxXV49aTE7Q1syXV49aTI7Q1szXV49aTM7Q1s0XV49aTA7Q1s1XV49aTE7Q1s2XV49aTI7Q1s3XV49aTM7Zm9yKHZhciBpPTA7aTw0O2krKyl7bmV4dFN0YXRlLmNhbGwodGhpcyl9fX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKE0sb2Zmc2V0KXt2YXIgWD10aGlzLl9YO25leHRTdGF0ZS5jYWxsKHRoaXMpO1NbMF09WFswXV5YWzVdPj4+MTZeWFszXTw8MTY7U1sxXT1YWzJdXlhbN10+Pj4xNl5YWzVdPDwxNjtTWzJdPVhbNF1eWFsxXT4+PjE2XlhbN108PDE2O1NbM109WFs2XV5YWzNdPj4+MTZeWFsxXTw8MTY7Zm9yKHZhciBpPTA7aTw0O2krKyl7U1tpXT0oU1tpXTw8OHxTW2ldPj4+MjQpJjE2NzExOTM1fChTW2ldPDwyNHxTW2ldPj4+OCkmNDI3ODI1NTM2MDtNW29mZnNldCtpXV49U1tpXX19LGJsb2NrU2l6ZToxMjgvMzIsaXZTaXplOjY0LzMyfSk7XG5mdW5jdGlvbiBuZXh0U3RhdGUoKXt2YXIgWD10aGlzLl9YO3ZhciBDPXRoaXMuX0M7Zm9yKHZhciBpPTA7aTw4O2krKyl7Q19baV09Q1tpXX1DWzBdPUNbMF0rMTI5NTMwNzU5Nyt0aGlzLl9ifDA7Q1sxXT1DWzFdKzM1NDUwNTIzNzErKENbMF0+Pj4wPENfWzBdPj4+MD8xOjApfDA7Q1syXT1DWzJdKzg4NjI2MzA5MisoQ1sxXT4+PjA8Q19bMV0+Pj4wPzE6MCl8MDtDWzNdPUNbM10rMTI5NTMwNzU5NysoQ1syXT4+PjA8Q19bMl0+Pj4wPzE6MCl8MDtDWzRdPUNbNF0rMzU0NTA1MjM3MSsoQ1szXT4+PjA8Q19bM10+Pj4wPzE6MCl8MDtDWzVdPUNbNV0rODg2MjYzMDkyKyhDWzRdPj4+MDxDX1s0XT4+PjA/MTowKXwwO0NbNl09Q1s2XSsxMjk1MzA3NTk3KyhDWzVdPj4+MDxDX1s1XT4+PjA/MTowKXwwO0NbN109Q1s3XSszNTQ1MDUyMzcxKyhDWzZdPj4+MDxDX1s2XT4+PjA/MTowKXwwO3RoaXMuX2I9Q1s3XT4+PjA8Q19bN10+Pj4wPzE6MDtmb3IodmFyIGk9MDtpPDg7aSsrKXt2YXIgZ3g9WFtpXStDW2ldO3ZhciBnYT1neCY2NTUzNTt2YXIgZ2I9Z3g+Pj4xNjt2YXIgZ2g9KChnYSpnYT4+PjE3KStnYSpnYj4+PjE1KStnYipnYjt2YXIgZ2w9KChneCY0Mjk0OTAxNzYwKSpneHwwKSsoKGd4JjY1NTM1KSpneHwwKTtHW2ldPWdoXmdsfVhbMF09R1swXSsoR1s3XTw8MTZ8R1s3XT4+PjE2KSsoR1s2XTw8MTZ8R1s2XT4+PjE2KXwwO1hbMV09R1sxXSsoR1swXTw8OHxHWzBdPj4+MjQpK0dbN118MDtYWzJdPUdbMl0rKEdbMV08PDE2fEdbMV0+Pj4xNikrKEdbMF08PDE2fEdbMF0+Pj4xNil8MDtYWzNdPUdbM10rKEdbMl08PDh8R1syXT4+PjI0KStHWzFdfDA7WFs0XT1HWzRdKyhHWzNdPDwxNnxHWzNdPj4+MTYpKyhHWzJdPDwxNnxHWzJdPj4+MTYpfDA7WFs1XT1HWzVdKyhHWzRdPDw4fEdbNF0+Pj4yNCkrR1szXXwwO1hbNl09R1s2XSsoR1s1XTw8MTZ8R1s1XT4+PjE2KSsoR1s0XTw8MTZ8R1s0XT4+PjE2KXwwO1hbN109R1s3XSsoR1s2XTw8OHxHWzZdPj4+MjQpK0dbNV18MH1DLlJhYmJpdExlZ2FjeT1TdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSYWJiaXRMZWdhY3kpfSkoKTtyZXR1cm4gQ3J5cHRvSlMuUmFiYml0TGVnYWN5fSl9LHtcIi4vY2lwaGVyLWNvcmVcIjoxOSxcIi4vY29yZVwiOjIwLFwiLi9lbmMtYmFzZTY0XCI6MjEsXCIuL2V2cGtkZlwiOjIzLFwiLi9tZDVcIjoyOX1dLDQyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL2VuYy1iYXNlNjRcIiksX2RlcmVxXyhcIi4vbWQ1XCIpLF9kZXJlcV8oXCIuL2V2cGtkZlwiKSxfZGVyZXFfKFwiLi9jaXBoZXItY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL2VuYy1iYXNlNjRcIixcIi4vbWQ1XCIsXCIuL2V2cGtkZlwiLFwiLi9jaXBoZXItY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBTdHJlYW1DaXBoZXI9Q19saWIuU3RyZWFtQ2lwaGVyO3ZhciBDX2FsZ289Qy5hbGdvO3ZhciBTPVtdO3ZhciBDXz1bXTt2YXIgRz1bXTt2YXIgUmFiYml0PUNfYWxnby5SYWJiaXQ9U3RyZWFtQ2lwaGVyLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt2YXIgSz10aGlzLl9rZXkud29yZHM7dmFyIGl2PXRoaXMuY2ZnLml2O2Zvcih2YXIgaT0wO2k8NDtpKyspe0tbaV09KEtbaV08PDh8S1tpXT4+PjI0KSYxNjcxMTkzNXwoS1tpXTw8MjR8S1tpXT4+PjgpJjQyNzgyNTUzNjB9dmFyIFg9dGhpcy5fWD1bS1swXSxLWzNdPDwxNnxLWzJdPj4+MTYsS1sxXSxLWzBdPDwxNnxLWzNdPj4+MTYsS1syXSxLWzFdPDwxNnxLWzBdPj4+MTYsS1szXSxLWzJdPDwxNnxLWzFdPj4+MTZdO3ZhciBDPXRoaXMuX0M9W0tbMl08PDE2fEtbMl0+Pj4xNixLWzBdJjQyOTQ5MDE3NjB8S1sxXSY2NTUzNSxLWzNdPDwxNnxLWzNdPj4+MTYsS1sxXSY0Mjk0OTAxNzYwfEtbMl0mNjU1MzUsS1swXTw8MTZ8S1swXT4+PjE2LEtbMl0mNDI5NDkwMTc2MHxLWzNdJjY1NTM1LEtbMV08PDE2fEtbMV0+Pj4xNixLWzNdJjQyOTQ5MDE3NjB8S1swXSY2NTUzNV07dGhpcy5fYj0wO2Zvcih2YXIgaT0wO2k8NDtpKyspe25leHRTdGF0ZS5jYWxsKHRoaXMpfWZvcih2YXIgaT0wO2k8ODtpKyspe0NbaV1ePVhbaSs0JjddfWlmKGl2KXt2YXIgSVY9aXYud29yZHM7dmFyIElWXzA9SVZbMF07dmFyIElWXzE9SVZbMV07dmFyIGkwPShJVl8wPDw4fElWXzA+Pj4yNCkmMTY3MTE5MzV8KElWXzA8PDI0fElWXzA+Pj44KSY0Mjc4MjU1MzYwO3ZhciBpMj0oSVZfMTw8OHxJVl8xPj4+MjQpJjE2NzExOTM1fChJVl8xPDwyNHxJVl8xPj4+OCkmNDI3ODI1NTM2MDt2YXIgaTE9aTA+Pj4xNnxpMiY0Mjk0OTAxNzYwO3ZhciBpMz1pMjw8MTZ8aTAmNjU1MzU7Q1swXV49aTA7Q1sxXV49aTE7Q1syXV49aTI7Q1szXV49aTM7Q1s0XV49aTA7Q1s1XV49aTE7Q1s2XV49aTI7Q1s3XV49aTM7Zm9yKHZhciBpPTA7aTw0O2krKyl7bmV4dFN0YXRlLmNhbGwodGhpcyl9fX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKE0sb2Zmc2V0KXt2YXIgWD10aGlzLl9YO25leHRTdGF0ZS5jYWxsKHRoaXMpO1NbMF09WFswXV5YWzVdPj4+MTZeWFszXTw8MTY7U1sxXT1YWzJdXlhbN10+Pj4xNl5YWzVdPDwxNjtTWzJdPVhbNF1eWFsxXT4+PjE2XlhbN108PDE2O1NbM109WFs2XV5YWzNdPj4+MTZeWFsxXTw8MTY7Zm9yKHZhciBpPTA7aTw0O2krKyl7U1tpXT0oU1tpXTw8OHxTW2ldPj4+MjQpJjE2NzExOTM1fChTW2ldPDwyNHxTW2ldPj4+OCkmNDI3ODI1NTM2MDtNW29mZnNldCtpXV49U1tpXX19LGJsb2NrU2l6ZToxMjgvMzIsaXZTaXplOjY0LzMyfSk7ZnVuY3Rpb24gbmV4dFN0YXRlKCl7dmFyIFg9dGhpcy5fWDt2YXIgQz10aGlzLl9DO2Zvcih2YXIgaT0wO2k8ODtpKyspe0NfW2ldPUNbaV19Q1swXT1DWzBdKzEyOTUzMDc1OTcrdGhpcy5fYnwwO0NbMV09Q1sxXSszNTQ1MDUyMzcxKyhDWzBdPj4+MDxDX1swXT4+PjA/MTowKXwwO0NbMl09Q1syXSs4ODYyNjMwOTIrKENbMV0+Pj4wPENfWzFdPj4+MD8xOjApfDA7Q1szXT1DWzNdKzEyOTUzMDc1OTcrKENbMl0+Pj4wPENfWzJdPj4+MD8xOjApfDA7Q1s0XT1DWzRdKzM1NDUwNTIzNzErKENbM10+Pj4wPENfWzNdPj4+MD8xOjApfDA7Q1s1XT1DWzVdKzg4NjI2MzA5MisoQ1s0XT4+PjA8Q19bNF0+Pj4wPzE6MCl8MDtDWzZdPUNbNl0rMTI5NTMwNzU5NysoQ1s1XT4+PjA8Q19bNV0+Pj4wPzE6MCl8MDtDWzddPUNbN10rMzU0NTA1MjM3MSsoQ1s2XT4+PjA8Q19bNl0+Pj4wPzE6MCl8MDt0aGlzLl9iPUNbN10+Pj4wPENfWzddPj4+MD8xOjA7Zm9yKHZhciBpPTA7aTw4O2krKyl7dmFyIGd4PVhbaV0rQ1tpXTt2YXIgZ2E9Z3gmNjU1MzU7dmFyIGdiPWd4Pj4+MTY7dmFyIGdoPSgoZ2EqZ2E+Pj4xNykrZ2EqZ2I+Pj4xNSkrZ2IqZ2I7dmFyIGdsPSgoZ3gmNDI5NDkwMTc2MCkqZ3h8MCkrKChneCY2NTUzNSkqZ3h8MCk7R1tpXT1naF5nbH1YWzBdPUdbMF0rKEdbN108PDE2fEdbN10+Pj4xNikrKEdbNl08PDE2fEdbNl0+Pj4xNil8MDtYWzFdPUdbMV0rKEdbMF08PDh8R1swXT4+PjI0KStHWzddfDA7WFsyXT1HWzJdKyhHWzFdPDwxNnxHWzFdPj4+MTYpKyhHWzBdPDwxNnxHWzBdPj4+MTYpfDA7WFszXT1HWzNdKyhHWzJdPDw4fEdbMl0+Pj4yNCkrR1sxXXwwO1hbNF09R1s0XSsoR1szXTw8MTZ8R1szXT4+PjE2KSsoR1syXTw8MTZ8R1syXT4+PjE2KXwwO1hbNV09R1s1XSsoR1s0XTw8OHxHWzRdPj4+MjQpK0dbM118MDtYWzZdPUdbNl0rKEdbNV08PDE2fEdbNV0+Pj4xNikrKEdbNF08PDE2fEdbNF0+Pj4xNil8MDtYWzddPUdbN10rKEdbNl08PDh8R1s2XT4+PjI0KStHWzVdfDB9Qy5SYWJiaXQ9U3RyZWFtQ2lwaGVyLl9jcmVhdGVIZWxwZXIoUmFiYml0KX0pKCk7cmV0dXJuIENyeXB0b0pTLlJhYmJpdH0pfSx7XCIuL2NpcGhlci1jb3JlXCI6MTksXCIuL2NvcmVcIjoyMCxcIi4vZW5jLWJhc2U2NFwiOjIxLFwiLi9ldnBrZGZcIjoyMyxcIi4vbWQ1XCI6Mjl9XSw0MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9lbmMtYmFzZTY0XCIpLF9kZXJlcV8oXCIuL21kNVwiKSxfZGVyZXFfKFwiLi9ldnBrZGZcIiksX2RlcmVxXyhcIi4vY2lwaGVyLWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9lbmMtYmFzZTY0XCIsXCIuL21kNVwiLFwiLi9ldnBrZGZcIixcIi4vY2lwaGVyLWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbigpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgU3RyZWFtQ2lwaGVyPUNfbGliLlN0cmVhbUNpcGhlcjt2YXIgQ19hbGdvPUMuYWxnbzt2YXIgUkM0PUNfYWxnby5SQzQ9U3RyZWFtQ2lwaGVyLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt2YXIga2V5PXRoaXMuX2tleTt2YXIga2V5V29yZHM9a2V5LndvcmRzO3ZhciBrZXlTaWdCeXRlcz1rZXkuc2lnQnl0ZXM7dmFyIFM9dGhpcy5fUz1bXTtmb3IodmFyIGk9MDtpPDI1NjtpKyspe1NbaV09aX1mb3IodmFyIGk9MCxqPTA7aTwyNTY7aSsrKXt2YXIga2V5Qnl0ZUluZGV4PWkla2V5U2lnQnl0ZXM7dmFyIGtleUJ5dGU9a2V5V29yZHNba2V5Qnl0ZUluZGV4Pj4+Ml0+Pj4yNC1rZXlCeXRlSW5kZXglNCo4JjI1NTtqPShqK1NbaV0ra2V5Qnl0ZSklMjU2O3ZhciB0PVNbaV07U1tpXT1TW2pdO1Nbal09dH10aGlzLl9pPXRoaXMuX2o9MH0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKE0sb2Zmc2V0KXtNW29mZnNldF1ePWdlbmVyYXRlS2V5c3RyZWFtV29yZC5jYWxsKHRoaXMpfSxrZXlTaXplOjI1Ni8zMixpdlNpemU6MH0pO2Z1bmN0aW9uIGdlbmVyYXRlS2V5c3RyZWFtV29yZCgpe3ZhciBTPXRoaXMuX1M7dmFyIGk9dGhpcy5faTt2YXIgaj10aGlzLl9qO3ZhciBrZXlzdHJlYW1Xb3JkPTA7Zm9yKHZhciBuPTA7bjw0O24rKyl7aT0oaSsxKSUyNTY7aj0oaitTW2ldKSUyNTY7dmFyIHQ9U1tpXTtTW2ldPVNbal07U1tqXT10O2tleXN0cmVhbVdvcmR8PVNbKFNbaV0rU1tqXSklMjU2XTw8MjQtbio4fXRoaXMuX2k9aTt0aGlzLl9qPWo7cmV0dXJuIGtleXN0cmVhbVdvcmR9Qy5SQzQ9U3RyZWFtQ2lwaGVyLl9jcmVhdGVIZWxwZXIoUkM0KTt2YXIgUkM0RHJvcD1DX2FsZ28uUkM0RHJvcD1SQzQuZXh0ZW5kKHtjZmc6UkM0LmNmZy5leHRlbmQoe2Ryb3A6MTkyfSksX2RvUmVzZXQ6ZnVuY3Rpb24oKXtSQzQuX2RvUmVzZXQuY2FsbCh0aGlzKTtmb3IodmFyIGk9dGhpcy5jZmcuZHJvcDtpPjA7aS0tKXtnZW5lcmF0ZUtleXN0cmVhbVdvcmQuY2FsbCh0aGlzKX19fSk7Qy5SQzREcm9wPVN0cmVhbUNpcGhlci5fY3JlYXRlSGVscGVyKFJDNERyb3ApfSkoKTtyZXR1cm4gQ3J5cHRvSlMuUkM0fSl9LHtcIi4vY2lwaGVyLWNvcmVcIjoxOSxcIi4vY29yZVwiOjIwLFwiLi9lbmMtYmFzZTY0XCI6MjEsXCIuL2V2cGtkZlwiOjIzLFwiLi9tZDVcIjoyOX1dLDQ0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5KXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbihNYXRoKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIFdvcmRBcnJheT1DX2xpYi5Xb3JkQXJyYXk7dmFyIEhhc2hlcj1DX2xpYi5IYXNoZXI7dmFyIENfYWxnbz1DLmFsZ287dmFyIF96bD1Xb3JkQXJyYXkuY3JlYXRlKFswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDcsNCwxMywxLDEwLDYsMTUsMywxMiwwLDksNSwyLDE0LDExLDgsMywxMCwxNCw0LDksMTUsOCwxLDIsNywwLDYsMTMsMTEsNSwxMiwxLDksMTEsMTAsMCw4LDEyLDQsMTMsMyw3LDE1LDE0LDUsNiwyLDQsMCw1LDksNywxMiwyLDEwLDE0LDEsMyw4LDExLDYsMTUsMTNdKTt2YXIgX3pyPVdvcmRBcnJheS5jcmVhdGUoWzUsMTQsNywwLDksMiwxMSw0LDEzLDYsMTUsOCwxLDEwLDMsMTIsNiwxMSwzLDcsMCwxMyw1LDEwLDE0LDE1LDgsMTIsNCw5LDEsMiwxNSw1LDEsMyw3LDE0LDYsOSwxMSw4LDEyLDIsMTAsMCw0LDEzLDgsNiw0LDEsMywxMSwxNSwwLDUsMTIsMiwxMyw5LDcsMTAsMTQsMTIsMTUsMTAsNCwxLDUsOCw3LDYsMiwxMywxNCwwLDMsOSwxMV0pO3ZhciBfc2w9V29yZEFycmF5LmNyZWF0ZShbMTEsMTQsMTUsMTIsNSw4LDcsOSwxMSwxMywxNCwxNSw2LDcsOSw4LDcsNiw4LDEzLDExLDksNywxNSw3LDEyLDE1LDksMTEsNywxMywxMiwxMSwxMyw2LDcsMTQsOSwxMywxNSwxNCw4LDEzLDYsNSwxMiw3LDUsMTEsMTIsMTQsMTUsMTQsMTUsOSw4LDksMTQsNSw2LDgsNiw1LDEyLDksMTUsNSwxMSw2LDgsMTMsMTIsNSwxMiwxMywxNCwxMSw4LDUsNl0pO3ZhciBfc3I9V29yZEFycmF5LmNyZWF0ZShbOCw5LDksMTEsMTMsMTUsMTUsNSw3LDcsOCwxMSwxNCwxNCwxMiw2LDksMTMsMTUsNywxMiw4LDksMTEsNyw3LDEyLDcsNiwxNSwxMywxMSw5LDcsMTUsMTEsOCw2LDYsMTQsMTIsMTMsNSwxNCwxMywxMyw3LDUsMTUsNSw4LDExLDE0LDE0LDYsMTQsNiw5LDEyLDksMTIsNSwxNSw4LDgsNSwxMiw5LDEyLDUsMTQsNiw4LDEzLDYsNSwxNSwxMywxMSwxMV0pO3ZhciBfaGw9V29yZEFycmF5LmNyZWF0ZShbMCwxNTE4NTAwMjQ5LDE4NTk3NzUzOTMsMjQwMDk1OTcwOCwyODQwODUzODM4XSk7dmFyIF9ocj1Xb3JkQXJyYXkuY3JlYXRlKFsxMzUyODI5OTI2LDE1NDg2MDM2ODQsMTgzNjA3MjY5MSwyMDUzOTk0MjE3LDBdKTt2YXIgUklQRU1EMTYwPUNfYWxnby5SSVBFTUQxNjA9SGFzaGVyLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPVdvcmRBcnJheS5jcmVhdGUoWzE3MzI1ODQxOTMsNDAyMzIzMzQxNywyNTYyMzgzMTAyLDI3MTczMzg3OCwzMjg1Mzc3NTIwXSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihNLG9mZnNldCl7Zm9yKHZhciBpPTA7aTwxNjtpKyspe3ZhciBvZmZzZXRfaT1vZmZzZXQraTt2YXIgTV9vZmZzZXRfaT1NW29mZnNldF9pXTtNW29mZnNldF9pXT0oTV9vZmZzZXRfaTw8OHxNX29mZnNldF9pPj4+MjQpJjE2NzExOTM1fChNX29mZnNldF9pPDwyNHxNX29mZnNldF9pPj4+OCkmNDI3ODI1NTM2MH12YXIgSD10aGlzLl9oYXNoLndvcmRzO3ZhciBobD1faGwud29yZHM7dmFyIGhyPV9oci53b3Jkczt2YXIgemw9X3psLndvcmRzO3ZhciB6cj1fenIud29yZHM7dmFyIHNsPV9zbC53b3Jkczt2YXIgc3I9X3NyLndvcmRzO3ZhciBhbCxibCxjbCxkbCxlbDt2YXIgYXIsYnIsY3IsZHIsZXI7YXI9YWw9SFswXTticj1ibD1IWzFdO2NyPWNsPUhbMl07ZHI9ZGw9SFszXTtlcj1lbD1IWzRdO3ZhciB0O2Zvcih2YXIgaT0wO2k8ODA7aSs9MSl7dD1hbCtNW29mZnNldCt6bFtpXV18MDtpZihpPDE2KXt0Kz1mMShibCxjbCxkbCkraGxbMF19ZWxzZSBpZihpPDMyKXt0Kz1mMihibCxjbCxkbCkraGxbMV19ZWxzZSBpZihpPDQ4KXt0Kz1mMyhibCxjbCxkbCkraGxbMl19ZWxzZSBpZihpPDY0KXt0Kz1mNChibCxjbCxkbCkraGxbM119ZWxzZXt0Kz1mNShibCxjbCxkbCkraGxbNF19dD10fDA7dD1yb3RsKHQsc2xbaV0pO3Q9dCtlbHwwO2FsPWVsO2VsPWRsO2RsPXJvdGwoY2wsMTApO2NsPWJsO2JsPXQ7dD1hcitNW29mZnNldCt6cltpXV18MDtpZihpPDE2KXt0Kz1mNShicixjcixkcikraHJbMF19ZWxzZSBpZihpPDMyKXt0Kz1mNChicixjcixkcikraHJbMV19ZWxzZSBpZihpPDQ4KXt0Kz1mMyhicixjcixkcikraHJbMl19ZWxzZSBpZihpPDY0KXt0Kz1mMihicixjcixkcikraHJbM119ZWxzZXt0Kz1mMShicixjcixkcikraHJbNF19dD10fDA7dD1yb3RsKHQsc3JbaV0pO3Q9dCtlcnwwO2FyPWVyO2VyPWRyO2RyPXJvdGwoY3IsMTApO2NyPWJyO2JyPXR9dD1IWzFdK2NsK2RyfDA7SFsxXT1IWzJdK2RsK2VyfDA7SFsyXT1IWzNdK2VsK2FyfDA7SFszXT1IWzRdK2FsK2JyfDA7SFs0XT1IWzBdK2JsK2NyfDA7SFswXT10fSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciBkYXRhPXRoaXMuX2RhdGE7dmFyIGRhdGFXb3Jkcz1kYXRhLndvcmRzO3ZhciBuQml0c1RvdGFsPXRoaXMuX25EYXRhQnl0ZXMqODt2YXIgbkJpdHNMZWZ0PWRhdGEuc2lnQnl0ZXMqODtkYXRhV29yZHNbbkJpdHNMZWZ0Pj4+NV18PTEyODw8MjQtbkJpdHNMZWZ0JTMyO2RhdGFXb3Jkc1sobkJpdHNMZWZ0KzY0Pj4+OTw8NCkrMTRdPShuQml0c1RvdGFsPDw4fG5CaXRzVG90YWw+Pj4yNCkmMTY3MTE5MzV8KG5CaXRzVG90YWw8PDI0fG5CaXRzVG90YWw+Pj44KSY0Mjc4MjU1MzYwO2RhdGEuc2lnQnl0ZXM9KGRhdGFXb3Jkcy5sZW5ndGgrMSkqNDt0aGlzLl9wcm9jZXNzKCk7dmFyIGhhc2g9dGhpcy5faGFzaDt2YXIgSD1oYXNoLndvcmRzO2Zvcih2YXIgaT0wO2k8NTtpKyspe3ZhciBIX2k9SFtpXTtIW2ldPShIX2k8PDh8SF9pPj4+MjQpJjE2NzExOTM1fChIX2k8PDI0fEhfaT4+PjgpJjQyNzgyNTUzNjB9cmV0dXJuIGhhc2h9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGNsb25lPUhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO2Nsb25lLl9oYXNoPXRoaXMuX2hhc2guY2xvbmUoKTtyZXR1cm4gY2xvbmV9fSk7ZnVuY3Rpb24gZjEoeCx5LHope3JldHVybiB4Xnleen1mdW5jdGlvbiBmMih4LHkseil7cmV0dXJuIHgmeXx+eCZ6fWZ1bmN0aW9uIGYzKHgseSx6KXtyZXR1cm4oeHx+eSleen1mdW5jdGlvbiBmNCh4LHkseil7cmV0dXJuIHgmenx5Jn56fWZ1bmN0aW9uIGY1KHgseSx6KXtyZXR1cm4geF4oeXx+eil9ZnVuY3Rpb24gcm90bCh4LG4pe3JldHVybiB4PDxufHg+Pj4zMi1ufUMuUklQRU1EMTYwPUhhc2hlci5fY3JlYXRlSGVscGVyKFJJUEVNRDE2MCk7Qy5IbWFjUklQRU1EMTYwPUhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihSSVBFTUQxNjApfSkoTWF0aCk7cmV0dXJuIENyeXB0b0pTLlJJUEVNRDE2MH0pfSx7XCIuL2NvcmVcIjoyMH1dLDQ1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5KXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbigpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgV29yZEFycmF5PUNfbGliLldvcmRBcnJheTt2YXIgSGFzaGVyPUNfbGliLkhhc2hlcjt2YXIgQ19hbGdvPUMuYWxnbzt2YXIgVz1bXTt2YXIgU0hBMT1DX2FsZ28uU0hBMT1IYXNoZXIuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IFdvcmRBcnJheS5pbml0KFsxNzMyNTg0MTkzLDQwMjMyMzM0MTcsMjU2MjM4MzEwMiwyNzE3MzM4NzgsMzI4NTM3NzUyMF0pfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24oTSxvZmZzZXQpe3ZhciBIPXRoaXMuX2hhc2gud29yZHM7dmFyIGE9SFswXTt2YXIgYj1IWzFdO3ZhciBjPUhbMl07dmFyIGQ9SFszXTt2YXIgZT1IWzRdO2Zvcih2YXIgaT0wO2k8ODA7aSsrKXtpZihpPDE2KXtXW2ldPU1bb2Zmc2V0K2ldfDB9ZWxzZXt2YXIgbj1XW2ktM11eV1tpLThdXldbaS0xNF1eV1tpLTE2XTtXW2ldPW48PDF8bj4+PjMxfXZhciB0PShhPDw1fGE+Pj4yNykrZStXW2ldO2lmKGk8MjApe3QrPShiJmN8fmImZCkrMTUxODUwMDI0OX1lbHNlIGlmKGk8NDApe3QrPShiXmNeZCkrMTg1OTc3NTM5M31lbHNlIGlmKGk8NjApe3QrPShiJmN8YiZkfGMmZCktMTg5NDAwNzU4OH1lbHNle3QrPShiXmNeZCktODk5NDk3NTE0fWU9ZDtkPWM7Yz1iPDwzMHxiPj4+MjtiPWE7YT10fUhbMF09SFswXSthfDA7SFsxXT1IWzFdK2J8MDtIWzJdPUhbMl0rY3wwO0hbM109SFszXStkfDA7SFs0XT1IWzRdK2V8MH0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgZGF0YT10aGlzLl9kYXRhO3ZhciBkYXRhV29yZHM9ZGF0YS53b3Jkczt2YXIgbkJpdHNUb3RhbD10aGlzLl9uRGF0YUJ5dGVzKjg7dmFyIG5CaXRzTGVmdD1kYXRhLnNpZ0J5dGVzKjg7ZGF0YVdvcmRzW25CaXRzTGVmdD4+PjVdfD0xMjg8PDI0LW5CaXRzTGVmdCUzMjtkYXRhV29yZHNbKG5CaXRzTGVmdCs2ND4+Pjk8PDQpKzE0XT1NYXRoLmZsb29yKG5CaXRzVG90YWwvNDI5NDk2NzI5Nik7ZGF0YVdvcmRzWyhuQml0c0xlZnQrNjQ+Pj45PDw0KSsxNV09bkJpdHNUb3RhbDtkYXRhLnNpZ0J5dGVzPWRhdGFXb3Jkcy5sZW5ndGgqNDt0aGlzLl9wcm9jZXNzKCk7cmV0dXJuIHRoaXMuX2hhc2h9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGNsb25lPUhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO2Nsb25lLl9oYXNoPXRoaXMuX2hhc2guY2xvbmUoKTtyZXR1cm4gY2xvbmV9fSk7Qy5TSEExPUhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTEpO0MuSG1hY1NIQTE9SGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTEpfSkoKTtyZXR1cm4gQ3J5cHRvSlMuU0hBMX0pfSx7XCIuL2NvcmVcIjoyMH1dLDQ2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL3NoYTI1NlwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL3NoYTI1NlwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBXb3JkQXJyYXk9Q19saWIuV29yZEFycmF5O3ZhciBDX2FsZ289Qy5hbGdvO3ZhciBTSEEyNTY9Q19hbGdvLlNIQTI1Njt2YXIgU0hBMjI0PUNfYWxnby5TSEEyMjQ9U0hBMjU2LmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyBXb3JkQXJyYXkuaW5pdChbMzIzODM3MTAzMiw5MTQxNTA2NjMsODEyNzAyOTk5LDQxNDQ5MTI2OTcsNDI5MDc3NTg1NywxNzUwNjAzMDI1LDE2OTQwNzY4MzksMzIwNDA3NTQyOF0pfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciBoYXNoPVNIQTI1Ni5fZG9GaW5hbGl6ZS5jYWxsKHRoaXMpO2hhc2guc2lnQnl0ZXMtPTQ7cmV0dXJuIGhhc2h9fSk7Qy5TSEEyMjQ9U0hBMjU2Ll9jcmVhdGVIZWxwZXIoU0hBMjI0KTtDLkhtYWNTSEEyMjQ9U0hBMjU2Ll9jcmVhdGVIbWFjSGVscGVyKFNIQTIyNCl9KSgpO3JldHVybiBDcnlwdG9KUy5TSEEyMjR9KX0se1wiLi9jb3JlXCI6MjAsXCIuL3NoYTI1NlwiOjQ3fV0sNDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3Rvcnkpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKE1hdGgpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgV29yZEFycmF5PUNfbGliLldvcmRBcnJheTt2YXIgSGFzaGVyPUNfbGliLkhhc2hlcjt2YXIgQ19hbGdvPUMuYWxnbzt2YXIgSD1bXTt2YXIgSz1bXTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBpc1ByaW1lKG4pe3ZhciBzcXJ0Tj1NYXRoLnNxcnQobik7Zm9yKHZhciBmYWN0b3I9MjtmYWN0b3I8PXNxcnROO2ZhY3RvcisrKXtpZighKG4lZmFjdG9yKSl7cmV0dXJuIGZhbHNlfX1yZXR1cm4gdHJ1ZX1mdW5jdGlvbiBnZXRGcmFjdGlvbmFsQml0cyhuKXtyZXR1cm4obi0obnwwKSkqNDI5NDk2NzI5NnwwfXZhciBuPTI7dmFyIG5QcmltZT0wO3doaWxlKG5QcmltZTw2NCl7aWYoaXNQcmltZShuKSl7aWYoblByaW1lPDgpe0hbblByaW1lXT1nZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLDEvMikpfUtbblByaW1lXT1nZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLDEvMykpO25QcmltZSsrfW4rK319KSgpO3ZhciBXPVtdO3ZhciBTSEEyNTY9Q19hbGdvLlNIQTI1Nj1IYXNoZXIuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IFdvcmRBcnJheS5pbml0KEguc2xpY2UoMCkpfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24oTSxvZmZzZXQpe3ZhciBIPXRoaXMuX2hhc2gud29yZHM7dmFyIGE9SFswXTt2YXIgYj1IWzFdO3ZhciBjPUhbMl07dmFyIGQ9SFszXTt2YXIgZT1IWzRdO3ZhciBmPUhbNV07dmFyIGc9SFs2XTt2YXIgaD1IWzddO2Zvcih2YXIgaT0wO2k8NjQ7aSsrKXtpZihpPDE2KXtXW2ldPU1bb2Zmc2V0K2ldfDB9ZWxzZXt2YXIgZ2FtbWEweD1XW2ktMTVdO3ZhciBnYW1tYTA9KGdhbW1hMHg8PDI1fGdhbW1hMHg+Pj43KV4oZ2FtbWEweDw8MTR8Z2FtbWEweD4+PjE4KV5nYW1tYTB4Pj4+Mzt2YXIgZ2FtbWExeD1XW2ktMl07dmFyIGdhbW1hMT0oZ2FtbWExeDw8MTV8Z2FtbWExeD4+PjE3KV4oZ2FtbWExeDw8MTN8Z2FtbWExeD4+PjE5KV5nYW1tYTF4Pj4+MTA7V1tpXT1nYW1tYTArV1tpLTddK2dhbW1hMStXW2ktMTZdfXZhciBjaD1lJmZefmUmZzt2YXIgbWFqPWEmYl5hJmNeYiZjO3ZhciBzaWdtYTA9KGE8PDMwfGE+Pj4yKV4oYTw8MTl8YT4+PjEzKV4oYTw8MTB8YT4+PjIyKTt2YXIgc2lnbWExPShlPDwyNnxlPj4+NileKGU8PDIxfGU+Pj4xMSleKGU8PDd8ZT4+PjI1KTt2YXIgdDE9aCtzaWdtYTErY2grS1tpXStXW2ldO3ZhciB0Mj1zaWdtYTArbWFqO2g9ZztnPWY7Zj1lO2U9ZCt0MXwwO2Q9YztjPWI7Yj1hO2E9dDErdDJ8MH1IWzBdPUhbMF0rYXwwO0hbMV09SFsxXStifDA7SFsyXT1IWzJdK2N8MDtIWzNdPUhbM10rZHwwO0hbNF09SFs0XStlfDA7SFs1XT1IWzVdK2Z8MDtIWzZdPUhbNl0rZ3wwO0hbN109SFs3XStofDB9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGRhdGE9dGhpcy5fZGF0YTt2YXIgZGF0YVdvcmRzPWRhdGEud29yZHM7dmFyIG5CaXRzVG90YWw9dGhpcy5fbkRhdGFCeXRlcyo4O3ZhciBuQml0c0xlZnQ9ZGF0YS5zaWdCeXRlcyo4O2RhdGFXb3Jkc1tuQml0c0xlZnQ+Pj41XXw9MTI4PDwyNC1uQml0c0xlZnQlMzI7ZGF0YVdvcmRzWyhuQml0c0xlZnQrNjQ+Pj45PDw0KSsxNF09TWF0aC5mbG9vcihuQml0c1RvdGFsLzQyOTQ5NjcyOTYpO2RhdGFXb3Jkc1sobkJpdHNMZWZ0KzY0Pj4+OTw8NCkrMTVdPW5CaXRzVG90YWw7ZGF0YS5zaWdCeXRlcz1kYXRhV29yZHMubGVuZ3RoKjQ7dGhpcy5fcHJvY2VzcygpO3JldHVybiB0aGlzLl9oYXNofSxjbG9uZTpmdW5jdGlvbigpe3ZhciBjbG9uZT1IYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtjbG9uZS5faGFzaD10aGlzLl9oYXNoLmNsb25lKCk7cmV0dXJuIGNsb25lfX0pO0MuU0hBMjU2PUhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTI1Nik7Qy5IbWFjU0hBMjU2PUhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEEyNTYpfSkoTWF0aCk7cmV0dXJuIENyeXB0b0pTLlNIQTI1Nn0pfSx7XCIuL2NvcmVcIjoyMH1dLDQ4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL3g2NC1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4veDY0LWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbihNYXRoKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIFdvcmRBcnJheT1DX2xpYi5Xb3JkQXJyYXk7dmFyIEhhc2hlcj1DX2xpYi5IYXNoZXI7dmFyIENfeDY0PUMueDY0O3ZhciBYNjRXb3JkPUNfeDY0LldvcmQ7dmFyIENfYWxnbz1DLmFsZ287dmFyIFJIT19PRkZTRVRTPVtdO3ZhciBQSV9JTkRFWEVTPVtdO3ZhciBST1VORF9DT05TVEFOVFM9W107KGZ1bmN0aW9uKCl7dmFyIHg9MSx5PTA7Zm9yKHZhciB0PTA7dDwyNDt0Kyspe1JIT19PRkZTRVRTW3grNSp5XT0odCsxKSoodCsyKS8yJTY0O3ZhciBuZXdYPXklNTt2YXIgbmV3WT0oMip4KzMqeSklNTt4PW5ld1g7eT1uZXdZfWZvcih2YXIgeD0wO3g8NTt4Kyspe2Zvcih2YXIgeT0wO3k8NTt5Kyspe1BJX0lOREVYRVNbeCs1KnldPXkrKDIqeCszKnkpJTUqNX19dmFyIExGU1I9MTtmb3IodmFyIGk9MDtpPDI0O2krKyl7dmFyIHJvdW5kQ29uc3RhbnRNc3c9MDt2YXIgcm91bmRDb25zdGFudExzdz0wO2Zvcih2YXIgaj0wO2o8NztqKyspe2lmKExGU1ImMSl7dmFyIGJpdFBvc2l0aW9uPSgxPDxqKS0xO2lmKGJpdFBvc2l0aW9uPDMyKXtyb3VuZENvbnN0YW50THN3Xj0xPDxiaXRQb3NpdGlvbn1lbHNle3JvdW5kQ29uc3RhbnRNc3dePTE8PGJpdFBvc2l0aW9uLTMyfX1pZihMRlNSJjEyOCl7TEZTUj1MRlNSPDwxXjExM31lbHNle0xGU1I8PD0xfX1ST1VORF9DT05TVEFOVFNbaV09WDY0V29yZC5jcmVhdGUocm91bmRDb25zdGFudE1zdyxyb3VuZENvbnN0YW50THN3KX19KSgpO3ZhciBUPVtdOyhmdW5jdGlvbigpe2Zvcih2YXIgaT0wO2k8MjU7aSsrKXtUW2ldPVg2NFdvcmQuY3JlYXRlKCl9fSkoKTt2YXIgU0hBMz1DX2FsZ28uU0hBMz1IYXNoZXIuZXh0ZW5kKHtjZmc6SGFzaGVyLmNmZy5leHRlbmQoe291dHB1dExlbmd0aDo1MTJ9KSxfZG9SZXNldDpmdW5jdGlvbigpe3ZhciBzdGF0ZT10aGlzLl9zdGF0ZT1bXTtmb3IodmFyIGk9MDtpPDI1O2krKyl7c3RhdGVbaV09bmV3IFg2NFdvcmQuaW5pdH10aGlzLmJsb2NrU2l6ZT0oMTYwMC0yKnRoaXMuY2ZnLm91dHB1dExlbmd0aCkvMzJ9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihNLG9mZnNldCl7dmFyIHN0YXRlPXRoaXMuX3N0YXRlO3ZhciBuQmxvY2tTaXplTGFuZXM9dGhpcy5ibG9ja1NpemUvMjtmb3IodmFyIGk9MDtpPG5CbG9ja1NpemVMYW5lcztpKyspe3ZhciBNMmk9TVtvZmZzZXQrMippXTt2YXIgTTJpMT1NW29mZnNldCsyKmkrMV07TTJpPShNMmk8PDh8TTJpPj4+MjQpJjE2NzExOTM1fChNMmk8PDI0fE0yaT4+PjgpJjQyNzgyNTUzNjA7TTJpMT0oTTJpMTw8OHxNMmkxPj4+MjQpJjE2NzExOTM1fChNMmkxPDwyNHxNMmkxPj4+OCkmNDI3ODI1NTM2MDt2YXIgbGFuZT1zdGF0ZVtpXTtsYW5lLmhpZ2hePU0yaTE7bGFuZS5sb3dePU0yaX1mb3IodmFyIHJvdW5kPTA7cm91bmQ8MjQ7cm91bmQrKyl7Zm9yKHZhciB4PTA7eDw1O3grKyl7dmFyIHRNc3c9MCx0THN3PTA7Zm9yKHZhciB5PTA7eTw1O3krKyl7dmFyIGxhbmU9c3RhdGVbeCs1KnldO3RNc3dePWxhbmUuaGlnaDt0THN3Xj1sYW5lLmxvd312YXIgVHg9VFt4XTtUeC5oaWdoPXRNc3c7VHgubG93PXRMc3d9Zm9yKHZhciB4PTA7eDw1O3grKyl7dmFyIFR4ND1UWyh4KzQpJTVdO3ZhciBUeDE9VFsoeCsxKSU1XTt2YXIgVHgxTXN3PVR4MS5oaWdoO3ZhciBUeDFMc3c9VHgxLmxvdzt2YXIgdE1zdz1UeDQuaGlnaF4oVHgxTXN3PDwxfFR4MUxzdz4+PjMxKTt2YXIgdExzdz1UeDQubG93XihUeDFMc3c8PDF8VHgxTXN3Pj4+MzEpO2Zvcih2YXIgeT0wO3k8NTt5Kyspe3ZhciBsYW5lPXN0YXRlW3grNSp5XTtsYW5lLmhpZ2hePXRNc3c7bGFuZS5sb3dePXRMc3d9fWZvcih2YXIgbGFuZUluZGV4PTE7bGFuZUluZGV4PDI1O2xhbmVJbmRleCsrKXt2YXIgbGFuZT1zdGF0ZVtsYW5lSW5kZXhdO3ZhciBsYW5lTXN3PWxhbmUuaGlnaDt2YXIgbGFuZUxzdz1sYW5lLmxvdzt2YXIgcmhvT2Zmc2V0PVJIT19PRkZTRVRTW2xhbmVJbmRleF07aWYocmhvT2Zmc2V0PDMyKXt2YXIgdE1zdz1sYW5lTXN3PDxyaG9PZmZzZXR8bGFuZUxzdz4+PjMyLXJob09mZnNldDt2YXIgdExzdz1sYW5lTHN3PDxyaG9PZmZzZXR8bGFuZU1zdz4+PjMyLXJob09mZnNldH1lbHNle3ZhciB0TXN3PWxhbmVMc3c8PHJob09mZnNldC0zMnxsYW5lTXN3Pj4+NjQtcmhvT2Zmc2V0O3ZhciB0THN3PWxhbmVNc3c8PHJob09mZnNldC0zMnxsYW5lTHN3Pj4+NjQtcmhvT2Zmc2V0fXZhciBUUGlMYW5lPVRbUElfSU5ERVhFU1tsYW5lSW5kZXhdXTtUUGlMYW5lLmhpZ2g9dE1zdztUUGlMYW5lLmxvdz10THN3fXZhciBUMD1UWzBdO3ZhciBzdGF0ZTA9c3RhdGVbMF07VDAuaGlnaD1zdGF0ZTAuaGlnaDtUMC5sb3c9c3RhdGUwLmxvdztmb3IodmFyIHg9MDt4PDU7eCsrKXtmb3IodmFyIHk9MDt5PDU7eSsrKXt2YXIgbGFuZUluZGV4PXgrNSp5O3ZhciBsYW5lPXN0YXRlW2xhbmVJbmRleF07dmFyIFRMYW5lPVRbbGFuZUluZGV4XTt2YXIgVHgxTGFuZT1UWyh4KzEpJTUrNSp5XTt2YXIgVHgyTGFuZT1UWyh4KzIpJTUrNSp5XTtsYW5lLmhpZ2g9VExhbmUuaGlnaF5+VHgxTGFuZS5oaWdoJlR4MkxhbmUuaGlnaDtsYW5lLmxvdz1UTGFuZS5sb3deflR4MUxhbmUubG93JlR4MkxhbmUubG93fX12YXIgbGFuZT1zdGF0ZVswXTt2YXIgcm91bmRDb25zdGFudD1ST1VORF9DT05TVEFOVFNbcm91bmRdO2xhbmUuaGlnaF49cm91bmRDb25zdGFudC5oaWdoO2xhbmUubG93Xj1yb3VuZENvbnN0YW50Lmxvd319LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGRhdGE9dGhpcy5fZGF0YTt2YXIgZGF0YVdvcmRzPWRhdGEud29yZHM7dmFyIG5CaXRzVG90YWw9dGhpcy5fbkRhdGFCeXRlcyo4O3ZhciBuQml0c0xlZnQ9ZGF0YS5zaWdCeXRlcyo4O3ZhciBibG9ja1NpemVCaXRzPXRoaXMuYmxvY2tTaXplKjMyO2RhdGFXb3Jkc1tuQml0c0xlZnQ+Pj41XXw9MTw8MjQtbkJpdHNMZWZ0JTMyO2RhdGFXb3Jkc1soTWF0aC5jZWlsKChuQml0c0xlZnQrMSkvYmxvY2tTaXplQml0cykqYmxvY2tTaXplQml0cz4+PjUpLTFdfD0xMjg7ZGF0YS5zaWdCeXRlcz1kYXRhV29yZHMubGVuZ3RoKjQ7dGhpcy5fcHJvY2VzcygpO3ZhciBzdGF0ZT10aGlzLl9zdGF0ZTt2YXIgb3V0cHV0TGVuZ3RoQnl0ZXM9dGhpcy5jZmcub3V0cHV0TGVuZ3RoLzg7dmFyIG91dHB1dExlbmd0aExhbmVzPW91dHB1dExlbmd0aEJ5dGVzLzg7dmFyIGhhc2hXb3Jkcz1bXTtmb3IodmFyIGk9MDtpPG91dHB1dExlbmd0aExhbmVzO2krKyl7dmFyIGxhbmU9c3RhdGVbaV07dmFyIGxhbmVNc3c9bGFuZS5oaWdoO3ZhciBsYW5lTHN3PWxhbmUubG93O2xhbmVNc3c9KGxhbmVNc3c8PDh8bGFuZU1zdz4+PjI0KSYxNjcxMTkzNXwobGFuZU1zdzw8MjR8bGFuZU1zdz4+PjgpJjQyNzgyNTUzNjA7bGFuZUxzdz0obGFuZUxzdzw8OHxsYW5lTHN3Pj4+MjQpJjE2NzExOTM1fChsYW5lTHN3PDwyNHxsYW5lTHN3Pj4+OCkmNDI3ODI1NTM2MDtoYXNoV29yZHMucHVzaChsYW5lTHN3KTtoYXNoV29yZHMucHVzaChsYW5lTXN3KX1yZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KGhhc2hXb3JkcyxvdXRwdXRMZW5ndGhCeXRlcyl9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGNsb25lPUhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO3ZhciBzdGF0ZT1jbG9uZS5fc3RhdGU9dGhpcy5fc3RhdGUuc2xpY2UoMCk7Zm9yKHZhciBpPTA7aTwyNTtpKyspe3N0YXRlW2ldPXN0YXRlW2ldLmNsb25lKCl9cmV0dXJuIGNsb25lfX0pO0MuU0hBMz1IYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEEzKTtDLkhtYWNTSEEzPUhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEEzKX0pKE1hdGgpO3JldHVybiBDcnlwdG9KUy5TSEEzfSl9LHtcIi4vY29yZVwiOjIwLFwiLi94NjQtY29yZVwiOjUyfV0sNDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4veDY0LWNvcmVcIiksX2RlcmVxXyhcIi4vc2hhNTEyXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4veDY0LWNvcmVcIixcIi4vc2hhNTEyXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ194NjQ9Qy54NjQ7dmFyIFg2NFdvcmQ9Q194NjQuV29yZDt2YXIgWDY0V29yZEFycmF5PUNfeDY0LldvcmRBcnJheTt2YXIgQ19hbGdvPUMuYWxnbzt2YXIgU0hBNTEyPUNfYWxnby5TSEE1MTI7dmFyIFNIQTM4ND1DX2FsZ28uU0hBMzg0PVNIQTUxMi5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgWDY0V29yZEFycmF5LmluaXQoW25ldyBYNjRXb3JkLmluaXQoMzQxODA3MDM2NSwzMjM4MzcxMDMyKSxuZXcgWDY0V29yZC5pbml0KDE2NTQyNzAyNTAsOTE0MTUwNjYzKSxuZXcgWDY0V29yZC5pbml0KDI0Mzg1MjkzNzAsODEyNzAyOTk5KSxuZXcgWDY0V29yZC5pbml0KDM1NTQ2MjM2MCw0MTQ0OTEyNjk3KSxuZXcgWDY0V29yZC5pbml0KDE3MzE0MDU0MTUsNDI5MDc3NTg1NyksbmV3IFg2NFdvcmQuaW5pdCgyMzk0MTgwMjMxLDE3NTA2MDMwMjUpLG5ldyBYNjRXb3JkLmluaXQoMzY3NTAwODUyNSwxNjk0MDc2ODM5KSxuZXcgWDY0V29yZC5pbml0KDEyMDMwNjI4MTMsMzIwNDA3NTQyOCldKX0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgaGFzaD1TSEE1MTIuX2RvRmluYWxpemUuY2FsbCh0aGlzKTtoYXNoLnNpZ0J5dGVzLT0xNjtyZXR1cm4gaGFzaH19KTtDLlNIQTM4ND1TSEE1MTIuX2NyZWF0ZUhlbHBlcihTSEEzODQpO0MuSG1hY1NIQTM4ND1TSEE1MTIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMzg0KX0pKCk7cmV0dXJuIENyeXB0b0pTLlNIQTM4NH0pfSx7XCIuL2NvcmVcIjoyMCxcIi4vc2hhNTEyXCI6NTAsXCIuL3g2NC1jb3JlXCI6NTJ9XSw1MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi94NjQtY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL3g2NC1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIEhhc2hlcj1DX2xpYi5IYXNoZXI7dmFyIENfeDY0PUMueDY0O3ZhciBYNjRXb3JkPUNfeDY0LldvcmQ7dmFyIFg2NFdvcmRBcnJheT1DX3g2NC5Xb3JkQXJyYXk7dmFyIENfYWxnbz1DLmFsZ287ZnVuY3Rpb24gWDY0V29yZF9jcmVhdGUoKXtyZXR1cm4gWDY0V29yZC5jcmVhdGUuYXBwbHkoWDY0V29yZCxhcmd1bWVudHMpfXZhciBLPVtYNjRXb3JkX2NyZWF0ZSgxMTE2MzUyNDA4LDM2MDk3Njc0NTgpLFg2NFdvcmRfY3JlYXRlKDE4OTk0NDc0NDEsNjAyODkxNzI1KSxYNjRXb3JkX2NyZWF0ZSgzMDQ5MzIzNDcxLDM5NjQ0ODQzOTkpLFg2NFdvcmRfY3JlYXRlKDM5MjEwMDk1NzMsMjE3MzI5NTU0OCksWDY0V29yZF9jcmVhdGUoOTYxOTg3MTYzLDQwODE2Mjg0NzIpLFg2NFdvcmRfY3JlYXRlKDE1MDg5NzA5OTMsMzA1MzgzNDI2NSksWDY0V29yZF9jcmVhdGUoMjQ1MzYzNTc0OCwyOTM3NjcxNTc5KSxYNjRXb3JkX2NyZWF0ZSgyODcwNzYzMjIxLDM2NjQ2MDk1NjApLFg2NFdvcmRfY3JlYXRlKDM2MjQzODEwODAsMjczNDg4MzM5NCksWDY0V29yZF9jcmVhdGUoMzEwNTk4NDAxLDExNjQ5OTY1NDIpLFg2NFdvcmRfY3JlYXRlKDYwNzIyNTI3OCwxMzIzNjEwNzY0KSxYNjRXb3JkX2NyZWF0ZSgxNDI2ODgxOTg3LDM1OTAzMDQ5OTQpLFg2NFdvcmRfY3JlYXRlKDE5MjUwNzgzODgsNDA2ODE4MjM4MyksWDY0V29yZF9jcmVhdGUoMjE2MjA3ODIwNiw5OTEzMzYxMTMpLFg2NFdvcmRfY3JlYXRlKDI2MTQ4ODgxMDMsNjMzODAzMzE3KSxYNjRXb3JkX2NyZWF0ZSgzMjQ4MjIyNTgwLDM0Nzk3NzQ4NjgpLFg2NFdvcmRfY3JlYXRlKDM4MzUzOTA0MDEsMjY2NjYxMzQ1OCksWDY0V29yZF9jcmVhdGUoNDAyMjIyNDc3NCw5NDQ3MTExMzkpLFg2NFdvcmRfY3JlYXRlKDI2NDM0NzA3OCwyMzQxMjYyNzczKSxYNjRXb3JkX2NyZWF0ZSg2MDQ4MDc2MjgsMjAwNzgwMDkzMyksWDY0V29yZF9jcmVhdGUoNzcwMjU1OTgzLDE0OTU5OTA5MDEpLFg2NFdvcmRfY3JlYXRlKDEyNDkxNTAxMjIsMTg1NjQzMTIzNSksWDY0V29yZF9jcmVhdGUoMTU1NTA4MTY5MiwzMTc1MjE4MTMyKSxYNjRXb3JkX2NyZWF0ZSgxOTk2MDY0OTg2LDIxOTg5NTA4MzcpLFg2NFdvcmRfY3JlYXRlKDI1NTQyMjA4ODIsMzk5OTcxOTMzOSksWDY0V29yZF9jcmVhdGUoMjgyMTgzNDM0OSw3NjY3ODQwMTYpLFg2NFdvcmRfY3JlYXRlKDI5NTI5OTY4MDgsMjU2NjU5NDg3OSksWDY0V29yZF9jcmVhdGUoMzIxMDMxMzY3MSwzMjAzMzM3OTU2KSxYNjRXb3JkX2NyZWF0ZSgzMzM2NTcxODkxLDEwMzQ0NTcwMjYpLFg2NFdvcmRfY3JlYXRlKDM1ODQ1Mjg3MTEsMjQ2Njk0ODkwMSksWDY0V29yZF9jcmVhdGUoMTEzOTI2OTkzLDM3NTgzMjYzODMpLFg2NFdvcmRfY3JlYXRlKDMzODI0MTg5NSwxNjg3MTc5MzYpLFg2NFdvcmRfY3JlYXRlKDY2NjMwNzIwNSwxMTg4MTc5OTY0KSxYNjRXb3JkX2NyZWF0ZSg3NzM1Mjk5MTIsMTU0NjA0NTczNCksWDY0V29yZF9jcmVhdGUoMTI5NDc1NzM3MiwxNTIyODA1NDg1KSxYNjRXb3JkX2NyZWF0ZSgxMzk2MTgyMjkxLDI2NDM4MzM4MjMpLFg2NFdvcmRfY3JlYXRlKDE2OTUxODM3MDAsMjM0MzUyNzM5MCksWDY0V29yZF9jcmVhdGUoMTk4NjY2MTA1MSwxMDE0NDc3NDgwKSxYNjRXb3JkX2NyZWF0ZSgyMTc3MDI2MzUwLDEyMDY3NTkxNDIpLFg2NFdvcmRfY3JlYXRlKDI0NTY5NTYwMzcsMzQ0MDc3NjI3KSxYNjRXb3JkX2NyZWF0ZSgyNzMwNDg1OTIxLDEyOTA4NjM0NjApLFg2NFdvcmRfY3JlYXRlKDI4MjAzMDI0MTEsMzE1ODQ1NDI3MyksWDY0V29yZF9jcmVhdGUoMzI1OTczMDgwMCwzNTA1OTUyNjU3KSxYNjRXb3JkX2NyZWF0ZSgzMzQ1NzY0NzcxLDEwNjIxNzAwOCksWDY0V29yZF9jcmVhdGUoMzUxNjA2NTgxNywzNjA2MDA4MzQ0KSxYNjRXb3JkX2NyZWF0ZSgzNjAwMzUyODA0LDE0MzI3MjU3NzYpLFg2NFdvcmRfY3JlYXRlKDQwOTQ1NzE5MDksMTQ2NzAzMTU5NCksWDY0V29yZF9jcmVhdGUoMjc1NDIzMzQ0LDg1MTE2OTcyMCksWDY0V29yZF9jcmVhdGUoNDMwMjI3NzM0LDMxMDA4MjM3NTIpLFg2NFdvcmRfY3JlYXRlKDUwNjk0ODYxNiwxMzYzMjU4MTk1KSxYNjRXb3JkX2NyZWF0ZSg2NTkwNjA1NTYsMzc1MDY4NTU5MyksWDY0V29yZF9jcmVhdGUoODgzOTk3ODc3LDM3ODUwNTAyODApLFg2NFdvcmRfY3JlYXRlKDk1ODEzOTU3MSwzMzE4MzA3NDI3KSxYNjRXb3JkX2NyZWF0ZSgxMzIyODIyMjE4LDM4MTI3MjM0MDMpLFg2NFdvcmRfY3JlYXRlKDE1MzcwMDIwNjMsMjAwMzAzNDk5NSksWDY0V29yZF9jcmVhdGUoMTc0Nzg3Mzc3OSwzNjAyMDM2ODk5KSxYNjRXb3JkX2NyZWF0ZSgxOTU1NTYyMjIyLDE1NzU5OTAwMTIpLFg2NFdvcmRfY3JlYXRlKDIwMjQxMDQ4MTUsMTEyNTU5MjkyOCksWDY0V29yZF9jcmVhdGUoMjIyNzczMDQ1MiwyNzE2OTA0MzA2KSxYNjRXb3JkX2NyZWF0ZSgyMzYxODUyNDI0LDQ0Mjc3NjA0NCksWDY0V29yZF9jcmVhdGUoMjQyODQzNjQ3NCw1OTM2OTgzNDQpLFg2NFdvcmRfY3JlYXRlKDI3NTY3MzQxODcsMzczMzExMDI0OSksWDY0V29yZF9jcmVhdGUoMzIwNDAzMTQ3OSwyOTk5MzUxNTczKSxYNjRXb3JkX2NyZWF0ZSgzMzI5MzI1Mjk4LDM4MTU5MjA0MjcpLFg2NFdvcmRfY3JlYXRlKDMzOTE1Njk2MTQsMzkyODM4MzkwMCksWDY0V29yZF9jcmVhdGUoMzUxNTI2NzI3MSw1NjYyODA3MTEpLFg2NFdvcmRfY3JlYXRlKDM5NDAxODc2MDYsMzQ1NDA2OTUzNCksWDY0V29yZF9jcmVhdGUoNDExODYzMDI3MSw0MDAwMjM5OTkyKSxYNjRXb3JkX2NyZWF0ZSgxMTY0MTg0NzQsMTkxNDEzODU1NCksWDY0V29yZF9jcmVhdGUoMTc0MjkyNDIxLDI3MzEwNTUyNzApLFg2NFdvcmRfY3JlYXRlKDI4OTM4MDM1NiwzMjAzOTkzMDA2KSxYNjRXb3JkX2NyZWF0ZSg0NjAzOTMyNjksMzIwNjIwMzE1KSxYNjRXb3JkX2NyZWF0ZSg2ODU0NzE3MzMsNTg3NDk2ODM2KSxYNjRXb3JkX2NyZWF0ZSg4NTIxNDI5NzEsMTA4Njc5Mjg1MSksWDY0V29yZF9jcmVhdGUoMTAxNzAzNjI5OCwzNjU1NDMxMDApLFg2NFdvcmRfY3JlYXRlKDExMjYwMDA1ODAsMjYxODI5NzY3NiksWDY0V29yZF9jcmVhdGUoMTI4ODAzMzQ3MCwzNDA5ODU1MTU4KSxYNjRXb3JkX2NyZWF0ZSgxNTAxNTA1OTQ4LDQyMzQ1MDk4NjYpLFg2NFdvcmRfY3JlYXRlKDE2MDcxNjc5MTUsOTg3MTY3NDY4KSxYNjRXb3JkX2NyZWF0ZSgxODE2NDAyMzE2LDEyNDYxODk1OTEpXTt2YXIgVz1bXTsoZnVuY3Rpb24oKXtmb3IodmFyIGk9MDtpPDgwO2krKyl7V1tpXT1YNjRXb3JkX2NyZWF0ZSgpfX0pKCk7dmFyIFNIQTUxMj1DX2FsZ28uU0hBNTEyPUhhc2hlci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgWDY0V29yZEFycmF5LmluaXQoW25ldyBYNjRXb3JkLmluaXQoMTc3OTAzMzcwMyw0MDg5MjM1NzIwKSxuZXcgWDY0V29yZC5pbml0KDMxNDQxMzQyNzcsMjIyNzg3MzU5NSksbmV3IFg2NFdvcmQuaW5pdCgxMDEzOTA0MjQyLDQyNzExNzU3MjMpLG5ldyBYNjRXb3JkLmluaXQoMjc3MzQ4MDc2MiwxNTk1NzUwMTI5KSxuZXcgWDY0V29yZC5pbml0KDEzNTk4OTMxMTksMjkxNzU2NTEzNyksbmV3IFg2NFdvcmQuaW5pdCgyNjAwODIyOTI0LDcyNTUxMTE5OSksbmV3IFg2NFdvcmQuaW5pdCg1Mjg3MzQ2MzUsNDIxNTM4OTU0NyksbmV3IFg2NFdvcmQuaW5pdCgxNTQxNDU5MjI1LDMyNzAzMzIwOSldKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKE0sb2Zmc2V0KXt2YXIgSD10aGlzLl9oYXNoLndvcmRzO3ZhciBIMD1IWzBdO3ZhciBIMT1IWzFdO3ZhciBIMj1IWzJdO3ZhciBIMz1IWzNdO3ZhciBIND1IWzRdO3ZhciBINT1IWzVdO3ZhciBINj1IWzZdO3ZhciBINz1IWzddO3ZhciBIMGg9SDAuaGlnaDt2YXIgSDBsPUgwLmxvdzt2YXIgSDFoPUgxLmhpZ2g7dmFyIEgxbD1IMS5sb3c7dmFyIEgyaD1IMi5oaWdoO3ZhciBIMmw9SDIubG93O3ZhciBIM2g9SDMuaGlnaDt2YXIgSDNsPUgzLmxvdzt2YXIgSDRoPUg0LmhpZ2g7dmFyIEg0bD1INC5sb3c7dmFyIEg1aD1INS5oaWdoO3ZhciBINWw9SDUubG93O3ZhciBINmg9SDYuaGlnaDt2YXIgSDZsPUg2Lmxvdzt2YXIgSDdoPUg3LmhpZ2g7dmFyIEg3bD1INy5sb3c7dmFyIGFoPUgwaDt2YXIgYWw9SDBsO3ZhciBiaD1IMWg7dmFyIGJsPUgxbDt2YXIgY2g9SDJoO3ZhciBjbD1IMmw7dmFyIGRoPUgzaDt2YXIgZGw9SDNsO3ZhciBlaD1INGg7dmFyIGVsPUg0bDt2YXIgZmg9SDVoO3ZhciBmbD1INWw7dmFyIGdoPUg2aDt2YXIgZ2w9SDZsO3ZhciBoaD1IN2g7dmFyIGhsPUg3bDtmb3IodmFyIGk9MDtpPDgwO2krKyl7dmFyIFdpPVdbaV07aWYoaTwxNil7dmFyIFdpaD1XaS5oaWdoPU1bb2Zmc2V0K2kqMl18MDt2YXIgV2lsPVdpLmxvdz1NW29mZnNldCtpKjIrMV18MH1lbHNle3ZhciBnYW1tYTB4PVdbaS0xNV07dmFyIGdhbW1hMHhoPWdhbW1hMHguaGlnaDt2YXIgZ2FtbWEweGw9Z2FtbWEweC5sb3c7dmFyIGdhbW1hMGg9KGdhbW1hMHhoPj4+MXxnYW1tYTB4bDw8MzEpXihnYW1tYTB4aD4+Pjh8Z2FtbWEweGw8PDI0KV5nYW1tYTB4aD4+Pjc7dmFyIGdhbW1hMGw9KGdhbW1hMHhsPj4+MXxnYW1tYTB4aDw8MzEpXihnYW1tYTB4bD4+Pjh8Z2FtbWEweGg8PDI0KV4oZ2FtbWEweGw+Pj43fGdhbW1hMHhoPDwyNSk7dmFyIGdhbW1hMXg9V1tpLTJdO3ZhciBnYW1tYTF4aD1nYW1tYTF4LmhpZ2g7dmFyIGdhbW1hMXhsPWdhbW1hMXgubG93O3ZhciBnYW1tYTFoPShnYW1tYTF4aD4+PjE5fGdhbW1hMXhsPDwxMyleKGdhbW1hMXhoPDwzfGdhbW1hMXhsPj4+MjkpXmdhbW1hMXhoPj4+Njt2YXIgZ2FtbWExbD0oZ2FtbWExeGw+Pj4xOXxnYW1tYTF4aDw8MTMpXihnYW1tYTF4bDw8M3xnYW1tYTF4aD4+PjI5KV4oZ2FtbWExeGw+Pj42fGdhbW1hMXhoPDwyNik7dmFyIFdpNz1XW2ktN107dmFyIFdpN2g9V2k3LmhpZ2g7dmFyIFdpN2w9V2k3Lmxvdzt2YXIgV2kxNj1XW2ktMTZdO3ZhciBXaTE2aD1XaTE2LmhpZ2g7dmFyIFdpMTZsPVdpMTYubG93O3ZhciBXaWw9Z2FtbWEwbCtXaTdsO3ZhciBXaWg9Z2FtbWEwaCtXaTdoKyhXaWw+Pj4wPGdhbW1hMGw+Pj4wPzE6MCk7dmFyIFdpbD1XaWwrZ2FtbWExbDt2YXIgV2loPVdpaCtnYW1tYTFoKyhXaWw+Pj4wPGdhbW1hMWw+Pj4wPzE6MCk7dmFyIFdpbD1XaWwrV2kxNmw7dmFyIFdpaD1XaWgrV2kxNmgrKFdpbD4+PjA8V2kxNmw+Pj4wPzE6MCk7V2kuaGlnaD1XaWg7V2kubG93PVdpbH12YXIgY2hoPWVoJmZoXn5laCZnaDt2YXIgY2hsPWVsJmZsXn5lbCZnbDt2YXIgbWFqaD1haCZiaF5haCZjaF5iaCZjaDt2YXIgbWFqbD1hbCZibF5hbCZjbF5ibCZjbDt2YXIgc2lnbWEwaD0oYWg+Pj4yOHxhbDw8NCleKGFoPDwzMHxhbD4+PjIpXihhaDw8MjV8YWw+Pj43KTt2YXIgc2lnbWEwbD0oYWw+Pj4yOHxhaDw8NCleKGFsPDwzMHxhaD4+PjIpXihhbDw8MjV8YWg+Pj43KTt2YXIgc2lnbWExaD0oZWg+Pj4xNHxlbDw8MTgpXihlaD4+PjE4fGVsPDwxNCleKGVoPDwyM3xlbD4+PjkpO3ZhciBzaWdtYTFsPShlbD4+PjE0fGVoPDwxOCleKGVsPj4+MTh8ZWg8PDE0KV4oZWw8PDIzfGVoPj4+OSk7dmFyIEtpPUtbaV07dmFyIEtpaD1LaS5oaWdoO3ZhciBLaWw9S2kubG93O3ZhciB0MWw9aGwrc2lnbWExbDt2YXIgdDFoPWhoK3NpZ21hMWgrKHQxbD4+PjA8aGw+Pj4wPzE6MCk7dmFyIHQxbD10MWwrY2hsO3ZhciB0MWg9dDFoK2NoaCsodDFsPj4+MDxjaGw+Pj4wPzE6MCk7dmFyIHQxbD10MWwrS2lsO3ZhciB0MWg9dDFoK0tpaCsodDFsPj4+MDxLaWw+Pj4wPzE6MCk7dmFyIHQxbD10MWwrV2lsO3ZhciB0MWg9dDFoK1dpaCsodDFsPj4+MDxXaWw+Pj4wPzE6MCk7dmFyIHQybD1zaWdtYTBsK21hamw7dmFyIHQyaD1zaWdtYTBoK21hamgrKHQybD4+PjA8c2lnbWEwbD4+PjA/MTowKTtoaD1naDtobD1nbDtnaD1maDtnbD1mbDtmaD1laDtmbD1lbDtlbD1kbCt0MWx8MDtlaD1kaCt0MWgrKGVsPj4+MDxkbD4+PjA/MTowKXwwO2RoPWNoO2RsPWNsO2NoPWJoO2NsPWJsO2JoPWFoO2JsPWFsO2FsPXQxbCt0Mmx8MDthaD10MWgrdDJoKyhhbD4+PjA8dDFsPj4+MD8xOjApfDB9SDBsPUgwLmxvdz1IMGwrYWw7SDAuaGlnaD1IMGgrYWgrKEgwbD4+PjA8YWw+Pj4wPzE6MCk7SDFsPUgxLmxvdz1IMWwrYmw7SDEuaGlnaD1IMWgrYmgrKEgxbD4+PjA8Ymw+Pj4wPzE6MCk7SDJsPUgyLmxvdz1IMmwrY2w7SDIuaGlnaD1IMmgrY2grKEgybD4+PjA8Y2w+Pj4wPzE6MCk7SDNsPUgzLmxvdz1IM2wrZGw7SDMuaGlnaD1IM2grZGgrKEgzbD4+PjA8ZGw+Pj4wPzE6MCk7SDRsPUg0Lmxvdz1INGwrZWw7SDQuaGlnaD1INGgrZWgrKEg0bD4+PjA8ZWw+Pj4wPzE6MCk7SDVsPUg1Lmxvdz1INWwrZmw7SDUuaGlnaD1INWgrZmgrKEg1bD4+PjA8Zmw+Pj4wPzE6MCk7SDZsPUg2Lmxvdz1INmwrZ2w7SDYuaGlnaD1INmgrZ2grKEg2bD4+PjA8Z2w+Pj4wPzE6MCk7SDdsPUg3Lmxvdz1IN2wraGw7SDcuaGlnaD1IN2graGgrKEg3bD4+PjA8aGw+Pj4wPzE6MCl9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGRhdGE9dGhpcy5fZGF0YTt2YXIgZGF0YVdvcmRzPWRhdGEud29yZHM7dmFyIG5CaXRzVG90YWw9dGhpcy5fbkRhdGFCeXRlcyo4O3ZhciBuQml0c0xlZnQ9ZGF0YS5zaWdCeXRlcyo4O2RhdGFXb3Jkc1tuQml0c0xlZnQ+Pj41XXw9MTI4PDwyNC1uQml0c0xlZnQlMzI7ZGF0YVdvcmRzWyhuQml0c0xlZnQrMTI4Pj4+MTA8PDUpKzMwXT1NYXRoLmZsb29yKG5CaXRzVG90YWwvNDI5NDk2NzI5Nik7ZGF0YVdvcmRzWyhuQml0c0xlZnQrMTI4Pj4+MTA8PDUpKzMxXT1uQml0c1RvdGFsO2RhdGEuc2lnQnl0ZXM9ZGF0YVdvcmRzLmxlbmd0aCo0O3RoaXMuX3Byb2Nlc3MoKTt2YXIgaGFzaD10aGlzLl9oYXNoLnRvWDMyKCk7cmV0dXJuIGhhc2h9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGNsb25lPUhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO2Nsb25lLl9oYXNoPXRoaXMuX2hhc2guY2xvbmUoKTtyZXR1cm4gY2xvbmV9LGJsb2NrU2l6ZToxMDI0LzMyfSk7Qy5TSEE1MTI9SGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBNTEyKTtDLkhtYWNTSEE1MTI9SGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTUxMil9KSgpO3JldHVybiBDcnlwdG9KUy5TSEE1MTJ9KX0se1wiLi9jb3JlXCI6MjAsXCIuL3g2NC1jb3JlXCI6NTJ9XSw1MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9lbmMtYmFzZTY0XCIpLF9kZXJlcV8oXCIuL21kNVwiKSxfZGVyZXFfKFwiLi9ldnBrZGZcIiksX2RlcmVxXyhcIi4vY2lwaGVyLWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9lbmMtYmFzZTY0XCIsXCIuL21kNVwiLFwiLi9ldnBrZGZcIixcIi4vY2lwaGVyLWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbigpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgV29yZEFycmF5PUNfbGliLldvcmRBcnJheTt2YXIgQmxvY2tDaXBoZXI9Q19saWIuQmxvY2tDaXBoZXI7dmFyIENfYWxnbz1DLmFsZ287dmFyIFBDMT1bNTcsNDksNDEsMzMsMjUsMTcsOSwxLDU4LDUwLDQyLDM0LDI2LDE4LDEwLDIsNTksNTEsNDMsMzUsMjcsMTksMTEsMyw2MCw1Miw0NCwzNiw2Myw1NSw0NywzOSwzMSwyMywxNSw3LDYyLDU0LDQ2LDM4LDMwLDIyLDE0LDYsNjEsNTMsNDUsMzcsMjksMjEsMTMsNSwyOCwyMCwxMiw0XTt2YXIgUEMyPVsxNCwxNywxMSwyNCwxLDUsMywyOCwxNSw2LDIxLDEwLDIzLDE5LDEyLDQsMjYsOCwxNiw3LDI3LDIwLDEzLDIsNDEsNTIsMzEsMzcsNDcsNTUsMzAsNDAsNTEsNDUsMzMsNDgsNDQsNDksMzksNTYsMzQsNTMsNDYsNDIsNTAsMzYsMjksMzJdO3ZhciBCSVRfU0hJRlRTPVsxLDIsNCw2LDgsMTAsMTIsMTQsMTUsMTcsMTksMjEsMjMsMjUsMjcsMjhdO3ZhciBTQk9YX1A9W3swOjg0MjE4ODgsMjY4NDM1NDU2OjMyNzY4LDUzNjg3MDkxMjo4NDIxMzc4LDgwNTMwNjM2ODoyLDEwNzM3NDE4MjQ6NTEyLDEzNDIxNzcyODA6ODQyMTg5MCwxNjEwNjEyNzM2OjgzODkxMjIsMTg3OTA0ODE5Mjo4Mzg4NjA4LDIxNDc0ODM2NDg6NTE0LDI0MTU5MTkxMDQ6ODM4OTEyMCwyNjg0MzU0NTYwOjMzMjgwLDI5NTI3OTAwMTY6ODQyMTM3NiwzMjIxMjI1NDcyOjMyNzcwLDM0ODk2NjA5Mjg6ODM4ODYxMCwzNzU4MDk2Mzg0OjAsNDAyNjUzMTg0MDozMzI4MiwxMzQyMTc3Mjg6MCw0MDI2NTMxODQ6ODQyMTg5MCw2NzEwODg2NDA6MzMyODIsOTM5NTI0MDk2OjMyNzY4LDEyMDc5NTk1NTI6ODQyMTg4OCwxNDc2Mzk1MDA4OjUxMiwxNzQ0ODMwNDY0Ojg0MjEzNzgsMjAxMzI2NTkyMDoyLDIyODE3MDEzNzY6ODM4OTEyMCwyNTUwMTM2ODMyOjMzMjgwLDI4MTg1NzIyODg6ODQyMTM3NiwzMDg3MDA3NzQ0OjgzODkxMjIsMzM1NTQ0MzIwMDo4Mzg4NjEwLDM2MjM4Nzg2NTY6MzI3NzAsMzg5MjMxNDExMjo1MTQsNDE2MDc0OTU2ODo4Mzg4NjA4LDE6MzI3NjgsMjY4NDM1NDU3OjIsNTM2ODcwOTEzOjg0MjE4ODgsODA1MzA2MzY5OjgzODg2MDgsMTA3Mzc0MTgyNTo4NDIxMzc4LDEzNDIxNzcyODE6MzMyODAsMTYxMDYxMjczNzo1MTIsMTg3OTA0ODE5Mzo4Mzg5MTIyLDIxNDc0ODM2NDk6ODQyMTg5MCwyNDE1OTE5MTA1Ojg0MjEzNzYsMjY4NDM1NDU2MTo4Mzg4NjEwLDI5NTI3OTAwMTc6MzMyODIsMzIyMTIyNTQ3Mzo1MTQsMzQ4OTY2MDkyOTo4Mzg5MTIwLDM3NTgwOTYzODU6MzI3NzAsNDAyNjUzMTg0MTowLDEzNDIxNzcyOTo4NDIxODkwLDQwMjY1MzE4NTo4NDIxMzc2LDY3MTA4ODY0MTo4Mzg4NjA4LDkzOTUyNDA5Nzo1MTIsMTIwNzk1OTU1MzozMjc2OCwxNDc2Mzk1MDA5OjgzODg2MTAsMTc0NDgzMDQ2NToyLDIwMTMyNjU5MjE6MzMyODIsMjI4MTcwMTM3NzozMjc3MCwyNTUwMTM2ODMzOjgzODkxMjIsMjgxODU3MjI4OTo1MTQsMzA4NzAwNzc0NTo4NDIxODg4LDMzNTU0NDMyMDE6ODM4OTEyMCwzNjIzODc4NjU3OjAsMzg5MjMxNDExMzozMzI4MCw0MTYwNzQ5NTY5Ojg0MjEzNzh9LHswOjEwNzQyODI1MTIsMTY3NzcyMTY6MTYzODQsMzM1NTQ0MzI6NTI0Mjg4LDUwMzMxNjQ4OjEwNzQyNjYxMjgsNjcxMDg4NjQ6MTA3Mzc0MTg0MCw4Mzg4NjA4MDoxMDc0MjgyNDk2LDEwMDY2MzI5NjoxMDczNzU4MjA4LDExNzQ0MDUxMjoxNiwxMzQyMTc3Mjg6NTQwNjcyLDE1MDk5NDk0NDoxMDczNzU4MjI0LDE2Nzc3MjE2MDoxMDczNzQxODI0LDE4NDU0OTM3Njo1NDA2ODgsMjAxMzI2NTkyOjUyNDMwNCwyMTgxMDM4MDg6MCwyMzQ4ODEwMjQ6MTY0MDAsMjUxNjU4MjQwOjEwNzQyNjYxMTIsODM4ODYwODoxMDczNzU4MjA4LDI1MTY1ODI0OjU0MDY4OCw0MTk0MzA0MDoxNiw1ODcyMDI1NjoxMDczNzU4MjI0LDc1NDk3NDcyOjEwNzQyODI1MTIsOTIyNzQ2ODg6MTA3Mzc0MTgyNCwxMDkwNTE5MDQ6NTI0Mjg4LDEyNTgyOTEyMDoxMDc0MjY2MTI4LDE0MjYwNjMzNjo1MjQzMDQsMTU5MzgzNTUyOjAsMTc2MTYwNzY4OjE2Mzg0LDE5MjkzNzk4NDoxMDc0MjY2MTEyLDIwOTcxNTIwMDoxMDczNzQxODQwLDIyNjQ5MjQxNjo1NDA2NzIsMjQzMjY5NjMyOjEwNzQyODI0OTYsMjYwMDQ2ODQ4OjE2NDAwLDI2ODQzNTQ1NjowLDI4NTIxMjY3MjoxMDc0MjY2MTI4LDMwMTk4OTg4ODoxMDczNzU4MjI0LDMxODc2NzEwNDoxMDc0MjgyNDk2LDMzNTU0NDMyMDoxMDc0MjY2MTEyLDM1MjMyMTUzNjoxNiwzNjkwOTg3NTI6NTQwNjg4LDM4NTg3NTk2ODoxNjM4NCw0MDI2NTMxODQ6MTY0MDAsNDE5NDMwNDAwOjUyNDI4OCw0MzYyMDc2MTY6NTI0MzA0LDQ1Mjk4NDgzMjoxMDczNzQxODQwLDQ2OTc2MjA0ODo1NDA2NzIsNDg2NTM5MjY0OjEwNzM3NTgyMDgsNTAzMzE2NDgwOjEwNzM3NDE4MjQsNTIwMDkzNjk2OjEwNzQyODI1MTIsMjc2ODI0MDY0OjU0MDY4OCwyOTM2MDEyODA6NTI0Mjg4LDMxMDM3ODQ5NjoxMDc0MjY2MTEyLDMyNzE1NTcxMjoxNjM4NCwzNDM5MzI5Mjg6MTA3Mzc1ODIwOCwzNjA3MTAxNDQ6MTA3NDI4MjUxMiwzNzc0ODczNjA6MTYsMzk0MjY0NTc2OjEwNzM3NDE4MjQsNDExMDQxNzkyOjEwNzQyODI0OTYsNDI3ODE5MDA4OjEwNzM3NDE4NDAsNDQ0NTk2MjI0OjEwNzM3NTgyMjQsNDYxMzczNDQwOjUyNDMwNCw0NzgxNTA2NTY6MCw0OTQ5Mjc4NzI6MTY0MDAsNTExNzA1MDg4OjEwNzQyNjYxMjgsNTI4NDgyMzA0OjU0MDY3Mn0sezA6MjYwLDEwNDg1NzY6MCwyMDk3MTUyOjY3MTA5MTIwLDMxNDU3Mjg6NjU3OTYsNDE5NDMwNDo2NTU0MCw1MjQyODgwOjY3MTA4ODY4LDYyOTE0NTY6NjcxNzQ2NjAsNzM0MDAzMjo2NzE3NDQwMCw4Mzg4NjA4OjY3MTA4ODY0LDk0MzcxODQ6NjcxNzQ2NTYsMTA0ODU3NjA6NjU3OTIsMTE1MzQzMzY6NjcxNzQ0MDQsMTI1ODI5MTI6NjcxMDkxMjQsMTM2MzE0ODg6NjU1MzYsMTQ2ODAwNjQ6NCwxNTcyODY0MDoyNTYsNTI0Mjg4OjY3MTc0NjU2LDE1NzI4NjQ6NjcxNzQ0MDQsMjYyMTQ0MDowLDM2NzAwMTY6NjcxMDkxMjAsNDcxODU5Mjo2NzEwODg2OCw1NzY3MTY4OjY1NTM2LDY4MTU3NDQ6NjU1NDAsNzg2NDMyMDoyNjAsODkxMjg5Njo0LDk5NjE0NzI6MjU2LDExMDEwMDQ4OjY3MTc0NDAwLDEyMDU4NjI0OjY1Nzk2LDEzMTA3MjAwOjY1NzkyLDE0MTU1Nzc2OjY3MTA5MTI0LDE1MjA0MzUyOjY3MTc0NjYwLDE2MjUyOTI4OjY3MTA4ODY0LDE2Nzc3MjE2OjY3MTc0NjU2LDE3ODI1NzkyOjY1NTQwLDE4ODc0MzY4OjY1NTM2LDE5OTIyOTQ0OjY3MTA5MTIwLDIwOTcxNTIwOjI1NiwyMjAyMDA5Njo2NzE3NDY2MCwyMzA2ODY3Mjo2NzEwODg2OCwyNDExNzI0ODowLDI1MTY1ODI0OjY3MTA5MTI0LDI2MjE0NDAwOjY3MTA4ODY0LDI3MjYyOTc2OjQsMjgzMTE1NTI6NjU3OTIsMjkzNjAxMjg6NjcxNzQ0MDAsMzA0MDg3MDQ6MjYwLDMxNDU3MjgwOjY1Nzk2LDMyNTA1ODU2OjY3MTc0NDA0LDE3MzAxNTA0OjY3MTA4ODY0LDE4MzUwMDgwOjI2MCwxOTM5ODY1Njo2NzE3NDY1NiwyMDQ0NzIzMjowLDIxNDk1ODA4OjY1NTQwLDIyNTQ0Mzg0OjY3MTA5MTIwLDIzNTkyOTYwOjI1NiwyNDY0MTUzNjo2NzE3NDQwNCwyNTY5MDExMjo2NTUzNiwyNjczODY4ODo2NzE3NDY2MCwyNzc4NzI2NDo2NTc5NiwyODgzNTg0MDo2NzEwODg2OCwyOTg4NDQxNjo2NzEwOTEyNCwzMDkzMjk5Mjo2NzE3NDQwMCwzMTk4MTU2ODo0LDMzMDMwMTQ0OjY1NzkyfSx7MDoyMTUxNjgyMDQ4LDY1NTM2OjIxNDc0ODc4MDgsMTMxMDcyOjQxOTg0NjQsMTk2NjA4OjIxNTE2Nzc5NTIsMjYyMTQ0OjAsMzI3NjgwOjQxOTg0MDAsMzkzMjE2OjIxNDc0ODM3MTIsNDU4NzUyOjQxOTQzNjgsNTI0Mjg4OjIxNDc0ODM2NDgsNTg5ODI0OjQxOTQzMDQsNjU1MzYwOjY0LDcyMDg5NjoyMTQ3NDg3NzQ0LDc4NjQzMjoyMTUxNjc4MDE2LDg1MTk2ODo0MTYwLDkxNzUwNDo0MDk2LDk4MzA0MDoyMTUxNjgyMTEyLDMyNzY4OjIxNDc0ODc4MDgsOTgzMDQ6NjQsMTYzODQwOjIxNTE2NzgwMTYsMjI5Mzc2OjIxNDc0ODc3NDQsMjk0OTEyOjQxOTg0MDAsMzYwNDQ4OjIxNTE2ODIxMTIsNDI1OTg0OjAsNDkxNTIwOjIxNTE2Nzc5NTIsNTU3MDU2OjQwOTYsNjIyNTkyOjIxNTE2ODIwNDgsNjg4MTI4OjQxOTQzMDQsNzUzNjY0OjQxNjAsODE5MjAwOjIxNDc0ODM2NDgsODg0NzM2OjQxOTQzNjgsOTUwMjcyOjQxOTg0NjQsMTAxNTgwODoyMTQ3NDgzNzEyLDEwNDg1NzY6NDE5NDM2OCwxMTE0MTEyOjQxOTg0MDAsMTE3OTY0ODoyMTQ3NDgzNzEyLDEyNDUxODQ6MCwxMzEwNzIwOjQxNjAsMTM3NjI1NjoyMTUxNjc4MDE2LDE0NDE3OTI6MjE1MTY4MjA0OCwxNTA3MzI4OjIxNDc0ODc4MDgsMTU3Mjg2NDoyMTUxNjgyMTEyLDE2Mzg0MDA6MjE0NzQ4MzY0OCwxNzAzOTM2OjIxNTE2Nzc5NTIsMTc2OTQ3Mjo0MTk4NDY0LDE4MzUwMDg6MjE0NzQ4Nzc0NCwxOTAwNTQ0OjQxOTQzMDQsMTk2NjA4MDo2NCwyMDMxNjE2OjQwOTYsMTA4MTM0NDoyMTUxNjc3OTUyLDExNDY4ODA6MjE1MTY4MjExMiwxMjEyNDE2OjAsMTI3Nzk1Mjo0MTk4NDAwLDEzNDM0ODg6NDE5NDM2OCwxNDA5MDI0OjIxNDc0ODM2NDgsMTQ3NDU2MDoyMTQ3NDg3ODA4LDE1NDAwOTY6NjQsMTYwNTYzMjoyMTQ3NDgzNzEyLDE2NzExNjg6NDA5NiwxNzM2NzA0OjIxNDc0ODc3NDQsMTgwMjI0MDoyMTUxNjc4MDE2LDE4Njc3NzY6NDE2MCwxOTMzMzEyOjIxNTE2ODIwNDgsMTk5ODg0ODo0MTk0MzA0LDIwNjQzODQ6NDE5ODQ2NH0sezA6MTI4LDQwOTY6MTcwMzkzNjAsODE5MjoyNjIxNDQsMTIyODg6NTM2ODcwOTEyLDE2Mzg0OjUzNzEzMzE4NCwyMDQ4MDoxNjc3NzM0NCwyNDU3Njo1NTM2NDgyNTYsMjg2NzI6MjYyMjcyLDMyNzY4OjE2Nzc3MjE2LDM2ODY0OjUzNzEzMzA1Niw0MDk2MDo1MzY4NzEwNDAsNDUwNTY6NTUzOTEwNDAwLDQ5MTUyOjU1MzkxMDI3Miw1MzI0ODowLDU3MzQ0OjE3MDM5NDg4LDYxNDQwOjU1MzY0ODEyOCwyMDQ4OjE3MDM5NDg4LDYxNDQ6NTUzNjQ4MjU2LDEwMjQwOjEyOCwxNDMzNjoxNzAzOTM2MCwxODQzMjoyNjIxNDQsMjI1Mjg6NTM3MTMzMTg0LDI2NjI0OjU1MzkxMDI3MiwzMDcyMDo1MzY4NzA5MTIsMzQ4MTY6NTM3MTMzMDU2LDM4OTEyOjAsNDMwMDg6NTUzOTEwNDAwLDQ3MTA0OjE2Nzc3MzQ0LDUxMjAwOjUzNjg3MTA0MCw1NTI5Njo1NTM2NDgxMjgsNTkzOTI6MTY3NzcyMTYsNjM0ODg6MjYyMjcyLDY1NTM2OjI2MjE0NCw2OTYzMjoxMjgsNzM3Mjg6NTM2ODcwOTEyLDc3ODI0OjU1MzY0ODI1Niw4MTkyMDoxNjc3NzM0NCw4NjAxNjo1NTM5MTAyNzIsOTAxMTI6NTM3MTMzMTg0LDk0MjA4OjE2Nzc3MjE2LDk4MzA0OjU1MzkxMDQwMCwxMDI0MDA6NTUzNjQ4MTI4LDEwNjQ5NjoxNzAzOTM2MCwxMTA1OTI6NTM3MTMzMDU2LDExNDY4ODoyNjIyNzIsMTE4Nzg0OjUzNjg3MTA0MCwxMjI4ODA6MCwxMjY5NzY6MTcwMzk0ODgsNjc1ODQ6NTUzNjQ4MjU2LDcxNjgwOjE2Nzc3MjE2LDc1Nzc2OjE3MDM5MzYwLDc5ODcyOjUzNzEzMzE4NCw4Mzk2ODo1MzY4NzA5MTIsODgwNjQ6MTcwMzk0ODgsOTIxNjA6MTI4LDk2MjU2OjU1MzkxMDI3MiwxMDAzNTI6MjYyMjcyLDEwNDQ0ODo1NTM5MTA0MDAsMTA4NTQ0OjAsMTEyNjQwOjU1MzY0ODEyOCwxMTY3MzY6MTY3NzczNDQsMTIwODMyOjI2MjE0NCwxMjQ5Mjg6NTM3MTMzMDU2LDEyOTAyNDo1MzY4NzEwNDB9LHswOjI2ODQzNTQ2NCwyNTY6ODE5Miw1MTI6MjcwNTMyNjA4LDc2ODoyNzA1NDA4MDgsMTAyNDoyNjg0NDM2NDgsMTI4MDoyMDk3MTUyLDE1MzY6MjA5NzE2MCwxNzkyOjI2ODQzNTQ1NiwyMDQ4OjAsMjMwNDoyNjg0NDM2NTYsMjU2MDoyMTA1MzQ0LDI4MTY6OCwzMDcyOjI3MDUzMjYxNiwzMzI4OjIxMDUzNTIsMzU4NDo4MjAwLDM4NDA6MjcwNTQwODAwLDEyODoyNzA1MzI2MDgsMzg0OjI3MDU0MDgwOCw2NDA6OCw4OTY6MjA5NzE1MiwxMTUyOjIxMDUzNTIsMTQwODoyNjg0MzU0NjQsMTY2NDoyNjg0NDM2NDgsMTkyMDo4MjAwLDIxNzY6MjA5NzE2MCwyNDMyOjgxOTIsMjY4ODoyNjg0NDM2NTYsMjk0NDoyNzA1MzI2MTYsMzIwMDowLDM0NTY6MjcwNTQwODAwLDM3MTI6MjEwNTM0NCwzOTY4OjI2ODQzNTQ1Niw0MDk2OjI2ODQ0MzY0OCw0MzUyOjI3MDUzMjYxNiw0NjA4OjI3MDU0MDgwOCw0ODY0OjgyMDAsNTEyMDoyMDk3MTUyLDUzNzY6MjY4NDM1NDU2LDU2MzI6MjY4NDM1NDY0LDU4ODg6MjEwNTM0NCw2MTQ0OjIxMDUzNTIsNjQwMDowLDY2NTY6OCw2OTEyOjI3MDUzMjYwOCw3MTY4OjgxOTIsNzQyNDoyNjg0NDM2NTYsNzY4MDoyNzA1NDA4MDAsNzkzNjoyMDk3MTYwLDQyMjQ6OCw0NDgwOjIxMDUzNDQsNDczNjoyMDk3MTUyLDQ5OTI6MjY4NDM1NDY0LDUyNDg6MjY4NDQzNjQ4LDU1MDQ6ODIwMCw1NzYwOjI3MDU0MDgwOCw2MDE2OjI3MDUzMjYwOCw2MjcyOjI3MDU0MDgwMCw2NTI4OjI3MDUzMjYxNiw2Nzg0OjgxOTIsNzA0MDoyMTA1MzUyLDcyOTY6MjA5NzE2MCw3NTUyOjAsNzgwODoyNjg0MzU0NTYsODA2NDoyNjg0NDM2NTZ9LHswOjEwNDg1NzYsMTY6MzM1NTU0NTcsMzI6MTAyNCw0ODoxMDQ5NjAxLDY0OjM0NjA0MDMzLDgwOjAsOTY6MSwxMTI6MzQ2MDMwMDksMTI4OjMzNTU1NDU2LDE0NDoxMDQ4NTc3LDE2MDozMzU1NDQzMywxNzY6MzQ2MDQwMzIsMTkyOjM0NjAzMDA4LDIwODoxMDI1LDIyNDoxMDQ5NjAwLDI0MDozMzU1NDQzMiw4OjM0NjAzMDA5LDI0OjAsNDA6MzM1NTU0NTcsNTY6MzQ2MDQwMzIsNzI6MTA0ODU3Niw4ODozMzU1NDQzMywxMDQ6MzM1NTQ0MzIsMTIwOjEwMjUsMTM2OjEwNDk2MDEsMTUyOjMzNTU1NDU2LDE2ODozNDYwMzAwOCwxODQ6MTA0ODU3NywyMDA6MTAyNCwyMTY6MzQ2MDQwMzMsMjMyOjEsMjQ4OjEwNDk2MDAsMjU2OjMzNTU0NDMyLDI3MjoxMDQ4NTc2LDI4ODozMzU1NTQ1NywzMDQ6MzQ2MDMwMDksMzIwOjEwNDg1NzcsMzM2OjMzNTU1NDU2LDM1MjozNDYwNDAzMiwzNjg6MTA0OTYwMSwzODQ6MTAyNSw0MDA6MzQ2MDQwMzMsNDE2OjEwNDk2MDAsNDMyOjEsNDQ4OjAsNDY0OjM0NjAzMDA4LDQ4MDozMzU1NDQzMyw0OTY6MTAyNCwyNjQ6MTA0OTYwMCwyODA6MzM1NTU0NTcsMjk2OjM0NjAzMDA5LDMxMjoxLDMyODozMzU1NDQzMiwzNDQ6MTA0ODU3NiwzNjA6MTAyNSwzNzY6MzQ2MDQwMzIsMzkyOjMzNTU0NDMzLDQwODozNDYwMzAwOCw0MjQ6MCw0NDA6MzQ2MDQwMzMsNDU2OjEwNDk2MDEsNDcyOjEwMjQsNDg4OjMzNTU1NDU2LDUwNDoxMDQ4NTc3fSx7MDoxMzQyMTk4MDgsMToxMzEwNzIsMjoxMzQyMTc3MjgsMzozMiw0OjEzMTEwNCw1OjEzNDM1MDg4MCw2OjEzNDM1MDg0OCw3OjIwNDgsODoxMzQzNDg4MDAsOToxMzQyMTk3NzYsMTA6MTMzMTIwLDExOjEzNDM0ODgzMiwxMjoyMDgwLDEzOjAsMTQ6MTM0MjE3NzYwLDE1OjEzMzE1MiwyMTQ3NDgzNjQ4OjIwNDgsMjE0NzQ4MzY0OToxMzQzNTA4ODAsMjE0NzQ4MzY1MDoxMzQyMTk4MDgsMjE0NzQ4MzY1MToxMzQyMTc3MjgsMjE0NzQ4MzY1MjoxMzQzNDg4MDAsMjE0NzQ4MzY1MzoxMzMxMjAsMjE0NzQ4MzY1NDoxMzMxNTIsMjE0NzQ4MzY1NTozMiwyMTQ3NDgzNjU2OjEzNDIxNzc2MCwyMTQ3NDgzNjU3OjIwODAsMjE0NzQ4MzY1ODoxMzExMDQsMjE0NzQ4MzY1OToxMzQzNTA4NDgsMjE0NzQ4MzY2MDowLDIxNDc0ODM2NjE6MTM0MzQ4ODMyLDIxNDc0ODM2NjI6MTM0MjE5Nzc2LDIxNDc0ODM2NjM6MTMxMDcyLDE2OjEzMzE1MiwxNzoxMzQzNTA4NDgsMTg6MzIsMTk6MjA0OCwyMDoxMzQyMTk3NzYsMjE6MTM0MjE3NzYwLDIyOjEzNDM0ODgzMiwyMzoxMzEwNzIsMjQ6MCwyNToxMzExMDQsMjY6MTM0MzQ4ODAwLDI3OjEzNDIxOTgwOCwyODoxMzQzNTA4ODAsMjk6MTMzMTIwLDMwOjIwODAsMzE6MTM0MjE3NzI4LDIxNDc0ODM2NjQ6MTMxMDcyLDIxNDc0ODM2NjU6MjA0OCwyMTQ3NDgzNjY2OjEzNDM0ODgzMiwyMTQ3NDgzNjY3OjEzMzE1MiwyMTQ3NDgzNjY4OjMyLDIxNDc0ODM2Njk6MTM0MzQ4ODAwLDIxNDc0ODM2NzA6MTM0MjE3NzI4LDIxNDc0ODM2NzE6MTM0MjE5ODA4LDIxNDc0ODM2NzI6MTM0MzUwODgwLDIxNDc0ODM2NzM6MTM0MjE3NzYwLDIxNDc0ODM2NzQ6MTM0MjE5Nzc2LDIxNDc0ODM2NzU6MCwyMTQ3NDgzNjc2OjEzMzEyMCwyMTQ3NDgzNjc3OjIwODAsMjE0NzQ4MzY3ODoxMzExMDQsMjE0NzQ4MzY3OToxMzQzNTA4NDh9XTtcbnZhciBTQk9YX01BU0s9WzQxNjA3NDk1NjksNTI4NDgyMzA0LDMzMDMwMTQ0LDIwNjQzODQsMTI5MDI0LDgwNjQsNTA0LDIxNDc0ODM2NzldO3ZhciBERVM9Q19hbGdvLkRFUz1CbG9ja0NpcGhlci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dmFyIGtleT10aGlzLl9rZXk7dmFyIGtleVdvcmRzPWtleS53b3Jkczt2YXIga2V5Qml0cz1bXTtmb3IodmFyIGk9MDtpPDU2O2krKyl7dmFyIGtleUJpdFBvcz1QQzFbaV0tMTtrZXlCaXRzW2ldPWtleVdvcmRzW2tleUJpdFBvcz4+PjVdPj4+MzEta2V5Qml0UG9zJTMyJjF9dmFyIHN1YktleXM9dGhpcy5fc3ViS2V5cz1bXTtmb3IodmFyIG5TdWJLZXk9MDtuU3ViS2V5PDE2O25TdWJLZXkrKyl7dmFyIHN1YktleT1zdWJLZXlzW25TdWJLZXldPVtdO3ZhciBiaXRTaGlmdD1CSVRfU0hJRlRTW25TdWJLZXldO2Zvcih2YXIgaT0wO2k8MjQ7aSsrKXtzdWJLZXlbaS82fDBdfD1rZXlCaXRzWyhQQzJbaV0tMStiaXRTaGlmdCklMjhdPDwzMS1pJTY7c3ViS2V5WzQrKGkvNnwwKV18PWtleUJpdHNbMjgrKFBDMltpKzI0XS0xK2JpdFNoaWZ0KSUyOF08PDMxLWklNn1zdWJLZXlbMF09c3ViS2V5WzBdPDwxfHN1YktleVswXT4+PjMxO2Zvcih2YXIgaT0xO2k8NztpKyspe3N1YktleVtpXT1zdWJLZXlbaV0+Pj4oaS0xKSo0KzN9c3ViS2V5WzddPXN1YktleVs3XTw8NXxzdWJLZXlbN10+Pj4yN312YXIgaW52U3ViS2V5cz10aGlzLl9pbnZTdWJLZXlzPVtdO2Zvcih2YXIgaT0wO2k8MTY7aSsrKXtpbnZTdWJLZXlzW2ldPXN1YktleXNbMTUtaV19fSxlbmNyeXB0QmxvY2s6ZnVuY3Rpb24oTSxvZmZzZXQpe3RoaXMuX2RvQ3J5cHRCbG9jayhNLG9mZnNldCx0aGlzLl9zdWJLZXlzKX0sZGVjcnlwdEJsb2NrOmZ1bmN0aW9uKE0sb2Zmc2V0KXt0aGlzLl9kb0NyeXB0QmxvY2soTSxvZmZzZXQsdGhpcy5faW52U3ViS2V5cyl9LF9kb0NyeXB0QmxvY2s6ZnVuY3Rpb24oTSxvZmZzZXQsc3ViS2V5cyl7dGhpcy5fbEJsb2NrPU1bb2Zmc2V0XTt0aGlzLl9yQmxvY2s9TVtvZmZzZXQrMV07ZXhjaGFuZ2VMUi5jYWxsKHRoaXMsNCwyNTI2NDUxMzUpO2V4Y2hhbmdlTFIuY2FsbCh0aGlzLDE2LDY1NTM1KTtleGNoYW5nZVJMLmNhbGwodGhpcywyLDg1ODk5MzQ1OSk7ZXhjaGFuZ2VSTC5jYWxsKHRoaXMsOCwxNjcxMTkzNSk7ZXhjaGFuZ2VMUi5jYWxsKHRoaXMsMSwxNDMxNjU1NzY1KTtmb3IodmFyIHJvdW5kPTA7cm91bmQ8MTY7cm91bmQrKyl7dmFyIHN1YktleT1zdWJLZXlzW3JvdW5kXTt2YXIgbEJsb2NrPXRoaXMuX2xCbG9jazt2YXIgckJsb2NrPXRoaXMuX3JCbG9jazt2YXIgZj0wO2Zvcih2YXIgaT0wO2k8ODtpKyspe2Z8PVNCT1hfUFtpXVsoKHJCbG9ja15zdWJLZXlbaV0pJlNCT1hfTUFTS1tpXSk+Pj4wXX10aGlzLl9sQmxvY2s9ckJsb2NrO3RoaXMuX3JCbG9jaz1sQmxvY2teZn12YXIgdD10aGlzLl9sQmxvY2s7dGhpcy5fbEJsb2NrPXRoaXMuX3JCbG9jazt0aGlzLl9yQmxvY2s9dDtleGNoYW5nZUxSLmNhbGwodGhpcywxLDE0MzE2NTU3NjUpO2V4Y2hhbmdlUkwuY2FsbCh0aGlzLDgsMTY3MTE5MzUpO2V4Y2hhbmdlUkwuY2FsbCh0aGlzLDIsODU4OTkzNDU5KTtleGNoYW5nZUxSLmNhbGwodGhpcywxNiw2NTUzNSk7ZXhjaGFuZ2VMUi5jYWxsKHRoaXMsNCwyNTI2NDUxMzUpO01bb2Zmc2V0XT10aGlzLl9sQmxvY2s7TVtvZmZzZXQrMV09dGhpcy5fckJsb2NrfSxrZXlTaXplOjY0LzMyLGl2U2l6ZTo2NC8zMixibG9ja1NpemU6NjQvMzJ9KTtmdW5jdGlvbiBleGNoYW5nZUxSKG9mZnNldCxtYXNrKXt2YXIgdD0odGhpcy5fbEJsb2NrPj4+b2Zmc2V0XnRoaXMuX3JCbG9jaykmbWFzazt0aGlzLl9yQmxvY2tePXQ7dGhpcy5fbEJsb2NrXj10PDxvZmZzZXR9ZnVuY3Rpb24gZXhjaGFuZ2VSTChvZmZzZXQsbWFzayl7dmFyIHQ9KHRoaXMuX3JCbG9jaz4+Pm9mZnNldF50aGlzLl9sQmxvY2spJm1hc2s7dGhpcy5fbEJsb2NrXj10O3RoaXMuX3JCbG9ja149dDw8b2Zmc2V0fUMuREVTPUJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoREVTKTt2YXIgVHJpcGxlREVTPUNfYWxnby5UcmlwbGVERVM9QmxvY2tDaXBoZXIuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3ZhciBrZXk9dGhpcy5fa2V5O3ZhciBrZXlXb3Jkcz1rZXkud29yZHM7dGhpcy5fZGVzMT1ERVMuY3JlYXRlRW5jcnlwdG9yKFdvcmRBcnJheS5jcmVhdGUoa2V5V29yZHMuc2xpY2UoMCwyKSkpO3RoaXMuX2RlczI9REVTLmNyZWF0ZUVuY3J5cHRvcihXb3JkQXJyYXkuY3JlYXRlKGtleVdvcmRzLnNsaWNlKDIsNCkpKTt0aGlzLl9kZXMzPURFUy5jcmVhdGVFbmNyeXB0b3IoV29yZEFycmF5LmNyZWF0ZShrZXlXb3Jkcy5zbGljZSg0LDYpKSl9LGVuY3J5cHRCbG9jazpmdW5jdGlvbihNLG9mZnNldCl7dGhpcy5fZGVzMS5lbmNyeXB0QmxvY2soTSxvZmZzZXQpO3RoaXMuX2RlczIuZGVjcnlwdEJsb2NrKE0sb2Zmc2V0KTt0aGlzLl9kZXMzLmVuY3J5cHRCbG9jayhNLG9mZnNldCl9LGRlY3J5cHRCbG9jazpmdW5jdGlvbihNLG9mZnNldCl7dGhpcy5fZGVzMy5kZWNyeXB0QmxvY2soTSxvZmZzZXQpO3RoaXMuX2RlczIuZW5jcnlwdEJsb2NrKE0sb2Zmc2V0KTt0aGlzLl9kZXMxLmRlY3J5cHRCbG9jayhNLG9mZnNldCl9LGtleVNpemU6MTkyLzMyLGl2U2l6ZTo2NC8zMixibG9ja1NpemU6NjQvMzJ9KTtDLlRyaXBsZURFUz1CbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKFRyaXBsZURFUyl9KSgpO3JldHVybiBDcnlwdG9KUy5UcmlwbGVERVN9KX0se1wiLi9jaXBoZXItY29yZVwiOjE5LFwiLi9jb3JlXCI6MjAsXCIuL2VuYy1iYXNlNjRcIjoyMSxcIi4vZXZwa2RmXCI6MjMsXCIuL21kNVwiOjI5fV0sNTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3Rvcnkpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKHVuZGVmaW5lZCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBCYXNlPUNfbGliLkJhc2U7dmFyIFgzMldvcmRBcnJheT1DX2xpYi5Xb3JkQXJyYXk7dmFyIENfeDY0PUMueDY0PXt9O3ZhciBYNjRXb3JkPUNfeDY0LldvcmQ9QmFzZS5leHRlbmQoe2luaXQ6ZnVuY3Rpb24oaGlnaCxsb3cpe3RoaXMuaGlnaD1oaWdoO3RoaXMubG93PWxvd319KTt2YXIgWDY0V29yZEFycmF5PUNfeDY0LldvcmRBcnJheT1CYXNlLmV4dGVuZCh7aW5pdDpmdW5jdGlvbih3b3JkcyxzaWdCeXRlcyl7d29yZHM9dGhpcy53b3Jkcz13b3Jkc3x8W107aWYoc2lnQnl0ZXMhPXVuZGVmaW5lZCl7dGhpcy5zaWdCeXRlcz1zaWdCeXRlc31lbHNle3RoaXMuc2lnQnl0ZXM9d29yZHMubGVuZ3RoKjh9fSx0b1gzMjpmdW5jdGlvbigpe3ZhciB4NjRXb3Jkcz10aGlzLndvcmRzO3ZhciB4NjRXb3Jkc0xlbmd0aD14NjRXb3Jkcy5sZW5ndGg7dmFyIHgzMldvcmRzPVtdO2Zvcih2YXIgaT0wO2k8eDY0V29yZHNMZW5ndGg7aSsrKXt2YXIgeDY0V29yZD14NjRXb3Jkc1tpXTt4MzJXb3Jkcy5wdXNoKHg2NFdvcmQuaGlnaCk7eDMyV29yZHMucHVzaCh4NjRXb3JkLmxvdyl9cmV0dXJuIFgzMldvcmRBcnJheS5jcmVhdGUoeDMyV29yZHMsdGhpcy5zaWdCeXRlcyl9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGNsb25lPUJhc2UuY2xvbmUuY2FsbCh0aGlzKTt2YXIgd29yZHM9Y2xvbmUud29yZHM9dGhpcy53b3Jkcy5zbGljZSgwKTt2YXIgd29yZHNMZW5ndGg9d29yZHMubGVuZ3RoO2Zvcih2YXIgaT0wO2k8d29yZHNMZW5ndGg7aSsrKXt3b3Jkc1tpXT13b3Jkc1tpXS5jbG9uZSgpfXJldHVybiBjbG9uZX19KX0pKCk7cmV0dXJuIENyeXB0b0pTfSl9LHtcIi4vY29yZVwiOjIwfV0sNTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihwcm9jZXNzKXshZnVuY3Rpb24oZ2xvYmFscyl7XCJ1c2Ugc3RyaWN0XCI7aWYodHlwZW9mIGRlZmluZSE9PVwidW5kZWZpbmVkXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmdW5jdGlvbigpe3JldHVybiBzZWN1cmVSYW5kb219KX1lbHNlIGlmKHR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiJiZtb2R1bGUuZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9c2VjdXJlUmFuZG9tfWVsc2V7Z2xvYmFscy5zZWN1cmVSYW5kb209c2VjdXJlUmFuZG9tfWZ1bmN0aW9uIHNlY3VyZVJhbmRvbShjb3VudCxvcHRpb25zKXtvcHRpb25zPW9wdGlvbnN8fHt9O2lmKHR5cGVvZiBwcm9jZXNzIT1cInVuZGVmaW5lZFwiJiZ0eXBlb2YgcHJvY2Vzcy5waWQ9PVwibnVtYmVyXCIpe3JldHVybiBub2RlUmFuZG9tKGNvdW50LG9wdGlvbnMpfWVsc2V7aWYoIXdpbmRvdy5jcnlwdG8pdGhyb3cgbmV3IEVycm9yKFwiWW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgd2luZG93LmNyeXB0by5cIik7cmV0dXJuIGJyb3dzZXJSYW5kb20oY291bnQsb3B0aW9ucyl9fWZ1bmN0aW9uIG5vZGVSYW5kb20oY291bnQsb3B0aW9ucyl7dmFyIGNyeXB0bz1fZGVyZXFfKFwiY3J5cHRvXCIpO3ZhciBidWY9Y3J5cHRvLnJhbmRvbUJ5dGVzKGNvdW50KTtpZihvcHRpb25zLmFycmF5KXZhciByZXQ9W107ZWxzZSB2YXIgcmV0PW5ldyBVaW50OEFycmF5KGNvdW50KTtmb3IodmFyIGk9MDtpPGNvdW50OysraSl7cmV0W2ldPWJ1Zi5yZWFkVUludDgoaSl9cmV0dXJuIHJldH1mdW5jdGlvbiBicm93c2VyUmFuZG9tKGNvdW50LG9wdGlvbnMpe3ZhciBuYXRpdmVBcnI9bmV3IFVpbnQ4QXJyYXkoY291bnQpO3dpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5hdGl2ZUFycik7aWYob3B0aW9ucy5hcnJheSl7dmFyIHJldD1bXTtmb3IodmFyIGk9MDtpPG5hdGl2ZUFyci5sZW5ndGg7KytpKXtyZXRbaV09bmF0aXZlQXJyW2ldfX1lbHNle3JldD1uYXRpdmVBcnJ9cmV0dXJuIHJldH19KHRoaXMpfSkuY2FsbCh0aGlzLF9kZXJlcV8oXCJGV2FBU0hcIikpfSx7RldhQVNIOjE1LGNyeXB0bzo0fV0sNTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBiYXNlNTg9X2RlcmVxXyhcIi4vYmFzZTU4XCIpO3ZhciBiYXNlNThjaGVjaz1fZGVyZXFfKFwiLi9iYXNlNThjaGVja1wiKTt2YXIgY29udmVydD1fZGVyZXFfKFwiLi9jb252ZXJ0XCIpO3ZhciBlcnJvcj1fZGVyZXFfKFwiLi91dGlsXCIpLmVycm9yO3ZhciBtYWlubmV0PV9kZXJlcV8oXCIuL25ldHdvcmtcIikubWFpbm5ldC5hZGRyZXNzVmVyc2lvbjtmdW5jdGlvbiBBZGRyZXNzKGJ5dGVzLHZlcnNpb24pe2lmKCEodGhpcyBpbnN0YW5jZW9mIEFkZHJlc3MpKXtyZXR1cm4gbmV3IEFkZHJlc3MoYnl0ZXMsdmVyc2lvbil9aWYoYnl0ZXMgaW5zdGFuY2VvZiBBZGRyZXNzKXt0aGlzLmhhc2g9Ynl0ZXMuaGFzaDt0aGlzLnZlcnNpb249Ynl0ZXMudmVyc2lvbn1lbHNlIGlmKHR5cGVvZiBieXRlcz09PVwic3RyaW5nXCIpe2lmKGJ5dGVzLmxlbmd0aDw9MzUpe3ZhciBkZWNvZGU9YmFzZTU4Y2hlY2suZGVjb2RlKGJ5dGVzKTt0aGlzLmhhc2g9ZGVjb2RlLnBheWxvYWQ7dGhpcy52ZXJzaW9uPWRlY29kZS52ZXJzaW9ufWVsc2UgaWYoYnl0ZXMubGVuZ3RoPD00MCl7dGhpcy5oYXNoPWNvbnZlcnQuaGV4VG9CeXRlcyhieXRlcyk7dGhpcy52ZXJzaW9uPXZlcnNpb258fG1haW5uZXR9ZWxzZXtlcnJvcihcImludmFsaWQgb3IgdW5yZWNvZ25pemVkIGlucHV0XCIpfX1lbHNle3RoaXMuaGFzaD1ieXRlczt0aGlzLnZlcnNpb249dmVyc2lvbnx8bWFpbm5ldH19QWRkcmVzcy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gYmFzZTU4Y2hlY2suZW5jb2RlKHRoaXMuaGFzaC5zbGljZSgwKSx0aGlzLnZlcnNpb24pfTtBZGRyZXNzLmdldFZlcnNpb249ZnVuY3Rpb24oYWRkcmVzcyl7cmV0dXJuIGJhc2U1OC5kZWNvZGUoYWRkcmVzcylbMF19O0FkZHJlc3MudmFsaWRhdGU9ZnVuY3Rpb24oYWRkcmVzcyl7dHJ5e2Jhc2U1OGNoZWNrLmRlY29kZShhZGRyZXNzKTtyZXR1cm4gdHJ1ZX1jYXRjaChlKXtyZXR1cm4gZmFsc2V9fTttb2R1bGUuZXhwb3J0cz1BZGRyZXNzfSx7XCIuL2Jhc2U1OFwiOjU1LFwiLi9iYXNlNThjaGVja1wiOjU2LFwiLi9jb252ZXJ0XCI6NTcsXCIuL25ldHdvcmtcIjo2NixcIi4vdXRpbFwiOjcwfV0sNTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihCdWZmZXIpe3ZhciBCaWdJbnRlZ2VyPV9kZXJlcV8oXCIuL2pzYm4vanNiblwiKTt2YXIgYWxwaGFiZXQ9XCIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XCI7dmFyIGJhc2U9QmlnSW50ZWdlci52YWx1ZU9mKDU4KTt2YXIgYWxwaGFiZXRNYXA9e307Zm9yKHZhciBpPTA7aTxhbHBoYWJldC5sZW5ndGg7KytpKXt2YXIgY2hyPWFscGhhYmV0W2ldO2FscGhhYmV0TWFwW2Nocl09QmlnSW50ZWdlci52YWx1ZU9mKGkpfWZ1bmN0aW9uIGVuY29kZShidWZmZXIpe3ZhciBiaT1CaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZChidWZmZXIpO3ZhciBjaGFycz1bXTt3aGlsZShiaS5jb21wYXJlVG8oYmFzZSk+PTApe3ZhciBtb2Q9YmkubW9kKGJhc2UpO2JpPWJpLnN1YnRyYWN0KG1vZCkuZGl2aWRlKGJhc2UpO2NoYXJzLnB1c2goYWxwaGFiZXRbbW9kLmludFZhbHVlKCldKX1jaGFycy5wdXNoKGFscGhhYmV0W2JpLmludFZhbHVlKCldKTtmb3IodmFyIGk9MDtpPGJ1ZmZlci5sZW5ndGg7aSsrKXtpZihidWZmZXJbaV0hPT0wKWJyZWFrO2NoYXJzLnB1c2goYWxwaGFiZXRbMF0pfXJldHVybiBjaGFycy5yZXZlcnNlKCkuam9pbihcIlwiKX1mdW5jdGlvbiBkZWNvZGUoc3RyKXt2YXIgbnVtPUJpZ0ludGVnZXIudmFsdWVPZigwKTt2YXIgbGVhZGluZ196ZXJvPTA7dmFyIHNlZW5fb3RoZXI9ZmFsc2U7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIGNocj1zdHJbaV07dmFyIGJpPWFscGhhYmV0TWFwW2Nocl07aWYoYmk9PT11bmRlZmluZWQpe3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgYmFzZTU4IHN0cmluZzogXCIrc3RyKX1udW09bnVtLm11bHRpcGx5KGJhc2UpLmFkZChiaSk7aWYoY2hyPT09XCIxXCImJiFzZWVuX290aGVyKXsrK2xlYWRpbmdfemVyb31lbHNle3NlZW5fb3RoZXI9dHJ1ZX19dmFyIGJ5dGVzPW51bS50b0J5dGVBcnJheVVuc2lnbmVkKCk7d2hpbGUobGVhZGluZ196ZXJvLS0+MCl7Ynl0ZXMudW5zaGlmdCgwKX1yZXR1cm4gbmV3IEJ1ZmZlcihieXRlcyl9bW9kdWxlLmV4cG9ydHM9e2VuY29kZTplbmNvZGUsZGVjb2RlOmRlY29kZX19KS5jYWxsKHRoaXMsX2RlcmVxXyhcImJ1ZmZlclwiKS5CdWZmZXIpfSx7XCIuL2pzYm4vanNiblwiOjYzLGJ1ZmZlcjo1fV0sNTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihCdWZmZXIpe3ZhciBhc3NlcnQ9X2RlcmVxXyhcImFzc2VydFwiKTt2YXIgYmFzZTU4PV9kZXJlcV8oXCIuL2Jhc2U1OFwiKTt2YXIgY3J5cHRvPV9kZXJlcV8oXCJjcnlwdG9cIik7ZnVuY3Rpb24gc2hhMjU2KGJ1Zil7dmFyIGhhc2g9Y3J5cHRvLmNyZWF0ZUhhc2goXCJzaGEyNTZcIik7aGFzaC51cGRhdGUoYnVmKTtyZXR1cm4gaGFzaC5kaWdlc3QoKX1mdW5jdGlvbiBlbmNvZGUoYnVmZmVyLHZlcnNpb24pe3ZlcnNpb249dmVyc2lvbnx8MDt2YXIgdmVyc2lvbj1uZXcgQnVmZmVyKFt2ZXJzaW9uXSk7dmFyIHBheWxvYWQ9bmV3IEJ1ZmZlcihidWZmZXIpO3ZhciBtZXNzYWdlPUJ1ZmZlci5jb25jYXQoW3ZlcnNpb24scGF5bG9hZF0pO3ZhciBjaGVja3N1bT1zaGEyNTYoc2hhMjU2KG1lc3NhZ2UpKS5zbGljZSgwLDQpO3JldHVybiBiYXNlNTguZW5jb2RlKEJ1ZmZlci5jb25jYXQoW21lc3NhZ2UsY2hlY2tzdW1dKSl9ZnVuY3Rpb24gZGVjb2RlKHN0cmluZyl7dmFyIGJ1ZmZlcj1iYXNlNTguZGVjb2RlKHN0cmluZyk7dmFyIG1lc3NhZ2U9YnVmZmVyLnNsaWNlKDAsLTQpO3ZhciBjaGVja3N1bT1idWZmZXIuc2xpY2UoLTQpO3ZhciBuZXdDaGVja3N1bT1zaGEyNTYoc2hhMjU2KG1lc3NhZ2UpKS5zbGljZSgwLDQpO2Fzc2VydC5kZWVwRXF1YWwobmV3Q2hlY2tzdW0sY2hlY2tzdW0pO3ZhciB2ZXJzaW9uPW1lc3NhZ2UucmVhZFVJbnQ4KDApO3ZhciBwYXlsb2FkPW1lc3NhZ2Uuc2xpY2UoMSk7cmV0dXJue3ZlcnNpb246dmVyc2lvbixwYXlsb2FkOnBheWxvYWQsY2hlY2tzdW06Y2hlY2tzdW19fW1vZHVsZS5leHBvcnRzPXtlbmNvZGU6ZW5jb2RlLGRlY29kZTpkZWNvZGV9fSkuY2FsbCh0aGlzLF9kZXJlcV8oXCJidWZmZXJcIikuQnVmZmVyKX0se1wiLi9iYXNlNThcIjo1NSxhc3NlcnQ6MSxidWZmZXI6NSxjcnlwdG86OX1dLDU3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oQnVmZmVyKXt2YXIgQ3J5cHRvPV9kZXJlcV8oXCJjcnlwdG8tanNcIik7dmFyIFdvcmRBcnJheT1DcnlwdG8ubGliLldvcmRBcnJheTt2YXIgYmFzZTY0bWFwPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO2Z1bmN0aW9uIGxwYWQoc3RyLHBhZFN0cmluZyxsZW5ndGgpe3doaWxlKHN0ci5sZW5ndGg8bGVuZ3RoKXN0cj1wYWRTdHJpbmcrc3RyO3JldHVybiBzdHJ9ZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcyl7aWYoQnVmZmVyLmlzQnVmZmVyKGJ5dGVzKSl7cmV0dXJuIGJ5dGVzLnRvU3RyaW5nKFwiaGV4XCIpfXJldHVybiBieXRlcy5tYXAoZnVuY3Rpb24oeCl7cmV0dXJuIGxwYWQoeC50b1N0cmluZygxNiksXCIwXCIsMil9KS5qb2luKFwiXCIpfWZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KXtyZXR1cm4gaGV4Lm1hdGNoKC8uLi9nKS5tYXAoZnVuY3Rpb24oeCl7cmV0dXJuIHBhcnNlSW50KHgsMTYpfSl9ZnVuY3Rpb24gYnl0ZXNUb0Jhc2U2NChieXRlcyl7dmFyIGJhc2U2ND1bXTtmb3IodmFyIGk9MDtpPGJ5dGVzLmxlbmd0aDtpKz0zKXt2YXIgdHJpcGxldD1ieXRlc1tpXTw8MTZ8Ynl0ZXNbaSsxXTw8OHxieXRlc1tpKzJdO2Zvcih2YXIgaj0wO2o8NDtqKyspe2lmKGkqOCtqKjY8PWJ5dGVzLmxlbmd0aCo4KXtiYXNlNjQucHVzaChiYXNlNjRtYXAuY2hhckF0KHRyaXBsZXQ+Pj42KigzLWopJjYzKSl9ZWxzZXtiYXNlNjQucHVzaChcIj1cIil9fX1yZXR1cm4gYmFzZTY0LmpvaW4oXCJcIil9ZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyhiYXNlNjQpe2Jhc2U2ND1iYXNlNjQucmVwbGFjZSgvW15BLVowLTkrXFwvXS9naSxcIlwiKTt2YXIgYnl0ZXM9W107dmFyIGltb2Q0PTA7Zm9yKHZhciBpPTA7aTxiYXNlNjQubGVuZ3RoO2ltb2Q0PSsraSU0KXtpZighaW1vZDQpY29udGludWU7Ynl0ZXMucHVzaCgoYmFzZTY0bWFwLmluZGV4T2YoYmFzZTY0LmNoYXJBdChpLTEpKSZNYXRoLnBvdygyLC0yKmltb2Q0KzgpLTEpPDxpbW9kNCoyfGJhc2U2NG1hcC5pbmRleE9mKGJhc2U2NC5jaGFyQXQoaSkpPj4+Ni1pbW9kNCoyKX1yZXR1cm4gYnl0ZXN9ZnVuY3Rpb24gY29lcmNlVG9CeXRlcyhpbnB1dCl7aWYodHlwZW9mIGlucHV0IT1cInN0cmluZ1wiKXJldHVybiBpbnB1dDtyZXR1cm4gaGV4VG9CeXRlcyhpbnB1dCl9ZnVuY3Rpb24gYmluVG9CeXRlcyhiaW4pe3JldHVybiBiaW4ubWF0Y2goLy4uLi4uLi4uL2cpLm1hcChmdW5jdGlvbih4KXtyZXR1cm4gcGFyc2VJbnQoeCwyKX0pfWZ1bmN0aW9uIGJ5dGVzVG9CaW4oYnl0ZXMpe3JldHVybiBieXRlcy5tYXAoZnVuY3Rpb24oeCl7cmV0dXJuIGxwYWQoeC50b1N0cmluZygyKSxcIjBcIiw4KX0pLmpvaW4oXCJcIil9ZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcyl7cmV0dXJuIGJ5dGVzLm1hcChmdW5jdGlvbih4KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh4KX0pLmpvaW4oXCJcIil9ZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHJpbmcpe3JldHVybiBzdHJpbmcuc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uKHgpe3JldHVybiB4LmNoYXJDb2RlQXQoMCl9KX1mdW5jdGlvbiBudW1Ub0J5dGVzKG51bSxieXRlcyl7aWYoYnl0ZXM9PT11bmRlZmluZWQpYnl0ZXM9ODtpZihieXRlcz09PTApcmV0dXJuW107cmV0dXJuW251bSUyNTZdLmNvbmNhdChudW1Ub0J5dGVzKE1hdGguZmxvb3IobnVtLzI1NiksYnl0ZXMtMSkpfWZ1bmN0aW9uIGJ5dGVzVG9OdW0oYnl0ZXMpe2lmKGJ5dGVzLmxlbmd0aD09PTApcmV0dXJuIDA7cmV0dXJuIGJ5dGVzWzBdKzI1NipieXRlc1RvTnVtKGJ5dGVzLnNsaWNlKDEpKX1mdW5jdGlvbiBudW1Ub1ZhckludChudW0pe2lmKG51bTwyNTMpcmV0dXJuW251bV07aWYobnVtPDY1NTM2KXJldHVyblsyNTNdLmNvbmNhdChudW1Ub0J5dGVzKG51bSwyKSk7aWYobnVtPDQyOTQ5NjcyOTYpcmV0dXJuWzI1NF0uY29uY2F0KG51bVRvQnl0ZXMobnVtLDQpKTtyZXR1cm5bMjU1XS5jb25jYXQobnVtVG9CeXRlcyhudW0sOCkpfWZ1bmN0aW9uIHZhckludFRvTnVtKGJ5dGVzKXt2YXIgcHJlZml4PWJ5dGVzWzBdO3ZhciB2aUJ5dGVzPXByZWZpeDwyNTM/Ynl0ZXMuc2xpY2UoMCwxKTpwcmVmaXg9PT0yNTM/Ynl0ZXMuc2xpY2UoMSwzKTpwcmVmaXg9PT0yNTQ/Ynl0ZXMuc2xpY2UoMSw1KTpieXRlcy5zbGljZSgxLDkpO3JldHVybntieXRlczpwcmVmaXg8MjUzP3ZpQnl0ZXM6Ynl0ZXMuc2xpY2UoMCx2aUJ5dGVzLmxlbmd0aCsxKSxudW1iZXI6Ynl0ZXNUb051bSh2aUJ5dGVzKX19ZnVuY3Rpb24gYnl0ZXNUb1dvcmRzKGJ5dGVzKXt2YXIgd29yZHM9W107Zm9yKHZhciBpPTAsYj0wO2k8Ynl0ZXMubGVuZ3RoO2krKyxiKz04KXt3b3Jkc1tiPj4+NV18PWJ5dGVzW2ldPDwyNC1iJTMyfXJldHVybiB3b3Jkc31mdW5jdGlvbiB3b3Jkc1RvQnl0ZXMod29yZHMpe3ZhciBieXRlcz1bXTtmb3IodmFyIGI9MDtiPHdvcmRzLmxlbmd0aCozMjtiKz04KXtieXRlcy5wdXNoKHdvcmRzW2I+Pj41XT4+PjI0LWIlMzImMjU1KX1yZXR1cm4gYnl0ZXN9ZnVuY3Rpb24gYnl0ZXNUb1dvcmRBcnJheShieXRlcyl7cmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdChieXRlc1RvV29yZHMoYnl0ZXMpLGJ5dGVzLmxlbmd0aCl9ZnVuY3Rpb24gd29yZEFycmF5VG9CeXRlcyh3b3JkQXJyYXkpe3JldHVybiB3b3Jkc1RvQnl0ZXMod29yZEFycmF5LndvcmRzKX1mdW5jdGlvbiByZXZlcnNlRW5kaWFuKGhleCl7cmV0dXJuIGJ5dGVzVG9IZXgoaGV4VG9CeXRlcyhoZXgpLnJldmVyc2UoKSl9bW9kdWxlLmV4cG9ydHM9e2xwYWQ6bHBhZCxieXRlc1RvSGV4OmJ5dGVzVG9IZXgsaGV4VG9CeXRlczpoZXhUb0J5dGVzLGJ5dGVzVG9CYXNlNjQ6Ynl0ZXNUb0Jhc2U2NCxiYXNlNjRUb0J5dGVzOmJhc2U2NFRvQnl0ZXMsY29lcmNlVG9CeXRlczpjb2VyY2VUb0J5dGVzLGJpblRvQnl0ZXM6YmluVG9CeXRlcyxieXRlc1RvQmluOmJ5dGVzVG9CaW4sYnl0ZXNUb1N0cmluZzpieXRlc1RvU3RyaW5nLHN0cmluZ1RvQnl0ZXM6c3RyaW5nVG9CeXRlcyxudW1Ub0J5dGVzOm51bVRvQnl0ZXMsYnl0ZXNUb051bTpieXRlc1RvTnVtLG51bVRvVmFySW50Om51bVRvVmFySW50LHZhckludFRvTnVtOnZhckludFRvTnVtLGJ5dGVzVG9Xb3JkczpieXRlc1RvV29yZHMsd29yZHNUb0J5dGVzOndvcmRzVG9CeXRlcyxieXRlc1RvV29yZEFycmF5OmJ5dGVzVG9Xb3JkQXJyYXksd29yZEFycmF5VG9CeXRlczp3b3JkQXJyYXlUb0J5dGVzLHJldmVyc2VFbmRpYW46cmV2ZXJzZUVuZGlhbn19KS5jYWxsKHRoaXMsX2RlcmVxXyhcImJ1ZmZlclwiKS5CdWZmZXIpfSx7YnVmZmVyOjUsXCJjcnlwdG8tanNcIjoyN31dLDU4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgc2VjPV9kZXJlcV8oXCIuL2pzYm4vc2VjXCIpO3ZhciBybmc9X2RlcmVxXyhcInNlY3VyZS1yYW5kb21cIik7dmFyIEJpZ0ludGVnZXI9X2RlcmVxXyhcIi4vanNibi9qc2JuXCIpO3ZhciBjb252ZXJ0PV9kZXJlcV8oXCIuL2NvbnZlcnRcIik7dmFyIEhtYWNTSEEyNTY9X2RlcmVxXyhcImNyeXB0by1qcy9obWFjLXNoYTI1NlwiKTt2YXIgRUNQb2ludEZwPV9kZXJlcV8oXCIuL2pzYm4vZWNcIikuRUNQb2ludEZwO3ZhciBlY3BhcmFtcz1zZWMoXCJzZWNwMjU2azFcIik7dmFyIFBfT1ZFUl9GT1VSPW51bGw7ZnVuY3Rpb24gaW1wbFNoYW1pcnNUcmljayhQLGssUSxsKXt2YXIgbT1NYXRoLm1heChrLmJpdExlbmd0aCgpLGwuYml0TGVuZ3RoKCkpO3ZhciBaPVAuYWRkMkQoUSk7dmFyIFI9UC5jdXJ2ZS5nZXRJbmZpbml0eSgpO2Zvcih2YXIgaT1tLTE7aT49MDstLWkpe1I9Ui50d2ljZTJEKCk7Ui56PUJpZ0ludGVnZXIuT05FO2lmKGsudGVzdEJpdChpKSl7aWYobC50ZXN0Qml0KGkpKXtSPVIuYWRkMkQoWil9ZWxzZXtSPVIuYWRkMkQoUCl9fWVsc2V7aWYobC50ZXN0Qml0KGkpKXtSPVIuYWRkMkQoUSl9fX1yZXR1cm4gUn1mdW5jdGlvbiBkZXRlcm1pbmlzdGljR2VuZXJhdGVLKGhhc2gsa2V5KXt2YXIgdkFycj1bXTt2YXIga0Fycj1bXTtmb3IodmFyIGk9MDtpPDMyO2krKyl2QXJyLnB1c2goMSk7Zm9yKHZhciBpPTA7aTwzMjtpKyspa0Fyci5wdXNoKDApO3ZhciB2PWNvbnZlcnQuYnl0ZXNUb1dvcmRBcnJheSh2QXJyKTt2YXIgaz1jb252ZXJ0LmJ5dGVzVG9Xb3JkQXJyYXkoa0Fycik7az1IbWFjU0hBMjU2KGNvbnZlcnQuYnl0ZXNUb1dvcmRBcnJheSh2QXJyLmNvbmNhdChbMF0pLmNvbmNhdChrZXkpLmNvbmNhdChoYXNoKSksayk7dj1IbWFjU0hBMjU2KHYsayk7dkFycj1jb252ZXJ0LndvcmRBcnJheVRvQnl0ZXModik7az1IbWFjU0hBMjU2KGNvbnZlcnQuYnl0ZXNUb1dvcmRBcnJheSh2QXJyLmNvbmNhdChbMV0pLmNvbmNhdChrZXkpLmNvbmNhdChoYXNoKSksayk7dj1IbWFjU0hBMjU2KHYsayk7dj1IbWFjU0hBMjU2KHYsayk7dkFycj1jb252ZXJ0LndvcmRBcnJheVRvQnl0ZXModik7cmV0dXJuIEJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKHZBcnIpfXZhciBFQ0RTQT17Z2V0QmlnUmFuZG9tOmZ1bmN0aW9uKGxpbWl0KXtyZXR1cm4gbmV3IEJpZ0ludGVnZXIobGltaXQuYml0TGVuZ3RoKCkscm5nKS5tb2QobGltaXQuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpKS5hZGQoQmlnSW50ZWdlci5PTkUpfSxzaWduOmZ1bmN0aW9uKGhhc2gscHJpdil7dmFyIGQ9cHJpdjt2YXIgbj1lY3BhcmFtcy5nZXROKCk7dmFyIGU9QmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQoaGFzaCk7dmFyIGs9ZGV0ZXJtaW5pc3RpY0dlbmVyYXRlSyhoYXNoLHByaXYudG9CeXRlQXJyYXlVbnNpZ25lZCgpKTt2YXIgRz1lY3BhcmFtcy5nZXRHKCk7dmFyIFE9Ry5tdWx0aXBseShrKTt2YXIgcj1RLmdldFgoKS50b0JpZ0ludGVnZXIoKS5tb2Qobik7dmFyIHM9ay5tb2RJbnZlcnNlKG4pLm11bHRpcGx5KGUuYWRkKGQubXVsdGlwbHkocikpKS5tb2Qobik7cmV0dXJuIEVDRFNBLnNlcmlhbGl6ZVNpZyhyLHMpfSx2ZXJpZnk6ZnVuY3Rpb24oaGFzaCxzaWcscHVia2V5KXt2YXIgcixzO2lmKEFycmF5LmlzQXJyYXkoc2lnKSl7dmFyIG9iaj1FQ0RTQS5wYXJzZVNpZyhzaWcpO3I9b2JqLnI7cz1vYmouc31lbHNlIGlmKFwib2JqZWN0XCI9PT10eXBlb2Ygc2lnJiZzaWcuciYmc2lnLnMpe3I9c2lnLnI7cz1zaWcuc31lbHNle3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHNpZ25hdHVyZVwiKX12YXIgUTtpZihwdWJrZXkgaW5zdGFuY2VvZiBFQ1BvaW50RnApe1E9cHVia2V5fWVsc2UgaWYoQXJyYXkuaXNBcnJheShwdWJrZXkpKXtRPUVDUG9pbnRGcC5kZWNvZGVGcm9tKGVjcGFyYW1zLmdldEN1cnZlKCkscHVia2V5KX1lbHNle3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgZm9ybWF0IGZvciBwdWJrZXkgdmFsdWUsIG11c3QgYmUgYnl0ZSBhcnJheSBvciBFQ1BvaW50RnBcIil9dmFyIGU9QmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQoaGFzaCk7cmV0dXJuIEVDRFNBLnZlcmlmeVJhdyhlLHIscyxRKX0sdmVyaWZ5UmF3OmZ1bmN0aW9uKGUscixzLFEpe3ZhciBuPWVjcGFyYW1zLmdldE4oKTt2YXIgRz1lY3BhcmFtcy5nZXRHKCk7aWYoci5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpPDB8fHIuY29tcGFyZVRvKG4pPj0wKXtyZXR1cm4gZmFsc2V9aWYocy5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpPDB8fHMuY29tcGFyZVRvKG4pPj0wKXtyZXR1cm4gZmFsc2V9dmFyIGM9cy5tb2RJbnZlcnNlKG4pO3ZhciB1MT1lLm11bHRpcGx5KGMpLm1vZChuKTt2YXIgdTI9ci5tdWx0aXBseShjKS5tb2Qobik7dmFyIHBvaW50PUcubXVsdGlwbHkodTEpLmFkZChRLm11bHRpcGx5KHUyKSk7dmFyIHY9cG9pbnQuZ2V0WCgpLnRvQmlnSW50ZWdlcigpLm1vZChuKTtyZXR1cm4gdi5lcXVhbHMocil9LHNlcmlhbGl6ZVNpZzpmdW5jdGlvbihyLHMpe3ZhciByQmE9ci50b0J5dGVBcnJheVNpZ25lZCgpO3ZhciBzQmE9cy50b0J5dGVBcnJheVNpZ25lZCgpO3ZhciBzZXF1ZW5jZT1bXTtzZXF1ZW5jZS5wdXNoKDIpO3NlcXVlbmNlLnB1c2gockJhLmxlbmd0aCk7c2VxdWVuY2U9c2VxdWVuY2UuY29uY2F0KHJCYSk7c2VxdWVuY2UucHVzaCgyKTtzZXF1ZW5jZS5wdXNoKHNCYS5sZW5ndGgpO3NlcXVlbmNlPXNlcXVlbmNlLmNvbmNhdChzQmEpO3NlcXVlbmNlLnVuc2hpZnQoc2VxdWVuY2UubGVuZ3RoKTtzZXF1ZW5jZS51bnNoaWZ0KDQ4KTtyZXR1cm4gc2VxdWVuY2V9LHBhcnNlU2lnOmZ1bmN0aW9uKHNpZyl7dmFyIGN1cnNvcjtpZihzaWdbMF0hPTQ4KXt0aHJvdyBuZXcgRXJyb3IoXCJTaWduYXR1cmUgbm90IGEgdmFsaWQgREVSU2VxdWVuY2VcIil9Y3Vyc29yPTI7aWYoc2lnW2N1cnNvcl0hPTIpe3Rocm93IG5ldyBFcnJvcihcIkZpcnN0IGVsZW1lbnQgaW4gc2lnbmF0dXJlIG11c3QgYmUgYSBERVJJbnRlZ2VyXCIpfXZhciByQmE9c2lnLnNsaWNlKGN1cnNvcisyLGN1cnNvcisyK3NpZ1tjdXJzb3IrMV0pO2N1cnNvcis9MitzaWdbY3Vyc29yKzFdO2lmKHNpZ1tjdXJzb3JdIT0yKXt0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmQgZWxlbWVudCBpbiBzaWduYXR1cmUgbXVzdCBiZSBhIERFUkludGVnZXJcIil9dmFyIHNCYT1zaWcuc2xpY2UoY3Vyc29yKzIsY3Vyc29yKzIrc2lnW2N1cnNvcisxXSk7Y3Vyc29yKz0yK3NpZ1tjdXJzb3IrMV07dmFyIHI9QmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQockJhKTt2YXIgcz1CaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZChzQmEpO3JldHVybntyOnIsczpzfX0scGFyc2VTaWdDb21wYWN0OmZ1bmN0aW9uKHNpZyl7aWYoc2lnLmxlbmd0aCE9PTY1KXt0aHJvdyBuZXcgRXJyb3IoXCJTaWduYXR1cmUgaGFzIHRoZSB3cm9uZyBsZW5ndGhcIil9dmFyIGk9c2lnWzBdLTI3O2lmKGk8MHx8aT43KXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNpZ25hdHVyZSB0eXBlXCIpfXZhciBuPWVjcGFyYW1zLmdldE4oKTt2YXIgcj1CaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZChzaWcuc2xpY2UoMSwzMykpLm1vZChuKTt2YXIgcz1CaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZChzaWcuc2xpY2UoMzMsNjUpKS5tb2Qobik7cmV0dXJue3I6cixzOnMsaTppfX0scmVjb3ZlclB1YktleTpmdW5jdGlvbihyLHMsaGFzaCxpKXtpPWkmMzt2YXIgaXNZRXZlbj1pJjE7dmFyIGlzU2Vjb25kS2V5PWk+PjE7dmFyIG49ZWNwYXJhbXMuZ2V0TigpO3ZhciBHPWVjcGFyYW1zLmdldEcoKTt2YXIgY3VydmU9ZWNwYXJhbXMuZ2V0Q3VydmUoKTt2YXIgcD1jdXJ2ZS5nZXRRKCk7dmFyIGE9Y3VydmUuZ2V0QSgpLnRvQmlnSW50ZWdlcigpO3ZhciBiPWN1cnZlLmdldEIoKS50b0JpZ0ludGVnZXIoKTtpZighUF9PVkVSX0ZPVVIpe1BfT1ZFUl9GT1VSPXAuYWRkKEJpZ0ludGVnZXIuT05FKS5kaXZpZGUoQmlnSW50ZWdlci52YWx1ZU9mKDQpKX12YXIgeD1pc1NlY29uZEtleT9yLmFkZChuKTpyO3ZhciBhbHBoYT14Lm11bHRpcGx5KHgpLm11bHRpcGx5KHgpLmFkZChhLm11bHRpcGx5KHgpKS5hZGQoYikubW9kKHApO3ZhciBiZXRhPWFscGhhLm1vZFBvdyhQX09WRVJfRk9VUixwKTt2YXIgeT0oYmV0YS5pc0V2ZW4oKT8haXNZRXZlbjppc1lFdmVuKT9iZXRhOnAuc3VidHJhY3QoYmV0YSk7dmFyIFI9bmV3IEVDUG9pbnRGcChjdXJ2ZSxjdXJ2ZS5mcm9tQmlnSW50ZWdlcih4KSxjdXJ2ZS5mcm9tQmlnSW50ZWdlcih5KSk7Ui52YWxpZGF0ZSgpO3ZhciBlPUJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKGhhc2gpO3ZhciBlTmVnPUJpZ0ludGVnZXIuWkVSTy5zdWJ0cmFjdChlKS5tb2Qobik7dmFyIHJJbnY9ci5tb2RJbnZlcnNlKG4pO3ZhciBRPWltcGxTaGFtaXJzVHJpY2soUixzLEcsZU5lZykubXVsdGlwbHkockludik7US52YWxpZGF0ZSgpO2lmKCFFQ0RTQS52ZXJpZnlSYXcoZSxyLHMsUSkpe3Rocm93IG5ldyBFcnJvcihcIlB1YmtleSByZWNvdmVyeSB1bnN1Y2Nlc3NmdWxcIil9cmV0dXJuIFF9LGNhbGNQdWJLZXlSZWNvdmVyeVBhcmFtOmZ1bmN0aW9uKG9yaWdQdWJLZXkscixzLGhhc2gpe2Zvcih2YXIgaT0wO2k8NDtpKyspe3ZhciBwdWJLZXk9RUNEU0EucmVjb3ZlclB1YktleShyLHMsaGFzaCxpKTtpZihwdWJLZXkuZXF1YWxzKG9yaWdQdWJLZXkpKXtyZXR1cm4gaX19dGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgdmFsaWQgcmVjb3ZlcnkgZmFjdG9yXCIpfX07bW9kdWxlLmV4cG9ydHM9RUNEU0F9LHtcIi4vY29udmVydFwiOjU3LFwiLi9qc2JuL2VjXCI6NjIsXCIuL2pzYm4vanNiblwiOjYzLFwiLi9qc2JuL3NlY1wiOjY0LFwiY3J5cHRvLWpzL2htYWMtc2hhMjU2XCI6MjUsXCJzZWN1cmUtcmFuZG9tXCI6NTN9XSw1OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIEFkZHJlc3M9X2RlcmVxXyhcIi4vYWRkcmVzc1wiKTt2YXIgYXNzZXJ0PV9kZXJlcV8oXCJhc3NlcnRcIik7dmFyIGNvbnZlcnQ9X2RlcmVxXyhcIi4vY29udmVydFwiKTt2YXIgYmFzZTU4Y2hlY2s9X2RlcmVxXyhcIi4vYmFzZTU4Y2hlY2tcIik7dmFyIEJpZ0ludGVnZXI9X2RlcmVxXyhcIi4vanNibi9qc2JuXCIpO3ZhciBlY2RzYT1fZGVyZXFfKFwiLi9lY2RzYVwiKTt2YXIgRUNQb2ludEZwPV9kZXJlcV8oXCIuL2pzYm4vZWNcIikuRUNQb2ludEZwO3ZhciBzZWM9X2RlcmVxXyhcIi4vanNibi9zZWNcIik7dmFyIE5ldHdvcms9X2RlcmVxXyhcIi4vbmV0d29ya1wiKTt2YXIgdXRpbD1fZGVyZXFfKFwiLi91dGlsXCIpO3ZhciBlY3BhcmFtcz1zZWMoXCJzZWNwMjU2azFcIik7dmFyIEVDS2V5PWZ1bmN0aW9uKGlucHV0LGNvbXByZXNzZWQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIEVDS2V5KSl7cmV0dXJuIG5ldyBFQ0tleShpbnB1dCxjb21wcmVzc2VkKX1pZighaW5wdXQpe3ZhciBuPWVjcGFyYW1zLmdldE4oKTt0aGlzLnByaXY9ZWNkc2EuZ2V0QmlnUmFuZG9tKG4pO3RoaXMuY29tcHJlc3NlZD1jb21wcmVzc2VkfHxmYWxzZX1lbHNlIHRoaXMuaW1wb3J0KGlucHV0LGNvbXByZXNzZWQpfTtFQ0tleS5wcm90b3R5cGUuaW1wb3J0PWZ1bmN0aW9uKGlucHV0LGNvbXByZXNzZWQpe2Z1bmN0aW9uIGhhcyhsaSx2KXtyZXR1cm4gbGkuaW5kZXhPZih2KT49MH1mdW5jdGlvbiBmcm9tQmluKHgpe3JldHVybiBCaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZCh4KX10aGlzLnByaXY9aW5wdXQgaW5zdGFuY2VvZiBFQ0tleT9pbnB1dC5wcml2OmlucHV0IGluc3RhbmNlb2YgQmlnSW50ZWdlcj9pbnB1dC5tb2QoZWNwYXJhbXMuZ2V0TigpKTpBcnJheS5pc0FycmF5KGlucHV0KT9mcm9tQmluKGlucHV0LnNsaWNlKDAsMzIpKTp0eXBlb2YgaW5wdXQhPVwic3RyaW5nXCI/bnVsbDppbnB1dC5sZW5ndGg9PTQ0P2Zyb21CaW4oY29udmVydC5iYXNlNjRUb0J5dGVzKGlucHV0KSk6aW5wdXQubGVuZ3RoPT01MSYmaW5wdXRbMF09PVwiNVwiP2Zyb21CaW4oYmFzZTU4Y2hlY2suZGVjb2RlKGlucHV0KS5wYXlsb2FkKTppbnB1dC5sZW5ndGg9PTUxJiZpbnB1dFswXT09XCI5XCI/ZnJvbUJpbihiYXNlNThjaGVjay5kZWNvZGUoaW5wdXQpLnBheWxvYWQpOmlucHV0Lmxlbmd0aD09NTImJmhhcyhcIkxLXCIsaW5wdXRbMF0pP2Zyb21CaW4oYmFzZTU4Y2hlY2suZGVjb2RlKGlucHV0KS5wYXlsb2FkLnNsaWNlKDAsMzIpKTppbnB1dC5sZW5ndGg9PTUyJiZpbnB1dFswXT09XCJjXCI/ZnJvbUJpbihiYXNlNThjaGVjay5kZWNvZGUoaW5wdXQpLnBheWxvYWQuc2xpY2UoMCwzMikpOmhhcyhbNjQsNjVdLGlucHV0Lmxlbmd0aCk/ZnJvbUJpbihjb252ZXJ0LmhleFRvQnl0ZXMoaW5wdXQuc2xpY2UoMCw2NCkpKTpudWxsO2Fzc2VydCh0aGlzLnByaXYhPT1udWxsKTt0aGlzLmNvbXByZXNzZWQ9Y29tcHJlc3NlZCE9PXVuZGVmaW5lZD9jb21wcmVzc2VkOmlucHV0IGluc3RhbmNlb2YgRUNLZXk/aW5wdXQuY29tcHJlc3NlZDppbnB1dCBpbnN0YW5jZW9mIEJpZ0ludGVnZXI/ZmFsc2U6QXJyYXkuaXNBcnJheShpbnB1dCk/ZmFsc2U6dHlwZW9mIGlucHV0IT1cInN0cmluZ1wiP251bGw6aW5wdXQubGVuZ3RoPT00ND9mYWxzZTppbnB1dC5sZW5ndGg9PTUxJiZpbnB1dFswXT09XCI1XCI/ZmFsc2U6aW5wdXQubGVuZ3RoPT01MSYmaW5wdXRbMF09PVwiOVwiP2ZhbHNlOmlucHV0Lmxlbmd0aD09NTImJmhhcyhcIkxLXCIsaW5wdXRbMF0pP3RydWU6aW5wdXQubGVuZ3RoPT01MiYmaW5wdXRbMF09PVwiY1wiP3RydWU6aW5wdXQubGVuZ3RoPT02ND9mYWxzZTppbnB1dC5sZW5ndGg9PTY1P3RydWU6bnVsbDthc3NlcnQodGhpcy5jb21wcmVzc2VkIT09bnVsbCl9O0VDS2V5LnByb3RvdHlwZS5nZXRQdWI9ZnVuY3Rpb24oY29tcHJlc3NlZCl7aWYoY29tcHJlc3NlZD09PXVuZGVmaW5lZCljb21wcmVzc2VkPXRoaXMuY29tcHJlc3NlZDtyZXR1cm4gRUNQdWJLZXkoZWNwYXJhbXMuZ2V0RygpLm11bHRpcGx5KHRoaXMucHJpdiksY29tcHJlc3NlZCl9O0VDS2V5LnByb3RvdHlwZS50b0Jpbj1mdW5jdGlvbigpe3JldHVybiBjb252ZXJ0LmJ5dGVzVG9TdHJpbmcodGhpcy50b0J5dGVzKCkpfTtFQ0tleS52ZXJzaW9uX2J5dGVzPXswOjEyOCwxMTE6MjM5fTtFQ0tleS5wcm90b3R5cGUudG9XaWY9ZnVuY3Rpb24odmVyc2lvbil7dmVyc2lvbj12ZXJzaW9ufHxOZXR3b3JrLm1haW5uZXQuYWRkcmVzc1ZlcnNpb247cmV0dXJuIGJhc2U1OGNoZWNrLmVuY29kZSh0aGlzLnRvQnl0ZXMoKSxFQ0tleS52ZXJzaW9uX2J5dGVzW3ZlcnNpb25dKX07RUNLZXkucHJvdG90eXBlLnRvSGV4PWZ1bmN0aW9uKCl7cmV0dXJuIGNvbnZlcnQuYnl0ZXNUb0hleCh0aGlzLnRvQnl0ZXMoKSl9O0VDS2V5LnByb3RvdHlwZS50b0J5dGVzPWZ1bmN0aW9uKCl7dmFyIGJ5dGVzPXRoaXMucHJpdi50b0J5dGVBcnJheVVuc2lnbmVkKCk7aWYodGhpcy5jb21wcmVzc2VkKWJ5dGVzLnB1c2goMSk7cmV0dXJuIGJ5dGVzfTtFQ0tleS5wcm90b3R5cGUudG9CYXNlNjQ9ZnVuY3Rpb24oKXtyZXR1cm4gY29udmVydC5ieXRlc1RvQmFzZTY0KHRoaXMudG9CeXRlcygpKX07RUNLZXkucHJvdG90eXBlLnRvU3RyaW5nPUVDS2V5LnByb3RvdHlwZS50b0hleDtFQ0tleS5wcm90b3R5cGUuZ2V0QWRkcmVzcz1mdW5jdGlvbih2ZXJzaW9uKXtyZXR1cm4gdGhpcy5nZXRQdWIoKS5nZXRBZGRyZXNzKHZlcnNpb24pfTtFQ0tleS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGtleSl7cmV0dXJuIEVDS2V5KHRoaXMucHJpdi5hZGQoRUNLZXkoa2V5KS5wcml2KSx0aGlzLmNvbXByZXNzZWQpfTtFQ0tleS5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24oa2V5KXtyZXR1cm4gRUNLZXkodGhpcy5wcml2Lm11bHRpcGx5KEVDS2V5KGtleSkucHJpdiksdGhpcy5jb21wcmVzc2VkKX07RUNLZXkucHJvdG90eXBlLnNpZ249ZnVuY3Rpb24oaGFzaCl7cmV0dXJuIGVjZHNhLnNpZ24oaGFzaCx0aGlzLnByaXYpfTtFQ0tleS5wcm90b3R5cGUudmVyaWZ5PWZ1bmN0aW9uKGhhc2gsc2lnKXtyZXR1cm4gdGhpcy5nZXRQdWIoKS52ZXJpZnkoaGFzaCxzaWcpfTt2YXIgRUNQdWJLZXk9ZnVuY3Rpb24oaW5wdXQsY29tcHJlc3NlZCl7aWYoISh0aGlzIGluc3RhbmNlb2YgRUNQdWJLZXkpKXtyZXR1cm4gbmV3IEVDUHViS2V5KGlucHV0LGNvbXByZXNzZWQpfXRoaXMuaW1wb3J0KGlucHV0LGNvbXByZXNzZWQpfTtFQ1B1YktleS5wcm90b3R5cGUuaW1wb3J0PWZ1bmN0aW9uKGlucHV0LGNvbXByZXNzZWQpe3ZhciBkZWNvZGU9ZnVuY3Rpb24oeCl7cmV0dXJuIEVDUG9pbnRGcC5kZWNvZGVGcm9tKGVjcGFyYW1zLmdldEN1cnZlKCkseCl9O3RoaXMucHViPWlucHV0IGluc3RhbmNlb2YgRUNQb2ludEZwP2lucHV0OmlucHV0IGluc3RhbmNlb2YgRUNLZXk/ZWNwYXJhbXMuZ2V0RygpLm11bHRpcGx5KGlucHV0LnByaXYpOmlucHV0IGluc3RhbmNlb2YgRUNQdWJLZXk/aW5wdXQucHViOnR5cGVvZiBpbnB1dD09XCJzdHJpbmdcIj9kZWNvZGUoY29udmVydC5oZXhUb0J5dGVzKGlucHV0KSk6QXJyYXkuaXNBcnJheShpbnB1dCk/ZGVjb2RlKGlucHV0KTpudWxsO2Fzc2VydCh0aGlzLnB1YiE9PW51bGwpO3RoaXMuY29tcHJlc3NlZD1jb21wcmVzc2VkP2NvbXByZXNzZWQ6aW5wdXQgaW5zdGFuY2VvZiBFQ1BvaW50RnA/aW5wdXQuY29tcHJlc3NlZDppbnB1dCBpbnN0YW5jZW9mIEVDUHViS2V5P2lucHV0LmNvbXByZXNzZWQ6dGhpcy5wdWJbMF08NH07RUNQdWJLZXkucHJvdG90eXBlLmFkZD1mdW5jdGlvbihrZXkpe3JldHVybiBFQ1B1YktleSh0aGlzLnB1Yi5hZGQoRUNQdWJLZXkoa2V5KS5wdWIpLHRoaXMuY29tcHJlc3NlZCl9O0VDUHViS2V5LnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbihrZXkpe3JldHVybiBFQ1B1YktleSh0aGlzLnB1Yi5tdWx0aXBseShFQ0tleShrZXkpLnByaXYpLHRoaXMuY29tcHJlc3NlZCl9O0VDUHViS2V5LnByb3RvdHlwZS50b0J5dGVzPWZ1bmN0aW9uKGNvbXByZXNzZWQpe2lmKGNvbXByZXNzZWQ9PT11bmRlZmluZWQpY29tcHJlc3NlZD10aGlzLmNvbXByZXNzZWQ7cmV0dXJuIHRoaXMucHViLmdldEVuY29kZWQoY29tcHJlc3NlZCl9O0VDUHViS2V5LnByb3RvdHlwZS50b0hleD1mdW5jdGlvbihjb21wcmVzc2VkKXtyZXR1cm4gY29udmVydC5ieXRlc1RvSGV4KHRoaXMudG9CeXRlcyhjb21wcmVzc2VkKSl9O0VDUHViS2V5LnByb3RvdHlwZS50b0Jpbj1mdW5jdGlvbihjb21wcmVzc2VkKXtyZXR1cm4gY29udmVydC5ieXRlc1RvU3RyaW5nKHRoaXMudG9CeXRlcyhjb21wcmVzc2VkKSl9O0VDUHViS2V5LnByb3RvdHlwZS50b1dpZj1mdW5jdGlvbih2ZXJzaW9uKXt2ZXJzaW9uPXZlcnNpb258fE5ldHdvcmsubWFpbm5ldC5hZGRyZXNzVmVyc2lvbjtyZXR1cm4gYmFzZTU4Y2hlY2suZW5jb2RlKHRoaXMudG9CeXRlcygpLHZlcnNpb24pfTtFQ1B1YktleS5wcm90b3R5cGUudG9TdHJpbmc9RUNQdWJLZXkucHJvdG90eXBlLnRvSGV4O0VDUHViS2V5LnByb3RvdHlwZS5nZXRBZGRyZXNzPWZ1bmN0aW9uKHZlcnNpb24pe3ZlcnNpb249dmVyc2lvbnx8TmV0d29yay5tYWlubmV0LmFkZHJlc3NWZXJzaW9uO3JldHVybiBuZXcgQWRkcmVzcyh1dGlsLnNoYTI1NnJpcGUxNjAodGhpcy50b0J5dGVzKCkpLHZlcnNpb24pfTtFQ1B1YktleS5wcm90b3R5cGUudmVyaWZ5PWZ1bmN0aW9uKGhhc2gsc2lnKXtyZXR1cm4gZWNkc2EudmVyaWZ5KGhhc2gsc2lnLHRoaXMudG9CeXRlcygpKX07bW9kdWxlLmV4cG9ydHM9e0VDS2V5OkVDS2V5LEVDUHViS2V5OkVDUHViS2V5fX0se1wiLi9hZGRyZXNzXCI6NTQsXCIuL2Jhc2U1OGNoZWNrXCI6NTYsXCIuL2NvbnZlcnRcIjo1NyxcIi4vZWNkc2FcIjo1OCxcIi4vanNibi9lY1wiOjYyLFwiLi9qc2JuL2pzYm5cIjo2MyxcIi4vanNibi9zZWNcIjo2NCxcIi4vbmV0d29ya1wiOjY2LFwiLi91dGlsXCI6NzAsYXNzZXJ0OjF9XSw2MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKEJ1ZmZlcil7dmFyIGNvbnZlcnQ9X2RlcmVxXyhcIi4vY29udmVydC5qc1wiKTt2YXIgYmFzZTU4PV9kZXJlcV8oXCIuL2Jhc2U1OC5qc1wiKTt2YXIgYXNzZXJ0PV9kZXJlcV8oXCJhc3NlcnRcIik7dmFyIGZvcm1hdD1fZGVyZXFfKFwidXRpbFwiKS5mb3JtYXQ7dmFyIHV0aWw9X2RlcmVxXyhcIi4vdXRpbC5qc1wiKTt2YXIgQ3J5cHRvPV9kZXJlcV8oXCJjcnlwdG8tanNcIik7dmFyIEhtYWNTSEE1MTI9Q3J5cHRvLkhtYWNTSEE1MTI7dmFyIEhNQUM9Q3J5cHRvLmFsZ28uSE1BQzt2YXIgRUNLZXk9X2RlcmVxXyhcIi4vZWNrZXkuanNcIikuRUNLZXk7dmFyIEVDUHViS2V5PV9kZXJlcV8oXCIuL2Vja2V5LmpzXCIpLkVDUHViS2V5O3ZhciBBZGRyZXNzPV9kZXJlcV8oXCIuL2FkZHJlc3MuanNcIik7dmFyIE5ldHdvcms9X2RlcmVxXyhcIi4vbmV0d29ya1wiKTt2YXIgY3J5cHRvPV9kZXJlcV8oXCJjcnlwdG9cIik7ZnVuY3Rpb24gc2hhMjU2KGJ1Zil7dmFyIGhhc2g9Y3J5cHRvLmNyZWF0ZUhhc2goXCJzaGEyNTZcIik7aGFzaC51cGRhdGUoYnVmKTtyZXR1cm4gaGFzaC5kaWdlc3QoKX1mdW5jdGlvbiBIRFdhbGxldChzZWVkLG5ldHdvcmspe2lmKHNlZWQ9PT11bmRlZmluZWQpcmV0dXJuO3ZhciBzZWVkV29yZHM9Y29udmVydC5ieXRlc1RvV29yZEFycmF5KHNlZWQpO3ZhciBJPWNvbnZlcnQud29yZEFycmF5VG9CeXRlcyhIbWFjU0hBNTEyKHNlZWRXb3JkcyxcIkJpdGNvaW4gc2VlZFwiKSk7dGhpcy5jaGFpbmNvZGU9SS5zbGljZSgzMik7dGhpcy5uZXR3b3JrPW5ldHdvcmt8fFwibWFpbm5ldFwiO2lmKCFOZXR3b3JrLmhhc093blByb3BlcnR5KHRoaXMubmV0d29yaykpe3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gbmV0d29yazogXCIrdGhpcy5uZXR3b3JrKX10aGlzLnByaXY9bmV3IEVDS2V5KEkuc2xpY2UoMCwzMikuY29uY2F0KFsxXSksdHJ1ZSk7dGhpcy5wdWI9dGhpcy5wcml2LmdldFB1YigpO3RoaXMuaW5kZXg9MDt0aGlzLmRlcHRoPTB9SERXYWxsZXQuSElHSEVTVF9CSVQ9MjE0NzQ4MzY0ODtIRFdhbGxldC5MRU5HVEg9Nzg7ZnVuY3Rpb24gYXJyYXlFcXVhbChhLGIpe3JldHVybiEoYTxifHxhPmIpfUhEV2FsbGV0LmZyb21TZWVkSGV4PWZ1bmN0aW9uKGhleCxuZXR3b3JrKXtyZXR1cm4gbmV3IEhEV2FsbGV0KGNvbnZlcnQuaGV4VG9CeXRlcyhoZXgpLG5ldHdvcmspfTtIRFdhbGxldC5mcm9tU2VlZFN0cmluZz1mdW5jdGlvbihzdHJpbmcsbmV0d29yayl7cmV0dXJuIG5ldyBIRFdhbGxldChjb252ZXJ0LnN0cmluZ1RvQnl0ZXMoc3RyaW5nKSxuZXR3b3JrKX07SERXYWxsZXQuZnJvbUJhc2U1OD1mdW5jdGlvbihzdHJpbmcpe3ZhciBidWZmZXI9YmFzZTU4LmRlY29kZShzdHJpbmcpO3ZhciBwYXlsb2FkPWJ1ZmZlci5zbGljZSgwLC00KTt2YXIgY2hlY2tzdW09YnVmZmVyLnNsaWNlKC00KTt2YXIgbmV3Q2hlY2tzdW09c2hhMjU2KHNoYTI1NihwYXlsb2FkKSkuc2xpY2UoMCw0KTthc3NlcnQuZGVlcEVxdWFsKG5ld0NoZWNrc3VtLGNoZWNrc3VtKTthc3NlcnQuZXF1YWwocGF5bG9hZC5sZW5ndGgsSERXYWxsZXQuTEVOR1RIKTtyZXR1cm4gSERXYWxsZXQuZnJvbUJ5dGVzKHBheWxvYWQpfTtIRFdhbGxldC5mcm9tSGV4PWZ1bmN0aW9uKGlucHV0KXtyZXR1cm4gSERXYWxsZXQuZnJvbUJ5dGVzKGNvbnZlcnQuaGV4VG9CeXRlcyhpbnB1dCkpfTtIRFdhbGxldC5mcm9tQnl0ZXM9ZnVuY3Rpb24oaW5wdXQpe2lmKGlucHV0Lmxlbmd0aCE9SERXYWxsZXQuTEVOR1RIKXt0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KFwiSW52YWxpZCBpbnB1dCBsZW5ndGgsICVzLiBFeHBlY3RlZCAlcy5cIixpbnB1dC5sZW5ndGgsSERXYWxsZXQuTEVOR1RIKSl9aWYoQnVmZmVyLmlzQnVmZmVyKGlucHV0KSl7aW5wdXQ9QXJyYXkucHJvdG90eXBlLm1hcC5iaW5kKGlucHV0LGZ1bmN0aW9uKHgpe3JldHVybiB4fSkoKX12YXIgaGQ9bmV3IEhEV2FsbGV0O3ZhciB2ZXJzaW9uQnl0ZXM9aW5wdXQuc2xpY2UoMCw0KTt2YXIgdmVyc2lvbldvcmQ9Y29udmVydC5ieXRlc1RvV29yZHModmVyc2lvbkJ5dGVzKVswXTt2YXIgdHlwZTtmb3IodmFyIG5hbWUgaW4gTmV0d29yayl7dmFyIG5ldHdvcms9TmV0d29ya1tuYW1lXTtmb3IodmFyIHQgaW4gbmV0d29yay5oZFZlcnNpb25zKXtpZih2ZXJzaW9uV29yZCE9bmV0d29yay5oZFZlcnNpb25zW3RdKWNvbnRpbnVlO3R5cGU9dDtoZC5uZXR3b3JrPW5hbWV9fWlmKCFoZC5uZXR3b3JrKXt0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KFwiQ291bGQgbm90IGZpbmQgdmVyc2lvbiAlc1wiLGNvbnZlcnQuYnl0ZXNUb0hleCh2ZXJzaW9uQnl0ZXMpKSl9aGQuZGVwdGg9aW5wdXRbNF07aGQucGFyZW50RmluZ2VycHJpbnQ9aW5wdXQuc2xpY2UoNSw5KTthc3NlcnQoaGQuZGVwdGg9PT0wPT1hcnJheUVxdWFsKGhkLnBhcmVudEZpbmdlcnByaW50LFswLDAsMCwwXSkpO2hkLmluZGV4PWNvbnZlcnQuYnl0ZXNUb051bShpbnB1dC5zbGljZSg5LDEzKS5yZXZlcnNlKCkpO2Fzc2VydChoZC5kZXB0aD4wfHxoZC5pbmRleD09PTApO2hkLmNoYWluY29kZT1pbnB1dC5zbGljZSgxMyw0NSk7aWYodHlwZT09XCJwcml2XCIpe2hkLnByaXY9bmV3IEVDS2V5KGlucHV0LnNsaWNlKDQ2LDc4KS5jb25jYXQoWzFdKSx0cnVlKTtoZC5wdWI9aGQucHJpdi5nZXRQdWIoKX1lbHNle2hkLnB1Yj1uZXcgRUNQdWJLZXkoaW5wdXQuc2xpY2UoNDUsNzgpLHRydWUpfXJldHVybiBoZH07SERXYWxsZXQucHJvdG90eXBlLmdldElkZW50aWZpZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdXRpbC5zaGEyNTZyaXBlMTYwKHRoaXMucHViLnRvQnl0ZXMoKSl9O0hEV2FsbGV0LnByb3RvdHlwZS5nZXRGaW5nZXJwcmludD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldElkZW50aWZpZXIoKS5zbGljZSgwLDQpfTtIRFdhbGxldC5wcm90b3R5cGUuZ2V0QWRkcmVzcz1mdW5jdGlvbigpe3JldHVybiBuZXcgQWRkcmVzcyh1dGlsLnNoYTI1NnJpcGUxNjAodGhpcy5wdWIudG9CeXRlcygpKSx0aGlzLmdldEtleVZlcnNpb24oKSl9O0hEV2FsbGV0LnByb3RvdHlwZS50b0J5dGVzPWZ1bmN0aW9uKHByaXYpe3ZhciBidWZmZXI9W107dmFyIHZlcnNpb249TmV0d29ya1t0aGlzLm5ldHdvcmtdLmhkVmVyc2lvbnNbcHJpdj9cInByaXZcIjpcInB1YlwiXTt2YXIgdkJ5dGVzPWNvbnZlcnQud29yZHNUb0J5dGVzKFt2ZXJzaW9uXSk7YnVmZmVyPWJ1ZmZlci5jb25jYXQodkJ5dGVzKTthc3NlcnQuZXF1YWwoYnVmZmVyLmxlbmd0aCw0KTtidWZmZXIucHVzaCh0aGlzLmRlcHRoKTthc3NlcnQuZXF1YWwoYnVmZmVyLmxlbmd0aCw0KzEpO2J1ZmZlcj1idWZmZXIuY29uY2F0KHRoaXMuZGVwdGg/dGhpcy5wYXJlbnRGaW5nZXJwcmludDpbMCwwLDAsMF0pO2Fzc2VydC5lcXVhbChidWZmZXIubGVuZ3RoLDQrMSs0KTtidWZmZXI9YnVmZmVyLmNvbmNhdChjb252ZXJ0Lm51bVRvQnl0ZXModGhpcy5pbmRleCw0KS5yZXZlcnNlKCkpO2Fzc2VydC5lcXVhbChidWZmZXIubGVuZ3RoLDQrMSs0KzQpO2J1ZmZlcj1idWZmZXIuY29uY2F0KHRoaXMuY2hhaW5jb2RlKTthc3NlcnQuZXF1YWwoYnVmZmVyLmxlbmd0aCw0KzErNCs0KzMyKTtpZihwcml2KXthc3NlcnQodGhpcy5wcml2LFwiQ2Fubm90IHNlcmlhbGl6ZSB0byBwcml2YXRlIHdpdGhvdXQgcHJpdmF0ZSBrZXlcIik7YnVmZmVyLnB1c2goMCk7YnVmZmVyPWJ1ZmZlci5jb25jYXQodGhpcy5wcml2LnRvQnl0ZXMoKS5zbGljZSgwLDMyKSl9ZWxzZXtidWZmZXI9YnVmZmVyLmNvbmNhdCh0aGlzLnB1Yi50b0J5dGVzKHRydWUpKX1yZXR1cm4gYnVmZmVyfTtIRFdhbGxldC5wcm90b3R5cGUudG9IZXg9ZnVuY3Rpb24ocHJpdil7dmFyIGJ5dGVzPXRoaXMudG9CeXRlcyhwcml2KTtyZXR1cm4gY29udmVydC5ieXRlc1RvSGV4KGJ5dGVzKX07SERXYWxsZXQucHJvdG90eXBlLnRvQmFzZTU4PWZ1bmN0aW9uKHByaXYpe3ZhciBidWZmZXI9bmV3IEJ1ZmZlcih0aGlzLnRvQnl0ZXMocHJpdikpO3ZhciBjaGVja3N1bT1zaGEyNTYoc2hhMjU2KGJ1ZmZlcikpLnNsaWNlKDAsNCk7cmV0dXJuIGJhc2U1OC5lbmNvZGUoQnVmZmVyLmNvbmNhdChbYnVmZmVyLGNoZWNrc3VtXSkpfTtIRFdhbGxldC5wcm90b3R5cGUuZGVyaXZlPWZ1bmN0aW9uKGkpe3ZhciBJLGlCeXRlcz1jb252ZXJ0Lm51bVRvQnl0ZXMoaSw0KS5yZXZlcnNlKCksY1Bhcj10aGlzLmNoYWluY29kZSx1c2VQcml2PWk+PUhEV2FsbGV0LkhJR0hFU1RfQklULFNIQTUxMj1DcnlwdG8uYWxnby5TSEE1MTI7aWYodXNlUHJpdil7YXNzZXJ0KHRoaXMucHJpdixcIlByaXZhdGUgZGVyaXZlIG9uIHB1YmxpYyBrZXlcIik7dmFyIGtQYXI9dGhpcy5wcml2LnRvQnl0ZXMoKS5zbGljZSgwLDMyKTtJPUhtYWNGcm9tQnl0ZXNUb0J5dGVzKFNIQTUxMixbMF0uY29uY2F0KGtQYXIsaUJ5dGVzKSxjUGFyKX1lbHNle3ZhciBLUGFyPXRoaXMucHViLnRvQnl0ZXModHJ1ZSk7ST1IbWFjRnJvbUJ5dGVzVG9CeXRlcyhTSEE1MTIsS1Bhci5jb25jYXQoaUJ5dGVzKSxjUGFyKX12YXIgSUw9SS5zbGljZSgwLDMyKSxJUj1JLnNsaWNlKDMyKTt2YXIgaGQ9bmV3IEhEV2FsbGV0O2hkLm5ldHdvcms9dGhpcy5uZXR3b3JrO2lmKHRoaXMucHJpdil7aGQucHJpdj10aGlzLnByaXYuYWRkKG5ldyBFQ0tleShJTC5jb25jYXQoWzFdKSkpO2hkLnByaXYuY29tcHJlc3NlZD10cnVlO2hkLnByaXYudmVyc2lvbj10aGlzLmdldEtleVZlcnNpb24oKTtoZC5wdWI9aGQucHJpdi5nZXRQdWIoKX1lbHNle2hkLnB1Yj10aGlzLnB1Yi5hZGQobmV3IEVDS2V5KElMLmNvbmNhdChbMV0pLHRydWUpLmdldFB1YigpKX1oZC5jaGFpbmNvZGU9SVI7aGQucGFyZW50RmluZ2VycHJpbnQ9dGhpcy5nZXRGaW5nZXJwcmludCgpO2hkLmRlcHRoPXRoaXMuZGVwdGgrMTtoZC5pbmRleD1pO2hkLnB1Yi5jb21wcmVzc2VkPXRydWU7cmV0dXJuIGhkfTtIRFdhbGxldC5wcm90b3R5cGUuZGVyaXZlUHJpdmF0ZT1mdW5jdGlvbihpbmRleCl7cmV0dXJuIHRoaXMuZGVyaXZlKGluZGV4K0hEV2FsbGV0LkhJR0hFU1RfQklUKX07SERXYWxsZXQucHJvdG90eXBlLmdldEtleVZlcnNpb249ZnVuY3Rpb24oKXtyZXR1cm4gTmV0d29ya1t0aGlzLm5ldHdvcmtdLmFkZHJlc3NWZXJzaW9ufTtIRFdhbGxldC5wcm90b3R5cGUudG9TdHJpbmc9SERXYWxsZXQucHJvdG90eXBlLnRvQmFzZTU4O2Z1bmN0aW9uIEhtYWNGcm9tQnl0ZXNUb0J5dGVzKGhhc2hlcixtZXNzYWdlLGtleSl7dmFyIGhtYWM9SE1BQy5jcmVhdGUoaGFzaGVyLGNvbnZlcnQuYnl0ZXNUb1dvcmRBcnJheShrZXkpKTtobWFjLnVwZGF0ZShjb252ZXJ0LmJ5dGVzVG9Xb3JkQXJyYXkobWVzc2FnZSkpO3JldHVybiBjb252ZXJ0LndvcmRBcnJheVRvQnl0ZXMoaG1hYy5maW5hbGl6ZSgpKX1tb2R1bGUuZXhwb3J0cz1IRFdhbGxldH0pLmNhbGwodGhpcyxfZGVyZXFfKFwiYnVmZmVyXCIpLkJ1ZmZlcil9LHtcIi4vYWRkcmVzcy5qc1wiOjU0LFwiLi9iYXNlNTguanNcIjo1NSxcIi4vY29udmVydC5qc1wiOjU3LFwiLi9lY2tleS5qc1wiOjU5LFwiLi9uZXR3b3JrXCI6NjYsXCIuL3V0aWwuanNcIjo3MCxhc3NlcnQ6MSxidWZmZXI6NSxjcnlwdG86OSxcImNyeXB0by1qc1wiOjI3LHV0aWw6MTd9XSw2MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIEtleT1fZGVyZXFfKFwiLi9lY2tleVwiKTt2YXIgVD1fZGVyZXFfKFwiLi90cmFuc2FjdGlvblwiKTttb2R1bGUuZXhwb3J0cz17QWRkcmVzczpfZGVyZXFfKFwiLi9hZGRyZXNzXCIpLEtleTpLZXkuRUNLZXksRUNLZXk6S2V5LkVDS2V5LEVDUHViS2V5OktleS5FQ1B1YktleSxNZXNzYWdlOl9kZXJlcV8oXCIuL21lc3NhZ2VcIiksQmlnSW50ZWdlcjpfZGVyZXFfKFwiLi9qc2JuL2pzYm5cIiksQ3J5cHRvOl9kZXJlcV8oXCJjcnlwdG8tanNcIiksU2NyaXB0Ol9kZXJlcV8oXCIuL3NjcmlwdFwiKSxPcGNvZGU6X2RlcmVxXyhcIi4vb3Bjb2RlXCIpLFRyYW5zYWN0aW9uOlQuVHJhbnNhY3Rpb24sVXRpbDpfZGVyZXFfKFwiLi91dGlsXCIpLFRyYW5zYWN0aW9uSW46VC5UcmFuc2FjdGlvbkluLFRyYW5zYWN0aW9uT3V0OlQuVHJhbnNhY3Rpb25PdXQsRUNQb2ludEZwOl9kZXJlcV8oXCIuL2pzYm4vZWNcIikuRUNQb2ludEZwLFdhbGxldDpfZGVyZXFfKFwiLi93YWxsZXRcIiksbmV0d29yazpfZGVyZXFfKFwiLi9uZXR3b3JrXCIpLGVjZHNhOl9kZXJlcV8oXCIuL2VjZHNhXCIpLEhEV2FsbGV0Ol9kZXJlcV8oXCIuL2hkd2FsbGV0LmpzXCIpLGJhc2U1ODpfZGVyZXFfKFwiLi9iYXNlNThcIiksYmFzZTU4Y2hlY2s6X2RlcmVxXyhcIi4vYmFzZTU4Y2hlY2tcIiksY29udmVydDpfZGVyZXFfKFwiLi9jb252ZXJ0XCIpfX0se1wiLi9hZGRyZXNzXCI6NTQsXCIuL2Jhc2U1OFwiOjU1LFwiLi9iYXNlNThjaGVja1wiOjU2LFwiLi9jb252ZXJ0XCI6NTcsXCIuL2VjZHNhXCI6NTgsXCIuL2Vja2V5XCI6NTksXCIuL2hkd2FsbGV0LmpzXCI6NjAsXCIuL2pzYm4vZWNcIjo2MixcIi4vanNibi9qc2JuXCI6NjMsXCIuL21lc3NhZ2VcIjo2NSxcIi4vbmV0d29ya1wiOjY2LFwiLi9vcGNvZGVcIjo2NyxcIi4vc2NyaXB0XCI6NjgsXCIuL3RyYW5zYWN0aW9uXCI6NjksXCIuL3V0aWxcIjo3MCxcIi4vd2FsbGV0XCI6NzEsXCJjcnlwdG8tanNcIjoyN31dLDYyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgQmlnSW50ZWdlcj1fZGVyZXFfKFwiLi9qc2JuXCIpLHNlYz1fZGVyZXFfKFwiLi9zZWNcIik7ZnVuY3Rpb24gRUNGaWVsZEVsZW1lbnRGcChxLHgpe3RoaXMueD14O3RoaXMucT1xfWZ1bmN0aW9uIGZlRnBFcXVhbHMob3RoZXIpe2lmKG90aGVyPT10aGlzKXJldHVybiB0cnVlO3JldHVybiB0aGlzLnEuZXF1YWxzKG90aGVyLnEpJiZ0aGlzLnguZXF1YWxzKG90aGVyLngpfWZ1bmN0aW9uIGZlRnBUb0JpZ0ludGVnZXIoKXtyZXR1cm4gdGhpcy54fWZ1bmN0aW9uIGZlRnBOZWdhdGUoKXtyZXR1cm4gbmV3IEVDRmllbGRFbGVtZW50RnAodGhpcy5xLHRoaXMueC5uZWdhdGUoKS5tb2QodGhpcy5xKSl9ZnVuY3Rpb24gZmVGcEFkZChiKXtyZXR1cm4gbmV3IEVDRmllbGRFbGVtZW50RnAodGhpcy5xLHRoaXMueC5hZGQoYi50b0JpZ0ludGVnZXIoKSkubW9kKHRoaXMucSkpfWZ1bmN0aW9uIGZlRnBTdWJ0cmFjdChiKXtyZXR1cm4gbmV3IEVDRmllbGRFbGVtZW50RnAodGhpcy5xLHRoaXMueC5zdWJ0cmFjdChiLnRvQmlnSW50ZWdlcigpKS5tb2QodGhpcy5xKSl9ZnVuY3Rpb24gZmVGcE11bHRpcGx5KGIpe3JldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcCh0aGlzLnEsdGhpcy54Lm11bHRpcGx5KGIudG9CaWdJbnRlZ2VyKCkpLm1vZCh0aGlzLnEpKX1mdW5jdGlvbiBmZUZwU3F1YXJlKCl7cmV0dXJuIG5ldyBFQ0ZpZWxkRWxlbWVudEZwKHRoaXMucSx0aGlzLnguc3F1YXJlKCkubW9kKHRoaXMucSkpfWZ1bmN0aW9uIGZlRnBEaXZpZGUoYil7cmV0dXJuIG5ldyBFQ0ZpZWxkRWxlbWVudEZwKHRoaXMucSx0aGlzLngubXVsdGlwbHkoYi50b0JpZ0ludGVnZXIoKS5tb2RJbnZlcnNlKHRoaXMucSkpLm1vZCh0aGlzLnEpKX1FQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5lcXVhbHM9ZmVGcEVxdWFscztFQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS50b0JpZ0ludGVnZXI9ZmVGcFRvQmlnSW50ZWdlcjtFQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5uZWdhdGU9ZmVGcE5lZ2F0ZTtFQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5hZGQ9ZmVGcEFkZDtFQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5zdWJ0cmFjdD1mZUZwU3VidHJhY3Q7RUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUubXVsdGlwbHk9ZmVGcE11bHRpcGx5O0VDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLnNxdWFyZT1mZUZwU3F1YXJlO0VDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLmRpdmlkZT1mZUZwRGl2aWRlO2Z1bmN0aW9uIEVDUG9pbnRGcChjdXJ2ZSx4LHkseil7dGhpcy5jdXJ2ZT1jdXJ2ZTt0aGlzLng9eDt0aGlzLnk9eTtpZih6PT1udWxsKXt0aGlzLno9QmlnSW50ZWdlci5PTkV9ZWxzZXt0aGlzLno9en10aGlzLnppbnY9bnVsbH1mdW5jdGlvbiBwb2ludEZwR2V0WCgpe2lmKHRoaXMuemludj09bnVsbCl7dGhpcy56aW52PXRoaXMuei5tb2RJbnZlcnNlKHRoaXMuY3VydmUucSl9cmV0dXJuIHRoaXMuY3VydmUuZnJvbUJpZ0ludGVnZXIodGhpcy54LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KHRoaXMuemludikubW9kKHRoaXMuY3VydmUucSkpfWZ1bmN0aW9uIHBvaW50RnBHZXRZKCl7aWYodGhpcy56aW52PT1udWxsKXt0aGlzLnppbnY9dGhpcy56Lm1vZEludmVyc2UodGhpcy5jdXJ2ZS5xKX1yZXR1cm4gdGhpcy5jdXJ2ZS5mcm9tQmlnSW50ZWdlcih0aGlzLnkudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkodGhpcy56aW52KS5tb2QodGhpcy5jdXJ2ZS5xKSl9ZnVuY3Rpb24gcG9pbnRGcEVxdWFscyhvdGhlcil7aWYob3RoZXI9PXRoaXMpcmV0dXJuIHRydWU7aWYodGhpcy5pc0luZmluaXR5KCkpcmV0dXJuIG90aGVyLmlzSW5maW5pdHkoKTtpZihvdGhlci5pc0luZmluaXR5KCkpcmV0dXJuIHRoaXMuaXNJbmZpbml0eSgpO3ZhciB1LHY7dT1vdGhlci55LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QodGhpcy55LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KG90aGVyLnopKS5tb2QodGhpcy5jdXJ2ZS5xKTtpZighdS5lcXVhbHMoQmlnSW50ZWdlci5aRVJPKSlyZXR1cm4gZmFsc2U7dj1vdGhlci54LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QodGhpcy54LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KG90aGVyLnopKS5tb2QodGhpcy5jdXJ2ZS5xKTtyZXR1cm4gdi5lcXVhbHMoQmlnSW50ZWdlci5aRVJPKX1mdW5jdGlvbiBwb2ludEZwSXNJbmZpbml0eSgpe2lmKHRoaXMueD09bnVsbCYmdGhpcy55PT1udWxsKXJldHVybiB0cnVlO3JldHVybiB0aGlzLnouZXF1YWxzKEJpZ0ludGVnZXIuWkVSTykmJiF0aGlzLnkudG9CaWdJbnRlZ2VyKCkuZXF1YWxzKEJpZ0ludGVnZXIuWkVSTyl9ZnVuY3Rpb24gcG9pbnRGcE5lZ2F0ZSgpe3JldHVybiBuZXcgRUNQb2ludEZwKHRoaXMuY3VydmUsdGhpcy54LHRoaXMueS5uZWdhdGUoKSx0aGlzLnopfWZ1bmN0aW9uIHBvaW50RnBBZGQoYil7aWYodGhpcy5pc0luZmluaXR5KCkpcmV0dXJuIGI7aWYoYi5pc0luZmluaXR5KCkpcmV0dXJuIHRoaXM7dmFyIHU9Yi55LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QodGhpcy55LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KGIueikpLm1vZCh0aGlzLmN1cnZlLnEpO3ZhciB2PWIueC50b0JpZ0ludGVnZXIoKS5tdWx0aXBseSh0aGlzLnopLnN1YnRyYWN0KHRoaXMueC50b0JpZ0ludGVnZXIoKS5tdWx0aXBseShiLnopKS5tb2QodGhpcy5jdXJ2ZS5xKTtpZihCaWdJbnRlZ2VyLlpFUk8uZXF1YWxzKHYpKXtpZihCaWdJbnRlZ2VyLlpFUk8uZXF1YWxzKHUpKXtyZXR1cm4gdGhpcy50d2ljZSgpfXJldHVybiB0aGlzLmN1cnZlLmdldEluZmluaXR5KCl9dmFyIFRIUkVFPW5ldyBCaWdJbnRlZ2VyKFwiM1wiKTt2YXIgeDE9dGhpcy54LnRvQmlnSW50ZWdlcigpO3ZhciB5MT10aGlzLnkudG9CaWdJbnRlZ2VyKCk7dmFyIHgyPWIueC50b0JpZ0ludGVnZXIoKTt2YXIgeTI9Yi55LnRvQmlnSW50ZWdlcigpO3ZhciB2Mj12LnNxdWFyZSgpO3ZhciB2Mz12Mi5tdWx0aXBseSh2KTt2YXIgeDF2Mj14MS5tdWx0aXBseSh2Mik7dmFyIHp1Mj11LnNxdWFyZSgpLm11bHRpcGx5KHRoaXMueik7dmFyIHgzPXp1Mi5zdWJ0cmFjdCh4MXYyLnNoaWZ0TGVmdCgxKSkubXVsdGlwbHkoYi56KS5zdWJ0cmFjdCh2MykubXVsdGlwbHkodikubW9kKHRoaXMuY3VydmUucSk7dmFyIHkzPXgxdjIubXVsdGlwbHkoVEhSRUUpLm11bHRpcGx5KHUpLnN1YnRyYWN0KHkxLm11bHRpcGx5KHYzKSkuc3VidHJhY3QoenUyLm11bHRpcGx5KHUpKS5tdWx0aXBseShiLnopLmFkZCh1Lm11bHRpcGx5KHYzKSkubW9kKHRoaXMuY3VydmUucSk7dmFyIHozPXYzLm11bHRpcGx5KHRoaXMueikubXVsdGlwbHkoYi56KS5tb2QodGhpcy5jdXJ2ZS5xKTtyZXR1cm4gbmV3IEVDUG9pbnRGcCh0aGlzLmN1cnZlLHRoaXMuY3VydmUuZnJvbUJpZ0ludGVnZXIoeDMpLHRoaXMuY3VydmUuZnJvbUJpZ0ludGVnZXIoeTMpLHozKX1mdW5jdGlvbiBwb2ludEZwVHdpY2UoKXtpZih0aGlzLmlzSW5maW5pdHkoKSlyZXR1cm4gdGhpcztpZih0aGlzLnkudG9CaWdJbnRlZ2VyKCkuc2lnbnVtKCk9PTApcmV0dXJuIHRoaXMuY3VydmUuZ2V0SW5maW5pdHkoKTt2YXIgVEhSRUU9bmV3IEJpZ0ludGVnZXIoXCIzXCIpO3ZhciB4MT10aGlzLngudG9CaWdJbnRlZ2VyKCk7dmFyIHkxPXRoaXMueS50b0JpZ0ludGVnZXIoKTt2YXIgeTF6MT15MS5tdWx0aXBseSh0aGlzLnopO3ZhciB5MXNxejE9eTF6MS5tdWx0aXBseSh5MSkubW9kKHRoaXMuY3VydmUucSk7dmFyIGE9dGhpcy5jdXJ2ZS5hLnRvQmlnSW50ZWdlcigpO1xudmFyIHc9eDEuc3F1YXJlKCkubXVsdGlwbHkoVEhSRUUpO2lmKCFCaWdJbnRlZ2VyLlpFUk8uZXF1YWxzKGEpKXt3PXcuYWRkKHRoaXMuei5zcXVhcmUoKS5tdWx0aXBseShhKSl9dz13Lm1vZCh0aGlzLmN1cnZlLnEpO3ZhciB4Mz13LnNxdWFyZSgpLnN1YnRyYWN0KHgxLnNoaWZ0TGVmdCgzKS5tdWx0aXBseSh5MXNxejEpKS5zaGlmdExlZnQoMSkubXVsdGlwbHkoeTF6MSkubW9kKHRoaXMuY3VydmUucSk7dmFyIHkzPXcubXVsdGlwbHkoVEhSRUUpLm11bHRpcGx5KHgxKS5zdWJ0cmFjdCh5MXNxejEuc2hpZnRMZWZ0KDEpKS5zaGlmdExlZnQoMikubXVsdGlwbHkoeTFzcXoxKS5zdWJ0cmFjdCh3LnNxdWFyZSgpLm11bHRpcGx5KHcpKS5tb2QodGhpcy5jdXJ2ZS5xKTt2YXIgejM9eTF6MS5zcXVhcmUoKS5tdWx0aXBseSh5MXoxKS5zaGlmdExlZnQoMykubW9kKHRoaXMuY3VydmUucSk7cmV0dXJuIG5ldyBFQ1BvaW50RnAodGhpcy5jdXJ2ZSx0aGlzLmN1cnZlLmZyb21CaWdJbnRlZ2VyKHgzKSx0aGlzLmN1cnZlLmZyb21CaWdJbnRlZ2VyKHkzKSx6Myl9ZnVuY3Rpb24gcG9pbnRGcE11bHRpcGx5KGspe2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVybiB0aGlzO2lmKGsuc2lnbnVtKCk9PTApcmV0dXJuIHRoaXMuY3VydmUuZ2V0SW5maW5pdHkoKTt2YXIgZT1rO3ZhciBoPWUubXVsdGlwbHkobmV3IEJpZ0ludGVnZXIoXCIzXCIpKTt2YXIgbmVnPXRoaXMubmVnYXRlKCk7dmFyIFI9dGhpczt2YXIgaTtmb3IoaT1oLmJpdExlbmd0aCgpLTI7aT4wOy0taSl7Uj1SLnR3aWNlKCk7dmFyIGhCaXQ9aC50ZXN0Qml0KGkpO3ZhciBlQml0PWUudGVzdEJpdChpKTtpZihoQml0IT1lQml0KXtSPVIuYWRkKGhCaXQ/dGhpczpuZWcpfX1yZXR1cm4gUn1mdW5jdGlvbiBwb2ludEZwTXVsdGlwbHlUd28oaix4LGspe3ZhciBpO2lmKGouYml0TGVuZ3RoKCk+ay5iaXRMZW5ndGgoKSlpPWouYml0TGVuZ3RoKCktMTtlbHNlIGk9ay5iaXRMZW5ndGgoKS0xO3ZhciBSPXRoaXMuY3VydmUuZ2V0SW5maW5pdHkoKTt2YXIgYm90aD10aGlzLmFkZCh4KTt3aGlsZShpPj0wKXtSPVIudHdpY2UoKTtpZihqLnRlc3RCaXQoaSkpe2lmKGsudGVzdEJpdChpKSl7Uj1SLmFkZChib3RoKX1lbHNle1I9Ui5hZGQodGhpcyl9fWVsc2V7aWYoay50ZXN0Qml0KGkpKXtSPVIuYWRkKHgpfX0tLWl9cmV0dXJuIFJ9RUNQb2ludEZwLnByb3RvdHlwZS5nZXRYPXBvaW50RnBHZXRYO0VDUG9pbnRGcC5wcm90b3R5cGUuZ2V0WT1wb2ludEZwR2V0WTtFQ1BvaW50RnAucHJvdG90eXBlLmVxdWFscz1wb2ludEZwRXF1YWxzO0VDUG9pbnRGcC5wcm90b3R5cGUuaXNJbmZpbml0eT1wb2ludEZwSXNJbmZpbml0eTtFQ1BvaW50RnAucHJvdG90eXBlLm5lZ2F0ZT1wb2ludEZwTmVnYXRlO0VDUG9pbnRGcC5wcm90b3R5cGUuYWRkPXBvaW50RnBBZGQ7RUNQb2ludEZwLnByb3RvdHlwZS50d2ljZT1wb2ludEZwVHdpY2U7RUNQb2ludEZwLnByb3RvdHlwZS5tdWx0aXBseT1wb2ludEZwTXVsdGlwbHk7RUNQb2ludEZwLnByb3RvdHlwZS5tdWx0aXBseVR3bz1wb2ludEZwTXVsdGlwbHlUd287ZnVuY3Rpb24gRUNDdXJ2ZUZwKHEsYSxiKXt0aGlzLnE9cTt0aGlzLmE9dGhpcy5mcm9tQmlnSW50ZWdlcihhKTt0aGlzLmI9dGhpcy5mcm9tQmlnSW50ZWdlcihiKTt0aGlzLmluZmluaXR5PW5ldyBFQ1BvaW50RnAodGhpcyxudWxsLG51bGwpfWZ1bmN0aW9uIGN1cnZlRnBHZXRRKCl7cmV0dXJuIHRoaXMucX1mdW5jdGlvbiBjdXJ2ZUZwR2V0QSgpe3JldHVybiB0aGlzLmF9ZnVuY3Rpb24gY3VydmVGcEdldEIoKXtyZXR1cm4gdGhpcy5ifWZ1bmN0aW9uIGN1cnZlRnBFcXVhbHMob3RoZXIpe2lmKG90aGVyPT10aGlzKXJldHVybiB0cnVlO3JldHVybiB0aGlzLnEuZXF1YWxzKG90aGVyLnEpJiZ0aGlzLmEuZXF1YWxzKG90aGVyLmEpJiZ0aGlzLmIuZXF1YWxzKG90aGVyLmIpfWZ1bmN0aW9uIGN1cnZlRnBHZXRJbmZpbml0eSgpe3JldHVybiB0aGlzLmluZmluaXR5fWZ1bmN0aW9uIGN1cnZlRnBGcm9tQmlnSW50ZWdlcih4KXtyZXR1cm4gbmV3IEVDRmllbGRFbGVtZW50RnAodGhpcy5xLHgpfWZ1bmN0aW9uIGN1cnZlRnBEZWNvZGVQb2ludEhleChzKXtzd2l0Y2gocGFyc2VJbnQocy5zdWJzdHIoMCwyKSwxNikpe2Nhc2UgMDpyZXR1cm4gdGhpcy5pbmZpbml0eTtjYXNlIDI6Y2FzZSAzOnJldHVybiBudWxsO2Nhc2UgNDpjYXNlIDY6Y2FzZSA3OnZhciBsZW49KHMubGVuZ3RoLTIpLzI7dmFyIHhIZXg9cy5zdWJzdHIoMixsZW4pO3ZhciB5SGV4PXMuc3Vic3RyKGxlbisyLGxlbik7cmV0dXJuIG5ldyBFQ1BvaW50RnAodGhpcyx0aGlzLmZyb21CaWdJbnRlZ2VyKG5ldyBCaWdJbnRlZ2VyKHhIZXgsMTYpKSx0aGlzLmZyb21CaWdJbnRlZ2VyKG5ldyBCaWdJbnRlZ2VyKHlIZXgsMTYpKSk7ZGVmYXVsdDpyZXR1cm4gbnVsbH19RUNDdXJ2ZUZwLnByb3RvdHlwZS5nZXRRPWN1cnZlRnBHZXRRO0VDQ3VydmVGcC5wcm90b3R5cGUuZ2V0QT1jdXJ2ZUZwR2V0QTtFQ0N1cnZlRnAucHJvdG90eXBlLmdldEI9Y3VydmVGcEdldEI7RUNDdXJ2ZUZwLnByb3RvdHlwZS5lcXVhbHM9Y3VydmVGcEVxdWFscztFQ0N1cnZlRnAucHJvdG90eXBlLmdldEluZmluaXR5PWN1cnZlRnBHZXRJbmZpbml0eTtFQ0N1cnZlRnAucHJvdG90eXBlLmZyb21CaWdJbnRlZ2VyPWN1cnZlRnBGcm9tQmlnSW50ZWdlcjtFQ0N1cnZlRnAucHJvdG90eXBlLmRlY29kZVBvaW50SGV4PWN1cnZlRnBEZWNvZGVQb2ludEhleDtmdW5jdGlvbiBpbnRlZ2VyVG9CeXRlcyhpLGxlbil7dmFyIGJ5dGVzPWkudG9CeXRlQXJyYXlVbnNpZ25lZCgpO2lmKGxlbjxieXRlcy5sZW5ndGgpe2J5dGVzPWJ5dGVzLnNsaWNlKGJ5dGVzLmxlbmd0aC1sZW4pfWVsc2Ugd2hpbGUobGVuPmJ5dGVzLmxlbmd0aCl7Ynl0ZXMudW5zaGlmdCgwKX1yZXR1cm4gYnl0ZXN9RUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUuZ2V0Qnl0ZUxlbmd0aD1mdW5jdGlvbigpe3JldHVybiBNYXRoLmZsb29yKCh0aGlzLnRvQmlnSW50ZWdlcigpLmJpdExlbmd0aCgpKzcpLzgpfTtFQ1BvaW50RnAucHJvdG90eXBlLmdldEVuY29kZWQ9ZnVuY3Rpb24oY29tcHJlc3NlZCl7dmFyIHg9dGhpcy5nZXRYKCkudG9CaWdJbnRlZ2VyKCk7dmFyIHk9dGhpcy5nZXRZKCkudG9CaWdJbnRlZ2VyKCk7dmFyIGVuYz1pbnRlZ2VyVG9CeXRlcyh4LDMyKTtpZihjb21wcmVzc2VkKXtpZih5LmlzRXZlbigpKXtlbmMudW5zaGlmdCgyKX1lbHNle2VuYy51bnNoaWZ0KDMpfX1lbHNle2VuYy51bnNoaWZ0KDQpO2VuYz1lbmMuY29uY2F0KGludGVnZXJUb0J5dGVzKHksMzIpKX1yZXR1cm4gZW5jfTtFQ1BvaW50RnAuZGVjb2RlRnJvbT1mdW5jdGlvbihlY3BhcmFtcyxlbmMpe3ZhciB0eXBlPWVuY1swXTt2YXIgZGF0YUxlbj1lbmMubGVuZ3RoLTE7aWYodHlwZT09NCl7dmFyIHhCYT1lbmMuc2xpY2UoMSwxK2RhdGFMZW4vMikseUJhPWVuYy5zbGljZSgxK2RhdGFMZW4vMiwxK2RhdGFMZW4pLHg9QmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQoeEJhKSx5PUJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKHlCYSl9ZWxzZXt2YXIgeEJhPWVuYy5zbGljZSgxKSx4PUJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKHhCYSkscD1lY3BhcmFtcy5nZXRRKCkseEN1YmVkUGx1czc9eC5tdWx0aXBseSh4KS5tdWx0aXBseSh4KS5hZGQobmV3IEJpZ0ludGVnZXIoXCI3XCIpKS5tb2QocCkscFBsdXMxT3ZlcjQ9cC5hZGQobmV3IEJpZ0ludGVnZXIoXCIxXCIpKS5kaXZpZGUobmV3IEJpZ0ludGVnZXIoXCI0XCIpKSx5PXhDdWJlZFBsdXM3Lm1vZFBvdyhwUGx1czFPdmVyNCxwKTtpZih5Lm1vZChuZXcgQmlnSW50ZWdlcihcIjJcIikpLnRvU3RyaW5nKCkhPVwiXCIrdHlwZSUyKXt5PXAuc3VidHJhY3QoeSl9fXJldHVybiBuZXcgRUNQb2ludEZwKGVjcGFyYW1zLGVjcGFyYW1zLmZyb21CaWdJbnRlZ2VyKHgpLGVjcGFyYW1zLmZyb21CaWdJbnRlZ2VyKHkpKX07RUNQb2ludEZwLnByb3RvdHlwZS5hZGQyRD1mdW5jdGlvbihiKXtpZih0aGlzLmlzSW5maW5pdHkoKSlyZXR1cm4gYjtpZihiLmlzSW5maW5pdHkoKSlyZXR1cm4gdGhpcztpZih0aGlzLnguZXF1YWxzKGIueCkpe2lmKHRoaXMueS5lcXVhbHMoYi55KSl7cmV0dXJuIHRoaXMudHdpY2UoKX1yZXR1cm4gdGhpcy5jdXJ2ZS5nZXRJbmZpbml0eSgpfXZhciB4X3g9Yi54LnN1YnRyYWN0KHRoaXMueCk7dmFyIHlfeT1iLnkuc3VidHJhY3QodGhpcy55KTt2YXIgZ2FtbWE9eV95LmRpdmlkZSh4X3gpO3ZhciB4Mz1nYW1tYS5zcXVhcmUoKS5zdWJ0cmFjdCh0aGlzLngpLnN1YnRyYWN0KGIueCk7dmFyIHkzPWdhbW1hLm11bHRpcGx5KHRoaXMueC5zdWJ0cmFjdCh4MykpLnN1YnRyYWN0KHRoaXMueSk7cmV0dXJuIG5ldyBFQ1BvaW50RnAodGhpcy5jdXJ2ZSx4Myx5Myl9O0VDUG9pbnRGcC5wcm90b3R5cGUudHdpY2UyRD1mdW5jdGlvbigpe2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVybiB0aGlzO2lmKHRoaXMueS50b0JpZ0ludGVnZXIoKS5zaWdudW0oKT09MCl7cmV0dXJuIHRoaXMuY3VydmUuZ2V0SW5maW5pdHkoKX12YXIgVFdPPXRoaXMuY3VydmUuZnJvbUJpZ0ludGVnZXIoQmlnSW50ZWdlci52YWx1ZU9mKDIpKTt2YXIgVEhSRUU9dGhpcy5jdXJ2ZS5mcm9tQmlnSW50ZWdlcihCaWdJbnRlZ2VyLnZhbHVlT2YoMykpO3ZhciBnYW1tYT10aGlzLnguc3F1YXJlKCkubXVsdGlwbHkoVEhSRUUpLmFkZCh0aGlzLmN1cnZlLmEpLmRpdmlkZSh0aGlzLnkubXVsdGlwbHkoVFdPKSk7dmFyIHgzPWdhbW1hLnNxdWFyZSgpLnN1YnRyYWN0KHRoaXMueC5tdWx0aXBseShUV08pKTt2YXIgeTM9Z2FtbWEubXVsdGlwbHkodGhpcy54LnN1YnRyYWN0KHgzKSkuc3VidHJhY3QodGhpcy55KTtyZXR1cm4gbmV3IEVDUG9pbnRGcCh0aGlzLmN1cnZlLHgzLHkzKX07RUNQb2ludEZwLnByb3RvdHlwZS5tdWx0aXBseTJEPWZ1bmN0aW9uKGspe2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVybiB0aGlzO2lmKGsuc2lnbnVtKCk9PTApcmV0dXJuIHRoaXMuY3VydmUuZ2V0SW5maW5pdHkoKTt2YXIgZT1rO3ZhciBoPWUubXVsdGlwbHkobmV3IEJpZ0ludGVnZXIoXCIzXCIpKTt2YXIgbmVnPXRoaXMubmVnYXRlKCk7dmFyIFI9dGhpczt2YXIgaTtmb3IoaT1oLmJpdExlbmd0aCgpLTI7aT4wOy0taSl7Uj1SLnR3aWNlKCk7dmFyIGhCaXQ9aC50ZXN0Qml0KGkpO3ZhciBlQml0PWUudGVzdEJpdChpKTtpZihoQml0IT1lQml0KXtSPVIuYWRkMkQoaEJpdD90aGlzOm5lZyl9fXJldHVybiBSfTtFQ1BvaW50RnAucHJvdG90eXBlLmlzT25DdXJ2ZT1mdW5jdGlvbigpe3ZhciB4PXRoaXMuZ2V0WCgpLnRvQmlnSW50ZWdlcigpO3ZhciB5PXRoaXMuZ2V0WSgpLnRvQmlnSW50ZWdlcigpO3ZhciBhPXRoaXMuY3VydmUuZ2V0QSgpLnRvQmlnSW50ZWdlcigpO3ZhciBiPXRoaXMuY3VydmUuZ2V0QigpLnRvQmlnSW50ZWdlcigpO3ZhciBuPXRoaXMuY3VydmUuZ2V0USgpO3ZhciBsaHM9eS5tdWx0aXBseSh5KS5tb2Qobik7dmFyIHJocz14Lm11bHRpcGx5KHgpLm11bHRpcGx5KHgpLmFkZChhLm11bHRpcGx5KHgpKS5hZGQoYikubW9kKG4pO3JldHVybiBsaHMuZXF1YWxzKHJocyl9O0VDUG9pbnRGcC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIihcIit0aGlzLmdldFgoKS50b0JpZ0ludGVnZXIoKS50b1N0cmluZygpK1wiLFwiK3RoaXMuZ2V0WSgpLnRvQmlnSW50ZWdlcigpLnRvU3RyaW5nKCkrXCIpXCJ9O0VDUG9pbnRGcC5wcm90b3R5cGUudmFsaWRhdGU9ZnVuY3Rpb24oKXt2YXIgbj10aGlzLmN1cnZlLmdldFEoKTtpZih0aGlzLmlzSW5maW5pdHkoKSl7dGhyb3cgbmV3IEVycm9yKFwiUG9pbnQgaXMgYXQgaW5maW5pdHkuXCIpfXZhciB4PXRoaXMuZ2V0WCgpLnRvQmlnSW50ZWdlcigpO3ZhciB5PXRoaXMuZ2V0WSgpLnRvQmlnSW50ZWdlcigpO2lmKHguY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKTwwfHx4LmNvbXBhcmVUbyhuLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKSk+MCl7dGhyb3cgbmV3IEVycm9yKFwieCBjb29yZGluYXRlIG91dCBvZiBib3VuZHNcIil9aWYoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpPDB8fHkuY29tcGFyZVRvKG4uc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpKT4wKXt0aHJvdyBuZXcgRXJyb3IoXCJ5IGNvb3JkaW5hdGUgb3V0IG9mIGJvdW5kc1wiKX1pZighdGhpcy5pc09uQ3VydmUoKSl7dGhyb3cgbmV3IEVycm9yKFwiUG9pbnQgaXMgbm90IG9uIHRoZSBjdXJ2ZS5cIil9aWYodGhpcy5tdWx0aXBseShuKS5pc0luZmluaXR5KCkpe3Rocm93IG5ldyBFcnJvcihcIlBvaW50IGlzIG5vdCBhIHNjYWxhciBtdWx0aXBsZSBvZiBHLlwiKX1yZXR1cm4gdHJ1ZX07bW9kdWxlLmV4cG9ydHM9RUNDdXJ2ZUZwO21vZHVsZS5leHBvcnRzLkVDUG9pbnRGcD1FQ1BvaW50RnB9LHtcIi4vanNiblwiOjYzLFwiLi9zZWNcIjo2NH1dLDYzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oQnVmZmVyKXt2YXIgZGJpdHM7dmFyIGNhbmFyeT0weGRlYWRiZWVmY2FmZTt2YXIgal9sbT0oY2FuYXJ5JjE2Nzc3MjE1KT09MTU3MTUwNzA7ZnVuY3Rpb24gQmlnSW50ZWdlcihhLGIsYyl7aWYoISh0aGlzIGluc3RhbmNlb2YgQmlnSW50ZWdlcikpe3JldHVybiBuZXcgQmlnSW50ZWdlcihhLGIsYyl9aWYoYSE9bnVsbCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGEpdGhpcy5mcm9tTnVtYmVyKGEsYixjKTtlbHNlIGlmKGI9PW51bGwmJlwic3RyaW5nXCIhPXR5cGVvZiBhKXRoaXMuZnJvbVN0cmluZyhhLDI1Nik7ZWxzZSB0aGlzLmZyb21TdHJpbmcoYSxiKX19dmFyIHByb3RvPUJpZ0ludGVnZXIucHJvdG90eXBlO2Z1bmN0aW9uIG5iaSgpe3JldHVybiBuZXcgQmlnSW50ZWdlcihudWxsKX1mdW5jdGlvbiBhbTEoaSx4LHcsaixjLG4pe3doaWxlKC0tbj49MCl7dmFyIHY9eCp0aGlzW2krK10rd1tqXStjO2M9TWF0aC5mbG9vcih2LzY3MTA4ODY0KTt3W2orK109diY2NzEwODg2M31yZXR1cm4gY31mdW5jdGlvbiBhbTIoaSx4LHcsaixjLG4pe3ZhciB4bD14JjMyNzY3LHhoPXg+PjE1O3doaWxlKC0tbj49MCl7dmFyIGw9dGhpc1tpXSYzMjc2Nzt2YXIgaD10aGlzW2krK10+PjE1O3ZhciBtPXhoKmwraCp4bDtsPXhsKmwrKChtJjMyNzY3KTw8MTUpK3dbal0rKGMmMTA3Mzc0MTgyMyk7Yz0obD4+PjMwKSsobT4+PjE1KSt4aCpoKyhjPj4+MzApO3dbaisrXT1sJjEwNzM3NDE4MjN9cmV0dXJuIGN9ZnVuY3Rpb24gYW0zKGkseCx3LGosYyxuKXt2YXIgeGw9eCYxNjM4Myx4aD14Pj4xNDt3aGlsZSgtLW4+PTApe3ZhciBsPXRoaXNbaV0mMTYzODM7dmFyIGg9dGhpc1tpKytdPj4xNDt2YXIgbT14aCpsK2gqeGw7bD14bCpsKygobSYxNjM4Myk8PDE0KSt3W2pdK2M7Yz0obD4+MjgpKyhtPj4xNCkreGgqaDt3W2orK109bCYyNjg0MzU0NTV9cmV0dXJuIGN9QmlnSW50ZWdlci5wcm90b3R5cGUuYW09YW0xO2RiaXRzPTI2O0JpZ0ludGVnZXIucHJvdG90eXBlLkRCPWRiaXRzO0JpZ0ludGVnZXIucHJvdG90eXBlLkRNPSgxPDxkYml0cyktMTt2YXIgRFY9QmlnSW50ZWdlci5wcm90b3R5cGUuRFY9MTw8ZGJpdHM7dmFyIEJJX0ZQPTUyO0JpZ0ludGVnZXIucHJvdG90eXBlLkZWPU1hdGgucG93KDIsQklfRlApO0JpZ0ludGVnZXIucHJvdG90eXBlLkYxPUJJX0ZQLWRiaXRzO0JpZ0ludGVnZXIucHJvdG90eXBlLkYyPTIqZGJpdHMtQklfRlA7dmFyIEJJX1JNPVwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7dmFyIEJJX1JDPW5ldyBBcnJheTt2YXIgcnIsdnY7cnI9XCIwXCIuY2hhckNvZGVBdCgwKTtmb3IodnY9MDt2djw9OTsrK3Z2KUJJX1JDW3JyKytdPXZ2O3JyPVwiYVwiLmNoYXJDb2RlQXQoMCk7Zm9yKHZ2PTEwO3Z2PDM2OysrdnYpQklfUkNbcnIrK109dnY7cnI9XCJBXCIuY2hhckNvZGVBdCgwKTtmb3IodnY9MTA7dnY8MzY7Kyt2dilCSV9SQ1tycisrXT12djtmdW5jdGlvbiBpbnQyY2hhcihuKXtyZXR1cm4gQklfUk0uY2hhckF0KG4pfWZ1bmN0aW9uIGludEF0KHMsaSl7dmFyIGM9QklfUkNbcy5jaGFyQ29kZUF0KGkpXTtyZXR1cm4gYz09bnVsbD8tMTpjfWZ1bmN0aW9uIGJucENvcHlUbyhyKXtmb3IodmFyIGk9dGhpcy50LTE7aT49MDstLWkpcltpXT10aGlzW2ldO3IudD10aGlzLnQ7ci5zPXRoaXMuc31mdW5jdGlvbiBibnBGcm9tSW50KHgpe3RoaXMudD0xO3RoaXMucz14PDA/LTE6MDtpZih4PjApdGhpc1swXT14O2Vsc2UgaWYoeDwtMSl0aGlzWzBdPXgrRFY7ZWxzZSB0aGlzLnQ9MH1mdW5jdGlvbiBuYnYoaSl7dmFyIHI9bmJpKCk7ci5mcm9tSW50KGkpO3JldHVybiByfWZ1bmN0aW9uIGJucEZyb21TdHJpbmcocyxiKXt2YXIgc2VsZj10aGlzO3ZhciBrO2lmKGI9PTE2KWs9NDtlbHNlIGlmKGI9PTgpaz0zO2Vsc2UgaWYoYj09MjU2KWs9ODtlbHNlIGlmKGI9PTIpaz0xO2Vsc2UgaWYoYj09MzIpaz01O2Vsc2UgaWYoYj09NClrPTI7ZWxzZXtzZWxmLmZyb21SYWRpeChzLGIpO3JldHVybn1zZWxmLnQ9MDtzZWxmLnM9MDt2YXIgaT1zLmxlbmd0aCxtaT1mYWxzZSxzaD0wO3doaWxlKC0taT49MCl7dmFyIHg9az09OD9zW2ldJjI1NTppbnRBdChzLGkpO2lmKHg8MCl7aWYocy5jaGFyQXQoaSk9PVwiLVwiKW1pPXRydWU7Y29udGludWV9bWk9ZmFsc2U7aWYoc2g9PTApc2VsZltzZWxmLnQrK109eDtlbHNlIGlmKHNoK2s+c2VsZi5EQil7c2VsZltzZWxmLnQtMV18PSh4JigxPDxzZWxmLkRCLXNoKS0xKTw8c2g7c2VsZltzZWxmLnQrK109eD4+c2VsZi5EQi1zaH1lbHNlIHNlbGZbc2VsZi50LTFdfD14PDxzaDtzaCs9aztpZihzaD49c2VsZi5EQilzaC09c2VsZi5EQn1pZihrPT04JiYoc1swXSYxMjgpIT0wKXtzZWxmLnM9LTE7aWYoc2g+MClzZWxmW3NlbGYudC0xXXw9KDE8PHNlbGYuREItc2gpLTE8PHNofXNlbGYuY2xhbXAoKTtpZihtaSlCaWdJbnRlZ2VyLlpFUk8uc3ViVG8oc2VsZixzZWxmKX1mdW5jdGlvbiBibnBDbGFtcCgpe3ZhciBjPXRoaXMucyZ0aGlzLkRNO3doaWxlKHRoaXMudD4wJiZ0aGlzW3RoaXMudC0xXT09YyktLXRoaXMudH1mdW5jdGlvbiBiblRvU3RyaW5nKGIpe3ZhciBzZWxmPXRoaXM7aWYoc2VsZi5zPDApcmV0dXJuXCItXCIrc2VsZi5uZWdhdGUoKS50b1N0cmluZyhiKTt2YXIgaztpZihiPT0xNilrPTQ7ZWxzZSBpZihiPT04KWs9MztlbHNlIGlmKGI9PTIpaz0xO2Vsc2UgaWYoYj09MzIpaz01O2Vsc2UgaWYoYj09NClrPTI7ZWxzZSByZXR1cm4gc2VsZi50b1JhZGl4KGIpO3ZhciBrbT0oMTw8ayktMSxkLG09ZmFsc2Uscj1cIlwiLGk9c2VsZi50O3ZhciBwPXNlbGYuREItaSpzZWxmLkRCJWs7aWYoaS0tPjApe2lmKHA8c2VsZi5EQiYmKGQ9c2VsZltpXT4+cCk+MCl7bT10cnVlO3I9aW50MmNoYXIoZCl9d2hpbGUoaT49MCl7aWYocDxrKXtkPShzZWxmW2ldJigxPDxwKS0xKTw8ay1wO2R8PXNlbGZbLS1pXT4+KHArPXNlbGYuREItayl9ZWxzZXtkPXNlbGZbaV0+PihwLT1rKSZrbTtpZihwPD0wKXtwKz1zZWxmLkRCOy0taX19aWYoZD4wKW09dHJ1ZTtpZihtKXIrPWludDJjaGFyKGQpfX1yZXR1cm4gbT9yOlwiMFwifWZ1bmN0aW9uIGJuTmVnYXRlKCl7dmFyIHI9bmJpKCk7QmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMscik7cmV0dXJuIHJ9ZnVuY3Rpb24gYm5BYnMoKXtyZXR1cm4gdGhpcy5zPDA/dGhpcy5uZWdhdGUoKTp0aGlzfWZ1bmN0aW9uIGJuQ29tcGFyZVRvKGEpe3ZhciByPXRoaXMucy1hLnM7aWYociE9MClyZXR1cm4gcjt2YXIgaT10aGlzLnQ7cj1pLWEudDtpZihyIT0wKXJldHVybiB0aGlzLnM8MD8tcjpyO3doaWxlKC0taT49MClpZigocj10aGlzW2ldLWFbaV0pIT0wKXJldHVybiByO3JldHVybiAwfWZ1bmN0aW9uIG5iaXRzKHgpe3ZhciByPTEsdDtpZigodD14Pj4+MTYpIT0wKXt4PXQ7cis9MTZ9aWYoKHQ9eD4+OCkhPTApe3g9dDtyKz04fWlmKCh0PXg+PjQpIT0wKXt4PXQ7cis9NH1pZigodD14Pj4yKSE9MCl7eD10O3IrPTJ9aWYoKHQ9eD4+MSkhPTApe3g9dDtyKz0xfXJldHVybiByfWZ1bmN0aW9uIGJuQml0TGVuZ3RoKCl7aWYodGhpcy50PD0wKXJldHVybiAwO3JldHVybiB0aGlzLkRCKih0aGlzLnQtMSkrbmJpdHModGhpc1t0aGlzLnQtMV1edGhpcy5zJnRoaXMuRE0pfWZ1bmN0aW9uIGJucERMU2hpZnRUbyhuLHIpe3ZhciBpO2ZvcihpPXRoaXMudC0xO2k+PTA7LS1pKXJbaStuXT10aGlzW2ldO2ZvcihpPW4tMTtpPj0wOy0taSlyW2ldPTA7ci50PXRoaXMudCtuO3Iucz10aGlzLnN9ZnVuY3Rpb24gYm5wRFJTaGlmdFRvKG4scil7Zm9yKHZhciBpPW47aTx0aGlzLnQ7KytpKXJbaS1uXT10aGlzW2ldO3IudD1NYXRoLm1heCh0aGlzLnQtbiwwKTtyLnM9dGhpcy5zfWZ1bmN0aW9uIGJucExTaGlmdFRvKG4scil7dmFyIHNlbGY9dGhpczt2YXIgYnM9biVzZWxmLkRCO3ZhciBjYnM9c2VsZi5EQi1iczt2YXIgYm09KDE8PGNicyktMTt2YXIgZHM9TWF0aC5mbG9vcihuL3NlbGYuREIpLGM9c2VsZi5zPDxicyZzZWxmLkRNLGk7Zm9yKGk9c2VsZi50LTE7aT49MDstLWkpe3JbaStkcysxXT1zZWxmW2ldPj5jYnN8YztjPShzZWxmW2ldJmJtKTw8YnN9Zm9yKGk9ZHMtMTtpPj0wOy0taSlyW2ldPTA7cltkc109YztyLnQ9c2VsZi50K2RzKzE7ci5zPXNlbGYucztyLmNsYW1wKCl9ZnVuY3Rpb24gYm5wUlNoaWZ0VG8obixyKXt2YXIgc2VsZj10aGlzO3Iucz1zZWxmLnM7dmFyIGRzPU1hdGguZmxvb3Iobi9zZWxmLkRCKTtpZihkcz49c2VsZi50KXtyLnQ9MDtyZXR1cm59dmFyIGJzPW4lc2VsZi5EQjt2YXIgY2JzPXNlbGYuREItYnM7dmFyIGJtPSgxPDxicyktMTtyWzBdPXNlbGZbZHNdPj5icztmb3IodmFyIGk9ZHMrMTtpPHNlbGYudDsrK2kpe3JbaS1kcy0xXXw9KHNlbGZbaV0mYm0pPDxjYnM7cltpLWRzXT1zZWxmW2ldPj5ic31pZihicz4wKXJbc2VsZi50LWRzLTFdfD0oc2VsZi5zJmJtKTw8Y2JzO3IudD1zZWxmLnQtZHM7ci5jbGFtcCgpfWZ1bmN0aW9uIGJucFN1YlRvKGEscil7dmFyIHNlbGY9dGhpczt2YXIgaT0wLGM9MCxtPU1hdGgubWluKGEudCxzZWxmLnQpO3doaWxlKGk8bSl7Yys9c2VsZltpXS1hW2ldO3JbaSsrXT1jJnNlbGYuRE07Yz4+PXNlbGYuREJ9aWYoYS50PHNlbGYudCl7Yy09YS5zO3doaWxlKGk8c2VsZi50KXtjKz1zZWxmW2ldO3JbaSsrXT1jJnNlbGYuRE07Yz4+PXNlbGYuREJ9Yys9c2VsZi5zfWVsc2V7Yys9c2VsZi5zO3doaWxlKGk8YS50KXtjLT1hW2ldO3JbaSsrXT1jJnNlbGYuRE07Yz4+PXNlbGYuREJ9Yy09YS5zfXIucz1jPDA/LTE6MDtpZihjPC0xKXJbaSsrXT1zZWxmLkRWK2M7ZWxzZSBpZihjPjApcltpKytdPWM7ci50PWk7ci5jbGFtcCgpfWZ1bmN0aW9uIGJucE11bHRpcGx5VG8oYSxyKXt2YXIgeD10aGlzLmFicygpLHk9YS5hYnMoKTt2YXIgaT14LnQ7ci50PWkreS50O3doaWxlKC0taT49MClyW2ldPTA7Zm9yKGk9MDtpPHkudDsrK2kpcltpK3gudF09eC5hbSgwLHlbaV0scixpLDAseC50KTtyLnM9MDtyLmNsYW1wKCk7aWYodGhpcy5zIT1hLnMpQmlnSW50ZWdlci5aRVJPLnN1YlRvKHIscil9ZnVuY3Rpb24gYm5wU3F1YXJlVG8ocil7dmFyIHg9dGhpcy5hYnMoKTt2YXIgaT1yLnQ9Mip4LnQ7d2hpbGUoLS1pPj0wKXJbaV09MDtmb3IoaT0wO2k8eC50LTE7KytpKXt2YXIgYz14LmFtKGkseFtpXSxyLDIqaSwwLDEpO2lmKChyW2kreC50XSs9eC5hbShpKzEsMip4W2ldLHIsMippKzEsYyx4LnQtaS0xKSk+PXguRFYpe3JbaSt4LnRdLT14LkRWO3JbaSt4LnQrMV09MX19aWYoci50PjApcltyLnQtMV0rPXguYW0oaSx4W2ldLHIsMippLDAsMSk7ci5zPTA7ci5jbGFtcCgpfWZ1bmN0aW9uIGJucERpdlJlbVRvKG0scSxyKXt2YXIgc2VsZj10aGlzO3ZhciBwbT1tLmFicygpO2lmKHBtLnQ8PTApcmV0dXJuO3ZhciBwdD1zZWxmLmFicygpO2lmKHB0LnQ8cG0udCl7aWYocSE9bnVsbClxLmZyb21JbnQoMCk7aWYociE9bnVsbClzZWxmLmNvcHlUbyhyKTtyZXR1cm59aWYocj09bnVsbClyPW5iaSgpO3ZhciB5PW5iaSgpLHRzPXNlbGYucyxtcz1tLnM7dmFyIG5zaD1zZWxmLkRCLW5iaXRzKHBtW3BtLnQtMV0pO2lmKG5zaD4wKXtwbS5sU2hpZnRUbyhuc2gseSk7cHQubFNoaWZ0VG8obnNoLHIpfWVsc2V7cG0uY29weVRvKHkpO3B0LmNvcHlUbyhyKX12YXIgeXM9eS50O3ZhciB5MD15W3lzLTFdO2lmKHkwPT0wKXJldHVybjt2YXIgeXQ9eTAqKDE8PHNlbGYuRjEpKyh5cz4xP3lbeXMtMl0+PnNlbGYuRjI6MCk7dmFyIGQxPXNlbGYuRlYveXQsZDI9KDE8PHNlbGYuRjEpL3l0LGU9MTw8c2VsZi5GMjt2YXIgaT1yLnQsaj1pLXlzLHQ9cT09bnVsbD9uYmkoKTpxO3kuZGxTaGlmdFRvKGosdCk7aWYoci5jb21wYXJlVG8odCk+PTApe3Jbci50KytdPTE7ci5zdWJUbyh0LHIpfUJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbyh5cyx0KTt0LnN1YlRvKHkseSk7d2hpbGUoeS50PHlzKXlbeS50KytdPTA7d2hpbGUoLS1qPj0wKXt2YXIgcWQ9clstLWldPT15MD9zZWxmLkRNOk1hdGguZmxvb3IocltpXSpkMSsocltpLTFdK2UpKmQyKTtpZigocltpXSs9eS5hbSgwLHFkLHIsaiwwLHlzKSk8cWQpe3kuZGxTaGlmdFRvKGosdCk7ci5zdWJUbyh0LHIpO3doaWxlKHJbaV08LS1xZClyLnN1YlRvKHQscil9fWlmKHEhPW51bGwpe3IuZHJTaGlmdFRvKHlzLHEpO2lmKHRzIT1tcylCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocSxxKX1yLnQ9eXM7ci5jbGFtcCgpO2lmKG5zaD4wKXIuclNoaWZ0VG8obnNoLHIpO2lmKHRzPDApQmlnSW50ZWdlci5aRVJPLnN1YlRvKHIscil9ZnVuY3Rpb24gYm5Nb2QoYSl7dmFyIHI9bmJpKCk7dGhpcy5hYnMoKS5kaXZSZW1UbyhhLG51bGwscik7aWYodGhpcy5zPDAmJnIuY29tcGFyZVRvKEJpZ0ludGVnZXIuWkVSTyk+MClhLnN1YlRvKHIscik7cmV0dXJuIHJ9ZnVuY3Rpb24gQ2xhc3NpYyhtKXt0aGlzLm09bX1mdW5jdGlvbiBjQ29udmVydCh4KXtpZih4LnM8MHx8eC5jb21wYXJlVG8odGhpcy5tKT49MClyZXR1cm4geC5tb2QodGhpcy5tKTtlbHNlIHJldHVybiB4fWZ1bmN0aW9uIGNSZXZlcnQoeCl7cmV0dXJuIHh9ZnVuY3Rpb24gY1JlZHVjZSh4KXt4LmRpdlJlbVRvKHRoaXMubSxudWxsLHgpfWZ1bmN0aW9uIGNNdWxUbyh4LHkscil7eC5tdWx0aXBseVRvKHkscik7dGhpcy5yZWR1Y2Uocil9ZnVuY3Rpb24gY1NxclRvKHgscil7eC5zcXVhcmVUbyhyKTt0aGlzLnJlZHVjZShyKX1DbGFzc2ljLnByb3RvdHlwZS5jb252ZXJ0PWNDb252ZXJ0O0NsYXNzaWMucHJvdG90eXBlLnJldmVydD1jUmV2ZXJ0O0NsYXNzaWMucHJvdG90eXBlLnJlZHVjZT1jUmVkdWNlO0NsYXNzaWMucHJvdG90eXBlLm11bFRvPWNNdWxUbztDbGFzc2ljLnByb3RvdHlwZS5zcXJUbz1jU3FyVG87ZnVuY3Rpb24gYm5wSW52RGlnaXQoKXtpZih0aGlzLnQ8MSlyZXR1cm4gMDt2YXIgeD10aGlzWzBdO2lmKCh4JjEpPT0wKXJldHVybiAwO3ZhciB5PXgmMzt5PXkqKDItKHgmMTUpKnkpJjE1O3k9eSooMi0oeCYyNTUpKnkpJjI1NTt5PXkqKDItKCh4JjY1NTM1KSp5JjY1NTM1KSkmNjU1MzU7eT15KigyLXgqeSV0aGlzLkRWKSV0aGlzLkRWO3JldHVybiB5PjA/dGhpcy5EVi15Oi15fWZ1bmN0aW9uIE1vbnRnb21lcnkobSl7dGhpcy5tPW07dGhpcy5tcD1tLmludkRpZ2l0KCk7dGhpcy5tcGw9dGhpcy5tcCYzMjc2Nzt0aGlzLm1waD10aGlzLm1wPj4xNTt0aGlzLnVtPSgxPDxtLkRCLTE1KS0xO3RoaXMubXQyPTIqbS50fWZ1bmN0aW9uIG1vbnRDb252ZXJ0KHgpe3ZhciByPW5iaSgpO3guYWJzKCkuZGxTaGlmdFRvKHRoaXMubS50LHIpO3IuZGl2UmVtVG8odGhpcy5tLG51bGwscik7aWYoeC5zPDAmJnIuY29tcGFyZVRvKEJpZ0ludGVnZXIuWkVSTyk+MCl0aGlzLm0uc3ViVG8ocixyKTtyZXR1cm4gcn1mdW5jdGlvbiBtb250UmV2ZXJ0KHgpe3ZhciByPW5iaSgpO3guY29weVRvKHIpO3RoaXMucmVkdWNlKHIpO3JldHVybiByfWZ1bmN0aW9uIG1vbnRSZWR1Y2UoeCl7d2hpbGUoeC50PD10aGlzLm10Mil4W3gudCsrXT0wO2Zvcih2YXIgaT0wO2k8dGhpcy5tLnQ7KytpKXt2YXIgaj14W2ldJjMyNzY3O3ZhciB1MD1qKnRoaXMubXBsKygoaip0aGlzLm1waCsoeFtpXT4+MTUpKnRoaXMubXBsJnRoaXMudW0pPDwxNSkmeC5ETTtqPWkrdGhpcy5tLnQ7eFtqXSs9dGhpcy5tLmFtKDAsdTAseCxpLDAsdGhpcy5tLnQpO3doaWxlKHhbal0+PXguRFYpe3hbal0tPXguRFY7eFsrK2pdKyt9fXguY2xhbXAoKTt4LmRyU2hpZnRUbyh0aGlzLm0udCx4KTtpZih4LmNvbXBhcmVUbyh0aGlzLm0pPj0wKXguc3ViVG8odGhpcy5tLHgpfWZ1bmN0aW9uIG1vbnRTcXJUbyh4LHIpe3guc3F1YXJlVG8ocik7dGhpcy5yZWR1Y2Uocil9ZnVuY3Rpb24gbW9udE11bFRvKHgseSxyKXt4Lm11bHRpcGx5VG8oeSxyKTt0aGlzLnJlZHVjZShyKX1Nb250Z29tZXJ5LnByb3RvdHlwZS5jb252ZXJ0PW1vbnRDb252ZXJ0O01vbnRnb21lcnkucHJvdG90eXBlLnJldmVydD1tb250UmV2ZXJ0O01vbnRnb21lcnkucHJvdG90eXBlLnJlZHVjZT1tb250UmVkdWNlO01vbnRnb21lcnkucHJvdG90eXBlLm11bFRvPW1vbnRNdWxUbztNb250Z29tZXJ5LnByb3RvdHlwZS5zcXJUbz1tb250U3FyVG87ZnVuY3Rpb24gYm5wSXNFdmVuKCl7cmV0dXJuKHRoaXMudD4wP3RoaXNbMF0mMTp0aGlzLnMpPT0wfWZ1bmN0aW9uIGJucEV4cChlLHope2lmKGU+NDI5NDk2NzI5NXx8ZTwxKXJldHVybiBCaWdJbnRlZ2VyLk9ORTt2YXIgcj1uYmkoKSxyMj1uYmkoKSxnPXouY29udmVydCh0aGlzKSxpPW5iaXRzKGUpLTE7Zy5jb3B5VG8ocik7d2hpbGUoLS1pPj0wKXt6LnNxclRvKHIscjIpO2lmKChlJjE8PGkpPjApei5tdWxUbyhyMixnLHIpO2Vsc2V7dmFyIHQ9cjtyPXIyO3IyPXR9fXJldHVybiB6LnJldmVydChyKX1mdW5jdGlvbiBibk1vZFBvd0ludChlLG0pe3ZhciB6O2lmKGU8MjU2fHxtLmlzRXZlbigpKXo9bmV3IENsYXNzaWMobSk7ZWxzZSB6PW5ldyBNb250Z29tZXJ5KG0pO3JldHVybiB0aGlzLmV4cChlLHopfXByb3RvLmNvcHlUbz1ibnBDb3B5VG87cHJvdG8uZnJvbUludD1ibnBGcm9tSW50O3Byb3RvLmZyb21TdHJpbmc9Ym5wRnJvbVN0cmluZztwcm90by5jbGFtcD1ibnBDbGFtcDtwcm90by5kbFNoaWZ0VG89Ym5wRExTaGlmdFRvO3Byb3RvLmRyU2hpZnRUbz1ibnBEUlNoaWZ0VG87cHJvdG8ubFNoaWZ0VG89Ym5wTFNoaWZ0VG87cHJvdG8uclNoaWZ0VG89Ym5wUlNoaWZ0VG87cHJvdG8uc3ViVG89Ym5wU3ViVG87cHJvdG8ubXVsdGlwbHlUbz1ibnBNdWx0aXBseVRvO3Byb3RvLnNxdWFyZVRvPWJucFNxdWFyZVRvO3Byb3RvLmRpdlJlbVRvPWJucERpdlJlbVRvO3Byb3RvLmludkRpZ2l0PWJucEludkRpZ2l0O3Byb3RvLmlzRXZlbj1ibnBJc0V2ZW47cHJvdG8uZXhwPWJucEV4cDtwcm90by50b1N0cmluZz1iblRvU3RyaW5nO3Byb3RvLm5lZ2F0ZT1ibk5lZ2F0ZTtwcm90by5hYnM9Ym5BYnM7cHJvdG8uY29tcGFyZVRvPWJuQ29tcGFyZVRvO3Byb3RvLmJpdExlbmd0aD1ibkJpdExlbmd0aDtwcm90by5tb2Q9Ym5Nb2Q7cHJvdG8ubW9kUG93SW50PWJuTW9kUG93SW50O2Z1bmN0aW9uIG5iaSgpe3JldHVybiBuZXcgQmlnSW50ZWdlcihudWxsKX1mdW5jdGlvbiBibkNsb25lKCl7dmFyIHI9bmJpKCk7dGhpcy5jb3B5VG8ocik7cmV0dXJuIHJ9ZnVuY3Rpb24gYm5JbnRWYWx1ZSgpe2lmKHRoaXMuczwwKXtpZih0aGlzLnQ9PTEpcmV0dXJuIHRoaXNbMF0tdGhpcy5EVjtlbHNlIGlmKHRoaXMudD09MClyZXR1cm4tMX1lbHNlIGlmKHRoaXMudD09MSlyZXR1cm4gdGhpc1swXTtlbHNlIGlmKHRoaXMudD09MClyZXR1cm4gMDtyZXR1cm4odGhpc1sxXSYoMTw8MzItdGhpcy5EQiktMSk8PHRoaXMuREJ8dGhpc1swXX1mdW5jdGlvbiBibkJ5dGVWYWx1ZSgpe3JldHVybiB0aGlzLnQ9PTA/dGhpcy5zOnRoaXNbMF08PDI0Pj4yNH1mdW5jdGlvbiBiblNob3J0VmFsdWUoKXtyZXR1cm4gdGhpcy50PT0wP3RoaXMuczp0aGlzWzBdPDwxNj4+MTZ9ZnVuY3Rpb24gYm5wQ2h1bmtTaXplKHIpe3JldHVybiBNYXRoLmZsb29yKE1hdGguTE4yKnRoaXMuREIvTWF0aC5sb2cocikpfWZ1bmN0aW9uIGJuU2lnTnVtKCl7aWYodGhpcy5zPDApcmV0dXJuLTE7ZWxzZSBpZih0aGlzLnQ8PTB8fHRoaXMudD09MSYmdGhpc1swXTw9MClyZXR1cm4gMDtlbHNlIHJldHVybiAxfWZ1bmN0aW9uIGJucFRvUmFkaXgoYil7aWYoYj09bnVsbCliPTEwO2lmKHRoaXMuc2lnbnVtKCk9PTB8fGI8Mnx8Yj4zNilyZXR1cm5cIjBcIjt2YXIgY3M9dGhpcy5jaHVua1NpemUoYik7dmFyIGE9TWF0aC5wb3coYixjcyk7dmFyIGQ9bmJ2KGEpLHk9bmJpKCksej1uYmkoKSxyPVwiXCI7dGhpcy5kaXZSZW1UbyhkLHkseik7d2hpbGUoeS5zaWdudW0oKT4wKXtyPShhK3ouaW50VmFsdWUoKSkudG9TdHJpbmcoYikuc3Vic3RyKDEpK3I7eS5kaXZSZW1UbyhkLHkseil9cmV0dXJuIHouaW50VmFsdWUoKS50b1N0cmluZyhiKStyfWZ1bmN0aW9uIGJucEZyb21SYWRpeChzLGIpe3ZhciBzZWxmPXRoaXM7c2VsZi5mcm9tSW50KDApO2lmKGI9PW51bGwpYj0xMDt2YXIgY3M9c2VsZi5jaHVua1NpemUoYik7dmFyIGQ9TWF0aC5wb3coYixjcyksbWk9ZmFsc2Usaj0wLHc9MDtmb3IodmFyIGk9MDtpPHMubGVuZ3RoOysraSl7dmFyIHg9aW50QXQocyxpKTtpZih4PDApe2lmKHMuY2hhckF0KGkpPT1cIi1cIiYmc2VsZi5zaWdudW0oKT09MCltaT10cnVlO2NvbnRpbnVlfXc9Yip3K3g7aWYoKytqPj1jcyl7c2VsZi5kTXVsdGlwbHkoZCk7c2VsZi5kQWRkT2Zmc2V0KHcsMCk7aj0wO3c9MH19aWYoaj4wKXtzZWxmLmRNdWx0aXBseShNYXRoLnBvdyhiLGopKTtzZWxmLmRBZGRPZmZzZXQodywwKX1pZihtaSlCaWdJbnRlZ2VyLlpFUk8uc3ViVG8oc2VsZixzZWxmKX1mdW5jdGlvbiBibnBGcm9tTnVtYmVyKGEsYixjKXt2YXIgc2VsZj10aGlzO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBiKXtpZihhPDIpc2VsZi5mcm9tSW50KDEpO2Vsc2V7c2VsZi5mcm9tTnVtYmVyKGEsYyk7aWYoIXNlbGYudGVzdEJpdChhLTEpKXNlbGYuYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhLTEpLG9wX29yLHNlbGYpO2lmKHNlbGYuaXNFdmVuKCkpc2VsZi5kQWRkT2Zmc2V0KDEsMCk7d2hpbGUoIXNlbGYuaXNQcm9iYWJsZVByaW1lKGIpKXtzZWxmLmRBZGRPZmZzZXQoMiwwKTtpZihzZWxmLmJpdExlbmd0aCgpPmEpc2VsZi5zdWJUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYS0xKSxzZWxmKX19fWVsc2V7dmFyIHQ9YSY3O3ZhciBsZW5ndGg9KGE+PjMpKzE7dmFyIHg9YihsZW5ndGgse2FycmF5OnRydWV9KTtpZih0PjApeFswXSY9KDE8PHQpLTE7ZWxzZSB4WzBdPTA7c2VsZi5mcm9tU3RyaW5nKHgsMjU2KX19ZnVuY3Rpb24gYm5Ub0J5dGVBcnJheSgpe3ZhciBzZWxmPXRoaXM7dmFyIGk9c2VsZi50LHI9bmV3IEFycmF5O3JbMF09c2VsZi5zO3ZhciBwPXNlbGYuREItaSpzZWxmLkRCJTgsZCxrPTA7aWYoaS0tPjApe2lmKHA8c2VsZi5EQiYmKGQ9c2VsZltpXT4+cCkhPShzZWxmLnMmc2VsZi5ETSk+PnApcltrKytdPWR8c2VsZi5zPDxzZWxmLkRCLXA7d2hpbGUoaT49MCl7aWYocDw4KXtkPShzZWxmW2ldJigxPDxwKS0xKTw8OC1wO2R8PXNlbGZbLS1pXT4+KHArPXNlbGYuREItOCl9ZWxzZXtkPXNlbGZbaV0+PihwLT04KSYyNTU7aWYocDw9MCl7cCs9c2VsZi5EQjstLWl9fWlmKChkJjEyOCkhPTApZHw9LTI1NjtpZihrPT09MCYmKHNlbGYucyYxMjgpIT0oZCYxMjgpKSsraztpZihrPjB8fGQhPXNlbGYucylyW2srK109ZH19cmV0dXJuIHJ9ZnVuY3Rpb24gYm5FcXVhbHMoYSl7cmV0dXJuIHRoaXMuY29tcGFyZVRvKGEpPT0wfWZ1bmN0aW9uIGJuTWluKGEpe3JldHVybiB0aGlzLmNvbXBhcmVUbyhhKTwwP3RoaXM6YX1mdW5jdGlvbiBibk1heChhKXtyZXR1cm4gdGhpcy5jb21wYXJlVG8oYSk+MD90aGlzOmF9ZnVuY3Rpb24gYm5wQml0d2lzZVRvKGEsb3Ascil7dmFyIHNlbGY9dGhpczt2YXIgaSxmLG09TWF0aC5taW4oYS50LHNlbGYudCk7Zm9yKGk9MDtpPG07KytpKXJbaV09b3Aoc2VsZltpXSxhW2ldKTtpZihhLnQ8c2VsZi50KXtmPWEucyZzZWxmLkRNO2ZvcihpPW07aTxzZWxmLnQ7KytpKXJbaV09b3Aoc2VsZltpXSxmKTtyLnQ9c2VsZi50fWVsc2V7Zj1zZWxmLnMmc2VsZi5ETTtmb3IoaT1tO2k8YS50OysraSlyW2ldPW9wKGYsYVtpXSk7ci50PWEudH1yLnM9b3Aoc2VsZi5zLGEucyk7ci5jbGFtcCgpfWZ1bmN0aW9uIG9wX2FuZCh4LHkpe3JldHVybiB4Jnl9ZnVuY3Rpb24gYm5BbmQoYSl7dmFyIHI9bmJpKCk7dGhpcy5iaXR3aXNlVG8oYSxvcF9hbmQscik7cmV0dXJuIHJ9ZnVuY3Rpb24gb3Bfb3IoeCx5KXtyZXR1cm4geHx5fWZ1bmN0aW9uIGJuT3IoYSl7dmFyIHI9bmJpKCk7dGhpcy5iaXR3aXNlVG8oYSxvcF9vcixyKTtyZXR1cm4gcn1mdW5jdGlvbiBvcF94b3IoeCx5KXtyZXR1cm4geF55fWZ1bmN0aW9uIGJuWG9yKGEpe3ZhciByPW5iaSgpO3RoaXMuYml0d2lzZVRvKGEsb3BfeG9yLHIpO3JldHVybiByfWZ1bmN0aW9uIG9wX2FuZG5vdCh4LHkpe3JldHVybiB4Jn55fWZ1bmN0aW9uIGJuQW5kTm90KGEpe3ZhciByPW5iaSgpO3RoaXMuYml0d2lzZVRvKGEsb3BfYW5kbm90LHIpO3JldHVybiByfWZ1bmN0aW9uIGJuTm90KCl7dmFyIHI9bmJpKCk7Zm9yKHZhciBpPTA7aTx0aGlzLnQ7KytpKXJbaV09dGhpcy5ETSZ+dGhpc1tpXTtyLnQ9dGhpcy50O3Iucz1+dGhpcy5zO3JldHVybiByfWZ1bmN0aW9uIGJuU2hpZnRMZWZ0KG4pe3ZhciByPW5iaSgpO2lmKG48MCl0aGlzLnJTaGlmdFRvKC1uLHIpO2Vsc2UgdGhpcy5sU2hpZnRUbyhuLHIpO3JldHVybiByfWZ1bmN0aW9uIGJuU2hpZnRSaWdodChuKXt2YXIgcj1uYmkoKTtpZihuPDApdGhpcy5sU2hpZnRUbygtbixyKTtlbHNlIHRoaXMuclNoaWZ0VG8obixyKTtyZXR1cm4gcn1mdW5jdGlvbiBsYml0KHgpe2lmKHg9PTApcmV0dXJuLTE7dmFyIHI9MDtpZigoeCY2NTUzNSk9PTApe3g+Pj0xNjtyKz0xNn1pZigoeCYyNTUpPT0wKXt4Pj49ODtyKz04fWlmKCh4JjE1KT09MCl7eD4+PTQ7cis9NH1pZigoeCYzKT09MCl7eD4+PTI7cis9Mn1pZigoeCYxKT09MCkrK3I7cmV0dXJuIHJ9ZnVuY3Rpb24gYm5HZXRMb3dlc3RTZXRCaXQoKXtmb3IodmFyIGk9MDtpPHRoaXMudDsrK2kpaWYodGhpc1tpXSE9MClyZXR1cm4gaSp0aGlzLkRCK2xiaXQodGhpc1tpXSk7aWYodGhpcy5zPDApcmV0dXJuIHRoaXMudCp0aGlzLkRCO3JldHVybi0xfWZ1bmN0aW9uIGNiaXQoeCl7dmFyIHI9MDt3aGlsZSh4IT0wKXt4Jj14LTE7KytyfXJldHVybiByfWZ1bmN0aW9uIGJuQml0Q291bnQoKXt2YXIgcj0wLHg9dGhpcy5zJnRoaXMuRE07Zm9yKHZhciBpPTA7aTx0aGlzLnQ7KytpKXIrPWNiaXQodGhpc1tpXV54KTtyZXR1cm4gcn1mdW5jdGlvbiBiblRlc3RCaXQobil7dmFyIGo9TWF0aC5mbG9vcihuL3RoaXMuREIpO2lmKGo+PXRoaXMudClyZXR1cm4gdGhpcy5zIT0wO3JldHVybih0aGlzW2pdJjE8PG4ldGhpcy5EQikhPTB9ZnVuY3Rpb24gYm5wQ2hhbmdlQml0KG4sb3Ape3ZhciByPUJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChuKTt0aGlzLmJpdHdpc2VUbyhyLG9wLHIpO3JldHVybiByfWZ1bmN0aW9uIGJuU2V0Qml0KG4pe3JldHVybiB0aGlzLmNoYW5nZUJpdChuLG9wX29yKX1mdW5jdGlvbiBibkNsZWFyQml0KG4pe3JldHVybiB0aGlzLmNoYW5nZUJpdChuLG9wX2FuZG5vdCl9ZnVuY3Rpb24gYm5GbGlwQml0KG4pe3JldHVybiB0aGlzLmNoYW5nZUJpdChuLG9wX3hvcil9ZnVuY3Rpb24gYm5wQWRkVG8oYSxyKXt2YXIgc2VsZj10aGlzO3ZhciBpPTAsYz0wLG09TWF0aC5taW4oYS50LHNlbGYudCk7d2hpbGUoaTxtKXtjKz1zZWxmW2ldK2FbaV07cltpKytdPWMmc2VsZi5ETTtjPj49c2VsZi5EQn1pZihhLnQ8c2VsZi50KXtjKz1hLnM7d2hpbGUoaTxzZWxmLnQpe2MrPXNlbGZbaV07cltpKytdPWMmc2VsZi5ETTtjPj49c2VsZi5EQn1jKz1zZWxmLnN9ZWxzZXtjKz1zZWxmLnM7d2hpbGUoaTxhLnQpe2MrPWFbaV07cltpKytdPWMmc2VsZi5ETTtjPj49c2VsZi5EQn1jKz1hLnN9ci5zPWM8MD8tMTowO2lmKGM+MClyW2krK109YztlbHNlIGlmKGM8LTEpcltpKytdPXNlbGYuRFYrYztyLnQ9aTtyLmNsYW1wKCl9ZnVuY3Rpb24gYm5BZGQoYSl7dmFyIHI9bmJpKCk7dGhpcy5hZGRUbyhhLHIpO3JldHVybiByfWZ1bmN0aW9uIGJuU3VidHJhY3QoYSl7dmFyIHI9bmJpKCk7dGhpcy5zdWJUbyhhLHIpO3JldHVybiByfWZ1bmN0aW9uIGJuTXVsdGlwbHkoYSl7dmFyIHI9bmJpKCk7dGhpcy5tdWx0aXBseVRvKGEscik7cmV0dXJuIHJ9ZnVuY3Rpb24gYm5TcXVhcmUoKXt2YXIgcj1uYmkoKTt0aGlzLnNxdWFyZVRvKHIpO3JldHVybiByfWZ1bmN0aW9uIGJuRGl2aWRlKGEpe3ZhciByPW5iaSgpO3RoaXMuZGl2UmVtVG8oYSxyLG51bGwpO3JldHVybiByfWZ1bmN0aW9uIGJuUmVtYWluZGVyKGEpe3ZhciByPW5iaSgpO3RoaXMuZGl2UmVtVG8oYSxudWxsLHIpO3JldHVybiByfWZ1bmN0aW9uIGJuRGl2aWRlQW5kUmVtYWluZGVyKGEpe3ZhciBxPW5iaSgpLHI9bmJpKCk7dGhpcy5kaXZSZW1UbyhhLHEscik7cmV0dXJuIG5ldyBBcnJheShxLHIpfWZ1bmN0aW9uIGJucERNdWx0aXBseShuKXt0aGlzW3RoaXMudF09dGhpcy5hbSgwLG4tMSx0aGlzLDAsMCx0aGlzLnQpOysrdGhpcy50O3RoaXMuY2xhbXAoKX1mdW5jdGlvbiBibnBEQWRkT2Zmc2V0KG4sdyl7aWYobj09MClyZXR1cm47d2hpbGUodGhpcy50PD13KXRoaXNbdGhpcy50KytdPTA7dGhpc1t3XSs9bjt3aGlsZSh0aGlzW3ddPj10aGlzLkRWKXt0aGlzW3ddLT10aGlzLkRWO2lmKCsrdz49dGhpcy50KXRoaXNbdGhpcy50KytdPTA7Kyt0aGlzW3ddfX1mdW5jdGlvbiBOdWxsRXhwKCl7fWZ1bmN0aW9uIG5Ob3AoeCl7cmV0dXJuIHh9ZnVuY3Rpb24gbk11bFRvKHgseSxyKXt4Lm11bHRpcGx5VG8oeSxyKX1mdW5jdGlvbiBuU3FyVG8oeCxyKXt4LnNxdWFyZVRvKHIpfU51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQ9bk5vcDtOdWxsRXhwLnByb3RvdHlwZS5yZXZlcnQ9bk5vcDtOdWxsRXhwLnByb3RvdHlwZS5tdWxUbz1uTXVsVG87TnVsbEV4cC5wcm90b3R5cGUuc3FyVG89blNxclRvO2Z1bmN0aW9uIGJuUG93KGUpe3JldHVybiB0aGlzLmV4cChlLG5ldyBOdWxsRXhwKX1mdW5jdGlvbiBibnBNdWx0aXBseUxvd2VyVG8oYSxuLHIpe3ZhciBpPU1hdGgubWluKHRoaXMudCthLnQsbik7ci5zPTA7ci50PWk7d2hpbGUoaT4wKXJbLS1pXT0wO3ZhciBqO2ZvcihqPXIudC10aGlzLnQ7aTxqOysraSlyW2krdGhpcy50XT10aGlzLmFtKDAsYVtpXSxyLGksMCx0aGlzLnQpO2ZvcihqPU1hdGgubWluKGEudCxuKTtpPGo7KytpKXRoaXMuYW0oMCxhW2ldLHIsaSwwLG4taSk7ci5jbGFtcCgpfWZ1bmN0aW9uIGJucE11bHRpcGx5VXBwZXJUbyhhLG4scil7LS1uO3ZhciBpPXIudD10aGlzLnQrYS50LW47ci5zPTA7d2hpbGUoLS1pPj0wKXJbaV09MDtmb3IoaT1NYXRoLm1heChuLXRoaXMudCwwKTtpPGEudDsrK2kpclt0aGlzLnQraS1uXT10aGlzLmFtKG4taSxhW2ldLHIsMCwwLHRoaXMudCtpLW4pO3IuY2xhbXAoKTtyLmRyU2hpZnRUbygxLHIpfWZ1bmN0aW9uIEJhcnJldHQobSl7dGhpcy5yMj1uYmkoKTt0aGlzLnEzPW5iaSgpO0JpZ0ludGVnZXIuT05FLmRsU2hpZnRUbygyKm0udCx0aGlzLnIyKTt0aGlzLm11PXRoaXMucjIuZGl2aWRlKG0pO3RoaXMubT1tfWZ1bmN0aW9uIGJhcnJldHRDb252ZXJ0KHgpe2lmKHguczwwfHx4LnQ+Mip0aGlzLm0udClyZXR1cm4geC5tb2QodGhpcy5tKTtlbHNlIGlmKHguY29tcGFyZVRvKHRoaXMubSk8MClyZXR1cm4geDtlbHNle3ZhciByPW5iaSgpO3guY29weVRvKHIpO3RoaXMucmVkdWNlKHIpO3JldHVybiByfX1mdW5jdGlvbiBiYXJyZXR0UmV2ZXJ0KHgpe3JldHVybiB4fWZ1bmN0aW9uIGJhcnJldHRSZWR1Y2UoeCl7dmFyIHNlbGY9dGhpczt4LmRyU2hpZnRUbyhzZWxmLm0udC0xLHNlbGYucjIpO2lmKHgudD5zZWxmLm0udCsxKXt4LnQ9c2VsZi5tLnQrMTt4LmNsYW1wKCl9c2VsZi5tdS5tdWx0aXBseVVwcGVyVG8oc2VsZi5yMixzZWxmLm0udCsxLHNlbGYucTMpO3NlbGYubS5tdWx0aXBseUxvd2VyVG8oc2VsZi5xMyxzZWxmLm0udCsxLHNlbGYucjIpO3doaWxlKHguY29tcGFyZVRvKHNlbGYucjIpPDApeC5kQWRkT2Zmc2V0KDEsc2VsZi5tLnQrMSk7eC5zdWJUbyhzZWxmLnIyLHgpO3doaWxlKHguY29tcGFyZVRvKHNlbGYubSk+PTApeC5zdWJUbyhzZWxmLm0seCl9ZnVuY3Rpb24gYmFycmV0dFNxclRvKHgscil7eC5zcXVhcmVUbyhyKTt0aGlzLnJlZHVjZShyKX1mdW5jdGlvbiBiYXJyZXR0TXVsVG8oeCx5LHIpe3gubXVsdGlwbHlUbyh5LHIpO3RoaXMucmVkdWNlKHIpfUJhcnJldHQucHJvdG90eXBlLmNvbnZlcnQ9YmFycmV0dENvbnZlcnQ7QmFycmV0dC5wcm90b3R5cGUucmV2ZXJ0PWJhcnJldHRSZXZlcnQ7QmFycmV0dC5wcm90b3R5cGUucmVkdWNlPWJhcnJldHRSZWR1Y2U7QmFycmV0dC5wcm90b3R5cGUubXVsVG89YmFycmV0dE11bFRvO0JhcnJldHQucHJvdG90eXBlLnNxclRvPWJhcnJldHRTcXJUbztmdW5jdGlvbiBibk1vZFBvdyhlLG0pe3ZhciBpPWUuYml0TGVuZ3RoKCksayxyPW5idigxKSx6O2lmKGk8PTApcmV0dXJuIHI7ZWxzZSBpZihpPDE4KWs9MTtlbHNlIGlmKGk8NDgpaz0zO2Vsc2UgaWYoaTwxNDQpaz00O2Vsc2UgaWYoaTw3Njgpaz01O2Vsc2Ugaz02O2lmKGk8OCl6PW5ldyBDbGFzc2ljKG0pO2Vsc2UgaWYobS5pc0V2ZW4oKSl6PW5ldyBCYXJyZXR0KG0pO2Vsc2Ugej1uZXcgTW9udGdvbWVyeShtKTt2YXIgZz1uZXcgQXJyYXksbj0zLGsxPWstMSxrbT0oMTw8ayktMTtnWzFdPXouY29udmVydCh0aGlzKTtpZihrPjEpe3ZhciBnMj1uYmkoKTt6LnNxclRvKGdbMV0sZzIpO3doaWxlKG48PWttKXtnW25dPW5iaSgpO3oubXVsVG8oZzIsZ1tuLTJdLGdbbl0pO24rPTJ9fXZhciBqPWUudC0xLHcsaXMxPXRydWUscjI9bmJpKCksdDtpPW5iaXRzKGVbal0pLTE7d2hpbGUoaj49MCl7aWYoaT49azEpdz1lW2pdPj5pLWsxJmttO2Vsc2V7dz0oZVtqXSYoMTw8aSsxKS0xKTw8azEtaTtpZihqPjApd3w9ZVtqLTFdPj50aGlzLkRCK2ktazF9bj1rO3doaWxlKCh3JjEpPT0wKXt3Pj49MTstLW59aWYoKGktPW4pPDApe2krPXRoaXMuREI7LS1qfWlmKGlzMSl7Z1t3XS5jb3B5VG8ocik7aXMxPWZhbHNlfWVsc2V7d2hpbGUobj4xKXt6LnNxclRvKHIscjIpO3ouc3FyVG8ocjIscik7bi09Mn1pZihuPjApei5zcXJUbyhyLHIyKTtlbHNle3Q9cjtyPXIyO3IyPXR9ei5tdWxUbyhyMixnW3ddLHIpfXdoaWxlKGo+PTAmJihlW2pdJjE8PGkpPT0wKXt6LnNxclRvKHIscjIpO3Q9cjtyPXIyO3IyPXQ7aWYoLS1pPDApe2k9dGhpcy5EQi0xOy0tan19fXJldHVybiB6LnJldmVydChyKX1mdW5jdGlvbiBibkdDRChhKXt2YXIgeD10aGlzLnM8MD90aGlzLm5lZ2F0ZSgpOnRoaXMuY2xvbmUoKTt2YXIgeT1hLnM8MD9hLm5lZ2F0ZSgpOmEuY2xvbmUoKTtpZih4LmNvbXBhcmVUbyh5KTwwKXt2YXIgdD14O3g9eTt5PXR9dmFyIGk9eC5nZXRMb3dlc3RTZXRCaXQoKSxnPXkuZ2V0TG93ZXN0U2V0Qml0KCk7aWYoZzwwKXJldHVybiB4O2lmKGk8ZylnPWk7aWYoZz4wKXt4LnJTaGlmdFRvKGcseCk7eS5yU2hpZnRUbyhnLHkpfXdoaWxlKHguc2lnbnVtKCk+MCl7aWYoKGk9eC5nZXRMb3dlc3RTZXRCaXQoKSk+MCl4LnJTaGlmdFRvKGkseCk7aWYoKGk9eS5nZXRMb3dlc3RTZXRCaXQoKSk+MCl5LnJTaGlmdFRvKGkseSk7aWYoeC5jb21wYXJlVG8oeSk+PTApe3guc3ViVG8oeSx4KTt4LnJTaGlmdFRvKDEseCl9ZWxzZXt5LnN1YlRvKHgseSk7eS5yU2hpZnRUbygxLHkpfX1pZihnPjApeS5sU2hpZnRUbyhnLHkpO3JldHVybiB5fWZ1bmN0aW9uIGJucE1vZEludChuKXtpZihuPD0wKXJldHVybiAwO3ZhciBkPXRoaXMuRFYlbixyPXRoaXMuczwwP24tMTowO2lmKHRoaXMudD4wKWlmKGQ9PTApcj10aGlzWzBdJW47ZWxzZSBmb3IodmFyIGk9dGhpcy50LTE7aT49MDstLWkpcj0oZCpyK3RoaXNbaV0pJW47cmV0dXJuIHJ9ZnVuY3Rpb24gYm5Nb2RJbnZlcnNlKG0pe3ZhciBhYz1tLmlzRXZlbigpO2lmKHRoaXMuaXNFdmVuKCkmJmFjfHxtLnNpZ251bSgpPT0wKXJldHVybiBCaWdJbnRlZ2VyLlpFUk87dmFyIHU9bS5jbG9uZSgpLHY9dGhpcy5jbG9uZSgpO3ZhciBhPW5idigxKSxiPW5idigwKSxjPW5idigwKSxkPW5idigxKTt3aGlsZSh1LnNpZ251bSgpIT0wKXt3aGlsZSh1LmlzRXZlbigpKXt1LnJTaGlmdFRvKDEsdSk7aWYoYWMpe2lmKCFhLmlzRXZlbigpfHwhYi5pc0V2ZW4oKSl7YS5hZGRUbyh0aGlzLGEpO2Iuc3ViVG8obSxiKX1hLnJTaGlmdFRvKDEsYSl9ZWxzZSBpZighYi5pc0V2ZW4oKSliLnN1YlRvKG0sYik7Yi5yU2hpZnRUbygxLGIpfXdoaWxlKHYuaXNFdmVuKCkpe3YuclNoaWZ0VG8oMSx2KTtpZihhYyl7aWYoIWMuaXNFdmVuKCl8fCFkLmlzRXZlbigpKXtjLmFkZFRvKHRoaXMsYyk7ZC5zdWJUbyhtLGQpfWMuclNoaWZ0VG8oMSxjKX1lbHNlIGlmKCFkLmlzRXZlbigpKWQuc3ViVG8obSxkKTtkLnJTaGlmdFRvKDEsZCl9aWYodS5jb21wYXJlVG8odik+PTApe3Uuc3ViVG8odix1KTtpZihhYylhLnN1YlRvKGMsYSk7Yi5zdWJUbyhkLGIpfWVsc2V7di5zdWJUbyh1LHYpO2lmKGFjKWMuc3ViVG8oYSxjKTtkLnN1YlRvKGIsZCl9fWlmKHYuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSE9MClyZXR1cm4gQmlnSW50ZWdlci5aRVJPO2lmKGQuY29tcGFyZVRvKG0pPj0wKXJldHVybiBkLnN1YnRyYWN0KG0pO2lmKGQuc2lnbnVtKCk8MClkLmFkZFRvKG0sZCk7ZWxzZSByZXR1cm4gZDtpZihkLnNpZ251bSgpPDApcmV0dXJuIGQuYWRkKG0pO2Vsc2UgcmV0dXJuIGR9cHJvdG8uY2h1bmtTaXplPWJucENodW5rU2l6ZTtwcm90by50b1JhZGl4PWJucFRvUmFkaXg7cHJvdG8uZnJvbVJhZGl4PWJucEZyb21SYWRpeDtwcm90by5mcm9tTnVtYmVyPWJucEZyb21OdW1iZXI7cHJvdG8uYml0d2lzZVRvPWJucEJpdHdpc2VUbztwcm90by5jaGFuZ2VCaXQ9Ym5wQ2hhbmdlQml0O3Byb3RvLmFkZFRvPWJucEFkZFRvO3Byb3RvLmRNdWx0aXBseT1ibnBETXVsdGlwbHk7cHJvdG8uZEFkZE9mZnNldD1ibnBEQWRkT2Zmc2V0O3Byb3RvLm11bHRpcGx5TG93ZXJUbz1ibnBNdWx0aXBseUxvd2VyVG87cHJvdG8ubXVsdGlwbHlVcHBlclRvPWJucE11bHRpcGx5VXBwZXJUbztwcm90by5tb2RJbnQ9Ym5wTW9kSW50O3Byb3RvLmNsb25lPWJuQ2xvbmU7cHJvdG8uaW50VmFsdWU9Ym5JbnRWYWx1ZTtwcm90by5ieXRlVmFsdWU9Ym5CeXRlVmFsdWU7cHJvdG8uc2hvcnRWYWx1ZT1iblNob3J0VmFsdWU7cHJvdG8uc2lnbnVtPWJuU2lnTnVtO3Byb3RvLnRvQnl0ZUFycmF5PWJuVG9CeXRlQXJyYXk7cHJvdG8uZXF1YWxzPWJuRXF1YWxzO3Byb3RvLm1pbj1ibk1pbjtwcm90by5tYXg9Ym5NYXg7cHJvdG8uYW5kPWJuQW5kO3Byb3RvLm9yPWJuT3I7cHJvdG8ueG9yPWJuWG9yO3Byb3RvLmFuZE5vdD1ibkFuZE5vdDtwcm90by5ub3Q9Ym5Ob3Q7cHJvdG8uc2hpZnRMZWZ0PWJuU2hpZnRMZWZ0O3Byb3RvLnNoaWZ0UmlnaHQ9Ym5TaGlmdFJpZ2h0O3Byb3RvLmdldExvd2VzdFNldEJpdD1ibkdldExvd2VzdFNldEJpdDtwcm90by5iaXRDb3VudD1ibkJpdENvdW50O3Byb3RvLnRlc3RCaXQ9Ym5UZXN0Qml0O3Byb3RvLnNldEJpdD1iblNldEJpdDtwcm90by5jbGVhckJpdD1ibkNsZWFyQml0O3Byb3RvLmZsaXBCaXQ9Ym5GbGlwQml0O3Byb3RvLmFkZD1ibkFkZDtwcm90by5zdWJ0cmFjdD1iblN1YnRyYWN0O3Byb3RvLm11bHRpcGx5PWJuTXVsdGlwbHk7cHJvdG8uZGl2aWRlPWJuRGl2aWRlO3Byb3RvLnJlbWFpbmRlcj1iblJlbWFpbmRlcjtwcm90by5kaXZpZGVBbmRSZW1haW5kZXI9Ym5EaXZpZGVBbmRSZW1haW5kZXI7cHJvdG8ubW9kUG93PWJuTW9kUG93O3Byb3RvLm1vZEludmVyc2U9Ym5Nb2RJbnZlcnNlO3Byb3RvLnBvdz1iblBvdztwcm90by5nY2Q9Ym5HQ0Q7cHJvdG8uc3F1YXJlPWJuU3F1YXJlO0JpZ0ludGVnZXIuWkVSTz1uYnYoMCk7QmlnSW50ZWdlci5PTkU9bmJ2KDEpO0JpZ0ludGVnZXIudmFsdWVPZj1uYnY7QmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQ9ZnVuY3Rpb24oYmEpe2lmKEJ1ZmZlci5pc0J1ZmZlcihiYSkpe2JhPUFycmF5LnByb3RvdHlwZS5tYXAuYmluZChiYSxmdW5jdGlvbih4KXtyZXR1cm4geH0pKCl9aWYoIWJhLmxlbmd0aCl7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyLnZhbHVlT2YoMCl9ZWxzZSBpZihiYVswXSYxMjgpe3JldHVybiBuZXcgQmlnSW50ZWdlcihbMF0uY29uY2F0KGJhKSl9ZWxzZXtyZXR1cm4gbmV3IEJpZ0ludGVnZXIoYmEpfX07QmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5U2lnbmVkPWZ1bmN0aW9uKGJhKXtpZihiYVswXSYxMjgpe2JhWzBdJj0xMjc7cmV0dXJuIEJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKGJhKS5uZWdhdGUoKX1lbHNle3JldHVybiBCaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZChiYSl9fTtCaWdJbnRlZ2VyLnByb3RvdHlwZS50b0J5dGVBcnJheVVuc2lnbmVkPWZ1bmN0aW9uKCl7dmFyIGJhPXRoaXMuYWJzKCkudG9CeXRlQXJyYXkoKTtpZighYmEubGVuZ3RoKXtyZXR1cm4gYmF9aWYoYmFbMF09PT0wKXtiYT1iYS5zbGljZSgxKX1mb3IodmFyIGk9MDtpPGJhLmxlbmd0aDsrK2kpe2JhW2ldPWJhW2ldPDA/YmFbaV0rMjU2OmJhW2ldfXJldHVybiBiYX07QmlnSW50ZWdlci5wcm90b3R5cGUudG9CeXRlQXJyYXlTaWduZWQ9ZnVuY3Rpb24oKXt2YXIgdmFsPXRoaXMudG9CeXRlQXJyYXlVbnNpZ25lZCgpO3ZhciBuZWc9dGhpcy5zPDA7aWYodmFsWzBdJjEyOCl7dmFsLnVuc2hpZnQobmVnPzEyODowKX1lbHNlIGlmKG5lZyl7dmFsWzBdfD0xMjh9cmV0dXJuIHZhbH07bW9kdWxlLmV4cG9ydHM9QmlnSW50ZWdlcn0pLmNhbGwodGhpcyxfZGVyZXFfKFwiYnVmZmVyXCIpLkJ1ZmZlcil9LHtidWZmZXI6NX1dLDY0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgRUNDdXJ2ZUZwPV9kZXJlcV8oXCIuL2VjXCIpO3ZhciBCaWdJbnRlZ2VyPV9kZXJlcV8oXCIuL2pzYm5cIik7ZnVuY3Rpb24gWDlFQ1BhcmFtZXRlcnMoY3VydmUsZyxuLGgpe3RoaXMuY3VydmU9Y3VydmU7dGhpcy5nPWc7dGhpcy5uPW47dGhpcy5oPWh9ZnVuY3Rpb24geDlnZXRDdXJ2ZSgpe3JldHVybiB0aGlzLmN1cnZlfWZ1bmN0aW9uIHg5Z2V0Rygpe3JldHVybiB0aGlzLmd9ZnVuY3Rpb24geDlnZXROKCl7cmV0dXJuIHRoaXMubn1mdW5jdGlvbiB4OWdldEgoKXtyZXR1cm4gdGhpcy5ofVg5RUNQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRDdXJ2ZT14OWdldEN1cnZlO1g5RUNQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRHPXg5Z2V0RztYOUVDUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0Tj14OWdldE47WDlFQ1BhcmFtZXRlcnMucHJvdG90eXBlLmdldEg9eDlnZXRIO2Z1bmN0aW9uIGZyb21IZXgocyl7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHMsMTYpfWZ1bmN0aW9uIHNlY3AxMjhyMSgpe3ZhciBwPWZyb21IZXgoXCJGRkZGRkZGREZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRlwiKTt2YXIgYT1mcm9tSGV4KFwiRkZGRkZGRkRGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkNcIik7dmFyIGI9ZnJvbUhleChcIkU4NzU3OUMxMTA3OUY0M0REODI0OTkzQzJDRUU1RUQzXCIpO3ZhciBuPWZyb21IZXgoXCJGRkZGRkZGRTAwMDAwMDAwNzVBMzBEMUI5MDM4QTExNVwiKTt2YXIgaD1CaWdJbnRlZ2VyLk9ORTt2YXIgY3VydmU9bmV3IEVDQ3VydmVGcChwLGEsYik7dmFyIEc9Y3VydmUuZGVjb2RlUG9pbnRIZXgoXCIwNFwiK1wiMTYxRkY3NTI4Qjg5OUIyRDBDMjg2MDdDQTUyQzVCODZcIitcIkNGNUFDODM5NUJBRkVCMTNDMDJEQTI5MkRERUQ3QTgzXCIpO3JldHVybiBuZXcgWDlFQ1BhcmFtZXRlcnMoY3VydmUsRyxuLGgpfWZ1bmN0aW9uIHNlY3AxNjBrMSgpe3ZhciBwPWZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRUZGRkZBQzczXCIpO3ZhciBhPUJpZ0ludGVnZXIuWkVSTzt2YXIgYj1mcm9tSGV4KFwiN1wiKTt2YXIgbj1mcm9tSGV4KFwiMDEwMDAwMDAwMDAwMDAwMDAwMDAwMUI4RkExNkRGQUI5QUNBMTZCNkIzXCIpO3ZhciBoPUJpZ0ludGVnZXIuT05FO3ZhciBjdXJ2ZT1uZXcgRUNDdXJ2ZUZwKHAsYSxiKTt2YXIgRz1jdXJ2ZS5kZWNvZGVQb2ludEhleChcIjA0XCIrXCIzQjRDMzgyQ0UzN0FBMTkyQTQwMTlFNzYzMDM2RjRGNURENEQ3RUJCXCIrXCI5MzhDRjkzNTMxOEZEQ0VENkJDMjgyODY1MzE3MzNDM0YwM0M0RkVFXCIpO3JldHVybiBuZXcgWDlFQ1BhcmFtZXRlcnMoY3VydmUsRyxuLGgpfWZ1bmN0aW9uIHNlY3AxNjByMSgpe3ZhciBwPWZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRjdGRkZGRkZGXCIpO3ZhciBhPWZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRjdGRkZGRkZDXCIpO3ZhciBiPWZyb21IZXgoXCIxQzk3QkVGQzU0QkQ3QThCNjVBQ0Y4OUY4MUQ0RDRBREM1NjVGQTQ1XCIpO3ZhciBuPWZyb21IZXgoXCIwMTAwMDAwMDAwMDAwMDAwMDAwMDAxRjRDOEY5MjdBRUQzQ0E3NTIyNTdcIik7dmFyIGg9QmlnSW50ZWdlci5PTkU7dmFyIGN1cnZlPW5ldyBFQ0N1cnZlRnAocCxhLGIpO3ZhciBHPWN1cnZlLmRlY29kZVBvaW50SGV4KFwiMDRcIitcIjRBOTZCNTY4OEVGNTczMjg0NjY0Njk4OTY4QzM4QkI5MTNDQkZDODJcIitcIjIzQTYyODU1MzE2ODk0N0Q1OURDQzkxMjA0MjM1MTM3N0FDNUZCMzJcIik7cmV0dXJuIG5ldyBYOUVDUGFyYW1ldGVycyhjdXJ2ZSxHLG4saCl9ZnVuY3Rpb24gc2VjcDE5MmsxKCl7dmFyIHA9ZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkVGRkZGRUUzN1wiKTt2YXIgYT1CaWdJbnRlZ2VyLlpFUk87dmFyIGI9ZnJvbUhleChcIjNcIik7dmFyIG49ZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRTI2RjJGQzE3MEY2OTQ2NkE3NERFRkQ4RFwiKTt2YXIgaD1CaWdJbnRlZ2VyLk9ORTt2YXIgY3VydmU9bmV3IEVDQ3VydmVGcChwLGEsYik7dmFyIEc9Y3VydmUuZGVjb2RlUG9pbnRIZXgoXCIwNFwiK1wiREI0RkYxMEVDMDU3RTlBRTI2QjA3RDAyODBCN0Y0MzQxREE1RDFCMUVBRTA2QzdEXCIrXCI5QjJGMkY2RDlDNTYyOEE3ODQ0MTYzRDAxNUJFODYzNDQwODJBQTg4RDk1RTJGOURcIik7cmV0dXJuIG5ldyBYOUVDUGFyYW1ldGVycyhjdXJ2ZSxHLG4saCl9ZnVuY3Rpb24gc2VjcDE5MnIxKCl7dmFyIHA9ZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZFRkZGRkZGRkZGRkZGRkZGRlwiKTt2YXIgYT1mcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkVGRkZGRkZGRkZGRkZGRkZDXCIpO3ZhciBiPWZyb21IZXgoXCI2NDIxMDUxOUU1OUM4MEU3MEZBN0U5QUI3MjI0MzA0OUZFQjhERUVDQzE0NkI5QjFcIik7dmFyIG49ZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRjk5REVGODM2MTQ2QkM5QjFCNEQyMjgzMVwiKTt2YXIgaD1CaWdJbnRlZ2VyLk9ORTt2YXIgY3VydmU9bmV3IEVDQ3VydmVGcChwLGEsYik7dmFyIEc9Y3VydmUuZGVjb2RlUG9pbnRIZXgoXCIwNFwiK1wiMTg4REE4MEVCMDMwOTBGNjdDQkYyMEVCNDNBMTg4MDBGNEZGMEFGRDgyRkYxMDEyXCIrXCIwNzE5MkI5NUZGQzhEQTc4NjMxMDExRUQ2QjI0Q0RENTczRjk3N0ExMUU3OTQ4MTFcIik7cmV0dXJuIG5ldyBYOUVDUGFyYW1ldGVycyhjdXJ2ZSxHLG4saCl9ZnVuY3Rpb24gc2VjcDIyNHIxKCl7dmFyIHA9ZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxXCIpO3ZhciBhPWZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRUZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRVwiKTt2YXIgYj1mcm9tSGV4KFwiQjQwNTBBODUwQzA0QjNBQkY1NDEzMjU2NTA0NEIwQjdEN0JGRDhCQTI3MEIzOTQzMjM1NUZGQjRcIik7dmFyIG49ZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYxNkEyRTBCOEYwM0UxM0REMjk0NTVDNUMyQTNEXCIpO3ZhciBoPUJpZ0ludGVnZXIuT05FO3ZhciBjdXJ2ZT1uZXcgRUNDdXJ2ZUZwKHAsYSxiKTt2YXIgRz1jdXJ2ZS5kZWNvZGVQb2ludEhleChcIjA0XCIrXCJCNzBFMENCRDZCQjRCRjdGMzIxMzkwQjk0QTAzQzFEMzU2QzIxMTIyMzQzMjgwRDYxMTVDMUQyMVwiK1wiQkQzNzYzODhCNUY3MjNGQjRDMjJERkU2Q0Q0Mzc1QTA1QTA3NDc2NDQ0RDU4MTk5ODUwMDdFMzRcIik7cmV0dXJuIG5ldyBYOUVDUGFyYW1ldGVycyhjdXJ2ZSxHLG4saCl9ZnVuY3Rpb24gc2VjcDI1NmsxKCl7dmFyIHA9ZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZFRkZGRkZDMkZcIik7dmFyIGE9QmlnSW50ZWdlci5aRVJPO3ZhciBiPWZyb21IZXgoXCI3XCIpO3ZhciBuPWZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRUJBQUVEQ0U2QUY0OEEwM0JCRkQyNUU4Q0QwMzY0MTQxXCIpO3ZhciBoPUJpZ0ludGVnZXIuT05FO3ZhciBjdXJ2ZT1uZXcgRUNDdXJ2ZUZwKHAsYSxiKTt2YXIgRz1jdXJ2ZS5kZWNvZGVQb2ludEhleChcIjA0XCIrXCI3OUJFNjY3RUY5RENCQkFDNTVBMDYyOTVDRTg3MEIwNzAyOUJGQ0RCMkRDRTI4RDk1OUYyODE1QjE2RjgxNzk4XCIrXCI0ODNBREE3NzI2QTNDNDY1NURBNEZCRkMwRTExMDhBOEZEMTdCNDQ4QTY4NTU0MTk5QzQ3RDA4RkZCMTBENEI4XCIpO3JldHVybiBuZXcgWDlFQ1BhcmFtZXRlcnMoY3VydmUsRyxuLGgpfWZ1bmN0aW9uIHNlY3AyNTZyMSgpe3ZhciBwPWZyb21IZXgoXCJGRkZGRkZGRjAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGXCIpO3ZhciBhPWZyb21IZXgoXCJGRkZGRkZGRjAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZDXCIpO3ZhciBiPWZyb21IZXgoXCI1QUM2MzVEOEFBM0E5M0U3QjNFQkJENTU3Njk4ODZCQzY1MUQwNkIwQ0M1M0IwRjYzQkNFM0MzRTI3RDI2MDRCXCIpO3ZhciBuPWZyb21IZXgoXCJGRkZGRkZGRjAwMDAwMDAwRkZGRkZGRkZGRkZGRkZGRkJDRTZGQUFEQTcxNzlFODRGM0I5Q0FDMkZDNjMyNTUxXCIpO3ZhciBoPUJpZ0ludGVnZXIuT05FO3ZhciBjdXJ2ZT1uZXcgRUNDdXJ2ZUZwKHAsYSxiKTt2YXIgRz1jdXJ2ZS5kZWNvZGVQb2ludEhleChcIjA0XCIrXCI2QjE3RDFGMkUxMkM0MjQ3RjhCQ0U2RTU2M0E0NDBGMjc3MDM3RDgxMkRFQjMzQTBGNEExMzk0NUQ4OThDMjk2XCIrXCI0RkUzNDJFMkZFMUE3RjlCOEVFN0VCNEE3QzBGOUUxNjJCQ0UzMzU3NkIzMTVFQ0VDQkI2NDA2ODM3QkY1MUY1XCIpO3JldHVybiBuZXcgWDlFQ1BhcmFtZXRlcnMoY3VydmUsRyxuLGgpfWZ1bmN0aW9uIGdldFNFQ0N1cnZlQnlOYW1lKG5hbWUpe2lmKG5hbWU9PVwic2VjcDEyOHIxXCIpcmV0dXJuIHNlY3AxMjhyMSgpO2lmKG5hbWU9PVwic2VjcDE2MGsxXCIpcmV0dXJuIHNlY3AxNjBrMSgpO2lmKG5hbWU9PVwic2VjcDE2MHIxXCIpcmV0dXJuIHNlY3AxNjByMSgpO2lmKG5hbWU9PVwic2VjcDE5MmsxXCIpcmV0dXJuIHNlY3AxOTJrMSgpO2lmKG5hbWU9PVwic2VjcDE5MnIxXCIpcmV0dXJuIHNlY3AxOTJyMSgpO2lmKG5hbWU9PVwic2VjcDIyNHIxXCIpcmV0dXJuIHNlY3AyMjRyMSgpO2lmKG5hbWU9PVwic2VjcDI1NmsxXCIpcmV0dXJuIHNlY3AyNTZrMSgpO2lmKG5hbWU9PVwic2VjcDI1NnIxXCIpcmV0dXJuIHNlY3AyNTZyMSgpO3JldHVybiBudWxsfW1vZHVsZS5leHBvcnRzPWdldFNFQ0N1cnZlQnlOYW1lfSx7XCIuL2VjXCI6NjIsXCIuL2pzYm5cIjo2M31dLDY1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgQWRkcmVzcz1fZGVyZXFfKFwiLi9hZGRyZXNzXCIpO3ZhciBjb252ZXJ0PV9kZXJlcV8oXCIuL2NvbnZlcnRcIik7dmFyIGVjZHNhPV9kZXJlcV8oXCIuL2VjZHNhXCIpO3ZhciBFQ1B1YktleT1fZGVyZXFfKFwiLi9lY2tleVwiKS5FQ1B1YktleTt2YXIgU0hBMjU2PV9kZXJlcV8oXCJjcnlwdG8tanMvc2hhMjU2XCIpO3ZhciBtYWdpY0J5dGVzPWNvbnZlcnQuc3RyaW5nVG9CeXRlcyhcIkJpdGNvaW4gU2lnbmVkIE1lc3NhZ2U6XFxuXCIpO2Z1bmN0aW9uIG1hZ2ljSGFzaChtZXNzYWdlKXt2YXIgbWVzc2FnZUJ5dGVzPWNvbnZlcnQuc3RyaW5nVG9CeXRlcyhtZXNzYWdlKTt2YXIgYnVmZmVyPVtdLmNvbmNhdChjb252ZXJ0Lm51bVRvVmFySW50KG1hZ2ljQnl0ZXMubGVuZ3RoKSxtYWdpY0J5dGVzLGNvbnZlcnQubnVtVG9WYXJJbnQobWVzc2FnZUJ5dGVzLmxlbmd0aCksbWVzc2FnZUJ5dGVzKTtcbnJldHVybiBjb252ZXJ0LndvcmRBcnJheVRvQnl0ZXMoU0hBMjU2KFNIQTI1Nihjb252ZXJ0LmJ5dGVzVG9Xb3JkQXJyYXkoYnVmZmVyKSkpKX1mdW5jdGlvbiBzaWduKGtleSxtZXNzYWdlKXt2YXIgaGFzaD1tYWdpY0hhc2gobWVzc2FnZSk7dmFyIHNpZz1rZXkuc2lnbihoYXNoKTt2YXIgb2JqPWVjZHNhLnBhcnNlU2lnKHNpZyk7dmFyIGk9ZWNkc2EuY2FsY1B1YktleVJlY292ZXJ5UGFyYW0oa2V5LmdldFB1YigpLnB1YixvYmoucixvYmoucyxoYXNoKTtpKz0yNztpZihrZXkuY29tcHJlc3NlZCl7aSs9NH12YXIgckJhPW9iai5yLnRvQnl0ZUFycmF5VW5zaWduZWQoKTt2YXIgc0JhPW9iai5zLnRvQnl0ZUFycmF5VW5zaWduZWQoKTt3aGlsZShyQmEubGVuZ3RoPDMyKXJCYS51bnNoaWZ0KDApO3doaWxlKHNCYS5sZW5ndGg8MzIpc0JhLnVuc2hpZnQoMCk7c2lnPVtpXS5jb25jYXQockJhLHNCYSk7cmV0dXJuIHNpZ31mdW5jdGlvbiB2ZXJpZnkoYWRkcmVzcyxzaWcsbWVzc2FnZSl7c2lnPWVjZHNhLnBhcnNlU2lnQ29tcGFjdChzaWcpO3ZhciBwdWJLZXk9bmV3IEVDUHViS2V5KGVjZHNhLnJlY292ZXJQdWJLZXkoc2lnLnIsc2lnLnMsbWFnaWNIYXNoKG1lc3NhZ2UpLHNpZy5pKSk7dmFyIGlzQ29tcHJlc3NlZD0hIShzaWcuaSY0KTtwdWJLZXkuY29tcHJlc3NlZD1pc0NvbXByZXNzZWQ7YWRkcmVzcz1uZXcgQWRkcmVzcyhhZGRyZXNzKTtyZXR1cm4gcHViS2V5LmdldEFkZHJlc3MoYWRkcmVzcy52ZXJzaW9uKS50b1N0cmluZygpPT09YWRkcmVzcy50b1N0cmluZygpfW1vZHVsZS5leHBvcnRzPXttYWdpY0hhc2g6bWFnaWNIYXNoLHNpZ246c2lnbix2ZXJpZnk6dmVyaWZ5fX0se1wiLi9hZGRyZXNzXCI6NTQsXCIuL2NvbnZlcnRcIjo1NyxcIi4vZWNkc2FcIjo1OCxcIi4vZWNrZXlcIjo1OSxcImNyeXB0by1qcy9zaGEyNTZcIjo0N31dLDY2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz17bWFpbm5ldDp7YWRkcmVzc1ZlcnNpb246MCxwMnNoVmVyc2lvbjo1LGhkVmVyc2lvbnM6e3B1Yjo3NjA2NzM1OCxwcml2Ojc2MDY2Mjc2fX0sdGVzdG5ldDp7YWRkcmVzc1ZlcnNpb246MTExLHAyc2hWZXJzaW9uOjE5NixoZFZlcnNpb25zOntwdWI6NzA2MTcwMzkscHJpdjo3MDYxNTk1Nn19fX0se31dLDY3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgT3Bjb2RlPXttYXA6e09QXzA6MCxPUF9GQUxTRTowLE9QX1BVU0hEQVRBMTo3NixPUF9QVVNIREFUQTI6NzcsT1BfUFVTSERBVEE0Ojc4LE9QXzFORUdBVEU6NzksT1BfUkVTRVJWRUQ6ODAsT1BfMTo4MSxPUF9UUlVFOjgxLE9QXzI6ODIsT1BfMzo4MyxPUF80Ojg0LE9QXzU6ODUsT1BfNjo4NixPUF83Ojg3LE9QXzg6ODgsT1BfOTo4OSxPUF8xMDo5MCxPUF8xMTo5MSxPUF8xMjo5MixPUF8xMzo5MyxPUF8xNDo5NCxPUF8xNTo5NSxPUF8xNjo5NixPUF9OT1A6OTcsT1BfVkVSOjk4LE9QX0lGOjk5LE9QX05PVElGOjEwMCxPUF9WRVJJRjoxMDEsT1BfVkVSTk9USUY6MTAyLE9QX0VMU0U6MTAzLE9QX0VORElGOjEwNCxPUF9WRVJJRlk6MTA1LE9QX1JFVFVSTjoxMDYsT1BfVE9BTFRTVEFDSzoxMDcsT1BfRlJPTUFMVFNUQUNLOjEwOCxPUF8yRFJPUDoxMDksT1BfMkRVUDoxMTAsT1BfM0RVUDoxMTEsT1BfMk9WRVI6MTEyLE9QXzJST1Q6MTEzLE9QXzJTV0FQOjExNCxPUF9JRkRVUDoxMTUsT1BfREVQVEg6MTE2LE9QX0RST1A6MTE3LE9QX0RVUDoxMTgsT1BfTklQOjExOSxPUF9PVkVSOjEyMCxPUF9QSUNLOjEyMSxPUF9ST0xMOjEyMixPUF9ST1Q6MTIzLE9QX1NXQVA6MTI0LE9QX1RVQ0s6MTI1LE9QX0NBVDoxMjYsT1BfU1VCU1RSOjEyNyxPUF9MRUZUOjEyOCxPUF9SSUdIVDoxMjksT1BfU0laRToxMzAsT1BfSU5WRVJUOjEzMSxPUF9BTkQ6MTMyLE9QX09SOjEzMyxPUF9YT1I6MTM0LE9QX0VRVUFMOjEzNSxPUF9FUVVBTFZFUklGWToxMzYsT1BfUkVTRVJWRUQxOjEzNyxPUF9SRVNFUlZFRDI6MTM4LE9QXzFBREQ6MTM5LE9QXzFTVUI6MTQwLE9QXzJNVUw6MTQxLE9QXzJESVY6MTQyLE9QX05FR0FURToxNDMsT1BfQUJTOjE0NCxPUF9OT1Q6MTQ1LE9QXzBOT1RFUVVBTDoxNDYsT1BfQUREOjE0NyxPUF9TVUI6MTQ4LE9QX01VTDoxNDksT1BfRElWOjE1MCxPUF9NT0Q6MTUxLE9QX0xTSElGVDoxNTIsT1BfUlNISUZUOjE1MyxPUF9CT09MQU5EOjE1NCxPUF9CT09MT1I6MTU1LE9QX05VTUVRVUFMOjE1NixPUF9OVU1FUVVBTFZFUklGWToxNTcsT1BfTlVNTk9URVFVQUw6MTU4LE9QX0xFU1NUSEFOOjE1OSxPUF9HUkVBVEVSVEhBTjoxNjAsT1BfTEVTU1RIQU5PUkVRVUFMOjE2MSxPUF9HUkVBVEVSVEhBTk9SRVFVQUw6MTYyLE9QX01JTjoxNjMsT1BfTUFYOjE2NCxPUF9XSVRISU46MTY1LE9QX1JJUEVNRDE2MDoxNjYsT1BfU0hBMToxNjcsT1BfU0hBMjU2OjE2OCxPUF9IQVNIMTYwOjE2OSxPUF9IQVNIMjU2OjE3MCxPUF9DT0RFU0VQQVJBVE9SOjE3MSxPUF9DSEVDS1NJRzoxNzIsT1BfQ0hFQ0tTSUdWRVJJRlk6MTczLE9QX0NIRUNLTVVMVElTSUc6MTc0LE9QX0NIRUNLTVVMVElTSUdWRVJJRlk6MTc1LE9QX05PUDE6MTc2LE9QX05PUDI6MTc3LE9QX05PUDM6MTc4LE9QX05PUDQ6MTc5LE9QX05PUDU6MTgwLE9QX05PUDY6MTgxLE9QX05PUDc6MTgyLE9QX05PUDg6MTgzLE9QX05PUDk6MTg0LE9QX05PUDEwOjE4NSxPUF9QVUJLRVlIQVNIOjI1MyxPUF9QVUJLRVk6MjU0LE9QX0lOVkFMSURPUENPREU6MjU1fSxyZXZlcnNlTWFwOltdfTtmb3IodmFyIGkgaW4gT3Bjb2RlLm1hcCl7T3Bjb2RlLnJldmVyc2VNYXBbT3Bjb2RlLm1hcFtpXV09aX1tb2R1bGUuZXhwb3J0cz1PcGNvZGV9LHt9XSw2ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKEJ1ZmZlcil7dmFyIE9wY29kZT1fZGVyZXFfKFwiLi9vcGNvZGVcIik7dmFyIHV0aWw9X2RlcmVxXyhcIi4vdXRpbFwiKTt2YXIgY29udmVydD1fZGVyZXFfKFwiLi9jb252ZXJ0XCIpO3ZhciBBZGRyZXNzPV9kZXJlcV8oXCIuL2FkZHJlc3NcIik7dmFyIG5ldHdvcms9X2RlcmVxXyhcIi4vbmV0d29ya1wiKTt2YXIgU2NyaXB0PWZ1bmN0aW9uKGRhdGEpe3RoaXMuYnVmZmVyPWRhdGF8fFtdO2lmKCFBcnJheS5pc0FycmF5KHRoaXMuYnVmZmVyKSl7dGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0IFNjcmlwdCB0byBiZSBpbml0aWFsaXplZCB3aXRoIEFycmF5LCBidXQgZ290IFwiK2RhdGEpfXRoaXMucGFyc2UoKX07U2NyaXB0LmZyb21IZXg9ZnVuY3Rpb24oZGF0YSl7cmV0dXJuIG5ldyBTY3JpcHQoY29udmVydC5oZXhUb0J5dGVzKGRhdGEpKX07U2NyaXB0LmZyb21QdWJLZXk9ZnVuY3Rpb24oc3RyKXt2YXIgc2NyaXB0PW5ldyBTY3JpcHQ7dmFyIHM9c3RyLnNwbGl0KFwiIFwiKTtmb3IodmFyIGkgaW4gcyl7aWYoT3Bjb2RlLm1hcC5oYXNPd25Qcm9wZXJ0eShzW2ldKSl7c2NyaXB0LndyaXRlT3AoT3Bjb2RlLm1hcFtzW2ldXSl9ZWxzZXtzY3JpcHQud3JpdGVCeXRlcyhjb252ZXJ0LmhleFRvQnl0ZXMoc1tpXSkpfX1yZXR1cm4gc2NyaXB0fTtTY3JpcHQuZnJvbVNjcmlwdFNpZz1mdW5jdGlvbihzdHIpe3ZhciBzY3JpcHQ9bmV3IFNjcmlwdDt2YXIgcz1zdHIuc3BsaXQoXCIgXCIpO2Zvcih2YXIgaSBpbiBzKXtpZihPcGNvZGUubWFwLmhhc093blByb3BlcnR5KHNbaV0pKXtzY3JpcHQud3JpdGVPcChPcGNvZGUubWFwW3NbaV1dKX1lbHNle3NjcmlwdC53cml0ZUJ5dGVzKGNvbnZlcnQuaGV4VG9CeXRlcyhzW2ldKSl9fXJldHVybiBzY3JpcHR9O1NjcmlwdC5wcm90b3R5cGUucGFyc2U9ZnVuY3Rpb24oKXt2YXIgc2VsZj10aGlzO3RoaXMuY2h1bmtzPVtdO3ZhciBpPTA7ZnVuY3Rpb24gcmVhZENodW5rKG4pe3NlbGYuY2h1bmtzLnB1c2goc2VsZi5idWZmZXIuc2xpY2UoaSxpK24pKTtpKz1ufXdoaWxlKGk8dGhpcy5idWZmZXIubGVuZ3RoKXt2YXIgb3Bjb2RlPXRoaXMuYnVmZmVyW2krK107aWYob3Bjb2RlPj0yNDApe29wY29kZT1vcGNvZGU8PDh8dGhpcy5idWZmZXJbaSsrXX12YXIgbGVuO2lmKG9wY29kZT4wJiZvcGNvZGU8T3Bjb2RlLm1hcC5PUF9QVVNIREFUQTEpe3JlYWRDaHVuayhvcGNvZGUpfWVsc2UgaWYob3Bjb2RlPT1PcGNvZGUubWFwLk9QX1BVU0hEQVRBMSl7bGVuPXRoaXMuYnVmZmVyW2krK107cmVhZENodW5rKGxlbil9ZWxzZSBpZihvcGNvZGU9PU9wY29kZS5tYXAuT1BfUFVTSERBVEEyKXtsZW49dGhpcy5idWZmZXJbaSsrXTw8OHx0aGlzLmJ1ZmZlcltpKytdO3JlYWRDaHVuayhsZW4pfWVsc2UgaWYob3Bjb2RlPT1PcGNvZGUubWFwLk9QX1BVU0hEQVRBNCl7bGVuPXRoaXMuYnVmZmVyW2krK108PDI0fHRoaXMuYnVmZmVyW2krK108PDE2fHRoaXMuYnVmZmVyW2krK108PDh8dGhpcy5idWZmZXJbaSsrXTtyZWFkQ2h1bmsobGVuKX1lbHNle3RoaXMuY2h1bmtzLnB1c2gob3Bjb2RlKX19fTtTY3JpcHQucHJvdG90eXBlLmdldE91dFR5cGU9ZnVuY3Rpb24oKXtpZih0aGlzLmNodW5rc1t0aGlzLmNodW5rcy5sZW5ndGgtMV09PU9wY29kZS5tYXAuT1BfRVFVQUwmJnRoaXMuY2h1bmtzWzBdPT1PcGNvZGUubWFwLk9QX0hBU0gxNjAmJnRoaXMuY2h1bmtzLmxlbmd0aD09Myl7cmV0dXJuXCJQMlNIXCJ9ZWxzZSBpZih0aGlzLmNodW5rcy5sZW5ndGg9PTUmJnRoaXMuY2h1bmtzWzBdPT1PcGNvZGUubWFwLk9QX0RVUCYmdGhpcy5jaHVua3NbMV09PU9wY29kZS5tYXAuT1BfSEFTSDE2MCYmdGhpcy5jaHVua3NbM109PU9wY29kZS5tYXAuT1BfRVFVQUxWRVJJRlkmJnRoaXMuY2h1bmtzWzRdPT1PcGNvZGUubWFwLk9QX0NIRUNLU0lHKXtyZXR1cm5cIlB1YmtleVwifWVsc2V7cmV0dXJuXCJTdHJhbmdlXCJ9fTtTY3JpcHQucHJvdG90eXBlLnRvU2NyaXB0SGFzaD1mdW5jdGlvbigpe3ZhciBvdXRUeXBlPXRoaXMuZ2V0T3V0VHlwZSgpO2lmKG91dFR5cGU9PVwiUHVia2V5XCIpe3JldHVybiB0aGlzLmNodW5rc1syXX1pZihvdXRUeXBlPT1cIlAyU0hcIil7cmV0dXJuIHV0aWwuc2hhMjU2cmlwZTE2MCh0aGlzLmJ1ZmZlcil9cmV0dXJuIHV0aWwuc2hhMjU2cmlwZTE2MCh0aGlzLmJ1ZmZlcil9O1NjcmlwdC5wcm90b3R5cGUuZ2V0VG9BZGRyZXNzPWZ1bmN0aW9uKCl7dmFyIG91dFR5cGU9dGhpcy5nZXRPdXRUeXBlKCk7aWYob3V0VHlwZT09XCJQdWJrZXlcIil7cmV0dXJuIG5ldyBBZGRyZXNzKHRoaXMuY2h1bmtzWzJdKX1pZihvdXRUeXBlPT1cIlAyU0hcIil7cmV0dXJuIG5ldyBBZGRyZXNzKHRoaXMuY2h1bmtzWzFdLDUpfXJldHVybiBuZXcgQWRkcmVzcyh0aGlzLmNodW5rc1sxXSw1KX07U2NyaXB0LnByb3RvdHlwZS5nZXRGcm9tQWRkcmVzcz1mdW5jdGlvbigpe3JldHVybiBuZXcgQWRkcmVzcyh0aGlzLnNpbXBsZUluSGFzaCgpKX07U2NyaXB0LnByb3RvdHlwZS5nZXRJblR5cGU9ZnVuY3Rpb24oKXtpZih0aGlzLmNodW5rcy5sZW5ndGg9PTEmJkFycmF5LmlzQXJyYXkodGhpcy5jaHVua3NbMF0pKXtyZXR1cm5cIlB1YmtleVwifWVsc2UgaWYodGhpcy5jaHVua3MubGVuZ3RoPT0yJiZBcnJheS5pc0FycmF5KHRoaXMuY2h1bmtzWzBdKSYmQXJyYXkuaXNBcnJheSh0aGlzLmNodW5rc1sxXSkpe3JldHVyblwiQWRkcmVzc1wifWVsc2UgaWYodGhpcy5jaHVua3NbMF09PU9wY29kZS5tYXAuT1BfMCYmdGhpcy5jaHVua3Muc2xpY2UoMSkucmVkdWNlKGZ1bmN0aW9uKHQsY2h1bmssaSl7cmV0dXJuIHQmJkFycmF5LmlzQXJyYXkoY2h1bmspJiYoY2h1bmtbMF09PTQ4fHxpPT10aGlzLmNodW5rcy5sZW5ndGgtMSl9LHRydWUpKXtyZXR1cm5cIk11bHRpc2lnXCJ9ZWxzZXtyZXR1cm5cIlN0cmFuZ2VcIn19O1NjcmlwdC5wcm90b3R5cGUuc2ltcGxlSW5QdWJLZXk9ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5nZXRJblR5cGUoKSl7Y2FzZVwiQWRkcmVzc1wiOnJldHVybiB0aGlzLmNodW5rc1sxXTtjYXNlXCJQdWJrZXlcIjp0aHJvdyBuZXcgRXJyb3IoXCJTY3JpcHQgZG9lcyBub3QgY29udGFpbiBwdWJrZXlcIik7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJFbmNvdW50ZXJlZCBub24tc3RhbmRhcmQgc2NyaXB0U2lnXCIpfX07U2NyaXB0LnByb3RvdHlwZS5zaW1wbGVJbkhhc2g9ZnVuY3Rpb24oKXtyZXR1cm4gdXRpbC5zaGEyNTZyaXBlMTYwKHRoaXMuc2ltcGxlSW5QdWJLZXkoKSl9O1NjcmlwdC5wcm90b3R5cGUuc2ltcGxlSW5QdWJLZXlIYXNoPVNjcmlwdC5wcm90b3R5cGUuc2ltcGxlSW5IYXNoO1NjcmlwdC5wcm90b3R5cGUud3JpdGVPcD1mdW5jdGlvbihvcGNvZGUpe3RoaXMuYnVmZmVyLnB1c2gob3Bjb2RlKTt0aGlzLmNodW5rcy5wdXNoKG9wY29kZSl9O1NjcmlwdC5wcm90b3R5cGUud3JpdGVCeXRlcz1mdW5jdGlvbihkYXRhKXtpZihCdWZmZXIuaXNCdWZmZXIoZGF0YSkpe2RhdGE9QXJyYXkucHJvdG90eXBlLm1hcC5iaW5kKGRhdGEsZnVuY3Rpb24oeCl7cmV0dXJuIHh9KSgpfWlmKGRhdGEubGVuZ3RoPE9wY29kZS5tYXAuT1BfUFVTSERBVEExKXt0aGlzLmJ1ZmZlci5wdXNoKGRhdGEubGVuZ3RoKX1lbHNlIGlmKGRhdGEubGVuZ3RoPD0yNTUpe3RoaXMuYnVmZmVyLnB1c2goT3Bjb2RlLm1hcC5PUF9QVVNIREFUQTEpO3RoaXMuYnVmZmVyLnB1c2goZGF0YS5sZW5ndGgpfWVsc2UgaWYoZGF0YS5sZW5ndGg8PTY1NTM1KXt0aGlzLmJ1ZmZlci5wdXNoKE9wY29kZS5tYXAuT1BfUFVTSERBVEEyKTt0aGlzLmJ1ZmZlci5wdXNoKGRhdGEubGVuZ3RoJjI1NSk7dGhpcy5idWZmZXIucHVzaChkYXRhLmxlbmd0aD4+PjgmMjU1KX1lbHNle3RoaXMuYnVmZmVyLnB1c2goT3Bjb2RlLm1hcC5PUF9QVVNIREFUQTQpO3RoaXMuYnVmZmVyLnB1c2goZGF0YS5sZW5ndGgmMjU1KTt0aGlzLmJ1ZmZlci5wdXNoKGRhdGEubGVuZ3RoPj4+OCYyNTUpO3RoaXMuYnVmZmVyLnB1c2goZGF0YS5sZW5ndGg+Pj4xNiYyNTUpO3RoaXMuYnVmZmVyLnB1c2goZGF0YS5sZW5ndGg+Pj4yNCYyNTUpfXRoaXMuYnVmZmVyPXRoaXMuYnVmZmVyLmNvbmNhdChkYXRhKTt0aGlzLmNodW5rcy5wdXNoKGRhdGEpfTtTY3JpcHQuY3JlYXRlT3V0cHV0U2NyaXB0PWZ1bmN0aW9uKGFkZHJlc3Mpe3ZhciBzY3JpcHQ9bmV3IFNjcmlwdDthZGRyZXNzPW5ldyBBZGRyZXNzKGFkZHJlc3MpO2lmKGFkZHJlc3MudmVyc2lvbj09bmV0d29yay5tYWlubmV0LnAyc2hWZXJzaW9ufHxhZGRyZXNzLnZlcnNpb249PW5ldHdvcmsudGVzdG5ldC5wMnNoVmVyc2lvbil7c2NyaXB0LndyaXRlT3AoT3Bjb2RlLm1hcC5PUF9IQVNIMTYwKTtzY3JpcHQud3JpdGVCeXRlcyhhZGRyZXNzLmhhc2gpO3NjcmlwdC53cml0ZU9wKE9wY29kZS5tYXAuT1BfRVFVQUwpfWVsc2V7c2NyaXB0LndyaXRlT3AoT3Bjb2RlLm1hcC5PUF9EVVApO3NjcmlwdC53cml0ZU9wKE9wY29kZS5tYXAuT1BfSEFTSDE2MCk7c2NyaXB0LndyaXRlQnl0ZXMoYWRkcmVzcy5oYXNoKTtzY3JpcHQud3JpdGVPcChPcGNvZGUubWFwLk9QX0VRVUFMVkVSSUZZKTtzY3JpcHQud3JpdGVPcChPcGNvZGUubWFwLk9QX0NIRUNLU0lHKX1yZXR1cm4gc2NyaXB0fTtTY3JpcHQucHJvdG90eXBlLmV4dHJhY3RQdWJrZXlzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2h1bmtzLmZpbHRlcihmdW5jdGlvbihjaHVuayl7cmV0dXJuIGNodW5rWzBdPT00JiZjaHVuay5sZW5ndGg9PTY1fHxjaHVua1swXTw0JiZjaHVuay5sZW5ndGg9PTMzfSl9O1NjcmlwdC5jcmVhdGVNdWx0aVNpZ091dHB1dFNjcmlwdD1mdW5jdGlvbihtLHB1YmtleXMpe3ZhciBzY3JpcHQ9bmV3IFNjcmlwdDtwdWJrZXlzPXB1YmtleXMuc29ydCgpO3NjcmlwdC53cml0ZU9wKE9wY29kZS5tYXAuT1BfMSttLTEpO2Zvcih2YXIgaT0wO2k8cHVia2V5cy5sZW5ndGg7KytpKXtzY3JpcHQud3JpdGVCeXRlcyhwdWJrZXlzW2ldKX1zY3JpcHQud3JpdGVPcChPcGNvZGUubWFwLk9QXzErcHVia2V5cy5sZW5ndGgtMSk7c2NyaXB0LndyaXRlT3AoT3Bjb2RlLm1hcC5PUF9DSEVDS01VTFRJU0lHKTtyZXR1cm4gc2NyaXB0fTtTY3JpcHQuY3JlYXRlSW5wdXRTY3JpcHQ9ZnVuY3Rpb24oc2lnbmF0dXJlLHB1YktleSl7dmFyIHNjcmlwdD1uZXcgU2NyaXB0O3NjcmlwdC53cml0ZUJ5dGVzKHNpZ25hdHVyZSk7c2NyaXB0LndyaXRlQnl0ZXMocHViS2V5KTtyZXR1cm4gc2NyaXB0fTtTY3JpcHQuY3JlYXRlTXVsdGlTaWdJbnB1dFNjcmlwdD1mdW5jdGlvbihzaWduYXR1cmVzLHNjcmlwdCl7c2NyaXB0PW5ldyBTY3JpcHQoc2NyaXB0KTt2YXIgaz1zY3JpcHQuY2h1bmtzWzBdWzBdO2lmKHNpZ25hdHVyZXMubGVuZ3RoPGspcmV0dXJuIGZhbHNlO3ZhciBpblNjcmlwdD1uZXcgU2NyaXB0O2luU2NyaXB0LndyaXRlT3AoT3Bjb2RlLm1hcC5PUF8wKTtzaWduYXR1cmVzLm1hcChmdW5jdGlvbihzaWcpe2luU2NyaXB0LndyaXRlQnl0ZXMoc2lnKX0pO2luU2NyaXB0LndyaXRlQnl0ZXMoc2NyaXB0LmJ1ZmZlcik7cmV0dXJuIGluU2NyaXB0fTtTY3JpcHQucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTY3JpcHQodGhpcy5idWZmZXIpfTttb2R1bGUuZXhwb3J0cz1TY3JpcHR9KS5jYWxsKHRoaXMsX2RlcmVxXyhcImJ1ZmZlclwiKS5CdWZmZXIpfSx7XCIuL2FkZHJlc3NcIjo1NCxcIi4vY29udmVydFwiOjU3LFwiLi9uZXR3b3JrXCI6NjYsXCIuL29wY29kZVwiOjY3LFwiLi91dGlsXCI6NzAsYnVmZmVyOjV9XSw2OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIEJpZ0ludGVnZXI9X2RlcmVxXyhcIi4vanNibi9qc2JuXCIpO3ZhciBTY3JpcHQ9X2RlcmVxXyhcIi4vc2NyaXB0XCIpO3ZhciB1dGlsPV9kZXJlcV8oXCIuL3V0aWxcIik7dmFyIGNvbnZlcnQ9X2RlcmVxXyhcIi4vY29udmVydFwiKTt2YXIgRUNLZXk9X2RlcmVxXyhcIi4vZWNrZXlcIikuRUNLZXk7dmFyIEVDRFNBPV9kZXJlcV8oXCIuL2VjZHNhXCIpO3ZhciBBZGRyZXNzPV9kZXJlcV8oXCIuL2FkZHJlc3NcIik7dmFyIFNIQTI1Nj1fZGVyZXFfKFwiY3J5cHRvLWpzL3NoYTI1NlwiKTt2YXIgVHJhbnNhY3Rpb249ZnVuY3Rpb24oZG9jKXtpZighKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikpe3JldHVybiBuZXcgVHJhbnNhY3Rpb24oZG9jKX10aGlzLnZlcnNpb249MTt0aGlzLmxvY2t0aW1lPTA7dGhpcy5pbnM9W107dGhpcy5vdXRzPVtdO3RoaXMuZGVmYXVsdFNlcXVlbmNlPVsyNTUsMjU1LDI1NSwyNTVdO2lmKGRvYyl7aWYodHlwZW9mIGRvYz09XCJzdHJpbmdcInx8QXJyYXkuaXNBcnJheShkb2MpKXtkb2M9VHJhbnNhY3Rpb24uZGVzZXJpYWxpemUoZG9jKX1pZihkb2MuaGFzaCl0aGlzLmhhc2g9ZG9jLmhhc2g7aWYoZG9jLnZlcnNpb24pdGhpcy52ZXJzaW9uPWRvYy52ZXJzaW9uO2lmKGRvYy5sb2NrdGltZSl0aGlzLmxvY2t0aW1lPWRvYy5sb2NrdGltZTtpZihkb2MuaW5zJiZkb2MuaW5zLmxlbmd0aCl7ZG9jLmlucy5mb3JFYWNoKGZ1bmN0aW9uKGlucHV0KXt0aGlzLmFkZElucHV0KG5ldyBUcmFuc2FjdGlvbkluKGlucHV0KSl9LHRoaXMpfWlmKGRvYy5vdXRzJiZkb2Mub3V0cy5sZW5ndGgpe2RvYy5vdXRzLmZvckVhY2goZnVuY3Rpb24ob3V0cHV0KXt0aGlzLmFkZE91dHB1dChuZXcgVHJhbnNhY3Rpb25PdXQob3V0cHV0KSl9LHRoaXMpfXRoaXMuaGFzaD10aGlzLmhhc2h8fHRoaXMuZ2V0SGFzaCgpfX07VHJhbnNhY3Rpb24ucHJvdG90eXBlLmFkZElucHV0PWZ1bmN0aW9uKHR4LG91dEluZGV4KXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFRyYW5zYWN0aW9uSW4pe3RoaXMuaW5zLnB1c2goYXJndW1lbnRzWzBdKX1lbHNlIGlmKGFyZ3VtZW50c1swXS5sZW5ndGg+NjUpe3ZhciBhcmdzPWFyZ3VtZW50c1swXS5zcGxpdChcIjpcIik7cmV0dXJuIHRoaXMuYWRkSW5wdXQoYXJnc1swXSxhcmdzWzFdKX1lbHNle3ZhciBoYXNoPXR5cGVvZiB0eD09PVwic3RyaW5nXCI/dHg6dHguaGFzaDtoYXNoPUFycmF5LmlzQXJyYXkoaGFzaCk/Y29udmVydC5ieXRlc1RvSGV4KGhhc2gpOmhhc2g7dGhpcy5pbnMucHVzaChuZXcgVHJhbnNhY3Rpb25Jbih7b3V0cG9pbnQ6e2hhc2g6aGFzaCxpbmRleDpvdXRJbmRleH0sc2NyaXB0Om5ldyBTY3JpcHQsc2VxdWVuY2U6dGhpcy5kZWZhdWx0U2VxdWVuY2V9KSl9fTtUcmFuc2FjdGlvbi5wcm90b3R5cGUuYWRkT3V0cHV0PWZ1bmN0aW9uKGFkZHJlc3MsdmFsdWUpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHJhbnNhY3Rpb25PdXQpe3RoaXMub3V0cy5wdXNoKGFyZ3VtZW50c1swXSk7cmV0dXJufWlmKGFyZ3VtZW50c1swXS5pbmRleE9mKFwiOlwiKT49MCl7dmFyIGFyZ3M9YXJndW1lbnRzWzBdLnNwbGl0KFwiOlwiKTthZGRyZXNzPWFyZ3NbMF07dmFsdWU9cGFyc2VJbnQoYXJnc1sxXSl9dGhpcy5vdXRzLnB1c2gobmV3IFRyYW5zYWN0aW9uT3V0KHt2YWx1ZTp2YWx1ZSxzY3JpcHQ6U2NyaXB0LmNyZWF0ZU91dHB1dFNjcmlwdChhZGRyZXNzKX0pKX07VHJhbnNhY3Rpb24ucHJvdG90eXBlLnNlcmlhbGl6ZT1mdW5jdGlvbigpe3ZhciBidWZmZXI9W107YnVmZmVyPWJ1ZmZlci5jb25jYXQoY29udmVydC5udW1Ub0J5dGVzKHBhcnNlSW50KHRoaXMudmVyc2lvbiksNCkpO2J1ZmZlcj1idWZmZXIuY29uY2F0KGNvbnZlcnQubnVtVG9WYXJJbnQodGhpcy5pbnMubGVuZ3RoKSk7dGhpcy5pbnMuZm9yRWFjaChmdW5jdGlvbih0eGluKXtidWZmZXI9YnVmZmVyLmNvbmNhdChjb252ZXJ0LmhleFRvQnl0ZXModHhpbi5vdXRwb2ludC5oYXNoKS5yZXZlcnNlKCkpO2J1ZmZlcj1idWZmZXIuY29uY2F0KGNvbnZlcnQubnVtVG9CeXRlcyhwYXJzZUludCh0eGluLm91dHBvaW50LmluZGV4KSw0KSk7dmFyIHNjcmlwdEJ5dGVzPXR4aW4uc2NyaXB0LmJ1ZmZlcjtidWZmZXI9YnVmZmVyLmNvbmNhdChjb252ZXJ0Lm51bVRvVmFySW50KHNjcmlwdEJ5dGVzLmxlbmd0aCkpO2J1ZmZlcj1idWZmZXIuY29uY2F0KHNjcmlwdEJ5dGVzKTtidWZmZXI9YnVmZmVyLmNvbmNhdCh0eGluLnNlcXVlbmNlKX0pO2J1ZmZlcj1idWZmZXIuY29uY2F0KGNvbnZlcnQubnVtVG9WYXJJbnQodGhpcy5vdXRzLmxlbmd0aCkpO3RoaXMub3V0cy5mb3JFYWNoKGZ1bmN0aW9uKHR4b3V0KXtidWZmZXI9YnVmZmVyLmNvbmNhdChjb252ZXJ0Lm51bVRvQnl0ZXModHhvdXQudmFsdWUsOCkpO3ZhciBzY3JpcHRCeXRlcz10eG91dC5zY3JpcHQuYnVmZmVyO2J1ZmZlcj1idWZmZXIuY29uY2F0KGNvbnZlcnQubnVtVG9WYXJJbnQoc2NyaXB0Qnl0ZXMubGVuZ3RoKSk7YnVmZmVyPWJ1ZmZlci5jb25jYXQoc2NyaXB0Qnl0ZXMpfSk7YnVmZmVyPWJ1ZmZlci5jb25jYXQoY29udmVydC5udW1Ub0J5dGVzKHBhcnNlSW50KHRoaXMubG9ja3RpbWUpLDQpKTtyZXR1cm4gYnVmZmVyfTtUcmFuc2FjdGlvbi5wcm90b3R5cGUuc2VyaWFsaXplSGV4PWZ1bmN0aW9uKCl7cmV0dXJuIGNvbnZlcnQuYnl0ZXNUb0hleCh0aGlzLnNlcmlhbGl6ZSgpKX07dmFyIFNJR0hBU0hfQUxMPTE7dmFyIFNJR0hBU0hfTk9ORT0yO3ZhciBTSUdIQVNIX1NJTkdMRT0zO3ZhciBTSUdIQVNIX0FOWU9ORUNBTlBBWT04MDtUcmFuc2FjdGlvbi5wcm90b3R5cGUuaGFzaFRyYW5zYWN0aW9uRm9yU2lnbmF0dXJlPWZ1bmN0aW9uKGNvbm5lY3RlZFNjcmlwdCxpbkluZGV4LGhhc2hUeXBlKXt2YXIgdHhUbXA9dGhpcy5jbG9uZSgpO3R4VG1wLmlucy5mb3JFYWNoKGZ1bmN0aW9uKHR4aW4pe3R4aW4uc2NyaXB0PW5ldyBTY3JpcHR9KTt0eFRtcC5pbnNbaW5JbmRleF0uc2NyaXB0PWNvbm5lY3RlZFNjcmlwdDtpZigoaGFzaFR5cGUmMzEpPT1TSUdIQVNIX05PTkUpe3R4VG1wLm91dHM9W107dHhUbXAuaW5zLmZvckVhY2goZnVuY3Rpb24odHhpbixpKXtpZihpIT1pbkluZGV4KXt0eFRtcC5pbnNbaV0uc2VxdWVuY2U9MH19KX1lbHNlIGlmKChoYXNoVHlwZSYzMSk9PVNJR0hBU0hfU0lOR0xFKXt9aWYoaGFzaFR5cGUmU0lHSEFTSF9BTllPTkVDQU5QQVkpe3R4VG1wLmlucz1bdHhUbXAuaW5zW2luSW5kZXhdXX12YXIgYnVmZmVyPXR4VG1wLnNlcmlhbGl6ZSgpO2J1ZmZlcj1idWZmZXIuY29uY2F0KGNvbnZlcnQubnVtVG9CeXRlcyhwYXJzZUludChoYXNoVHlwZSksNCkpO2J1ZmZlcj1jb252ZXJ0LmJ5dGVzVG9Xb3JkQXJyYXkoYnVmZmVyKTtyZXR1cm4gY29udmVydC53b3JkQXJyYXlUb0J5dGVzKFNIQTI1NihTSEEyNTYoYnVmZmVyKSkpfTtUcmFuc2FjdGlvbi5wcm90b3R5cGUuZ2V0SGFzaD1mdW5jdGlvbigpe3ZhciBidWZmZXI9Y29udmVydC5ieXRlc1RvV29yZEFycmF5KHRoaXMuc2VyaWFsaXplKCkpO3JldHVybiBjb252ZXJ0LndvcmRBcnJheVRvQnl0ZXMoU0hBMjU2KFNIQTI1NihidWZmZXIpKSkucmV2ZXJzZSgpfTtUcmFuc2FjdGlvbi5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgbmV3VHg9bmV3IFRyYW5zYWN0aW9uO25ld1R4LnZlcnNpb249dGhpcy52ZXJzaW9uO25ld1R4LmxvY2t0aW1lPXRoaXMubG9ja3RpbWU7dGhpcy5pbnMuZm9yRWFjaChmdW5jdGlvbih0eGluKXtuZXdUeC5hZGRJbnB1dCh0eGluLmNsb25lKCkpfSk7dGhpcy5vdXRzLmZvckVhY2goZnVuY3Rpb24odHhvdXQpe25ld1R4LmFkZE91dHB1dCh0eG91dC5jbG9uZSgpKX0pO3JldHVybiBuZXdUeH07VHJhbnNhY3Rpb24uZGVzZXJpYWxpemU9ZnVuY3Rpb24oYnVmZmVyKXtpZih0eXBlb2YgYnVmZmVyPT1cInN0cmluZ1wiKXtidWZmZXI9Y29udmVydC5oZXhUb0J5dGVzKGJ1ZmZlcil9dmFyIHBvcz0wO3ZhciByZWFkQXNJbnQ9ZnVuY3Rpb24oYnl0ZXMpe2lmKGJ5dGVzPT09MClyZXR1cm4gMDtwb3MrKztyZXR1cm4gYnVmZmVyW3Bvcy0xXStyZWFkQXNJbnQoYnl0ZXMtMSkqMjU2fTt2YXIgcmVhZFZhckludD1mdW5jdGlvbigpe3ZhciBieXRlcz1idWZmZXIuc2xpY2UocG9zLHBvcys5KTt2YXIgcmVzdWx0PWNvbnZlcnQudmFySW50VG9OdW0oYnl0ZXMpO3Bvcys9cmVzdWx0LmJ5dGVzLmxlbmd0aDtyZXR1cm4gcmVzdWx0Lm51bWJlcn07dmFyIHJlYWRCeXRlcz1mdW5jdGlvbihieXRlcyl7cG9zKz1ieXRlcztyZXR1cm4gYnVmZmVyLnNsaWNlKHBvcy1ieXRlcyxwb3MpfTt2YXIgcmVhZFZhclN0cmluZz1mdW5jdGlvbigpe3ZhciBzaXplPXJlYWRWYXJJbnQoKTtyZXR1cm4gcmVhZEJ5dGVzKHNpemUpfTt2YXIgb2JqPXtpbnM6W10sb3V0czpbXX07b2JqLnZlcnNpb249cmVhZEFzSW50KDQpO3ZhciBpbnM9cmVhZFZhckludCgpO3ZhciBpO2ZvcihpPTA7aTxpbnM7aSsrKXtvYmouaW5zLnB1c2goe291dHBvaW50OntoYXNoOmNvbnZlcnQuYnl0ZXNUb0hleChyZWFkQnl0ZXMoMzIpLnJldmVyc2UoKSksaW5kZXg6cmVhZEFzSW50KDQpfSxzY3JpcHQ6bmV3IFNjcmlwdChyZWFkVmFyU3RyaW5nKCkpLHNlcXVlbmNlOnJlYWRCeXRlcyg0KX0pfXZhciBvdXRzPXJlYWRWYXJJbnQoKTtmb3IoaT0wO2k8b3V0cztpKyspe29iai5vdXRzLnB1c2goe3ZhbHVlOmNvbnZlcnQuYnl0ZXNUb051bShyZWFkQnl0ZXMoOCkpLHNjcmlwdDpuZXcgU2NyaXB0KHJlYWRWYXJTdHJpbmcoKSl9KX1vYmoubG9ja3RpbWU9cmVhZEFzSW50KDQpO3JldHVybiBuZXcgVHJhbnNhY3Rpb24ob2JqKX07VHJhbnNhY3Rpb24ucHJvdG90eXBlLnNpZ249ZnVuY3Rpb24oaW5kZXgsa2V5LHR5cGUpe3R5cGU9dHlwZXx8U0lHSEFTSF9BTEw7a2V5PW5ldyBFQ0tleShrZXkpO3ZhciBwdWI9a2V5LmdldFB1YigpLnRvQnl0ZXMoKSxoYXNoMTYwPXV0aWwuc2hhMjU2cmlwZTE2MChwdWIpLHNjcmlwdD1TY3JpcHQuY3JlYXRlT3V0cHV0U2NyaXB0KG5ldyBBZGRyZXNzKGhhc2gxNjApKSxoYXNoPXRoaXMuaGFzaFRyYW5zYWN0aW9uRm9yU2lnbmF0dXJlKHNjcmlwdCxpbmRleCx0eXBlKSxzaWc9a2V5LnNpZ24oaGFzaCkuY29uY2F0KFt0eXBlXSk7dGhpcy5pbnNbaW5kZXhdLnNjcmlwdD1TY3JpcHQuY3JlYXRlSW5wdXRTY3JpcHQoc2lnLHB1Yil9O1RyYW5zYWN0aW9uLnByb3RvdHlwZS5zaWduV2l0aEtleXM9ZnVuY3Rpb24oa2V5cyxvdXRwdXRzLHR5cGUpe3R5cGU9dHlwZXx8U0lHSEFTSF9BTEw7dmFyIGFkZHJkYXRhPWtleXMubWFwKGZ1bmN0aW9uKGtleSl7a2V5PW5ldyBFQ0tleShrZXkpO3JldHVybntrZXk6a2V5LGFkZHJlc3M6a2V5LmdldEFkZHJlc3MoKS50b1N0cmluZygpfX0pO3ZhciBobWFwPXt9O291dHB1dHMuZm9yRWFjaChmdW5jdGlvbihvKXtobWFwW28ub3V0cHV0XT1vfSk7Zm9yKHZhciBpPTA7aTx0aGlzLmlucy5sZW5ndGg7aSsrKXt2YXIgb3V0cG9pbnQ9dGhpcy5pbnNbaV0ub3V0cG9pbnQuaGFzaCtcIjpcIit0aGlzLmluc1tpXS5vdXRwb2ludC5pbmRleDt2YXIgaGlzdEl0ZW09aG1hcFtvdXRwb2ludF07aWYoIWhpc3RJdGVtKWNvbnRpbnVlO3ZhciB0aGlzSW5wdXRBZGRyZGF0YT1hZGRyZGF0YS5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIGEuYWRkcmVzcz09aGlzdEl0ZW0uYWRkcmVzc30pO2lmKHRoaXNJbnB1dEFkZHJkYXRhLmxlbmd0aD09PTApY29udGludWU7dGhpcy5zaWduKGksdGhpc0lucHV0QWRkcmRhdGFbMF0ua2V5KX19O1RyYW5zYWN0aW9uLnByb3RvdHlwZS5wMnNoc2lnbj1mdW5jdGlvbihpbmRleCxzY3JpcHQsa2V5LHR5cGUpe3NjcmlwdD1uZXcgU2NyaXB0KHNjcmlwdCk7a2V5PW5ldyBFQ0tleShrZXkpO3R5cGU9dHlwZXx8U0lHSEFTSF9BTEw7dmFyIGhhc2g9dGhpcy5oYXNoVHJhbnNhY3Rpb25Gb3JTaWduYXR1cmUoc2NyaXB0LGluZGV4LHR5cGUpLHNpZz1rZXkuc2lnbihoYXNoKS5jb25jYXQoW3R5cGVdKTtyZXR1cm4gc2lnfTtUcmFuc2FjdGlvbi5wcm90b3R5cGUubXVsdGlzaWduPVRyYW5zYWN0aW9uLnByb3RvdHlwZS5wMnNoc2lnbjtUcmFuc2FjdGlvbi5wcm90b3R5cGUuYXBwbHlNdWx0aXNpZ3M9ZnVuY3Rpb24oaW5kZXgsc2NyaXB0LHNpZ3Mpe3RoaXMuaW5zW2luZGV4XS5zY3JpcHQ9U2NyaXB0LmNyZWF0ZU11bHRpU2lnSW5wdXRTY3JpcHQoc2lncyxzY3JpcHQpfTtUcmFuc2FjdGlvbi5wcm90b3R5cGUudmFsaWRhdGVTaWc9ZnVuY3Rpb24oaW5kZXgsc2NyaXB0LHNpZyxwdWIpe3NjcmlwdD1uZXcgU2NyaXB0KHNjcmlwdCk7dmFyIGhhc2g9dGhpcy5oYXNoVHJhbnNhY3Rpb25Gb3JTaWduYXR1cmUoc2NyaXB0LGluZGV4LDEpO3JldHVybiBFQ0RTQS52ZXJpZnkoaGFzaCxjb252ZXJ0LmNvZXJjZVRvQnl0ZXMoc2lnKSxjb252ZXJ0LmNvZXJjZVRvQnl0ZXMocHViKSl9O1RyYW5zYWN0aW9uLmZlZVBlcktiPTJlNDtUcmFuc2FjdGlvbi5wcm90b3R5cGUuZXN0aW1hdGVGZWU9ZnVuY3Rpb24oZmVlUGVyS2Ipe3ZhciB1bmNvbXByZXNzZWRJblNpemU9MTgwO3ZhciBvdXRTaXplPTM0O3ZhciBmaXhlZFBhZGRpbmc9MzQ7aWYoZmVlUGVyS2I9PXVuZGVmaW5lZClmZWVQZXJLYj1UcmFuc2FjdGlvbi5mZWVQZXJLYjt2YXIgc2l6ZT10aGlzLmlucy5sZW5ndGgqdW5jb21wcmVzc2VkSW5TaXplK3RoaXMub3V0cy5sZW5ndGgqb3V0U2l6ZStmaXhlZFBhZGRpbmc7cmV0dXJuIGZlZVBlcktiKk1hdGguY2VpbChzaXplLzFlMyl9O3ZhciBUcmFuc2FjdGlvbkluPWZ1bmN0aW9uKGRhdGEpe2lmKHR5cGVvZiBkYXRhPT1cInN0cmluZ1wiKXt0aGlzLm91dHBvaW50PXtoYXNoOmRhdGEuc3BsaXQoXCI6XCIpWzBdLGluZGV4OmRhdGEuc3BsaXQoXCI6XCIpWzFdfX1lbHNlIGlmKGRhdGEub3V0cG9pbnQpe3RoaXMub3V0cG9pbnQ9ZGF0YS5vdXRwb2ludH1lbHNle3RoaXMub3V0cG9pbnQ9e2hhc2g6ZGF0YS5oYXNoLGluZGV4OmRhdGEuaW5kZXh9fWlmKGRhdGEuc2NyaXB0U2lnKXt0aGlzLnNjcmlwdD1TY3JpcHQuZnJvbVNjcmlwdFNpZyhkYXRhLnNjcmlwdFNpZyl9ZWxzZSBpZihkYXRhLnNjcmlwdCl7dGhpcy5zY3JpcHQ9ZGF0YS5zY3JpcHR9ZWxzZXt0aGlzLnNjcmlwdD1uZXcgU2NyaXB0KGRhdGEuc2NyaXB0KX10aGlzLnNlcXVlbmNlPWRhdGEuc2VxdWVuY2V8fHRoaXMuZGVmYXVsdFNlcXVlbmNlfTtUcmFuc2FjdGlvbkluLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgVHJhbnNhY3Rpb25Jbih7b3V0cG9pbnQ6e2hhc2g6dGhpcy5vdXRwb2ludC5oYXNoLGluZGV4OnRoaXMub3V0cG9pbnQuaW5kZXh9LHNjcmlwdDp0aGlzLnNjcmlwdC5jbG9uZSgpLHNlcXVlbmNlOnRoaXMuc2VxdWVuY2V9KX07dmFyIFRyYW5zYWN0aW9uT3V0PWZ1bmN0aW9uKGRhdGEpe3RoaXMuc2NyaXB0PWRhdGEuc2NyaXB0IGluc3RhbmNlb2YgU2NyaXB0P2RhdGEuc2NyaXB0LmNsb25lKCk6QXJyYXkuaXNBcnJheShkYXRhLnNjcmlwdCk/bmV3IFNjcmlwdChkYXRhLnNjcmlwdCk6dHlwZW9mIGRhdGEuc2NyaXB0PT1cInN0cmluZ1wiP25ldyBTY3JpcHQoY29udmVydC5oZXhUb0J5dGVzKGRhdGEuc2NyaXB0KSk6ZGF0YS5zY3JpcHRQdWJLZXk/U2NyaXB0LmZyb21TY3JpcHRTaWcoZGF0YS5zY3JpcHRQdWJLZXkpOmRhdGEuYWRkcmVzcz9TY3JpcHQuY3JlYXRlT3V0cHV0U2NyaXB0KGRhdGEuYWRkcmVzcyk6bmV3IFNjcmlwdDtpZih0aGlzLnNjcmlwdC5idWZmZXIubGVuZ3RoPjApdGhpcy5hZGRyZXNzPXRoaXMuc2NyaXB0LmdldFRvQWRkcmVzcygpO3RoaXMudmFsdWU9QXJyYXkuaXNBcnJheShkYXRhLnZhbHVlKT9jb252ZXJ0LmJ5dGVzVG9OdW0oZGF0YS52YWx1ZSk6XCJzdHJpbmdcIj09dHlwZW9mIGRhdGEudmFsdWU/cGFyc2VJbnQoZGF0YS52YWx1ZSk6ZGF0YS52YWx1ZSBpbnN0YW5jZW9mIEJpZ0ludGVnZXI/cGFyc2VJbnQoZGF0YS52YWx1ZS50b1N0cmluZygpKTpkYXRhLnZhbHVlfTtUcmFuc2FjdGlvbk91dC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgbmV3VHhvdXQ9bmV3IFRyYW5zYWN0aW9uT3V0KHtzY3JpcHQ6dGhpcy5zY3JpcHQuY2xvbmUoKSx2YWx1ZTp0aGlzLnZhbHVlfSk7cmV0dXJuIG5ld1R4b3V0fTtUcmFuc2FjdGlvbk91dC5wcm90b3R5cGUuc2NyaXB0UHViS2V5PWZ1bmN0aW9uKCl7cmV0dXJuIGNvbnZlcnQuYnl0ZXNUb0hleCh0aGlzLnNjcmlwdC5idWZmZXIpfTttb2R1bGUuZXhwb3J0cz17VHJhbnNhY3Rpb246VHJhbnNhY3Rpb24sVHJhbnNhY3Rpb25JbjpUcmFuc2FjdGlvbkluLFRyYW5zYWN0aW9uT3V0OlRyYW5zYWN0aW9uT3V0fX0se1wiLi9hZGRyZXNzXCI6NTQsXCIuL2NvbnZlcnRcIjo1NyxcIi4vZWNkc2FcIjo1OCxcIi4vZWNrZXlcIjo1OSxcIi4vanNibi9qc2JuXCI6NjMsXCIuL3NjcmlwdFwiOjY4LFwiLi91dGlsXCI6NzAsXCJjcnlwdG8tanMvc2hhMjU2XCI6NDd9XSw3MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIGNvbnZlcnQ9X2RlcmVxXyhcIi4vY29udmVydC5qc1wiKTt2YXIgQ3J5cHRvPV9kZXJlcV8oXCJjcnlwdG8tanNcIik7dmFyIFJJUEVNRDE2MD1DcnlwdG8uUklQRU1EMTYwO3ZhciBTSEEyNTY9Q3J5cHRvLlNIQTI1NjtleHBvcnRzLnNoYTI1NnJpcGUxNjA9ZnVuY3Rpb24oZGF0YSl7dmFyIHdvcmRBcnJheT1SSVBFTUQxNjAoU0hBMjU2KGNvbnZlcnQuYnl0ZXNUb1dvcmRBcnJheShkYXRhKSkpO3JldHVybiBjb252ZXJ0LndvcmRBcnJheVRvQnl0ZXMod29yZEFycmF5KX07ZXhwb3J0cy5lcnJvcj1mdW5jdGlvbihtc2cpe3Rocm93IG5ldyBFcnJvcihtc2cpfX0se1wiLi9jb252ZXJ0LmpzXCI6NTcsXCJjcnlwdG8tanNcIjoyN31dLDcxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocHJvY2Vzcyl7dmFyIGNvbnZlcnQ9X2RlcmVxXyhcIi4vY29udmVydFwiKTt2YXIgVHJhbnNhY3Rpb249X2RlcmVxXyhcIi4vdHJhbnNhY3Rpb25cIikuVHJhbnNhY3Rpb247dmFyIEhETm9kZT1fZGVyZXFfKFwiLi9oZHdhbGxldC5qc1wiKTt2YXIgcm5nPV9kZXJlcV8oXCJzZWN1cmUtcmFuZG9tXCIpO2Z1bmN0aW9uIFdhbGxldChzZWVkLG9wdGlvbnMpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFdhbGxldCkpe3JldHVybiBuZXcgV2FsbGV0KHNlZWQsb3B0aW9ucyl9dmFyIG9wdGlvbnM9b3B0aW9uc3x8e307dmFyIG5ldHdvcms9b3B0aW9ucy5uZXR3b3JrfHxcIm1haW5uZXRcIjt2YXIgbWFzdGVya2V5PW51bGw7dmFyIG1lPXRoaXM7dmFyIGFjY291bnRaZXJvPW51bGw7dmFyIGludGVybmFsQWNjb3VudD1udWxsO3ZhciBleHRlcm5hbEFjY291bnQ9bnVsbDt0aGlzLmFkZHJlc3Nlcz1bXTt0aGlzLmNoYW5nZUFkZHJlc3Nlcz1bXTt0aGlzLm91dHB1dHM9e307dGhpcy5uZXdNYXN0ZXJLZXk9ZnVuY3Rpb24oc2VlZCxuZXR3b3JrKXtpZighc2VlZClzZWVkPXJuZygzMix7YXJyYXk6dHJ1ZX0pO21hc3RlcmtleT1uZXcgSEROb2RlKHNlZWQsbmV0d29yayk7YWNjb3VudFplcm89bWFzdGVya2V5LmRlcml2ZVByaXZhdGUoMCk7ZXh0ZXJuYWxBY2NvdW50PWFjY291bnRaZXJvLmRlcml2ZSgwKTtpbnRlcm5hbEFjY291bnQ9YWNjb3VudFplcm8uZGVyaXZlKDEpO21lLmFkZHJlc3Nlcz1bXTttZS5jaGFuZ2VBZGRyZXNzZXM9W107bWUub3V0cHV0cz17fX07dGhpcy5uZXdNYXN0ZXJLZXkoc2VlZCxuZXR3b3JrKTt0aGlzLmdlbmVyYXRlQWRkcmVzcz1mdW5jdGlvbigpe3ZhciBrZXk9ZXh0ZXJuYWxBY2NvdW50LmRlcml2ZSh0aGlzLmFkZHJlc3Nlcy5sZW5ndGgpO3RoaXMuYWRkcmVzc2VzLnB1c2goa2V5LmdldEFkZHJlc3MoKS50b1N0cmluZygpKTtyZXR1cm4gdGhpcy5hZGRyZXNzZXNbdGhpcy5hZGRyZXNzZXMubGVuZ3RoLTFdfTt0aGlzLmdlbmVyYXRlQ2hhbmdlQWRkcmVzcz1mdW5jdGlvbigpe3ZhciBrZXk9aW50ZXJuYWxBY2NvdW50LmRlcml2ZSh0aGlzLmNoYW5nZUFkZHJlc3Nlcy5sZW5ndGgpO3RoaXMuY2hhbmdlQWRkcmVzc2VzLnB1c2goa2V5LmdldEFkZHJlc3MoKS50b1N0cmluZygpKTtyZXR1cm4gdGhpcy5jaGFuZ2VBZGRyZXNzZXNbdGhpcy5jaGFuZ2VBZGRyZXNzZXMubGVuZ3RoLTFdfTt0aGlzLmdldEJhbGFuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRVbnNwZW50T3V0cHV0cygpLnJlZHVjZShmdW5jdGlvbihtZW1vLG91dHB1dCl7cmV0dXJuIG1lbW8rb3V0cHV0LnZhbHVlfSwwKX07dGhpcy5nZXRVbnNwZW50T3V0cHV0cz1mdW5jdGlvbigpe3ZhciB1dHhvPVtdO2Zvcih2YXIga2V5IGluIHRoaXMub3V0cHV0cyl7dmFyIG91dHB1dD10aGlzLm91dHB1dHNba2V5XTtpZighb3V0cHV0LnNwZW5kKXV0eG8ucHVzaChvdXRwdXRUb1Vuc3BlbnRPdXRwdXQob3V0cHV0KSl9cmV0dXJuIHV0eG99O3RoaXMuc2V0VW5zcGVudE91dHB1dHM9ZnVuY3Rpb24odXR4byl7dmFyIG91dHB1dHM9e307dXR4by5mb3JFYWNoKGZ1bmN0aW9uKHVvKXt2YWxpZGF0ZVVuc3BlbnRPdXRwdXQodW8pO3ZhciBvPXVuc3BlbnRPdXRwdXRUb091dHB1dCh1byk7b3V0cHV0c1tvLnJlY2VpdmVdPW99KTt0aGlzLm91dHB1dHM9b3V0cHV0c307dGhpcy5zZXRVbnNwZW50T3V0cHV0c0FzeW5jPWZ1bmN0aW9uKHV0eG8sY2FsbGJhY2spe3ZhciBlcnJvcj1udWxsO3RyeXt0aGlzLnNldFVuc3BlbnRPdXRwdXRzKHV0eG8pfWNhdGNoKGVycil7ZXJyb3I9ZXJyfWZpbmFsbHl7cHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpe2NhbGxiYWNrKGVycm9yKX0pfX07ZnVuY3Rpb24gb3V0cHV0VG9VbnNwZW50T3V0cHV0KG91dHB1dCl7dmFyIGhhc2hBbmRJbmRleD1vdXRwdXQucmVjZWl2ZS5zcGxpdChcIjpcIik7cmV0dXJue2hhc2g6aGFzaEFuZEluZGV4WzBdLGhhc2hMaXR0bGVFbmRpYW46Y29udmVydC5yZXZlcnNlRW5kaWFuKGhhc2hBbmRJbmRleFswXSksb3V0cHV0SW5kZXg6cGFyc2VJbnQoaGFzaEFuZEluZGV4WzFdKSxhZGRyZXNzOm91dHB1dC5hZGRyZXNzLHZhbHVlOm91dHB1dC52YWx1ZX19ZnVuY3Rpb24gdW5zcGVudE91dHB1dFRvT3V0cHV0KG8pe3ZhciBoYXNoPW8uaGFzaHx8Y29udmVydC5yZXZlcnNlRW5kaWFuKG8uaGFzaExpdHRsZUVuZGlhbik7dmFyIGtleT1oYXNoK1wiOlwiK28ub3V0cHV0SW5kZXg7cmV0dXJue3JlY2VpdmU6a2V5LGFkZHJlc3M6by5hZGRyZXNzLHZhbHVlOm8udmFsdWV9fWZ1bmN0aW9uIHZhbGlkYXRlVW5zcGVudE91dHB1dCh1byl7dmFyIG1pc3NpbmdGaWVsZDtpZihpc051bGxPclVuZGVmaW5lZCh1by5oYXNoKSYmaXNOdWxsT3JVbmRlZmluZWQodW8uaGFzaExpdHRsZUVuZGlhbikpe21pc3NpbmdGaWVsZD1cImhhc2gob3IgaGFzaExpdHRsZUVuZGlhbilcIn12YXIgcmVxdWlyZWRLZXlzPVtcIm91dHB1dEluZGV4XCIsXCJhZGRyZXNzXCIsXCJ2YWx1ZVwiXTtyZXF1aXJlZEtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpe2lmKGlzTnVsbE9yVW5kZWZpbmVkKHVvW2tleV0pKXttaXNzaW5nRmllbGQ9a2V5fX0pO2lmKG1pc3NpbmdGaWVsZCl7dmFyIG1lc3NhZ2U9W1wiSW52YWxpZCB1bnNwZW50IG91dHB1dDoga2V5XCIsbWlzc2luZ0ZpZWxkLFwiaXMgbWlzc2luZy5cIixcIkEgdmFsaWQgdW5zcGVudCBvdXRwdXQgbXVzdCBjb250YWluXCJdO21lc3NhZ2UucHVzaChyZXF1aXJlZEtleXMuam9pbihcIiwgXCIpKTttZXNzYWdlLnB1c2goXCJhbmQgaGFzaChvciBoYXNoTGl0dGxlRW5kaWFuKVwiKTt0aHJvdyBuZXcgRXJyb3IobWVzc2FnZS5qb2luKFwiIFwiKSl9fWZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKXtyZXR1cm4gdmFsdWU9PXVuZGVmaW5lZH10aGlzLnByb2Nlc3NUeD1mdW5jdGlvbih0eCl7dmFyIHR4aGFzaD1jb252ZXJ0LmJ5dGVzVG9IZXgodHguZ2V0SGFzaCgpKTt0eC5vdXRzLmZvckVhY2goZnVuY3Rpb24odHhPdXQsaSl7dmFyIGFkZHJlc3M9dHhPdXQuYWRkcmVzcy50b1N0cmluZygpO2lmKGlzTXlBZGRyZXNzKGFkZHJlc3MpKXt2YXIgb3V0cHV0PXR4aGFzaCtcIjpcIitpO21lLm91dHB1dHNbb3V0cHV0XT17cmVjZWl2ZTpvdXRwdXQsdmFsdWU6dHhPdXQudmFsdWUsYWRkcmVzczphZGRyZXNzfX19KTt0eC5pbnMuZm9yRWFjaChmdW5jdGlvbih0eEluLGkpe3ZhciBvcD10eEluLm91dHBvaW50O3ZhciBvPW1lLm91dHB1dHNbb3AuaGFzaCtcIjpcIitvcC5pbmRleF07aWYobyl7by5zcGVuZD10eGhhc2grXCI6XCIraX19KX07dGhpcy5jcmVhdGVUeD1mdW5jdGlvbih0byx2YWx1ZSxmaXhlZEZlZSl7Y2hlY2tEdXN0KHZhbHVlKTt2YXIgdHg9bmV3IFRyYW5zYWN0aW9uO3R4LmFkZE91dHB1dCh0byx2YWx1ZSk7dmFyIHV0eG89Z2V0Q2FuZGlkYXRlT3V0cHV0cyh2YWx1ZSk7dmFyIHRvdGFsSW5WYWx1ZT0wO2Zvcih2YXIgaT0wO2k8dXR4by5sZW5ndGg7aSsrKXt2YXIgb3V0cHV0PXV0eG9baV07dHguYWRkSW5wdXQob3V0cHV0LnJlY2VpdmUpO3RvdGFsSW5WYWx1ZSs9b3V0cHV0LnZhbHVlO2lmKHRvdGFsSW5WYWx1ZTx2YWx1ZSljb250aW51ZTt2YXIgZmVlPWZpeGVkRmVlPT11bmRlZmluZWQ/ZXN0aW1hdGVGZWVQYWRDaGFuZ2VPdXRwdXQodHgpOmZpeGVkRmVlO2lmKHRvdGFsSW5WYWx1ZTx2YWx1ZStmZWUpY29udGludWU7dmFyIGNoYW5nZT10b3RhbEluVmFsdWUtdmFsdWUtZmVlO2lmKGNoYW5nZT4wJiYhaXNEdXN0KGNoYW5nZSkpe3R4LmFkZE91dHB1dChnZXRDaGFuZ2VBZGRyZXNzKCksY2hhbmdlKX1icmVha31jaGVja0luc3VmZmljaWVudEZ1bmQodG90YWxJblZhbHVlLHZhbHVlLGZlZSk7dGhpcy5zaWduKHR4KTtyZXR1cm4gdHh9O3RoaXMuY3JlYXRlVHhBc3luYz1mdW5jdGlvbih0byx2YWx1ZSxmaXhlZEZlZSxjYWxsYmFjayl7aWYoZml4ZWRGZWUgaW5zdGFuY2VvZiBGdW5jdGlvbil7Y2FsbGJhY2s9Zml4ZWRGZWU7Zml4ZWRGZWU9dW5kZWZpbmVkfXZhciB0eD1udWxsO3ZhciBlcnJvcj1udWxsO3RyeXt0eD10aGlzLmNyZWF0ZVR4KHRvLHZhbHVlLGZpeGVkRmVlKX1jYXRjaChlcnIpe2Vycm9yPWVycn1maW5hbGx5e3Byb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKXtjYWxsYmFjayhlcnJvcix0eCl9KX19O3RoaXMuZHVzdFRocmVzaG9sZD01NDMwO2Z1bmN0aW9uIGlzRHVzdChhbW91bnQpe3JldHVybiBhbW91bnQ8PW1lLmR1c3RUaHJlc2hvbGR9ZnVuY3Rpb24gY2hlY2tEdXN0KHZhbHVlKXtpZihpc051bGxPclVuZGVmaW5lZCh2YWx1ZSl8fGlzRHVzdCh2YWx1ZSkpe3Rocm93IG5ldyBFcnJvcihcIlZhbHVlIG11c3QgYmUgYWJvdmUgZHVzdCB0aHJlc2hvbGRcIil9fWZ1bmN0aW9uIGdldENhbmRpZGF0ZU91dHB1dHModmFsdWUpe3ZhciB1bnNwZW50PVtdO2Zvcih2YXIga2V5IGluIG1lLm91dHB1dHMpe3ZhciBvdXRwdXQ9bWUub3V0cHV0c1trZXldO2lmKCFvdXRwdXQuc3BlbmQpdW5zcGVudC5wdXNoKG91dHB1dCl9dmFyIHNvcnRCeVZhbHVlRGVzYz11bnNwZW50LnNvcnQoZnVuY3Rpb24obzEsbzIpe3JldHVybiBvMi52YWx1ZS1vMS52YWx1ZX0pO3JldHVybiBzb3J0QnlWYWx1ZURlc2N9ZnVuY3Rpb24gZXN0aW1hdGVGZWVQYWRDaGFuZ2VPdXRwdXQodHgpe3ZhciB0bXBUeD10eC5jbG9uZSgpO3RtcFR4LmFkZE91dHB1dChnZXRDaGFuZ2VBZGRyZXNzKCksMCk7cmV0dXJuIHRtcFR4LmVzdGltYXRlRmVlKCl9ZnVuY3Rpb24gZ2V0Q2hhbmdlQWRkcmVzcygpe2lmKG1lLmNoYW5nZUFkZHJlc3Nlcy5sZW5ndGg9PT0wKW1lLmdlbmVyYXRlQ2hhbmdlQWRkcmVzcygpO3JldHVybiBtZS5jaGFuZ2VBZGRyZXNzZXNbbWUuY2hhbmdlQWRkcmVzc2VzLmxlbmd0aC0xXX1mdW5jdGlvbiBjaGVja0luc3VmZmljaWVudEZ1bmQodG90YWxJblZhbHVlLHZhbHVlLGZlZSl7aWYodG90YWxJblZhbHVlPHZhbHVlK2ZlZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IGVub3VnaCBtb25leSB0byBzZW5kIGZ1bmRzIGluY2x1ZGluZyB0cmFuc2FjdGlvbiBmZWUuIEhhdmU6IFwiK3RvdGFsSW5WYWx1ZStcIiwgbmVlZGVkOiBcIisodmFsdWUrZmVlKSl9fXRoaXMuc2lnbj1mdW5jdGlvbih0eCl7dHguaW5zLmZvckVhY2goZnVuY3Rpb24oaW5wLGkpe3ZhciBvdXRwdXQ9bWUub3V0cHV0c1tpbnAub3V0cG9pbnQuaGFzaCtcIjpcIitpbnAub3V0cG9pbnQuaW5kZXhdO2lmKG91dHB1dCl7dHguc2lnbihpLG1lLmdldFByaXZhdGVLZXlGb3JBZGRyZXNzKG91dHB1dC5hZGRyZXNzKSl9fSk7cmV0dXJuIHR4fTt0aGlzLmdldE1hc3RlcktleT1mdW5jdGlvbigpe3JldHVybiBtYXN0ZXJrZXl9O3RoaXMuZ2V0QWNjb3VudFplcm89ZnVuY3Rpb24oKXtyZXR1cm4gYWNjb3VudFplcm99O3RoaXMuZ2V0SW50ZXJuYWxBY2NvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIGludGVybmFsQWNjb3VudH07dGhpcy5nZXRFeHRlcm5hbEFjY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gZXh0ZXJuYWxBY2NvdW50fTt0aGlzLmdldFByaXZhdGVLZXk9ZnVuY3Rpb24oaW5kZXgpe3JldHVybiBleHRlcm5hbEFjY291bnQuZGVyaXZlKGluZGV4KS5wcml2fTt0aGlzLmdldEludGVybmFsUHJpdmF0ZUtleT1mdW5jdGlvbihpbmRleCl7cmV0dXJuIGludGVybmFsQWNjb3VudC5kZXJpdmUoaW5kZXgpLnByaXZ9O3RoaXMuZ2V0UHJpdmF0ZUtleUZvckFkZHJlc3M9ZnVuY3Rpb24oYWRkcmVzcyl7dmFyIGluZGV4O2lmKChpbmRleD10aGlzLmFkZHJlc3Nlcy5pbmRleE9mKGFkZHJlc3MpKT4tMSl7cmV0dXJuIHRoaXMuZ2V0UHJpdmF0ZUtleShpbmRleCl9ZWxzZSBpZigoaW5kZXg9dGhpcy5jaGFuZ2VBZGRyZXNzZXMuaW5kZXhPZihhZGRyZXNzKSk+LTEpe3JldHVybiB0aGlzLmdldEludGVybmFsUHJpdmF0ZUtleShpbmRleCl9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFkZHJlc3MuIE1ha2Ugc3VyZSB0aGUgYWRkcmVzcyBpcyBmcm9tIHRoZSBrZXljaGFpbiBhbmQgaGFzIGJlZW4gZ2VuZXJhdGVkLlwiKX19O2Z1bmN0aW9uIGlzUmVjZWl2ZUFkZHJlc3MoYWRkcmVzcyl7cmV0dXJuIG1lLmFkZHJlc3Nlcy5pbmRleE9mKGFkZHJlc3MpPi0xfWZ1bmN0aW9uIGlzQ2hhbmdlQWRkcmVzcyhhZGRyZXNzKXtyZXR1cm4gbWUuY2hhbmdlQWRkcmVzc2VzLmluZGV4T2YoYWRkcmVzcyk+LTF9ZnVuY3Rpb24gaXNNeUFkZHJlc3MoYWRkcmVzcyl7cmV0dXJuIGlzUmVjZWl2ZUFkZHJlc3MoYWRkcmVzcyl8fGlzQ2hhbmdlQWRkcmVzcyhhZGRyZXNzKX19bW9kdWxlLmV4cG9ydHM9V2FsbGV0fSkuY2FsbCh0aGlzLF9kZXJlcV8oXCJGV2FBU0hcIikpfSx7XCIuL2NvbnZlcnRcIjo1NyxcIi4vaGR3YWxsZXQuanNcIjo2MCxcIi4vdHJhbnNhY3Rpb25cIjo2OSxGV2FBU0g6MTUsXCJzZWN1cmUtcmFuZG9tXCI6NTN9XX0se30sWzYxXSkoNjEpfSk7IiwiLyohIHBlZXJqcy5qcyBidWlsZDowLjMuOCwgZGV2ZWxvcG1lbnQuIENvcHlyaWdodChjKSAyMDEzIE1pY2hlbGxlIEJ1IDxtaWNoZWxsZUBtaWNoZWxsZWJ1LmNvbT4gKi9cbihmdW5jdGlvbihleHBvcnRzKXtcbiAgLy9IYWNrIHRvIGdldCBwZWVyLmpzIHRvIHdvcmsgaW4gYSB3b3JrZXJcbiAgaWYodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgdmFyIHdpbmRvdz17fTtcbiAgfVxudmFyIGJpbmFyeUZlYXR1cmVzID0ge307XG5iaW5hcnlGZWF0dXJlcy51c2VCbG9iQnVpbGRlciA9IChmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIG5ldyBCbG9iKFtdKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSkoKTtcblxuYmluYXJ5RmVhdHVyZXMudXNlQXJyYXlCdWZmZXJWaWV3ID0gIWJpbmFyeUZlYXR1cmVzLnVzZUJsb2JCdWlsZGVyICYmIChmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIHJldHVybiAobmV3IEJsb2IoW25ldyBVaW50OEFycmF5KFtdKV0pKS5zaXplID09PSAwO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0pKCk7XG5cbmV4cG9ydHMuYmluYXJ5RmVhdHVyZXMgPSBiaW5hcnlGZWF0dXJlcztcblxuXG4gIGV4cG9ydHMuQmxvYkJ1aWxkZXIgPSB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1vekJsb2JCdWlsZGVyIHx8IHdpbmRvdy5NU0Jsb2JCdWlsZGVyIHx8IHdpbmRvdy5CbG9iQnVpbGRlcjtcblxuXG4gIGZ1bmN0aW9uIEJ1ZmZlckJ1aWxkZXIoKXtcbiAgdGhpcy5fcGllY2VzID0gW107XG4gIHRoaXMuX3BhcnRzID0gW107XG59XG5cbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgaWYodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5fcGllY2VzLnB1c2goZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICAgIHRoaXMuX3BhcnRzLnB1c2goZGF0YSk7XG4gIH1cbn07XG5cbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9waWVjZXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLl9waWVjZXMpO1xuICAgIGlmKCFiaW5hcnlGZWF0dXJlcy51c2VBcnJheUJ1ZmZlclZpZXcpIHtcbiAgICAgIGJ1ZiA9IGJ1Zi5idWZmZXI7XG4gICAgfVxuICAgIHRoaXMuX3BhcnRzLnB1c2goYnVmKTtcbiAgICB0aGlzLl9waWVjZXMgPSBbXTtcbiAgfVxufTtcblxuQnVmZmVyQnVpbGRlci5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZmx1c2goKTtcbiAgaWYoYmluYXJ5RmVhdHVyZXMudXNlQmxvYkJ1aWxkZXIpIHtcbiAgICB2YXIgYnVpbGRlciA9IG5ldyBCbG9iQnVpbGRlcigpO1xuICAgIGZvcih2YXIgaSA9IDAsIGlpID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgYnVpbGRlci5hcHBlbmQodGhpcy5fcGFydHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYnVpbGRlci5nZXRCbG9iKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBCbG9iKHRoaXMuX3BhcnRzKTtcbiAgfVxufTtcbmV4cG9ydHMuQmluYXJ5UGFjayA9IHtcbiAgdW5wYWNrOiBmdW5jdGlvbihkYXRhKXtcbiAgICB2YXIgdW5wYWNrZXIgPSBuZXcgVW5wYWNrZXIoZGF0YSk7XG4gICAgcmV0dXJuIHVucGFja2VyLnVucGFjaygpO1xuICB9LFxuICBwYWNrOiBmdW5jdGlvbihkYXRhKXtcbiAgICB2YXIgcGFja2VyID0gbmV3IFBhY2tlcigpO1xuICAgIHBhY2tlci5wYWNrKGRhdGEpO1xuICAgIHZhciBidWZmZXIgPSBwYWNrZXIuZ2V0QnVmZmVyKCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxufTtcblxuZnVuY3Rpb24gVW5wYWNrZXIgKGRhdGEpe1xuICAvLyBEYXRhIGlzIEFycmF5QnVmZmVyXG4gIHRoaXMuaW5kZXggPSAwO1xuICB0aGlzLmRhdGFCdWZmZXIgPSBkYXRhO1xuICB0aGlzLmRhdGFWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhQnVmZmVyKTtcbiAgdGhpcy5sZW5ndGggPSB0aGlzLmRhdGFCdWZmZXIuYnl0ZUxlbmd0aDtcbn1cblxuXG5VbnBhY2tlci5wcm90b3R5cGUudW5wYWNrID0gZnVuY3Rpb24oKXtcbiAgdmFyIHR5cGUgPSB0aGlzLnVucGFja191aW50OCgpO1xuICBpZiAodHlwZSA8IDB4ODApe1xuICAgIHZhciBwb3NpdGl2ZV9maXhudW0gPSB0eXBlO1xuICAgIHJldHVybiBwb3NpdGl2ZV9maXhudW07XG4gIH0gZWxzZSBpZiAoKHR5cGUgXiAweGUwKSA8IDB4MjApe1xuICAgIHZhciBuZWdhdGl2ZV9maXhudW0gPSAodHlwZSBeIDB4ZTApIC0gMHgyMDtcbiAgICByZXR1cm4gbmVnYXRpdmVfZml4bnVtO1xuICB9XG4gIHZhciBzaXplO1xuICBpZiAoKHNpemUgPSB0eXBlIF4gMHhhMCkgPD0gMHgwZil7XG4gICAgcmV0dXJuIHRoaXMudW5wYWNrX3JhdyhzaXplKTtcbiAgfSBlbHNlIGlmICgoc2l6ZSA9IHR5cGUgXiAweGIwKSA8PSAweDBmKXtcbiAgICByZXR1cm4gdGhpcy51bnBhY2tfc3RyaW5nKHNpemUpO1xuICB9IGVsc2UgaWYgKChzaXplID0gdHlwZSBeIDB4OTApIDw9IDB4MGYpe1xuICAgIHJldHVybiB0aGlzLnVucGFja19hcnJheShzaXplKTtcbiAgfSBlbHNlIGlmICgoc2l6ZSA9IHR5cGUgXiAweDgwKSA8PSAweDBmKXtcbiAgICByZXR1cm4gdGhpcy51bnBhY2tfbWFwKHNpemUpO1xuICB9XG4gIHN3aXRjaCh0eXBlKXtcbiAgICBjYXNlIDB4YzA6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIDB4YzE6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNhc2UgMHhjMjpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXNlIDB4YzM6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlIDB4Y2E6XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfZmxvYXQoKTtcbiAgICBjYXNlIDB4Y2I6XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfZG91YmxlKCk7XG4gICAgY2FzZSAweGNjOlxuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX3VpbnQ4KCk7XG4gICAgY2FzZSAweGNkOlxuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX3VpbnQxNigpO1xuICAgIGNhc2UgMHhjZTpcbiAgICAgIHJldHVybiB0aGlzLnVucGFja191aW50MzIoKTtcbiAgICBjYXNlIDB4Y2Y6XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfdWludDY0KCk7XG4gICAgY2FzZSAweGQwOlxuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX2ludDgoKTtcbiAgICBjYXNlIDB4ZDE6XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfaW50MTYoKTtcbiAgICBjYXNlIDB4ZDI6XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfaW50MzIoKTtcbiAgICBjYXNlIDB4ZDM6XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfaW50NjQoKTtcbiAgICBjYXNlIDB4ZDQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNhc2UgMHhkNTpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY2FzZSAweGQ2OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjYXNlIDB4ZDc6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNhc2UgMHhkODpcbiAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MTYoKTtcbiAgICAgIHJldHVybiB0aGlzLnVucGFja19zdHJpbmcoc2l6ZSk7XG4gICAgY2FzZSAweGQ5OlxuICAgICAgc2l6ZSA9IHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX3N0cmluZyhzaXplKTtcbiAgICBjYXNlIDB4ZGE6XG4gICAgICBzaXplID0gdGhpcy51bnBhY2tfdWludDE2KCk7XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfcmF3KHNpemUpO1xuICAgIGNhc2UgMHhkYjpcbiAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MzIoKTtcbiAgICAgIHJldHVybiB0aGlzLnVucGFja19yYXcoc2l6ZSk7XG4gICAgY2FzZSAweGRjOlxuICAgICAgc2l6ZSA9IHRoaXMudW5wYWNrX3VpbnQxNigpO1xuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX2FycmF5KHNpemUpO1xuICAgIGNhc2UgMHhkZDpcbiAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MzIoKTtcbiAgICAgIHJldHVybiB0aGlzLnVucGFja19hcnJheShzaXplKTtcbiAgICBjYXNlIDB4ZGU6XG4gICAgICBzaXplID0gdGhpcy51bnBhY2tfdWludDE2KCk7XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfbWFwKHNpemUpO1xuICAgIGNhc2UgMHhkZjpcbiAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MzIoKTtcbiAgICAgIHJldHVybiB0aGlzLnVucGFja19tYXAoc2l6ZSk7XG4gIH1cbn1cblxuVW5wYWNrZXIucHJvdG90eXBlLnVucGFja191aW50OCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBieXRlID0gdGhpcy5kYXRhVmlld1t0aGlzLmluZGV4XSAmIDB4ZmY7XG4gIHRoaXMuaW5kZXgrKztcbiAgcmV0dXJuIGJ5dGU7XG59O1xuXG5VbnBhY2tlci5wcm90b3R5cGUudW5wYWNrX3VpbnQxNiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBieXRlcyA9IHRoaXMucmVhZCgyKTtcbiAgdmFyIHVpbnQxNiA9XG4gICAgKChieXRlc1swXSAmIDB4ZmYpICogMjU2KSArIChieXRlc1sxXSAmIDB4ZmYpO1xuICB0aGlzLmluZGV4ICs9IDI7XG4gIHJldHVybiB1aW50MTY7XG59XG5cblVucGFja2VyLnByb3RvdHlwZS51bnBhY2tfdWludDMyID0gZnVuY3Rpb24oKXtcbiAgdmFyIGJ5dGVzID0gdGhpcy5yZWFkKDQpO1xuICB2YXIgdWludDMyID1cbiAgICAgKChieXRlc1swXSAgKiAyNTYgK1xuICAgICAgIGJ5dGVzWzFdKSAqIDI1NiArXG4gICAgICAgYnl0ZXNbMl0pICogMjU2ICtcbiAgICAgICBieXRlc1szXTtcbiAgdGhpcy5pbmRleCArPSA0O1xuICByZXR1cm4gdWludDMyO1xufVxuXG5VbnBhY2tlci5wcm90b3R5cGUudW5wYWNrX3VpbnQ2NCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBieXRlcyA9IHRoaXMucmVhZCg4KTtcbiAgdmFyIHVpbnQ2NCA9XG4gICAoKCgoKChieXRlc1swXSAgKiAyNTYgK1xuICAgICAgIGJ5dGVzWzFdKSAqIDI1NiArXG4gICAgICAgYnl0ZXNbMl0pICogMjU2ICtcbiAgICAgICBieXRlc1szXSkgKiAyNTYgK1xuICAgICAgIGJ5dGVzWzRdKSAqIDI1NiArXG4gICAgICAgYnl0ZXNbNV0pICogMjU2ICtcbiAgICAgICBieXRlc1s2XSkgKiAyNTYgK1xuICAgICAgIGJ5dGVzWzddO1xuICB0aGlzLmluZGV4ICs9IDg7XG4gIHJldHVybiB1aW50NjQ7XG59XG5cblxuVW5wYWNrZXIucHJvdG90eXBlLnVucGFja19pbnQ4ID0gZnVuY3Rpb24oKXtcbiAgdmFyIHVpbnQ4ID0gdGhpcy51bnBhY2tfdWludDgoKTtcbiAgcmV0dXJuICh1aW50OCA8IDB4ODAgKSA/IHVpbnQ4IDogdWludDggLSAoMSA8PCA4KTtcbn07XG5cblVucGFja2VyLnByb3RvdHlwZS51bnBhY2tfaW50MTYgPSBmdW5jdGlvbigpe1xuICB2YXIgdWludDE2ID0gdGhpcy51bnBhY2tfdWludDE2KCk7XG4gIHJldHVybiAodWludDE2IDwgMHg4MDAwICkgPyB1aW50MTYgOiB1aW50MTYgLSAoMSA8PCAxNik7XG59XG5cblVucGFja2VyLnByb3RvdHlwZS51bnBhY2tfaW50MzIgPSBmdW5jdGlvbigpe1xuICB2YXIgdWludDMyID0gdGhpcy51bnBhY2tfdWludDMyKCk7XG4gIHJldHVybiAodWludDMyIDwgTWF0aC5wb3coMiwgMzEpICkgPyB1aW50MzIgOlxuICAgIHVpbnQzMiAtIE1hdGgucG93KDIsIDMyKTtcbn1cblxuVW5wYWNrZXIucHJvdG90eXBlLnVucGFja19pbnQ2NCA9IGZ1bmN0aW9uKCl7XG4gIHZhciB1aW50NjQgPSB0aGlzLnVucGFja191aW50NjQoKTtcbiAgcmV0dXJuICh1aW50NjQgPCBNYXRoLnBvdygyLCA2MykgKSA/IHVpbnQ2NCA6XG4gICAgdWludDY0IC0gTWF0aC5wb3coMiwgNjQpO1xufVxuXG5VbnBhY2tlci5wcm90b3R5cGUudW5wYWNrX3JhdyA9IGZ1bmN0aW9uKHNpemUpe1xuICBpZiAoIHRoaXMubGVuZ3RoIDwgdGhpcy5pbmRleCArIHNpemUpe1xuICAgIHRocm93IG5ldyBFcnJvcignQmluYXJ5UGFja0ZhaWx1cmU6IGluZGV4IGlzIG91dCBvZiByYW5nZSdcbiAgICAgICsgJyAnICsgdGhpcy5pbmRleCArICcgJyArIHNpemUgKyAnICcgKyB0aGlzLmxlbmd0aCk7XG4gIH1cbiAgdmFyIGJ1ZiA9IHRoaXMuZGF0YUJ1ZmZlci5zbGljZSh0aGlzLmluZGV4LCB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gIHRoaXMuaW5kZXggKz0gc2l6ZTtcblxuICAgIC8vYnVmID0gdXRpbC5idWZmZXJUb1N0cmluZyhidWYpO1xuXG4gIHJldHVybiBidWY7XG59XG5cblVucGFja2VyLnByb3RvdHlwZS51bnBhY2tfc3RyaW5nID0gZnVuY3Rpb24oc2l6ZSl7XG4gIHZhciBieXRlcyA9IHRoaXMucmVhZChzaXplKTtcbiAgdmFyIGkgPSAwLCBzdHIgPSAnJywgYywgY29kZTtcbiAgd2hpbGUoaSA8IHNpemUpe1xuICAgIGMgPSBieXRlc1tpXTtcbiAgICBpZiAoIGMgPCAxMjgpe1xuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICBpKys7XG4gICAgfSBlbHNlIGlmICgoYyBeIDB4YzApIDwgMzIpe1xuICAgICAgY29kZSA9ICgoYyBeIDB4YzApIDw8IDYpIHwgKGJ5dGVzW2krMV0gJiA2Myk7XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgIGkgKz0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSA9ICgoYyAmIDE1KSA8PCAxMikgfCAoKGJ5dGVzW2krMV0gJiA2MykgPDwgNikgfFxuICAgICAgICAoYnl0ZXNbaSsyXSAmIDYzKTtcbiAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgaSArPSAzO1xuICAgIH1cbiAgfVxuICB0aGlzLmluZGV4ICs9IHNpemU7XG4gIHJldHVybiBzdHI7XG59XG5cblVucGFja2VyLnByb3RvdHlwZS51bnBhY2tfYXJyYXkgPSBmdW5jdGlvbihzaXplKXtcbiAgdmFyIG9iamVjdHMgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplIDsgaSsrKXtcbiAgICBvYmplY3RzW2ldID0gdGhpcy51bnBhY2soKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0cztcbn1cblxuVW5wYWNrZXIucHJvdG90eXBlLnVucGFja19tYXAgPSBmdW5jdGlvbihzaXplKXtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZSA7IGkrKyl7XG4gICAgdmFyIGtleSAgPSB0aGlzLnVucGFjaygpO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudW5wYWNrKCk7XG4gICAgbWFwW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gbWFwO1xufVxuXG5VbnBhY2tlci5wcm90b3R5cGUudW5wYWNrX2Zsb2F0ID0gZnVuY3Rpb24oKXtcbiAgdmFyIHVpbnQzMiA9IHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICB2YXIgc2lnbiA9IHVpbnQzMiA+PiAzMTtcbiAgdmFyIGV4cCAgPSAoKHVpbnQzMiA+PiAyMykgJiAweGZmKSAtIDEyNztcbiAgdmFyIGZyYWN0aW9uID0gKCB1aW50MzIgJiAweDdmZmZmZiApIHwgMHg4MDAwMDA7XG4gIHJldHVybiAoc2lnbiA9PSAwID8gMSA6IC0xKSAqXG4gICAgZnJhY3Rpb24gKiBNYXRoLnBvdygyLCBleHAgLSAyMyk7XG59XG5cblVucGFja2VyLnByb3RvdHlwZS51bnBhY2tfZG91YmxlID0gZnVuY3Rpb24oKXtcbiAgdmFyIGgzMiA9IHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICB2YXIgbDMyID0gdGhpcy51bnBhY2tfdWludDMyKCk7XG4gIHZhciBzaWduID0gaDMyID4+IDMxO1xuICB2YXIgZXhwICA9ICgoaDMyID4+IDIwKSAmIDB4N2ZmKSAtIDEwMjM7XG4gIHZhciBoZnJhYyA9ICggaDMyICYgMHhmZmZmZiApIHwgMHgxMDAwMDA7XG4gIHZhciBmcmFjID0gaGZyYWMgKiBNYXRoLnBvdygyLCBleHAgLSAyMCkgK1xuICAgIGwzMiAgICogTWF0aC5wb3coMiwgZXhwIC0gNTIpO1xuICByZXR1cm4gKHNpZ24gPT0gMCA/IDEgOiAtMSkgKiBmcmFjO1xufVxuXG5VbnBhY2tlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKGxlbmd0aCl7XG4gIHZhciBqID0gdGhpcy5pbmRleDtcbiAgaWYgKGogKyBsZW5ndGggPD0gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhVmlldy5zdWJhcnJheShqLCBqICsgbGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpbmFyeVBhY2tGYWlsdXJlOiByZWFkIGluZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFBhY2tlcigpe1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIgPSBuZXcgQnVmZmVyQnVpbGRlcigpO1xufVxuXG5QYWNrZXIucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLmJ1ZmZlckJ1aWxkZXIuZ2V0QnVmZmVyKCk7XG59XG5cblBhY2tlci5wcm90b3R5cGUucGFjayA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHR5cGUgPSB0eXBlb2YodmFsdWUpO1xuICBpZiAodHlwZSA9PSAnc3RyaW5nJyl7XG4gICAgdGhpcy5wYWNrX3N0cmluZyh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PSAnbnVtYmVyJyl7XG4gICAgaWYgKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSl7XG4gICAgICB0aGlzLnBhY2tfaW50ZWdlcih2YWx1ZSk7XG4gICAgfSBlbHNle1xuICAgICAgdGhpcy5wYWNrX2RvdWJsZSh2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nKXtcbiAgICBpZiAodmFsdWUgPT09IHRydWUpe1xuICAgICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgweGMzKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBmYWxzZSl7XG4gICAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4YzIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09ICd1bmRlZmluZWQnKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4YzApO1xuICB9IGVsc2UgaWYgKHR5cGUgPT0gJ29iamVjdCcpe1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCl7XG4gICAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4YzApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChjb25zdHJ1Y3RvciA9PSBBcnJheSl7XG4gICAgICAgIHRoaXMucGFja19hcnJheSh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yID09IEJsb2IgfHwgY29uc3RydWN0b3IgPT0gRmlsZSkge1xuICAgICAgICB0aGlzLnBhY2tfYmluKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uc3RydWN0b3IgPT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgaWYoYmluYXJ5RmVhdHVyZXMudXNlQXJyYXlCdWZmZXJWaWV3KSB7XG4gICAgICAgICAgdGhpcy5wYWNrX2JpbihuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFja19iaW4odmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCdCWVRFU19QRVJfRUxFTUVOVCcgaW4gdmFsdWUpe1xuICAgICAgICBpZihiaW5hcnlGZWF0dXJlcy51c2VBcnJheUJ1ZmZlclZpZXcpIHtcbiAgICAgICAgICB0aGlzLnBhY2tfYmluKG5ldyBVaW50OEFycmF5KHZhbHVlLmJ1ZmZlcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFja19iaW4odmFsdWUuYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb25zdHJ1Y3RvciA9PSBPYmplY3Qpe1xuICAgICAgICB0aGlzLnBhY2tfb2JqZWN0KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uc3RydWN0b3IgPT0gRGF0ZSl7XG4gICAgICAgIHRoaXMucGFja19zdHJpbmcodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0JpbmFyeVBhY2sgPT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQodmFsdWUudG9CaW5hcnlQYWNrKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeXBlIFwiJyArIGNvbnN0cnVjdG9yLnRvU3RyaW5nKCkgKyAnXCIgbm90IHlldCBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUeXBlIFwiJyArIHR5cGUgKyAnXCIgbm90IHlldCBzdXBwb3J0ZWQnKTtcbiAgfVxuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuZmx1c2goKTtcbn1cblxuXG5QYWNrZXIucHJvdG90eXBlLnBhY2tfYmluID0gZnVuY3Rpb24oYmxvYil7XG4gIHZhciBsZW5ndGggPSBibG9iLmxlbmd0aCB8fCBibG9iLmJ5dGVMZW5ndGggfHwgYmxvYi5zaXplO1xuICBpZiAobGVuZ3RoIDw9IDB4MGYpe1xuICAgIHRoaXMucGFja191aW50OCgweGEwICsgbGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZGEpIDtcbiAgICB0aGlzLnBhY2tfdWludDE2KGxlbmd0aCk7XG4gIH0gZWxzZSBpZiAobGVuZ3RoIDw9IDB4ZmZmZmZmZmYpe1xuICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkYik7XG4gICAgdGhpcy5wYWNrX3VpbnQzMihsZW5ndGgpO1xuICB9IGVsc2V7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxlbmd0aCcpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKGJsb2IpO1xufVxuXG5QYWNrZXIucHJvdG90eXBlLnBhY2tfc3RyaW5nID0gZnVuY3Rpb24oc3RyKXtcbiAgdmFyIGxlbmd0aCA9IHV0ZjhMZW5ndGgoc3RyKTtcblxuICBpZiAobGVuZ3RoIDw9IDB4MGYpe1xuICAgIHRoaXMucGFja191aW50OCgweGIwICsgbGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZDgpIDtcbiAgICB0aGlzLnBhY2tfdWludDE2KGxlbmd0aCk7XG4gIH0gZWxzZSBpZiAobGVuZ3RoIDw9IDB4ZmZmZmZmZmYpe1xuICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkOSk7XG4gICAgdGhpcy5wYWNrX3VpbnQzMihsZW5ndGgpO1xuICB9IGVsc2V7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxlbmd0aCcpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKHN0cik7XG59XG5cblBhY2tlci5wcm90b3R5cGUucGFja19hcnJheSA9IGZ1bmN0aW9uKGFyeSl7XG4gIHZhciBsZW5ndGggPSBhcnkubGVuZ3RoO1xuICBpZiAobGVuZ3RoIDw9IDB4MGYpe1xuICAgIHRoaXMucGFja191aW50OCgweDkwICsgbGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZGMpXG4gICAgdGhpcy5wYWNrX3VpbnQxNihsZW5ndGgpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA8PSAweGZmZmZmZmZmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZGQpO1xuICAgIHRoaXMucGFja191aW50MzIobGVuZ3RoKTtcbiAgfSBlbHNle1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsZW5ndGgnKTtcbiAgfVxuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuZ3RoIDsgaSsrKXtcbiAgICB0aGlzLnBhY2soYXJ5W2ldKTtcbiAgfVxufVxuXG5QYWNrZXIucHJvdG90eXBlLnBhY2tfaW50ZWdlciA9IGZ1bmN0aW9uKG51bSl7XG4gIGlmICggLTB4MjAgPD0gbnVtICYmIG51bSA8PSAweDdmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKG51bSAmIDB4ZmYpO1xuICB9IGVsc2UgaWYgKDB4MDAgPD0gbnVtICYmIG51bSA8PSAweGZmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4Y2MpO1xuICAgIHRoaXMucGFja191aW50OChudW0pO1xuICB9IGVsc2UgaWYgKC0weDgwIDw9IG51bSAmJiBudW0gPD0gMHg3Zil7XG4gICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgweGQwKTtcbiAgICB0aGlzLnBhY2tfaW50OChudW0pO1xuICB9IGVsc2UgaWYgKCAweDAwMDAgPD0gbnVtICYmIG51bSA8PSAweGZmZmYpe1xuICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjZCk7XG4gICAgdGhpcy5wYWNrX3VpbnQxNihudW0pO1xuICB9IGVsc2UgaWYgKC0weDgwMDAgPD0gbnVtICYmIG51bSA8PSAweDdmZmYpe1xuICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkMSk7XG4gICAgdGhpcy5wYWNrX2ludDE2KG51bSk7XG4gIH0gZWxzZSBpZiAoIDB4MDAwMDAwMDAgPD0gbnVtICYmIG51bSA8PSAweGZmZmZmZmZmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4Y2UpO1xuICAgIHRoaXMucGFja191aW50MzIobnVtKTtcbiAgfSBlbHNlIGlmICgtMHg4MDAwMDAwMCA8PSBudW0gJiYgbnVtIDw9IDB4N2ZmZmZmZmYpe1xuICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkMik7XG4gICAgdGhpcy5wYWNrX2ludDMyKG51bSk7XG4gIH0gZWxzZSBpZiAoLTB4ODAwMDAwMDAwMDAwMDAwMCA8PSBudW0gJiYgbnVtIDw9IDB4N0ZGRkZGRkZGRkZGRkZGRil7XG4gICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgweGQzKTtcbiAgICB0aGlzLnBhY2tfaW50NjQobnVtKTtcbiAgfSBlbHNlIGlmICgweDAwMDAwMDAwMDAwMDAwMDAgPD0gbnVtICYmIG51bSA8PSAweEZGRkZGRkZGRkZGRkZGRkYpe1xuICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjZik7XG4gICAgdGhpcy5wYWNrX3VpbnQ2NChudW0pO1xuICB9IGVsc2V7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVnZXInKTtcbiAgfVxufVxuXG5QYWNrZXIucHJvdG90eXBlLnBhY2tfZG91YmxlID0gZnVuY3Rpb24obnVtKXtcbiAgdmFyIHNpZ24gPSAwO1xuICBpZiAobnVtIDwgMCl7XG4gICAgc2lnbiA9IDE7XG4gICAgbnVtID0gLW51bTtcbiAgfVxuICB2YXIgZXhwICA9IE1hdGguZmxvb3IoTWF0aC5sb2cobnVtKSAvIE1hdGguTE4yKTtcbiAgdmFyIGZyYWMwID0gbnVtIC8gTWF0aC5wb3coMiwgZXhwKSAtIDE7XG4gIHZhciBmcmFjMSA9IE1hdGguZmxvb3IoZnJhYzAgKiBNYXRoLnBvdygyLCA1MikpO1xuICB2YXIgYjMyICAgPSBNYXRoLnBvdygyLCAzMik7XG4gIHZhciBoMzIgPSAoc2lnbiA8PCAzMSkgfCAoKGV4cCsxMDIzKSA8PCAyMCkgfFxuICAgICAgKGZyYWMxIC8gYjMyKSAmIDB4MGZmZmZmO1xuICB2YXIgbDMyID0gZnJhYzEgJSBiMzI7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjYik7XG4gIHRoaXMucGFja19pbnQzMihoMzIpO1xuICB0aGlzLnBhY2tfaW50MzIobDMyKTtcbn1cblxuUGFja2VyLnByb3RvdHlwZS5wYWNrX29iamVjdCA9IGZ1bmN0aW9uKG9iail7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoIDw9IDB4MGYpe1xuICAgIHRoaXMucGFja191aW50OCgweDgwICsgbGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZGUpO1xuICAgIHRoaXMucGFja191aW50MTYobGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmZmZmZil7XG4gICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgweGRmKTtcbiAgICB0aGlzLnBhY2tfdWludDMyKGxlbmd0aCk7XG4gIH0gZWxzZXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGVuZ3RoJyk7XG4gIH1cbiAgZm9yKHZhciBwcm9wIGluIG9iail7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSl7XG4gICAgICB0aGlzLnBhY2socHJvcCk7XG4gICAgICB0aGlzLnBhY2sob2JqW3Byb3BdKTtcbiAgICB9XG4gIH1cbn1cblxuUGFja2VyLnByb3RvdHlwZS5wYWNrX3VpbnQ4ID0gZnVuY3Rpb24obnVtKXtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZChudW0pO1xufVxuXG5QYWNrZXIucHJvdG90eXBlLnBhY2tfdWludDE2ID0gZnVuY3Rpb24obnVtKXtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZChudW0gPj4gOCk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQobnVtICYgMHhmZik7XG59XG5cblBhY2tlci5wcm90b3R5cGUucGFja191aW50MzIgPSBmdW5jdGlvbihudW0pe1xuICB2YXIgbiA9IG51bSAmIDB4ZmZmZmZmZmY7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKG4gJiAweGZmMDAwMDAwKSA+Pj4gMjQpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChuICYgMHgwMGZmMDAwMCkgPj4+IDE2KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobiAmIDB4MDAwMGZmMDApID4+PiAgOCk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKG4gJiAweDAwMDAwMGZmKSk7XG59XG5cblBhY2tlci5wcm90b3R5cGUucGFja191aW50NjQgPSBmdW5jdGlvbihudW0pe1xuICB2YXIgaGlnaCA9IG51bSAvIE1hdGgucG93KDIsIDMyKTtcbiAgdmFyIGxvdyAgPSBudW0gJSBNYXRoLnBvdygyLCAzMik7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGhpZ2ggJiAweGZmMDAwMDAwKSA+Pj4gMjQpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChoaWdoICYgMHgwMGZmMDAwMCkgPj4+IDE2KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgoaGlnaCAmIDB4MDAwMGZmMDApID4+PiAgOCk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGhpZ2ggJiAweDAwMDAwMGZmKSk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGxvdyAgJiAweGZmMDAwMDAwKSA+Pj4gMjQpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChsb3cgICYgMHgwMGZmMDAwMCkgPj4+IDE2KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobG93ICAmIDB4MDAwMGZmMDApID4+PiAgOCk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGxvdyAgJiAweDAwMDAwMGZmKSk7XG59XG5cblBhY2tlci5wcm90b3R5cGUucGFja19pbnQ4ID0gZnVuY3Rpb24obnVtKXtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZChudW0gJiAweGZmKTtcbn1cblxuUGFja2VyLnByb3RvdHlwZS5wYWNrX2ludDE2ID0gZnVuY3Rpb24obnVtKXtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobnVtICYgMHhmZjAwKSA+PiA4KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZChudW0gJiAweGZmKTtcbn1cblxuUGFja2VyLnByb3RvdHlwZS5wYWNrX2ludDMyID0gZnVuY3Rpb24obnVtKXtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobnVtID4+PiAyNCkgJiAweGZmKTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobnVtICYgMHgwMGZmMDAwMCkgPj4+IDE2KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobnVtICYgMHgwMDAwZmYwMCkgPj4+IDgpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChudW0gJiAweDAwMDAwMGZmKSk7XG59XG5cblBhY2tlci5wcm90b3R5cGUucGFja19pbnQ2NCA9IGZ1bmN0aW9uKG51bSl7XG4gIHZhciBoaWdoID0gTWF0aC5mbG9vcihudW0gLyBNYXRoLnBvdygyLCAzMikpO1xuICB2YXIgbG93ICA9IG51bSAlIE1hdGgucG93KDIsIDMyKTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgoaGlnaCAmIDB4ZmYwMDAwMDApID4+PiAyNCk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGhpZ2ggJiAweDAwZmYwMDAwKSA+Pj4gMTYpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChoaWdoICYgMHgwMDAwZmYwMCkgPj4+ICA4KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgoaGlnaCAmIDB4MDAwMDAwZmYpKTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobG93ICAmIDB4ZmYwMDAwMDApID4+PiAyNCk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGxvdyAgJiAweDAwZmYwMDAwKSA+Pj4gMTYpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChsb3cgICYgMHgwMDAwZmYwMCkgPj4+ICA4KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobG93ICAmIDB4MDAwMDAwZmYpKTtcbn1cblxuZnVuY3Rpb24gX3V0ZjhSZXBsYWNlKG0pe1xuICB2YXIgY29kZSA9IG0uY2hhckNvZGVBdCgwKTtcblxuICBpZihjb2RlIDw9IDB4N2ZmKSByZXR1cm4gJzAwJztcbiAgaWYoY29kZSA8PSAweGZmZmYpIHJldHVybiAnMDAwJztcbiAgaWYoY29kZSA8PSAweDFmZmZmZikgcmV0dXJuICcwMDAwJztcbiAgaWYoY29kZSA8PSAweDNmZmZmZmYpIHJldHVybiAnMDAwMDAnO1xuICByZXR1cm4gJzAwMDAwMCc7XG59XG5cbmZ1bmN0aW9uIHV0ZjhMZW5ndGgoc3RyKXtcbiAgaWYgKHN0ci5sZW5ndGggPiA2MDApIHtcbiAgICAvLyBCbG9iIG1ldGhvZCBmYXN0ZXIgZm9yIGxhcmdlIHN0cmluZ3NcbiAgICByZXR1cm4gKG5ldyBCbG9iKFtzdHJdKSkuc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1teXFx1MDAwMC1cXHUwMDdGXS9nLCBfdXRmOFJlcGxhY2UpLmxlbmd0aDtcbiAgfVxufVxuLyoqXG4gKiBMaWdodCBFdmVudEVtaXR0ZXIuIFBvcnRlZCBmcm9tIE5vZGUuanMvZXZlbnRzLmpzXG4gKiBFcmljIFpoYW5nXG4gKi9cblxuLyoqXG4gKiBFdmVudEVtaXR0ZXIgY2xhc3NcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggZXZlbnQgcmVnaXN0ZXJpbmcgYW5kIGZpcmluZyBtZXRob2RzXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgLy8gSW5pdGlhbGlzZSByZXF1aXJlZCBzdG9yYWdlIHZhcmlhYmxlc1xuICB0aGlzLl9ldmVudHMgPSB7fTtcbn1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgc2NvcGUsIG9uY2UpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcignYWRkTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgfVxuICBcbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PSBcIm5ld0xpc3RlbmVyc1wiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lcnNcIi5cbiAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsIHR5cGVvZiBsaXN0ZW5lci5saXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcbiAgICAgICAgICAgIFxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkge1xuXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcblxuICB9IGVsc2Uge1xuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgc2NvcGUpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcignLm9uY2Ugb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgZnVuY3Rpb24gZygpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzZWxmLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCBzY29wZSkge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSByZXR1cm4gdGhpcztcblxuICB2YXIgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNBcnJheShsaXN0KSkge1xuICAgIHZhciBwb3NpdGlvbiA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpXG4gICAgICB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMCkgcmV0dXJuIHRoaXM7XG4gICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAwKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfSBlbHNlIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgICAgIChsaXN0Lmxpc3RlbmVyICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSlcbiAge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gIGlmICh0eXBlICYmIHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV0pIHRoaXMuX2V2ZW50c1t0eXBlXSA9IG51bGw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB0aGlzLl9ldmVudHNbdHlwZV0gPSBbXTtcbiAgaWYgKCFpc0FycmF5KHRoaXMuX2V2ZW50c1t0eXBlXSkpIHtcbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZXZlbnRzW3R5cGVdO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGlmICghaGFuZGxlcikgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGw7IGkrKykgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsOyBpKyspIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5cblxuLyoqXG4gKiBSZWxpYWJsZSB0cmFuc2ZlciBmb3IgQ2hyb21lIENhbmFyeSBEYXRhQ2hhbm5lbCBpbXBsLlxuICogQXV0aG9yOiBAbWljaGVsbGVidVxuICovXG5mdW5jdGlvbiBSZWxpYWJsZShkYywgZGVidWcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlbGlhYmxlKSkgcmV0dXJuIG5ldyBSZWxpYWJsZShkYyk7XG4gIHRoaXMuX2RjID0gZGM7XG5cbiAgdXRpbC5kZWJ1ZyA9IGRlYnVnO1xuXG4gIC8vIE1lc3NhZ2VzIHNlbnQvcmVjZWl2ZWQgc28gZmFyLlxuICAvLyBpZDogeyBhY2s6IG4sIGNodW5rczogWy4uLl0gfVxuICB0aGlzLl9vdXRnb2luZyA9IHt9O1xuICAvLyBpZDogeyBhY2s6IFsnYWNrJywgaWQsIG5dLCBjaHVua3M6IFsuLi5dIH1cbiAgdGhpcy5faW5jb21pbmcgPSB7fTtcbiAgdGhpcy5fcmVjZWl2ZWQgPSB7fTtcblxuICAvLyBXaW5kb3cgc2l6ZS5cbiAgdGhpcy5fd2luZG93ID0gMTAwMDtcbiAgLy8gTVRVLlxuICB0aGlzLl9tdHUgPSA1MDA7XG4gIC8vIEludGVydmFsIGZvciBzZXRJbnRlcnZhbC4gSW4gbXMuXG4gIHRoaXMuX2ludGVydmFsID0gMDtcblxuICAvLyBNZXNzYWdlcyBzZW50LlxuICB0aGlzLl9jb3VudCA9IDA7XG5cbiAgLy8gT3V0Z29pbmcgbWVzc2FnZSBxdWV1ZS5cbiAgdGhpcy5fcXVldWUgPSBbXTtcblxuICB0aGlzLl9zZXR1cERDKCk7XG59O1xuXG4vLyBTZW5kIGEgbWVzc2FnZSByZWxpYWJseS5cblJlbGlhYmxlLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obXNnKSB7XG4gIC8vIERldGVybWluZSBpZiBjaHVua2luZyBpcyBuZWNlc3NhcnkuXG4gIHZhciBibCA9IHV0aWwucGFjayhtc2cpO1xuICBpZiAoYmwuc2l6ZSA8IHRoaXMuX210dSkge1xuICAgIHRoaXMuX2hhbmRsZVNlbmQoWydubycsIGJsXSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fb3V0Z29pbmdbdGhpcy5fY291bnRdID0ge1xuICAgIGFjazogMCxcbiAgICBjaHVua3M6IHRoaXMuX2NodW5rKGJsKVxuICB9O1xuXG4gIGlmICh1dGlsLmRlYnVnKSB7XG4gICAgdGhpcy5fb3V0Z29pbmdbdGhpcy5fY291bnRdLnRpbWVyID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gIC8vIFNlbmQgcHJlbGltIHdpbmRvdy5cbiAgdGhpcy5fc2VuZFdpbmRvd2VkQ2h1bmtzKHRoaXMuX2NvdW50KTtcbiAgdGhpcy5fY291bnQgKz0gMTtcbn07XG5cbi8vIFNldCB1cCBpbnRlcnZhbCBmb3IgcHJvY2Vzc2luZyBxdWV1ZS5cblJlbGlhYmxlLnByb3RvdHlwZS5fc2V0dXBJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICAvLyBUT0RPOiBmYWlsIGdyYWNlZnVsbHkuXG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl90aW1lb3V0ID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgLy8gRklYTUU6IFN0cmluZyBzdHVmZiBtYWtlcyB0aGluZ3MgdGVycmlibHkgYXN5bmMuXG4gICAgdmFyIG1zZyA9IHNlbGYuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKG1zZy5fbXVsdGlwbGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG1zZy5sZW5ndGg7IGkgPCBpaTsgaSArPSAxKSB7XG4gICAgICAgIHNlbGYuX2ludGVydmFsU2VuZChtc2dbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl9pbnRlcnZhbFNlbmQobXNnKTtcbiAgICB9XG4gIH0sIHRoaXMuX2ludGVydmFsKTtcbn07XG5cblJlbGlhYmxlLnByb3RvdHlwZS5faW50ZXJ2YWxTZW5kID0gZnVuY3Rpb24obXNnKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgbXNnID0gdXRpbC5wYWNrKG1zZyk7XG4gIHV0aWwuYmxvYlRvQmluYXJ5U3RyaW5nKG1zZywgZnVuY3Rpb24oc3RyKSB7XG4gICAgc2VsZi5fZGMuc2VuZChzdHIpO1xuICB9KTtcbiAgaWYgKHNlbGYuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgIGNsZWFyVGltZW91dChzZWxmLl90aW1lb3V0KTtcbiAgICBzZWxmLl90aW1lb3V0ID0gbnVsbDtcbiAgICAvL3NlbGYuX3Byb2Nlc3NBY2tzKCk7XG4gIH1cbn07XG5cbi8vIEdvIHRocm91Z2ggQUNLcyB0byBzZW5kIG1pc3NpbmcgcGllY2VzLlxuUmVsaWFibGUucHJvdG90eXBlLl9wcm9jZXNzQWNrcyA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpZCBpbiB0aGlzLl9vdXRnb2luZykge1xuICAgIGlmICh0aGlzLl9vdXRnb2luZy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIHRoaXMuX3NlbmRXaW5kb3dlZENodW5rcyhpZCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBIYW5kbGUgc2VuZGluZyBhIG1lc3NhZ2UuXG4vLyBGSVhNRTogRG9uJ3Qgd2FpdCBmb3IgaW50ZXJ2YWwgdGltZSBmb3IgYWxsIG1lc3NhZ2VzLi4uXG5SZWxpYWJsZS5wcm90b3R5cGUuX2hhbmRsZVNlbmQgPSBmdW5jdGlvbihtc2cpIHtcbiAgdmFyIHB1c2ggPSB0cnVlO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkgPCBpaTsgaSArPSAxKSB7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLl9xdWV1ZVtpXTtcbiAgICBpZiAoaXRlbSA9PT0gbXNnKSB7XG4gICAgICBwdXNoID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpdGVtLl9tdWx0aXBsZSAmJiBpdGVtLmluZGV4T2YobXNnKSAhPT0gLTEpIHtcbiAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHB1c2gpIHtcbiAgICB0aGlzLl9xdWV1ZS5wdXNoKG1zZyk7XG4gICAgaWYgKCF0aGlzLl90aW1lb3V0KSB7XG4gICAgICB0aGlzLl9zZXR1cEludGVydmFsKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBTZXQgdXAgRGF0YUNoYW5uZWwgaGFuZGxlcnMuXG5SZWxpYWJsZS5wcm90b3R5cGUuX3NldHVwREMgPSBmdW5jdGlvbigpIHtcbiAgLy8gSGFuZGxlIHZhcmlvdXMgbWVzc2FnZSB0eXBlcy5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9kYy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG1zZyA9IGUuZGF0YTtcbiAgICB2YXIgZGF0YXR5cGUgPSBtc2cuY29uc3RydWN0b3I7XG4gICAgLy8gRklYTUU6IG1zZyBpcyBTdHJpbmcgdW50aWwgYmluYXJ5IGlzIHN1cHBvcnRlZC5cbiAgICAvLyBPbmNlIHRoYXQgaGFwcGVucywgdGhpcyB3aWxsIGhhdmUgdG8gYmUgc21hcnRlci5cbiAgICBpZiAoZGF0YXR5cGUgPT09IFN0cmluZykge1xuICAgICAgdmFyIGFiID0gdXRpbC5iaW5hcnlTdHJpbmdUb0FycmF5QnVmZmVyKG1zZyk7XG4gICAgICBtc2cgPSB1dGlsLnVucGFjayhhYik7XG4gICAgICBzZWxmLl9oYW5kbGVNZXNzYWdlKG1zZyk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gSGFuZGxlcyBhbiBpbmNvbWluZyBtZXNzYWdlLlxuUmVsaWFibGUucHJvdG90eXBlLl9oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gIHZhciBpZCA9IG1zZ1sxXTtcbiAgdmFyIGlkYXRhID0gdGhpcy5faW5jb21pbmdbaWRdO1xuICB2YXIgb2RhdGEgPSB0aGlzLl9vdXRnb2luZ1tpZF07XG4gIHZhciBkYXRhO1xuICBzd2l0Y2ggKG1zZ1swXSkge1xuICAgIC8vIE5vIGNodW5raW5nIHdhcyBkb25lLlxuICAgIGNhc2UgJ25vJzpcbiAgICAgIHZhciBtZXNzYWdlID0gaWQ7XG4gICAgICBpZiAoISFtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMub25tZXNzYWdlKHV0aWwudW5wYWNrKG1lc3NhZ2UpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIC8vIFJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbWVzc2FnZS5cbiAgICBjYXNlICdlbmQnOlxuICAgICAgZGF0YSA9IGlkYXRhO1xuXG4gICAgICAvLyBJbiBjYXNlIGVuZCBjb21lcyBmaXJzdC5cbiAgICAgIHRoaXMuX3JlY2VpdmVkW2lkXSA9IG1zZ1syXTtcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hY2soaWQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYWNrJzpcbiAgICAgIGRhdGEgPSBvZGF0YTtcbiAgICAgIGlmICghIWRhdGEpIHtcbiAgICAgICAgdmFyIGFjayA9IG1zZ1syXTtcbiAgICAgICAgLy8gVGFrZSB0aGUgbGFyZ2VyIEFDSywgZm9yIG91dCBvZiBvcmRlciBtZXNzYWdlcy5cbiAgICAgICAgZGF0YS5hY2sgPSBNYXRoLm1heChhY2ssIGRhdGEuYWNrKTtcblxuICAgICAgICAvLyBDbGVhbiB1cCB3aGVuIGFsbCBjaHVua3MgYXJlIEFDS2VkLlxuICAgICAgICBpZiAoZGF0YS5hY2sgPj0gZGF0YS5jaHVua3MubGVuZ3RoKSB7XG4gICAgICAgICAgdXRpbC5sb2coJ1RpbWU6ICcsIG5ldyBEYXRlKCkgLSBkYXRhLnRpbWVyKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fb3V0Z29pbmdbaWRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Byb2Nlc3NBY2tzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIElmICFkYXRhLCBqdXN0IGlnbm9yZS5cbiAgICAgIGJyZWFrO1xuICAgIC8vIFJlY2VpdmVkIGEgY2h1bmsgb2YgZGF0YS5cbiAgICBjYXNlICdjaHVuayc6XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgZW50cnkgaWYgbm9uZSBleGlzdHMuXG4gICAgICBkYXRhID0gaWRhdGE7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuX3JlY2VpdmVkW2lkXTtcbiAgICAgICAgaWYgKGVuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgYWNrOiBbJ2FjaycsIGlkLCAwXSxcbiAgICAgICAgICBjaHVua3M6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2luY29taW5nW2lkXSA9IGRhdGE7XG4gICAgICB9XG5cbiAgICAgIHZhciBuID0gbXNnWzJdO1xuICAgICAgdmFyIGNodW5rID0gbXNnWzNdO1xuICAgICAgZGF0YS5jaHVua3Nbbl0gPSBuZXcgVWludDhBcnJheShjaHVuayk7XG5cbiAgICAgIC8vIElmIHdlIGdldCB0aGUgY2h1bmsgd2UncmUgbG9va2luZyBmb3IsIEFDSyBmb3IgbmV4dCBtaXNzaW5nLlxuICAgICAgLy8gT3RoZXJ3aXNlLCBBQ0sgdGhlIHNhbWUgTiBhZ2Fpbi5cbiAgICAgIGlmIChuID09PSBkYXRhLmFja1syXSkge1xuICAgICAgICB0aGlzLl9jYWxjdWxhdGVOZXh0QWNrKGlkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FjayhpZCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gU2hvdWxkbid0IGhhcHBlbiwgYnV0IHdvdWxkIG1ha2Ugc2Vuc2UgZm9yIG1lc3NhZ2UgdG8ganVzdCBnb1xuICAgICAgLy8gdGhyb3VnaCBhcyBpcy5cbiAgICAgIHRoaXMuX2hhbmRsZVNlbmQobXNnKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vLyBDaHVua3MgQkwgaW50byBzbWFsbGVyIG1lc3NhZ2VzLlxuUmVsaWFibGUucHJvdG90eXBlLl9jaHVuayA9IGZ1bmN0aW9uKGJsKSB7XG4gIHZhciBjaHVua3MgPSBbXTtcbiAgdmFyIHNpemUgPSBibC5zaXplO1xuICB2YXIgc3RhcnQgPSAwO1xuICB3aGlsZSAoc3RhcnQgPCBzaXplKSB7XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHNpemUsIHN0YXJ0ICsgdGhpcy5fbXR1KTtcbiAgICB2YXIgYiA9IGJsLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIHZhciBjaHVuayA9IHtcbiAgICAgIHBheWxvYWQ6IGJcbiAgICB9XG4gICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgIHN0YXJ0ID0gZW5kO1xuICB9XG4gIHV0aWwubG9nKCdDcmVhdGVkJywgY2h1bmtzLmxlbmd0aCwgJ2NodW5rcy4nKTtcbiAgcmV0dXJuIGNodW5rcztcbn07XG5cbi8vIFNlbmRzIEFDSyBOLCBleHBlY3RpbmcgTnRoIGJsb2IgY2h1bmsgZm9yIG1lc3NhZ2UgSUQuXG5SZWxpYWJsZS5wcm90b3R5cGUuX2FjayA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBhY2sgPSB0aGlzLl9pbmNvbWluZ1tpZF0uYWNrO1xuXG4gIC8vIGlmIGFjayBpcyB0aGUgZW5kIHZhbHVlLCB0aGVuIGNhbGwgX2NvbXBsZXRlLlxuICBpZiAodGhpcy5fcmVjZWl2ZWRbaWRdID09PSBhY2tbMl0pIHtcbiAgICB0aGlzLl9jb21wbGV0ZShpZCk7XG4gICAgdGhpcy5fcmVjZWl2ZWRbaWRdID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2hhbmRsZVNlbmQoYWNrKTtcbn07XG5cbi8vIENhbGN1bGF0ZXMgdGhlIG5leHQgQUNLIG51bWJlciwgZ2l2ZW4gY2h1bmtzLlxuUmVsaWFibGUucHJvdG90eXBlLl9jYWxjdWxhdGVOZXh0QWNrID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9pbmNvbWluZ1tpZF07XG4gIHZhciBjaHVua3MgPSBkYXRhLmNodW5rcztcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gY2h1bmtzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDEpIHtcbiAgICAvLyBUaGlzIGNodW5rIGlzIG1pc3NpbmchISEgQmV0dGVyIEFDSyBmb3IgaXQuXG4gICAgaWYgKGNodW5rc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkYXRhLmFja1syXSA9IGk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGRhdGEuYWNrWzJdID0gY2h1bmtzLmxlbmd0aDtcbn07XG5cbi8vIFNlbmRzIHRoZSBuZXh0IHdpbmRvdyBvZiBjaHVua3MuXG5SZWxpYWJsZS5wcm90b3R5cGUuX3NlbmRXaW5kb3dlZENodW5rcyA9IGZ1bmN0aW9uKGlkKSB7XG4gIHV0aWwubG9nKCdzZW5kV2luZG93ZWRDaHVua3MgZm9yOiAnLCBpZCk7XG4gIHZhciBkYXRhID0gdGhpcy5fb3V0Z29pbmdbaWRdO1xuICB2YXIgY2ggPSBkYXRhLmNodW5rcztcbiAgdmFyIGNodW5rcyA9IFtdO1xuICB2YXIgbGltaXQgPSBNYXRoLm1pbihkYXRhLmFjayArIHRoaXMuX3dpbmRvdywgY2gubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IGRhdGEuYWNrOyBpIDwgbGltaXQ7IGkgKz0gMSkge1xuICAgIGlmICghY2hbaV0uc2VudCB8fCBpID09PSBkYXRhLmFjaykge1xuICAgICAgY2hbaV0uc2VudCA9IHRydWU7XG4gICAgICBjaHVua3MucHVzaChbJ2NodW5rJywgaWQsIGksIGNoW2ldLnBheWxvYWRdKTtcbiAgICB9XG4gIH1cbiAgaWYgKGRhdGEuYWNrICsgdGhpcy5fd2luZG93ID49IGNoLmxlbmd0aCkge1xuICAgIGNodW5rcy5wdXNoKFsnZW5kJywgaWQsIGNoLmxlbmd0aF0pXG4gIH1cbiAgY2h1bmtzLl9tdWx0aXBsZSA9IHRydWU7XG4gIHRoaXMuX2hhbmRsZVNlbmQoY2h1bmtzKTtcbn07XG5cbi8vIFB1dHMgdG9nZXRoZXIgYSBtZXNzYWdlIGZyb20gY2h1bmtzLlxuUmVsaWFibGUucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uKGlkKSB7XG4gIHV0aWwubG9nKCdDb21wbGV0ZWQgY2FsbGVkIGZvcicsIGlkKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2h1bmtzID0gdGhpcy5faW5jb21pbmdbaWRdLmNodW5rcztcbiAgdmFyIGJsID0gbmV3IEJsb2IoY2h1bmtzKTtcbiAgdXRpbC5ibG9iVG9BcnJheUJ1ZmZlcihibCwgZnVuY3Rpb24oYWIpIHtcbiAgICBzZWxmLm9ubWVzc2FnZSh1dGlsLnVucGFjayhhYikpO1xuICB9KTtcbiAgZGVsZXRlIHRoaXMuX2luY29taW5nW2lkXTtcbn07XG5cbi8vIFVwcyBiYW5kd2lkdGggbGltaXQgb24gU0RQLiBNZWFudCB0byBiZSBjYWxsZWQgZHVyaW5nIG9mZmVyL2Fuc3dlci5cblJlbGlhYmxlLmhpZ2hlckJhbmR3aWR0aFNEUCA9IGZ1bmN0aW9uKHNkcCkge1xuICAvLyBBUyBzdGFuZHMgZm9yIEFwcGxpY2F0aW9uLVNwZWNpZmljIE1heGltdW0uXG4gIC8vIEJhbmR3aWR0aCBudW1iZXIgaXMgaW4ga2lsb2JpdHMgLyBzZWMuXG4gIC8vIFNlZSBSRkMgZm9yIG1vcmUgaW5mbzogaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMjMyNy50eHRcblxuICAvLyBDaHJvbWUgMzErIGRvZXNuJ3Qgd2FudCB1cyBtdW5naW5nIHRoZSBTRFAsIHNvIHdlJ2xsIGxldCB0aGVtIGhhdmUgdGhlaXJcbiAgLy8gd2F5LlxuICB2YXIgdmVyc2lvbiA9IG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKC9DaHJvbWVcXC8oLio/KSAvKTtcbiAgaWYgKHZlcnNpb24pIHtcbiAgICB2ZXJzaW9uID0gcGFyc2VJbnQodmVyc2lvblsxXS5zcGxpdCgnLicpLnNoaWZ0KCkpO1xuICAgIGlmICh2ZXJzaW9uIDwgMzEpIHtcbiAgICAgIHZhciBwYXJ0cyA9IHNkcC5zcGxpdCgnYj1BUzozMCcpO1xuICAgICAgdmFyIHJlcGxhY2UgPSAnYj1BUzoxMDI0MDAnOyAvLyAxMDAgTWJwc1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzWzBdICsgcmVwbGFjZSArIHBhcnRzWzFdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBPdmVyd3JpdHRlbiwgdHlwaWNhbGx5LlxuUmVsaWFibGUucHJvdG90eXBlLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge307XG5cbmV4cG9ydHMuUmVsaWFibGUgPSBSZWxpYWJsZTtcbmV4cG9ydHMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uID0gd2luZG93Lm1velJUQ1Nlc3Npb25EZXNjcmlwdGlvbiB8fCB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uO1xuZXhwb3J0cy5SVENQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbiB8fCB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24gfHwgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uO1xuZXhwb3J0cy5SVENJY2VDYW5kaWRhdGUgPSB3aW5kb3cubW96UlRDSWNlQ2FuZGlkYXRlIHx8IHdpbmRvdy5SVENJY2VDYW5kaWRhdGU7XG52YXIgZGVmYXVsdENvbmZpZyA9IHsnaWNlU2VydmVycyc6IFt7ICd1cmwnOiAnc3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMicgfV19O1xudmFyIGRhdGFDb3VudCA9IDE7XG5cbnZhciB1dGlsID0ge1xuICBub29wOiBmdW5jdGlvbigpIHt9LFxuXG4gIENMT1VEX0hPU1Q6ICcwLnBlZXJqcy5jb20nLFxuICBDTE9VRF9QT1JUOiA5MDAwLFxuXG4gIC8vIEJyb3dzZXJzIHRoYXQgbmVlZCBjaHVua2luZzpcbiAgY2h1bmtlZEJyb3dzZXJzOiB7J0Nocm9tZSc6IDF9LFxuICBjaHVua2VkTVRVOiAxNjMwMCwgLy8gVGhlIG9yaWdpbmFsIDYwMDAwIGJ5dGVzIHNldHRpbmcgZG9lcyBub3Qgd29yayB3aGVuIHNlbmRpbmcgZGF0YSBmcm9tIEZpcmVmb3ggdG8gQ2hyb21lLCB3aGljaCBpcyBcImN1dCBvZmZcIiBhZnRlciAxNjM4NCBieXRlcyBhbmQgZGVsaXZlcmVkIGluZGl2aWR1YWxseS5cblxuICAvLyBMb2dnaW5nIGxvZ2ljXG4gIGxvZ0xldmVsOiAwLFxuICBzZXRMb2dMZXZlbDogZnVuY3Rpb24obGV2ZWwpIHtcbiAgICB2YXIgZGVidWdMZXZlbCA9IHBhcnNlSW50KGxldmVsLCAxMCk7XG4gICAgaWYgKCFpc05hTihwYXJzZUludChsZXZlbCwgMTApKSkge1xuICAgICAgdXRpbC5sb2dMZXZlbCA9IGRlYnVnTGV2ZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXkgYXJlIHVzaW5nIHRydXRoeS9mYWxzeSB2YWx1ZXMgZm9yIGRlYnVnXG4gICAgICB1dGlsLmxvZ0xldmVsID0gbGV2ZWwgPyAzIDogMDtcbiAgICB9XG4gICAgdXRpbC5sb2cgPSB1dGlsLndhcm4gPSB1dGlsLmVycm9yID0gdXRpbC5ub29wO1xuICAgIGlmICh1dGlsLmxvZ0xldmVsID4gMCkge1xuICAgICAgdXRpbC5lcnJvciA9IHV0aWwuX3ByaW50V2l0aCgnRVJST1InKTtcbiAgICB9XG4gICAgaWYgKHV0aWwubG9nTGV2ZWwgPiAxKSB7XG4gICAgICB1dGlsLndhcm4gPSB1dGlsLl9wcmludFdpdGgoJ1dBUk5JTkcnKTtcbiAgICB9XG4gICAgaWYgKHV0aWwubG9nTGV2ZWwgPiAyKSB7XG4gICAgICB1dGlsLmxvZyA9IHV0aWwuX3ByaW50O1xuICAgIH1cbiAgfSxcbiAgc2V0TG9nRnVuY3Rpb246IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKGZuLmNvbnN0cnVjdG9yICE9PSBGdW5jdGlvbikge1xuICAgICAgdXRpbC53YXJuKCdUaGUgbG9nIGZ1bmN0aW9uIHlvdSBwYXNzZWQgaW4gaXMgbm90IGEgZnVuY3Rpb24uIERlZmF1bHRpbmcgdG8gcmVndWxhciBsb2dzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLl9wcmludCA9IGZuO1xuICAgIH1cbiAgfSxcblxuICBfcHJpbnRXaXRoOiBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29weSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBjb3B5LnVuc2hpZnQocHJlZml4KTtcbiAgICAgIHV0aWwuX3ByaW50LmFwcGx5KHV0aWwsIGNvcHkpO1xuICAgIH07XG4gIH0sXG4gIF9wcmludDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlcnIgPSBmYWxzZTtcbiAgICB2YXIgY29weSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgY29weS51bnNoaWZ0KCdQZWVySlM6ICcpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29weS5sZW5ndGg7IGkgPCBsOyBpKyspe1xuICAgICAgaWYgKGNvcHlbaV0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBjb3B5W2ldID0gJygnICsgY29weVtpXS5uYW1lICsgJykgJyArIGNvcHlbaV0ubWVzc2FnZTtcbiAgICAgICAgZXJyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXJyID8gY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBjb3B5KSA6IGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGNvcHkpOyAgXG4gIH0sXG4gIC8vXG5cbiAgLy8gUmV0dXJucyBicm93c2VyLWFnbm9zdGljIGRlZmF1bHQgY29uZmlnXG4gIGRlZmF1bHRDb25maWc6IGRlZmF1bHRDb25maWcsXG4gIC8vXG5cbiAgLy8gUmV0dXJucyB0aGUgY3VycmVudCBicm93c2VyLlxuICBicm93c2VyOiAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikge1xuICAgICAgcmV0dXJuICdGaXJlZm94JztcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbikge1xuICAgICAgcmV0dXJuICdDaHJvbWUnO1xuICAgIH0gZWxzZSBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgICByZXR1cm4gJ1N1cHBvcnRlZCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnVW5zdXBwb3J0ZWQnO1xuICAgIH1cbiAgfSkoKSxcbiAgLy9cblxuICAvLyBMaXN0cyB3aGljaCBmZWF0dXJlcyBhcmUgc3VwcG9ydGVkXG4gIHN1cHBvcnRzOiAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiBSVENQZWVyQ29ubmVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHRydWU7XG4gICAgdmFyIGF1ZGlvVmlkZW8gPSB0cnVlO1xuXG4gICAgdmFyIGJpbmFyeUJsb2IgPSBmYWxzZTtcbiAgICB2YXIgc2N0cCA9IGZhbHNlO1xuICAgIHZhciBvbm5lZ290aWF0aW9ubmVlZGVkID0gISF3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb247XG5cbiAgICB2YXIgcGMsIGRjO1xuICAgIHRyeSB7XG4gICAgICBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihkZWZhdWx0Q29uZmlnLCB7b3B0aW9uYWw6IFt7UnRwRGF0YUNoYW5uZWxzOiB0cnVlfV19KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkYXRhID0gZmFsc2U7XG4gICAgICBhdWRpb1ZpZGVvID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRjID0gcGMuY3JlYXRlRGF0YUNoYW5uZWwoJ19QRUVSSlNURVNUJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRhdGEgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgLy8gQmluYXJ5IHRlc3RcbiAgICAgIHRyeSB7XG4gICAgICAgIGRjLmJpbmFyeVR5cGUgPSAnYmxvYic7XG4gICAgICAgIGJpbmFyeUJsb2IgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuXG4gICAgICAvLyBSZWxpYWJsZSB0ZXN0LlxuICAgICAgLy8gVW5mb3J0dW5hdGVseSBDaHJvbWUgaXMgYSBiaXQgdW5yZWxpYWJsZSBhYm91dCB3aGV0aGVyIG9yIG5vdCB0aGV5XG4gICAgICAvLyBzdXBwb3J0IHJlbGlhYmxlLlxuICAgICAgdmFyIHJlbGlhYmxlUEMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oZGVmYXVsdENvbmZpZywge30pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlbGlhYmxlREMgPSByZWxpYWJsZVBDLmNyZWF0ZURhdGFDaGFubmVsKCdfUEVFUkpTUkVMSUFCTEVURVNUJywge30pO1xuICAgICAgICBzY3RwID0gcmVsaWFibGVEQy5yZWxpYWJsZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICAgIHJlbGlhYmxlUEMuY2xvc2UoKTtcbiAgICB9XG5cbiAgICAvLyBGSVhNRTogbm90IHJlYWxseSB0aGUgYmVzdCBjaGVjay4uLlxuICAgIGlmIChhdWRpb1ZpZGVvKSB7XG4gICAgICBhdWRpb1ZpZGVvID0gISFwYy5hZGRTdHJlYW07XG4gICAgfVxuXG4gICAgLy8gRklYTUU6IHRoaXMgaXMgbm90IGdyZWF0IGJlY2F1c2UgaW4gdGhlb3J5IGl0IGRvZXNuJ3Qgd29yayBmb3JcbiAgICAvLyBhdi1vbmx5IGJyb3dzZXJzICg/KS5cbiAgICBpZiAoIW9ubmVnb3RpYXRpb25uZWVkZWQgJiYgZGF0YSkge1xuICAgICAgLy8gc3luYyBkZWZhdWx0IGNoZWNrLlxuICAgICAgdmFyIG5lZ290aWF0aW9uUEMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oZGVmYXVsdENvbmZpZywge29wdGlvbmFsOiBbe1J0cERhdGFDaGFubmVsczogdHJ1ZX1dfSk7XG4gICAgICBuZWdvdGlhdGlvblBDLm9ubmVnb3RpYXRpb25uZWVkZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgb25uZWdvdGlhdGlvbm5lZWRlZCA9IHRydWU7XG4gICAgICAgIC8vIGFzeW5jIGNoZWNrLlxuICAgICAgICBpZiAodXRpbCAmJiB1dGlsLnN1cHBvcnRzKSB7XG4gICAgICAgICAgdXRpbC5zdXBwb3J0cy5vbm5lZ290aWF0aW9ubmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBuZWdvdGlhdGlvbkRDID0gbmVnb3RpYXRpb25QQy5jcmVhdGVEYXRhQ2hhbm5lbCgnX1BFRVJKU05FR09USUFUSU9OVEVTVCcpO1xuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBuZWdvdGlhdGlvblBDLmNsb3NlKCk7XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG5cbiAgICBpZiAocGMpIHtcbiAgICAgIHBjLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvVmlkZW86IGF1ZGlvVmlkZW8sXG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgYmluYXJ5QmxvYjogYmluYXJ5QmxvYixcbiAgICAgIGJpbmFyeTogc2N0cCwgLy8gZGVwcmVjYXRlZDsgc2N0cCBpbXBsaWVzIGJpbmFyeSBzdXBwb3J0LlxuICAgICAgcmVsaWFibGU6IHNjdHAsIC8vIGRlcHJlY2F0ZWQ7IHNjdHAgaW1wbGllcyByZWxpYWJsZSBkYXRhLlxuICAgICAgc2N0cDogc2N0cCxcbiAgICAgIG9ubmVnb3RpYXRpb25uZWVkZWQ6IG9ubmVnb3RpYXRpb25uZWVkZWRcbiAgICB9O1xuICB9KCkpLFxuICAvL1xuXG4gIC8vIEVuc3VyZSBhbHBoYW51bWVyaWMgaWRzXG4gIHZhbGlkYXRlSWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgLy8gQWxsb3cgZW1wdHkgaWRzXG4gICAgcmV0dXJuICFpZCB8fCAvXltBLVphLXowLTldKyg/OlsgXy1dW0EtWmEtejAtOV0rKSokLy5leGVjKGlkKTtcbiAgfSxcblxuICB2YWxpZGF0ZUtleTogZnVuY3Rpb24oa2V5KSB7XG4gICAgLy8gQWxsb3cgZW1wdHkga2V5c1xuICAgIHJldHVybiAha2V5IHx8IC9eW0EtWmEtejAtOV0rKD86WyBfLV1bQS1aYS16MC05XSspKiQvLmV4ZWMoa2V5KTtcbiAgfSxcblxuXG4gIGRlYnVnOiBmYWxzZSxcblxuICBpbmhlcml0czogZnVuY3Rpb24oY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBleHRlbmQ6IGZ1bmN0aW9uKGRlc3QsIHNvdXJjZSkge1xuICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgZGVzdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9LFxuICBwYWNrOiBCaW5hcnlQYWNrLnBhY2ssXG4gIHVucGFjazogQmluYXJ5UGFjay51bnBhY2ssXG5cbiAgbG9nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHV0aWwuZGVidWcpIHtcbiAgICAgIHZhciBlcnIgPSBmYWxzZTtcbiAgICAgIHZhciBjb3B5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGNvcHkudW5zaGlmdCgnUGVlckpTOiAnKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29weS5sZW5ndGg7IGkgPCBsOyBpKyspe1xuICAgICAgICBpZiAoY29weVtpXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgY29weVtpXSA9ICcoJyArIGNvcHlbaV0ubmFtZSArICcpICcgKyBjb3B5W2ldLm1lc3NhZ2U7XG4gICAgICAgICAgZXJyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXJyID8gY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBjb3B5KSA6IGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGNvcHkpO1xuICAgIH1cbiAgfSxcblxuICBzZXRaZXJvVGltZW91dDogKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAgIHZhciB0aW1lb3V0cyA9IFtdO1xuICAgIHZhciBtZXNzYWdlTmFtZSA9ICd6ZXJvLXRpbWVvdXQtbWVzc2FnZSc7XG5cbiAgICAvLyBMaWtlIHNldFRpbWVvdXQsIGJ1dCBvbmx5IHRha2VzIGEgZnVuY3Rpb24gYXJndW1lbnQuXHQgVGhlcmUnc1xuICAgIC8vIG5vIHRpbWUgYXJndW1lbnQgKGFsd2F5cyB6ZXJvKSBhbmQgbm8gYXJndW1lbnRzICh5b3UgaGF2ZSB0b1xuICAgIC8vIHVzZSBhIGNsb3N1cmUpLlxuICAgIGZ1bmN0aW9uIHNldFplcm9UaW1lb3V0UG9zdE1lc3NhZ2UoZm4pIHtcbiAgICAgIHRpbWVvdXRzLnB1c2goZm4pO1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VOYW1lLCAnKicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5zb3VyY2UgPT0gZ2xvYmFsICYmIGV2ZW50LmRhdGEgPT0gbWVzc2FnZU5hbWUpIHtcbiAgICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lb3V0cy5sZW5ndGgpIHtcbiAgICAgICAgICB0aW1lb3V0cy5zaGlmdCgpKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29ubWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0WmVyb1RpbWVvdXRQb3N0TWVzc2FnZTtcbiAgfSh0aGlzKSksXG5cbiAgLy8gQmluYXJ5IHN0dWZmXG5cbiAgLy8gY2h1bmtzIGEgYmxvYi5cbiAgY2h1bms6IGZ1bmN0aW9uKGJsKSB7XG4gICAgdmFyIGNodW5rcyA9IFtdO1xuICAgIHZhciBzaXplID0gYmwuc2l6ZTtcbiAgICB2YXIgc3RhcnQgPSBpbmRleCA9IDA7XG4gICAgdmFyIHRvdGFsID0gTWF0aC5jZWlsKHNpemUgLyB1dGlsLmNodW5rZWRNVFUpO1xuICAgIHdoaWxlIChzdGFydCA8IHNpemUpIHtcbiAgICAgIHZhciBlbmQgPSBNYXRoLm1pbihzaXplLCBzdGFydCArIHV0aWwuY2h1bmtlZE1UVSk7XG4gICAgICB2YXIgYiA9IGJsLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgICB2YXIgY2h1bmsgPSB7XG4gICAgICAgIF9fcGVlckRhdGE6IGRhdGFDb3VudCxcbiAgICAgICAgbjogaW5kZXgsXG4gICAgICAgIGRhdGE6IGIsXG4gICAgICAgIHRvdGFsOiB0b3RhbFxuICAgICAgfTtcblxuICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuXG4gICAgICBzdGFydCA9IGVuZDtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgfVxuICAgIGRhdGFDb3VudCArPSAxO1xuICAgIHJldHVybiBjaHVua3M7XG4gIH0sXG5cbiAgYmxvYlRvQXJyYXlCdWZmZXI6IGZ1bmN0aW9uKGJsb2IsIGNiKXtcbiAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgY2IoZXZ0LnRhcmdldC5yZXN1bHQpO1xuICAgIH07XG4gICAgZnIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gIH0sXG4gIGJsb2JUb0JpbmFyeVN0cmluZzogZnVuY3Rpb24oYmxvYiwgY2Ipe1xuICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZnIub25sb2FkID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBjYihldnQudGFyZ2V0LnJlc3VsdCk7XG4gICAgfTtcbiAgICBmci5yZWFkQXNCaW5hcnlTdHJpbmcoYmxvYik7XG4gIH0sXG4gIGJpbmFyeVN0cmluZ1RvQXJyYXlCdWZmZXI6IGZ1bmN0aW9uKGJpbmFyeSkge1xuICAgIHZhciBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShiaW5hcnkubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmFyeS5sZW5ndGg7IGkrKykge1xuICAgICAgYnl0ZUFycmF5W2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSkgJiAweGZmO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZUFycmF5LmJ1ZmZlcjtcbiAgfSxcbiAgcmFuZG9tVG9rZW46IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIpO1xuICB9LFxuICAvL1xuXG4gIGlzU2VjdXJlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonO1xuICB9XG59O1xuXG5leHBvcnRzLnV0aWwgPSB1dGlsO1xuLyoqXG4gKiBBIHBlZXIgd2hvIGNhbiBpbml0aWF0ZSBjb25uZWN0aW9ucyB3aXRoIG90aGVyIHBlZXJzLlxuICovXG5mdW5jdGlvbiBQZWVyKGlkLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQZWVyKSkgcmV0dXJuIG5ldyBQZWVyKGlkLCBvcHRpb25zKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgLy8gRGVhbCB3aXRoIG92ZXJsb2FkaW5nXG4gIGlmIChpZCAmJiBpZC5jb25zdHJ1Y3RvciA9PSBPYmplY3QpIHtcbiAgICBvcHRpb25zID0gaWQ7XG4gICAgaWQgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoaWQpIHtcbiAgICAvLyBFbnN1cmUgaWQgaXMgYSBzdHJpbmdcbiAgICBpZCA9IGlkLnRvU3RyaW5nKCk7XG4gIH1cbiAgLy9cblxuICAvLyBDb25maWd1cml6ZSBvcHRpb25zXG4gIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgZGVidWc6IDAsIC8vIDE6IEVycm9ycywgMjogV2FybmluZ3MsIDM6IEFsbCBsb2dzXG4gICAgaG9zdDogdXRpbC5DTE9VRF9IT1NULFxuICAgIHBvcnQ6IHV0aWwuQ0xPVURfUE9SVCxcbiAgICBrZXk6ICdwZWVyanMnLFxuICAgIHBhdGg6ICcvJyxcbiAgICBjb25maWc6IHV0aWwuZGVmYXVsdENvbmZpZ1xuICB9LCBvcHRpb25zKTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgLy8gRGV0ZWN0IHJlbGF0aXZlIFVSTCBob3N0LlxuICBpZiAob3B0aW9ucy5ob3N0ID09PSAnLycpIHtcbiAgICBvcHRpb25zLmhvc3QgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG4gIH1cbiAgLy8gU2V0IHBhdGggY29ycmVjdGx5LlxuICBpZiAob3B0aW9ucy5wYXRoWzBdICE9PSAnLycpIHtcbiAgICBvcHRpb25zLnBhdGggPSAnLycgKyBvcHRpb25zLnBhdGg7XG4gIH1cbiAgaWYgKG9wdGlvbnMucGF0aFtvcHRpb25zLnBhdGgubGVuZ3RoIC0gMV0gIT09ICcvJykge1xuICAgIG9wdGlvbnMucGF0aCArPSAnLyc7XG4gIH1cblxuICAvLyBTZXQgd2hldGhlciB3ZSB1c2UgU1NMIHRvIHNhbWUgYXMgY3VycmVudCBob3N0XG4gIGlmIChvcHRpb25zLnNlY3VyZSA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuaG9zdCAhPT0gdXRpbC5DTE9VRF9IT1NUKSB7XG4gICAgb3B0aW9ucy5zZWN1cmUgPSB1dGlsLmlzU2VjdXJlKCk7XG4gIH1cbiAgLy8gU2V0IGEgY3VzdG9tIGxvZyBmdW5jdGlvbiBpZiBwcmVzZW50XG4gIGlmIChvcHRpb25zLmxvZ0Z1bmN0aW9uKSB7XG4gICAgdXRpbC5zZXRMb2dGdW5jdGlvbihvcHRpb25zLmxvZ0Z1bmN0aW9uKTtcbiAgfVxuICB1dGlsLnNldExvZ0xldmVsKG9wdGlvbnMuZGVidWcpO1xuICAvL1xuXG4gIC8vIFNhbml0eSBjaGVja3NcbiAgLy8gRW5zdXJlIFdlYlJUQyBzdXBwb3J0ZWRcbiAgaWYgKCF1dGlsLnN1cHBvcnRzLmF1ZGlvVmlkZW8gJiYgIXV0aWwuc3VwcG9ydHMuZGF0YSApIHtcbiAgICB0aGlzLl9kZWxheWVkQWJvcnQoJ2Jyb3dzZXItaW5jb21wYXRpYmxlJywgJ1RoZSBjdXJyZW50IGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJSVEMnKTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gRW5zdXJlIGFscGhhbnVtZXJpYyBpZFxuICBpZiAoIXV0aWwudmFsaWRhdGVJZChpZCkpIHtcbiAgICB0aGlzLl9kZWxheWVkQWJvcnQoJ2ludmFsaWQtaWQnLCAnSUQgXCInICsgaWQgKyAnXCIgaXMgaW52YWxpZCcpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBFbnN1cmUgdmFsaWQga2V5XG4gIGlmICghdXRpbC52YWxpZGF0ZUtleShvcHRpb25zLmtleSkpIHtcbiAgICB0aGlzLl9kZWxheWVkQWJvcnQoJ2ludmFsaWQta2V5JywgJ0FQSSBLRVkgXCInICsgb3B0aW9ucy5rZXkgKyAnXCIgaXMgaW52YWxpZCcpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBFbnN1cmUgbm90IHVzaW5nIHVuc2VjdXJlIGNsb3VkIHNlcnZlciBvbiBTU0wgcGFnZVxuICBpZiAob3B0aW9ucy5zZWN1cmUgJiYgb3B0aW9ucy5ob3N0ID09PSAnMC5wZWVyanMuY29tJykge1xuICAgIHRoaXMuX2RlbGF5ZWRBYm9ydCgnc3NsLXVuYXZhaWxhYmxlJyxcbiAgICAgICdUaGUgY2xvdWQgc2VydmVyIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IEhUVFBTLiBQbGVhc2UgcnVuIHlvdXIgb3duIFBlZXJTZXJ2ZXIgdG8gdXNlIEhUVFBTLicpO1xuICAgIHJldHVybjtcbiAgfVxuICAvL1xuXG4gIC8vIFN0YXRlcy5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gQ29ubmVjdGlvbnMgaGF2ZSBiZWVuIGtpbGxlZFxuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IGZhbHNlOyAvLyBDb25uZWN0aW9uIHRvIFBlZXJTZXJ2ZXIga2lsbGVkIG1hbnVhbGx5IGJ1dCBQMlAgY29ubmVjdGlvbnMgc3RpbGwgYWN0aXZlXG4gIHRoaXMub3BlbiA9IGZhbHNlOyAvLyBTb2NrZXRzIGFuZCBzdWNoIGFyZSBub3QgeWV0IG9wZW4uXG4gIC8vXG5cbiAgLy8gUmVmZXJlbmNlc1xuICB0aGlzLmNvbm5lY3Rpb25zID0ge307IC8vIERhdGFDb25uZWN0aW9ucyBmb3IgdGhpcyBwZWVyLlxuICB0aGlzLl9sb3N0TWVzc2FnZXMgPSB7fTsgLy8gc3JjID0+IFtsaXN0IG9mIG1lc3NhZ2VzXVxuICAvL1xuXG4gIC8vIEluaXRpYWxpemUgdGhlICdzb2NrZXQnICh3aGljaCBpcyBhY3R1YWxseSBhIG1peCBvZiBYSFIgc3RyZWFtaW5nIGFuZFxuICAvLyB3ZWJzb2NrZXRzLilcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnNvY2tldCA9IG5ldyBTb2NrZXQodGhpcy5vcHRpb25zLnNlY3VyZSwgdGhpcy5vcHRpb25zLmhvc3QsIHRoaXMub3B0aW9ucy5wb3J0LCB0aGlzLm9wdGlvbnMucGF0aCwgdGhpcy5vcHRpb25zLmtleSk7XG4gIHRoaXMuc29ja2V0Lm9uKCdtZXNzYWdlJywgZnVuY3Rpb24oZGF0YSkge1xuICAgIHNlbGYuX2hhbmRsZU1lc3NhZ2UoZGF0YSk7XG4gIH0pO1xuICB0aGlzLnNvY2tldC5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgIHNlbGYuX2Fib3J0KCdzb2NrZXQtZXJyb3InLCBlcnJvcik7XG4gIH0pO1xuICB0aGlzLnNvY2tldC5vbignY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXNlbGYuZGlzY29ubmVjdGVkKSB7IC8vIElmIHdlIGhhdmVuJ3QgZXhwbGljaXRseSBkaXNjb25uZWN0ZWQsIGVtaXQgZXJyb3IuXG4gICAgICBzZWxmLl9hYm9ydCgnc29ja2V0LWNsb3NlZCcsICdVbmRlcmx5aW5nIHNvY2tldCBpcyBhbHJlYWR5IGNsb3NlZC4nKTtcbiAgICB9XG4gIH0pO1xuICAvL1xuXG4gIC8vIFN0YXJ0IHRoZSBjb25uZWN0aW9uc1xuICBpZiAoaWQpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplKGlkKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9yZXRyaWV2ZUlkKCk7XG4gIH1cbiAgLy9cbn07XG5cbnV0aWwuaW5oZXJpdHMoUGVlciwgRXZlbnRFbWl0dGVyKTtcblxuLyoqIEdldCBhIHVuaXF1ZSBJRCBmcm9tIHRoZSBzZXJ2ZXIgdmlhIFhIUi4gKi9cblBlZXIucHJvdG90eXBlLl9yZXRyaWV2ZUlkID0gZnVuY3Rpb24oY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgaHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICB2YXIgcHJvdG9jb2wgPSB0aGlzLm9wdGlvbnMuc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJztcbiAgdmFyIHVybCA9IHByb3RvY29sICsgdGhpcy5vcHRpb25zLmhvc3QgKyAnOicgKyB0aGlzLm9wdGlvbnMucG9ydFxuICAgICsgdGhpcy5vcHRpb25zLnBhdGggKyB0aGlzLm9wdGlvbnMua2V5ICsgJy9pZCc7XG4gIHZhciBxdWVyeVN0cmluZyA9ICc/dHM9JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgJycgKyBNYXRoLnJhbmRvbSgpO1xuICB1cmwgKz0gcXVlcnlTdHJpbmc7XG5cbiAgLy8gSWYgdGhlcmUncyBubyBJRCB3ZSBuZWVkIHRvIHdhaXQgZm9yIG9uZSBiZWZvcmUgdHJ5aW5nIHRvIGluaXQgc29ja2V0LlxuICBodHRwLm9wZW4oJ2dldCcsIHVybCwgdHJ1ZSk7XG4gIGh0dHAub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICB1dGlsLmVycm9yKCdFcnJvciByZXRyaWV2aW5nIElEJywgZSk7XG4gICAgdmFyIHBhdGhFcnJvciA9ICcnO1xuICAgIGlmIChzZWxmLm9wdGlvbnMucGF0aCA9PT0gJy8nICYmIHNlbGYub3B0aW9ucy5ob3N0ICE9PSB1dGlsLkNMT1VEX0hPU1QpIHtcbiAgICAgIHBhdGhFcnJvciA9ICcgSWYgeW91IHBhc3NlZCBpbiBhIGBwYXRoYCB0byB5b3VyIHNlbGYtaG9zdGVkIFBlZXJTZXJ2ZXIsICdcbiAgICAgICAgKyAneW91XFwnbGwgYWxzbyBuZWVkIHRvIHBhc3MgaW4gdGhhdCBzYW1lIHBhdGggd2hlbiBjcmVhdGluZyBhIG5ldydcbiAgICAgICAgKyAnIFBlZXIuJztcbiAgICB9XG4gICAgc2VsZi5fYWJvcnQoJ3NlcnZlci1lcnJvcicsICdDb3VsZCBub3QgZ2V0IGFuIElEIGZyb20gdGhlIHNlcnZlci4nICsgcGF0aEVycm9yKTtcbiAgfVxuICBodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChodHRwLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGh0dHAuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIGh0dHAub25lcnJvcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLl9pbml0aWFsaXplKGh0dHAucmVzcG9uc2VUZXh0KTtcbiAgfTtcbiAgaHR0cC5zZW5kKG51bGwpO1xufTtcblxuLyoqIEluaXRpYWxpemUgYSBjb25uZWN0aW9uIHdpdGggdGhlIHNlcnZlci4gKi9cblBlZXIucHJvdG90eXBlLl9pbml0aWFsaXplID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuc29ja2V0LnN0YXJ0KHRoaXMuaWQpO1xufVxuXG4vKiogSGFuZGxlcyBtZXNzYWdlcyBmcm9tIHRoZSBzZXJ2ZXIuICovXG5QZWVyLnByb3RvdHlwZS5faGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgdmFyIHR5cGUgPSBtZXNzYWdlLnR5cGU7XG4gIHZhciBwYXlsb2FkID0gbWVzc2FnZS5wYXlsb2FkO1xuICB2YXIgcGVlciA9IG1lc3NhZ2Uuc3JjO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ09QRU4nOiAvLyBUaGUgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyIGlzIG9wZW4uXG4gICAgICB0aGlzLmVtaXQoJ29wZW4nLCB0aGlzLmlkKTtcbiAgICAgIHRoaXMub3BlbiA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdFUlJPUic6IC8vIFNlcnZlciBlcnJvci5cbiAgICAgIHRoaXMuX2Fib3J0KCdzZXJ2ZXItZXJyb3InLCBwYXlsb2FkLm1zZyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdJRC1UQUtFTic6IC8vIFRoZSBzZWxlY3RlZCBJRCBpcyB0YWtlbi5cbiAgICAgIHRoaXMuX2Fib3J0KCd1bmF2YWlsYWJsZS1pZCcsICdJRCBgJyArIHRoaXMuaWQgKyAnYCBpcyB0YWtlbicpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnSU5WQUxJRC1LRVknOiAvLyBUaGUgZ2l2ZW4gQVBJIGtleSBjYW5ub3QgYmUgZm91bmQuXG4gICAgICB0aGlzLl9hYm9ydCgnaW52YWxpZC1rZXknLCAnQVBJIEtFWSBcIicgKyB0aGlzLm9wdGlvbnMua2V5ICsgJ1wiIGlzIGludmFsaWQnKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgLy9cbiAgICBjYXNlICdMRUFWRSc6IC8vIEFub3RoZXIgcGVlciBoYXMgY2xvc2VkIGl0cyBjb25uZWN0aW9uIHRvIHRoaXMgcGVlci5cbiAgICAgIHV0aWwubG9nKCdSZWNlaXZlZCBsZWF2ZSBtZXNzYWdlIGZyb20nLCBwZWVyKTtcbiAgICAgIHRoaXMuX2NsZWFudXBQZWVyKHBlZXIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdFWFBJUkUnOiAvLyBUaGUgb2ZmZXIgc2VudCB0byBhIHBlZXIgaGFzIGV4cGlyZWQgd2l0aG91dCByZXNwb25zZS5cbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb25uZWN0IHRvIHBlZXIgJyArIHBlZXIpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ09GRkVSJzogLy8gd2Ugc2hvdWxkIGNvbnNpZGVyIHN3aXRjaGluZyB0aGlzIHRvIENBTEwvQ09OTkVDVCwgYnV0IHRoaXMgaXMgdGhlIGxlYXN0IGJyZWFraW5nIG9wdGlvbi5cbiAgICAgIHZhciBjb25uZWN0aW9uSWQgPSBwYXlsb2FkLmNvbm5lY3Rpb25JZDtcbiAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5nZXRDb25uZWN0aW9uKHBlZXIsIGNvbm5lY3Rpb25JZCk7XG5cbiAgICAgIGlmIChjb25uZWN0aW9uKSB7XG4gICAgICAgIHV0aWwud2FybignT2ZmZXIgcmVjZWl2ZWQgZm9yIGV4aXN0aW5nIENvbm5lY3Rpb24gSUQ6JywgY29ubmVjdGlvbklkKTtcbiAgICAgICAgLy9jb25uZWN0aW9uLmhhbmRsZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY29ubmVjdGlvbi5cbiAgICAgICAgaWYgKHBheWxvYWQudHlwZSA9PT0gJ21lZGlhJykge1xuICAgICAgICAgIHZhciBjb25uZWN0aW9uID0gbmV3IE1lZGlhQ29ubmVjdGlvbihwZWVyLCB0aGlzLCB7XG4gICAgICAgICAgICBjb25uZWN0aW9uSWQ6IGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHBheWxvYWQubWV0YWRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9hZGRDb25uZWN0aW9uKHBlZXIsIGNvbm5lY3Rpb24pO1xuICAgICAgICAgIHRoaXMuZW1pdCgnY2FsbCcsIGNvbm5lY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWQudHlwZSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgY29ubmVjdGlvbiA9IG5ldyBEYXRhQ29ubmVjdGlvbihwZWVyLCB0aGlzLCB7XG4gICAgICAgICAgICBjb25uZWN0aW9uSWQ6IGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHBheWxvYWQubWV0YWRhdGEsXG4gICAgICAgICAgICBsYWJlbDogcGF5bG9hZC5sYWJlbCxcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb246IHBheWxvYWQuc2VyaWFsaXphdGlvbixcbiAgICAgICAgICAgIHJlbGlhYmxlOiBwYXlsb2FkLnJlbGlhYmxlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5fYWRkQ29ubmVjdGlvbihwZWVyLCBjb25uZWN0aW9uKTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3Rpb24nLCBjb25uZWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1dGlsLndhcm4oJ1JlY2VpdmVkIG1hbGZvcm1lZCBjb25uZWN0aW9uIHR5cGU6JywgcGF5bG9hZC50eXBlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCBtZXNzYWdlcy5cbiAgICAgICAgdmFyIG1lc3NhZ2VzID0gdGhpcy5fZ2V0TWVzc2FnZXMoY29ubmVjdGlvbklkKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbWVzc2FnZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMSkge1xuICAgICAgICAgIGNvbm5lY3Rpb24uaGFuZGxlTWVzc2FnZShtZXNzYWdlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoIXBheWxvYWQpIHtcbiAgICAgICAgdXRpbC53YXJuKCdZb3UgcmVjZWl2ZWQgYSBtYWxmb3JtZWQgbWVzc2FnZSBmcm9tICcgKyBwZWVyICsgJyBvZiB0eXBlICcgKyB0eXBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWQgPSBwYXlsb2FkLmNvbm5lY3Rpb25JZDtcbiAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5nZXRDb25uZWN0aW9uKHBlZXIsIGlkKTtcblxuICAgICAgaWYgKGNvbm5lY3Rpb24gJiYgY29ubmVjdGlvbi5wYykge1xuICAgICAgICAvLyBQYXNzIGl0IG9uLlxuICAgICAgICBjb25uZWN0aW9uLmhhbmRsZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICB9IGVsc2UgaWYgKGlkKSB7XG4gICAgICAgIC8vIFN0b3JlIGZvciBwb3NzaWJsZSBsYXRlciB1c2VcbiAgICAgICAgdGhpcy5fc3RvcmVNZXNzYWdlKGlkLCBtZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwud2FybignWW91IHJlY2VpdmVkIGFuIHVucmVjb2duaXplZCBtZXNzYWdlOicsIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuLyoqIFN0b3JlcyBtZXNzYWdlcyB3aXRob3V0IGEgc2V0IHVwIGNvbm5lY3Rpb24sIHRvIGJlIGNsYWltZWQgbGF0ZXIuICovXG5QZWVyLnByb3RvdHlwZS5fc3RvcmVNZXNzYWdlID0gZnVuY3Rpb24oY29ubmVjdGlvbklkLCBtZXNzYWdlKSB7XG4gIGlmICghdGhpcy5fbG9zdE1lc3NhZ2VzW2Nvbm5lY3Rpb25JZF0pIHtcbiAgICB0aGlzLl9sb3N0TWVzc2FnZXNbY29ubmVjdGlvbklkXSA9IFtdO1xuICB9XG4gIHRoaXMuX2xvc3RNZXNzYWdlc1tjb25uZWN0aW9uSWRdLnB1c2gobWVzc2FnZSk7XG59XG5cbi8qKiBSZXRyaWV2ZSBtZXNzYWdlcyBmcm9tIGxvc3QgbWVzc2FnZSBzdG9yZSAqL1xuUGVlci5wcm90b3R5cGUuX2dldE1lc3NhZ2VzID0gZnVuY3Rpb24oY29ubmVjdGlvbklkKSB7XG4gIHZhciBtZXNzYWdlcyA9IHRoaXMuX2xvc3RNZXNzYWdlc1tjb25uZWN0aW9uSWRdO1xuICBpZiAobWVzc2FnZXMpIHtcbiAgICBkZWxldGUgdGhpcy5fbG9zdE1lc3NhZ2VzW2Nvbm5lY3Rpb25JZF07XG4gICAgcmV0dXJuIG1lc3NhZ2VzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBEYXRhQ29ubmVjdGlvbiB0byB0aGUgc3BlY2lmaWVkIHBlZXIuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBhXG4gKiBjb21wbGV0ZSBsaXN0IG9mIG9wdGlvbnMuXG4gKi9cblBlZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihwZWVyLCBvcHRpb25zKSB7XG4gIGlmICh0aGlzLmRpc2Nvbm5lY3RlZCkge1xuICAgIHV0aWwud2FybignWW91IGNhbm5vdCBjb25uZWN0IHRvIGEgbmV3IFBlZXIgYmVjYXVzZSB5b3UgY2FsbGVkICdcbiAgICAgICAgKyAnLmRpc2Nvbm5lY3QoKSBvbiB0aGlzIFBlZXIgYW5kIGVuZGVkIHlvdXIgY29ubmVjdGlvbiB3aXRoIHRoZSdcbiAgICAgICAgKyAnIHNlcnZlci4gWW91IGNhbiBjcmVhdGUgYSBuZXcgUGVlciB0byByZWNvbm5lY3QuJyk7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IGNvbm5lY3QgdG8gbmV3IFBlZXIgYWZ0ZXIgZGlzY29ubmVjdGluZyBmcm9tIHNlcnZlci4nKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjb25uZWN0aW9uID0gbmV3IERhdGFDb25uZWN0aW9uKHBlZXIsIHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLl9hZGRDb25uZWN0aW9uKHBlZXIsIGNvbm5lY3Rpb24pO1xuICByZXR1cm4gY29ubmVjdGlvbjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgTWVkaWFDb25uZWN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgcGVlci4gU2VlIGRvY3VtZW50YXRpb24gZm9yIGFcbiAqIGNvbXBsZXRlIGxpc3Qgb2Ygb3B0aW9ucy5cbiAqL1xuUGVlci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uKHBlZXIsIHN0cmVhbSwgb3B0aW9ucykge1xuICBpZiAodGhpcy5kaXNjb25uZWN0ZWQpIHtcbiAgICB1dGlsLndhcm4oJ1lvdSBjYW5ub3QgY29ubmVjdCB0byBhIG5ldyBQZWVyIGJlY2F1c2UgeW91IGNhbGxlZCAnXG4gICAgICAgICsgJy5kaXNjb25uZWN0KCkgb24gdGhpcyBQZWVyIGFuZCBlbmRlZCB5b3VyIGNvbm5lY3Rpb24gd2l0aCB0aGUnXG4gICAgICAgICsgJyBzZXJ2ZXIuIFlvdSBjYW4gY3JlYXRlIGEgbmV3IFBlZXIgdG8gcmVjb25uZWN0LicpO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBjb25uZWN0IHRvIG5ldyBQZWVyIGFmdGVyIGRpc2Nvbm5lY3RpbmcgZnJvbSBzZXJ2ZXIuJykpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXN0cmVhbSkge1xuICAgIHV0aWwuZXJyb3IoJ1RvIGNhbGwgYSBwZWVyLCB5b3UgbXVzdCBwcm92aWRlIGEgc3RyZWFtIGZyb20geW91ciBicm93c2VyXFwncyBgZ2V0VXNlck1lZGlhYC4nKTtcbiAgICByZXR1cm47XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgdmFyIGNhbGwgPSBuZXcgTWVkaWFDb25uZWN0aW9uKHBlZXIsIHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLl9hZGRDb25uZWN0aW9uKHBlZXIsIGNhbGwpO1xuICByZXR1cm4gY2FsbDtcbn1cblxuLyoqIEFkZCBhIGRhdGEvbWVkaWEgY29ubmVjdGlvbiB0byB0aGlzIHBlZXIuICovXG5QZWVyLnByb3RvdHlwZS5fYWRkQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKHBlZXIsIGNvbm5lY3Rpb24pIHtcbiAgaWYgKCF0aGlzLmNvbm5lY3Rpb25zW3BlZXJdKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uc1twZWVyXSA9IFtdO1xuICB9XG4gIHRoaXMuY29ubmVjdGlvbnNbcGVlcl0ucHVzaChjb25uZWN0aW9uKTtcbn1cblxuLyoqIFJldHJpZXZlIGEgZGF0YS9tZWRpYSBjb25uZWN0aW9uIGZvciB0aGlzIHBlZXIuICovXG5QZWVyLnByb3RvdHlwZS5nZXRDb25uZWN0aW9uID0gZnVuY3Rpb24ocGVlciwgaWQpIHtcbiAgdmFyIGNvbm5lY3Rpb25zID0gdGhpcy5jb25uZWN0aW9uc1twZWVyXTtcbiAgaWYgKCFjb25uZWN0aW9ucykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvbm5lY3Rpb25zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBpZiAoY29ubmVjdGlvbnNbaV0uaWQgPT09IGlkKSB7XG4gICAgICByZXR1cm4gY29ubmVjdGlvbnNbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5QZWVyLnByb3RvdHlwZS5fZGVsYXllZEFib3J0ID0gZnVuY3Rpb24odHlwZSwgbWVzc2FnZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHV0aWwuc2V0WmVyb1RpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICBzZWxmLl9hYm9ydCh0eXBlLCBtZXNzYWdlKTtcbiAgfSk7XG59XG5cbi8qKiBEZXN0cm95cyB0aGUgUGVlciBhbmQgZW1pdHMgYW4gZXJyb3IgbWVzc2FnZS4gKi9cblBlZXIucHJvdG90eXBlLl9hYm9ydCA9IGZ1bmN0aW9uKHR5cGUsIG1lc3NhZ2UpIHtcbiAgdXRpbC5lcnJvcignQWJvcnRpbmcuIEVycm9yOicsIG1lc3NhZ2UpO1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnIudHlwZSA9IHR5cGU7XG4gIHRoaXMuZGVzdHJveSgpO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIFBlZXI6IGNsb3NlcyBhbGwgYWN0aXZlIGNvbm5lY3Rpb25zIGFzIHdlbGwgYXMgdGhlIGNvbm5lY3Rpb25cbiAqICB0byB0aGUgc2VydmVyLlxuICogV2FybmluZzogVGhlIHBlZXIgY2FuIG5vIGxvbmdlciBjcmVhdGUgb3IgYWNjZXB0IGNvbm5lY3Rpb25zIGFmdGVyIGJlaW5nXG4gKiAgZGVzdHJveWVkLlxuICovXG5QZWVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG59XG5cblxuLyoqIERpc2Nvbm5lY3RzIGV2ZXJ5IGNvbm5lY3Rpb24gb24gdGhpcyBwZWVyLiAqL1xuUGVlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY29ubmVjdGlvbnMpIHtcbiAgICB2YXIgcGVlcnMgPSBPYmplY3Qua2V5cyh0aGlzLmNvbm5lY3Rpb25zKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwZWVycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB0aGlzLl9jbGVhbnVwUGVlcihwZWVyc1tpXSk7XG4gICAgfVxuICB9XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqIENsb3NlcyBhbGwgY29ubmVjdGlvbnMgdG8gdGhpcyBwZWVyLiAqL1xuUGVlci5wcm90b3R5cGUuX2NsZWFudXBQZWVyID0gZnVuY3Rpb24ocGVlcikge1xuICB2YXIgY29ubmVjdGlvbnMgPSB0aGlzLmNvbm5lY3Rpb25zW3BlZXJdO1xuICBmb3IgKHZhciBqID0gMCwgamogPSBjb25uZWN0aW9ucy5sZW5ndGg7IGogPCBqajsgaiArPSAxKSB7XG4gICAgY29ubmVjdGlvbnNbal0uY2xvc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc2Nvbm5lY3RzIHRoZSBQZWVyJ3MgY29ubmVjdGlvbiB0byB0aGUgUGVlclNlcnZlci4gRG9lcyBub3QgY2xvc2UgYW55XG4gKiAgYWN0aXZlIGNvbm5lY3Rpb25zLlxuICogV2FybmluZzogVGhlIHBlZXIgY2FuIG5vIGxvbmdlciBjcmVhdGUgb3IgYWNjZXB0IGNvbm5lY3Rpb25zIGFmdGVyIGJlaW5nXG4gKiAgZGlzY29ubmVjdGVkLiBJdCBhbHNvIGNhbm5vdCByZWNvbm5lY3QgdG8gdGhlIHNlcnZlci5cbiAqL1xuUGVlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHV0aWwuc2V0WmVyb1RpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICBpZiAoIXNlbGYuZGlzY29ubmVjdGVkKSB7XG4gICAgICBzZWxmLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICBzZWxmLm9wZW4gPSBmYWxzZTtcbiAgICAgIGlmIChzZWxmLnNvY2tldCkge1xuICAgICAgICBzZWxmLnNvY2tldC5jbG9zZSgpO1xuICAgICAgfVxuICAgICAgc2VsZi5pZCA9IG51bGw7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgYSBsaXN0IG9mIGF2YWlsYWJsZSBwZWVyIElEcy4gSWYgeW91J3JlIHJ1bm5pbmcgeW91ciBvd24gc2VydmVyLCB5b3UnbGxcbiAqIHdhbnQgdG8gc2V0IGFsbG93X2Rpc2NvdmVyeTogdHJ1ZSBpbiB0aGUgUGVlclNlcnZlciBvcHRpb25zLiBJZiB5b3UncmUgdXNpbmdcbiAqIHRoZSBjbG91ZCBzZXJ2ZXIsIGVtYWlsIHRlYW1AcGVlcmpzLmNvbSB0byBnZXQgdGhlIGZ1bmN0aW9uYWxpdHkgZW5hYmxlZCBmb3JcbiAqIHlvdXIga2V5LlxuICovXG5QZWVyLnByb3RvdHlwZS5saXN0QWxsUGVlcnMgPSBmdW5jdGlvbihjYikge1xuICBjYiA9IGNiIHx8IGZ1bmN0aW9uKCkge307XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgdmFyIHByb3RvY29sID0gdGhpcy5vcHRpb25zLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLyc7XG4gIHZhciB1cmwgPSBwcm90b2NvbCArIHRoaXMub3B0aW9ucy5ob3N0ICsgJzonICsgdGhpcy5vcHRpb25zLnBvcnRcbiAgICArIHRoaXMub3B0aW9ucy5wYXRoICsgdGhpcy5vcHRpb25zLmtleSArICcvcGVlcnMnO1xuICB2YXIgcXVlcnlTdHJpbmcgPSAnP3RzPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSArICcnICsgTWF0aC5yYW5kb20oKTtcbiAgdXJsICs9IHF1ZXJ5U3RyaW5nO1xuXG4gIC8vIElmIHRoZXJlJ3Mgbm8gSUQgd2UgbmVlZCB0byB3YWl0IGZvciBvbmUgYmVmb3JlIHRyeWluZyB0byBpbml0IHNvY2tldC5cbiAgaHR0cC5vcGVuKCdnZXQnLCB1cmwsIHRydWUpO1xuICBodHRwLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgc2VsZi5fYWJvcnQoJ3NlcnZlci1lcnJvcicsICdDb3VsZCBub3QgZ2V0IHBlZXJzIGZyb20gdGhlIHNlcnZlci4nKTtcbiAgICBjYihbXSk7XG4gIH1cbiAgaHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoaHR0cC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChodHRwLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICB2YXIgaGVscGZ1bEVycm9yID0gJyc7XG4gICAgICBpZiAoc2VsZi5vcHRpb25zLmhvc3QgIT09IHV0aWwuQ0xPVURfSE9TVCkge1xuICAgICAgICBoZWxwZnVsRXJyb3IgPSAnSXQgbG9va3MgbGlrZSB5b3VcXCdyZSB1c2luZyB0aGUgY2xvdWQgc2VydmVyLiBZb3UgY2FuIGVtYWlsICdcbiAgICAgICAgICArICd0ZWFtQHBlZXJqcy5jb20gdG8gZW5hYmxlIHBlZXIgbGlzdGluZyBmb3IgeW91ciBBUEkga2V5Lic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWxwZnVsRXJyb3IgPSAnWW91IG5lZWQgdG8gZW5hYmxlIGBhbGxvd19kaXNjb3ZlcnlgIG9uIHlvdXIgc2VsZi1ob3N0ZWQnXG4gICAgICAgICAgKyAnIFBlZXJTZXJ2ZXIgdG8gdXNlIHRoaXMgZmVhdHVyZS4nO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdCBkb2VzblxcJ3QgbG9vayBsaWtlIHlvdSBoYXZlIHBlcm1pc3Npb24gdG8gbGlzdCBwZWVycyBJRHMuICcgKyBoZWxwZnVsRXJyb3IpO1xuICAgICAgY2IoW10pO1xuICAgIH0gZWxzZSBpZiAoaHR0cC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgY2IoW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYihKU09OLnBhcnNlKGh0dHAucmVzcG9uc2VUZXh0KSk7XG4gICAgfVxuICB9O1xuICBodHRwLnNlbmQobnVsbCk7XG59XG5cbmV4cG9ydHMuUGVlciA9IFBlZXI7XG4vKipcbiAqIFdyYXBzIGEgRGF0YUNoYW5uZWwgYmV0d2VlbiB0d28gUGVlcnMuXG4gKi9cbmZ1bmN0aW9uIERhdGFDb25uZWN0aW9uKHBlZXIsIHByb3ZpZGVyLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEYXRhQ29ubmVjdGlvbikpIHJldHVybiBuZXcgRGF0YUNvbm5lY3Rpb24ocGVlciwgcHJvdmlkZXIsIG9wdGlvbnMpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgc2VyaWFsaXphdGlvbjogJ2JpbmFyeScsXG4gICAgcmVsaWFibGU6IGZhbHNlXG4gIH0sIG9wdGlvbnMpO1xuXG4gIC8vIENvbm5lY3Rpb24gaXMgbm90IG9wZW4geWV0LlxuICB0aGlzLm9wZW4gPSBmYWxzZTtcbiAgdGhpcy50eXBlID0gJ2RhdGEnO1xuICB0aGlzLnBlZXIgPSBwZWVyO1xuICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG5cbiAgdGhpcy5pZCA9IHRoaXMub3B0aW9ucy5jb25uZWN0aW9uSWQgfHwgRGF0YUNvbm5lY3Rpb24uX2lkUHJlZml4ICsgdXRpbC5yYW5kb21Ub2tlbigpO1xuXG4gIHRoaXMubGFiZWwgPSB0aGlzLm9wdGlvbnMubGFiZWwgfHwgdGhpcy5pZDtcbiAgdGhpcy5tZXRhZGF0YSA9IHRoaXMub3B0aW9ucy5tZXRhZGF0YTtcbiAgdGhpcy5zZXJpYWxpemF0aW9uID0gdGhpcy5vcHRpb25zLnNlcmlhbGl6YXRpb247XG4gIHRoaXMucmVsaWFibGUgPSB0aGlzLm9wdGlvbnMucmVsaWFibGU7XG5cbiAgLy8gRGF0YSBjaGFubmVsIGJ1ZmZlcmluZy5cbiAgdGhpcy5fYnVmZmVyID0gW107XG4gIHRoaXMuX2J1ZmZlcmluZyA9IGZhbHNlO1xuICB0aGlzLmJ1ZmZlclNpemUgPSAwO1xuXG4gIC8vIEZvciBzdG9yaW5nIGxhcmdlIGRhdGEuXG4gIHRoaXMuX2NodW5rZWREYXRhID0ge307XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5fcGF5bG9hZCkge1xuICAgIHRoaXMuX3BlZXJCcm93c2VyID0gdGhpcy5vcHRpb25zLl9wYXlsb2FkLmJyb3dzZXI7XG4gIH1cblxuICBOZWdvdGlhdG9yLnN0YXJ0Q29ubmVjdGlvbihcbiAgICB0aGlzLFxuICAgIHRoaXMub3B0aW9ucy5fcGF5bG9hZCB8fCB7XG4gICAgICBvcmlnaW5hdG9yOiB0cnVlXG4gICAgfVxuICApO1xufVxuXG51dGlsLmluaGVyaXRzKERhdGFDb25uZWN0aW9uLCBFdmVudEVtaXR0ZXIpO1xuXG5EYXRhQ29ubmVjdGlvbi5faWRQcmVmaXggPSAnZGNfJztcblxuLyoqIENhbGxlZCBieSB0aGUgTmVnb3RpYXRvciB3aGVuIHRoZSBEYXRhQ2hhbm5lbCBpcyByZWFkeS4gKi9cbkRhdGFDb25uZWN0aW9uLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZGMpIHtcbiAgdGhpcy5fZGMgPSB0aGlzLmRhdGFDaGFubmVsID0gZGM7XG4gIHRoaXMuX2NvbmZpZ3VyZURhdGFDaGFubmVsKCk7XG59XG5cbkRhdGFDb25uZWN0aW9uLnByb3RvdHlwZS5fY29uZmlndXJlRGF0YUNoYW5uZWwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodXRpbC5zdXBwb3J0cy5zY3RwKSB7XG4gICAgdGhpcy5fZGMuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gIH1cbiAgdGhpcy5fZGMub25vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgdXRpbC5sb2coJ0RhdGEgY2hhbm5lbCBjb25uZWN0aW9uIHN1Y2Nlc3MnKTtcbiAgICBzZWxmLm9wZW4gPSB0cnVlO1xuICAgIHNlbGYuZW1pdCgnb3BlbicpO1xuICB9XG5cbiAgLy8gVXNlIHRoZSBSZWxpYWJsZSBzaGltIGZvciBub24gRmlyZWZveCBicm93c2Vyc1xuICBpZiAoIXV0aWwuc3VwcG9ydHMuc2N0cCAmJiB0aGlzLnJlbGlhYmxlKSB7XG4gICAgdGhpcy5fcmVsaWFibGUgPSBuZXcgUmVsaWFibGUodGhpcy5fZGMsIHV0aWwuZGVidWcpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3JlbGlhYmxlKSB7XG4gICAgdGhpcy5fcmVsaWFibGUub25tZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gICAgICBzZWxmLmVtaXQoJ2RhdGEnLCBtc2cpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZGMub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgc2VsZi5faGFuZGxlRGF0YU1lc3NhZ2UoZSk7XG4gICAgfTtcbiAgfVxuICB0aGlzLl9kYy5vbmNsb3NlID0gZnVuY3Rpb24oZSkge1xuICAgIHV0aWwubG9nKCdEYXRhQ2hhbm5lbCBjbG9zZWQgZm9yOicsIHNlbGYucGVlcik7XG4gICAgc2VsZi5jbG9zZSgpO1xuICB9O1xufVxuXG4vLyBIYW5kbGVzIGEgRGF0YUNoYW5uZWwgbWVzc2FnZS5cbkRhdGFDb25uZWN0aW9uLnByb3RvdHlwZS5faGFuZGxlRGF0YU1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGRhdGEgPSBlLmRhdGE7XG4gIHZhciBkYXRhdHlwZSA9IGRhdGEuY29uc3RydWN0b3I7XG4gIGlmICh0aGlzLnNlcmlhbGl6YXRpb24gPT09ICdiaW5hcnknIHx8IHRoaXMuc2VyaWFsaXphdGlvbiA9PT0gJ2JpbmFyeS11dGY4Jykge1xuICAgIGlmIChkYXRhdHlwZSA9PT0gQmxvYikge1xuICAgICAgLy8gRGF0YXR5cGUgc2hvdWxkIG5ldmVyIGJlIGJsb2JcbiAgICAgIHV0aWwuYmxvYlRvQXJyYXlCdWZmZXIoZGF0YSwgZnVuY3Rpb24oYWIpIHtcbiAgICAgICAgZGF0YSA9IHV0aWwudW5wYWNrKGFiKTtcbiAgICAgICAgc2VsZi5lbWl0KCdkYXRhJywgZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGRhdGF0eXBlID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgZGF0YSA9IHV0aWwudW5wYWNrKGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoZGF0YXR5cGUgPT09IFN0cmluZykge1xuICAgICAgLy8gU3RyaW5nIGZhbGxiYWNrIGZvciBiaW5hcnkgZGF0YSBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGJpbmFyeSB5ZXRcbiAgICAgIHZhciBhYiA9IHV0aWwuYmluYXJ5U3RyaW5nVG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgIGRhdGEgPSB1dGlsLnVucGFjayhhYik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuc2VyaWFsaXphdGlvbiA9PT0gJ2pzb24nKSB7XG4gICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gIH1cblxuICAvLyBDaGVjayBpZiB3ZSd2ZSBjaHVua2VkLS1pZiBzbywgcGllY2UgdGhpbmdzIGJhY2sgdG9nZXRoZXIuXG4gIC8vIFdlJ3JlIGd1YXJhbnRlZWQgdGhhdCB0aGlzIGlzbid0IDAuXG4gIGlmIChkYXRhLl9fcGVlckRhdGEpIHtcbiAgICB2YXIgaWQgPSBkYXRhLl9fcGVlckRhdGE7XG4gICAgdmFyIGNodW5rSW5mbyA9IHRoaXMuX2NodW5rZWREYXRhW2lkXSB8fCB7ZGF0YTogW10sIGNvdW50OiAwLCB0b3RhbDogZGF0YS50b3RhbH07XG5cbiAgICBjaHVua0luZm8uZGF0YVtkYXRhLm5dID0gZGF0YS5kYXRhO1xuICAgIGNodW5rSW5mby5jb3VudCArPSAxO1xuXG4gICAgaWYgKGNodW5rSW5mby50b3RhbCA9PT0gY2h1bmtJbmZvLmNvdW50KSB7XG4gICAgICAvLyBXZSd2ZSByZWNlaXZlZCBhbGwgdGhlIGNodW5rcy0tdGltZSB0byBjb25zdHJ1Y3QgdGhlIGNvbXBsZXRlIGRhdGEuXG4gICAgICBkYXRhID0gbmV3IEJsb2IoY2h1bmtJbmZvLmRhdGEpO1xuICAgICAgdGhpcy5faGFuZGxlRGF0YU1lc3NhZ2Uoe2RhdGE6IGRhdGF9KTtcblxuICAgICAgLy8gV2UgY2FuIGFsc28ganVzdCBkZWxldGUgdGhlIGNodW5rcyBub3cuXG4gICAgICBkZWxldGUgdGhpcy5fY2h1bmtlZERhdGFbaWRdO1xuICAgIH1cblxuICAgIHRoaXMuX2NodW5rZWREYXRhW2lkXSA9IGNodW5rSW5mbztcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBFeHBvc2VkIGZ1bmN0aW9uYWxpdHkgZm9yIHVzZXJzLlxuICovXG5cbi8qKiBBbGxvd3MgdXNlciB0byBjbG9zZSBjb25uZWN0aW9uLiAqL1xuRGF0YUNvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5vcGVuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMub3BlbiA9IGZhbHNlO1xuICBOZWdvdGlhdG9yLmNsZWFudXAodGhpcyk7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqIEFsbG93cyB1c2VyIHRvIHNlbmQgZGF0YS4gKi9cbkRhdGFDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSwgY2h1bmtlZCkge1xuICBpZiAoIXRoaXMub3Blbikge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gaXMgbm90IG9wZW4uIFlvdSBzaG91bGQgbGlzdGVuIGZvciB0aGUgYG9wZW5gIGV2ZW50IGJlZm9yZSBzZW5kaW5nIG1lc3NhZ2VzLicpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHRoaXMuX3JlbGlhYmxlKSB7XG4gICAgLy8gTm90ZTogcmVsaWFibGUgc2hpbSBzZW5kaW5nIHdpbGwgbWFrZSBpdCBzbyB0aGF0IHlvdSBjYW5ub3QgY3VzdG9taXplXG4gICAgLy8gc2VyaWFsaXphdGlvbi5cbiAgICB0aGlzLl9yZWxpYWJsZS5zZW5kKGRhdGEpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLnNlcmlhbGl6YXRpb24gPT09ICdqc29uJykge1xuICAgIHRoaXMuX2J1ZmZlcmVkU2VuZChKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gIH0gZWxzZSBpZiAodGhpcy5zZXJpYWxpemF0aW9uID09PSAnYmluYXJ5JyB8fCB0aGlzLnNlcmlhbGl6YXRpb24gPT09ICdiaW5hcnktdXRmOCcpIHtcbiAgICB2YXIgYmxvYiA9IHV0aWwucGFjayhkYXRhKTtcblxuICAgIC8vIEZvciBDaHJvbWUtRmlyZWZveCBpbnRlcm9wZXJhYmlsaXR5LCB3ZSBuZWVkIHRvIG1ha2UgRmlyZWZveCBcImNodW5rXCJcbiAgICAvLyB0aGUgZGF0YSBpdCBzZW5kcyBvdXQuXG4gICAgdmFyIG5lZWRzQ2h1bmtpbmcgPSB1dGlsLmNodW5rZWRCcm93c2Vyc1t0aGlzLl9wZWVyQnJvd3Nlcl0gfHwgdXRpbC5jaHVua2VkQnJvd3NlcnNbdXRpbC5icm93c2VyXTtcbiAgICBpZiAobmVlZHNDaHVua2luZyAmJiAhY2h1bmtlZCAmJiBibG9iLnNpemUgPiB1dGlsLmNodW5rZWRNVFUpIHtcbiAgICAgIHRoaXMuX3NlbmRDaHVua3MoYmxvYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGF0YUNoYW5uZWwgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgc3RyaW5ncy5cbiAgICBpZiAoIXV0aWwuc3VwcG9ydHMuc2N0cCkge1xuICAgICAgdXRpbC5ibG9iVG9CaW5hcnlTdHJpbmcoYmxvYiwgZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHNlbGYuX2J1ZmZlcmVkU2VuZChzdHIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghdXRpbC5zdXBwb3J0cy5iaW5hcnlCbG9iKSB7XG4gICAgICAvLyBXZSBvbmx5IGRvIHRoaXMgaWYgd2UgcmVhbGx5IG5lZWQgdG8gKGUuZy4gYmxvYnMgYXJlIG5vdCBzdXBwb3J0ZWQpLFxuICAgICAgLy8gYmVjYXVzZSB0aGlzIGNvbnZlcnNpb24gaXMgY29zdGx5LlxuICAgICAgdXRpbC5ibG9iVG9BcnJheUJ1ZmZlcihibG9iLCBmdW5jdGlvbihhYikge1xuICAgICAgICBzZWxmLl9idWZmZXJlZFNlbmQoYWIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkU2VuZChibG9iKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fYnVmZmVyZWRTZW5kKGRhdGEpO1xuICB9XG59XG5cbkRhdGFDb25uZWN0aW9uLnByb3RvdHlwZS5fYnVmZmVyZWRTZW5kID0gZnVuY3Rpb24obXNnKSB7XG4gIGlmICh0aGlzLl9idWZmZXJpbmcgfHwgIXRoaXMuX3RyeVNlbmQobXNnKSkge1xuICAgIHRoaXMuX2J1ZmZlci5wdXNoKG1zZyk7XG4gICAgdGhpcy5idWZmZXJTaXplID0gdGhpcy5fYnVmZmVyLmxlbmd0aDtcbiAgfVxufVxuXG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIHNlbmQgc3VjY2VlZHMuXG5EYXRhQ29ubmVjdGlvbi5wcm90b3R5cGUuX3RyeVNlbmQgPSBmdW5jdGlvbihtc2cpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLl9kYy5zZW5kKG1zZyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLl9idWZmZXJpbmcgPSB0cnVlO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBUcnkgYWdhaW4uXG4gICAgICBzZWxmLl9idWZmZXJpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYuX3RyeUJ1ZmZlcigpO1xuICAgIH0sIDEwMCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBUcnkgdG8gc2VuZCB0aGUgZmlyc3QgbWVzc2FnZSBpbiB0aGUgYnVmZmVyLlxuRGF0YUNvbm5lY3Rpb24ucHJvdG90eXBlLl90cnlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2J1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbXNnID0gdGhpcy5fYnVmZmVyWzBdO1xuXG4gIGlmICh0aGlzLl90cnlTZW5kKG1zZykpIHtcbiAgICB0aGlzLl9idWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLmJ1ZmZlclNpemUgPSB0aGlzLl9idWZmZXIubGVuZ3RoO1xuICAgIHRoaXMuX3RyeUJ1ZmZlcigpO1xuICB9XG59XG5cbkRhdGFDb25uZWN0aW9uLnByb3RvdHlwZS5fc2VuZENodW5rcyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgdmFyIGJsb2JzID0gdXRpbC5jaHVuayhibG9iKTtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gYmxvYnMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMSkge1xuICAgIHZhciBibG9iID0gYmxvYnNbaV07XG4gICAgdGhpcy5zZW5kKGJsb2IsIHRydWUpO1xuICB9XG59XG5cbkRhdGFDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICB2YXIgcGF5bG9hZCA9IG1lc3NhZ2UucGF5bG9hZDtcblxuICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgIGNhc2UgJ0FOU1dFUic6XG4gICAgICB0aGlzLl9wZWVyQnJvd3NlciA9IHBheWxvYWQuYnJvd3NlcjtcblxuICAgICAgLy8gRm9yd2FyZCB0byBuZWdvdGlhdG9yXG4gICAgICBOZWdvdGlhdG9yLmhhbmRsZVNEUChtZXNzYWdlLnR5cGUsIHRoaXMsIHBheWxvYWQuc2RwKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0NBTkRJREFURSc6XG4gICAgICBOZWdvdGlhdG9yLmhhbmRsZUNhbmRpZGF0ZSh0aGlzLCBwYXlsb2FkLmNhbmRpZGF0ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdXRpbC53YXJuKCdVbnJlY29nbml6ZWQgbWVzc2FnZSB0eXBlOicsIG1lc3NhZ2UudHlwZSwgJ2Zyb20gcGVlcjonLCB0aGlzLnBlZXIpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbi8qKlxuICogV3JhcHMgdGhlIHN0cmVhbWluZyBpbnRlcmZhY2UgYmV0d2VlbiB0d28gUGVlcnMuXG4gKi9cbmZ1bmN0aW9uIE1lZGlhQ29ubmVjdGlvbihwZWVyLCBwcm92aWRlciwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWVkaWFDb25uZWN0aW9uKSkgcmV0dXJuIG5ldyBNZWRpYUNvbm5lY3Rpb24ocGVlciwgcHJvdmlkZXIsIG9wdGlvbnMpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgb3B0aW9ucyk7XG5cbiAgdGhpcy5vcGVuID0gZmFsc2U7XG4gIHRoaXMudHlwZSA9ICdtZWRpYSc7XG4gIHRoaXMucGVlciA9IHBlZXI7XG4gIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgdGhpcy5tZXRhZGF0YSA9IHRoaXMub3B0aW9ucy5tZXRhZGF0YTtcbiAgdGhpcy5sb2NhbFN0cmVhbSA9IHRoaXMub3B0aW9ucy5fc3RyZWFtO1xuXG4gIHRoaXMuaWQgPSB0aGlzLm9wdGlvbnMuY29ubmVjdGlvbklkIHx8IE1lZGlhQ29ubmVjdGlvbi5faWRQcmVmaXggKyB1dGlsLnJhbmRvbVRva2VuKCk7XG4gIGlmICh0aGlzLmxvY2FsU3RyZWFtKSB7XG4gICAgTmVnb3RpYXRvci5zdGFydENvbm5lY3Rpb24oXG4gICAgICB0aGlzLFxuICAgICAge19zdHJlYW06IHRoaXMubG9jYWxTdHJlYW0sIG9yaWdpbmF0b3I6IHRydWV9XG4gICAgKTtcbiAgfVxufTtcblxudXRpbC5pbmhlcml0cyhNZWRpYUNvbm5lY3Rpb24sIEV2ZW50RW1pdHRlcik7XG5cbk1lZGlhQ29ubmVjdGlvbi5faWRQcmVmaXggPSAnbWNfJztcblxuTWVkaWFDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbihyZW1vdGVTdHJlYW0pIHtcbiAgdXRpbC5sb2coJ1JlY2VpdmluZyBzdHJlYW0nLCByZW1vdGVTdHJlYW0pO1xuXG4gIHRoaXMucmVtb3RlU3RyZWFtID0gcmVtb3RlU3RyZWFtO1xuICB0aGlzLmVtaXQoJ3N0cmVhbScsIHJlbW90ZVN0cmVhbSk7IC8vIFNob3VsZCB3ZSBjYWxsIHRoaXMgYG9wZW5gP1xuXG59O1xuXG5NZWRpYUNvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIHZhciBwYXlsb2FkID0gbWVzc2FnZS5wYXlsb2FkO1xuXG4gIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgY2FzZSAnQU5TV0VSJzpcbiAgICAgIC8vIEZvcndhcmQgdG8gbmVnb3RpYXRvclxuICAgICAgTmVnb3RpYXRvci5oYW5kbGVTRFAobWVzc2FnZS50eXBlLCB0aGlzLCBwYXlsb2FkLnNkcCk7XG4gICAgICB0aGlzLm9wZW4gPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQ0FORElEQVRFJzpcbiAgICAgIE5lZ290aWF0b3IuaGFuZGxlQ2FuZGlkYXRlKHRoaXMsIHBheWxvYWQuY2FuZGlkYXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB1dGlsLndhcm4oJ1VucmVjb2duaXplZCBtZXNzYWdlIHR5cGU6JywgbWVzc2FnZS50eXBlLCAnZnJvbSBwZWVyOicsIHRoaXMucGVlcik7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5NZWRpYUNvbm5lY3Rpb24ucHJvdG90eXBlLmFuc3dlciA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICBpZiAodGhpcy5sb2NhbFN0cmVhbSkge1xuICAgIHV0aWwud2FybignTG9jYWwgc3RyZWFtIGFscmVhZHkgZXhpc3RzIG9uIHRoaXMgTWVkaWFDb25uZWN0aW9uLiBBcmUgeW91IGFuc3dlcmluZyBhIGNhbGwgdHdpY2U/Jyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5vcHRpb25zLl9wYXlsb2FkLl9zdHJlYW0gPSBzdHJlYW07XG5cbiAgdGhpcy5sb2NhbFN0cmVhbSA9IHN0cmVhbTtcbiAgTmVnb3RpYXRvci5zdGFydENvbm5lY3Rpb24oXG4gICAgdGhpcyxcbiAgICB0aGlzLm9wdGlvbnMuX3BheWxvYWRcbiAgKVxuICAvLyBSZXRyaWV2ZSBsb3N0IG1lc3NhZ2VzIHN0b3JlZCBiZWNhdXNlIFBlZXJDb25uZWN0aW9uIG5vdCBzZXQgdXAuXG4gIHZhciBtZXNzYWdlcyA9IHRoaXMucHJvdmlkZXIuX2dldE1lc3NhZ2VzKHRoaXMuaWQpO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBtZXNzYWdlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAxKSB7XG4gICAgdGhpcy5oYW5kbGVNZXNzYWdlKG1lc3NhZ2VzW2ldKTtcbiAgfVxuICB0aGlzLm9wZW4gPSB0cnVlO1xufTtcblxuLyoqXG4gKiBFeHBvc2VkIGZ1bmN0aW9uYWxpdHkgZm9yIHVzZXJzLlxuICovXG5cbi8qKiBBbGxvd3MgdXNlciB0byBjbG9zZSBjb25uZWN0aW9uLiAqL1xuTWVkaWFDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMub3Blbikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLm9wZW4gPSBmYWxzZTtcbiAgTmVnb3RpYXRvci5jbGVhbnVwKHRoaXMpO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn07XG4vKipcbiAqIE1hbmFnZXMgYWxsIG5lZ290aWF0aW9ucyBiZXR3ZWVuIFBlZXJzLlxuICovXG52YXIgTmVnb3RpYXRvciA9IHtcbiAgcGNzOiB7XG4gICAgZGF0YToge30sXG4gICAgbWVkaWE6IHt9XG4gIH0sIC8vIHR5cGUgPT4ge3BlZXJJZDoge3BjX2lkOiBwY319LlxuICAvL3Byb3ZpZGVyczoge30sIC8vIHByb3ZpZGVyJ3MgaWQgPT4gcHJvdmlkZXJzICh0aGVyZSBtYXkgYmUgbXVsdGlwbGUgcHJvdmlkZXJzL2NsaWVudC5cbiAgcXVldWU6IFtdIC8vIGNvbm5lY3Rpb25zIHRoYXQgYXJlIGRlbGF5ZWQgZHVlIHRvIGEgUEMgYmVpbmcgaW4gdXNlLlxufVxuXG5OZWdvdGlhdG9yLl9pZFByZWZpeCA9ICdwY18nO1xuXG4vKiogUmV0dXJucyBhIFBlZXJDb25uZWN0aW9uIG9iamVjdCBzZXQgdXAgY29ycmVjdGx5IChmb3IgZGF0YSwgbWVkaWEpLiAqL1xuTmVnb3RpYXRvci5zdGFydENvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25uZWN0aW9uLCBvcHRpb25zKSB7XG4gIHZhciBwYyA9IE5lZ290aWF0b3IuX2dldFBlZXJDb25uZWN0aW9uKGNvbm5lY3Rpb24sIG9wdGlvbnMpO1xuXG4gIGlmIChjb25uZWN0aW9uLnR5cGUgPT09ICdtZWRpYScgJiYgb3B0aW9ucy5fc3RyZWFtKSB7XG4gICAgLy8gQWRkIHRoZSBzdHJlYW0uXG4gICAgcGMuYWRkU3RyZWFtKG9wdGlvbnMuX3N0cmVhbSk7XG4gIH1cblxuICAvLyBTZXQgdGhlIGNvbm5lY3Rpb24ncyBQQy5cbiAgY29ubmVjdGlvbi5wYyA9IGNvbm5lY3Rpb24ucGVlckNvbm5lY3Rpb24gPSBwYztcbiAgLy8gV2hhdCBkbyB3ZSBuZWVkIHRvIGRvIG5vdz9cbiAgaWYgKG9wdGlvbnMub3JpZ2luYXRvcikge1xuICAgIGlmIChjb25uZWN0aW9uLnR5cGUgPT09ICdkYXRhJykge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBkYXRhY2hhbm5lbC5cbiAgICAgIHZhciBjb25maWcgPSB7fTtcbiAgICAgIC8vIERyb3BwaW5nIHJlbGlhYmxlOmZhbHNlIHN1cHBvcnQsIHNpbmNlIGl0IHNlZW1zIHRvIGJlIGNyYXNoaW5nXG4gICAgICAvLyBDaHJvbWUuXG4gICAgICAvKmlmICh1dGlsLnN1cHBvcnRzLnNjdHAgJiYgIW9wdGlvbnMucmVsaWFibGUpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBjYW5vbmljYWwgcmVsaWFibGUgc3VwcG9ydC4uLlxuICAgICAgICBjb25maWcgPSB7bWF4UmV0cmFuc21pdHM6IDB9O1xuICAgICAgfSovXG4gICAgICAvLyBGYWxsYmFjayB0byBlbnN1cmUgb2xkZXIgYnJvd3NlcnMgZG9uJ3QgY3Jhc2guXG4gICAgICBpZiAoIXV0aWwuc3VwcG9ydHMuc2N0cCkge1xuICAgICAgICBjb25maWcgPSB7cmVsaWFibGU6IG9wdGlvbnMucmVsaWFibGV9O1xuICAgICAgfVxuICAgICAgdmFyIGRjID0gcGMuY3JlYXRlRGF0YUNoYW5uZWwoY29ubmVjdGlvbi5sYWJlbCwgY29uZmlnKTtcbiAgICAgIGNvbm5lY3Rpb24uaW5pdGlhbGl6ZShkYyk7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsLnN1cHBvcnRzLm9ubmVnb3RpYXRpb25uZWVkZWQpIHtcbiAgICAgIE5lZ290aWF0b3IuX21ha2VPZmZlcihjb25uZWN0aW9uKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgTmVnb3RpYXRvci5oYW5kbGVTRFAoJ09GRkVSJywgY29ubmVjdGlvbiwgb3B0aW9ucy5zZHApO1xuICB9XG59XG5cbk5lZ290aWF0b3IuX2dldFBlZXJDb25uZWN0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgb3B0aW9ucykge1xuICBpZiAoIU5lZ290aWF0b3IucGNzW2Nvbm5lY3Rpb24udHlwZV0pIHtcbiAgICB1dGlsLmVycm9yKGNvbm5lY3Rpb24udHlwZSArICcgaXMgbm90IGEgdmFsaWQgY29ubmVjdGlvbiB0eXBlLiBNYXliZSB5b3Ugb3ZlcnJvZGUgdGhlIGB0eXBlYCBwcm9wZXJ0eSBzb21ld2hlcmUuJyk7XG4gIH1cblxuICBpZiAoIU5lZ290aWF0b3IucGNzW2Nvbm5lY3Rpb24udHlwZV1bY29ubmVjdGlvbi5wZWVyXSkge1xuICAgIE5lZ290aWF0b3IucGNzW2Nvbm5lY3Rpb24udHlwZV1bY29ubmVjdGlvbi5wZWVyXSA9IHt9O1xuICB9XG4gIHZhciBwZWVyQ29ubmVjdGlvbnMgPSBOZWdvdGlhdG9yLnBjc1tjb25uZWN0aW9uLnR5cGVdW2Nvbm5lY3Rpb24ucGVlcl07XG5cbiAgdmFyIHBjO1xuICAvLyBOb3QgbXVsdGlwbGV4aW5nIHdoaWxlIEZGIGFuZCBDaHJvbWUgaGF2ZSBub3QtZ3JlYXQgc3VwcG9ydCBmb3IgaXQuXG4gIC8qaWYgKG9wdGlvbnMubXVsdGlwbGV4KSB7XG4gICAgaWRzID0gT2JqZWN0LmtleXMocGVlckNvbm5lY3Rpb25zKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBpZHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMSkge1xuICAgICAgcGMgPSBwZWVyQ29ubmVjdGlvbnNbaWRzW2ldXTtcbiAgICAgIGlmIChwYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ3N0YWJsZScpIHtcbiAgICAgICAgYnJlYWs7IC8vIFdlIGNhbiBnbyBhaGVhZCBhbmQgdXNlIHRoaXMgUEMuXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgKi9cbiAgaWYgKG9wdGlvbnMucGMpIHsgLy8gU2ltcGxlc3QgY2FzZTogUEMgaWQgYWxyZWFkeSBwcm92aWRlZCBmb3IgdXMuXG4gICAgcGMgPSBOZWdvdGlhdG9yLnBjc1tjb25uZWN0aW9uLnR5cGVdW2Nvbm5lY3Rpb24ucGVlcl1bb3B0aW9ucy5wY107XG4gIH1cblxuICBpZiAoIXBjIHx8IHBjLnNpZ25hbGluZ1N0YXRlICE9PSAnc3RhYmxlJykge1xuICAgIHBjID0gTmVnb3RpYXRvci5fc3RhcnRQZWVyQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gcGM7XG59XG5cbi8qXG5OZWdvdGlhdG9yLl9hZGRQcm92aWRlciA9IGZ1bmN0aW9uKHByb3ZpZGVyKSB7XG4gIGlmICgoIXByb3ZpZGVyLmlkICYmICFwcm92aWRlci5kaXNjb25uZWN0ZWQpIHx8ICFwcm92aWRlci5zb2NrZXQub3Blbikge1xuICAgIC8vIFdhaXQgZm9yIHByb3ZpZGVyIHRvIG9idGFpbiBhbiBJRC5cbiAgICBwcm92aWRlci5vbignb3BlbicsIGZ1bmN0aW9uKGlkKSB7XG4gICAgICBOZWdvdGlhdG9yLl9hZGRQcm92aWRlcihwcm92aWRlcik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgTmVnb3RpYXRvci5wcm92aWRlcnNbcHJvdmlkZXIuaWRdID0gcHJvdmlkZXI7XG4gIH1cbn0qL1xuXG5cbi8qKiBTdGFydCBhIFBDLiAqL1xuTmVnb3RpYXRvci5fc3RhcnRQZWVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgdXRpbC5sb2coJ0NyZWF0aW5nIFJUQ1BlZXJDb25uZWN0aW9uLicpO1xuXG4gIHZhciBpZCA9IE5lZ290aWF0b3IuX2lkUHJlZml4ICsgdXRpbC5yYW5kb21Ub2tlbigpO1xuICB2YXIgb3B0aW9uYWwgPSB7fTtcblxuICBpZiAoY29ubmVjdGlvbi50eXBlID09PSAnZGF0YScgJiYgIXV0aWwuc3VwcG9ydHMuc2N0cCkge1xuICAgIG9wdGlvbmFsID0ge29wdGlvbmFsOiBbe1J0cERhdGFDaGFubmVsczogdHJ1ZX1dfTtcbiAgfSBlbHNlIGlmIChjb25uZWN0aW9uLnR5cGUgPT09ICdtZWRpYScpIHtcbiAgICAvLyBJbnRlcm9wIHJlcSBmb3IgY2hyb21lLlxuICAgIG9wdGlvbmFsID0ge29wdGlvbmFsOiBbe0R0bHNTcnRwS2V5QWdyZWVtZW50OiB0cnVlfV19O1xuICB9XG5cbiAgdmFyIHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKGNvbm5lY3Rpb24ucHJvdmlkZXIub3B0aW9ucy5jb25maWcsIG9wdGlvbmFsKTtcbiAgTmVnb3RpYXRvci5wY3NbY29ubmVjdGlvbi50eXBlXVtjb25uZWN0aW9uLnBlZXJdW2lkXSA9IHBjO1xuXG4gIE5lZ290aWF0b3IuX3NldHVwTGlzdGVuZXJzKGNvbm5lY3Rpb24sIHBjLCBpZCk7XG5cbiAgcmV0dXJuIHBjO1xufVxuXG4vKiogU2V0IHVwIHZhcmlvdXMgV2ViUlRDIGxpc3RlbmVycy4gKi9cbk5lZ290aWF0b3IuX3NldHVwTGlzdGVuZXJzID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgcGMsIHBjX2lkKSB7XG4gIHZhciBwZWVySWQgPSBjb25uZWN0aW9uLnBlZXI7XG4gIHZhciBjb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uLmlkO1xuICB2YXIgcHJvdmlkZXIgPSBjb25uZWN0aW9uLnByb3ZpZGVyO1xuXG4gIC8vIElDRSBDQU5ESURBVEVTLlxuICB1dGlsLmxvZygnTGlzdGVuaW5nIGZvciBJQ0UgY2FuZGlkYXRlcy4nKTtcbiAgcGMub25pY2VjYW5kaWRhdGUgPSBmdW5jdGlvbihldnQpIHtcbiAgICBpZiAoZXZ0LmNhbmRpZGF0ZSkge1xuICAgICAgdXRpbC5sb2coJ1JlY2VpdmVkIElDRSBjYW5kaWRhdGVzIGZvcjonLCBjb25uZWN0aW9uLnBlZXIpO1xuICAgICAgcHJvdmlkZXIuc29ja2V0LnNlbmQoe1xuICAgICAgICB0eXBlOiAnQ0FORElEQVRFJyxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIGNhbmRpZGF0ZTogZXZ0LmNhbmRpZGF0ZSxcbiAgICAgICAgICB0eXBlOiBjb25uZWN0aW9uLnR5cGUsXG4gICAgICAgICAgY29ubmVjdGlvbklkOiBjb25uZWN0aW9uLmlkXG4gICAgICAgIH0sXG4gICAgICAgIGRzdDogcGVlcklkXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHBjLmljZUNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgIHV0aWwubG9nKCdpY2VDb25uZWN0aW9uU3RhdGUgaXMgZGlzY29ubmVjdGVkLCBjbG9zaW5nIGNvbm5lY3Rpb25zIHRvICcgKyBwZWVySWQpO1xuICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgcGMub25pY2VjYW5kaWRhdGUgPSB1dGlsLm5vb3A7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcblxuICAvLyBGYWxsYmFjayBmb3Igb2xkZXIgQ2hyb21lIGltcGxzLlxuICBwYy5vbmljZWNoYW5nZSA9IHBjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlO1xuXG4gIC8vIE9OTkVHT1RJQVRJT05ORUVERUQgKENocm9tZSlcbiAgdXRpbC5sb2coJ0xpc3RlbmluZyBmb3IgYG5lZ290aWF0aW9ubmVlZGVkYCcpO1xuICBwYy5vbm5lZ290aWF0aW9ubmVlZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdXRpbC5sb2coJ2BuZWdvdGlhdGlvbm5lZWRlZGAgdHJpZ2dlcmVkJyk7XG4gICAgaWYgKHBjLnNpZ25hbGluZ1N0YXRlID09ICdzdGFibGUnKSB7XG4gICAgICBOZWdvdGlhdG9yLl9tYWtlT2ZmZXIoY29ubmVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwubG9nKCdvbm5lZ290aWF0aW9ubmVlZGVkIHRyaWdnZXJlZCB3aGVuIG5vdCBzdGFibGUuIElzIGFub3RoZXIgY29ubmVjdGlvbiBiZWluZyBlc3RhYmxpc2hlZD8nKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gREFUQUNPTk5FQ1RJT04uXG4gIHV0aWwubG9nKCdMaXN0ZW5pbmcgZm9yIGRhdGEgY2hhbm5lbCcpO1xuICAvLyBGaXJlZCBiZXR3ZWVuIG9mZmVyIGFuZCBhbnN3ZXIsIHNvIG9wdGlvbnMgc2hvdWxkIGFscmVhZHkgYmUgc2F2ZWRcbiAgLy8gaW4gdGhlIG9wdGlvbnMgaGFzaC5cbiAgcGMub25kYXRhY2hhbm5lbCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIHV0aWwubG9nKCdSZWNlaXZlZCBkYXRhIGNoYW5uZWwnKTtcbiAgICB2YXIgZGMgPSBldnQuY2hhbm5lbDtcbiAgICB2YXIgY29ubmVjdGlvbiA9IHByb3ZpZGVyLmdldENvbm5lY3Rpb24ocGVlcklkLCBjb25uZWN0aW9uSWQpO1xuICAgIGNvbm5lY3Rpb24uaW5pdGlhbGl6ZShkYyk7XG4gIH07XG5cbiAgLy8gTUVESUFDT05ORUNUSU9OLlxuICB1dGlsLmxvZygnTGlzdGVuaW5nIGZvciByZW1vdGUgc3RyZWFtJyk7XG4gIHBjLm9uYWRkc3RyZWFtID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgdXRpbC5sb2coJ1JlY2VpdmVkIHJlbW90ZSBzdHJlYW0nKTtcbiAgICB2YXIgc3RyZWFtID0gZXZ0LnN0cmVhbTtcbiAgICBwcm92aWRlci5nZXRDb25uZWN0aW9uKHBlZXJJZCwgY29ubmVjdGlvbklkKS5hZGRTdHJlYW0oc3RyZWFtKTtcbiAgfTtcbn1cblxuTmVnb3RpYXRvci5jbGVhbnVwID0gZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICB1dGlsLmxvZygnQ2xlYW5pbmcgdXAgUGVlckNvbm5lY3Rpb24gdG8gJyArIGNvbm5lY3Rpb24ucGVlcik7XG5cbiAgdmFyIHBjID0gY29ubmVjdGlvbi5wYztcblxuICBpZiAoISFwYyAmJiAocGMucmVhZHlTdGF0ZSAhPT0gJ2Nsb3NlZCcgfHwgcGMuc2lnbmFsaW5nU3RhdGUgIT09ICdjbG9zZWQnKSkge1xuICAgIHBjLmNsb3NlKCk7XG4gICAgY29ubmVjdGlvbi5wYyA9IG51bGw7XG4gIH1cbn1cblxuTmVnb3RpYXRvci5fbWFrZU9mZmVyID0gZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICB2YXIgcGMgPSBjb25uZWN0aW9uLnBjO1xuICBwYy5jcmVhdGVPZmZlcihmdW5jdGlvbihvZmZlcikge1xuICAgIHV0aWwubG9nKCdDcmVhdGVkIG9mZmVyLicpO1xuXG4gICAgaWYgKCF1dGlsLnN1cHBvcnRzLnNjdHAgJiYgY29ubmVjdGlvbi50eXBlID09PSAnZGF0YScgJiYgY29ubmVjdGlvbi5yZWxpYWJsZSkge1xuICAgICAgb2ZmZXIuc2RwID0gUmVsaWFibGUuaGlnaGVyQmFuZHdpZHRoU0RQKG9mZmVyLnNkcCk7XG4gICAgfVxuXG4gICAgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlciwgZnVuY3Rpb24oKSB7XG4gICAgICB1dGlsLmxvZygnU2V0IGxvY2FsRGVzY3JpcHRpb246IG9mZmVyJywgJ2ZvcjonLCBjb25uZWN0aW9uLnBlZXIpO1xuICAgICAgY29ubmVjdGlvbi5wcm92aWRlci5zb2NrZXQuc2VuZCh7XG4gICAgICAgIHR5cGU6ICdPRkZFUicsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBzZHA6IG9mZmVyLFxuICAgICAgICAgIHR5cGU6IGNvbm5lY3Rpb24udHlwZSxcbiAgICAgICAgICBsYWJlbDogY29ubmVjdGlvbi5sYWJlbCxcbiAgICAgICAgICBjb25uZWN0aW9uSWQ6IGNvbm5lY3Rpb24uaWQsXG4gICAgICAgICAgcmVsaWFibGU6IGNvbm5lY3Rpb24ucmVsaWFibGUsXG4gICAgICAgICAgc2VyaWFsaXphdGlvbjogY29ubmVjdGlvbi5zZXJpYWxpemF0aW9uLFxuICAgICAgICAgIG1ldGFkYXRhOiBjb25uZWN0aW9uLm1ldGFkYXRhLFxuICAgICAgICAgIGJyb3dzZXI6IHV0aWwuYnJvd3NlclxuICAgICAgICB9LFxuICAgICAgICBkc3Q6IGNvbm5lY3Rpb24ucGVlclxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBjb25uZWN0aW9uLnByb3ZpZGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIHV0aWwubG9nKCdGYWlsZWQgdG8gc2V0TG9jYWxEZXNjcmlwdGlvbiwgJywgZXJyKTtcbiAgICB9KTtcbiAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgY29ubmVjdGlvbi5wcm92aWRlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgdXRpbC5sb2coJ0ZhaWxlZCB0byBjcmVhdGVPZmZlciwgJywgZXJyKTtcbiAgfSwgY29ubmVjdGlvbi5vcHRpb25zLmNvbnN0cmFpbnRzKTtcbn1cblxuTmVnb3RpYXRvci5fbWFrZUFuc3dlciA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgdmFyIHBjID0gY29ubmVjdGlvbi5wYztcblxuICBwYy5jcmVhdGVBbnN3ZXIoZnVuY3Rpb24oYW5zd2VyKSB7XG4gICAgdXRpbC5sb2coJ0NyZWF0ZWQgYW5zd2VyLicpO1xuXG4gICAgaWYgKCF1dGlsLnN1cHBvcnRzLnNjdHAgJiYgY29ubmVjdGlvbi50eXBlID09PSAnZGF0YScgJiYgY29ubmVjdGlvbi5yZWxpYWJsZSkge1xuICAgICAgYW5zd2VyLnNkcCA9IFJlbGlhYmxlLmhpZ2hlckJhbmR3aWR0aFNEUChhbnN3ZXIuc2RwKTtcbiAgICB9XG5cbiAgICBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlciwgZnVuY3Rpb24oKSB7XG4gICAgICB1dGlsLmxvZygnU2V0IGxvY2FsRGVzY3JpcHRpb246IGFuc3dlcicsICdmb3I6JywgY29ubmVjdGlvbi5wZWVyKTtcbiAgICAgIGNvbm5lY3Rpb24ucHJvdmlkZXIuc29ja2V0LnNlbmQoe1xuICAgICAgICB0eXBlOiAnQU5TV0VSJyxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIHNkcDogYW5zd2VyLFxuICAgICAgICAgIHR5cGU6IGNvbm5lY3Rpb24udHlwZSxcbiAgICAgICAgICBjb25uZWN0aW9uSWQ6IGNvbm5lY3Rpb24uaWQsXG4gICAgICAgICAgYnJvd3NlcjogdXRpbC5icm93c2VyXG4gICAgICAgIH0sXG4gICAgICAgIGRzdDogY29ubmVjdGlvbi5wZWVyXG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGNvbm5lY3Rpb24ucHJvdmlkZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgdXRpbC5sb2coJ0ZhaWxlZCB0byBzZXRMb2NhbERlc2NyaXB0aW9uLCAnLCBlcnIpO1xuICAgIH0pO1xuICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICBjb25uZWN0aW9uLnByb3ZpZGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB1dGlsLmxvZygnRmFpbGVkIHRvIGNyZWF0ZSBhbnN3ZXIsICcsIGVycik7XG4gIH0pO1xufVxuXG4vKiogSGFuZGxlIGFuIFNEUC4gKi9cbk5lZ290aWF0b3IuaGFuZGxlU0RQID0gZnVuY3Rpb24odHlwZSwgY29ubmVjdGlvbiwgc2RwKSB7XG4gIHNkcCA9IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oc2RwKTtcbiAgdmFyIHBjID0gY29ubmVjdGlvbi5wYztcblxuICB1dGlsLmxvZygnU2V0dGluZyByZW1vdGUgZGVzY3JpcHRpb24nLCBzZHApO1xuICBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZHAsIGZ1bmN0aW9uKCkge1xuICAgIHV0aWwubG9nKCdTZXQgcmVtb3RlRGVzY3JpcHRpb246JywgdHlwZSwgJ2ZvcjonLCBjb25uZWN0aW9uLnBlZXIpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdPRkZFUicpIHtcbiAgICAgIE5lZ290aWF0b3IuX21ha2VBbnN3ZXIoY29ubmVjdGlvbik7XG4gICAgfVxuICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICBjb25uZWN0aW9uLnByb3ZpZGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB1dGlsLmxvZygnRmFpbGVkIHRvIHNldFJlbW90ZURlc2NyaXB0aW9uLCAnLCBlcnIpO1xuICB9KTtcbn1cblxuLyoqIEhhbmRsZSBhIGNhbmRpZGF0ZS4gKi9cbk5lZ290aWF0b3IuaGFuZGxlQ2FuZGlkYXRlID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgaWNlKSB7XG4gIHZhciBjYW5kaWRhdGUgPSBpY2UuY2FuZGlkYXRlO1xuICB2YXIgc2RwTUxpbmVJbmRleCA9IGljZS5zZHBNTGluZUluZGV4O1xuICBjb25uZWN0aW9uLnBjLmFkZEljZUNhbmRpZGF0ZShuZXcgUlRDSWNlQ2FuZGlkYXRlKHtcbiAgICBzZHBNTGluZUluZGV4OiBzZHBNTGluZUluZGV4LFxuICAgIGNhbmRpZGF0ZTogY2FuZGlkYXRlXG4gIH0pKTtcbiAgdXRpbC5sb2coJ0FkZGVkIElDRSBjYW5kaWRhdGUgZm9yOicsIGNvbm5lY3Rpb24ucGVlcik7XG59XG4vKipcbiAqIEFuIGFic3RyYWN0aW9uIG9uIHRvcCBvZiBXZWJTb2NrZXRzIGFuZCBYSFIgc3RyZWFtaW5nIHRvIHByb3ZpZGUgZmFzdGVzdFxuICogcG9zc2libGUgY29ubmVjdGlvbiBmb3IgcGVlcnMuXG4gKi9cbmZ1bmN0aW9uIFNvY2tldChzZWN1cmUsIGhvc3QsIHBvcnQsIHBhdGgsIGtleSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja2V0KSkgcmV0dXJuIG5ldyBTb2NrZXQoc2VjdXJlLCBob3N0LCBwb3J0LCBwYXRoLCBrZXkpO1xuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIC8vIERpc2Nvbm5lY3RlZCBtYW51YWxseS5cbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5fcXVldWUgPSBbXTtcblxuICB2YXIgaHR0cFByb3RvY29sID0gc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJztcbiAgdmFyIHdzUHJvdG9jb2wgPSBzZWN1cmUgPyAnd3NzOi8vJyA6ICd3czovLyc7XG4gIHRoaXMuX2h0dHBVcmwgPSBodHRwUHJvdG9jb2wgKyBob3N0ICsgJzonICsgcG9ydCArIHBhdGggKyBrZXk7XG4gIHRoaXMuX3dzVXJsID0gd3NQcm90b2NvbCArIGhvc3QgKyAnOicgKyBwb3J0ICsgcGF0aCArICdwZWVyanM/a2V5PScgKyBrZXk7XG59XG5cbnV0aWwuaW5oZXJpdHMoU29ja2V0LCBFdmVudEVtaXR0ZXIpO1xuXG5cbi8qKiBDaGVjayBpbiB3aXRoIElEIG9yIGdldCBvbmUgZnJvbSBzZXJ2ZXIuICovXG5Tb2NrZXQucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oaWQpIHsgIFxuICB0aGlzLmlkID0gaWQ7XG5cbiAgdmFyIHRva2VuID0gdXRpbC5yYW5kb21Ub2tlbigpO1xuICB0aGlzLl9odHRwVXJsICs9ICcvJyArIGlkICsgJy8nICsgdG9rZW47XG4gIHRoaXMuX3dzVXJsICs9ICcmaWQ9JytpZCsnJnRva2VuPScrdG9rZW47XG5cbiAgdGhpcy5fc3RhcnRYaHJTdHJlYW0oKTtcbiAgdGhpcy5fc3RhcnRXZWJTb2NrZXQoKTtcbn1cblxuXG4vKiogU3RhcnQgdXAgd2Vic29ja2V0IGNvbW11bmljYXRpb25zLiAqL1xuU29ja2V0LnByb3RvdHlwZS5fc3RhcnRXZWJTb2NrZXQgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuX3NvY2tldCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX3NvY2tldCA9IG5ldyBXZWJTb2NrZXQodGhpcy5fd3NVcmwpO1xuXG4gIHRoaXMuX3NvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBkYXRhO1xuICAgIHRyeSB7XG4gICAgICBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHV0aWwubG9nKCdJbnZhbGlkIHNlcnZlciBtZXNzYWdlJywgZXZlbnQuZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICB9IGNhdGNoICgkZSkge1xuICAgICAgY29uc29sZS5sb2coJ3BlZXIgZXJyb3InLCAkZSlcbiAgICB9XG4gIH07XG5cbiAgLy8gVGFrZSBjYXJlIG9mIHRoZSBxdWV1ZSBvZiBjb25uZWN0aW9ucyBpZiBuZWNlc3NhcnkgYW5kIG1ha2Ugc3VyZSBQZWVyIGtub3dzXG4gIC8vIHNvY2tldCBpcyBvcGVuLlxuICB0aGlzLl9zb2NrZXQub25vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuX3RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLl90aW1lb3V0KTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5faHR0cC5hYm9ydCgpO1xuICAgICAgICBzZWxmLl9odHRwID0gbnVsbDtcbiAgICAgIH0sIDUwMDApO1xuICAgIH1cbiAgICBzZWxmLl9zZW5kUXVldWVkTWVzc2FnZXMoKTtcbiAgICB1dGlsLmxvZygnU29ja2V0IG9wZW4nKTtcbiAgfTtcbn1cblxuLyoqIFN0YXJ0IFhIUiBzdHJlYW1pbmcuICovXG5Tb2NrZXQucHJvdG90eXBlLl9zdGFydFhoclN0cmVhbSA9IGZ1bmN0aW9uKG4pIHtcbiAgdHJ5IHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5faHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHRoaXMuX2h0dHAuX2luZGV4ID0gMTtcbiAgICB0aGlzLl9odHRwLl9zdHJlYW1JbmRleCA9IG4gfHwgMDtcbiAgICB0aGlzLl9odHRwLm9wZW4oJ3Bvc3QnLCB0aGlzLl9odHRwVXJsICsgJy9pZD9pPScgKyB0aGlzLl9odHRwLl9zdHJlYW1JbmRleCwgdHJ1ZSk7XG4gICAgdGhpcy5faHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT0gMiAmJiB0aGlzLm9sZCkge1xuICAgICAgICB0aGlzLm9sZC5hYm9ydCgpO1xuICAgICAgICBkZWxldGUgdGhpcy5vbGQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gMiAmJiB0aGlzLnN0YXR1cyA9PSAyMDAgJiYgdGhpcy5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgc2VsZi5faGFuZGxlU3RyZWFtKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5faHR0cC5zZW5kKG51bGwpO1xuICAgIHRoaXMuX3NldEhUVFBUaW1lb3V0KCk7XG4gIH0gY2F0Y2goZSkge1xuICAgIHV0aWwubG9nKCdYTUxIdHRwUmVxdWVzdCBub3QgYXZhaWxhYmxlOyBkZWZhdWx0aW5nIHRvIFdlYlNvY2tldHMnKTtcbiAgfVxufVxuXG5cbi8qKiBIYW5kbGVzIG9ucmVhZHlzdGF0ZWNoYW5nZSByZXNwb25zZSBhcyBhIHN0cmVhbS4gKi9cblNvY2tldC5wcm90b3R5cGUuX2hhbmRsZVN0cmVhbSA9IGZ1bmN0aW9uKGh0dHApIHtcbiAgLy8gMyBhbmQgNCBhcmUgbG9hZGluZy9kb25lIHN0YXRlLiBBbGwgb3RoZXJzIGFyZSBub3QgcmVsZXZhbnQuXG4gIHZhciBtZXNzYWdlcyA9IGh0dHAucmVzcG9uc2VUZXh0LnNwbGl0KCdcXG4nKTtcblxuICAvLyBDaGVjayB0byBzZWUgaWYgYW55dGhpbmcgbmVlZHMgdG8gYmUgcHJvY2Vzc2VkIG9uIGJ1ZmZlci5cbiAgaWYgKGh0dHAuX2J1ZmZlcikge1xuICAgIHdoaWxlIChodHRwLl9idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGluZGV4ID0gaHR0cC5fYnVmZmVyLnNoaWZ0KCk7XG4gICAgICB2YXIgYnVmZmVyZWRNZXNzYWdlID0gbWVzc2FnZXNbaW5kZXhdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYnVmZmVyZWRNZXNzYWdlID0gSlNPTi5wYXJzZShidWZmZXJlZE1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGh0dHAuX2J1ZmZlci5zaGlmdChpbmRleCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgYnVmZmVyZWRNZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbWVzc2FnZSA9IG1lc3NhZ2VzW2h0dHAuX2luZGV4XTtcbiAgaWYgKG1lc3NhZ2UpIHtcbiAgICBodHRwLl9pbmRleCArPSAxO1xuICAgIC8vIEJ1ZmZlcmluZy0tdGhpcyBtZXNzYWdlIGlzIGluY29tcGxldGUgYW5kIHdlJ2xsIGdldCB0byBpdCBuZXh0IHRpbWUuXG4gICAgLy8gVGhpcyBjaGVja3MgaWYgdGhlIGh0dHBSZXNwb25zZSBlbmRlZCBpbiBhIGBcXG5gLCBpbiB3aGljaCBjYXNlIHRoZSBsYXN0XG4gICAgLy8gZWxlbWVudCBvZiBtZXNzYWdlcyBzaG91bGQgYmUgdGhlIGVtcHR5IHN0cmluZy5cbiAgICBpZiAoaHR0cC5faW5kZXggPT09IG1lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgaWYgKCFodHRwLl9idWZmZXIpIHtcbiAgICAgICAgaHR0cC5fYnVmZmVyID0gW107XG4gICAgICB9XG4gICAgICBodHRwLl9idWZmZXIucHVzaChodHRwLl9pbmRleCAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBtZXNzYWdlID0gSlNPTi5wYXJzZShtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICB1dGlsLmxvZygnSW52YWxpZCBzZXJ2ZXIgbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cblxuU29ja2V0LnByb3RvdHlwZS5fc2V0SFRUUFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICB2YXIgb2xkID0gc2VsZi5faHR0cDtcbiAgICBpZiAoIXNlbGYuX3dzT3BlbigpKSB7XG4gICAgICBzZWxmLl9zdGFydFhoclN0cmVhbShvbGQuX3N0cmVhbUluZGV4ICsgMSk7XG4gICAgICBzZWxmLl9odHRwLm9sZCA9IG9sZDtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkLmFib3J0KCk7XG4gICAgfVxuICB9LCAyNTAwMCk7XG59XG5cbi8qKiBJcyB0aGUgd2Vic29ja2V0IGN1cnJlbnRseSBvcGVuPyAqL1xuU29ja2V0LnByb3RvdHlwZS5fd3NPcGVuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zb2NrZXQgJiYgdGhpcy5fc29ja2V0LnJlYWR5U3RhdGUgPT0gMTtcbn1cblxuLyoqIFNlbmQgcXVldWVkIG1lc3NhZ2VzLiAqL1xuU29ja2V0LnByb3RvdHlwZS5fc2VuZFF1ZXVlZE1lc3NhZ2VzID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSA8IGlpOyBpICs9IDEpIHtcbiAgICB0aGlzLnNlbmQodGhpcy5fcXVldWVbaV0pO1xuICB9XG59XG5cbi8qKiBFeHBvc2VkIHNlbmQgZm9yIERDICYgUGVlci4gKi9cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgaWYgKHRoaXMuZGlzY29ubmVjdGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgd2UgZGlkbid0IGdldCBhbiBJRCB5ZXQsIHdlIGNhbid0IHlldCBzZW5kIGFueXRoaW5nIHNvIHdlIHNob3VsZCBxdWV1ZVxuICAvLyB1cCB0aGVzZSBtZXNzYWdlcy5cbiAgaWYgKCF0aGlzLmlkKSB7XG4gICAgdGhpcy5fcXVldWUucHVzaChkYXRhKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWRhdGEudHlwZSkge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCAnSW52YWxpZCBtZXNzYWdlJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgaWYgKHRoaXMuX3dzT3BlbigpKSB7XG4gICAgdGhpcy5fc29ja2V0LnNlbmQobWVzc2FnZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB2YXIgdXJsID0gdGhpcy5faHR0cFVybCArICcvJyArIGRhdGEudHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIGh0dHAub3BlbigncG9zdCcsIHVybCwgdHJ1ZSk7XG4gICAgaHR0cC5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIGh0dHAuc2VuZChtZXNzYWdlKTtcbiAgfVxufVxuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5kaXNjb25uZWN0ZWQgJiYgdGhpcy5fd3NPcGVuKCkpIHtcbiAgICB0aGlzLl9zb2NrZXQuY2xvc2UoKTtcbiAgICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIH1cbn1cblxufSkodGhpcyk7IiwiLyogaHR0cHM6Ly9naXRodWIuY29tL2pha2VhcmNoaWJhbGQvZXM2LXByb21pc2UgKi9cbiFmdW5jdGlvbigpe3ZhciBhLGIsYyxkOyFmdW5jdGlvbigpe3ZhciBlPXt9LGY9e307YT1mdW5jdGlvbihhLGIsYyl7ZVthXT17ZGVwczpiLGNhbGxiYWNrOmN9fSxkPWM9Yj1mdW5jdGlvbihhKXtmdW5jdGlvbiBjKGIpe2lmKFwiLlwiIT09Yi5jaGFyQXQoMCkpcmV0dXJuIGI7Zm9yKHZhciBjPWIuc3BsaXQoXCIvXCIpLGQ9YS5zcGxpdChcIi9cIikuc2xpY2UoMCwtMSksZT0wLGY9Yy5sZW5ndGg7Zj5lO2UrKyl7dmFyIGc9Y1tlXTtpZihcIi4uXCI9PT1nKWQucG9wKCk7ZWxzZXtpZihcIi5cIj09PWcpY29udGludWU7ZC5wdXNoKGcpfX1yZXR1cm4gZC5qb2luKFwiL1wiKX1pZihkLl9lYWtfc2Vlbj1lLGZbYV0pcmV0dXJuIGZbYV07aWYoZlthXT17fSwhZVthXSl0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBtb2R1bGUgXCIrYSk7Zm9yKHZhciBnLGg9ZVthXSxpPWguZGVwcyxqPWguY2FsbGJhY2ssaz1bXSxsPTAsbT1pLmxlbmd0aDttPmw7bCsrKVwiZXhwb3J0c1wiPT09aVtsXT9rLnB1c2goZz17fSk6ay5wdXNoKGIoYyhpW2xdKSkpO3ZhciBuPWouYXBwbHkodGhpcyxrKTtyZXR1cm4gZlthXT1nfHxufX0oKSxhKFwicHJvbWlzZS9hbGxcIixbXCIuL3V0aWxzXCIsXCJleHBvcnRzXCJdLGZ1bmN0aW9uKGEsYil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYyhhKXt2YXIgYj10aGlzO2lmKCFkKGEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIGFsbC5cIik7cmV0dXJuIG5ldyBiKGZ1bmN0aW9uKGIsYyl7ZnVuY3Rpb24gZChhKXtyZXR1cm4gZnVuY3Rpb24oYil7ZihhLGIpfX1mdW5jdGlvbiBmKGEsYyl7aFthXT1jLDA9PT0tLWkmJmIoaCl9dmFyIGcsaD1bXSxpPWEubGVuZ3RoOzA9PT1pJiZiKFtdKTtmb3IodmFyIGo9MDtqPGEubGVuZ3RoO2orKylnPWFbal0sZyYmZShnLnRoZW4pP2cudGhlbihkKGopLGMpOmYoaixnKX0pfXZhciBkPWEuaXNBcnJheSxlPWEuaXNGdW5jdGlvbjtiLmFsbD1jfSksYShcInByb21pc2UvYXNhcFwiLFtcImV4cG9ydHNcIl0sZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYigpe3JldHVybiBmdW5jdGlvbigpe3Byb2Nlc3MubmV4dFRpY2soZSl9fWZ1bmN0aW9uIGMoKXt2YXIgYT0wLGI9bmV3IGkoZSksYz1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtyZXR1cm4gYi5vYnNlcnZlKGMse2NoYXJhY3RlckRhdGE6ITB9KSxmdW5jdGlvbigpe2MuZGF0YT1hPSsrYSUyfX1mdW5jdGlvbiBkKCl7cmV0dXJuIGZ1bmN0aW9uKCl7ai5zZXRUaW1lb3V0KGUsMSl9fWZ1bmN0aW9uIGUoKXtmb3IodmFyIGE9MDthPGsubGVuZ3RoO2ErKyl7dmFyIGI9a1thXSxjPWJbMF0sZD1iWzFdO2MoZCl9az1bXX1mdW5jdGlvbiBmKGEsYil7dmFyIGM9ay5wdXNoKFthLGJdKTsxPT09YyYmZygpfXZhciBnLGg9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6e30saT1oLk11dGF0aW9uT2JzZXJ2ZXJ8fGguV2ViS2l0TXV0YXRpb25PYnNlcnZlcixqPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOnZvaWQgMD09PXRoaXM/d2luZG93OnRoaXMsaz1bXTtnPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzJiZcIltvYmplY3QgcHJvY2Vzc11cIj09PXt9LnRvU3RyaW5nLmNhbGwocHJvY2Vzcyk/YigpOmk/YygpOmQoKSxhLmFzYXA9Zn0pLGEoXCJwcm9taXNlL2NvbmZpZ1wiLFtcImV4cG9ydHNcIl0sZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihhLGIpe3JldHVybiAyIT09YXJndW1lbnRzLmxlbmd0aD9jW2FdOihjW2FdPWIsdm9pZCAwKX12YXIgYz17aW5zdHJ1bWVudDohMX07YS5jb25maWc9YyxhLmNvbmZpZ3VyZT1ifSksYShcInByb21pc2UvcG9seWZpbGxcIixbXCIuL3Byb21pc2VcIixcIi4vdXRpbHNcIixcImV4cG9ydHNcIl0sZnVuY3Rpb24oYSxiLGMpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGQoKXt2YXIgYTthPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5kb2N1bWVudD93aW5kb3c6c2VsZjt2YXIgYj1cIlByb21pc2VcImluIGEmJlwicmVzb2x2ZVwiaW4gYS5Qcm9taXNlJiZcInJlamVjdFwiaW4gYS5Qcm9taXNlJiZcImFsbFwiaW4gYS5Qcm9taXNlJiZcInJhY2VcImluIGEuUHJvbWlzZSYmZnVuY3Rpb24oKXt2YXIgYjtyZXR1cm4gbmV3IGEuUHJvbWlzZShmdW5jdGlvbihhKXtiPWF9KSxmKGIpfSgpO2J8fChhLlByb21pc2U9ZSl9dmFyIGU9YS5Qcm9taXNlLGY9Yi5pc0Z1bmN0aW9uO2MucG9seWZpbGw9ZH0pLGEoXCJwcm9taXNlL3Byb21pc2VcIixbXCIuL2NvbmZpZ1wiLFwiLi91dGlsc1wiLFwiLi9hbGxcIixcIi4vcmFjZVwiLFwiLi9yZXNvbHZlXCIsXCIuL3JlamVjdFwiLFwiLi9hc2FwXCIsXCJleHBvcnRzXCJdLGZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShhKXtpZighdihhKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvclwiKTtpZighKHRoaXMgaW5zdGFuY2VvZiBpKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO3RoaXMuX3N1YnNjcmliZXJzPVtdLGooYSx0aGlzKX1mdW5jdGlvbiBqKGEsYil7ZnVuY3Rpb24gYyhhKXtvKGIsYSl9ZnVuY3Rpb24gZChhKXtxKGIsYSl9dHJ5e2EoYyxkKX1jYXRjaChlKXtkKGUpfX1mdW5jdGlvbiBrKGEsYixjLGQpe3ZhciBlLGYsZyxoLGk9dihjKTtpZihpKXRyeXtlPWMoZCksZz0hMH1jYXRjaChqKXtoPSEwLGY9an1lbHNlIGU9ZCxnPSEwO24oYixlKXx8KGkmJmc/byhiLGUpOmg/cShiLGYpOmE9PT1EP28oYixlKTphPT09RSYmcShiLGUpKX1mdW5jdGlvbiBsKGEsYixjLGQpe3ZhciBlPWEuX3N1YnNjcmliZXJzLGY9ZS5sZW5ndGg7ZVtmXT1iLGVbZitEXT1jLGVbZitFXT1kfWZ1bmN0aW9uIG0oYSxiKXtmb3IodmFyIGMsZCxlPWEuX3N1YnNjcmliZXJzLGY9YS5fZGV0YWlsLGc9MDtnPGUubGVuZ3RoO2crPTMpYz1lW2ddLGQ9ZVtnK2JdLGsoYixjLGQsZik7YS5fc3Vic2NyaWJlcnM9bnVsbH1mdW5jdGlvbiBuKGEsYil7dmFyIGMsZD1udWxsO3RyeXtpZihhPT09Yil0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLlwiKTtpZih1KGIpJiYoZD1iLnRoZW4sdihkKSkpcmV0dXJuIGQuY2FsbChiLGZ1bmN0aW9uKGQpe3JldHVybiBjPyEwOihjPSEwLGIhPT1kP28oYSxkKTpwKGEsZCksdm9pZCAwKX0sZnVuY3Rpb24oYil7cmV0dXJuIGM/ITA6KGM9ITAscShhLGIpLHZvaWQgMCl9KSwhMH1jYXRjaChlKXtyZXR1cm4gYz8hMDoocShhLGUpLCEwKX1yZXR1cm4hMX1mdW5jdGlvbiBvKGEsYil7YT09PWI/cChhLGIpOm4oYSxiKXx8cChhLGIpfWZ1bmN0aW9uIHAoYSxiKXthLl9zdGF0ZT09PUImJihhLl9zdGF0ZT1DLGEuX2RldGFpbD1iLHQuYXN5bmMocixhKSl9ZnVuY3Rpb24gcShhLGIpe2EuX3N0YXRlPT09QiYmKGEuX3N0YXRlPUMsYS5fZGV0YWlsPWIsdC5hc3luYyhzLGEpKX1mdW5jdGlvbiByKGEpe20oYSxhLl9zdGF0ZT1EKX1mdW5jdGlvbiBzKGEpe20oYSxhLl9zdGF0ZT1FKX12YXIgdD1hLmNvbmZpZyx1PShhLmNvbmZpZ3VyZSxiLm9iamVjdE9yRnVuY3Rpb24pLHY9Yi5pc0Z1bmN0aW9uLHc9KGIubm93LGMuYWxsKSx4PWQucmFjZSx5PWUucmVzb2x2ZSx6PWYucmVqZWN0LEE9Zy5hc2FwO3QuYXN5bmM9QTt2YXIgQj12b2lkIDAsQz0wLEQ9MSxFPTI7aS5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOmksX3N0YXRlOnZvaWQgMCxfZGV0YWlsOnZvaWQgMCxfc3Vic2NyaWJlcnM6dm9pZCAwLHRoZW46ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQ9bmV3IHRoaXMuY29uc3RydWN0b3IoZnVuY3Rpb24oKXt9KTtpZih0aGlzLl9zdGF0ZSl7dmFyIGU9YXJndW1lbnRzO3QuYXN5bmMoZnVuY3Rpb24oKXtrKGMuX3N0YXRlLGQsZVtjLl9zdGF0ZS0xXSxjLl9kZXRhaWwpfSl9ZWxzZSBsKHRoaXMsZCxhLGIpO3JldHVybiBkfSxcImNhdGNoXCI6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMudGhlbihudWxsLGEpfX0saS5hbGw9dyxpLnJhY2U9eCxpLnJlc29sdmU9eSxpLnJlamVjdD16LGguUHJvbWlzZT1pfSksYShcInByb21pc2UvcmFjZVwiLFtcIi4vdXRpbHNcIixcImV4cG9ydHNcIl0sZnVuY3Rpb24oYSxiKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBjKGEpe3ZhciBiPXRoaXM7aWYoIWQoYSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS5cIik7cmV0dXJuIG5ldyBiKGZ1bmN0aW9uKGIsYyl7Zm9yKHZhciBkLGU9MDtlPGEubGVuZ3RoO2UrKylkPWFbZV0sZCYmXCJmdW5jdGlvblwiPT10eXBlb2YgZC50aGVuP2QudGhlbihiLGMpOmIoZCl9KX12YXIgZD1hLmlzQXJyYXk7Yi5yYWNlPWN9KSxhKFwicHJvbWlzZS9yZWplY3RcIixbXCJleHBvcnRzXCJdLGZ1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYSl7dmFyIGI9dGhpcztyZXR1cm4gbmV3IGIoZnVuY3Rpb24oYixjKXtjKGEpfSl9YS5yZWplY3Q9Yn0pLGEoXCJwcm9taXNlL3Jlc29sdmVcIixbXCJleHBvcnRzXCJdLGZ1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYSl7aWYoYSYmXCJvYmplY3RcIj09dHlwZW9mIGEmJmEuY29uc3RydWN0b3I9PT10aGlzKXJldHVybiBhO3ZhciBiPXRoaXM7cmV0dXJuIG5ldyBiKGZ1bmN0aW9uKGIpe2IoYSl9KX1hLnJlc29sdmU9Yn0pLGEoXCJwcm9taXNlL3V0aWxzXCIsW1wiZXhwb3J0c1wiXSxmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGEpe3JldHVybiBjKGEpfHxcIm9iamVjdFwiPT10eXBlb2YgYSYmbnVsbCE9PWF9ZnVuY3Rpb24gYyhhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBhfWZ1bmN0aW9uIGQoYSl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpfXZhciBlPURhdGUubm93fHxmdW5jdGlvbigpe3JldHVybihuZXcgRGF0ZSkuZ2V0VGltZSgpfTthLm9iamVjdE9yRnVuY3Rpb249YixhLmlzRnVuY3Rpb249YyxhLmlzQXJyYXk9ZCxhLm5vdz1lfSksYihcInByb21pc2UvcG9seWZpbGxcIikucG9seWZpbGwoKX0oKTsiLCIvKlxyXG5Db3B5cmlnaHQgKEMpIDIwMTEgUGF0cmljayBHaWxsZXNwaWUsIGh0dHA6Ly9wYXRvcmprLmNvbS9cclxuXHJcblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuVEhFIFNPRlRXQVJFLlxyXG4qL1xyXG5cclxuLypcclxuICAgIEV4dGVuZGlibGUgQkJDb2RlIFBhcnNlciB2MS4wLjBcclxuICAgIEJ5IFBhdHJpY2sgR2lsbGVzcGllIChwYXRvcmprQGdtYWlsLmNvbSlcclxuICAgIFdlYnNpdGU6IGh0dHA6Ly9wYXRvcmprLmNvbS9cclxuXHJcbiAgICBUaGlzIG1vZHVsZSBhbGxvd3MgeW91IHRvIHBhcnNlIEJCQ29kZSBhbmQgdG8gZXh0ZW5kIHRvIHRoZSBtYXJrLXVwIGxhbmd1YWdlXHJcbiAgICB0byBhZGQgaW4geW91ciBvd24gdGFncy5cclxuKi9cclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIFhCQkNPREUgPSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFNldCB1cCBwcml2YXRlIHZhcmlhYmxlc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICB2YXIgbWUgPSB7fSxcclxuICAgICAgICB1cmxQYXR0ZXJuID0gL14oPzpodHRwcz98ZmlsZXxjKTooPzpcXC97MSwzfXxcXFxcezF9KVstYS16QS1aMC05OkAjJSYoKX5fP1xcKz1cXC9cXFxcXFwuXSokLyxcclxuICAgICAgICBjb2xvck5hbWVQYXR0ZXJuID0gL14oPzpyZWR8Z3JlZW58Ymx1ZXxvcmFuZ2V8eWVsbG93fGJsYWNrfHdoaXRlfGJyb3dufGdyYXl8c2lsdmVyfHB1cnBsZXxtYXJvb258ZnVzaHNpYXxsaW1lfG9saXZlfG5hdnl8dGVhbHxhcXVhKSQvLFxyXG4gICAgICAgIGNvbG9yQ29kZVBhdHRlcm4gPSAvXiM/W2EtZkEtRjAtOV17Nn0kLyxcclxuICAgICAgICB0YWdzLFxyXG4gICAgICAgIHRhZ0xpc3QsXHJcbiAgICAgICAgdGFnc05vUGFyc2VMaXN0ID0gW10sXHJcbiAgICAgICAgYmJSZWdFeHAsXHJcbiAgICAgICAgcGJiUmVnRXhwLFxyXG4gICAgICAgIHBiYlJlZ0V4cDIsXHJcbiAgICAgICAgb3BlblRhZ3MsXHJcbiAgICAgICAgY2xvc2VUYWdzO1xyXG4gICAgICAgIFxyXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAqIHRhZ3NcclxuICAgICAqIFRoaXMgb2JqZWN0IGNvbnRhaW5zIGEgbGlzdCBvZiB0YWdzIHRoYXQgeW91ciBjb2RlIHdpbGwgYmUgYWJsZSB0byB1bmRlcnN0YW5kLlxyXG4gICAgICogRWFjaCB0YWcgb2JqZWN0IGhhcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKlxyXG4gICAgICogICBvcGVuVGFnIC0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGluIHRoZSB0YWcncyBwYXJhbWV0ZXJzIChpZiBhbnkpIGFuZCBpdHNcclxuICAgICAqICAgICAgICAgICAgIGNvbnRlbnRzLCBhbmQgcmV0dXJucyB3aGF0IGl0cyBIVE1MIG9wZW4gdGFnIHNob3VsZCBiZS4gXHJcbiAgICAgKiAgICAgICAgICAgICBFeGFtcGxlOiBbY29sb3I9cmVkXXRlc3RbL2NvbG9yXSB3b3VsZCB0YWtlIGluIFwiPXJlZFwiIGFzIGFcclxuICAgICAqICAgICAgICAgICAgIHBhcmFtZXRlciBpbnB1dCwgYW5kIFwidGVzdFwiIGFzIGEgY29udGVudCBpbnB1dC5cclxuICAgICAqICAgICAgICAgICAgIEl0IHNob3VsZCBiZSBub3RlZCB0aGF0IGFueSBCQkNvZGUgaW5zaWRlIG9mIFwiY29udGVudFwiIHdpbGwgaGF2ZSBcclxuICAgICAqICAgICAgICAgICAgIGJlZW4gcHJvY2Vzc2VkIGJ5IHRoZSB0aW1lIGl0IGVudGVyIHRoZSBvcGVuVGFnIGZ1bmN0aW9uLlxyXG4gICAgICpcclxuICAgICAqICAgY2xvc2VUYWcgLSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgaW4gdGhlIHRhZydzIHBhcmFtZXRlcnMgKGlmIGFueSkgYW5kIGl0c1xyXG4gICAgICogICAgICAgICAgICAgIGNvbnRlbnRzLCBhbmQgcmV0dXJucyB3aGF0IGl0cyBIVE1MIGNsb3NlIHRhZyBzaG91bGQgYmUuXHJcbiAgICAgKlxyXG4gICAgICogICBkaXNwbGF5Q29udGVudCAtIERlZmF1bHRzIHRvIHRydWUuIElmIGZhbHNlLCB0aGUgY29udGVudCBmb3IgdGhlIHRhZyB3aWxsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgbm90IGJlIGRpc3BsYXllZC4gVGhpcyBpcyB1c2VmdWwgZm9yIHRhZ3MgbGlrZSBJTUcgd2hlcmVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICBpdHMgY29udGVudHMgYXJlIGFjdHVhbGx5IGEgcGFyYW1ldGVyIGlucHV0LlxyXG4gICAgICpcclxuICAgICAqICAgcmVzdHJpY3RDaGlsZHJlblRvIC0gQSBsaXN0IG9mIEJCQ29kZSB0YWdzIHdoaWNoIGFyZSBhbGxvd2VkIHRvIGJlIG5lc3RlZFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICB3aXRoaW4gdGhpcyBCQkNvZGUgdGFnLiBJZiB0aGlzIHByb3BlcnR5IGlzIG9taXR0ZWQsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGFueSBCQkNvZGUgdGFnIG1heSBiZSBuZXN0ZWQgd2l0aGluIHRoZSB0YWcuXHJcbiAgICAgKlxyXG4gICAgICogICByZXN0cmljdFBhcmVudHNUbyAtIEEgbGlzdCBvZiBCQkNvZGUgdGFncyB3aGljaCBhcmUgYWxsb3dlZCB0byBiZSBwYXJlbnRzIG9mXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBCQkNvZGUgdGFnLiBJZiB0aGlzIHByb3BlcnR5IGlzIG9taXR0ZWQsIGFueSBCQkNvZGUgXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgdGFnIG1heSBiZSBhIHBhcmVudCBvZiB0aGUgdGFnLlxyXG4gICAgICpcclxuICAgICAqICAgbm9QYXJzZSAtIHRydWUgb3IgZmFsc2UuIElmIHRydWUsIG5vbmUgb2YgdGhlIGNvbnRlbnQgV0lUSElOIHRoaXMgdGFnIHdpbGwgYmVcclxuICAgICAqICAgICAgICAgICAgIHBhcnNlZCBieSB0aGUgWEJCQ29kZSBwYXJzZXIuXHJcbiAgICAgKiAgICAgICBcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogTElNSVRJT05TIG9uIGFkZGluZyBORVcgVEFHUzpcclxuICAgICAqICAtIFRhZyBuYW1lcyBzaG91bGQgYmUgYWxwaGFudW1lcmljIChpbmNsdWRpbmcgdW5kZXJzY29yZXMpIGFuZCBhbGwgdGFncyBzaG91bGQgaGF2ZSBhbiBvcGVuaW5nIHRhZ1xyXG4gICAgICogICAgYW5kIGEgY2xvc2luZyB0YWcuIFxyXG4gICAgICogICAgVGhlIFsqXSB0YWcgaXMgYW4gZXhjZXB0aW9uIGJlY2F1c2UgaXQgd2FzIGFscmVhZHkgYSBzdGFuZGFyZFxyXG4gICAgICogICAgYmJjb2RlIHRhZy4gVGVjaG5lY2lhbGx5IHRhZ3MgZG9uJ3QgKmhhdmUqIHRvIGJlIGFscGhhbnVtZXJpYywgYnV0IHNpbmNlIFxyXG4gICAgICogICAgcmVndWxhciBleHByZXNzaW9ucyBhcmUgdXNlZCB0byBwYXJzZSB0aGUgdGV4dCwgaWYgeW91IHVzZSBhIG5vbi1hbHBoYW51bWVyaWMgXHJcbiAgICAgKiAgICB0YWcgbmFtZXMsIGp1c3QgbWFrZSBzdXJlIHRoZSB0YWcgbmFtZSBnZXRzIGVzY2FwZWQgcHJvcGVybHkgKGlmIG5lZWRlZCkuXHJcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuICAgICAgICBcclxuICAgIHRhZ3MgPSB7XHJcbiAgICAgICAgXCJiXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCJ4YmJjb2RlLWJcIj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC9zcGFuPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICAgIFRoaXMgdGFnIGRvZXMgbm90aGluZyBhbmQgaXMgaGVyZSBtb3N0bHkgdG8gYmUgdXNlZCBhcyBhIGNsYXNzaWZpY2F0aW9uIGZvclxyXG4gICAgICAgICAgICB0aGUgYmJjb2RlIGlucHV0IHdoZW4gZXZhbHVhdGluZyBwYXJlbnQtY2hpbGQgdGFnIHJlbGF0aW9uc2hpcHNcclxuICAgICAgICAqL1xyXG4gICAgICAgIFwiYmJjb2RlXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiY29kZVwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwieGJiY29kZS1jb2RlXCI+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBub1BhcnNlOiB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImNvbG9yXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgY29sb3JDb2RlID0gcGFyYW1zLnN1YnN0cigxKSB8fCBcImJsYWNrXCI7XHJcbiAgICAgICAgICAgICAgICBjb2xvck5hbWVQYXR0ZXJuLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb2xvckNvZGVQYXR0ZXJuLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoICFjb2xvck5hbWVQYXR0ZXJuLnRlc3QoIGNvbG9yQ29kZSApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIWNvbG9yQ29kZVBhdHRlcm4udGVzdCggY29sb3JDb2RlICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yQ29kZSA9IFwiYmxhY2tcIjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3JDb2RlLnN1YnN0cigwLDEpICE9PSBcIiNcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JDb2RlID0gXCIjXCIgKyBjb2xvckNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8c3BhbiBzdHlsZT1cImNvbG9yOicgKyBjb2xvckNvZGUgKyAnXCI+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImlcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cInhiYmNvZGUtaVwiPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L3NwYW4+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJpbWdcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHZhciBteVVybCA9IGNvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHVybFBhdHRlcm4ubGFzdEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICggIXVybFBhdHRlcm4udGVzdCggbXlVcmwgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBteVVybCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8aW1nIHNyYz1cIicgKyBteVVybCArICdcIiAvPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkaXNwbGF5Q29udGVudDogZmFsc2VcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwibGlzdFwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzx1bD4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC91bD4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXN0cmljdENoaWxkcmVuVG86IFtcIipcIiwgXCJsaVwiXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJub3BhcnNlXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG5vUGFyc2U6IHRydWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwicGhwXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCJ4YmJjb2RlLWNvZGVcIj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC9zcGFuPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG5vUGFyc2U6IHRydWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwicXVvdGVcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8YmxvY2txdW90ZSBjbGFzcz1cInhiYmNvZGUtYmxvY2txdW90ZVwiPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L2Jsb2NrcXVvdGU+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCJ4YmJjb2RlLXNcIj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC9zcGFuPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwic2l6ZVwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIG15U2l6ZSA9IHBhcnNlSW50KHBhcmFtcy5zdWJzdHIoMSksMTApIHx8IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAobXlTaXplIDwgNCB8fCBteVNpemUgPiA0MCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG15U2l6ZSA9IDE0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCJ4YmJjb2RlLXNpemUtJyArIG15U2l6ZSArICdcIj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC9zcGFuPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidGFibGVcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8dGFibGUgY2xhc3M9XCJ4YmJjb2RlLXRhYmxlXCI+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvdGFibGU+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVzdHJpY3RDaGlsZHJlblRvOiBbXCJ0Ym9keVwiLFwidGhlYWRcIiwgXCJ0Zm9vdFwiLCBcInRyXCJdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInRib2R5XCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHRib2R5Pic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L3Rib2R5Pic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc3RyaWN0Q2hpbGRyZW5UbzogW1widHJcIl0sXHJcbiAgICAgICAgICAgIHJlc3RyaWN0UGFyZW50c1RvOiBbXCJ0YWJsZVwiXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0Zm9vdFwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzx0Zm9vdD4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC90Zm9vdD4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXN0cmljdENoaWxkcmVuVG86IFtcInRyXCJdLFxyXG4gICAgICAgICAgICByZXN0cmljdFBhcmVudHNUbzogW1widGFibGVcIl1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidGhlYWRcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8dGhlYWQgY2xhc3M9XCJ4YmJjb2RlLXRoZWFkXCI+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvdGhlYWQ+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVzdHJpY3RDaGlsZHJlblRvOiBbXCJ0clwiXSxcclxuICAgICAgICAgICAgcmVzdHJpY3RQYXJlbnRzVG86IFtcInRhYmxlXCJdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInRkXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwieGJiY29kZS10ZFwiPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L3RkPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc3RyaWN0UGFyZW50c1RvOiBbXCJ0clwiXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0aFwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzx0ZCBjbGFzcz1cInhiYmNvZGUtdGhcIj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC90ZD4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXN0cmljdFBhcmVudHNUbzogW1widHJcIl1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidHJcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8dHIgY2xhc3M9XCJ4YmJjb2RlLXRyXCI+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvdHI+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVzdHJpY3RDaGlsZHJlblRvOiBbXCJ0ZFwiLFwidGhcIl0sXHJcbiAgICAgICAgICAgIHJlc3RyaWN0UGFyZW50c1RvOiBbXCJ0YWJsZVwiLFwidGJvZHlcIixcInRmb290XCIsXCJ0aGVhZFwiXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ1XCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCJ4YmJjb2RlLXVcIj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC9zcGFuPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidXJsXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgbXlVcmw7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBteVVybCA9IGNvbnRlbnQucmVwbGFjZSgvPC4qPz4vZyxcIlwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbXlVcmwgPSBwYXJhbXMuc3Vic3RyKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB1cmxQYXR0ZXJuLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoICF1cmxQYXR0ZXJuLnRlc3QoIG15VXJsICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbXlVcmwgPSBcIiNcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxhIGhyZWY9XCInICsgbXlVcmwgKyAnXCI+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvYT4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKlxyXG4gICAgICAgICAgICBUaGUgWypdIHRhZyBpcyBzcGVjaWFsIHNpbmNlIHRoZSB1c2VyIGRvZXMgbm90IGRlZmluZSBhIGNsb3NpbmcgWy8qXSB0YWcgd2hlbiB3cml0aW5nIHRoZWlyIGJiY29kZS5cclxuICAgICAgICAgICAgSW5zdGVhZCB0aGlzIG1vZHVsZSBwYXJzZXMgdGhlIGNvZGUgYW5kIGFkZHMgdGhlIGNsb3NpbmcgWy8qXSB0YWcgaW4gZm9yIHRoZW0uIE5vbmUgb2YgdGhlIHRhZ3MgeW91XHJcbiAgICAgICAgICAgIGFkZCB3aWxsIGFjdCBsaWtlIHRoaXMgYW5kIHRoaXMgdGFnIGlzIGFuIGV4Y2VwdGlvbiB0byB0aGUgb3RoZXJzLlxyXG4gICAgICAgICovXHJcbiAgICAgICAgXCIqXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIjxsaT5cIjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCI8L2xpPlwiO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXN0cmljdFBhcmVudHNUbzogW1wibGlzdFwiXVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIGNyZWF0ZSB0YWcgbGlzdCBhbmQgbG9va3VwIGZpZWxkc1xyXG4gICAgdGFnTGlzdCA9IFtdO1xyXG4gICAgKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwcm9wLFxyXG4gICAgICAgICAgICBpaSxcclxuICAgICAgICAgICAgbGVuO1xyXG4gICAgICAgIGZvciAocHJvcCBpbiB0YWdzKSB7XHJcbiAgICAgICAgICAgIGlmICh0YWdzLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gXCIqXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YWdMaXN0LnB1c2goXCJcXFxcXCIgKyBwcm9wKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFnTGlzdC5wdXNoKHByb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGFnc1twcm9wXS5ub1BhcnNlICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdzTm9QYXJzZUxpc3QucHVzaChwcm9wKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHRhZ3NbcHJvcF0udmFsaWRDaGlsZExvb2t1cCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdGFnc1twcm9wXS52YWxpZFBhcmVudExvb2t1cCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdGFnc1twcm9wXS5yZXN0cmljdFBhcmVudHNUbyA9IHRhZ3NbcHJvcF0ucmVzdHJpY3RQYXJlbnRzVG8gfHwgW107XHJcbiAgICAgICAgICAgICAgICB0YWdzW3Byb3BdLnJlc3RyaWN0Q2hpbGRyZW5UbyA9IHRhZ3NbcHJvcF0ucmVzdHJpY3RDaGlsZHJlblRvIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBsZW4gPSB0YWdzW3Byb3BdLnJlc3RyaWN0Q2hpbGRyZW5Uby5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGlpID0gMDsgaWkgPCBsZW47IGlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0YWdzW3Byb3BdLnZhbGlkQ2hpbGRMb29rdXBbIHRhZ3NbcHJvcF0ucmVzdHJpY3RDaGlsZHJlblRvW2lpXSBdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxlbiA9IHRhZ3NbcHJvcF0ucmVzdHJpY3RQYXJlbnRzVG8ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpaSA9IDA7IGlpIDwgbGVuOyBpaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFnc1twcm9wXS52YWxpZFBhcmVudExvb2t1cFsgdGFnc1twcm9wXS5yZXN0cmljdFBhcmVudHNUb1tpaV0gXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KSgpO1xyXG4gICAgXHJcbiAgICBiYlJlZ0V4cCA9IG5ldyBSZWdFeHAoXCI8YmJjbD0oWzAtOV0rKSAoXCIgKyB0YWdMaXN0LmpvaW4oXCJ8XCIpICsgXCIpKFsgPV1bXj5dKj8pPz4oKD86LnxbXFxcXHJcXFxcbl0pKj8pPGJiY2w9XFxcXDEgL1xcXFwyPlwiLCBcImdpXCIpOyBcclxuICAgIHBiYlJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJcXFxcWyhcIiArIHRhZ0xpc3Quam9pbihcInxcIikgKyBcIikoWyA9XVteXFxcXF1dKj8pP1xcXFxdKFteXFxcXFtdKj8pXFxcXFsvXFxcXDFcXFxcXVwiLCBcImdpXCIpOyBcclxuICAgIHBiYlJlZ0V4cDIgPSBuZXcgUmVnRXhwKFwiXFxcXFsoXCIgKyB0YWdzTm9QYXJzZUxpc3Quam9pbihcInxcIikgKyBcIikoWyA9XVteXFxcXF1dKj8pP1xcXFxdKFtcXFxcc1xcXFxTXSo/KVxcXFxbL1xcXFwxXFxcXF1cIiwgXCJnaVwiKTsgICAgXHJcblxyXG4gICAgLy8gY3JlYXRlIHRoZSByZWdleCBmb3IgZXNjYXBpbmcgWydzIHRoYXQgYXJlbid0IGFwYXJ0IG9mIHRhZ3NcclxuICAgIChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgY2xvc2VUYWdMaXN0ID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHRhZ0xpc3QubGVuZ3RoOyBpaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICggdGFnTGlzdFtpaV0gIT09IFwiXFxcXCpcIiApIHsgLy8gdGhlICogdGFnIGRvZXNuJ3QgaGF2ZSBhbiBvZmZpY2FsIGNsb3NpbmcgdGFnXHJcbiAgICAgICAgICAgICAgICBjbG9zZVRhZ0xpc3QucHVzaCAoIFwiL1wiICsgdGFnTGlzdFtpaV0gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3BlblRhZ3MgPSBuZXcgUmVnRXhwKFwiKFxcXFxbKSgoPzpcIiArIHRhZ0xpc3Quam9pbihcInxcIikgKyBcIikoPzpbID1dW15cXFxcXV0qPyk/KShcXFxcXSlcIiwgXCJnaVwiKTsgXHJcbiAgICAgICAgY2xvc2VUYWdzID0gbmV3IFJlZ0V4cChcIihcXFxcWykoXCIgKyBjbG9zZVRhZ0xpc3Quam9pbihcInxcIikgKyBcIikoXFxcXF0pXCIsIFwiZ2lcIik7IFxyXG4gICAgfSkoKTtcclxuICAgIFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIHByaXZhdGUgZnVuY3Rpb25zXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBjaGVja1BhcmVudENoaWxkUmVzdHJpY3Rpb25zKHBhcmVudFRhZywgYmJjb2RlLCBiYmNvZGVMZXZlbCwgdGFnTmFtZSwgdGFnUGFyYW1zLCB0YWdDb250ZW50cywgZXJyUXVldWUpIHtcclxuICAgICAgICBcclxuICAgICAgICBlcnJRdWV1ZSA9IGVyclF1ZXVlIHx8IFtdO1xyXG4gICAgICAgIGJiY29kZUxldmVsKys7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gZ2V0IGEgbGlzdCBvZiBhbGwgb2YgdGhlIGNoaWxkIHRhZ3MgdG8gdGhpcyB0YWdcclxuICAgICAgICB2YXIgcmVUYWdOYW1lcyA9IG5ldyBSZWdFeHAoXCIoPGJiY2w9XCIgKyBiYmNvZGVMZXZlbCArIFwiICkoXCIgKyB0YWdMaXN0LmpvaW4oXCJ8XCIpICsgXCIpKFsgPT5dKVwiLFwiZ2lcIiksXHJcbiAgICAgICAgICAgIHJlVGFnTmFtZXNQYXJ0cyA9IG5ldyBSZWdFeHAoXCIoPGJiY2w9XCIgKyBiYmNvZGVMZXZlbCArIFwiICkoXCIgKyB0YWdMaXN0LmpvaW4oXCJ8XCIpICsgXCIpKFsgPT5dKVwiLFwiaVwiKSxcclxuICAgICAgICAgICAgbWF0Y2hpbmdUYWdzID0gdGFnQ29udGVudHMubWF0Y2gocmVUYWdOYW1lcykgfHwgW10sXHJcbiAgICAgICAgICAgIGNJbmZvLFxyXG4gICAgICAgICAgICBlcnJTdHIsXHJcbiAgICAgICAgICAgIGlpLFxyXG4gICAgICAgICAgICBjaGlsZFRhZyxcclxuICAgICAgICAgICAgcEluZm8gPSB0YWdzW3BhcmVudFRhZ10gfHwge307XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmVUYWdOYW1lcy5sYXN0SW5kZXggPSAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICghbWF0Y2hpbmdUYWdzKSB7XHJcbiAgICAgICAgICAgIHRhZ0NvbnRlbnRzID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChpaSA9IDA7IGlpIDwgbWF0Y2hpbmdUYWdzLmxlbmd0aDsgaWkrKykge1xyXG4gICAgICAgICAgICByZVRhZ05hbWVzUGFydHMubGFzdEluZGV4ID0gMDtcclxuICAgICAgICAgICAgY2hpbGRUYWcgPSAobWF0Y2hpbmdUYWdzW2lpXS5tYXRjaChyZVRhZ05hbWVzUGFydHMpKVsyXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCBwSW5mby5yZXN0cmljdENoaWxkcmVuVG8ubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgICAgIGlmICggIXBJbmZvLnZhbGlkQ2hpbGRMb29rdXBbY2hpbGRUYWddICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVyclN0ciA9IFwiVGhlIHRhZyBcXFwiXCIgKyBjaGlsZFRhZyArIFwiXFxcIiBpcyBub3QgYWxsb3dlZCBhcyBhIGNoaWxkIG9mIHRoZSB0YWcgXFxcIlwiICsgcGFyZW50VGFnICsgXCJcXFwiLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGVyclF1ZXVlLnB1c2goZXJyU3RyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjSW5mbyA9IHRhZ3NbY2hpbGRUYWddIHx8IHt9O1xyXG4gICAgICAgICAgICBpZiAoIGNJbmZvLnJlc3RyaWN0UGFyZW50c1RvLmxlbmd0aCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoICFjSW5mby52YWxpZFBhcmVudExvb2t1cFtwYXJlbnRUYWddICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVyclN0ciA9IFwiVGhlIHRhZyBcXFwiXCIgKyBwYXJlbnRUYWcgKyBcIlxcXCIgaXMgbm90IGFsbG93ZWQgYXMgYSBwYXJlbnQgb2YgdGhlIHRhZyBcXFwiXCIgKyBjaGlsZFRhZyArIFwiXFxcIi5cIjtcclxuICAgICAgICAgICAgICAgICAgICBlcnJRdWV1ZS5wdXNoKGVyclN0cik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRhZ0NvbnRlbnRzID0gdGFnQ29udGVudHMucmVwbGFjZShiYlJlZ0V4cCwgZnVuY3Rpb24obWF0Y2hTdHIsIGJiY29kZUxldmVsLCB0YWdOYW1lLCB0YWdQYXJhbXMsIHRhZ0NvbnRlbnRzICkge1xyXG4gICAgICAgICAgICBlcnJRdWV1ZSA9IGNoZWNrUGFyZW50Q2hpbGRSZXN0cmljdGlvbnModGFnTmFtZSwgbWF0Y2hTdHIsIGJiY29kZUxldmVsLCB0YWdOYW1lLCB0YWdQYXJhbXMsIHRhZ0NvbnRlbnRzLCBlcnJRdWV1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaFN0cjtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZXJyUXVldWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qXHJcbiAgICAgICAgVGhpcyBmdW5jdGlvbiB1cGRhdGVzIG9yIGFkZHMgYSBwaWVjZSBvZiBtZXRhZGF0YSB0byBlYWNoIHRhZyBjYWxsZWQgXCJiYmNsXCIgd2hpY2ggXHJcbiAgICAgICAgaW5kaWNhdGVzIGhvdyBkZWVwbHkgbmVzdGVkIGEgcGFydGljdWxhciB0YWcgd2FzIGluIHRoZSBiYmNvZGUuIFRoaXMgcHJvcGVydHkgaXMgcmVtb3ZlZFxyXG4gICAgICAgIGZyb20gdGhlIEhUTUwgY29kZSB0YWdzIGF0IHRoZSBlbmQgb2YgdGhlIHByb2Nlc3NpbmcuXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gdXBkYXRlVGFnRGVwdGhzKHRhZ0NvbnRlbnRzKSB7XHJcbiAgICAgICAgdGFnQ29udGVudHMgPSB0YWdDb250ZW50cy5yZXBsYWNlKC9cXDwoW15cXD5dW15cXD5dKj8pXFw+L2dpLCBmdW5jdGlvbihtYXRjaFN0ciwgc3ViTWF0Y2hTdHIpIHtcclxuICAgICAgICAgICAgdmFyIGJiQ29kZUxldmVsID0gc3ViTWF0Y2hTdHIubWF0Y2goL15iYmNsPShbMC05XSspIC8pO1xyXG4gICAgICAgICAgICBpZiAoYmJDb2RlTGV2ZWwgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIjxiYmNsPTAgXCIgKyBzdWJNYXRjaFN0ciArIFwiPlwiO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiPFwiICsgc3ViTWF0Y2hTdHIucmVwbGFjZSgvXihiYmNsPSkoWzAtOV0rKS8sIGZ1bmN0aW9uKG1hdGNoU3RyLCBtMSwgbTIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbTEgKyAocGFyc2VJbnQobTIsIDEwKSArIDEpO1xyXG4gICAgICAgICAgICAgICAgfSkgKyBcIj5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0YWdDb250ZW50cztcclxuICAgIH1cclxuICAgIFxyXG4gICAgLypcclxuICAgICAgICBUaGlzIGZ1bmN0aW9uIHJlbW92ZXMgdGhlIG1ldGFkYXRhIGFkZGVkIGJ5IHRoZSB1cGRhdGVUYWdEZXB0aHMgZnVuY3Rpb25cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiB1bnByb2Nlc3ModGFnQ29udGVudCkge1xyXG4gICAgICAgIHJldHVybiB0YWdDb250ZW50LnJlcGxhY2UoLzxiYmNsPVswLTldKyBcXC9cXCo+L2dpLFwiXCIpLnJlcGxhY2UoLzxiYmNsPVswLTldKyAvZ2ksXCImIzkxO1wiKS5yZXBsYWNlKC8+L2dpLFwiJiM5MztcIik7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciByZXBsYWNlRnVuY3QgPSBmdW5jdGlvbihtYXRjaFN0ciwgYmJjb2RlTGV2ZWwsIHRhZ05hbWUsIHRhZ1BhcmFtcywgdGFnQ29udGVudHMpIHtcclxuICAgIFxyXG4gICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIHZhciBwcm9jZXNzZWRDb250ZW50ID0gdGFnc1t0YWdOYW1lXS5ub1BhcnNlID8gdW5wcm9jZXNzKHRhZ0NvbnRlbnRzKSA6IHRhZ0NvbnRlbnRzLnJlcGxhY2UoYmJSZWdFeHAsIHJlcGxhY2VGdW5jdCksXHJcbiAgICAgICAgICAgIG9wZW5UYWcgPSB0YWdzW3RhZ05hbWVdLm9wZW5UYWcodGFnUGFyYW1zLHByb2Nlc3NlZENvbnRlbnQpLFxyXG4gICAgICAgICAgICBjbG9zZVRhZyA9IHRhZ3NbdGFnTmFtZV0uY2xvc2VUYWcodGFnUGFyYW1zLHByb2Nlc3NlZENvbnRlbnQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICBpZiAoIHRhZ3NbdGFnTmFtZV0uZGlzcGxheUNvbnRlbnQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZENvbnRlbnQgPSBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gb3BlblRhZyArIHByb2Nlc3NlZENvbnRlbnQgKyBjbG9zZVRhZztcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2UoY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIG91dHB1dCA9IGNvbmZpZy50ZXh0O1xyXG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKGJiUmVnRXhwLCByZXBsYWNlRnVuY3QpO1xyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qXHJcbiAgICAgICAgVGhlIHN0YXIgdGFnIFsqXSBpcyBzcGVjaWFsIGluIHRoYXQgaXQgZG9lcyBub3QgdXNlIGEgY2xvc2luZyB0YWcuIFNpbmNlIHRoaXMgcGFyc2VyIHJlcXVpcmVzIHRoYXQgdGFncyB0byBoYXZlIGEgY2xvc2luZ1xyXG4gICAgICAgIHRhZywgd2UgbXVzdCBwcmUtcHJvY2VzcyB0aGUgaW5wdXQgYW5kIGFkZCBpbiBjbG9zaW5nIHRhZ3MgWy8qXSBmb3IgdGhlIHN0YXIgdGFnLlxyXG4gICAgICAgIFdlIGhhdmUgYSBsaXR0bGUgbGV2YXJpZGdlIGluIHRoYXQgd2Uga25vdyB0aGUgdGV4dCB3ZSdyZSBwcm9jZXNzaW5nIHdvbnQgY29udGFpbiB0aGUgPD4gY2hhcmFjdGVycyAodGhleSBoYXZlIGJlZW5cclxuICAgICAgICBjaGFuZ2VkIGludG8gdGhlaXIgSFRNTCBlbnRpdHkgZm9ybSB0byBwcmV2ZW50IFhTUyBhbmQgY29kZSBpbmplY3Rpb24pLCBzbyB3ZSBjYW4gdXNlIHRob3NlIGNoYXJhY3RlcnMgYXMgbWFya2VycyB0b1xyXG4gICAgICAgIGhlbHAgdXMgZGVmaW5lIGJvdW5kYXJpZXMgYW5kIGZpZ3VyZSBvdXQgd2hlcmUgdG8gcGxhY2UgdGhlIFsvKl0gdGFncy5cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBmaXhTdGFyVGFnKHRleHQpIHtcclxuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXFsoPyFcXCpbID1cXF1dfGxpc3QoWyA9XVteXFxdXSopP1xcXXxcXC9saXN0W1xcXV0pL2lnLCBcIjxcIik7XHJcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxbKD89bGlzdChbID1dW15cXF1dKik/XFxdfFxcL2xpc3RbXFxdXSkvaWcsIFwiPlwiKTtcclxuXHJcbiAgICAgICAgd2hpbGUgKHRleHQgIT09ICh0ZXh0ID0gdGV4dC5yZXBsYWNlKC8+bGlzdChbID1dW15cXF1dKik/XFxdKFtePl0qPykoPlxcL2xpc3RdKS9naSwgZnVuY3Rpb24obWF0Y2hTdHIsY29udGVudHMsZW5kVGFnKSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgaW5uZXJMaXN0VHh0ID0gbWF0Y2hTdHI7XHJcbiAgICAgICAgICAgIHdoaWxlIChpbm5lckxpc3RUeHQgIT09IChpbm5lckxpc3RUeHQgPSBpbm5lckxpc3RUeHQucmVwbGFjZSgvXFxbXFwqXFxdKFteXFxbXSo/KShcXFtcXCpcXF18PlxcL2xpc3RdKS9pLCBmdW5jdGlvbihtYXRjaFN0cixjb250ZW50cyxlbmRUYWcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbmRUYWcgPT09IFwiPi9saXN0XVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kVGFnID0gXCI8LypdPC9saXN0XVwiO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRUYWcgPSBcIjwvKl1bKl1cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBcIjwqXVwiICsgY29udGVudHMgKyBlbmRUYWc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xyXG4gICAgICAgICAgICB9KSkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaW5uZXJMaXN0VHh0ID0gaW5uZXJMaXN0VHh0LnJlcGxhY2UoLz4vZywgXCI8XCIpOyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gaW5uZXJMaXN0VHh0O1xyXG4gICAgICAgIH0pKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gYWRkIFsncyBmb3Igb3VyIHRhZ3MgYmFjayBpblxyXG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLzwvZywgXCJbXCIpO1xyXG4gICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gYWRkQmJjb2RlTGV2ZWxzKHRleHQpIHtcclxuICAgICAgICB3aGlsZSAoIHRleHQgIT09ICh0ZXh0ID0gdGV4dC5yZXBsYWNlKHBiYlJlZ0V4cCwgZnVuY3Rpb24obWF0Y2hTdHIsIHRhZ05hbWUsIHRhZ1BhcmFtcywgdGFnQ29udGVudHMpIHtcclxuICAgICAgICAgICAgbWF0Y2hTdHIgPSBtYXRjaFN0ci5yZXBsYWNlKC9cXFsvZywgXCI8XCIpO1xyXG4gICAgICAgICAgICBtYXRjaFN0ciA9IG1hdGNoU3RyLnJlcGxhY2UoL1xcXS9nLCBcIj5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVUYWdEZXB0aHMobWF0Y2hTdHIpO1xyXG4gICAgICAgIH0pKSApO1xyXG4gICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gcHVibGljIGZ1bmN0aW9uc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIFxyXG4gICAgbWUucHJvY2VzcyA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgXHJcbiAgICAgICAgdmFyIHJldCA9IHtodG1sOiBcIlwiLCBlcnJvcjogZmFsc2V9LFxyXG4gICAgICAgICAgICBlcnJRdWV1ZSA9IFtdO1xyXG5cclxuICAgICAgICBjb25maWcudGV4dCA9IGNvbmZpZy50ZXh0LnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpOyAvLyBlc2NhcGUgSFRNTCB0YWcgYnJhY2tldHNcclxuICAgICAgICBjb25maWcudGV4dCA9IGNvbmZpZy50ZXh0LnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpOyAvLyBlc2NhcGUgSFRNTCB0YWcgYnJhY2tldHNcclxuICAgICAgICBcclxuICAgICAgICBjb25maWcudGV4dCA9IGNvbmZpZy50ZXh0LnJlcGxhY2Uob3BlblRhZ3MsIGZ1bmN0aW9uKG1hdGNoU3RyLCBvcGVuQiwgY29udGVudHMsIGNsb3NlQikge1xyXG4gICAgICAgICAgICByZXR1cm4gXCI8XCIgKyBjb250ZW50cyArIFwiPlwiO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbmZpZy50ZXh0ID0gY29uZmlnLnRleHQucmVwbGFjZShjbG9zZVRhZ3MsIGZ1bmN0aW9uKG1hdGNoU3RyLCBvcGVuQiwgY29udGVudHMsIGNsb3NlQikge1xyXG4gICAgICAgICAgICByZXR1cm4gXCI8XCIgKyBjb250ZW50cyArIFwiPlwiO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbmZpZy50ZXh0ID0gY29uZmlnLnRleHQucmVwbGFjZSgvXFxbL2csIFwiJiM5MTtcIik7IC8vIGVzY2FwZSBbJ3MgdGhhdCBhcmVuJ3QgYXBhcnQgb2YgdGFnc1xyXG4gICAgICAgIGNvbmZpZy50ZXh0ID0gY29uZmlnLnRleHQucmVwbGFjZSgvXFxdL2csIFwiJiM5MztcIik7IC8vIGVzY2FwZSBbJ3MgdGhhdCBhcmVuJ3QgYXBhcnQgb2YgdGFnc1xyXG4gICAgICAgIGNvbmZpZy50ZXh0ID0gY29uZmlnLnRleHQucmVwbGFjZSgvPC9nLCBcIltcIik7IC8vIGVzY2FwZSBbJ3MgdGhhdCBhcmVuJ3QgYXBhcnQgb2YgdGFnc1xyXG4gICAgICAgIGNvbmZpZy50ZXh0ID0gY29uZmlnLnRleHQucmVwbGFjZSgvPi9nLCBcIl1cIik7IC8vIGVzY2FwZSBbJ3MgdGhhdCBhcmVuJ3QgYXBhcnQgb2YgdGFnc1xyXG5cclxuICAgICAgICAvLyBwcm9jZXNzIHRhZ3MgdGhhdCBkb24ndCBoYXZlIHRoZWlyIGNvbnRlbnQgcGFyc2VkXHJcbiAgICAgICAgd2hpbGUgKCBjb25maWcudGV4dCAhPT0gKGNvbmZpZy50ZXh0ID0gY29uZmlnLnRleHQucmVwbGFjZShwYmJSZWdFeHAyLCBmdW5jdGlvbihtYXRjaFN0ciwgdGFnTmFtZSwgdGFnUGFyYW1zLCB0YWdDb250ZW50cykge1xyXG4gICAgICAgICAgICB0YWdDb250ZW50cyA9IHRhZ0NvbnRlbnRzLnJlcGxhY2UoL1xcWy9nLCBcIiYjOTE7XCIpO1xyXG4gICAgICAgICAgICB0YWdDb250ZW50cyA9IHRhZ0NvbnRlbnRzLnJlcGxhY2UoL1xcXS9nLCBcIiYjOTM7XCIpO1xyXG4gICAgICAgICAgICB0YWdQYXJhbXMgPSB0YWdQYXJhbXMgfHwgXCJcIjtcclxuICAgICAgICAgICAgdGFnQ29udGVudHMgPSB0YWdDb250ZW50cyB8fCBcIlwiO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJbXCIgKyB0YWdOYW1lICsgdGFnUGFyYW1zICsgXCJdXCIgKyB0YWdDb250ZW50cyArIFwiWy9cIiArIHRhZ05hbWUgKyBcIl1cIjtcclxuICAgICAgICB9KSkgKTtcclxuXHJcbiAgICAgICAgY29uZmlnLnRleHQgPSBmaXhTdGFyVGFnKGNvbmZpZy50ZXh0KTsgLy8gYWRkIGluIGNsb3NpbmcgdGFncyBmb3IgdGhlIFsqXSB0YWdcclxuICAgICAgICBjb25maWcudGV4dCA9IGFkZEJiY29kZUxldmVscyhjb25maWcudGV4dCk7IC8vIGFkZCBpbiBsZXZlbCBtZXRhZGF0YVxyXG5cclxuICAgICAgICBlcnJRdWV1ZSA9IGNoZWNrUGFyZW50Q2hpbGRSZXN0cmljdGlvbnMoXCJiYmNvZGVcIiwgY29uZmlnLnRleHQsIC0xLCBcIlwiLCBcIlwiLCBjb25maWcudGV4dCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0Lmh0bWwgPSBwYXJzZShjb25maWcpO1xyXG5cclxuICAgICAgICBpZiAoIHJldC5odG1sLmluZGV4T2YoXCJbXCIpICE9PSAtMSB8fCByZXQuaHRtbC5pbmRleE9mKFwiXVwiKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgZXJyUXVldWUucHVzaChcIlNvbWUgdGFncyBhcHBlYXIgdG8gYmUgbWlzYWxpZ25lZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgaWYgKGNvbmZpZy5yZW1vdmVNaXNhbGlnbmVkVGFncykge1xyXG4gICAgICAgICAgICByZXQuaHRtbCA9IHJldC5odG1sLnJlcGxhY2UoL1xcWy4qP1xcXS9nLFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uZmlnLmFkZEluTGluZUJyZWFrcykge1xyXG4gICAgICAgICAgICByZXQuaHRtbCA9IHJldC5odG1sLnJlcGxhY2UoL1xcclxcbi9nLCBcIlxcblwiKTtcclxuICAgICAgICAgICAgcmV0Lmh0bWwgPSByZXQuaHRtbC5yZXBsYWNlKC8oXFxyfFxcbikvZywgXCIkMTxici8+XCIpO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIHJldC5odG1sID0gcmV0Lmh0bWwucmVwbGFjZShcIiYjOTE7XCIsIFwiW1wiKTsgLy8gcHV0IFsncyBiYWNrIGluXHJcbiAgICAgICAgcmV0Lmh0bWwgPSByZXQuaHRtbC5yZXBsYWNlKFwiJiM5MztcIiwgXCJdXCIpOyAvLyBwdXQgWydzIGJhY2sgaW5cclxuICAgICAgICBcclxuICAgICAgICByZXQuZXJyb3IgPSAoZXJyUXVldWUubGVuZ3RoID09PSAwKSA/IGZhbHNlIDogdHJ1ZTtcclxuICAgICAgICByZXQuZXJyb3JRdWV1ZSA9IGVyclF1ZXVlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBtZTtcclxufSkoKTsiLCIvKlxuICAgIGJvcm9uOiBzb21lIHV0aWxpdGllcyBmb3IgaW1tdXRhYmlsaXR5XG4qL1xuXG5cbkJvcm9uID0ge31cblxuQm9yb24ucGVyc2lzdGVudF9tZXJnZSA9IGZ1bmN0aW9uKHByb3BzLCBkYXRhKSB7XG4gICAgLy8vIG1lcmdlcyBhICdmbGF0dGVuZWQnIGRhdGEgYXJyYXkgaW50byBwcm9wcyBpbiBhIHBlcnNpc3RlbnQgZmFzaGlvblxuICAgIC8vLyB0aGUgbmV3IG9iamVjdCByZXVzZXMgb2xkIGRhdGEgd2hlcmUgcG9zc2libGUsIHNvIHJlcXVpcmVzIH5sb2cgTiBhZGRpdGlvbmFsIHNwYWNlXG4gICAgXG4gICAgLy8vIGdpdmVuIHByb3BzIHtmdW46IHt5YXk6MTIzLCBvazoxMjN9LCBjYXQ6e2RvZzoxMjN9fSAgICBcbiAgICAvLy8gICBhbmQgIGRhdGEgeydmdW4ueWF5JzowLCAnY2F0LmFudC5iZWFyJzowfX0gICAgICAgICAgXG4gICAgLy8vICAgICByZXR1cm5zIHtmdW46IHt5YXk6MCwgb2s6MTIzfSwgY2F0OnthbnQ6e2JlYXI6MH19fVxuICAgIFxuICAgIGRhdGEgPSBkYXRhIHx8IFtdXG4gICAgXG4gICAgaWYoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIC8vIFRISU5LOiB3aGF0IGRvIHdlIGRvIHdpdGggYXJyYXlzP1xuICAgICAgICBpZihBcnJheS5pc0FycmF5KGRhdGEpICE9PSBBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgICAgICAgICAgLy8gVEhJTks6IGhvdyB0byBkZWFsIHdpdGggYXJyYXkgLyBvYmplY3QgbWlzbWF0Y2g/XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gVEhJTks6IHdoYXQgYWJvdXQgd2hlbiBkYXRhIGlzIHtjYXQ6eydhbnQuYmVhcic6MH19ID9cbiAgICBcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YSkucmVkdWNlKGZ1bmN0aW9uKHByb3BzLCBrZXkpIHsgICAgICAgICAgICAgIC8vIE9QVDogY29tYmluZSB0aGVzZSBpbnN0ZWFkIG9mIGRvaW5nIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICByZXR1cm4gQm9yb24uc2V0X2RlZXBfdmFsdWUocHJvcHMsIGtleSwgZGF0YVtrZXldKVxuICAgIH0sIHByb3BzKVxufVxuXG5Cb3Jvbi5zZXRfZGVlcF92YWx1ZSA9IGZ1bmN0aW9uKHByb3BzLCBwYXRoLCB2YWx1ZSkge1xuICAgIC8vLyBzZXQgYSB2YWx1ZSBmcm9tIGEgZmxhdHRlbmVkIHBhdGhcbiAgICBcbiAgICAvLy8gZ2l2ZW4gcHJvcHMge2Z1bjoge3lheToxMjMsIG9rOjEyM30sIGNhdDp7ZG9nOjEyM319XG4gICAgLy8vICAgYW5kICBwYXRoICdmdW4ub2snIFxuICAgIC8vLyAgIGFuZCB2YWx1ZSA0NTZcbiAgICAvLy8gICAgIHJldHVybnMge2Z1bjoge3lheToxMjMsIG9rOjQ1Nn0sIGNhdDp7ZG9nOjEyM319XG4gICAgXG4gICAgLy8gdmFyIHNlZ3MgPSBwYXRoLnNwbGl0KCcuJylcbiAgICAvLyBUSElOSzogdGhpcyBpcyB2YWd1ZWx5IGF3ZnVsLCBidXQgd2l0aG91dCBsb29rYmVoaW5kIGl0J3MgaGFyZCB0byBzYXkgXCJvbmx5IHNwbGl0IG9uIGRvdHMgdGhhdCBhcmVuJ3Qgc2xhc2hlZFwiXG4gICAgLy8gdmFyIHNlZ3MgPSBwYXRoLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJylcbiAgICAvLyAgICAgICAgICAgICAgICAuc3BsaXQoL1xcLig/IVxcXFwpLykucmV2ZXJzZSgpXG4gICAgLy8gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihjaHVuaykge3JldHVybiBjaHVuay5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpfSlcbiAgICAvLyAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGNodW5rKSB7cmV0dXJuIGNodW5rLnJlcGxhY2UoL1tcXFxcXSQvLCAnJyl9KVxuICAgIFxuICAgIC8vIFRISU5LOiB0aGlzIGlzIHZhZ3VlbHkgYXdmdWxsZXIsIGJ1dCB3b3JrcyBhbmQgaXMgZmFpcmx5IGZhc3QgYW5kIHJlYWRhYmxlLiBcbiAgICB2YXIgbWFnaWMgPSBcIl9fX01BR0lDX19fXCJcbiAgICB2YXIgbWFnaWNfcmVnZXggPSBuZXcgUmVnRXhwKG1hZ2ljLCAnZycpO1xuICAgIHZhciBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFxcXFwuL2csIG1hZ2ljKVxuICAgIHZhciBzZWdzID0gcGF0aC5zcGxpdCgnLicpLm1hcChmdW5jdGlvbihjaHVuaykge3JldHVybiBjaHVuay5yZXBsYWNlKG1hZ2ljX3JlZ2V4LCAnLicpfSlcbiAgICBcbiAgICB2YXIgbGFzdCA9IHNlZ3MucG9wKClcbiAgICB2YXIgZmluYWwgPSBuZXh0ID0gQm9yb24uc2hhbGxvd19jb3B5KHByb3BzKVxuXG4gICAgc2Vncy5mb3JFYWNoKGZ1bmN0aW9uKHNlZykge1xuICAgICAgICBuZXh0W3NlZ10gPSBCb3Jvbi5zaGFsbG93X2NvcHkobmV4dFtzZWddKVxuICAgICAgICBuZXh0ID0gbmV4dFtzZWddXG4gICAgfSlcblxuICAgIG5leHRbbGFzdF0gPSB2YWx1ZVxuICAgIHJldHVybiBmaW5hbFxufVxuXG5Cb3Jvbi5zaGFsbG93X2NvcHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZihBcnJheS5pc0FycmF5KG9iaikpIHJldHVybiBvYmouc2xpY2UoKVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmogfHwge30pLnJlZHVjZShmdW5jdGlvbihhY2MsIGtleSkge2FjY1trZXldID0gb2JqW2tleV07IHJldHVybiBhY2N9LCB7fSlcbn1cblxuQm9yb24uc2hhbGxvd19kaWZmID0gZnVuY3Rpb24ob2xkT2JqLCBuZXdPYmopIHsgLy8gcmVzdWx0cyBjb21lIGZyb20gbmV3T2JqXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9sZE9iaikucmVkdWNlKGZ1bmN0aW9uKGFjYywga2V5KSB7XG4gICAgICAgIGlmKEpTT04uc3RyaW5naWZ5KG9sZE9ialtrZXldKSAhPSBKU09OLnN0cmluZ2lmeShuZXdPYmpba2V5XSkpXG4gICAgICAgICAgICBhY2Nba2V5XSA9IG5ld09ialtrZXldIC8vIHRoaXMgcG9pbnRlciBjb3BpZXMgZGVlcCBkYXRhXG4gICAgICAgIHJldHVybiBhY2NcbiAgICB9LCBvbGRPYmouY29uc3RydWN0b3IoKSlcbn1cblxuQm9yb24uZGVlcF9kaWZmID0gZnVuY3Rpb24ob2xkT2JqLCBuZXdPYmopIHsgLy8gcmVzdWx0cyBjb21lIGZyb20gbmV3T2JqXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG5ld09iaikucmVkdWNlKGZ1bmN0aW9uKGFjYywga2V5KSB7XG4gICAgICAgIHZhciBvbGR0eXBlID0gdHlwZW9mIG9sZE9ialtrZXldXG4gICAgICAgIHZhciBuZXd0eXBlID0gdHlwZW9mIG5ld09ialtrZXldXG4gICAgICAgIFxuICAgICAgICBpZihvbGR0eXBlICE9IG5ld3R5cGUpIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gbmV3T2JqW2tleV0gLy8gdGhpcyBwb2ludGVyIGNvcGllcyBkZWVwIGRhdGFcbiAgICAgICAgICAgIHJldHVybiBhY2NcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYob2xkdHlwZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBCb3Jvbi5kZWVwX2RpZmYob2xkT2JqW2tleV0sIG5ld09ialtrZXldKVxuICAgICAgICAgICAgaWYoT2JqZWN0LmtleXMoZGlmZikubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGFjY1trZXldID0gZGlmZlxuICAgICAgICAgICAgcmV0dXJuIGFjY1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihvbGRPYmpba2V5XSAhPT0gbmV3T2JqW2tleV0pXG4gICAgICAgICAgICBhY2Nba2V5XSA9IG5ld09ialtrZXldXG4gICAgICAgIHJldHVybiBhY2NcbiAgICB9LCBuZXdPYmouY29uc3RydWN0b3IoKSlcbn1cblxuQm9yb24uZmxhdHRlbiA9IGZ1bmN0aW9uKG9iaiwgcHJlZml4KSB7XG4gICAgLy8vIGNvbnZlcnQge2Z1bjoge3lheTogMTIzfX0gaW50byB7J2Z1bi55YXknOiAxMjN9XG4gICAgXG4gICAgaWYoIUJvcm9uLnByb3Blcl9vYmplY3Qob2JqKSkgcmV0dXJuIHt9XG4gICAgXG4gICAgdmFyIG5ld29iaiA9IHt9XG4gICAgcHJlZml4ID0gcHJlZml4ID8gcHJlZml4ICsgJy4nIDogJydcbiAgICBcbiAgICBmb3IodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYoIUJvcm9uLnByb3Blcl9vYmplY3Qob2JqW2tleV0pKSB7XG4gICAgICAgICAgICBuZXdvYmpbcHJlZml4K2tleV0gPSBvYmpba2V5XVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3b2JqID0gQm9yb24uZXh0ZW5kKG5ld29iaiwgQm9yb24uZmxhdHRlbihvYmpba2V5XSwgcHJlZml4K2tleSkpIC8vIE9QVDogbG90c2EgR0MgaGVyZVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBuZXdvYmpcbn1cblxuQm9yb24udW5mbGF0dGVuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgLy8vIGNvbnZlcnQgeydmdW4ueWF5JzogMTIzfSBpbnRvIHtmdW46IHt5YXk6IDEyM319XG4gICAgXG4gICAgcmV0dXJuIEJvcm9uLnBlcnNpc3RlbnRfbWVyZ2Uoe30sIG9iaikgLy8gT1BUOiBHQ1xuICAgIC8vIHJldHVybiBPYmplY3Qua2V5cyhvYmp8fHt9KS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBrZXkpIHtyZXR1cm4gQm9yb24uc2V0X2RlZXBfdmFsdWUoYWNjLCBrZXksIG9ialtrZXldKX0sIHt9KSAvLyBPUFQ6IEdDXG59XG5cbkJvcm9uLnByb3Blcl9vYmplY3QgPSBmdW5jdGlvbihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmogPT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob2JqKSB9IFxuXG5Cb3Jvbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICAvLy8gZ2l2ZW4gKHtmdW46MTIzLCB5YXk6MTIzfSwge3lheTo0NTYsIG9rOjc4OX0pIGFzIGFyZ3MsIHJldHVybnMgYSBuZXcgb2JqZWN0IHtmdW46MTIzLCB5YXk6NDU2LCBvazo3ODl9XG4gICAgXG4gICAgdmFyIG5ld29iaiA9IHt9XG4gICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGFyZykge1xuICAgICAgICBmb3IodmFyIHByb3AgaW4gYXJnKSB7XG4gICAgICAgICAgICBuZXdvYmpbcHJvcF0gPSBhcmdbcHJvcF0gfSB9KVxuICAgIHJldHVybiBuZXdvYmpcbn1cblxuXG5Cb3Jvbi5tZW1vaXplID0gZnVuY3Rpb24oZikge1xuICAgIHZhciB0YWJsZSA9IHt9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICAgICAgdmFyIGtleSA9IGFyZ3MudG9TdHJpbmcoKVxuICAgICAgICByZXR1cm4gdGFibGVba2V5XSA/IHRhYmxlW2tleV0gOiAodGFibGVba2V5XSA9IGYuYXBwbHkobnVsbCwgYXJncykpXG4gICAgfSBcbn1cbiIsIlBCRmlsZXMgPSB7fVxuXG5QQkZpbGVzLm9sZEZpbGUgPSBudWxsXG5cblBCRmlsZXMuY3JlYXRlUHVmZiA9IGZ1bmN0aW9uKGNvbnRlbnQsIHR5cGUpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHt9XG4gICAgXG4gICAgdmFyIHR5cGUgICA9IHR5cGUgfHwgJ2ZpbGUnXG4gICAgdmFyIHJvdXRlcyA9IFsnbG9jYWwnXTtcblxuICAgIHZhciB1c2VyUmVjb3JkID0gUEIuZ2V0Q3VycmVudFVzZXJSZWNvcmQoKVxuICAgIHZhciB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHQgPSBbdXNlclJlY29yZF1cbiAgICB2YXIgcHJldmlvdXMsIHB1ZmZcbiAgICBcbiAgICBwdWZmID0gUEIuc2ltcGxlQnVpbGRQdWZmKHR5cGUsIGNvbnRlbnQsIHBheWxvYWQsIHJvdXRlcywgdXNlclJlY29yZHNGb3JXaG9tVG9FbmNyeXB0KVxuICAgIFxuXG4gICAgLy8gUEIudXNlU2VjdXJlSW5mbyhmdW5jdGlvbihpZGVudGl0aWVzLCBjdXJyZW50VXNlcm5hbWUsIHByaXZhdGVSb290S2V5LCBwcml2YXRlQWRtaW5LZXksIHByaXZhdGVEZWZhdWx0S2V5KSB7XG4gICAgLy8gICAgIHZhciBwcml2YXRlRW52ZWxvcGVBbGlhc1xuICAgIC8vICAgICBwdWZmID0gUEIuYnVpbGRQdWZmKGN1cnJlbnRVc2VybmFtZSwgcHJpdmF0ZURlZmF1bHRLZXksIHJvdXRlcywgdHlwZSwgY29udGVudCwgcGF5bG9hZCwgcHJldmlvdXMsIHVzZXJSZWNvcmRzRm9yV2hvbVRvRW5jcnlwdCwgcHJpdmF0ZUVudmVsb3BlQWxpYXMpXG4gICAgLy8gfSlcblxuICAgIHJldHVybiBwdWZmXG59XG5cblBCRmlsZXMucHJlcEJsb2IgPSBmdW5jdGlvbihzdHIsIHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPSAnc3RyaW5nJylcbiAgICAgICAgc3RyID0gSlNPTi5zdHJpbmdpZnkoc3RyKVxuXG4gICAgdmFyIGJsb2JcblxuICAgIGlmICh0eXBlID09ICdmaWxlJylcbiAgICAgICAgYmxvYiA9IFBCRmlsZXMuZGF0YVVSSXRvQmxvYihzdHIpXG4gICAgZWxzZVxuICAgICAgICBibG9iID0gbmV3IEJsb2IoW3N0cl0sIHt0eXBlOiAndGV4dC9wbGFpbid9KVxuXG5cbiAgICAvLyBJRSBuZWVkcyB0byBkaXJlY3RseSBzYXZlIHRoZSBibG9iIG9iamVjdFxuICAgIGlmIChuYXZpZ2F0b3IuYXBwVmVyc2lvbi50b1N0cmluZygpLmluZGV4T2YoJy5ORVQnKSA+IDApXG4gICAgICAgIHJldHVybiBibG9iXG5cbiAgICBpZihQQkZpbGVzLm9sZEZpbGUpXG4gICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwoUEJGaWxlcy5vbGRGaWxlKVxuXG4gICAgUEJGaWxlcy5vbGRGaWxlID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcblxuICAgIHJldHVybiBQQkZpbGVzLm9sZEZpbGVcbn1cblxuUEJGaWxlcy5leHRyYWN0TGV0dGVyUHVmZiA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICB2YXIgcHVmZiA9IFBCLnBhcnNlSlNPTihjb250ZW50KVxuICAgIGlmKCFwdWZmKSBcbiAgICAgICAgcmV0dXJuIFBCLmVtcHR5UHJvbWlzZSgnRW52ZWxvcGUgd2FzIG5vdCBKU09OIGVuY29kZWQnKVxuICAgIFxuICAgIC8vIHZhciB1c2VyUmVjb3JkID0gUEIuZ2V0Q3VycmVudFVzZXJSZWNvcmQoKVxuICAgIC8vIHZhciBwdWJrZXkgPSB1c2VyUmVjb3JkLmRlZmF1bHRLZXlcbiAgICBcbiAgICB2YXIgbGV0dGVyID0gUEIuRGF0YS5nZXREZWNyeXB0ZWRQdWZmUHJvbWlzZShwdWZmKVxuICAgIFxuICAgIHJldHVybiBsZXR0ZXJcbn1cblxuUEJGaWxlcy5vcGVuUHVmZkZpbGUgPSBmdW5jdGlvbihlbGVtZW50KSB7ICAgICAgICAgICAgICAgIFxuICAgIHJldHVybiBQQkZpbGVzLmhhbmRsZUZpbGVPcGVuKGVsZW1lbnQpXG59XG5cblBCRmlsZXMub3BlblRleHRGaWxlID0gZnVuY3Rpb24oZWxlbWVudCkgeyAgICAgICAgICAgICAgICBcbiAgICByZXR1cm4gUEJGaWxlcy5oYW5kbGVGaWxlT3BlbihlbGVtZW50KVxufVxuXG5QQkZpbGVzLm9wZW5CaW5hcnlGaWxlID0gZnVuY3Rpb24oZWxlbWVudCkgeyAgICAgICAgICAgICAgICBcbiAgICByZXR1cm4gUEJGaWxlcy5oYW5kbGVGaWxlT3BlbihlbGVtZW50LCAnYXNEYXRhVVJJJylcbn1cblxuUEJGaWxlcy5oYW5kbGVGaWxlT3BlbiA9IGZ1bmN0aW9uKGVsZW1lbnQsIGFzRGF0YVVSSSkgeyAgICAgICAgICAgICAgICBcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG5cbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhyZWFkZXIpXG4gICAgICAgICAgICB2YXIgZGF0YVVSSUNvbnRlbnQgPSBldmVudC50YXJnZXQucmVzdWx0XG4gICAgICAgICAgICAvLyB2YXIgYmxvYiA9IFBCRmlsZXMuZGF0YVVSSXRvQmxvYihkYXRhVVJJQ29udGVudClcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YVVSSUNvbnRlbnQpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKCFlbGVtZW50LmZpbGVzWzBdKSAvLyBUSElOSzogaXMgZmFsc2UgdGhlIHJpZ2h0IHJlc3BvbnNlP1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgnTm8gZmlsZSBzZWxlY3RlZCcpXG4gICAgICAgICAgICBcbiAgICAgICAgaWYoYXNEYXRhVVJJKVxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZWxlbWVudC5maWxlc1swXSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZWxlbWVudC5maWxlc1swXSlcbiAgICB9KVxufVxuXG4vLyB2aWEgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTk4OTA4L2NvbnZlcnQtZGF0YS11cmktdG8tZmlsZS10aGVuLWFwcGVuZC10by1mb3JtZGF0YVxuUEJGaWxlcy5kYXRhVVJJdG9CbG9iID0gZnVuY3Rpb24oZGF0YVVSSSkge1xuICAgIC8vIGNvbnZlcnQgYmFzZTY0L1VSTEVuY29kZWQgZGF0YSBjb21wb25lbnQgdG8gcmF3IGJpbmFyeSBkYXRhIGhlbGQgaW4gYSBCbG9iXG4gICAgdmFyIGJ5dGVTdHJpbmc7XG4gICAgaWYgKGRhdGFVUkkuc3BsaXQoJywnKVswXS5pbmRleE9mKCdiYXNlNjQnKSA+PSAwKVxuICAgICAgICBieXRlU3RyaW5nID0gYXRvYihkYXRhVVJJLnNwbGl0KCcsJylbMV0pO1xuICAgIGVsc2VcbiAgICAgICAgYnl0ZVN0cmluZyA9IHVuZXNjYXBlKGRhdGFVUkkuc3BsaXQoJywnKVsxXSk7XG5cbiAgICAvLyBzZXBhcmF0ZSBvdXQgdGhlIG1pbWUgY29tcG9uZW50XG4gICAgdmFyIG1pbWVTdHJpbmcgPSBkYXRhVVJJLnNwbGl0KCcsJylbMF0uc3BsaXQoJzonKVsxXS5zcGxpdCgnOycpWzBdXG5cbiAgICAvLyB3cml0ZSB0aGUgYnl0ZXMgb2YgdGhlIHN0cmluZyB0byBhIHR5cGVkIGFycmF5XG4gICAgdmFyIGlhID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpYVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJsb2IoW2lhXSwge3R5cGU6bWltZVN0cmluZ30pO1xufVxuIiwiLypcbiAgICBldmVudHM6IGEgcHViL3N1YiBzeXN0ZW0gd2l0aCB3aWxkY2FyZCBwYXRoc1xuKi9cblxuXG5FdmVudHMgPSB7fVxuRXZlbnRzLnN1YnMgPSB7fVxuXG5FdmVudHMucHViID0gZnVuY3Rpb24ocGF0aCwgZGF0YSkge1xuICAgIHJldHVybiBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7RXZlbnRzLnN0YXJ0X3B1YihwYXRoLCBkYXRhKX0pICAgICAgICAgICAgICAvLyBkbyBpdCBuZXh0IHRpY2tcbn1cblxuRXZlbnRzLnN1YiA9IGZ1bmN0aW9uKHBhdGgsIGhhbmRsZXIpIHtcbiAgICBwYXRoID0gRXZlbnRzLnNjcnViX3BhdGgocGF0aCkuam9pbignLycpXG4gICAgaWYoIUV2ZW50cy5zdWJzW3BhdGhdKSBFdmVudHMuc3Vic1twYXRoXSA9IFtdXG4gICAgRXZlbnRzLnN1YnNbcGF0aF0ucHVzaChoYW5kbGVyKVxufVxuXG5FdmVudHMudW5zdWIgPSBmdW5jdGlvbihwYXRoLCBoYW5kbGVyKSB7XG4gICAgcGF0aCA9IEV2ZW50cy5zY3J1Yl9wYXRoKHBhdGgpLmpvaW4oJy8nKVxuXG4gICAgdmFyIHN1YnMgPSBFdmVudHMuc3Vic1twYXRoXVxuICAgIGlmKCFzdWJzKSByZXR1cm4gZmFsc2VcblxuICAgIHZhciBpbmRleCA9IHN1YnMuaW5kZXhPZihoYW5kbGVyKVxuICAgIGlmKGluZGV4ID09IC0xKSByZXR1cm4gZmFsc2VcblxuICAgIHN1YnMuc3BsaWNlKGluZGV4LCAxKVxufVxuXG5FdmVudHMuc3RhcnRfcHViID0gZnVuY3Rpb24ocGF0aCwgZGF0YSkge1xuICAgIC8vLy8gcHViIHRvICogYXQgZWFjaCBsZXZlbCBhbmQgdGhlbiB0byBwYXRoIGl0c2VsZlxuICAgIHZhciBwYXRobGlzdCA9IEV2ZW50cy5zY3J1Yl9wYXRoKHBhdGgpXG4gICAgdmFyIHJlYWxwYXRoID0gcGF0aGxpc3Quam9pbignLycpXG5cbiAgICBFdmVudHMudHJ5X3B1YignKicsIGRhdGEsIHJlYWxwYXRoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2xvYmFsIGNhdGNoYWxsXG5cbiAgICBwYXRobGlzdC5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBzZWcpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbm5lbCBjYXRjaGFsbHNcbiAgICAgICAgdmFyIG5ld2FjYyA9IGFjYyArIHNlZyArICcvJ1xuICAgICAgICBFdmVudHMudHJ5X3B1YihuZXdhY2MgKyAnKicsIGRhdGEsIHJlYWxwYXRoKVxuICAgICAgICByZXR1cm4gbmV3YWNjXG4gICAgfSwgJycpXG5cbiAgICBFdmVudHMudHJ5X3B1YihyZWFscGF0aCwgZGF0YSwgcmVhbHBhdGgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWN0dWFsIGNoYW5uZWxcbn1cblxuRXZlbnRzLnRyeV9wdWIgPSBmdW5jdGlvbihwYXRoLCBkYXRhLCByZWFscGF0aCkge1xuICAgIHZhciBoYW5kbGVycyA9IEV2ZW50cy5zdWJzW3BhdGhdXG4gICAgaWYoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHJldHVybiBmYWxzZVxuICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlcikge2hhbmRsZXIoZGF0YSwgcmVhbHBhdGgpfSlcbiAgICAvLyBUSElOSzogdXNlIHNldEltbWVkaWF0ZSBoZXJlP1xufVxuXG5cbkV2ZW50cy5zY3J1Yl9wYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL15bXlxcdyotXSsvLCAnJykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJpbSBsZWFkaW5nIHNsYXNoZXMgZXRjXG4gICAgICAgIC5yZXBsYWNlKC9bXlxcdyotXSskLywgJycpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmltIHRyYWlsaW5nIGd1bmtcbiAgICAgICAgLnNwbGl0KCcvJykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWsgb3V0IHRoZSBwYXRoIHNlZ21lbnRzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtLnJlcGxhY2UoL1teXFx3Ki1dL2csICcnKX0pICAgICAgICAgICAgICAvLyBzY3J1YiBlYWNoIHNlZ21lbnRcbn1cblxuXG4vLyBtYXliZSBsYXRlclxuLy8gZXZlbnRsb2cgPSBbXVxuLy8gRXZlbnRzLnN1YignKicsIGZ1bmN0aW9uKGRhdGEsIHBhdGgpIHtcbi8vICAgICBldmVudGxvZy5wdXNoKFtwYXRoLCBkYXRhXSlcbi8vIH0pXG5cbiIsIi8qXG4gICAgZ3JpZGJveDogYSBzaW1wbGUgc3lzdGVtIGZvciBwdXR0aW5nIHRoaW5ncyBpbiBwbGFjZXNcbiovXG5cbkdyaWRib3ggPSB7fVxuXG5HcmlkYm94LmdldEdyaWRDb29yZEJveCA9IGZ1bmN0aW9uKHJvd3MsIGNvbHMsIG91dGVyd2lkdGgsIG91dGVyaGVpZ2h0LCB2ZXJ0aWNhbFBhZGRpbmcpIHtcbiAgICB2YXIgbWluID0gZnVuY3Rpb24oYSwgYikge3JldHVybiBNYXRoLm1pbihhLCBiKX1cbiAgICB2YXIgbWF4ID0gZnVuY3Rpb24oYSwgYikge3JldHVybiBNYXRoLm1heChhLCBiKX1cbiAgICB2YXIgZ3JpZHdpZHRoICA9IG91dGVyd2lkdGggIC8gY29sc1xuICAgIHZhciBncmlkaGVpZ2h0ID0gb3V0ZXJoZWlnaHQgLyByb3dzXG4gICAgdmFyIGVxID0gZnVuY3Rpb24oYSwgYikge3JldHVybiBhID09IGJ9XG4gICAgdmFyIGdyaWQgPSBBcnJheS5hcHBseSgwLCBBcnJheShyb3dzKSlcbiAgICAgICAgLm1hcChmdW5jdGlvbigpIHtyZXR1cm4gQXJyYXkuYXBwbHkoMCwgQXJyYXkoY29scykpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKCkge3JldHVybiAwfSl9KSAvLyBidWlsZCAyRCBhcnJheVxuXG4gICAgcmV0dXJuIHsgZ2V0OiBmdW5jdGlvbigpIHtyZXR1cm4gZ3JpZH1cbiAgICAgICAgLCBzZXRfZXE6IGZ1bmN0aW9uKG5ld19lcSkge2VxID0gbmV3X2VxfVxuICAgICAgICAsIGFkZDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgbWlueSwgbWlueCwgbWF4eSwgbWF4eCwgcG9pbnRlcikge1xuICAgICAgICAgICAgbWF4eSA9IG1pbihtYXh5fHxyb3dzLWhlaWdodCwgcm93cy1oZWlnaHQpLCBtYXh4ID0gbWluKG1heHh8fGNvbHMtd2lkdGgsIGNvbHMtd2lkdGgpXG4gICAgICAgICAgICBtaW55ID0gbWluKG1pbnl8fDAsIG1heHkpLCBtaW54ID0gbWluKG1pbnh8fDAsIG1heHgpXG4gICAgICAgICAgICBpZihtYXh4PDAgfHwgbWF4eTwwKSByZXR1cm4gUEIub25FcnJvcignQmxvY2sgaXMgdG9vIGJpZyBmb3IgdGhlIGdyaWQnKVxuXG4gICAgICAgICAgICB0b3A6IGZvcih2YXIgeSA9IG1pbnk7IHkgPD0gbWF4eTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgYm90OiBmb3IodmFyIHggPSBtaW54OyB4IDw9IG1heHg7ICB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBkeSA9IDA7IGR5IDwgaGVpZ2h0OyBkeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGR4ID0gMDsgZHggPCB3aWR0aDsgZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGdyaWRbeStkeV1beCtkeF0pIGNvbnRpbnVlIGJvdCB9fVxuICAgICAgICAgICAgICAgICAgICBicmVhayB0b3AgfX1cbiAgICAgICAgICAgIGlmKHggPT0gbWF4eCsxICYmIHkgPT0gbWF4eSsxKSByZXR1cm4gUEIub25FcnJvcignTm8gcm9vbSBpbiB0aGUgZ3JpZCcpXG4gICAgICAgICAgICBpZih4ID09IG51bGwgfHwgeSA9PSBudWxsKSByZXR1cm4gUEIub25FcnJvcignQmxvY2sgdG9vIGJpZyBmb3IgdGhlIGdyaWQnKVxuICAgICAgICAgICAgZm9yKHZhciBkeSA9IDA7IGR5IDwgaGVpZ2h0OyBkeSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBkeCA9IDA7IGR4IDwgd2lkdGg7IGR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZFt5K2R5XVt4K2R4XSA9IHBvaW50ZXIgfHwgMSB9IH1cbiAgICAgICAgICAgIHJldHVybiB7d2lkdGg6IHdpZHRoKmdyaWR3aWR0aCwgaGVpZ2h0OiBoZWlnaHQqZ3JpZGhlaWdodCwgeDogeCpncmlkd2lkdGgsIHk6IHkqZ3JpZGhlaWdodCsodmVydGljYWxQYWRkaW5nLzEuNSl9IC8vIFRISU5LOiBnZW5lcmFsaXplIHZlcnRpY2FsUGFkZGluZyBcbiAgICAgICAgfVxuICAgIH1cbn1cblxuR3JpZGJveC5maW5kTmVpZ2hib3IgPSBmdW5jdGlvbihncmlkLCBwb2ludGVyLCBkaXIpIHtcbiAgICB2YXIgYm94Q29vcmRzID0gR3JpZGJveC5maW5kQm94SW5HcmlkKGdyaWQsIHBvaW50ZXIpXG4gICAgaWYoIWJveENvb3JkcykgcmV0dXJuIGZhbHNlXG5cbiAgICAvLyBUT0RPOiBuZWVkIHRvIGluZGljYXRlIGlmIGRpckJveCBpcyBvdXRzaWRlIG9mIGdyaWQsIHZlcnN1cyBwb2ludGVyIG5vdCBmb3VuZFxuXG4gICAgdmFyIGRpckJveCA9IEdyaWRib3gubWFrZURpckJveChib3hDb29yZHMsIGRpcilcbiAgICBpZighZGlyQm94KSByZXR1cm4gZmFsc2VcblxuICAgIHJldHVybiBHcmlkYm94LmZpcnN0VGhpbmdJbkJveChncmlkLCBkaXJCb3hbMF0sIGRpckJveFsxXSlcbn1cblxuR3JpZGJveC5maW5kQm94SW5HcmlkID0gZnVuY3Rpb24oZ3JpZCwgdGFyZ2V0LCBlcSkge1xuICAgIC8vLyBmaW5kIHNvbWV0aGluZyBpbiBhIGdyaWQgYm94IGFuZCByZXR1cm4gY29vcmRzXG4gICAgLy8vIE5PVEU6IHRoaXMgYXNzdW1lcyByZWN0aWxpbmVhciBzaGFwZXNcbiAgICBlcSA9IGVxIHx8IGZ1bmN0aW9uKGEsIGIpIHtyZXR1cm4gYSA9PT0gYn1cbiAgICBlcSA9IGZ1bmN0aW9uKGEsIGIpIHtyZXR1cm4gYS5zaWcgPT09IGIuc2lnfSAvLyBUT0RPOiBlbmNhcHN1bGF0ZSBlcSBpbiBncmlkQm94IC8vIE9QVDogZG9uJ3QgbG9vayBpbnNpZGVcblxuICAgIHRvcDogZm9yKHZhciB5ID0gMCwgbHkgPSBncmlkLmxlbmd0aDsgeSA8IGx5OyB5KyspXG4gICAgICAgIGZvcih2YXIgeCA9IDAsIGx4ID0gZ3JpZFt5XS5sZW5ndGg7IHggPCBseDsgeCsrKVxuICAgICAgICAgICAgaWYoZXEoZ3JpZFt5XVt4XSwgdGFyZ2V0KSkgYnJlYWsgdG9wICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmluZCB0b3AgYW5kIGxlZnQgY29vcmRzXG5cbiAgICBpZih5ID09IGdyaWQubGVuZ3RoICYmIHggPT0gZ3JpZFswXS5sZW5ndGgpIHJldHVybiBmYWxzZSAgICAgICAgICAgIC8vIHRhcmdldCBub3QgaW4gYm94XG5cbiAgICBmb3IodmFyIGR5ID0gMCwgbHkgPSBncmlkLmxlbmd0aC15OyBkeSA8IGx5OyBkeSsrKVxuICAgICAgICBpZighZXEoZ3JpZFt5K2R5XVt4XSwgdGFyZ2V0KSkgYnJlYWsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBib3R0b20gY29vcmRcblxuICAgIGZvcih2YXIgZHggPSAwLCBseCA9IGdyaWRbeV0ubGVuZ3RoLXg7IGR4IDwgbHg7IGR4KyspXG4gICAgICAgIGlmKCFlcShncmlkW3ldW3grZHhdLCB0YXJnZXQpKSBicmVhayAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHJpZ2h0IGNvb3JkXG5cbiAgICByZXR1cm4gW1t4LCB5XSwgW3grZHgtMSwgeStkeS0xXV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pbnVzIG9uZSBiZWNhdXNlIGRlbHRhcyBhbHdheXMgb3ZlcnNob290XG59XG5cbkdyaWRib3guZmlyc3RUaGluZ0luQm94ID0gZnVuY3Rpb24oZ3JpZCwgdG9wbGVmdCwgYm90cmlnaHQpIHtcbiAgICBmb3IodmFyIHkgPSBNYXRoLm1heCh0b3BsZWZ0WzFdLCAwKSwgbHkgPSBNYXRoLm1pbihib3RyaWdodFsxXSwgZ3JpZC5sZW5ndGgtMSk7IHkgPD0gbHk7IHkrKylcbiAgICAgICAgZm9yKHZhciB4ID0gTWF0aC5tYXgodG9wbGVmdFswXSwgMCksIGx4ID0gTWF0aC5taW4oYm90cmlnaHRbMF0sIGdyaWRbMF0ubGVuZ3RoLTEpOyB4IDw9IGx4OyB4KyspXG4gICAgICAgICAgICBpZihncmlkW3ldW3hdKSByZXR1cm4gZ3JpZFt5XVt4XSAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsdGVxIGJlY2F1c2Ugb3VyIGJveGVzIGFyZSBpbmNsdXNpdmU7XG59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBib3VuZGFyaWVzIGFyZSBidWlsdCBpbi5cblxuR3JpZGJveC5tYWtlRGlyQm94ID0gZnVuY3Rpb24oYm94Q29vcmRzLCBkaXIpIHtcbiAgICB2YXIgdG9wICAgPSBib3hDb29yZHNbMF1bMV1cbiAgICB2YXIgbGVmdCAgPSBib3hDb29yZHNbMF1bMF1cbiAgICB2YXIgYm90ICAgPSBib3hDb29yZHNbMV1bMV1cbiAgICB2YXIgcmlnaHQgPSBib3hDb29yZHNbMV1bMF1cblxuICAgIGlmKGRpciA9PSAndXAnKSAgICByZXR1cm4gW1tsZWZ0LCB0b3AtMV0sICBbcmlnaHQsIHRvcC0xXV1cbiAgICBpZihkaXIgPT0gJ2Rvd24nKSAgcmV0dXJuIFtbbGVmdCwgYm90KzFdLCAgW3JpZ2h0LCBib3QrMV1dXG4gICAgaWYoZGlyID09ICdsZWZ0JykgIHJldHVybiBbW2xlZnQtMSwgdG9wXSwgIFtsZWZ0LTEsIGJvdF1dXG4gICAgaWYoZGlyID09ICdyaWdodCcpIHJldHVybiBbW3JpZ2h0KzEsIHRvcF0sIFtyaWdodCsxLCBib3RdXVxufVxuIiwiLypcbiAgICAgX19fXyAgX19fX18gX19fX18gX19fX18gX19fX18gX19fX18gXG4gICAgfCAgICBcXHwgIF8gIHwgICBfX3wgICAgIHwgX18gIHwgIF8gIHxcbiAgICB8ICB8ICB8ICAgICB8ICB8ICB8ICB8ICB8IF9fIC18ICAgICB8XG4gICAgfF9fX18vfF9ffF9ffF9fX19ffF9fX19ffF9fX19ffF9ffF9ffFxuICAgIFxuICAgIGRhZ29iYTogYSB0aW55IGluLW1lbW9yeSBncmFwaCBkYXRhYmFzZVxuXG4gICAgZXg6IFxuICAgIFYgPSBbIHtuYW1lOiAnYWxpY2UnfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxpY2UgZ2V0cyBhdXRvLV9pZCAocHJvbGx5IDEpXG4gICAgICAgICwge19pZDogMTAsIG5hbWU6ICdib2InLCBob2JiaWVzOiBbJ2FzZGYnLCB7eDozfV19XSBcbiAgICBFID0gWyB7X291dDogMSwgX2luOiAxMCwgX2xhYmVsOiAna25vd3MnfSBdXG4gICAgZyA9IERhZ29iYS5ncmFwaChWLCBFKVxuICAgIFxuICAgIGcuYWRkVmVydGV4KHtuYW1lOiAnY2hhcmxpZScsIF9pZDogJ2NoYXJsaWUnfSkgICAgICAgICAgICAgICAgLy8gc3RyaW5nIGlkcyBhcmUgZmluZVxuICAgIGcuYWRkVmVydGV4KHtuYW1lOiAnZGVsdGEnLCBfaWQ6ICczMCd9KSAgICAgICAgICAgICAgICAgICAgICAgLy8gYWN0dWFsbHkgdGhleSdyZSBhbGwgc3RyaW5nc1xuXG4gICAgZy5hZGRFZGdlKHtfb3V0OiAxMCwgX2luOiAzMCwgX2xhYmVsOiAncGFyZW50J30pXG4gICAgZy5hZGRFZGdlKHtfb3V0OiAxMCwgX2luOiAnY2hhcmxpZScsIF9sYWJlbDogJ2tub3dzJ30pXG5cbiAgICBnLnYoMSkub3V0KCdrbm93cycpLm91dCgpLnJ1bigpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgW2NoYXJsaWUsIGRlbHRhXVxuICAgIFxuICAgIHEgPSBnLnYoMSkub3V0KCdrbm93cycpLm91dCgpLnRha2UoMSlcbiAgICBxLnJ1bigpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgW2NoYXJsaWVdXG4gICAgcS5ydW4oKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFtkZWx0YV0gICAgKGJ1dCBkb24ndCByZWx5IG9uIHJlc3VsdCBvcmRlciEpXG4gICAgcS5ydW4oKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFtdXG4qL1xuXG5cbkRhZ29iYSA9IHt9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuYW1lc3BhY2VcblxuRGFnb2JhLkcgPSB7fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByb3RvdHlwZVxuXG5EYWdvYmEuZ3JhcGggPSBmdW5jdGlvbihWLCBFKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZmFjdG9yeVxuICB2YXIgZ3JhcGggPSBPYmplY3QuY3JlYXRlKCBEYWdvYmEuRyApXG4gIGdyYXBoLnZlcnRpY2VzID0gW10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcmVzaCBjb3BpZXMgc28gdGhleSdyZSBub3Qgc2hhcmVkXG4gIGdyYXBoLmVkZ2VzID0gW11cbiAgZ3JhcGgudmVydGV4SW5kZXggPSB7fVxuICBpZihWICYmIEFycmF5LmlzQXJyYXkoVikpIGdyYXBoLmFkZFZlcnRpY2VzKFYpICAgICAgICAgICAgICAgICAgLy8gYXJyYXlzIG9ubHksIGJlY2F1c2UgeW91IHdvdWxkbid0XG4gIGlmKEUgJiYgQXJyYXkuaXNBcnJheShFKSkgZ3JhcGguYWRkRWRnZXMoRSkgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHRoaXMgd2l0aCBzaW5ndWxhciBWIGFuZCBFXG4gIHJldHVybiBncmFwaFxufVxuXG5EYWdvYmEuRy52ID0gZnVuY3Rpb24oKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIHF1ZXJ5IGluaXRpYWxpemVyOiBnLnYoKSAtPiBxdWVyeVxuICB2YXIgcXVlcnkgPSBEYWdvYmEucXVlcnkodGhpcylcbiAgcXVlcnkuYWRkKFsndmVydGV4J10uY29uY2F0KCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykgKSlcbiAgcmV0dXJuIHF1ZXJ5XG59XG5cbkRhZ29iYS5HLmFkZFZlcnRleCA9IGZ1bmN0aW9uKHZlcnRleCkge1xuICBpZighdmVydGV4Ll9pZCkgXG4gICAgdmVydGV4Ll9pZCA9IHRoaXMudmVydGljZXMubGVuZ3RoKzFcbiAgLy8gVE9ETzogZW5zdXJlIHVuaXF1ZSBfaWRcbiAgdGhpcy52ZXJ0aWNlcy5wdXNoKHZlcnRleCkgLy8gVEhJTks6IHRoZSB1c2VyIG1heSByZXRhaW4gYSBwb2ludGVyIHRvIHZlcnRleCwgd2hpY2ggdGhleSBtaWdodCBtdXRhdGUgbGF0ZXIgPi48XG4gIC8vIGNhbiB0YWtlIGF3YXkgdXNlcidzIGFiaWxpdHkgdG8gc2V0IF9pZCBhbmQgbG9zZSB0aGUgaW5kZXggY2FjaGUgaGFzaCwgYmVjYXVzZSBidWlsZGluZyBpdCBjYXVzZXMgYmlnIHJlYmFsYW5jaW5nIHNsb3dkb3ducyBhbmQgcnVucyB0aGUgR0MgaGFyZC4gKG9yIGRvZXMgaXQ/KSBbdGhpcyB3YXMgd2l0aCBhIG1pbGxpb24gaXRlbXMsIGluZGV4ZWQgYnkgY29uc2VjdXRpdmUgaW50cy4gZ2VuZXJhbGx5IHdlIG5lZWQgc2V0dGFibGUgX2lkIGJlY2F1c2Ugd2UgbmVlZCB0byBncmFiIHZlcnRpY2VzIHF1aWNrbHkgYnkgZXh0ZXJuYWwga2V5XVxuICB0aGlzLnZlcnRleEluZGV4W3ZlcnRleC5faWRdID0gdmVydGV4XG4gIHZlcnRleC5fb3V0ID0gW107IHZlcnRleC5faW4gPSBbXVxufVxuXG5EYWdvYmEuRy5hZGRFZGdlID0gZnVuY3Rpb24oZWRnZSkge1xuICBpZighZWRnZS5fbGFiZWwpIHJldHVybiBmYWxzZVxuICBlZGdlLl9pbiAgPSB0aGlzLmZpbmRWZXJ0ZXhCeUlkKGVkZ2UuX2luKVxuICBlZGdlLl9vdXQgPSB0aGlzLmZpbmRWZXJ0ZXhCeUlkKGVkZ2UuX291dClcbiAgaWYoIShlZGdlLl9pbiAmJiBlZGdlLl9vdXQpKSByZXR1cm4gZmFsc2VcbiAgZWRnZS5fb3V0Ll9vdXQucHVzaChlZGdlKVxuICBlZGdlLl9pbi5faW4ucHVzaChlZGdlKVxuICB0aGlzLmVkZ2VzLnB1c2goZWRnZSlcbn1cblxuRGFnb2JhLkcuYWRkVmVydGljZXMgPSBmdW5jdGlvbih2ZXJ0aWNlcykgeyB2ZXJ0aWNlcy5mb3JFYWNoKHRoaXMuYWRkVmVydGV4LmJpbmQodGhpcykpIH1cbkRhZ29iYS5HLmFkZEVkZ2VzICAgID0gZnVuY3Rpb24oZWRnZXMpICAgIHsgZWRnZXMgICAuZm9yRWFjaCh0aGlzLmFkZEVkZ2UgIC5iaW5kKHRoaXMpKSB9XG5cbkRhZ29iYS5HLmZpbmRWZXJ0ZXhCeUlkID0gZnVuY3Rpb24odmVydGV4X2lkKSB7XG4gIHJldHVybiB0aGlzLnZlcnRleEluZGV4W3ZlcnRleF9pZF0gfVxuXG5EYWdvYmEuRy5maW5kVmVydGljZXNCeUlkcyA9IGZ1bmN0aW9uKGlkcykge1xuICByZXR1cm4gaWRzLmxlbmd0aCA9PSAxID8gW10uY29uY2F0KCB0aGlzLmZpbmRWZXJ0ZXhCeUlkKGlkc1swXSkgfHwgW10gKVxuICAgICAgIDogaWRzLm1hcCggdGhpcy5maW5kVmVydGV4QnlJZC5iaW5kKHRoaXMpICkuZmlsdGVyKEJvb2xlYW4pIH1cblxuRGFnb2JhLkcuZmluZFZlcnRpY2VzID0gZnVuY3Rpb24oaWRzKSB7XG4gIHJldHVybiB0eXBlb2YgaWRzWzBdID09ICdvYmplY3QnID8gdGhpcy5zZWFyY2hWZXJ0aWNlcyhpZHNbMF0pXG4gICAgICAgOiBpZHMubGVuZ3RoID09IDAgPyB0aGlzLnZlcnRpY2VzLnNsaWNlKCkgICAgICAgICAgICAgICAgICAvLyBPUFQ6IGRvIHdlIG5lZWQgdGhlIHNsaWNlP1xuICAgICAgIDogdGhpcy5maW5kVmVydGljZXNCeUlkcyhpZHMpIH1cblxuRGFnb2JhLkcuc2VhcmNoVmVydGljZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRoaXMudmVydGljZXMuZmlsdGVyKFxuICAgIGZ1bmN0aW9uKHZlcnRleCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKFxuICAgICAgICBmdW5jdGlvbihhY2MsIGtleSkge1xuICAgICAgICAgIHJldHVybiBhY2MgJiYgb2JqW2tleV0gPT0gdmVydGV4W2tleV0gfSwgdHJ1ZSApIH0gKSB9XG5cbkRhZ29iYS5HLmZpbmRFZGdlQnlJZCA9IGZ1bmN0aW9uKGVkZ2VfaWQpIHtcbiAgcmV0dXJuIERhZ29iYS5maW5kKHRoaXMuZWRnZXMsIGZ1bmN0aW9uKGVkZ2UpIHtyZXR1cm4gZWRnZS5faWQgPT0gZWRnZV9pZH0gKSB9XG5cbkRhZ29iYS5HLmZpbmRPdXRFZGdlcyA9IGZ1bmN0aW9uKHZlcnRleCkgeyByZXR1cm4gdmVydGV4Ll9vdXQ7IH1cbkRhZ29iYS5HLmZpbmRJbkVkZ2VzICA9IGZ1bmN0aW9uKHZlcnRleCkgeyByZXR1cm4gdmVydGV4Ll9pbjsgIH1cblxuRGFnb2JhLkcudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2lkcywgZG9uJ3QgaGFuZCBjb2RlIEpTT05cbiAgcmV0dXJuICd7XCJWXCI6JyArIEpTT04uc3RyaW5naWZ5KHRoaXMudmVydGljZXMsIERhZ29iYS5jbGVhbnZlcnRleClcbiAgICAgICArICcsXCJFXCI6JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZWRnZXMsICAgIERhZ29iYS5jbGVhbmVkZ2UpIFxuICAgICAgICsgJ30nIH1cblxuRGFnb2JhLmZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5vdGhlciBncmFwaCBjb25zdHJ1Y3RvclxuICB2YXIgb2JqID0gSlNPTi5wYXJzZShzdHIpXG4gIHJldHVybiBEYWdvYmEuZ3JhcGgob2JqLlYsIG9iai5FKSBcbn1cblxuXG5cbkRhZ29iYS5RID0ge30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3RvdHlwZVxuXG5EYWdvYmEucXVlcnkgPSBmdW5jdGlvbihncmFwaCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWN0b3J5IChvbmx5IGNhbGxlZCBieSBhIGdyYXBoJ3MgcXVlcnkgaW5pdGlhbGl6ZXJzKVxuICB2YXIgcXVlcnkgPSBPYmplY3QuY3JlYXRlKCBEYWdvYmEuUSApXG4gIFxuICBxdWVyeS4gICBncmFwaCA9IGdyYXBoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGdyYXBoIGl0c2VsZlxuICBxdWVyeS4gICBzdGF0ZSA9IFtdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhdGUgZm9yIGVhY2ggc3RlcFxuICBxdWVyeS4gcHJvZ3JhbSA9IFtdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBzdGVwcyB0byB0YWtlICBcbiAgcXVlcnkuZ3JlbWxpbnMgPSBbXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdyZW1saW5zIGZvciBlYWNoIHN0ZXBcbiAgXG4gIHJldHVybiBxdWVyeVxufVxuXG5EYWdvYmEuUS5ydW4gPSBmdW5jdGlvbigpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbWFnaWMgbGl2ZXMgaGVyZVxuICBcbiAgdmFyIGdyYXBoID0gdGhpcy5ncmFwaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXNlIGFyZSBjbG9zZWQgb3ZlciBpbiB0aGUgaGVscGVyc1xuICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgZ2l2ZSB0aGVtIGEgc3BvdCBpbiB0aGUgZnJhbWVcbiAgdmFyIHByb2dyYW0gID0gdGhpcy5wcm9ncmFtXG4gIHZhciBncmVtbGlucyA9IHRoaXMuZ3JlbWxpbnNcblxuICB2YXIgbWF4ID0gcHJvZ3JhbS5sZW5ndGgtMSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd29yayBiYWNrd2FyZHNcbiAgdmFyIHBjID0gbWF4ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2dyYW0gY291bnRlclxuICB2YXIgZG9uZSA9IC0xICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVoaW5kd2hpY2ggdGhpbmdzIGhhdmUgZmluaXNoZWRcbiAgdmFyIHJlc3VsdHMgPSBbXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdHMgZm9yIHRoaXMgcnVuXG4gIHZhciBtYXliZV9ncmVtbGluID0gZmFsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIG15dGhpY2FsIGJlYXN0XG5cbiAgaWYoIXByb2dyYW0ubGVuZ3RoKSByZXR1cm4gW10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGJvdGhlclxuICBcbiAgXG4gIC8vIGRyaXZlciBsb29wXG4gIHdoaWxlKGRvbmUgPCBtYXgpIHtcbiAgICBtYXliZV9ncmVtbGluID0gdHJ5X3N0ZXAocGMsIG1heWJlX2dyZW1saW4pICAgICAgICAgICAgICAgICAgIC8vIG1heWJlX2dyZW1saW4gaXMgYSBncmVtbGluIG9yIChzdHJpbmcgfCBmYWxzZSlcbiAgICBcbiAgICBpZihtYXliZV9ncmVtbGluID09ICdwdWxsJykge1xuICAgICAgbWF5YmVfZ3JlbWxpbiA9IGZhbHNlXG4gICAgICBpZihwYy0xID4gZG9uZSkge1xuICAgICAgICBwYy0tXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lID0gcGNcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYobWF5YmVfZ3JlbWxpbiA9PSAnZG9uZScpIHtcbiAgICAgIGRvbmUgPSBwY1xuICAgICAgbWF5YmVfZ3JlbWxpbiA9IGZhbHNlXG4gICAgfVxuICAgIFxuICAgIHBjKytcbiAgICBcbiAgICBpZihwYyA+IG1heCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgZ3JlbWxpbiBpcyBwb3BwaW5nIG91dCBvZiB0aGUgcGlwZWxpbmUuIGNhdGNoIGl0IVxuICAgICAgaWYobWF5YmVfZ3JlbWxpbilcbiAgICAgICAgcmVzdWx0cy5wdXNoKG1heWJlX2dyZW1saW4pXG4gICAgICBtYXliZV9ncmVtbGluID0gZmFsc2VcbiAgICAgIHBjLS1cbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBkZWFsIHdpdGggZ3JlbWxpbiBwYXRocyAvIGhpc3RvcnkgYW5kIGdyZW1saW4gXCJjb2xsaXNpb25zXCJcbiAgXG4gIHJlc3VsdHMgPSByZXN1bHRzLm1hcChmdW5jdGlvbihncmVtbGluKSB7ICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHRoaXMgYSBxdWVyeSBjb21wb25lbnQgKG9yIHBvc3Rob29rKVxuICAgIHJldHVybiBncmVtbGluLnJlc3VsdCA/IGdyZW1saW4ucmVzdWx0IDogZ3JlbWxpbi52ZXJ0ZXggfSApXG5cbiAgcmVzdWx0cyA9IERhZ29iYS5maXJlaG9va3MoJ3Bvc3RxdWVyeScsIHRoaXMsIHJlc3VsdHMpWzBdIFxuICBcbiAgcmV0dXJuIHJlc3VsdHNcbiAgXG4gIC8vIE5BTUVEIEhFTFBFUlNcbiAgXG4gIGZ1bmN0aW9uIHRyeV9zdGVwKHBjLCBtYXliZV9ncmVtbGluKSB7XG4gICAgdmFyIHN0ZXAgPSBwcm9ncmFtW3BjXVxuICAgIHZhciBteV9zdGF0ZSA9IChzdGF0ZVtwY10gPSBzdGF0ZVtwY10gfHwge30pXG4gICAgaWYoIURhZ29iYS5RRnVuc1tzdGVwWzBdXSkgcmV0dXJuIERhZ29iYS5vbkVycm9yKCdVbnJlY29nbml6ZWQgZnVuY3Rpb24gY2FsbDogJyArIHN0ZXBbMF0pIHx8IG1heWJlX2dyZW1saW4gfHwgJ3B1bGwnXG4gICAgcmV0dXJuIERhZ29iYS5RRnVuc1tzdGVwWzBdXShncmFwaCwgc3RlcC5zbGljZSgxKSB8fCB7fSwgbWF5YmVfZ3JlbWxpbiwgbXlfc3RhdGUpXG4gIH1cbiAgICBcbiAgZnVuY3Rpb24gZ3JlbWxpbl9ib3hlcihzdGVwX2luZGV4KSB7IHJldHVybiBmdW5jdGlvbihncmVtbGluKSB7IHJldHVybiBbc3RlcF9pbmRleCwgZ3JlbWxpbl0gfSB9XG4gIFxuICBmdW5jdGlvbiBzdGVwcGVyKHN0ZXBfaW5kZXgsIGdyZW1saW4pIHtcbiAgICB2YXIgc3RlcCA9IHByb2dyYW1bc3RlcF9pbmRleF1cbiAgICBpZighRGFnb2JhLlFGdW5zW3N0ZXBbMF1dKSByZXR1cm4gRGFnb2JhLm9uRXJyb3IoJ1VucmVjb2duaXplZCBmdW5jdGlvbiBjYWxsOiAnICsgc3RlcFswXSkgfHwge31cbiAgICByZXR1cm4gRGFnb2JhLlFGdW5zW3N0ZXBbMF1dKGdyYXBoLCBzdGVwLnNsaWNlKDEpIHx8IHt9LCBncmVtbGluIHx8IHt9LCBzdGF0ZVtzdGVwX2luZGV4XSB8fCB7fSlcbiAgfVxuICBcbiAgZnVuY3Rpb24gZWF0X2dyZW1saW5zKGdyZW1saW5zLCBzdGVwX2luZGV4LCByZXN1bHQpIHtcbiAgICByZXR1cm4gZ3JlbWxpbnMuY29uY2F0KCAocmVzdWx0LnN0YXkgfHwgW10pLm1hcChncmVtbGluX2JveGVyKHN0ZXBfaW5kZXgpKSAgIClcbiAgICAgICAgICAgICAgICAgICAuY29uY2F0KCAocmVzdWx0LmdvICAgfHwgW10pLm1hcChncmVtbGluX2JveGVyKHN0ZXBfaW5kZXgrMSkpICkgfVxuICBcbiAgZnVuY3Rpb24gc2V0YmFuZ19ncmVtbGlucyhzdGVwX2luZGV4LCByZXN1bHQpIHtncmVtbGlucyA9IGVhdF9ncmVtbGlucyhncmVtbGlucywgc3RlcF9pbmRleCwgcmVzdWx0KX1cbn1cblxuXG5EYWdvYmEuUS5hZGQgPSBmdW5jdGlvbihsaXN0KSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhIG5ldyB0cmF2ZXJzYWwgdG8gdGhlIHF1ZXJ5XG4gIHRoaXMucHJvZ3JhbS5wdXNoKGxpc3QpXG4gIHJldHVybiB0aGlzXG59XG5cbkRhZ29iYS5hZGRRRnVuID0gZnVuY3Rpb24obmFtZSwgZnVuKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhIG5ldyB0cmF2ZXJzYWwgdHlwZVxuICBEYWdvYmEuUUZ1bnNbbmFtZV0gPSBmdW5cbiAgRGFnb2JhLlFbbmFtZV0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuYWRkKFtuYW1lXS5jb25jYXQoW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzKSkpIH0gXG4gIC8vIFRPRE86IGFjY2VwdCBzdHJpbmcgZnVuIGFuZCBhbGxvdyBleHRyYSBwYXJhbXMsIGZvciBidWlsZGluZyBxdWljayBhbGlhc2VzIGxpa2VcbiAgLy8gICAgICAgRGFnb2JhLmFkZFFGdW4oJ2NoaWxkcmVuJywgJ291dCcpIDwtLSBpZiBhbGwgb3V0IGVkZ2VzIGFyZSBraWRzXG4gIC8vICAgICAgIERhZ29iYS5hZGRRRnVuKCdudGhHR1AnLCAnaW5OJywgJ3BhcmVudCcpXG4gIC8vIHZhciBtZXRob2RzID0gWydvdXQnLCAnaW4nLCAndGFrZScsICdwcm9wZXJ0eScsICdvdXRBbGxOJywgJ2luQWxsTicsICd1bmlxdWUnLCAnZmlsdGVyJywgJ291dFYnLCAnb3V0RScsICdpblYnLCAnaW5FJywgJ2JvdGgnLCAnYm90aFYnLCAnYm90aEUnXVxufVxuXG5cbkRhZ29iYS5RRnVucyA9IHt9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCB0cmF2ZXJzYWwgdHlwZXNcblxuRGFnb2JhLmFkZFFGdW4oJ3ZlcnRleCcsIGZ1bmN0aW9uKGdyYXBoLCBhcmdzLCBncmVtbGluLCBzdGF0ZSkge1xuICBpZighc3RhdGUudmVydGljZXMpIHN0YXRlLnZlcnRpY2VzID0gZ3JhcGguZmluZFZlcnRpY2VzKGFyZ3MpXG4gIGlmKCFzdGF0ZS52ZXJ0aWNlcy5sZW5ndGgpIHJldHVybiAnZG9uZSdcbiAgdmFyIHZlcnRleCA9IHN0YXRlLnZlcnRpY2VzLnBvcCgpIFxuICByZXR1cm4gRGFnb2JhLm1ha2VfZ3JlbWxpbih2ZXJ0ZXgpXG59KVxuICBcbkRhZ29iYS5hZGRRRnVuKCdvdXQnLCBmdW5jdGlvbihncmFwaCwgYXJncywgZ3JlbWxpbiwgc3RhdGUpIHtcbiAgaWYoIWdyZW1saW4gJiYgKCFzdGF0ZS5lZGdlcyB8fCAhc3RhdGUuZWRnZXMubGVuZ3RoKSkgcmV0dXJuICdwdWxsJ1xuICBpZighc3RhdGUuZWRnZXMgfHwgIXN0YXRlLmVkZ2VzLmxlbmd0aCkgXG4gICAgc3RhdGUuZWRnZXMgPSBncmFwaC5maW5kT3V0RWRnZXMoZ3JlbWxpbi52ZXJ0ZXgpLmZpbHRlcihEYWdvYmEuZmlsdGVyVGhpbmdzKGFyZ3NbMF0pKVxuICBpZighc3RhdGUuZWRnZXMubGVuZ3RoKSByZXR1cm4gJ3B1bGwnXG4gIHZhciB2ZXJ0ZXggPSBzdGF0ZS5lZGdlcy5wb3AoKS5faW4gLy8gd2hhdD9cbiAgdmFyIGNsb25lID0gRGFnb2JhLm1ha2VfZ3JlbWxpbih2ZXJ0ZXgpIC8vIHdlIGxvc2UgaGlzdG9yeSBoZXJlOiB1c2UgY2xvbmVfZ3JlbWxpbihncmVtbGluKS5nb3RvKHZlcnRleCkgaW5zdGVhZFxuICByZXR1cm4gY2xvbmVcbn0pXG5cbkRhZ29iYS5hZGRRRnVuKCdvdXRBbGxOJywgZnVuY3Rpb24oZ3JhcGgsIGFyZ3MsIGdyZW1saW4sIHN0YXRlKSB7XG4gIHZhciBmaWx0ZXIgPSBhcmdzWzBdXG4gIHZhciBsaW1pdCA9IGFyZ3NbMV0tMVxuICBcbiAgaWYoIXN0YXRlLmVkZ2VMaXN0KSB7IC8vIGluaXRpYWxpemVcbiAgICBpZighZ3JlbWxpbikgcmV0dXJuICdwdWxsJ1xuICAgIHN0YXRlLmVkZ2VMaXN0ID0gW11cbiAgICBzdGF0ZS5jdXJyZW50ID0gMFxuICAgIHN0YXRlLmVkZ2VMaXN0WzBdID0gZ3JhcGguZmluZE91dEVkZ2VzKGdyZW1saW4udmVydGV4KS5maWx0ZXIoRGFnb2JhLmZpbHRlclRoaW5ncyhmaWx0ZXIpKVxuICB9XG4gIFxuICBpZighc3RhdGUuZWRnZUxpc3Rbc3RhdGUuY3VycmVudF0ubGVuZ3RoKSB7IC8vIGZpbmlzaGVkIHRoaXMgcm91bmRcbiAgICBpZihzdGF0ZS5jdXJyZW50ID49IGxpbWl0IHx8ICFzdGF0ZS5lZGdlTGlzdFtzdGF0ZS5jdXJyZW50KzFdICAgLy8gdG90YWxseSBkb25lLCBvciB0aGUgbmV4dCByb3VuZCBoYXMgbm8gaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8ICFzdGF0ZS5lZGdlTGlzdFtzdGF0ZS5jdXJyZW50KzFdLmxlbmd0aCkge1xuICAgICAgc3RhdGUuZWRnZUxpc3QgPSBmYWxzZVxuICAgICAgcmV0dXJuICdwdWxsJ1xuICAgIH1cbiAgICBzdGF0ZS5jdXJyZW50KysgLy8gZ28gdG8gbmV4dCByb3VuZFxuICAgIHN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0gPSBbXSBcbiAgfVxuICBcbiAgdmFyIHZlcnRleCA9IHN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnRdLnBvcCgpLl9pblxuICBcbiAgaWYoc3RhdGUuY3VycmVudCA8IGxpbWl0KSB7IC8vIGFkZCBhbGwgb3VyIG1hdGNoaW5nIGVkZ2VzIHRvIHRoZSBuZXh0IGxldmVsXG4gICAgaWYoIXN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0pIHN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0gPSBbXVxuICAgIHN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0gPSBzdGF0ZS5lZGdlTGlzdFtzdGF0ZS5jdXJyZW50KzFdLmNvbmNhdChcbiAgICAgIGdyYXBoLmZpbmRPdXRFZGdlcyh2ZXJ0ZXgpLmZpbHRlcihEYWdvYmEuZmlsdGVyVGhpbmdzKGZpbHRlcikpXG4gICAgKVxuICB9XG4gIFxuICB2YXIgY2xvbmUgPSBEYWdvYmEubWFrZV9ncmVtbGluKHZlcnRleCkgLy8gd2UgbG9zZSBoaXN0b3J5IGhlcmU6IHVzZSBjbG9uZV9ncmVtbGluKGdyZW1saW4pLmdvdG8odmVydGV4KSBpbnN0ZWFkXG4gIHJldHVybiBjbG9uZVxufSlcbiAgXG5EYWdvYmEuYWRkUUZ1bignaW5BbGxOJywgZnVuY3Rpb24oZ3JhcGgsIGFyZ3MsIGdyZW1saW4sIHN0YXRlKSB7XG4gIHZhciBmaWx0ZXIgPSBhcmdzWzBdXG4gIHZhciBsaW1pdCA9IGFyZ3NbMV0tMVxuICBcbiAgaWYoIXN0YXRlLmVkZ2VMaXN0KSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemVcbiAgICBpZighZ3JlbWxpbikgcmV0dXJuICdwdWxsJ1xuICAgIHN0YXRlLmVkZ2VMaXN0ID0gW11cbiAgICBzdGF0ZS5jdXJyZW50ID0gMFxuICAgIHN0YXRlLmVkZ2VMaXN0WzBdID0gZ3JhcGguZmluZEluRWRnZXMoZ3JlbWxpbi52ZXJ0ZXgpLmZpbHRlcihEYWdvYmEuZmlsdGVyVGhpbmdzKGZpbHRlcikpXG4gIH1cbiAgXG4gIGlmKCFzdGF0ZS5lZGdlTGlzdFtzdGF0ZS5jdXJyZW50XS5sZW5ndGgpIHsgICAgICAgICAgICAgICAgICAgICAvLyBmaW5pc2hlZCB0aGlzIHJvdW5kXG4gICAgaWYoc3RhdGUuY3VycmVudCA+PSBsaW1pdCB8fCAhc3RhdGUuZWRnZUxpc3Rbc3RhdGUuY3VycmVudCsxXSAvLyB0b3RhbGx5IGRvbmUsIG9yIHRoZSBuZXh0IHJvdW5kIGhhcyBubyBpdGVtc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgIXN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0ubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5lZGdlTGlzdCA9IGZhbHNlXG4gICAgICByZXR1cm4gJ3B1bGwnXG4gICAgfVxuICAgIHN0YXRlLmN1cnJlbnQrKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ28gdG8gbmV4dCByb3VuZFxuICAgIHN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0gPSBbXSBcbiAgfVxuICBcbiAgdmFyIHZlcnRleCA9IHN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnRdLnBvcCgpLl9vdXRcbiAgXG4gIGlmKHN0YXRlLmN1cnJlbnQgPCBsaW1pdCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgYWxsIG91ciBtYXRjaGluZyBlZGdlcyB0byB0aGUgbmV4dCBsZXZlbFxuICAgIGlmKCFzdGF0ZS5lZGdlTGlzdFtzdGF0ZS5jdXJyZW50KzFdKSBzdGF0ZS5lZGdlTGlzdFtzdGF0ZS5jdXJyZW50KzFdID0gW11cbiAgICBzdGF0ZS5lZGdlTGlzdFtzdGF0ZS5jdXJyZW50KzFdID0gc3RhdGUuZWRnZUxpc3Rbc3RhdGUuY3VycmVudCsxXS5jb25jYXQoXG4gICAgICBncmFwaC5maW5kSW5FZGdlcyh2ZXJ0ZXgpLmZpbHRlcihEYWdvYmEuZmlsdGVyVGhpbmdzKGZpbHRlcikpXG4gICAgKVxuICB9XG4gIFxuICB2YXIgY2xvbmUgPSBEYWdvYmEubWFrZV9ncmVtbGluKHZlcnRleCkgLy8gd2UgbG9zZSBoaXN0b3J5IGhlcmU6IHVzZSBjbG9uZV9ncmVtbGluKGdyZW1saW4pLmdvdG8odmVydGV4KSBpbnN0ZWFkXG4gIHJldHVybiBjbG9uZVxufSlcbiAgXG5EYWdvYmEuYWRkUUZ1bignaW4nLCBmdW5jdGlvbihncmFwaCwgYXJncywgZ3JlbWxpbiwgc3RhdGUpIHtcbiAgaWYoIWdyZW1saW4gJiYgKCFzdGF0ZS5lZGdlcyB8fCAhc3RhdGUuZWRnZXMubGVuZ3RoKSkgcmV0dXJuICdwdWxsJ1xuICBpZighc3RhdGUuZWRnZXMgfHwgIXN0YXRlLmVkZ2VzLmxlbmd0aCkgXG4gICAgc3RhdGUuZWRnZXMgPSBncmFwaC5maW5kSW5FZGdlcyhncmVtbGluLnZlcnRleCkuZmlsdGVyKERhZ29iYS5maWx0ZXJUaGluZ3MoYXJnc1swXSkpXG4gIGlmKCFzdGF0ZS5lZGdlcy5sZW5ndGgpIHJldHVybiAncHVsbCdcbiAgdmFyIHZlcnRleCA9IHN0YXRlLmVkZ2VzLnBvcCgpLl9vdXQgLy8gd2hhdD8gLy8gYWxzbywgYWJzdHJhY3QgdGhpcy4uLlxuICB2YXIgY2xvbmUgPSBEYWdvYmEubWFrZV9ncmVtbGluKHZlcnRleCkgLy8gd2UgbG9zZSBoaXN0b3J5IGhlcmU6IHVzZSBjbG9uZV9ncmVtbGluKGdyZW1saW4pLmdvdG8odmVydGV4KSBpbnN0ZWFkXG4gIHJldHVybiBjbG9uZVxufSlcbiAgXG5EYWdvYmEuYWRkUUZ1bigncHJvcGVydHknLCBmdW5jdGlvbihncmFwaCwgYXJncywgZ3JlbWxpbiwgc3RhdGUpIHtcbiAgaWYoIWdyZW1saW4pIHJldHVybiAncHVsbCdcbiAgZ3JlbWxpbi5yZXN1bHQgPSBncmVtbGluLnZlcnRleFthcmdzWzBdXVxuICByZXR1cm4gZ3JlbWxpblxufSlcbiAgXG5EYWdvYmEuYWRkUUZ1bigndW5pcXVlJywgZnVuY3Rpb24oZ3JhcGgsIGFyZ3MsIGdyZW1saW4sIHN0YXRlKSB7XG4gIGlmKCFncmVtbGluKSByZXR1cm4gJ3B1bGwnXG4gIGlmKHN0YXRlW2dyZW1saW4udmVydGV4Ll9pZF0pIHJldHVybiAncHVsbCcgICAgICAgICAgICAgICAgICAgICAvLyB3ZSd2ZSBzZWVuIHRoaXMgZ3JlbWxpbiwgc28gZ2V0IGFub3RoZXIgaW5zdGVhZFxuICBzdGF0ZVtncmVtbGluLnZlcnRleC5faWRdID0gdHJ1ZVxuICByZXR1cm4gZ3JlbWxpblxufSlcbiAgXG5EYWdvYmEuYWRkUUZ1bignZmlsdGVyJywgZnVuY3Rpb24oZ3JhcGgsIGFyZ3MsIGdyZW1saW4sIHN0YXRlKSB7XG4gIGlmKCFncmVtbGluKSByZXR1cm4gJ3B1bGwnXG4gIGlmKHR5cGVvZiBhcmdzWzBdICE9ICdmdW5jdGlvbicpIHJldHVybiBEYWdvYmEub25FcnJvcignRmlsdGVyIGFyZyBpcyBub3QgYSBmdW5jdGlvbjogJyArIGFyZ3NbMF0pIHx8IGdyZW1saW5cbiAgaWYoIWFyZ3NbMF0oZ3JlbWxpbi52ZXJ0ZXgpKSByZXR1cm4gJ3B1bGwnICAgICAgICAgICAgICAgICAgICAgIC8vIGdyZW1saW4gZmFpbHMgZmlsdGVyIGZ1bmN0aW9uIFxuICAvLyBUSElOSzogd291bGQgd2UgZXZlciB3YW50IHRvIGZpbHRlciBieSBvdGhlciBwYXJ0cyBvZiB0aGUgZ3JlbWxpbj9cbiAgcmV0dXJuIGdyZW1saW5cbn0pXG4gIFxuRGFnb2JhLmFkZFFGdW4oJ3Rha2UnLCBmdW5jdGlvbihncmFwaCwgYXJncywgZ3JlbWxpbiwgc3RhdGUpIHtcbiAgc3RhdGUudGFrZW4gPSBzdGF0ZS50YWtlbiA/IHN0YXRlLnRha2VuIDogMFxuICBpZihzdGF0ZS50YWtlbiA9PSBhcmdzWzBdKSB7XG4gICAgc3RhdGUudGFrZW4gPSAwXG4gICAgcmV0dXJuICdkb25lJ1xuICB9XG4gIGlmKCFncmVtbGluKSByZXR1cm4gJ3B1bGwnXG4gIHN0YXRlLnRha2VuKysgLy8gVEhJTks6IG11dGF0aW5nIHN0YXRlXG4gIHJldHVybiBncmVtbGluXG59KVxuXG5cblxuLy8gaGkhIFxuLy8gLSB0dW5lIGdyZW1saW5zIChjb2xsaXNpb25zLCBoaXN0b3J5LCBldGMpXG4vLyAtIGludGVyZmFjZTogc2hvdyBxdWVyeSBwaWVjZXMgYW5kIHBhcmFtcyxcbi8vIC0gaW50ZXJmYWNlOiByZXN1bWFibGUgcXVlcmllc1xuLy8gLSBnZW5lcmF0aW9uYWwgcXVlcmllc1xuLy8gLSBpbnRlcnNlY3Rpb25zXG4vLyAtIGFkdmVyYnNcbi8vIC0geW91IGFyZSBncmVhdCFcblxuXG5cbkRhZ29iYS5ob29rcyA9IHt9XG5cbkRhZ29iYS5hZGRob29rID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2spIHtcbiAgaWYoIURhZ29iYS5ob29rc1t0eXBlXSkgRGFnb2JhLmhvb2tzW3R5cGVdID0gW11cbiAgRGFnb2JhLmhvb2tzW3R5cGVdLnB1c2goY2FsbGJhY2spXG59XG5cbkRhZ29iYS5maXJlaG9va3MgPSBmdW5jdGlvbih0eXBlLCBxdWVyeSkge1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKVxuICByZXR1cm4gKChEYWdvYmEuaG9va3MgfHwge30pW3R5cGVdIHx8IFtdKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBjYWxsYmFjaykge3JldHVybiBjYWxsYmFjay5hcHBseShxdWVyeSwgYWNjKX0sIGFyZ3MpXG59XG5cbkRhZ29iYS5tYWtlX2dyZW1saW4gPSBmdW5jdGlvbih2ZXJ0ZXgsIHN0YXRlKSB7IHJldHVybiB7dmVydGV4OiB2ZXJ0ZXgsIHN0YXRlOiBzdGF0ZX0gfVxuXG5EYWdvYmEuZmlsdGVyVGhpbmdzID0gZnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiAhYXJnID8gdHJ1ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgaXMgdHJ1ZVxuICAgICAgICAgOiBhcmcrJycgPT09IGFyZyA/IHRoaW5nLl9sYWJlbCA9PSBhcmcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBsYWJlbFxuICAgICAgICAgOiBBcnJheS5pc0FycmF5KGFyZykgPyAhIX5hcmcuaW5kZXhPZih0aGluZy5fbGFiZWwpIDogRGFnb2JhLm9iakZpbHRlcih0aGluZywgYXJnKSB9IH0gIC8vIG9yIGEgbGlzdCBvZiBsYWJlbHNcblxuRGFnb2JhLm9iakZpbHRlciA9IGZ1bmN0aW9uKHRoaW5nLCBvYmopIHtcbiAgZm9yKHZhciBrZXkgaW4gb2JqKVxuICAgIGlmKHRoaW5nW2tleV0gIT0gb2JqW2tleV0pXG4gICAgICByZXR1cm4gZmFsc2U7IHJldHVybiB0cnVlIH1cblxuRGFnb2JhLmZpbmQgPSBmdW5jdGlvbihhcnIsIGZ1bikge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgIGlmKGZ1bihhcnJbaV0sIGksIGFycikpXG4gICAgICByZXR1cm4gYXJyW2ldIH1cblxuRGFnb2JhLmNsZWFudmVydGV4ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge3JldHVybiAoa2V5ID09ICdfaW4nIHx8IGtleSA9PSAnX291dCcpID8gdW5kZWZpbmVkIDogdmFsdWV9IC8vIGZvciBKU09OLnN0cmluZ2lmeVxuRGFnb2JhLmNsZWFuZWRnZSAgID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge3JldHVybiBrZXkgPT0gJ19pbicgPyB2YWx1ZS5faWQgOiBrZXkgPT0gJ19vdXQnID8gdmFsdWUuX2lkIDogdmFsdWV9XG5cbkRhZ29iYS51bmlxdWVpZnkgPSBmdW5jdGlvbiAocmVzdWx0cykgeyAvLyBPUFQ6IGRvIHRoaXMgaW4gdGhlIHF1ZXJ5IHZpYSBncmVtbGluIGNvbGxpc2lvbiBjb3VudGluZ1xuICByZXR1cm4gW3Jlc3VsdHMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0sIGluZGV4LCBhcnJheSkge3JldHVybiBhcnJheS5pbmRleE9mKGl0ZW0pID09IGluZGV4fSldfVxuXG5EYWdvYmEuY2xlYW5jbG9uZSA9IGZ1bmN0aW9uIChyZXN1bHRzKSB7IC8vIHJlbW92ZSBhbGwgXy1wcmVmaXhlZCBwcm9wZXJ0aWVzXG4gcmV0dXJuIFtyZXN1bHRzLm1hcChmdW5jdGlvbihpdGVtKSB7cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaXRlbSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge3JldHVybiBrZXlbMF09PSdfJyA/IHVuZGVmaW5lZCA6IHZhbHVlfSkpfSldfVxuXG4vLyBOT1RFOiBhZGQgdGhlc2UgaG9va3MgaWYgeW91IG5lZWQgdGhlbS4gKG91ciB2ZXJ0ZXggcGF5bG9hZHMgYXJlIGltbXV0YWJsZSwgYW5kIHdlIHVuaXF1ZWlmeSBwcmlvciB0byB0YWtpbmcuKVxuXG4vLyBEYWdvYmEuYWRkaG9vaygncG9zdHF1ZXJ5JywgRGFnb2JhLnVuaXF1ZWlmeSlcbi8vIERhZ29iYS5hZGRob29rKCdwb3N0cXVlcnknLCBEYWdvYmEuY2xlYW5jbG9uZSlcblxuLy8gVEhJTks6IHRoZSB1bmlxdWlmeSBob29rIGhhcHBlbnMgYWZ0ZXIgdGhlIHRha2UgY29tcG9uZW50IHNvIGl0IHNtdXNoZXMgcmVzdWx0cyBkb3duLCBwb3NzaWJseSByZXR1cm5pbmcgZmV3ZXIgdGhhbiB5b3Ugd2FudGVkLi4uXG4gIFxuRGFnb2JhLm9uRXJyb3IgPSBmdW5jdGlvbihtc2cpIHtcbiAgY29uc29sZS5sb2cobXNnKVxuICByZXR1cm4gZmFsc2UgXG59IiwiLypcbiAgICAgICBfX19fX19fICBfXyAgIF9fICBfX19fX19fICBfX19fX19fICBfX19fX19fICBfX19fX19fICBfX18gICAgICBfX18gICAgIFxuICAgICAgfCAgICAgICB8fCAgfCB8ICB8fCAgICAgICB8fCAgICAgICB8fCAgXyAgICB8fCAgIF8gICB8fCAgIHwgICAgfCAgIHwgICAgXG4gICAgICB8ICAgIF8gIHx8ICB8IHwgIHx8ICAgIF9fX3x8ICAgIF9fX3x8IHxffCAgIHx8ICB8X3wgIHx8ICAgfCAgICB8ICAgfCAgICBcbiAgICAgIHwgICB8X3wgfHwgIHxffCAgfHwgICB8X19fIHwgICB8X19fIHwgICAgICAgfHwgICAgICAgfHwgICB8ICAgIHwgICB8ICAgIFxuICAgICAgfCAgICBfX198fCAgICAgICB8fCAgICBfX198fCAgICBfX198fCAgXyAgIHwgfCAgICAgICB8fCAgIHxfX18gfCAgIHxfX18gXG4gICAgICB8ICAgfCAgICB8ICAgICAgIHx8ICAgfCAgICB8ICAgfCAgICB8IHxffCAgIHx8ICAgXyAgIHx8ICAgICAgIHx8ICAgICAgIHxcbiAgICAgIHxfX198ICAgIHxfX19fX19ffHxfX198ICAgIHxfX198ICAgIHxfX19fX19ffHxfX3wgfF9ffHxfX19fX19ffHxfX19fX19ffCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuIFxuICBcbiAgICBUaGUgbWFpbiBpbnRlcmZhY2UgZm9yIHRoZSBwdWZmYmFsbCBwbGF0Zm9ybS4gXG4gICAgXG4gICAgTW9zdCBjYWxscyB0byB0aGUgcGxhdGZvcm0gc2hvdWxkIGdvIHRocm91Z2ggaGVyZSwgXG4gICAgcmF0aGVyIHRoYW4gYWNjZXNzaW5nIGNvcmUgc3lzdGVtcyBsaWtlIFBCLkRhdGEgYW5kIFBCLkNyeXB0byBkaXJlY3RseS5cblxuICAgIEluIGFkZGl0aW9uIHRvIHRoZSBwdWJsaWMtZmFjaW5nIEFQSSBtYW55IGdlbmVyYWwgaGVscGVyIGZ1bmN0aW9ucyBcbiAgICBhcmUgZXN0YWJsaXNoZWQgaGVyZSBmb3IgdXNlIGJ5IHRoZSBkZWVwZXIgbGF5ZXJzLlxuXG4gICAgQ29weXJpZ2h0IDIwMTQgRXZlcnlCaXQuIFNlZSBSRUFETUUgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbiAqL1xuXG5pZih0eXBlb2YgUEIgPT09ICd1bmRlZmluZWQnKSBQQiA9IHt9ICAgICAgICAgICAgICAgICAgIC8vIHdlIG1pZ2h0IGxvYWQgY29uZmlnLmpzIGZpcnN0XG5pZighUEIuQ09ORklHKSBQQi5DT05GSUcgPSB7fSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIHdlIG1pZ2h0IG5vdFxuXG5QQi5Nb2R1bGVzID0ge30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1cHBsZW1lbnRhcnkgZXh0ZW5zaW9ucyBsaXZlIGhlcmVcblBCLk0gPSBQQi5Nb2R1bGVzXG5cblBCLnZlcnNpb24gPSAnMC43LjInXG5cbi8vLy8vLy8vLy8vLy8vIFNUQU5EQVJEIEFQSSBGVU5DVElPTlMgLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuUEIuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAvLy8vIGluaXRpYWxpemVzIGFsbCBhdmFpbGFibGUgbW9kdWxlcyBhbmQgdGhlIHBsYXRmb3JtIHN1YnN5c3RlbXMuXG4gICAgLy8vLyBvcHRpb25zIGlzIGFuIG9iamVjdCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnMgdGhhdCBpcyBwYXNzZWQgdG8gZWFjaCBtb2R1bGUgYW5kIHN1YnN5c3RlbS5cbiAgICBcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIFxuICAgIC8vIEJFR0lOIENPTkZJRyBBTkQgT1BUSU9OUyAvL1xuICAgIFxuICAgIHNldERlZmF1bHQoJ3pvbmUnLCAnJylcbiAgICBzZXREZWZhdWx0KCdwdWZmQXBpJywgJ2h0dHBzOi8vaS5jeC9hcGkvcHVmZnMvYXBpLnBocCcpXG4gICAgc2V0RGVmYXVsdCgndXNlckFwaScsICdodHRwczovL2kuY3gvYXBpL3VzZXJzL2FwaS5waHAnKVxuICAgIHNldERlZmF1bHQoJ2V2ZW50c0FwaScsICdodHRwczovL2kuY3gvYXBpL3B1ZmZzL2FwaS5waHAnKVxuICAgIHNldERlZmF1bHQoJ2VuYWJsZVAyUCcsIGZhbHNlKVxuICAgIHNldERlZmF1bHQoJ3BhZ2VCYXRjaFNpemUnLCAxMClcbiAgICBzZXREZWZhdWx0KCdpbml0TG9hZEdpdmV1cCcsIDIwMClcbiAgICBzZXREZWZhdWx0KCduZXR3b3JrVGltZW91dCcsIDIwMDAwKSAgICAgICAgIC8vIHR3ZW50eSBzZWNvbmQgdGltZW91dFxuICAgIHNldERlZmF1bHQoJ25vTG9jYWxTdG9yYWdlJywgZmFsc2UpXG4gICAgc2V0RGVmYXVsdCgnbmV0YmxvY2tTdWZmaXgnLCAnbG9jYWwnKVxuICAgIHNldERlZmF1bHQoJ2NyeXB0b3dvcmtlclVSTCcsICcnKSAgICAgICAgICAgLy8gcG9pbnQgdG8gY3J5cHRvd29ya2VyLmpzIHRvIGVuYWJsZSB3b3JrZXIgdGhyZWFkXG4gICAgc2V0RGVmYXVsdCgnZXBoZW1lcmFsS2V5Y2hhaW4nLCBmYWxzZSkgICAgICAvLyBwcmV2ZW50cyBrZXljaGFpbiBmcm9tIGJlaW5nIHNhdmVkIHRvIGxvY2FsU3RvcmFnZVxuICAgIHNldERlZmF1bHQoJ2luaXRMb2FkQmF0Y2hTaXplJywgMjApXG4gICAgc2V0RGVmYXVsdCgnaW5NZW1vcnlTaGVsbExpbWl0JywgMTAwMDApICAgICAvLyBzaGVsbHMgYXJlIHJlbW92ZWQgdG8gY29tcGVuc2F0ZVxuICAgIHNldERlZmF1bHQoJ2dsb2JhbEJpZ0JhdGNoTGltaXQnLCAyMDAwKSAgICAgLy8gbWF4aW11bSBudW1iZXIgb2Ygc2hlbGxzIHRvIHJlY2VpdmUgYXQgb25jZSAvLyBUT0RPOiBhbGlnbiB3aXRoIEFQSVxuICAgIHNldERlZmF1bHQoJ2luTWVtb3J5TWVtb3J5TGltaXQnLCAzMDBFNikgICAgLy8gfjMwME1CXG4gICAgc2V0RGVmYXVsdCgnYW5vblByaXZhdGVBZG1pbktleScsICc1S2RWalF3amhNY2hyWnVkRlZmZVJpaVBNZHJONnJjNENvdU5oN0tQWm1oOGlIRWlXTXgnKSAvLyBVc2VkIHRvIHJlZ2lzdGVyIGFub24uIHVzZXJzXG4gICAgc2V0RGVmYXVsdCgnZGlzYWJsZVNlbmRUb1NlcnZlcicsIGZhbHNlKSAgICAvLyBzbyB5b3UgY2FuIHdvcmsgbG9jYWxseVxuICAgIHNldERlZmF1bHQoJ2Rpc2FibGVSZWNlaXZlUHVibGljJywgZmFsc2UpICAgLy8gbm8gcHVibGljIHB1ZmZzIGV4Y2VwdCBwcm9maWxlc1xuICAgIHNldERlZmF1bHQoJ2Rpc2FibGVDbG91ZElkZW50aXR5JywgZmFsc2UpICAgLy8gZG9uJ3Qgc3RvcmUgZW5jcnlwdGVkIGlkZW50aXR5IGluIHRoZSBjbG91ZFxuICAgIHNldERlZmF1bHQoJ3N1cHBvcnRlZENvbnRlbnRUeXBlcycsIGZhbHNlKSAgLy8gd2hpdGVsaXN0IG9mIGNvbnRleHQgdHlwZXM7IGZhbHNlIGxvYWRzIGFsbFxuICAgIHNldERlZmF1bHQoJ3NoZWxsQ29udGVudFRocmVzaG9sZCcsIDEwMDApICAgLy8gc2l6ZSBvZiB1bmNvbXBhY3RlZCBjb250ZW50XG4gICAgc2V0RGVmYXVsdCgnbG9jYWxTdG9yYWdlU2hlbGxMaW1pdCcsIDEwMDApICAvLyBtYXhpbXVtIG51bWJlciBvZiBzaGVsbHNcbiAgICBzZXREZWZhdWx0KCdsb2NhbFN0b3JhZ2VNZW1vcnlMaW1pdCcsIDNFNikgIC8vIH4zTUJcbiAgICBcbiAgICBmdW5jdGlvbiBzZXREZWZhdWx0KGtleSwgdmFsKSB7XG4gICAgICAgIFBCLkNPTkZJR1trZXldID0gb3B0aW9uc1trZXldIHx8IFBCLkNPTkZJR1trZXldIHx8IHZhbFxuICAgIH1cbiAgICBcbiAgICAvLyBFTkQgQ09ORklHIEFORCBPUFRJT05TIC8vXG4gICAgICAgIFxuICAgIFBCLlVzZXJzLmluaXQob3B0aW9ucykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSB1c2VyIHJlY29yZCBzdWJzeXN0ZW1cbiAgICBQQi5EYXRhLmluaXQob3B0aW9ucykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgZGF0YSBzdWJzeXN0ZW1cbiAgICBQQi5OZXQuaW5pdChvcHRpb25zKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgbmV0d29yayBzdWJzeXN0ZW1cbiAgICBcbiAgICB2YXIgbW9kdWxlS2V5cyA9IE9iamVjdC5rZXlzKFBCLk0pXG4gICAgbW9kdWxlS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkgeyAgICAgICAgICAgICAgICAgIC8vIGNhbGwgYWxsIG1vZHVsZSBpbml0aWFsaXplcnNcbiAgICAgICAgaWYoUEIuTVtrZXldLmluaXQpIFxuICAgICAgICAgICAgUEIuTVtrZXldLmluaXQob3B0aW9ucylcbiAgICB9KVxuICAgIFxuICAgIHBvcE1vZHMoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZsYXRlIGFueSBtYWNoaW5lIHByZWZzXG4gICAgZnVuY3Rpb24gcG9wTW9kcygpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRISU5LOiBtYXliZSBtb3ZlIHRoaXMgdG8gUEIuUGVyc2lzdC5pbml0XG4gICAgICAgIHZhciBtb2RzID0gUEIuUGVyc2lzdC5nZXQoJ0NPTkZJRycpXG4gICAgICAgIGlmKCFtb2RzKSByZXR1cm4gZmFsc2VcbiAgICBcbiAgICAgICAgUEIuQ09ORklHLm1vZHMgPSBtb2RzXG4gICAgICAgIE9iamVjdC5rZXlzKFBCLkNPTkZJRy5tb2RzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkgeyBQQi5DT05GSUdba2V5XSA9IG1vZHNba2V5XSB9KVxuICAgIH1cbiAgICBcbiAgICBQQi5idWlsZENyeXB0b3dvcmtlcihvcHRpb25zKVxufVxuXG5cblBCLmdldFB1ZmZCeVNpZyA9IGZ1bmN0aW9uKHNpZykge1xuICAgIC8vLy8gZ2V0IGEgcGFydGljdWxhciBwdWZmXG4gICAgdmFyIHNoZWxsID0gUEIuRGF0YS5nZXRDYWNoZWRTaGVsbEJ5U2lnKHNpZykgICAgICAgIC8vIGNoZWNrIGluIHJlZ3VsYXIgY2FjaGVcbiAgICBcbiAgICBpZighc2hlbGwpXG4gICAgICAgIHNoZWxsID0gUEIuRGF0YS5nZXREZWNyeXB0ZWRMZXR0ZXJCeVNpZyhzaWcpICAgIC8vIGNoZWNrIGluIHByaXZhdGUgY2FjaGVcbiAgICBcbiAgICBpZihzaGVsbClcbiAgICAgICAgcmV0dXJuIFBCLkRhdGEuZ2V0UHVmZkZyb21TaGVsbChzaGVsbCkgICAgICAgICAgLy8gZ2V0IGEgcHVmZiBmcm9tIHRoZSBzaGVsbFxuICAgICAgICBcbiAgICByZXR1cm4gUEIuRGF0YS5nZXRQdWZmQnlTaWcoc2lnKSAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBwdWZmXG59XG5cblBCLnBvc3RQdWJsaWNNZXNzYWdlID0gZnVuY3Rpb24oY29udGVudCwgdHlwZSkge1xuICAgIC8vLy8gcG9zdCBhIHB1YmxpYyBwdWZmLiB0eXBlIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAndGV4dCdcbiAgICB0eXBlID0gdHlwZSB8fCAndGV4dCdcbiAgICBcbiAgICB2YXIgbXlVc2VybmFtZSA9IFBCLmdldEN1cnJlbnRVc2VybmFtZSgpXG4gICAgaWYoIW15VXNlcm5hbWUpXG4gICAgICAgIHJldHVybiBQQi5lbXB0eVByb21pc2UoJ1lvdSBtdXN0IGhhdmUgYSBjdXJyZW50IGlkZW50aXR5IHRvIHBvc3QgYSBwdWJsaWMgbWVzc2FnZScpXG4gICAgXG4gICAgdmFyIHB1ZmYgPSBQQi5zaW1wbGVCdWlsZFB1ZmYodHlwZSwgY29udGVudClcbiAgICByZXR1cm4gUEIuYWRkUHVmZlRvU3lzdGVtKHB1ZmYpXG59XG5cblBCLnBvc3RQcml2YXRlTWVzc2FnZSA9IGZ1bmN0aW9uKGNvbnRlbnQsIHVzZXJuYW1lcywgdHlwZSkge1xuICAgIC8vLy8gcG9zdCBhbiBlbmNyeXB0ZWQgcHVmZi4gdHlwZSBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gJ3RleHQnLiB1c2VybmFtZXMgaXMgYW4gYXJyYXkgb2YgdXNlcm5hbWVzLlxuICAgIHR5cGUgPSB0eXBlIHx8ICd0ZXh0J1xuXG4gICAgdXNlcm5hbWVzID0gdXNlcm5hbWVzIHx8IFtdXG4gICAgaWYoIUFycmF5LmlzQXJyYXkodXNlcm5hbWVzKSlcbiAgICAgICAgdXNlcm5hbWVzID0gW3VzZXJuYW1lc11cbiAgICBcbiAgICB2YXIgbXlVc2VybmFtZSA9IFBCLmdldEN1cnJlbnRVc2VybmFtZSgpXG4gICAgaWYoIW15VXNlcm5hbWUpXG4gICAgICAgIHJldHVybiBQQi5lbXB0eVByb21pc2UoJ1lvdSBtdXN0IGhhdmUgYSBjdXJyZW50IGlkZW50aXR5IHRvIHBvc3QgYSBwcml2YXRlIG1lc3NhZ2UnKVxuICAgIFxuICAgIHVzZXJuYW1lcy5wdXNoKG15VXNlcm5hbWUpXG4gICAgdXNlcm5hbWVzID0gUEIudW5pcXVpZnkodXNlcm5hbWVzKVxuICAgIHZhciBwcm9tID0gUEIuVXNlcnMudXNlcm5hbWVzVG9Vc2VyUmVjb3Jkc1Byb21pc2UodXNlcm5hbWVzKVxuICAgIFxuICAgIHJldHVybiBwcm9tLnRoZW4oZnVuY3Rpb24odXNlclJlY29yZHMpIHsgICAgICAgIFxuICAgICAgICB2YXIgcHVmZiA9IFBCLnNpbXBsZUJ1aWxkUHVmZih0eXBlLCBjb250ZW50LCBudWxsLCB1c2VybmFtZXMsIHVzZXJSZWNvcmRzKVxuICAgICAgICByZXR1cm4gUEIuYWRkUHVmZlRvU3lzdGVtKHB1ZmYpXG4gICAgfSlcbiAgICBcbiAgICByZXR1cm4gcHJvbVxufVxuXG5QQi5nZXRNeU1lc3NhZ2VzID0gdHJ1ZVxuXG5QQi5jcmVhdGVJZGVudGl0eSA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBwYXNzcGhyYXNlKSB7XG4gICAgLy8gVE9ETzogdmFsaWRhdGlvbnMgYW5kIGVycm9yIGhhbmRsaW5nIChsb3RzIG9mIGl0KVxuICAgIFxuICAgIHZhciBwcmVwZW5kZWRQYXNzcGhyYXNlID0gdXNlcm5hbWUgKyBwYXNzcGhyYXNlXG4gICAgICAgIHZhciBwcml2YXRlS2V5ID0gUEIuQ3J5cHRvLnBhc3NwaHJhc2VUb1ByaXZhdGVLZXlXaWYocHJlcGVuZGVkUGFzc3BocmFzZSlcbiAgICBcbiAgICB2YXIgcHJvbSA9IFBCLnJlZ2lzdGVyVG9wTGV2ZWxVc2VyKHVzZXJuYW1lLCBwcml2YXRlS2V5LCBwcml2YXRlS2V5LCBwcml2YXRlS2V5KVxuICAgIFxuICAgIHByb20udGhlbihmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgICAgIHZhciBjYXBhID0gMSAvLyBUSElOSzogZG9lcyBjYXBhIGFsd2F5cyBzdGFydCBhdCAxPyB3aGVyZSBzaG91bGQgdGhhdCBrbm93bGVkZ2UgbGl2ZT9cbiAgICAgICAgUEIuYWRkQWxpYXModXNlcm5hbWUsIHVzZXJuYW1lLCBjYXBhLCBwcml2YXRlS2V5LCBwcml2YXRlS2V5LCBwcml2YXRlS2V5LCB7cGFzc3BocmFzZTogcGFzc3BocmFzZX0pXG4gICAgICAgIFBCLnN3aXRjaElkZW50aXR5VG8odXNlcm5hbWUpXG4gICAgfSlcbiAgICBcbiAgICAvLyBUT0RPOiBvbiBzd2l0Y2hJZGVudGl0eVRvIGZhbHNlIGNoYW5nZSB1bmRlZmluZWQgdG8gJydcbiAgICBcbiAgICByZXR1cm4gcHJvbVxufVxuXG5QQi5yZWdpc3RlclRvcExldmVsVXNlciA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBwcml2YXRlUm9vdEtleSwgcHJpdmF0ZUFkbWluS2V5LCBwcml2YXRlRGVmYXVsdEtleSkge1xuICAgIC8vLy8gY3JlYXRlIGEgYnJhbmQgbmV3IHRvcC1sZXZlbCB1c2VyXG5cbiAgICAvLyBPUFQ6IHByaXZhdGVUb1B1YmxpYyBpcyBleHBlbnNpdmUgLS0gd2UgY291bGQgcmVkdWNlIHRoZSBudW1iZXIgb2YgY2FsbHMgaWYgdGhlIHByaXZhdGUga2V5cyBhcmUgaWRlbnRpY2FsXG4gICAgdmFyIHJvb3RLZXlQdWJsaWMgICAgPSBQQi5DcnlwdG8ucHJpdmF0ZVRvUHVibGljKHByaXZhdGVSb290S2V5KVxuICAgIHZhciBhZG1pbktleVB1YmxpYyAgID0gUEIuQ3J5cHRvLnByaXZhdGVUb1B1YmxpYyhwcml2YXRlQWRtaW5LZXkpXG4gICAgdmFyIGRlZmF1bHRLZXlQdWJsaWMgPSBQQi5DcnlwdG8ucHJpdmF0ZVRvUHVibGljKHByaXZhdGVEZWZhdWx0S2V5KVxuXG4gICAgdmFyIHBheWxvYWQgPSB7IHJlcXVlc3RlZFVzZXJuYW1lOiB1c2VybmFtZVxuICAgICAgICAgICAgICAgICAgLCAgICAgICAgICAgcm9vdEtleTogcm9vdEtleVB1YmxpY1xuICAgICAgICAgICAgICAgICAgLCAgICAgICAgICBhZG1pbktleTogYWRtaW5LZXlQdWJsaWNcbiAgICAgICAgICAgICAgICAgICwgICAgICAgIGRlZmF1bHRLZXk6IGRlZmF1bHRLZXlQdWJsaWNcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgIHZhciByb3V0ZXMgID0gW11cbiAgICB2YXIgY29udGVudCA9ICdyZXF1ZXN0VXNlcm5hbWUnXG4gICAgdmFyIHR5cGUgICAgPSAndXBkYXRlVXNlclJlY29yZCdcblxuICAgIHZhciBwdWZmID0gUEIuYnVpbGRQdWZmKHVzZXJuYW1lLCBwcml2YXRlQWRtaW5LZXksIHJvdXRlcywgdHlwZSwgY29udGVudCwgcGF5bG9hZClcbiAgICBcbiAgICB2YXIgcHJvbSA9IFBCLk5ldC51cGRhdGVVc2VyUmVjb3JkKHB1ZmYpXG4gICAgXG4gICAgcmV0dXJuIHByb21cbn1cblxuLyoqXG4gKiByZWdpc3RlciBhIHN1YnVzZXIgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGlkZW50aXR5XG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5ld1VzZXJuYW1lICAgICBkZXNpcmVkIG5ldyBzdWJ1c2VyIG5hbWVcbiAqIEBwYXJhbSAge3N0cmluZ30gcm9vdEtleSAgICAgICAgIHB1YmxpYyByb290IGtleSBmb3IgdGhlIG5ldyBzdWJ1c2VyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGFkbWluS2V5ICAgICAgICBwdWJsaWMgYWRtaW4ga2V5IGZvciB0aGUgbmV3IHN1YnVzZXJcbiAqIEBwYXJhbSAge3N0cmluZ30gZGVmYXVsdEtleSAgICAgIHB1YmxpYyBkZWZhdWx0IGtleSBmb3IgdGhlIG5ldyBzdWJ1c2VyXG4gKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICAgIHVzZXIgcmVjb3JkIGZvciB0aGUgbmV3bHkgY3JlYXRlZCBzdWJ1c2VyXG4gKi9cblBCLnJlZ2lzdGVyU3VidXNlciA9IGZ1bmN0aW9uKG5ld1VzZXJuYW1lLCByb290S2V5LCBhZG1pbktleSwgZGVmYXVsdEtleSkge1xuICAgIC8vLy8gcmVnaXN0ZXJzIGEgc3VidXNlciBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgaWRlbnRpdHlcbiAgICBcbiAgICB2YXIgc2lnbmluZ1VzZXJuYW1lID0gUEIuZ2V0Q3VycmVudFVzZXJuYW1lKClcbiAgICB2YXIgcHJvbVxuICAgIFxuICAgIFBCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oXywgXywgXywgcHJpdmF0ZUFkbWluS2V5LCBfKSB7XG4gICAgICAgIHByb20gPSBQQi5yZWdpc3RlclN1YnVzZXJGb3JVc2VyKHNpZ25pbmdVc2VybmFtZSwgcHJpdmF0ZUFkbWluS2V5LCBuZXdVc2VybmFtZSwgcm9vdEtleSwgYWRtaW5LZXksIGRlZmF1bHRLZXkpXG4gICAgfSlcbiAgICBcbiAgICByZXR1cm4gcHJvbVxufVxuXG5cblBCLnVwZGF0ZVByaXZhdGVLZXkgPSBmdW5jdGlvbihrZXlUb01vZGlmeSwgbmV3UHJpdmF0ZUtleSwgc2VjcmV0cykge1xuICAgIC8vLy8gYXR0ZW1wdHMgdG8gdXBkYXRlIGEgcHJpdmF0ZSBrZXkgZm9yIHRoZSBjdXJyZW50IHVzZXIuIFxuICAgIC8vLy8gaWYgc3VjY2Vzc2Z1bCBpdCBhZGRzIHRoZSBuZXcgYWxpYXMgdG8gdGhlIGN1cnJlbnQgaWRlbnRpdHkuXG4gICAgLy8vLyByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIG5ldyB1c2VyUmVjb3JkLlxuICAgIFxuICAgIHZhciB1c2VybmFtZSA9IFBCLmdldEN1cnJlbnRVc2VybmFtZSgpXG4gICAgdmFyIG5ld1B1YmxpY0tleSA9IFBCLkNyeXB0by5wcml2YXRlVG9QdWJsaWMobmV3UHJpdmF0ZUtleSlcblxuICAgIGlmKFsnZGVmYXVsdEtleScsICdhZG1pbktleScsICdyb290S2V5J10uaW5kZXhPZihrZXlUb01vZGlmeSkgPT0gLTEpXG4gICAgICAgIHJldHVybiBQQi5lbXB0eVByb21pc2UoJ1RoYXQgaXMgbm90IGEgdmFsaWQga2V5IHRvIG1vZGlmeScpXG5cbiAgICB2YXIgcGF5bG9hZCA9IHt9XG4gICAgdmFyIHJvdXRlcyAgPSBbXVxuICAgIHZhciBjb250ZW50ID0gJ21vZGlmeVVzZXJLZXknXG4gICAgdmFyIHR5cGUgICAgPSAndXBkYXRlVXNlclJlY29yZCdcblxuICAgIHBheWxvYWQua2V5VG9Nb2RpZnkgPSBrZXlUb01vZGlmeVxuICAgIHBheWxvYWQubmV3S2V5ID0gbmV3UHVibGljS2V5XG4gICAgcGF5bG9hZC50aW1lID0gRGF0ZS5ub3coKVxuXG4gICAgdmFyIHByb20gPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHB1ZmZcblxuICAgICAgICBQQi51c2VTZWN1cmVJbmZvKGZ1bmN0aW9uKF8sIF8sIHByaXZhdGVSb290S2V5LCBwcml2YXRlQWRtaW5LZXksIHByaXZhdGVEZWZhdWx0S2V5KSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBwdWZmIGxlYWtzLCBidXQgb25seSBjb250YWlucyBwdWJsaWNseSBhY2Nlc3NpYmxlIGRhdGFcbiAgICAgICAgXG4gICAgICAgICAgICB2YXIgc2lnbmluZ1VzZXJLZXkgPSAncHJpdmF0ZVJvb3RLZXknICAvLyBjaGFuZ2luZyBhZG1pbiBvciByb290IGtleXMgcmVxdWlyZXMgcm9vdCBwcml2aWxlZ2VzXG4gICAgICAgICAgICB2YXIgcHJpdmF0ZUtleSA9IHByaXZhdGVSb290S2V5XG5cbiAgICAgICAgICAgIGlmIChrZXlUb01vZGlmeSA9PSAnZGVmYXVsdEtleScpIHsgXG4gICAgICAgICAgICAgICAgc2lnbmluZ1VzZXJLZXkgPSAncHJpdmF0ZUFkbWluS2V5JyAvLyBjaGFuZ2luZyB0aGUgZGVmYXVsdCBrZXkgb25seSByZXF1aXJlcyBhZG1pbiBwcml2aWxlZ2VzXG4gICAgICAgICAgICAgICAgcHJpdmF0ZUtleSA9IHByaXZhdGVBZG1pbktleVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighcHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoUEIubWFrZUVycm9yKFwiWW91IG5lZWQgdGhlIFwiICsgc2lnbmluZ1VzZXJLZXkgKyBcIiB0byBjaGFuZ2UgdGhlIFwiICsga2V5VG9Nb2RpZnkgKyBcIiBrZXkuXCIpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdWZmID0gUEIuYnVpbGRQdWZmKHVzZXJuYW1lLCBwcml2YXRlS2V5LCByb3V0ZXMsIHR5cGUsIGNvbnRlbnQsIHBheWxvYWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgdmFyIHVzZXJSZWNvcmRQcm9taXNlID0gUEIuTmV0LnVwZGF0ZVVzZXJSZWNvcmQocHVmZilcblxuICAgICAgICB1c2VyUmVjb3JkUHJvbWlzZS50aGVuKGZ1bmN0aW9uKHVzZXJSZWNvcmQpIHtcbiAgICAgICAgICAgIGlmKGtleVRvTW9kaWZ5ID09ICdkZWZhdWx0S2V5Jykge1xuICAgICAgICAgICAgICAgIFBCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oXywgdXNlcm5hbWUsIHByaXZhdGVSb290S2V5LCBwcml2YXRlQWRtaW5LZXksIF8pIHtcbiAgICAgICAgICAgICAgICAgICAgUEIuYWRkQWxpYXModXNlcm5hbWUsIHVzZXJuYW1lLCB1c2VyUmVjb3JkLmNhcGEsIHByaXZhdGVSb290S2V5LCBwcml2YXRlQWRtaW5LZXksIG5ld1ByaXZhdGVLZXksIHNlY3JldHMpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoa2V5VG9Nb2RpZnkgPT0gJ2FkbWluS2V5Jykge1xuICAgICAgICAgICAgICAgIFBCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oXywgdXNlcm5hbWUsIHByaXZhdGVSb290S2V5LCBfLCBwcml2YXRlRGVmYXVsdEtleSkge1xuICAgICAgICAgICAgICAgICAgICBQQi5hZGRBbGlhcyh1c2VybmFtZSwgdXNlcm5hbWUsIHVzZXJSZWNvcmQuY2FwYSwgcHJpdmF0ZVJvb3RLZXksIG5ld1ByaXZhdGVLZXksIHByaXZhdGVEZWZhdWx0S2V5LCBzZWNyZXRzKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGtleVRvTW9kaWZ5ID09ICdyb290S2V5Jykge1xuICAgICAgICAgICAgICAgIFBCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oXywgdXNlcm5hbWUsIF8sIHByaXZhdGVBZG1pbktleSwgcHJpdmF0ZURlZmF1bHRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgUEIuYWRkQWxpYXModXNlcm5hbWUsIHVzZXJuYW1lLCB1c2VyUmVjb3JkLmNhcGEsIG5ld1ByaXZhdGVLZXksIHByaXZhdGVBZG1pbktleSwgIHByaXZhdGVEZWZhdWx0S2V5LCBzZWNyZXRzKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHVzZXJSZWNvcmQpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoUEIubWFrZUVycm9yKGVycikpXG4gICAgICAgIH0pXG4gICAgfSlcblxuICAgIHJldHVybiBwcm9tXG59XG5cblBCLmdldFByb2ZpbGVQdWZmID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICB2YXIgY2FjaGVkX3Byb2ZpbGUgPSBQQi5EYXRhLnByb2ZpbGVzW3VzZXJuYW1lXVxuICAgIFxuICAgIGlmKGNhY2hlZF9wcm9maWxlKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZF9wcm9maWxlKVxuXG4gICAgdmFyIHByb20gPSBQQi5OZXQuZ2V0UHJvZmlsZVB1ZmYodXNlcm5hbWUpXG5cbiAgICBwcm9tID0gcHJvbS50aGVuKGZ1bmN0aW9uKHB1ZmZzKSB7XG4gICAgICAgIHZhciBwdWZmID0gcHVmZnNbMF1cbiAgICBcbiAgICAgICAgLy8gTk9URTogU2V0dGluZyB0aGlzIHByZXZlbnRzIHVzIGZyb20gcmUtdHJ5aW5nIHRvIGNvbGxlY3QgcHJvZmlsZXMgZnJvbSB1c2VycyB3aG8gZG9uJ3QgaGF2ZSB0aGVtLlxuICAgICAgICAvLyAgICAgICBUaGlzIGlzIGdvb2QsIGJlY2F1c2UgaXQgcHJldmVudHMgbmV0d29yayBub2lzZSwgYnV0IHJlcXVpcmVzIGEgcmVmcmVzaCB0byBzZWUgbmV3IHByb2ZpbGUgaW5mby5cbiAgICAgICAgaWYoIXB1ZmYpXG4gICAgICAgICAgICBwdWZmID0ge3BheWxvYWQ6e319IC8vIFRPRE86IGdldCBhIHByb3BlciBlbXB0eSBwdWZmIGZyb20gc29tZXdoZXJlXG4gICAgICAgIFxuICAgICAgICBQQi5EYXRhLnByb2ZpbGVzW1BCLlVzZXJzLmp1c3RVc2VybmFtZShwdWZmLnVzZXJuYW1lIHx8IHVzZXJuYW1lKV0gPSBwdWZmXG4gICAgXG4gICAgICAgIHJldHVybiBwdWZmXG4gICAgfSlcblxuICAgIHJldHVybiBwcm9tXG59XG5cblxuLy8vLy8vLy8vLy8vLy8gRU5EIFNUQU5EQVJEIEFQSSAvLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4vLy8vLy8vLy8vLy8vLyBIYW5kbGVyIEhhbmRsZXJzIC8vLy8vLy8vLy8vLy8vLy8vL1xuXG5QQi5oYW5kbGVycyA9IHt9XG5cblBCLmFkZEhhbmRsZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaykge1xuICBpZighUEIuaGFuZGxlcnNbdHlwZV0pIFBCLmhhbmRsZXJzW3R5cGVdID0gW11cbiAgUEIuaGFuZGxlcnNbdHlwZV0ucHVzaChjYWxsYmFjaylcbn1cblxuUEIucnVuSGFuZGxlcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gIHJldHVybiAoUEIuaGFuZGxlcnNbdHlwZV0gfHwgW10pLnJlZHVjZShcbiAgICAgIGZ1bmN0aW9uKGFjYywgY2FsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYWNjID09IG51bGwgPyBhcmdzIDogQXJyYXkuaXNBcnJheShhY2MpID8gYWNjIDogW2FjY10pfSwgYXJncylcbn1cblxuUEIubWFrZUhhbmRsZXJIYW5kbGVyID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge3JldHVybiBQQi5hZGRIYW5kbGVyKHR5cGUsIGNhbGxiYWNrKX1cbn1cblxuLy8gVVNFRlVMIEhBTkRMRVJTOlxuXG5QQi5hZGRFcnJvckhhbmRsZXIgICAgICAgICAgID0gUEIubWFrZUhhbmRsZXJIYW5kbGVyKCdlcnJvcicpICAgICAgICAgICAvLyByZWNlaXZlcyBhbGwgZXJyb3IgbWVzc2FnZXNcblxuUEIuYWRkTmV3UHVmZkhhbmRsZXIgICAgICAgICA9IFBCLm1ha2VIYW5kbGVySGFuZGxlcignbmV3UHVmZnMnKSAgICAgICAgLy8gY2FsbGVkIHdoZW4gbmV3IHB1ZmZzIGFyZSBhdmFpbGFibGVcblxuUEIuYWRkREhURXJyb3JIYW5kbGVyICAgICAgICA9IFBCLm1ha2VIYW5kbGVySGFuZGxlcignREhURXJyb3InKSAgICAgICAgLy8gcmVjZWl2ZXMgREhUIGVycm9yIG1lc3NhZ2VzXG5cblBCLmFkZFJlbGF0aW9uc2hpcEhhbmRsZXIgICAgPSBQQi5tYWtlSGFuZGxlckhhbmRsZXIoJ3JlbGF0aW9uc2hpcCcpICAgIC8vIG1hbmFnZSByZWxhdGlvbnNoaXBzIGJldHdlZW4gcHVmZnNcblxuUEIuYWRkVGltZW91dEVycm9ySGFuZGxlciAgICA9IFBCLm1ha2VIYW5kbGVySGFuZGxlcigndGltZW91dEVycm9yJykgICAgLy8gcmVjZWl2ZXMgdGltZW91dCBlcnJvciBtZXNzYWdlc1xuXG5QQi5hZGROZXR3b3JrRXJyb3JIYW5kbGVyICAgID0gUEIubWFrZUhhbmRsZXJIYW5kbGVyKCduZXR3b3JrRXJyb3InKSAgICAvLyByZWNlaXZlcyBuZXR3b3JrIGVycm9yIG1lc3NhZ2VzXG5cblBCLmFkZE5ld1B1ZmZSZXBvcnRIYW5kbGVyICAgPSBQQi5tYWtlSGFuZGxlckhhbmRsZXIoJ25ld1B1ZmZSZXBvcnQnKSAgIC8vIGhhbmRsZXMgcmVwb3J0cyBvbiBpbmNvbWluZyBwdWZmc1xuXG5QQi5hZGRJZGVudGl0eVVwZGF0ZUhhbmRsZXIgID0gUEIubWFrZUhhbmRsZXJIYW5kbGVyKCdpZGVudGl0eVVwZGF0ZScpICAvLyBnZW5lcmFsIEdVSSB1cGRhdGUgdHJpZ2dlclxuXG5QQi5hZGROZXR3b3JrUmVzcG9uc2VIYW5kbGVyID0gUEIubWFrZUhhbmRsZXJIYW5kbGVyKCduZXR3b3JrcmVzcG9uc2UnKSAvLyByZWNlaXZlcyBhbGwgbmV0d29yayByZXNwb25zZVxuXG5QQi5hZGRQYXlsb2FkTW9kaWZpZXJIYW5kbGVyID0gUEIubWFrZUhhbmRsZXJIYW5kbGVyKCdwYXlsb2FkTW9kaWZpZXInKSAvLyBkZWNvcmF0ZSBwdWZmIHBheWxvYWRzIFxuXG4vLyBQQi5hZGRDbGVhclB1ZmZDYWNoZUhhbmRsZXIgPSBQQi5tYWtlSGFuZGxlckhhbmRsZXIoJ2NsZWFycHVmZmNhY2hlJylcblxuLy8gYmVmb3JlU3dpdGNoSWRlbnRpdHkgaXMgY2FsbGVkIHByaW9yIHRvIHN3aXRjaElkZW50aXR5IGFuZCByZW1vdmVJZGVudGl0eSwgd2hpbGUgdGhlIG9sZCBpZGVudGl0eSBpcyBhY3RpdmVcbi8vIGFmdGVyU3dpdGNoSWRlbnRpdHkgaXMgY2FsbGVkIGFmdGVyIHN3aXRjaElkZW50aXR5LCBvbmNlIHRoZSBuZXcgaWRlbnRpdHkgaXMgYWN0aXZlXG5QQi5hZGRCZWZvcmVTd2l0Y2hJZGVudGl0eUhhbmRsZXIgPSBQQi5tYWtlSGFuZGxlckhhbmRsZXIoJ2JlZm9yZVN3aXRjaElkZW50aXR5JylcblBCLmFkZEFmdGVyU3dpdGNoSWRlbnRpdHlIYW5kbGVyICA9IFBCLm1ha2VIYW5kbGVySGFuZGxlcignYWZ0ZXJTd2l0Y2hJZGVudGl0eScpXG5cbi8vLy8vLy8vLy8vLy8vIEVuZCBIYW5kbGVyIEhhbmRsZXJzIC8vLy8vLy8vLy8vLy8vXG5cblxuXG5cbi8vLy8gUFVGRiBIRUxQRVJTIC8vLy9cblxuXG5QQi5zaW1wbGVCdWlsZFB1ZmYgPSBmdW5jdGlvbih0eXBlLCBjb250ZW50LCBwYXlsb2FkLCByb3V0ZXMsIHVzZXJSZWNvcmRzRm9yV2hvbVRvRW5jcnlwdCwgcHJpdmF0ZUVudmVsb3BlQWxpYXMpIHtcbiAgICAvLy8vIGJ1aWxkIGEgcHVmZiBmb3IgdGhlICdjdXJyZW50IHVzZXInLCBhcyBkZXRlcm1pbmVkIGJ5IHRoZSBrZXkgbWFuYWdlciAoYnkgZGVmYXVsdCBQQi5NLldhcmRyb2JlKVxuICAgIHZhciBwdWZmIFxuXG4gICAgcGF5bG9hZCA9IFBCLnJ1bkhhbmRsZXJzKCdwYXlsb2FkTW9kaWZpZXInLCBwYXlsb2FkKVxuXG4gICAgUEIudXNlU2VjdXJlSW5mbyhmdW5jdGlvbihpZGVudGl0aWVzLCBjdXJyZW50VXNlcm5hbWUsIHByaXZhdGVSb290S2V5LCBwcml2YXRlQWRtaW5LZXksIHByaXZhdGVEZWZhdWx0S2V5KSB7XG4gICAgICAgIC8vIFRISU5LOiBzaG91bGQgd2UgY29uZmlybSB0aGF0IG91ciBsb2NhbCBjYXBhIG1hdGNoZXMgdGhlIERIVCdzIGxhdGVzdCBjYXBhIGZvciB0aGUgY3VycmVudCB1c2VyIGhlcmU/IGl0IHR1cm5zIHRoZSBvdXRwdXQgaW50byBhIHByb21pc2UuLi5cbiAgICAgICAgdmFyIHByZXZpb3VzID0gZmFsc2UgLy8gVE9ETzogZ2V0IHRoZSBzaWcgb2YgdGhpcyB1c2VyJ3MgbGF0ZXN0IHB1ZmZcbiAgICAgICAgdmFyIHZlcnNpb25lZFVzZXJuYW1lID0gUEIuZ2V0Q3VycmVudFZlcnNpb25lZFVzZXJuYW1lKClcbiAgICAgICAgXG4gICAgICAgIHB1ZmYgPSBQQi5idWlsZFB1ZmYodmVyc2lvbmVkVXNlcm5hbWUsIHByaXZhdGVEZWZhdWx0S2V5LCByb3V0ZXMsIHR5cGUsIGNvbnRlbnQsIHBheWxvYWQsIHByZXZpb3VzLCB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHQsIHByaXZhdGVFbnZlbG9wZUFsaWFzKVxuICAgIH0pXG4gICAgXG4gICAgcmV0dXJuIHB1ZmZcbn1cblxuXG4vKipcbiAqIGJ1aWxkIGEgbmV3IHB1ZmYgb2JqZWN0IGJhc2VkIG9uIHRoZSBwYXJhbWV0ZXJzICBcbiAqIGRvZXMgbm90IGhpdCB0aGUgbmV0d29yaywgaGVuY2UgZG9lcyBubyByZWFsIHZlcmlmaWNhdGlvbiB3aGF0c29ldmVyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVzZXJuYW1lICAgICAgICAgICAgICAgICAgICB1c2VyIHdobyBzaWduIHRoZSBwdWZmXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHByaXZhdGVLZXkgICAgICAgICAgICAgICAgICBwcml2YXRlIGRlZmF1bHQga2V5IGZvciB0aGUgdXNlclxuICogQHBhcmFtICB7c3RyaW5nfSByb3V0ZXMgICAgICAgICAgICAgICAgICAgICAgcm91dGVzIG9mIHRoZSBwdWZmXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGUgICAgICAgICAgICAgICAgICAgICAgICB0eXBlIG9mIHRoZSBwdWZmXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRlbnQgICAgICAgICAgICAgICAgICAgICBjb250ZW50IG9mIHRoZSBwdWZmXG4gKiBAcGFyYW0gIHtvYmplY3R9IHBheWxvYWQgICAgICAgICAgICAgICAgICAgICBvdGhlciBwYXlsb2FkIGluZm9ybWF0aW9uIGZvciB0aGUgcHVmZlxuICogQHBhcmFtICB7c3RyaW5nfSBwcmV2aW91cyAgICAgICAgICAgICAgICAgICAgbW9zdCByZWNlbnRseSBwdWJsaXNoZWQgY29udGVudCBieSB0aGUgdXNlclxuICogQHBhcmFtICB7b2JqZWN0fSB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHRcbiAqIEBwYXJhbSAge29iamVjdH0gcHJpdmF0ZUVudmVsb3BlQWxpYXNcbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBuZXcgcHVmZiBvYmplY3RcbiAqL1xuUEIuYnVpbGRQdWZmID0gZnVuY3Rpb24odmVyc2lvbmVkVXNlcm5hbWUsIHByaXZhdGVLZXksIHJvdXRlcywgdHlwZSwgY29udGVudCwgcGF5bG9hZCwgcHJldmlvdXMsIHVzZXJSZWNvcmRzRm9yV2hvbVRvRW5jcnlwdCwgcHJpdmF0ZUVudmVsb3BlQWxpYXMpIHtcbiAgICB2YXIgcHVmZiA9IFBCLkRhdGEucGFja2FnZVB1ZmZTdHJ1Y3R1cmUodmVyc2lvbmVkVXNlcm5hbWUsIHJvdXRlcywgdHlwZSwgY29udGVudCwgcGF5bG9hZCwgcHJldmlvdXMpXG5cbiAgICBwdWZmLnNpZyA9IFBCLkNyeXB0by5zaWduUHVmZihwdWZmLCBwcml2YXRlS2V5KVxuICAgIFxuICAgIGlmKHVzZXJSZWNvcmRzRm9yV2hvbVRvRW5jcnlwdCkge1xuICAgICAgICBwdWZmID0gUEIuRGF0YS5lbmNyeXB0UHVmZihwdWZmLCBwcml2YXRlS2V5LCB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHQsIHByaXZhdGVFbnZlbG9wZUFsaWFzKVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcHVmZlxufVxuXG5cbi8qKlxuICogaGFuZGxlIGEgbmV3bHkgY3JlYXRlZCBwdWZmOiBhZGQgdG8gb3VyIGxvY2FsIGNhY2hlIGFuZCBmaXJlIG5ldyBjb250ZW50IGNhbGxiYWNrc1xuICogQHBhcmFtIHtvYmplY3R9IHB1ZmZcbiAqL1xuUEIuYWRkUHVmZlRvU3lzdGVtID0gZnVuY3Rpb24ocHVmZikge1xuICAgIGlmKFBCLkRhdGEuZ2V0Q2FjaGVkU2hlbGxCeVNpZyhwdWZmLnNpZykpIHJldHVybiBmYWxzZVxuICAgIFxuICAgIFBCLkRhdGEuYWRkU2hlbGxzVGhlbk1ha2VBdmFpbGFibGUocHVmZilcblxuICAgIFBCLk5ldC5kaXN0cmlidXRlUHVmZihwdWZmKVxuICAgIFxuICAgIHJldHVybiBwdWZmXG59XG5cblxuUEIuZGVjcnlwdFB1ZmZGb3JSZWFscyA9IGZ1bmN0aW9uKGVudmVsb3BlLCB5b3VyUHVibGljV2lmLCBteVZlcnNpb25lZFVzZXJuYW1lLCBteVByaXZhdGVXaWYpIHtcbiAgICAvLy8vIGludGVyZmFjZSB3aXRoIFBCLkNyeXB0byBmb3IgZGVjcnlwdGluZyBhIG1lc3NhZ2VcbiAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBpbiBQQi5EYXRhLCBidXQgaXMgaW4gUEIgZm9yIGNyeXB0b3dvcmtlcidzIHNha2VcbiAgICBpZighZW52ZWxvcGUua2V5cykgcmV0dXJuIGZhbHNlXG4gICAgdmFyIGtleUZvck1lID0gZW52ZWxvcGUua2V5c1tteVZlcnNpb25lZFVzZXJuYW1lXVxuICAgIHZhciBwdWZma2V5ICA9IFBCLkNyeXB0by5kZWNyeXB0UHJpdmF0ZU1lc3NhZ2Uoa2V5Rm9yTWUsIHlvdXJQdWJsaWNXaWYsIG15UHJpdmF0ZVdpZilcbiAgICB2YXIgbGV0dGVyQ2lwaGVyID0gZW52ZWxvcGUucGF5bG9hZC5jb250ZW50XG4gICAgdmFyIGxldHRlclN0cmluZyA9IFBCLkNyeXB0by5kZWNyeXB0V2l0aEFFUyhsZXR0ZXJDaXBoZXIsIHB1ZmZrZXkpXG4gICAgdmFyIGJldHRlclN0cmluZyA9IFBCLnRyeURlY29kZVVSSUNvbXBvbmVudChlc2NhcGUobGV0dGVyU3RyaW5nKSkgICAvLyB0cnkgZGVjb2RpbmdcbiAgICByZXR1cm4gUEIucGFyc2VKU09OKGJldHRlclN0cmluZykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSBwYXJzaW5nXG59XG5cblxuXG4vLy8vIElEIEZJTEUgKExPR0lOICsgRk9STUFUKSAvLy8vXG5cblxuUEIubG9naW4gPSBmdW5jdGlvbih1c2VybmFtZSwgcHJpdmF0ZUtleSkge1xuICAgIC8vLy8gcHJpdmF0ZUtleSBpcyB0aGUga2V5IGZvciB5b3VyIGlkZW50aXR5IGZpbGVcbiAgICBcbiAgICAvLyBUT0RPOiBoYW5kbGUgb2ZmbGluZSBjYXNlLi4uXG4gICAgLy8gVE9ETzogZW5jcnlwdGVkIGxvY2FsU3RvcmFnZSBpZGVudGl0eSBmaWxlc1xuICAgIC8vIFRPRE86IGNhY2hlIGVuY3J5cHRlZCBwdWZmcyBpbiBsb2NhbFN0b3JhZ2VcbiAgICAvLyBUT0RPOiBncmFiIHRoZSB1c2VyIHJlY29yZCBmcm9tIFBCLmxvZ2luV2l0aFBhc3NwaHJhc2VcbiAgICBcbiAgICB1c2VycHJvbSA9IFBCLlVzZXJzLmdldFVzZXJSZWNvcmROb0NhY2hlKHVzZXJuYW1lKVxuICAgIFxuICAgIHJldHVybiB1c2VycHJvbS50aGVuKGZ1bmN0aW9uKHVzZXJSZWNvcmQpIHtcbiAgICAgICAgdmFyIGlkZW50aXR5U2lnID0gdXNlclJlY29yZC5pZGVudGl0eVxuICAgICAgICAgICAgXG4gICAgICAgIGlmKCFpZGVudGl0eVNpZykgXG4gICAgICAgICAgICByZXR1cm4gUEIub25FcnJvcignVGhhdCB1c2VyIHJlY29yZCBoYXMgbm8gaWRlbnRpdHknKVxuICAgICAgICBcbiAgICAgICAgcHVmZnByb20gPSBQQi5OZXQuZ2V0UHVmZkJ5U2lnKGlkZW50aXR5U2lnKVxuICAgIFxuICAgICAgICByZXR1cm4gcHVmZnByb20udGhlbihmdW5jdGlvbihwdWZmcykge1xuICAgICAgICAgICAgdmFyIGVudmVsb3BlID0gcHVmZnNbMF1cbiAgICAgICAgICAgIHZhciBzZW5kZXJQdWJsaWNLZXkgPSB1c2VyUmVjb3JkLmRlZmF1bHRLZXlcbiAgICAgICAgICAgIHZhciByZWNpcGllbnRVc2VybmFtZSA9IFBCLlVzZXJzLm1ha2VWZXJzaW9uZWQodXNlclJlY29yZC51c2VybmFtZSwgdXNlclJlY29yZC5jYXBhKVxuICAgICAgICAgICAgdmFyIHJlY2lwaWVudFByaXZhdGVLZXkgPSBwcml2YXRlS2V5XG5cbiAgICAgICAgICAgIHZhciBkZWNyeXB0cHJvbSA9IFBCLkRhdGEuZGVjcnlwdFB1ZmZBbG1vc3RGb3JSZWFscyhlbnZlbG9wZSwgc2VuZGVyUHVibGljS2V5LCByZWNpcGllbnRVc2VybmFtZSwgcmVjaXBpZW50UHJpdmF0ZUtleSlcblxuICAgICAgICAgICAgcmV0dXJuIGRlY3J5cHRwcm9tLnRoZW4oZnVuY3Rpb24obGV0dGVyKSB7XG4gICAgICAgICAgICAgICAgaWYobGV0dGVyICYmIGxldHRlci5wYXlsb2FkICYmIGxldHRlci5wYXlsb2FkLmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQQi5sb2dpbldpdGhJZGVudGl0eUZpbGUobGV0dGVyLnBheWxvYWQuY29udGVudClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pICAgICAgICBcbiAgICB9KVxufVxuXG5QQi5sb2dpbldpdGhJZGVudGl0eUZpbGUgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAvLy8vIHRha2VzIGEgY2Fub25pY2FsIGlkZW50aXR5IGZpbGUgb2JqZWN0LCBhZGRzIGl0IHRvIHRoZSB3YXJkcm9iZSwgYW5kIHNpZ25zIHlvdSBpblxuICAgIFxuICAgIHZhciB1c2VybmFtZSA9IG9iamVjdC51c2VybmFtZVxuICAgIHZhciBhbGlhc2VzICA9IG9iamVjdC5hbGlhc2VzXG4gICAgdmFyIHByZWZlcmVuY2VzID0gb2JqZWN0LnByZWZlcmVuY2VzXG4gICAgXG4gICAgaWYoIXVzZXJuYW1lIHx8ICFhbGlhc2VzIHx8ICFwcmVmZXJlbmNlcylcbiAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ1RoYXQgaXMgbm90IGEgdmFsaWQgaWRlbnRpdHkgb2JqZWN0JylcbiAgICBcbiAgICBQQi5jdXJyZW50SWRlbnRpdHlIYXNoID0gUEIuQ3J5cHRvLmNyZWF0ZU1lc3NhZ2VIYXNoKEpTT04uc3RyaW5naWZ5KG9iamVjdCkpXG4gICAgXG4gICAgUEIuYWRkSWRlbnRpdHkodXNlcm5hbWUsIGFsaWFzZXMsIHByZWZlcmVuY2VzKVxuICAgIFxuICAgIHJldHVybiBQQi5zd2l0Y2hJZGVudGl0eVRvKHVzZXJuYW1lKVxufVxuXG5QQi5sb2dpbldpdGhQYXNzcGhyYXNlID0gZnVuY3Rpb24odXNlcm5hbWUsIHBhc3NwaHJhc2UsIGxlZ2FjeSkge1xuICAgIC8vIEZpcnN0IGF0dGVtcHQgdG8gcHJlcGVuZCB1c2VybmFtZSB0byBwYXNzcGhyYXNlXG4gICAgLy8gSWYgZmFpbHMsIHRoZW4gdHJ5IGp1c3QgdXNpbmcgdGhlIHBhc3NwaHJhc2VcbiAgICB2YXIgcGFzcyA9IGxlZ2FjeSA/IHBhc3NwaHJhc2UgOiB1c2VybmFtZSArIHBhc3NwaHJhc2VcblxuICAgIHZhciBwcml2YXRlS2V5ID0gUEIuQ3J5cHRvLnBhc3NwaHJhc2VUb1ByaXZhdGVLZXlXaWYocGFzcylcbiAgICB2YXIgcHVibGljS2V5ID0gUEIuQ3J5cHRvLnByaXZhdGVUb1B1YmxpYyhwcml2YXRlS2V5KVxuXG4gICAgdmFyIHVzZXJwcm9tID0gUEIuVXNlcnMuZ2V0VXNlclJlY29yZE5vQ2FjaGUodXNlcm5hbWUpXG5cbiAgICByZXR1cm4gdXNlcnByb20udGhlbihmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgICAgIGlmKCAodXNlclJlY29yZC5kZWZhdWx0S2V5ICE9IHB1YmxpY0tleSkgXG4gICAgICAgICAmJiAodXNlclJlY29yZC5hZG1pbktleSAgICE9IHB1YmxpY0tleSkgXG4gICAgICAgICAmJiAodXNlclJlY29yZC5yb290S2V5ICAgICE9IHB1YmxpY0tleSkgKVxuICAgICAgICAgICAgcmV0dXJuIChsZWdhY3kpID8gZmFsc2UgOiBQQi5sb2dpbldpdGhQYXNzcGhyYXNlKHVzZXJuYW1lLCBwYXNzcGhyYXNlLCB0cnVlKVxuXG4gICAgICAgIHJldHVybiBQQi5sb2dpbih1c2VybmFtZSwgcHJpdmF0ZUtleSlcbiAgICB9KVxufVxuXG5cblBCLnN0b3JlSWRlbnRpdHlGaWxlSW5DbG91ZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmKCFQQi5jdXJyZW50SWRlbnRpdHlIYXNoKSB7XG4gICAgICAgIC8vIFRISU5LOiB1c2VyIGRpZCBub3QgbG9nIGluIHdpdGggaWRlbnRpdHkgZmlsZS4uLiBzbyB3aGF0IHNob3VsZCB3ZSBkbyBoZXJlP1xuICAgIH1cblxuICAgIC8vIGdldCBpZGVudGl0eSBmaWxlXG4gICAgdmFyIGNvbnRlbnQgPSBQQi5mb3JtYXRJZGVudGl0eUZpbGUoKVxuICAgIGlmKCFjb250ZW50KSByZXR1cm4gZmFsc2VcbiAgICBcbiAgICAvLyBjaGVjayBhZ2FpbnN0IGxhdGVzdFxuICAgIHZhciBuZXdJZGVudGl0eUhhc2ggPSBQQi5DcnlwdG8uY3JlYXRlTWVzc2FnZUhhc2goSlNPTi5zdHJpbmdpZnkoY29udGVudCkpXG4gICAgaWYoUEIuY3VycmVudElkZW50aXR5SGFzaCA9PSBuZXdJZGVudGl0eUhhc2gpIHJldHVybiBmYWxzZVxuICAgIFBCLmN1cnJlbnRJZGVudGl0eUhhc2ggPSBuZXdJZGVudGl0eUhhc2hcbiAgICBcbiAgICAvLyBwYWNrYWdlIGFzIGVuY3J5cHRlZCBwdWZmXG4gICAgdmFyIHBheWxvYWQgPSB7fVxuICAgIHZhciByb3V0ZXMgID0gW11cbiAgICB2YXIgdHlwZSAgICA9ICdpZGVudGl0eSdcbiAgICAgICAgXG4gICAgdmFyIHVzZXJSZWNvcmQgPSBQQi5nZXRDdXJyZW50VXNlclJlY29yZCgpXG4gICAgdmFyIHVzZXJSZWNvcmRzRm9yV2hvbVRvRW5jcnlwdCA9IFt1c2VyUmVjb3JkXVxuXG4gICAgaWYoIXVzZXJSZWNvcmQpIHJldHVybiBmYWxzZVxuXG4gICAgLy8gVEhJTks6IHVzaW5nIHNpbXBsZUJ1aWxkUHVmZiBwdXRzIGEgdGltZXN0YW1wIGluIHRoZSBpZGVudGl0eSBmaWxlLi4uXG4gICAgdmFyIHB1ZmYgPSBQQi5zaW1wbGVCdWlsZFB1ZmYodHlwZSwgY29udGVudCwgcGF5bG9hZCwgcm91dGVzLCB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHQpXG4gICAgXG4gICAgaWYoIXB1ZmYpIHJldHVybiBmYWxzZVxuICAgICAgICBcbiAgICAvLyBpZihwdWZmLnNpZyA9PSB1c2VyUmVjb3JkLmlkZW50aXR5KSByZXR1cm4gZmFsc2UgLy8gYWx3YXlzIGZhbHNlLCBiZWNhdXNlIG9mIHRoZSB0aW1lc3RhbXAgLS0gaWYgeW91IHJlbW92ZSBpdCwgYWRkIHRoaXMgYmFja1xuICAgIFxuICAgIFBCLk5ldC5kaXN0cmlidXRlUHVmZihwdWZmKSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZW5kIGl0IHRvIHRoZSBzZXJ2ZXJcbiAgICBcbiAgICAvLyB1cGRhdGUgdXNlciByZWNvcmRcbiAgICB2YXIgcGF5bG9hZCA9IHt9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogdGhlIGRvdWJsZSBcInZhclwicyBkb24ndCBodXJ0LCBhbmQgaGVscCBrZWVwIHVzIGZvY3VzZWRcbiAgICB2YXIgcm91dGVzICA9IFtdXG4gICAgdmFyIHR5cGUgICAgPSAndXBkYXRlVXNlclJlY29yZCdcbiAgICB2YXIgY29udGVudCA9ICdzZXRJZGVudGl0eSdcbiAgICB2YXIgdXBkYXRlX3B1ZmZcblxuICAgIHBheWxvYWQuaWRlbnRpdHkgPSBwdWZmLnNpZ1xuXG4gICAgUEIudXNlU2VjdXJlSW5mbyhmdW5jdGlvbihfLCBjdXJyZW50VXNlcm5hbWUsIF8sIHByaXZhdGVBZG1pbktleSwgXykge1xuICAgICAgICBpZighcHJpdmF0ZUFkbWluS2V5KVxuICAgICAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ1lvdSBtdXN0IGhhdmUgYW4gYWRtaW5pc3RyYXRpdmUga2V5IHRvIHVwbG9hZCB5b3VyIGlkZW50aXR5IGZpbGUnKVxuICAgICAgICBcbiAgICAgICAgdXBkYXRlX3B1ZmYgPSBQQi5idWlsZFB1ZmYoY3VycmVudFVzZXJuYW1lLCBwcml2YXRlQWRtaW5LZXksIHJvdXRlcywgdHlwZSwgY29udGVudCwgcGF5bG9hZClcbiAgICB9KVxuICAgIFxuICAgIGlmKCF1cGRhdGVfcHVmZilcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgXG4gICAgdmFyIHVwZGF0ZV9wcm9tID0gUEIuTmV0LnVwZGF0ZVVzZXJSZWNvcmQodXBkYXRlX3B1ZmYpXG4gICAgICAgIFxuICAgIHJldHVybiB1cGRhdGVfcHJvbVxufVxuXG5QQi5mb3JtYXRJZGVudGl0eUZpbGUgPSBmdW5jdGlvbih1c2VybmFtZSkge1xuICAgIC8vIFRISU5LOiBjb25zaWRlciBwYXNzcGhyYXNlIHByb3RlY3RpbmcgdGhlIGlkZW50aXR5IGZpbGUgYnkgZGVmYXVsdFxuICAgIC8vIFRPRE86IGFkZCBhdXRoRnJvbUlkRmlsZSAtLSBuZWVkIGNvbnNpc3RlbmN5IGJvdGggd2F5c1xuICAgIFxuICAgIHVzZXJuYW1lID0gdXNlcm5hbWUgfHwgUEIuZ2V0Q3VycmVudFVzZXJuYW1lKClcbiAgICBcbiAgICBpZighdXNlcm5hbWUpIHJldHVybiBmYWxzZVxuXG4gICAgdmFyIGlkRmlsZSA9IHt9XG5cbiAgICBQQi51c2VTZWN1cmVJbmZvKGZ1bmN0aW9uKGlkZW50aXRpZXMsIGN1cnJlbnRVc2VybmFtZSwgcHJpdmF0ZVJvb3RLZXksIHByaXZhdGVBZG1pbktleSwgcHJpdmF0ZURlZmF1bHRLZXkpIHtcbiAgICAgICAgLy8gdGhpcyBsZWFrcyBhbGwgb2YgdGhlIGlkZW50aXR5IGluZm9ybWF0aW9uIGJhY2sgdG8gdGhlIGNhbGxlclxuICAgICAgICAvLyBpZiB3ZSBwYXNzcGhyYXNlIHByb3RlY3QgdGhlIGZpbGUsIGRvIGl0IGhlcmUgdG8gcHJldmVudCB0aGF0IGxlYWthZ2VcblxuICAgICAgICB2YXIgaWRlbnRpdHkgPSBpZGVudGl0aWVzW3VzZXJuYW1lXVxuXG4gICAgICAgIC8vIGFzc2VtYmxlIGlkRmlsZSBtYW51YWxseSB0byBrZWVwIGV2ZXJ5dGhpbmcgaW4gdGhlIHJpZ2h0IG9yZGVyXG4gICAgICAgIC8vIGlkRmlsZS5jb21tZW50ID0gXCJUaGlzIGZpbGUgY29udGFpbnMgeW91ciBwcml2YXRlIHBhc3NwaHJhc2UuIEl0IHdhcyBnZW5lcmF0ZWQgYXQgaS5jeC4gVGhlIGluZm9ybWF0aW9uIGhlcmUgY2FuIGJlIHVzZWQgdG8gbG9naW4gdG8gd2Vic2l0ZXMgb24gdGhlIHB1ZmZiYWxsLmlvIHBsYXRmb3JtLiBLZWVwIHRoaXMgZmlsZSBzYWZlIGFuZCBzZWN1cmUhXCJcblxuICAgICAgICBpZEZpbGUudXNlcm5hbWUgPSB1c2VybmFtZVxuICAgICAgICAvLyBpZEZpbGUucHJpbWFyeSAgPSBpZGVudGl0eS5wcmltYXJ5IC8vIE5PVEU6IHByaW1hcnkgaXMgYXV0b21hdGljYWxseSBnYXRoZXJlZCBmcm9tIGFsaWFzZXNcbiAgICAgICAgaWRGaWxlLmFsaWFzZXMgID0gaWRlbnRpdHkuYWxpYXNlc1xuICAgICAgICBpZEZpbGUucHJlZmVyZW5jZXMgPSBpZGVudGl0eS5wcmVmZXJlbmNlc1xuICAgICAgICBpZEZpbGUudmVyc2lvbiAgPSBcIjEuMVwiXG4gICAgfSlcblxuICAgIHJldHVybiBpZEZpbGVcbn1cblxuXG5cbi8vLy8gVVNFUiBDUkVBVElPTiAvLy8vXG5cbi8qKlxuICogcmVnaXN0ZXIgYSBzdWJ1c2VyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNpZ25pbmdVc2VybmFtZSB1c2VybmFtZSBvZiBleGlzdGVkIHVzZXJcbiAqIEBwYXJhbSAge3N0cmluZ30gcHJpdmF0ZUFkbWluS2V5IHByaXZhdGUgYWRtaW4ga2V5IGZvciBleGlzdGVkIHVzZXJcbiAqIEBwYXJhbSAge3N0cmluZ30gbmV3VXNlcm5hbWUgICAgIGRlc2lyZWQgbmV3IHN1YnVzZXIgbmFtZVxuICogQHBhcmFtICB7c3RyaW5nfSByb290S2V5ICAgICAgICAgcHVibGljIHJvb3Qga2V5IGZvciB0aGUgbmV3IHN1YnVzZXJcbiAqIEBwYXJhbSAge3N0cmluZ30gYWRtaW5LZXkgICAgICAgIHB1YmxpYyBhZG1pbiBrZXkgZm9yIHRoZSBuZXcgc3VidXNlclxuICogQHBhcmFtICB7c3RyaW5nfSBkZWZhdWx0S2V5ICAgICAgcHVibGljIGRlZmF1bHQga2V5IGZvciB0aGUgbmV3IHN1YnVzZXJcbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAgdXNlciByZWNvcmQgZm9yIHRoZSBuZXdseSBjcmVhdGVkIHN1YnVzZXJcbiAqL1xuUEIucmVnaXN0ZXJTdWJ1c2VyRm9yVXNlciA9IGZ1bmN0aW9uKHNpZ25pbmdVc2VybmFtZSwgcHJpdmF0ZUFkbWluS2V5LCBuZXdVc2VybmFtZSwgcm9vdEtleSwgYWRtaW5LZXksIGRlZmF1bHRLZXkpIHtcblxuICAgIC8vIGJ1aWxkIG91ciBESFQgdXBkYXRlIHB1ZmZcbiAgICB2YXIgcGF5bG9hZCA9IHsgcmVxdWVzdGVkVXNlcm5hbWU6IG5ld1VzZXJuYW1lXG4gICAgICAgICAgICAgICAgICAsICAgICAgICBkZWZhdWx0S2V5OiBkZWZhdWx0S2V5XG4gICAgICAgICAgICAgICAgICAsICAgICAgICAgIGFkbWluS2V5OiBhZG1pbktleVxuICAgICAgICAgICAgICAgICAgLCAgICAgICAgICAgcm9vdEtleTogcm9vdEtleVxuICAgICAgICAgICAgICAgICAgLCAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgdmFyIHJvdXRpbmcgPSBbXSAvLyBUSElOSzogREhUP1xuICAgIHZhciBjb250ZW50ID0gJ3JlcXVlc3RVc2VybmFtZSdcbiAgICB2YXIgdHlwZSAgICA9ICd1cGRhdGVVc2VyUmVjb3JkJ1xuXG4gICAgdmFyIHB1ZmYgPSBQQi5idWlsZFB1ZmYoc2lnbmluZ1VzZXJuYW1lLCBwcml2YXRlQWRtaW5LZXksIHJvdXRpbmcsIHR5cGUsIGNvbnRlbnQsIHBheWxvYWQpXG4gICAgLy8gTk9URTogd2UncmUgc2tpcHBpbmcgcHJldmlvdXMsIGJlY2F1c2UgcmVxdWVzdFVzZXJuYW1lLXN0eWxlIHB1ZmZzIGRvbid0IHVzZSBpdC5cblxuICAgIHJldHVybiBQQi5OZXQudXBkYXRlVXNlclJlY29yZChwdWZmKVxufVxuXG5cblxuXG4vLy8vIEJVSUxEIENSWVBUTyBXT1JLRVIgLy8vL1xuXG5QQi5idWlsZENyeXB0b3dvcmtlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgY3J5cHRvd29ya2VyVVJMID0gb3B0aW9ucy5jcnlwdG93b3JrZXJVUkwgfHwgUEIuQ09ORklHLmNyeXB0b3dvcmtlclVSTCAvLyB8fCAnY3J5cHRvd29ya2VyLmpzJ1xuICAgIFxuICAgIGlmKCFjcnlwdG93b3JrZXJVUkwpIHJldHVybiBmYWxzZVxuICAgIFxuICAgIFBCLmNyeXB0b3dvcmtlciA9IG5ldyBXb3JrZXIoY3J5cHRvd29ya2VyVVJMKVxuICAgIFBCLmNyeXB0b3dvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBQQi53b3JrZXJyZWNlaXZlKVxufVxuXG5QQi53b3JrZXJxdWV1ZSA9IFtdXG5QQi53b3JrZXJhdXRvaWQgPSAwXG5cblBCLndvcmtlcnJlY2VpdmUgPSBmdW5jdGlvbihtc2cpIHtcbiAgICB2YXIgaWQgPSBtc2cuZGF0YS5pZFxuICAgIGlmKCFpZCkgcmV0dXJuIGZhbHNlIC8vIFRPRE86IGFkZCBvbkVycm9yIGhlcmVcblxuICAgIHZhciBmdW4gPSBQQi53b3JrZXJxdWV1ZVtpZF1cbiAgICBpZighZnVuKSByZXR1cm4gZmFsc2UgLy8gVE9ETzogYWRkIG9uRXJyb3IgaGVyZVxuXG4gICAgZnVuKG1zZy5kYXRhLmV2YWx1YXRlZClcblxuICAgIGRlbGV0ZSBQQi53b3JrZXJxdWV1ZVtpZF0gLy8gVEhJTks6IHRoaXMgbGVhdmVzIGEgc3BhcnNlIGFycmF5LCBidXQgaXMgcHJvYmFibHkgZmFzdGVyIHRoYW4gc3BsaWNpbmdcbn1cblxuUEIud29ya2Vyc2VuZCA9IGZ1bmN0aW9uKGZ1bnN0ciwgYXJncywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgUEIud29ya2VyYXV0b2lkICs9IDFcbiAgICBQQi53b3JrZXJxdWV1ZVtQQi53b3JrZXJhdXRvaWRdID0gcmVzb2x2ZVxuICAgIGlmKCFBcnJheS5pc0FycmF5KGFyZ3MpKVxuICAgICAgICBhcmdzID0gW2FyZ3NdXG4gICAgUEIuY3J5cHRvd29ya2VyLnBvc3RNZXNzYWdlKHtmdW46IGZ1bnN0ciwgYXJnczogYXJncywgaWQ6IFBCLndvcmtlcmF1dG9pZH0pXG59XG5cbi8vLy8gRU5EIEJVSUxEIENSWVBUTyBXT1JLRVIgLy8vL1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLyBTRUNVUkUgSU5GT1JNQVRJT04gSU5URVJGQUNFIC8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblBCLmltcGxlbWVudFNlY3VyZUludGVyZmFjZSA9IGZ1bmN0aW9uKHVzZVNlY3VyZUluZm8sIGFkZElkZW50aXR5LCBhZGRBbGlhcywgc2V0UHJpbWFyeUFsaWFzLCBzZXRQcmVmZXJlbmNlLCBzd2l0Y2hJZGVudGl0eVRvLCByZW1vdmVJZGVudGl0eSkge1xuICAgIC8vIHVzZVNlY3VyZUluZm8gICAgPSBmdW5jdGlvbiggZnVuY3Rpb24oaWRlbnRpdGllcywgdXNlcm5hbWUsIHByaXZhdGVSb290S2V5LCBwcml2YXRlQWRtaW5LZXksIHByaXZhdGVEZWZhdWx0S2V5KSApXG4gICAgLy8gYWRkSWRlbnRpdHkgICAgICA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBhbGlhc2VzLCBwcmVmZXJlbmNlcylcbiAgICAvLyBhZGRBbGlhcyAgICAgICAgID0gZnVuY3Rpb24oaWRlbnRpdHlVc2VybmFtZSwgYWxpYXNVc2VybmFtZSwgY2FwYSwgcHJpdmF0ZVJvb3RLZXksIHByaXZhdGVBZG1pbktleSwgcHJpdmF0ZURlZmF1bHRLZXksIHNlY3JldHMpXG4gICAgLy8gc2V0UHJpbWFyeUFsaWFzICA9IGZ1bmN0aW9uKGlkZW50aXR5VXNlcm5hbWUsIGFsaWFzVXNlcm5hbWUpXG4gICAgLy8gcmVtb3ZlSWRlbnRpdHkgICA9IGZ1bmN0aW9uKHVzZXJuYW1lKVxuICAgIC8vIHNldFByZWZlcmVuY2UgICAgPSBmdW5jdGlvbihrZXksIHZhbHVlKSAvLyBmb3IgY3VycmVudCBpZGVudGl0eVxuICAgIC8vIHN3aXRjaElkZW50aXR5VG8gPSBmdW5jdGlvbih1c2VybmFtZSlcblxuICAgIC8vIFRISU5LOiBjb25zaWRlciBlbnN1cmluZyBhbGwgZnVuY3Rpb25zIGFyZSBwcmVzZW50IGZpcnN0LCBzbyBpdCdzIGhhcmRlciB0byBtaXggYW5kIG1hdGNoIHdhcmRyb2JlIGltcGxlbWVudGF0aW9uc1xuICAgIFxuICAgIGlmKHR5cGVvZiB1c2VTZWN1cmVJbmZvID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgUEIudXNlU2VjdXJlSW5mbyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiB1c2VTZWN1cmVJbmZvIHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBhIGN1cnJlbnQgaWRlbnRpdHksIGFuZCBmYWxzZSBvdGhlcndpc2VcbiAgICAgICAgICAgIHJldHVybiB1c2VTZWN1cmVJbmZvKCBmdW5jdGlvbihpZGVudGl0aWVzLCB1c2VybmFtZSwgcHJpdmF0ZVJvb3RLZXksIHByaXZhdGVBZG1pbktleSwgcHJpdmF0ZURlZmF1bHRLZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xvbmVkSWRlbnRpdGllcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaWRlbnRpdGllcykpIC8vIHByZXZlbnQgYWNjaWRlbnRhbCBtdXRhdGlvblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGNsb25lZElkZW50aXRpZXMsIHVzZXJuYW1lLCBwcml2YXRlUm9vdEtleSwgcHJpdmF0ZUFkbWluS2V5LCBwcml2YXRlRGVmYXVsdEtleSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYodHlwZW9mIGFkZElkZW50aXR5ID09ICdmdW5jdGlvbicpXG4gICAgICAgIFBCLmFkZElkZW50aXR5ID0gYWRkSWRlbnRpdHlcbiAgICAgICAgXG4gICAgaWYodHlwZW9mIGFkZEFsaWFzID09ICdmdW5jdGlvbicpXG4gICAgICAgIFBCLmFkZEFsaWFzID0gYWRkQWxpYXNcbiAgICAgICAgXG4gICAgaWYodHlwZW9mIHNldFByaW1hcnlBbGlhcyA9PSAnZnVuY3Rpb24nKVxuICAgICAgICBQQi5zZXRQcmltYXJ5QWxpYXMgPSBzZXRQcmltYXJ5QWxpYXNcbiAgICAgICAgXG4gICAgaWYodHlwZW9mIHNldFByZWZlcmVuY2UgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgUEIuc2V0UHJlZmVyZW5jZSA9IHNldFByZWZlcmVuY2VcbiAgICAgICAgXG4gICAgaWYodHlwZW9mIHN3aXRjaElkZW50aXR5VG8gPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgUEIuc3dpdGNoSWRlbnRpdHlUbyA9IGZ1bmN0aW9uKHVzZXJuYW1lKSB7XG4gICAgICAgICAgICBQQi5ydW5IYW5kbGVycygnYmVmb3JlU3dpdGNoSWRlbnRpdHknLCB1c2VybmFtZSlcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBzd2l0Y2hJZGVudGl0eVRvKHVzZXJuYW1lKVxuICAgICAgICAgICAgUEIucnVuSGFuZGxlcnMoJ2FmdGVyU3dpdGNoSWRlbnRpdHknLCB1c2VybmFtZSlcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgfVxuICAgICAgICBcbiAgICBpZih0eXBlb2YgcmVtb3ZlSWRlbnRpdHkgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgUEIucmVtb3ZlSWRlbnRpdHkgPSByZW1vdmVJZGVudGl0eVxuICAgICAgICBcbiAgICBQQi5nZXRDdXJyZW50VXNlcm5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8geWVzLCB0aGlzIHRlY2huaXF1ZSBhbGxvd3MgeW91IHRvIGxlYWsgZGF0YSBvdXQgb2YgdXNlU2VjdXJlSW5mby4gbm8sIHlvdSBzaG91bGQgbm90IHVzZSBpdC5cbiAgICAgICAgdmFyIG91dHB1dFxuICAgICAgICBQQi51c2VTZWN1cmVJbmZvKGZ1bmN0aW9uKGlkZW50aXRpZXMsIHVzZXJuYW1lKSB7IG91dHB1dCA9IHVzZXJuYW1lIH0pXG4gICAgICAgIHJldHVybiBvdXRwdXRcbiAgICB9XG4gICAgXG4gICAgUEIuZ2V0Q3VycmVudENhcGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8geWVzLCB0aGlzIHRlY2huaXF1ZSBhbGxvd3MgeW91IHRvIGxlYWsgZGF0YSBvdXQgb2YgdXNlU2VjdXJlSW5mby4gbm8sIHlvdSBzaG91bGQgbm90IHVzZSBpdC5cbiAgICAgICAgdmFyIG91dHB1dFxuICAgICAgICBQQi51c2VTZWN1cmVJbmZvKGZ1bmN0aW9uKGlkZW50aXRpZXMsIHVzZXJuYW1lKSB7IG91dHB1dCA9ICgoaWRlbnRpdGllc1t1c2VybmFtZV18fHt9KS5wcmltYXJ5fHx7fSkuY2FwYXx8MCB9KVxuICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgfVxuICAgIFxuICAgIFBCLmdldEN1cnJlbnRWZXJzaW9uZWRVc2VybmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdXNlcm5hbWUgPSBQQi5nZXRDdXJyZW50VXNlcm5hbWUoKVxuICAgICAgICBpZighdXNlcm5hbWUpXG4gICAgICAgICAgICByZXR1cm4gUEIub25FcnJvcignTm8gY3VycmVudCB1c2VyIGluIHdhcmRyb2JlJylcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBQQi5Vc2Vycy5tYWtlVmVyc2lvbmVkKHVzZXJuYW1lLCBQQi5nZXRDdXJyZW50Q2FwYSgpKVxuICAgIH1cbiAgICBcbiAgICBQQi5nZXRDdXJyZW50VXNlclJlY29yZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmVyc2lvbmVkVXNlcm5hbWUgPSBQQi5nZXRDdXJyZW50VmVyc2lvbmVkVXNlcm5hbWUoKVxuICAgICAgICBpZighdmVyc2lvbmVkVXNlcm5hbWUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgXG4gICAgICAgIC8vIFRISU5LOiBpdCdzIHdlaXJkIHRvIGhpdCB0aGUgY2FjaGUgZGlyZWN0bHkgZnJvbSBoZXJlLCBidXQgaWYgd2UgZG9uJ3QgdGhlbiB3ZSBhbHdheXMgZ2V0IGEgcHJvbWlzZSxcbiAgICAgICAgLy8gICAgICAgIGV2ZW4gaWYgd2UgaGl0IHRoZSBjYWNoZSwgYW5kIHRoaXMgc2hvdWxkIHJldHVybiBhIHByb3BlciB1c2VyUmVjb3JkLCBub3QgYSBwcm9taXNlLCBcbiAgICAgICAgLy8gICAgICAgIHNpbmNlIGFmdGVyIGFsbCB3ZSBoYXZlIHN0b3JlZCB0aGUgdXNlclJlY29yZCBpbiBvdXIgd2FyZHJvYmUsIGhhdmVuJ3Qgd2U/XG4gICAgXG4gICAgICAgIHZhciB1c2VyUmVjb3JkID0gUEIuVXNlcnMucmVjb3Jkc1t2ZXJzaW9uZWRVc2VybmFtZV1cbiAgICAgICAgaWYoIXVzZXJSZWNvcmQpXG4gICAgICAgICAgICByZXR1cm4gUEIub25FcnJvcignVGhhdCB1c2VyIGRvZXMgbm90IGV4aXN0IGluIG91ciByZWNvcmRzJylcbiAgICBcbiAgICAgICAgcmV0dXJuIHVzZXJSZWNvcmRcbiAgICB9XG5cbiAgICBQQi5nZXRBbGxJZGVudGl0eVVzZXJuYW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyB5ZXMsIHRoaXMgdGVjaG5pcXVlIGFsbG93cyB5b3UgdG8gbGVhayBkYXRhIG91dCBvZiB1c2VTZWN1cmVJbmZvLiBubywgeW91IHNob3VsZCBub3QgdXNlIGl0LlxuICAgICAgICB2YXIgb3V0cHV0XG4gICAgICAgIFBCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oaWRlbnRpdGllcywgdXNlcm5hbWUpIHsgb3V0cHV0ID0gT2JqZWN0LmtleXMoaWRlbnRpdGllcykgfSlcbiAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgIH1cbiAgICBcbn1cblxuLy8vLy8vLy8vLy8vLy8gRU5EIFNFQ1VSRSBJTkZPUk1BVElPTiBaT05FIC8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuXG5cblxuXG4vLy8vIFZBTElEQVRJT05TXG5cbi8vIFRPRE86IG1lcmdlIHRoZXNlIGludG8gUEIuU3BlY1xuXG4vKipcbiAqIGNoZWNrIGlmIGEgdXNlcm5hbWUgaXMgdmFsaWRcbiAqICAgICBhIHVzZXJuYW1lIG11c3QgYmUgc2hvcnRlciB0aGFuIDI1NiBjaGFyYWN0ZXJzLCBhbGwgbG93ZXJjYXNlIGFuZCBjb250YWlucyBvbmx5IGFscGhhbnVtZXJpYyBhbmQgLiBzaWduXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVzZXJuYW1lIHRoZSBzdHJpbmcgdG8gYmUgY2hlY2tcbiAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICAgIHJldHVybiB0cnVlIGlmICB0aGUgcGFyYW1ldGVyIHN0cmluZyBpcyBhIHZhbGlkIHVzZXJuYW1lLCBvdGhlcndpc2UgdGhyb3cgZXJyb3JcbiAqL1xuUEIudmFsaWRhdGVVc2VybmFtZSA9IGZ1bmN0aW9uKHVzZXJuYW1lKSB7XG4gICAgaWYoIXVzZXJuYW1lKSBcbiAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ1VzZXJuYW1lIGlzIHJlcXVpcmVkJywgdXNlcm5hbWUpXG5cbiAgICBpZih1c2VybmFtZS5sZW5ndGggPiAyNTYpIFxuICAgICAgICByZXR1cm4gUEIub25FcnJvcignVXNlcm5hbWVzIG11c3QgYmUgc2hvcnRlciB0aGFuIDI1NiBjaGFyYWN0ZXJzJywgdXNlcm5hbWUpXG5cbiAgICBpZih1c2VybmFtZSAhPSB1c2VybmFtZS50b0xvd2VyQ2FzZSgpKSBcbiAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ1VzZXJuYW1lcyBtdXN0IGJlIGxvd2VyY2FzZScsIHVzZXJuYW1lKVxuICAgIFxuICAgIGlmKCEvXlswLTlhLXouXSskLy50ZXN0KHVzZXJuYW1lKSlcbiAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ1VzZXJuYW1lcyBtdXN0IGJlIGFscGhhbnVtZXJpYycsIHVzZXJuYW1lKVxuICAgIFxuICAgIHJldHVybiB0cnVlXG59XG5cblxuLyoqXG4gKiBkZXRlcm1pbmUgaWYgaXQgaXMgYSBnb29kIHNoZWxsLCBjaGVja3MgZm9yIHRoZSBleGlzdGVuY2Ugb2YgcmVxdWlyZWQgZmllbGRzXG4gKiBAcGFyYW0ge1NoZWxsW119XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuUEIuaXNWYWxpZFNoZWxsID0gZnVuY3Rpb24oc2hlbGwpIHtcbiAgICAvLy8vIHRoaXMganVzdCBjaGVja3MgZm9yIHRoZSBleGlzdGVuY2Ugb2YgcmVxdWlyZWQgZmllbGRzXG4gICAgaWYoIXNoZWxsLnNpZykgcmV0dXJuIGZhbHNlXG4gICAgaWYoIXNoZWxsLnJvdXRlcykgcmV0dXJuIGZhbHNlXG4gICAgaWYoIXNoZWxsLnVzZXJuYW1lKSByZXR1cm4gZmFsc2VcbiAgICBpZih0eXBlb2Ygc2hlbGwucGF5bG9hZCAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlXG4gICAgaWYoIXNoZWxsLnBheWxvYWQudHlwZSkgcmV0dXJuIGZhbHNlXG4gICAgICAgIFxuICAgIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogdG8gdmVyaWZ5IGEgcHVmZlxuICogQHBhcmFtICB7b2JqZWN0fSBwdWZmXG4gKiBAcmV0dXJuIHsoc3RyaW5nfGJvb2xlYW4pfVxuICovXG5QQi5pc0dvb2RQdWZmID0gZnVuY3Rpb24ocHVmZikge1xuICAgIC8vIENVUlJFTlRMWSBVTlVTRURcbiAgICAvLyBUT0RPOiBjaGVjayBwcmV2aW91cyBzaWcsIG1heWJlXG4gICAgLy8gVE9ETzogY2hlY2sgZm9yIHdlbGwtZm9ybWVkLW5lc3NcbiAgICAvLyBUT0RPOiB1c2UgdGhpcyB0byB2ZXJpZnkgaW5jb21pbmcgcHVmZnNcbiAgICAvLyBUT0RPOiBpZiBwcm9tIGRvZXNuJ3QgbWF0Y2gsIHRyeSBhZ2FpbiB3aXRoIGdldFVzZXJSZWNvcmROb0NhY2hlXG4gICAgXG4gICAgLy8gVE9ETzogcmV3cml0ZSB0aGlzIGZ1bmN0aW9uIHRvIGdpdmUgYSBjb25zaXN0ZW50IHJldHVybiB2YWx1ZVxuICAgIFxuICAgIGlmICghUEIuTS5Gb3J1bS5jb250ZW50VHlwZXNbc2hlbGwucGF5bG9hZC50eXBlXSkge1xuICAgICAgICAvLyBUT0RPOiB0aGlzIG5lZWRzIHRvIGluY2x1ZGUgJ2VuY3J5cHRlZHB1ZmYnIGFzIGEgdmFsaWQgdHlwZVxuICAgICAgICBFdmVudHMucHViKCd0cmFjay91bnN1cHBvcnRlZC1jb250ZW50LXR5cGUnLCB7dHlwZTogc2hlbGwucGF5bG9hZC50eXBlLCBzaWc6IHNoZWxsLnNpZ30pXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBcbiAgICB2YXIgcHJvbSA9IFBCLlVzZXJzLmdldFVzZXJSZWNvcmRQcm9taXNlKHB1ZmYudXNlcm5hbWUpIC8vIE5PVEU6IHZlcnNpb25lZFVzZXJuYW1lXG4gICAgXG4gICAgcmV0dXJuIHByb20udGhlbihmdW5jdGlvbih1c2VyKSB7XG4gICAgICAgIHJldHVybiBQQi5DcnlwdG8udmVyaWZ5UHVmZlNpZyhwdWZmLCB1c2VyLmRlZmF1bHRLZXkpXG4gICAgfSlcbn1cblxuXG5cbi8vLy8gRVJST1IgSEVMUEVSU1xuXG4vLyBUT0RPOiBidWlsZCBhIG1vcmUgZ2VuZXJhbCBlcnJvciBoYW5kbGluZyBzeXN0ZW0gZm9yIEdVSSBpbnRlZ3JhdGlvblxuXG5QQi5vbkVycm9yID0gZnVuY3Rpb24obXNnLCBvYmosIHRyaWdnZXIpIHtcbiAgICAvLy8vIG92ZXJyaWRlIHRoaXMgZm9yIGN1c3RvbSBlcnJvciBiZWhhdmlvclxuICAgIFxuICAgIHZhciBjb21wb3NpdGUgPSB7bXNnOiBtc2csIG9iajogb2JqfVxuXG4gICAgUEIucnVuSGFuZGxlcnMoJ2Vycm9yJywgY29tcG9zaXRlKVxuICAgIFxuICAgIGlmKHRyaWdnZXIpXG4gICAgICAgIFBCLnJ1bkhhbmRsZXJzKHRyaWdnZXIsIGNvbXBvc2l0ZSlcbiAgICAgICAgXG4gICAgLy8gZm9yIGRlYnVnZ2luZyBoZWxwLCBydW4gdGhpcyBpbiB0aGUgY29uc29sZTpcbiAgICAvLyBQQi5hZGRFcnJvckhhbmRsZXIoZnVuY3Rpb24oY29tcG9zaXRlKSB7Y29uc29sZS5sb2coY29tcG9zaXRlKX0pXG5cbiAgICByZXR1cm4gZmFsc2Vcbn1cblxuUEIuY2F0Y2hFcnJvciA9IGZ1bmN0aW9uKG1zZykge1xuICAgIC8vLy8gZXg6IHByb20uY2F0Y2goIFBCLmNhdGNoRXJyb3IoJ2ludmFsaWQgZm9vJykgKS50aGVuKGZ1bmN0aW9uKGZvbykgey4uLn0pXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBQQi5vbkVycm9yKG1zZywgZXJyKVxuICAgICAgICB0aHJvdyBlcnJcbiAgICB9XG59XG5cblBCLnRocm93RXJyb3IgPSBmdW5jdGlvbihtc2csIGVycm1zZykge1xuICAgIC8vLy8gZXg6IHByb20udGhlbihmdW5jdGlvbihmb28pIHtpZighZm9vKSBQQi50aHJvd0Vycm9yKCdubyBmb28nKTsgLi4ufSlcbiAgICB2YXIgZXJyID0gZXJybXNnID8gRXJyb3IoZXJybXNnKSA6ICcnXG4gICAgdGhyb3cgUEIubWFrZUVycm9yKG1zZywgZXJyKVxufVxuXG5QQi5tYWtlRXJyb3IgPSBmdW5jdGlvbihtc2csIGVyciwgdHJpZ2dlcikge1xuICAgIC8vLy8gZXg6IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkgeyBpZighZm9vKSByZWplY3QoIFBCLm1ha2VFcnJvcignbm8gZm9vJykgKSAuLi4gfSlcbiAgICBQQi5vbkVycm9yKG1zZywgZXJyLCB0cmlnZ2VyKVxuICAgIHJldHVybiBFcnJvcihtc2cpXG59XG5cblBCLmVtcHR5UHJvbWlzZSA9IGZ1bmN0aW9uKG1zZykge1xuICAgIC8vLy8gZXg6IGZ1bmN0aW9uKGZvbykgeyBpZighZm9vKSByZXR1cm4gUEIuZW1wdHlQcm9taXNlKCdubyBmb28nKTsgcmV0dXJuIGdldEZvb1Byb21pc2UoZm9vKSB9XG4gICAgaWYobXNnKSBQQi5vbkVycm9yKG1zZylcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobXNnKVxufVxuXG5QQi50aHJvd05ldEVycm9yID0gZnVuY3Rpb24obXNnLCBlcnJtc2cpIHtcbiAgICAvLy8vIGxpa2UgdGhyb3cgZXJyb3IgYnV0IHRyaWdnZXJzIHRoZSBuZXR3b3JrRXJyb3IgaGFuZGxlclxuICAgIHZhciB0cmlnZ2VyID0gJ25ldHdvcmtFcnJvcidcbiAgICB2YXIgZXJyID0gZXJybXNnID8gRXJyb3IoZXJybXNnKSA6ICcnXG4gICAgdGhyb3cgUEIubWFrZUVycm9yKG1zZywgZXJyLCB0cmlnZ2VyKVxufVxuXG5QQi50aHJvd0RIVEVycm9yID0gZnVuY3Rpb24obXNnLCBlcnJtc2cpIHtcbiAgICAvLy8vIGxpa2UgdGhyb3cgZXJyb3IgYnV0IHRyaWdnZXJzIHRoZSBESFRFcnJvciBoYW5kbGVyXG4gICAgdmFyIHRyaWdnZXIgPSAnREhURXJyb3InXG4gICAgdmFyIGVyciA9IGVycm1zZyA/IEVycm9yKGVycm1zZykgOiAnJ1xuICAgIHRocm93IFBCLm1ha2VFcnJvcihtc2csIGVyciwgdHJpZ2dlcilcbn1cblxuXG4vLy8vIEV4Y2VwdGlvbmFsIEFQSSB3cmFwcGVyc1xuXG5QQi5wYXJzZUpTT04gPSBmdW5jdGlvbihzdHIpIHtcbiAgICAvLy8vIEpTT04ucGFyc2UgdGhyb3dzLCBzbyB3ZSBjYXRjaCBpdC4gdGhyb3cvY2F0Y2ggYm9ya3MgdGhlIEpTIFZNIG9wdGltaXplciwgc28gd2UgYm94IGl0LlxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0cilcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICByZXR1cm4gUEIub25FcnJvcignSW52YWxpZCBKU09OIHN0cmluZycsIGVycilcbiAgICB9XG59XG5cblBCLnN0cmluZ2lmeUpTT04gPSBmdW5jdGlvbihvYmopIHtcbiAgICAvLy8vIEpTT04uc3RyaW5naWZ5IHRocm93cyBvbiBkdW1iIERPTSBvYmplY3RzLCBzbyB3ZSBjYXRjaCBpdC4gdGhyb3cvY2F0Y2ggYm9ya3MgdGhlIEpTIFZNIG9wdGltaXplciwgc28gd2UgYm94IGl0LlxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopXG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ0ludmFsaWQgb2JqZWN0JywgZXJyKVxuICAgIH1cbn1cblxuUEIudHJ5RGVjb2RlVVJJQ29tcG9uZW50ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgLy8vLyBkZWNvZGVVUklDb21wb25lbnQgdGhyb3dzLCBzbyB3ZSB3cmFwIGl0LiB0cnkvY2F0Y2gga2lsbHMgdGhlIG9wdGltaXplciwgc28gd2UgaXNvbGF0ZSBpdC5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICByZXR1cm4gUEIub25FcnJvcignSW52YWxpZCBVUkkgc3RyaW5nJywgZXJyKVxuICAgIH1cbn1cblxuXG4vLy8vIHNvbWV0aGluZyBkaWZmZXJlbnRcblxuUEIucHJvbWlzZXNQZW5kaW5nID0ge31cblxuLy8gTWFqb3IganVqaXRzdSBoZXJlXG5QQi5wcm9taXNlTWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1biwgb2hib3kpIHtcbiAgICBpZighb2hib3kpIG9oYm95ID0gUEIucmVtb3ZlUHJvbWlzZVBlbmRpbmdcbiAgICBcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBrZXkgPSBKU09OLnN0cmluZ2lmeShbZnVuLnRvU3RyaW5nKCksYXJndW1lbnRzXSlcbiAgICAgICAgXG4gICAgICAgIGlmKFBCLnByb21pc2VzUGVuZGluZ1trZXldKVxuICAgICAgICAgICAgcmV0dXJuIFBCLnByb21pc2VzUGVuZGluZ1trZXldXG4gICAgICAgIFxuICAgICAgICB2YXIgcHJvbSA9IGZ1bi5hcHBseShmdW4sIGFyZ3VtZW50cylcbiAgICAgICAgcHJvbSA9IHByb20udGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgb2hib3koa2V5LCB2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWxpdmVyIHN1Y2Nlc3Nlc1xuICAgICAgICB9LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgb2hib3koa2V5LCB2YWx1ZSlcbiAgICAgICAgICAgIHRocm93IHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wYWdhdGUgZmFpbHVyZXNcbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIFBCLnByb21pc2VzUGVuZGluZ1trZXldID0gcHJvbVxuICAgICAgICByZXR1cm4gcHJvbVxuICAgIH1cbn1cblxuUEIucmVtb3ZlUHJvbWlzZVBlbmRpbmcgPSBmdW5jdGlvbihrZXkpIHtcbiAgICBkZWxldGUgUEIucHJvbWlzZXNQZW5kaW5nW2tleV1cbn1cblxuLy8vLyBUSU1JTkcgSEVMUEVSU1xuXG5cbi8vIFRPRE86IG1vdmUgdGhlc2UgaW50byBhIGxpYnJhcnlcblxufmZ1bmN0aW9uKCkge1xuICAgIC8vLy8gcG9zdHBvbmUgdW50aWwgbmV4dCB0aWNrXG4gICAgLy8gaW5zcGlyZWQgYnkgaHR0cDovL2RiYXJvbi5vcmcvbG9nLzIwMTAwMzA5LWZhc3Rlci10aW1lb3V0c1xuICAgIHZhciBsYXRlciA9IFtdXG4gICAgdmFyIG1lc3NhZ2VOYW1lID0gMTIzNDVcbiAgICB2YXIgZ2ltbWVfYV90aWNrID0gdHJ1ZVxuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZ1bikge1xuICAgICAgICBsYXRlci5wdXNoKGZ1bilcbiAgICAgICAgXG4gICAgICAgIGlmKGdpbW1lX2FfdGljaykge1xuICAgICAgICAgICAgZ2ltbWVfYV90aWNrID0gZmFsc2VcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlTmFtZSwgXCIqXCIpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgaWYoZXZlbnQuZGF0YSAhPSBtZXNzYWdlTmFtZSkgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgZ2ltbWVfYV90aWNrID0gdHJ1ZVxuXG4gICAgICAgIHZhciBub3cgPSBsYXRlclxuICAgICAgICBsYXRlciA9IFtdXG5cbiAgICAgICAgZm9yKHZhciBpPTAsIGw9bm93Lmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgIG5vd1tpXSgpXG4gICAgfVxuICBcbiAgICBpZih0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSwgdHJ1ZSlcbiAgICAgICAgd2luZG93LnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZVxuICAgIH1cbn0oKVxuXG5QQi5xdWV1ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAvLy8vIGRvIHNvbWV0aGluZyBhZnRlciBzb21lIG90aGVyIHRoaW5nc1xuICAgIHZhciBxdWV1ZSA9IFtdXG4gICAgXG4gICAgdmFyIG5leHR0aW1lID0gZnVuY3Rpb24oaW52b2tlcikge1xuICAgICAgICBpbnZva2VyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYoIXF1ZXVlLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICBxdWV1ZS5zaGlmdCgpKClcbiAgICAgICAgICAgIG5leHR0aW1lKGludm9rZXIpXG4gICAgICAgIH0pXG4gICAgfVxuICAgICAgICAgICAgXG4gICAgdmFyIHF1ZXVlciA9IGZ1bmN0aW9uKGludm9rZXIsIGZ1bikge1xuICAgICAgICBxdWV1ZS5wdXNoKGZ1bilcbiAgICAgICAgaWYocXVldWUubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlIC8vIFRISU5LOiBwb3NzaWJsZSByYWNlIGNvbmRpdGlvblxuICAgICAgICBuZXh0dGltZShpbnZva2VyKSBcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHF1ZXVlclxufVxuXG5QQi5vbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8vLyBkbyBzb21ldGhpbmcgbGF0ZXIsIGJ1dCBvbmx5IG9uY2VcbiAgICB2YXIgbGF0ZXIgPSBbXVxuXG4gICAgdmFyIHN0ZXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vdyA9IGxhdGVyXG4gICAgICAgIGxhdGVyID0gW11cbiAgICAgICAgZm9yKHZhciBpPTAsIGw9bm93Lmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgIG5vd1tpXSgpXG4gICAgfVxuICAgICAgICAgICAgXG4gICAgdmFyIG9uY2UgPSBmdW5jdGlvbihpbnZva2VyLCBmdW4pIHtcbiAgICAgICAgaWYofmxhdGVyLmluZGV4T2YoZnVuKSkgcmV0dXJuIGZhbHNlXG4gICAgICAgIGxhdGVyLnB1c2goZnVuKVxuICAgICAgICBpZihsYXRlci5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2UgLy8gVEhJTks6IHBvc3NpYmxlIHJhY2UgY29uZGl0aW9uXG4gICAgICAgIGludm9rZXIoc3RlcCkgXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvbmNlXG59XG5cbn5mdW5jdGlvbigpIHtcbiAgICBpZih0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbmRvdy5xdWV1ZUltbWVkaWF0ZSA9IFBCLnF1ZXVlcigpLmJpbmQobnVsbCwgc2V0SW1tZWRpYXRlKVxuICAgICAgICB3aW5kb3cub25jZUltbWVkaWF0ZSAgPSBQQi5vbmNlKCkuYmluZChudWxsLCBzZXRJbW1lZGlhdGUpXG4gICAgICAgIHdpbmRvdy5xdWV1ZVJBRiA9IFBCLnF1ZXVlcigpLmJpbmQobnVsbCwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKVxuICAgICAgICB3aW5kb3cub25jZVJBRiAgPSBQQi5vbmNlKCkuYmluZChudWxsLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXG4gICAgXG4gICAgICAgIHZhciB0aW1lZnVuYmluZCA9IHt9XG4gICAgICAgIHdpbmRvdy5vbmNlSW5Bd2hpbGUgPSBmdW5jdGlvbihmdW4sIHRpbWUpIHtcbiAgICAgICAgICAgIC8vLy8gTk9URTogZG9uJ3QgdXNlIHRoZSBzYW1lIGZ1biB3aXRoIGRpZmZlcmVudCB0aW1lc1xuICAgICAgICAgICAgaWYodGltZWZ1bmJpbmRbZnVuXSkgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB0aW1lZnVuYmluZFtmdW5dID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtmdW4oKTsgdGltZWZ1bmJpbmRbZnVuXSA9IGZhbHNlfSwgdGltZSlcbiAgICAgICAgfVxuICAgIH1cbn0oKVxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLyBBIGZldyBzbWFsbCBoZWxwZXJzIGZvciBidWlsZGluZyBmdW5jdGlvbmFsIHBpcGVsaW5lcyAvLy8vLy8vLy8vLy8vLy9cblxuUEIucHJvcCA9IGZ1bmN0aW9uKHAsIG9iaikgeyAvLyBUSElOSzogY29uc2lkZXIgaW1wb3J0aW5nIGFsbCBvZiBSYW1iZGEuanNcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmpbcF07IH0gOiBvYmpbcF1cbn1cblxuUEIudW5pcXVpZnkgPSBmdW5jdGlvbihsaXN0KSB7XG4gICAgcmV0dXJuIGxpc3QuZmlsdGVyKFBCLnVuaXF1ZSlcbn1cblxuUEIudW5pcXVlID0gZnVuY3Rpb24oaXRlbSwgaW5kZXgsIGFycmF5KSB7cmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSkgPT0gaW5kZXh9XG4iLCIvKlxuXG4gICAgTmV0d29yayBsaWJyYXJ5IGZvciB0aGUgRXZlcnlCaXQgcGxhdGZvcm0uXG5cbiAgICBDb250YWlucyBhIHBlZXIuanMtYmFzZWQgcDJwIGxheWVyLCBhIHByb21pc2UtYmFzZWQgWEhSIGltcGxlbWVudGF0aW9uLCBcbiAgICBoZWxwZXIgZnVuY3Rpb25zIGZvciBhY2Nlc3NpbmcgdmFyaW91cyBzZXJ2ZXItYmFzZWQgQVBJcywgXG4gICAgYW5kIGhlbHBlciBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIHB1ZmYgZGlzdHJpYnV0aW9uIGFuZCBhY3F1aXNpdGlvbi5cblxuICAgIENvcHlyaWdodCAyMDE0IEV2ZXJ5Qml0LiBTZWUgUkVBRE1FIGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG4gKi9cblxuUEIuTmV0ID0ge31cblxuLyoqXG4gKiBGaXJlIHVwIG5ldHdvcmtzIChjdXJyZW50bHkganVzdCB0aGUgcGVlciBjb25uZWN0aW9ucylcbiAqL1xuUEIuTmV0LmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICBQQi5OZXQuUDJQLmluaXQoKVxufVxuXG4vKipcbiAqIEdpdmVuIGEgc2lnbmF0dXJlLCByZXR1cm4gcHVmZiB3aXRoIHRoYXQgc2lnbmF0dXJlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNpZyBzaWduYXR1cmUgb2YgYSBwdWZmXG4gKiBAcmV0dXJuIHtvYmplY3R9ICAgICBwdWZmIGNvcnJlc3BvbmRzIHRvIHRoZSBzcGVjaWZpZWQgc2lnbmF0dXJlXG4gKi9cblBCLk5ldC5nZXRQdWZmQnlTaWcgPSBmdW5jdGlvbihzaWcpIHtcbiAgICB2YXIgdXJsICA9IFBCLkNPTkZJRy5wdWZmQXBpXG4gICAgdmFyIGRhdGEgPSB7dHlwZTogJ2dldFB1ZmZCeVNpZycsIHNpZzogc2lnfVxuICAgIFxuICAgIHJldHVybiBQQi5OZXQuUEJnZXRKU09OKHVybCwgZGF0YSlcbn1cblxuUEIuTmV0LmdldEtpZFNpZ3MgPSBmdW5jdGlvbihzaWcpIHtcbiAgICB2YXIgdXJsICA9IFBCLkNPTkZJRy5wdWZmQXBpXG4gICAgdmFyIGRhdGEgPSB7dHlwZTogJ2dldENoaWxkcmVuQnlTaWcnLCBzaWc6IHNpZ31cbiAgICBcbiAgICByZXR1cm4gUEIuTmV0LlBCZ2V0SlNPTih1cmwsIGRhdGEpXG59XG5cblBCLk5ldC5nZXRLaWRTaWdzID0gQm9yb24ubWVtb2l6ZShQQi5OZXQuZ2V0S2lkU2lncykgLy8gVEhJTks6IHRoaXMgYXNzdW1lcyB3ZSdsbCBnZXQgYWxsIG5ldyB0aGluZ3Mgb3ZlciB0aGUgUDJQIG5ldHdvcmssIHdoaWNoIHdvbid0IGFsd2F5cyBiZSB0cnVlLlxuXG5cblxuUEIuTmV0LmdldFN0YXJTaGVsbHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdXJsICA9IFBCLkNPTkZJRy5wdWZmQXBpXG4gICAgdmFyIGRhdGEgPSB7dHlwZTogJ2dldFB1ZmZzJywgY29udGVudFR5cGU6ICdzdGFyJywgbnVtYjogUEIuQ09ORklHLmdsb2JhbEJpZ0JhdGNoTGltaXR9XG4gICAgXG4gICAgcmV0dXJuIFBCLk5ldC5QQmdldEpTT04odXJsLCBkYXRhKVxufVxuXG5QQi5OZXQuZ2V0Q29udmVyc2F0aW9uUHVmZnMgPSBmdW5jdGlvbihjb252b0lkLCBiYXRjaHNpemUsIG9mZnNldCwgZnVsbE9yU2hlbGwpIHtcbiAgICBjb252b0lkICA9IGNvbnZvSWQucmVwbGFjZSgnJicsJywnKVxuXG4gICAgdmFyIHVybCAgPSBQQi5DT05GSUcucHVmZkFwaVxuICAgIHZhciBkYXRhID0geyB0eXBlOiAnZ2V0UHVmZnMnLCBjb250ZW50VHlwZTogJ2VuY3J5cHRlZHB1ZmYnXG4gICAgICAgICAgICAgICAsIGNvbnZlcnNhdGlvblBhcnRuZXJzOiBjb252b0lkXG4gICAgICAgICAgICAgICAsIG51bWI6IGJhdGNoc2l6ZVxuICAgICAgICAgICAgICAgLCBvZmZzZXQ6IG9mZnNldFxuICAgICAgICAgICAgICAgfVxuICAgIFxuICAgIHJldHVybiBQQi5OZXQuUEJnZXRKU09OKHVybCwgZGF0YSlcbn1cblxuUEIuTmV0LmdldE15UHJpdmF0ZVB1ZmZzID0gZnVuY3Rpb24odXNlcm5hbWUsIGJhdGNoc2l6ZSwgb2Zmc2V0LCBmdWxsT3JTaGVsbCkge1xuICAgIGlmKCF1c2VybmFtZSkgcmV0dXJuIFBCLmVtcHR5UHJvbWlzZSgpXG4gICAgYmF0Y2hzaXplID0gYmF0Y2hzaXplIHx8IFBCLkNPTkZJRy5nbG9iYWxCaWdCYXRjaExpbWl0XG4gICAgXG4gICAgdmFyIHVybCAgPSBQQi5DT05GSUcucHVmZkFwaVxuICAgIHZhciBkYXRhID0geyByb3V0ZTogdXNlcm5hbWUsIHVzZXJuYW1lOiB1c2VybmFtZSwgZnJvbUFuZFRvOiAxXG4gICAgICAgICAgICAgICAsIHR5cGU6ICdnZXRQdWZmcycsIGNvbnRlbnRUeXBlOiAnZW5jcnlwdGVkcHVmZidcbiAgICAgICAgICAgICAgICwgZnVsbE9yU2hlbGw6IGZ1bGxPclNoZWxsIHx8ICdmdWxsJ1xuICAgICAgICAgICAgICAgLCBudW1iOiBiYXRjaHNpemVcbiAgICAgICAgICAgICAgICwgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICByZXR1cm4gUEIuTmV0LlBCZ2V0SlNPTih1cmwsIGRhdGEpXG4gICAgXG4vKlxuXG4gICAgU28gc29tZXRoaW5nIGxpa2U6XG5cbiAgICBQQi5nZXRTb21lUHVmZnMocXVlcnksIGxpbWl0LCBldGMpXG5cbiAgICBoZWxwZXIuanM6XG4gICAgdHJ5R2V0dGluZ01vcmVQdWZmcyh2aXNpYmxlTGltaXQpIHtcbiAgICAgICAgLy8gZmlndXJlIG91dCBob3cgbWFueSB3ZSd2ZSByZXF1ZXN0ZWQgYWxyZWFkeSAoSUNYLmN1cnJlbnRPZmZzZXQpXG4gICAgICAgIC8vIGZpZ3VyZSBvdXQgaG93IG1hbnkgd2UgYWN0dWFsbHkgaGF2ZSAoUEIuRGF0YS5nZXREZWNyeXB0ZWRQdWZmcylcbiAgICAgICAgdmFyIGRlbHRhID0gdmlzaWJsZUxpbWl0IC0gUEIuRGF0YS5nZXREZWNyeXB0ZWRQdWZmcygpLmxlbmd0aFxuICAgICAgICBJQ1guY3VycmVudE9mZnNldCArPSBkZWx0YVxuICAgICAgICByZXR1cm4gUEIuZ2V0U29tZVB1ZmZzKHF1ZXJ5LCBJQ1guY3VycmVudE9mZnNldClcbiAgICB9XG5cblxuKi8gXG5cbiAgICAvLyBUT0RPOiBjaGFpbiB0aGlzIGluIHRvIHRoZSB0YWJsZSB2aWV3XG4gICAgXG59XG5cblxuUEIuTmV0LmdldFByb2ZpbGVQdWZmID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICB2YXIgdXJsICA9IFBCLkNPTkZJRy5wdWZmQXBpXG4gICAgdmFyIGRhdGEgPSB7IHVzZXJuYW1lOiB1c2VybmFtZVxuICAgICAgICAgICAgICAgLCBmdWxsT3JTaGVsbDogJ2Z1bGwnXG4gICAgICAgICAgICAgICAsIGNvbnRlbnRUeXBlOiAncHJvZmlsZSdcbiAgICAgICAgICAgICAgICwgdHlwZTogJ2dldFB1ZmZzJ1xuICAgICAgICAgICAgICAgLCBzb3J0OiAnREVTQydcbiAgICAgICAgICAgICAgICwgbnVtYjogMVxuICAgICAgICAgICAgICAgfVxuICAgIFxuICAgIHJldHVybiBQQi5OZXQuUEJnZXRKU09OKHVybCwgZGF0YSlcbn1cblBCLk5ldC5nZXRQcm9maWxlUHVmZiA9IFBCLnByb21pc2VNZW1vaXplKFBCLk5ldC5nZXRQcm9maWxlUHVmZilcblxuLyoqXG4gKiB0byBnZXQgc29tZSBzaGVsbHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeVxuICogQHBhcmFtIHtzdHJpbmd9IGZpbHRlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge1NoZWxsW119XG4gKi9cblBCLk5ldC5nZXRTb21lU2hlbGxzID0gZnVuY3Rpb24ocXVlcnksIGZpbHRlcnMsIGxpbWl0LCBvZmZzZXQpIHtcbiAgICAvLyBUT0RPOiBzd2l0Y2hpbmcgYnkgcXVlcnkgJ21vZGUnIHdpbGwgbmVlZCB0byBiZSBjaGFuZ2VkIHdoZW4gdGhlIG5ldHdvcmsgYXBpIG1hdGNoZXMgb3VyIGxvY2FsIGFwaSAoaS5lLiBvbmNlIHdlIHVzZSBicm93c2VyIHAycCAmIGhlYWRsZXNzIGNsaWVudHMgdG8gc2VydmljZSByZXF1ZXN0cylcbiAgICBcbiAgICB2YXIgbW9kZSA9IHF1ZXJ5Lm1vZGVcbiAgICBpZihtb2RlID09ICdhbmNlc3RvcnMnKSAgIHJldHVybiBQQi5OZXQuZ2V0QW5jZXN0b3JzICAoW3F1ZXJ5LmZvY3VzXSwgbGltaXQpXG4gICAgaWYobW9kZSA9PSAnZGVzY2VuZGFudHMnKSByZXR1cm4gUEIuTmV0LmdldERlc2NlbmRhbnRzKFtxdWVyeS5mb2N1c10sIGxpbWl0KVxuICAgIC8vIGlmKG1vZGUgPT0gJ3NpYmxpbmdzJykgICAgcmV0dXJuIFBCLk5ldC5nZXRTaWJsaW5ncyAgIChbcXVlcnkuZm9jdXNdLCBsaW1pdClcblxuICAgIC8vIFwibm9ybWFsXCIgbW9kZSAoanVzdCBhc2sgZm9yIHNoZWxscyBmcm9tIGxpc3RzIG9yIHNvbWV0aGluZylcbiAgICB2YXIgdXJsICA9IFBCLkNPTkZJRy5wdWZmQXBpXG5cbiAgICAvLyAgaWYoZmlsdGVycy50eXBlcykgICBkYXRhLnR5cGUgICAgICAgPSBmaWx0ZXJzLnR5cGVzICAgICAgLy8gZmlsdGVyIGJ5IHR5cGVzXG5cbiAgICB2YXIgZGF0YSA9IHt0eXBlOiAnZ2V0UHVmZnMnLCBjb250ZW50VHlwZTogJ3BsYWluJ31cbiAgICAvLyB2YXIgZGF0YSA9IHt0eXBlOiAnZ2V0UHVmZnMnLCBjb250ZW50VHlwZTogJ1tcImltYWdlXCJdJ31cblxuXG4gICAgaWYobGltaXQpICBkYXRhLm51bWIgICAgPSBsaW1pdCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0cyB0byAyMCBvbiB0aGUgc2VydmVyXG4gICAgaWYob2Zmc2V0KSBkYXRhLm9mZnNldCAgPSBvZmZzZXQgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0cyB0byAwLCB3aGljaCBpcyBsYXRlc3RcbiAgICBcbiAgICBpZihxdWVyeS5zb3J0KSAgICAgIGRhdGEuc29ydCAgICAgICAgPSBxdWVyeS5zb3J0ICAgICAgIC8vIEFTQyBvciBERVNDXG4gICAgaWYoZmlsdGVycy51c2VycykgICBkYXRhLnVzZXJuYW1lICAgID0gZmlsdGVycy51c2VycyAgICAvLyBmaWx0ZXIgYnkgdXNlcm5hbWVcbiAgICBpZihmaWx0ZXJzLnJvdXRlcykgIGRhdGEucm91dGUgICAgICAgPSBmaWx0ZXJzLnJvdXRlcyAgIC8vIGZpbHRlciBieSByb3V0ZVxuICAgIGlmKGZpbHRlcnMudGFncykgICAgZGF0YS50YWdzICAgICAgICA9IGZpbHRlcnMudGFncyAgICAgLy8gZmlsdGVyIGJ5IHRhZ3NcbiAgICBpZihmaWx0ZXJzLnR5cGVzKSAgIGRhdGEuY29udGVudFR5cGUgPSBmaWx0ZXJzLnR5cGVzICAgIC8vIGZpbHRlciBieSB0eXBlc1xuICAgIGlmKHF1ZXJ5LmFuY2VzdG9ycykgZGF0YS5tYXhQYXJlbnRzICA9IHF1ZXJ5LmFuY2VzdG9ycyAgLy8gZGVmYXVsdHMgdG8gYWxsIHNoZWxscyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgaXMgcm9vdHMsIDEgaXMgc2luZ2xlIHBhcmVudCwgZXRjXG4gICAgLy8gZGF0YS5mbGFnZ2VkID0gZmFsc2VcbiAgICBcbiAgICAvLyBkYXRhLmZvY3VzXG4gICAgLy8gZGF0YS5hbmNlc3RvcnNcbiAgICAvLyBkYXRhLmRlc2NlbmRhbnRzXG4gICAgXG4gICAgdmFyIGZpbHRlcnN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGZpbHRlcnMudHlwZXMpXG4gICAgdmFyIHByb2ZpbGVfcmVxdWVzdCA9IChmaWx0ZXJzdHJpbmcgPT0gJ1tcInByb2ZpbGVcIl0nKVxuICAgIFxuICAgIGlmKFBCLkNPTkZJRy5kaXNhYmxlUmVjZWl2ZVB1YmxpYyAmJiAhcHJvZmlsZV9yZXF1ZXN0KVxuICAgICAgICByZXR1cm4gUEIuZW1wdHlQcm9taXNlKClcbiAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7cmV0dXJuIFtdfSlcbiAgICBcbiAgICByZXR1cm4gUEIuTmV0LlBCZ2V0SlNPTih1cmwsIGRhdGEpICAgICAgICAgICAgICAgICAgICAgIC8vIGFsd2F5cyByZXR1cm5zIGEgdmFsaWQgYXJyYXlcbiAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oeCkge3JldHVybiB4IHx8IFtdfSwgZnVuY3Rpb24oKSB7cmV0dXJuIFtdfSlcbn1cblxuXG5QQi5OZXQuZ2V0QW5jZXN0b3JzID0gZnVuY3Rpb24oc3RhcnQsIGxpbWl0KSB7XG4gICAgZ2V0RW0oc3RhcnQsIFtdLCBsaW1pdClcbiAgICByZXR1cm4gUEIuZW1wdHlQcm9taXNlKClcbiAgICBcbiAgICBmdW5jdGlvbiBnZXRFbSh0b2RvLCBkb25lLCByZW1haW5pbmcpIHtcbiAgICAgICAgaWYoIXRvZG8ubGVuZ3RoKSByZXR1cm4gZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBkb25lXG4gICAgICAgIGlmKCFyZW1haW5pbmcpIHJldHVybiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgZG9uZVxuICAgIFxuICAgICAgICB2YXIgc2lnID0gdG9kb1swXVxuICAgIFxuICAgICAgICBpZih+ZG9uZS5pbmRleE9mKHNpZykpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFbSh0b2RvLnNsaWNlKDEpLCBkb25lLCByZW1haW5pbmcpICAgIC8vIHdlJ3ZlIGFscmVhZHkgZG9uZSB0aGlzIG9uZVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBUT0RPOiBzZXQgYSBjYWxsYmFjayBpbiBQQi5OZXQgaW5zdGVhZCBvZiBjYWxsaW5nIFBCLkRhdGEgZGlyZWN0bHlcbiAgICAgICAgdmFyIHB1ZmYgPSBQQi5EYXRhLmdldFB1ZmZCeVNpZyhzaWcpICAgICAgICAgICAgICAgIC8vIGVmZmVjdGZ1bFxuICAgIFxuICAgICAgICBpZihwdWZmKSBcbiAgICAgICAgICAgIHJldHVybiBnZXRFbSh0b2RvLnNsaWNlKDEpLmNvbmNhdChwdWZmLnBheWxvYWQucGFyZW50cyksIGRvbmUuY29uY2F0KHNpZyksIHJlbWFpbmluZylcblxuICAgICAgICAvLyBubyBwdWZmPyB0aGF0J3Mgb2suIGF0dGFjaCBhIHRoZW4gY2xhdXNlIHRvIGl0cyBwZW5kaW5nIHByb21pc2UuXG4gICAgICAgIC8vIFRPRE86IGZpbmQgYmV0dGVyIG1ldGhvZCB0byBkbyB0aGlzXG4gICAgICAgIHJlbWFpbmluZy0tIC8vIGJlY2F1c2Ugd2UncmUgYWRkaW5nIGEgbmV3IHB1ZmYsIG9yIGF0IGxlYXN0IG5ldyBjb250ZW50XG4gICAgICAgIHZhciBwcm9tID0gUEIuRGF0YS5wZW5kaW5nUHVmZlByb21pc2VzW3NpZ11cbiAgICAgICAgcHJvbS50aGVuKGZ1bmN0aW9uKHB1ZmZzKSB7XG4gICAgICAgICAgICBnZXRFbSh0b2RvLnNsaWNlKDEpLmNvbmNhdCgoKHB1ZmZzWzBdfHx7fSkucGF5bG9hZHx8e30pLnBhcmVudHMpLCBkb25lLmNvbmNhdChzaWcpLCByZW1haW5pbmcpXG4gICAgICAgIH0pXG4gICAgfVxuICAgIFxuICAgIC8vXG4gICAgLy8gaWYoIXRvZG8ubGVuZ3RoKVxuICAgIC8vICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpICAgICAgICAgICAgIC8vIGFsbCBkb25lXG4gICAgLy8gaWYocmVzdWx0cy5sZW5ndGggPj0gbGltaXQpXG4gICAgLy8gICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0cykgICAgICAgICAgICAgLy8gYWxsIGRvbmVcbiAgICAvL1xuICAgIC8vIHZhciBzaWcgPSB0b2RvWzBdXG4gICAgLy8gdmFyIHNoZWxsID0gUEIuRGF0YS5nZXRDYWNoZWRTaGVsbEJ5U2lnKHNpZykgICAvLyBUT0RPOiBzZXQgYSBjYWxsYmFjayBpbiBQQi5OZXQgaW5zdGVhZCBvZiBjYWxsaW5nIHRoaXMgZGlyZWN0bHlcbiAgICAvLyAgICAgICAgICB8fCByZXN1bHRzLmZpbHRlcihmdW5jdGlvbihyZXN1bHQpIHtyZXR1cm4gcmVzdWx0LnNpZyA9PSBzaWd9KVswXVxuICAgIC8vXG4gICAgLy8gLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgcHVmZiBmb3Igc2lnLCB0aGVuIHdlIGp1c3QgbmVlZCB0byBwdXQgaXRzIHBhcmVudHMgb24gdGhlIHRvZG8gc3RhY2tcbiAgICAvLyBpZihzaGVsbCkge1xuICAgIC8vICAgICB0b2RvLnNoaWZ0KCkgLy8gdGFrZSBvZmYgdGhlIHNoZWxsIHdlIGp1c3Qgd29ya2VkIG9uXG4gICAgLy8gICAgIHJldHVybiBQQi5OZXQuZ2V0QW5jZXN0b3JzKHRvZG8uY29uY2F0KHNoZWxsLnBheWxvYWQucGFyZW50cyksIGxpbWl0LCByZXN1bHRzKVxuICAgIC8vIH1cbiAgICAvL1xuICAgIC8vIC8vIG90aGVyd2lzZSwgZ2V0IGEgcHJvbWlzZSBmb3IgdGhlIHNoZWxsLCB0aGVuIGFkZCBpdCB0byByZXN1bHRzXG4gICAgLy8gdmFyIHByb20gPSBQQi5OZXQuZ2V0UHVmZkJ5U2lnKHNpZylcbiAgICAvLyByZXR1cm4gcHJvbS50aGVuKGZ1bmN0aW9uKHB1ZmZzKSB7XG4gICAgLy8gICAgIHJldHVybiBQQi5OZXQuZ2V0QW5jZXN0b3JzKHRvZG8sIGxpbWl0LCByZXN1bHRzLmNvbmNhdChwdWZmcykpXG4gICAgLy8gfSlcbn1cblxuUEIuTmV0LmdldERlc2NlbmRhbnRzID0gZnVuY3Rpb24oc3RhcnQsIGxpbWl0KSB7XG4gICAgZ2V0RW0oc3RhcnQsIFtdLCBsaW1pdClcbiAgICByZXR1cm4gUEIuZW1wdHlQcm9taXNlKClcbiAgICBcbiAgICBmdW5jdGlvbiBnZXRFbSh0b2RvLCBkb25lLCByZW1haW5pbmcpIHtcbiAgICAgICAgaWYoIXRvZG8ubGVuZ3RoKSByZXR1cm4gZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBkb25lXG4gICAgICAgIGlmKCFyZW1haW5pbmcpIHJldHVybiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgZG9uZVxuICAgICAgICBcbiAgICAgICAgdmFyIHNpZyA9IHRvZG9bMF1cbiAgICAgICAgXG4gICAgICAgIGlmKH5kb25lLmluZGV4T2Yoc2lnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEVtKHRvZG8uc2xpY2UoMSksIGRvbmUsIHJlbWFpbmluZykgICAgLy8gd2UndmUgYWxyZWFkeSBkb25lIHRoaXMgb25lXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFRPRE86IHNldCBhIGNhbGxiYWNrIGluIFBCLk5ldCBpbnN0ZWFkIG9mIGNhbGxpbmcgUEIuRGF0YSBkaXJlY3RseVxuICAgICAgICB2YXIgaGF2ZVNoZWxsID0gUEIuRGF0YS5nZXRDYWNoZWRTaGVsbEJ5U2lnKHNpZykgXG4gICAgICAgIFxuICAgICAgICBpZighaGF2ZVNoZWxsKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSB0aGUgc2hlbGwgeWV0LCBzbyBnbyBnZXQgaXRcbiAgICAgICAgICAgIC8vIFRPRE86IHVzZSBhYm92ZSBjYWxsYmFjayB0byBQQi5EYXRhXG4gICAgICAgICAgICBQQi5EYXRhLmdldFB1ZmZCeVNpZyhzaWcpICAgICAgICAgICAgICAgICAgICAgICAvLyBlZmZlY3RmdWxcbiAgICAgICAgICAgIHJlbWFpbmluZy0tXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBraWRzaWdwcm9tID0gUEIuTmV0LmdldEtpZFNpZ3Moc2lnKSAgICAgICAgICAgICAvLyBnZXQgYWxsIGl0cyBjaGlsZHJlblxuICAgICAgICByZXR1cm4ga2lkc2lncHJvbS50aGVuKGZ1bmN0aW9uKGtpZHNpZ3MpIHtcbiAgICAgICAgICAgIGdldEVtKHRvZG8uc2xpY2UoMSkuY29uY2F0KGtpZHNpZ3MpLCBkb25lLmNvbmNhdChzaWcpLCByZW1haW5pbmcpXG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5QQi5OZXQuZ2V0U2libGluZ3MgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB0aGlzIGNhc2UgaXMgdWdseSwgc28gd2UncmUgbGVhdmluZyBpdCB1bnRpbCB0aGUgY2xpZW50IGFwaSBjYW4gYW5zd2VyIHF1ZXN0aW9ucyBmb3IgdXNcbiAgICByZXR1cm4gUEIuZW1wdHlQcm9taXNlKCkgXG59XG5cbi8qKlxuICogYWRkIHB1ZmYgdG8gdGhlIHNlcnZlciBhbmQgYnJvYWRjYXN0IHRvIHBlZXJzXG4gKiBAcGFyYW0gIHtvYmplY3R9IHB1ZmYgdGhlIHB1ZmYgdG8gYmUgYWRkZWQgdG8gdGhlIHNlcnZlclxuICovXG5QQi5OZXQuZGlzdHJpYnV0ZVB1ZmYgPSBmdW5jdGlvbihwdWZmKSB7XG4gICAgLy8vLyBkaXN0cmlidXRlIGEgcHVmZiB0byB0aGUgbmV0d29ya1xuXG4gICAgaWYoUEIuQ09ORklHLmRpc2FibGVTZW5kVG9TZXJ2ZXIpIHJldHVybiBmYWxzZSAgICAgICAgICAvLyBzbyB5b3UgY2FuIHdvcmsgbG9jYWxseVxuXG4gICAgaWYoUEIuQ09ORklHLm5ldGJsb2NrU3VmZml4KSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBibG9jayBkaXN0cmlidXRpb24gb2YgbG9jYWwgcHVmZnNcbiAgICAgICAgdmFyIHVzZXJuYW1lcyA9IFtwdWZmLnVzZXJuYW1lXVxuICAgICAgICBpZihwdWZmLmtleXMpXG4gICAgICAgICAgICB1c2VybmFtZXMgPSB1c2VybmFtZXMuY29uY2F0KE9iamVjdC5rZXlzKHB1ZmYua2V5cykpXG5cbiAgICAgICAgdXNlcm5hbWVzID0gdXNlcm5hbWVzLm1hcChQQi5Vc2Vycy5qdXN0VXNlcm5hbWUpXG4gICAgICAgIHZhciBzdWZmaXhlcyA9IHVzZXJuYW1lcy5tYXAoZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAgICAgICAgIHZhciBjaHVua3MgPSB1c2VybmFtZS5zcGxpdCgnLicpXG4gICAgICAgICAgICByZXR1cm4gY2h1bmtzW2NodW5rcy5sZW5ndGgtMV1cbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIGlmKHN1ZmZpeGVzLmluZGV4T2YoUEIuQ09ORklHLm5ldGJsb2NrU3VmZml4KSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgUEIuTmV0LnNlbmRQdWZmVG9TZXJ2ZXIocHVmZikgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIHNlcnZlcidzIHB1ZmZsaXN0XG5cbiAgICBQQi5OZXQuUDJQLnNlbmRQdWZmVG9QZWVycyhwdWZmKSAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyb2FkY2FzdCBpdCB0byBwZWVyc1xufVxuXG4vKipcbiAqIGFkZCBhIHB1ZmYgdG8gdGhlIHNlcnZlcidzIHB1ZmZsaXN0XG4gKiBAcGFyYW0gIHtvYmplY3R9IHB1ZmZcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuUEIuTmV0LnNlbmRQdWZmVG9TZXJ2ZXIgPSBmdW5jdGlvbihwdWZmKSB7XG4gICAgLy8gVEhJTks6IHRoaXMgaXMgZmlyZS1hbmQtZm9yZ2V0LCBidXQgd2Ugc2hvdWxkIGRvIHNvbWV0aGluZyBzbWFydCBpZiB0aGUgbmV0d29yayBpcyBvZmZsaW5lIG9yIGl0IG90aGVyd2lzZSBmYWlscy4gXG4gICAgLy8gICAgICAgIG9uIHRoZSBvdGhlciBoYW5kLCB3ZSdsbCBwcm9iYWJseSB3YW50IHRvIGRvIHRoaXMgd2l0aCBzb2NrZXRzIGluc3RlYWQgb2YgYWpheCB1bHRpbWF0ZWx5Li4uXG4gICAgLy8gICAgICAgIG9yIG1hbmFnZSBpdCBlbnRpcmVseSB3aXRoIHJvdXRpbmcsIGV2ZW4gZm9yIHNlcnZlci1zZW50IHB1ZmZzP1xuICAgIFxuICAgIHZhciBkYXRhID0geyB0eXBlOiAnYWRkUHVmZidcbiAgICAgICAgICAgICAgICwgcHVmZjogSlNPTi5zdHJpbmdpZnkocHVmZikgfVxuICAgICAgICAgICAgICAgXG4gICAgcmV0dXJuIFBCLk5ldC5QQnBvc3QoUEIuQ09ORklHLnB1ZmZBcGksIGRhdGEpXG4gICAgICAgICAgICAgICAgIC5jYXRjaChQQi5jYXRjaEVycm9yKCdDb3VsZCBub3Qgc2VuZCBwdWZmIHRvIHNlcnZlcicpKVxufVxuXG4vKipcbiAqIGZldGNoIGEgcGFydGljdWxhciB1c2VyUmVjb3JkXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICB1c2VybmFtZSBcbiAqIEBwYXJhbSAge3N0cmluZ30gIGNhcGEgXG4gKiBAcmV0dXJuIHtwcm9taXNlfSBvbiBmdWxmaWxsZWQgcGFzc2VzIHRoZSB1c2VyIHJlY29yZCBhcyBvYmplY3QsIG90aGVyd2lzZSByZS10aHJvdyBlcnJvclxuICovXG5QQi5OZXQuZ2V0VXNlclJlY29yZCA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBjYXBhKSB7XG4gICAgdmFyIHVybCAgID0gUEIuQ09ORklHLnVzZXJBcGlcbiAgICBcbiAgICB2YXIgdmVyc2lvbmVkVXNlcm5hbWUgPSBQQi5Vc2Vycy5tYWtlVmVyc2lvbmVkKHVzZXJuYW1lLCBjYXBhKVxuICAgIHVzZXJuYW1lID0gUEIuVXNlcnMuanVzdFVzZXJuYW1lKHZlcnNpb25lZFVzZXJuYW1lKVxuICAgIFxuICAgIGlmKGNhcGEgIT09IDApIC8vIDAgc2lnbmFscyB0aGF0IHdlIG5lZWQgdG8gZmV0Y2ggdGhlIGxhdGVzdCB1c2VyUmVjb3JkXG4gICAgICAgIGNhcGEgPSBQQi5Vc2Vycy5qdXN0Q2FwYSh2ZXJzaW9uZWRVc2VybmFtZSlcbiAgICBcbiAgICB2YXIgZGF0YSAgPSB7IHR5cGU6ICdnZXRVc2VyJ1xuICAgICAgICAgICAgICAgICwgdXNlcm5hbWU6IHVzZXJuYW1lXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgaWYoY2FwYSlcbiAgICAgICAgZGF0YS5jYXBhID0gY2FwYVxuXG4gICAgcmV0dXJuIFBCLk5ldC5QQmdldEpTT04odXJsLCBkYXRhKVxufVxuXG5cbi8qKlxuICogbW9kaWZ5IGEgdXNlciByZWNvcmRcbiAqIEBwYXJhbSAge3B1ZmZ9ICAgcHVmZiBhIHNpZ25lZCBwdWZmIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gb2YgbW9kaWZpZWQgdXNlciByZWNvcmRcbiAqIEByZXR1cm4ge29iamVjdH0gcHJvbWlzZSBmb3IgbmV3IHVzZXJSZWNvcmQgb3IgZXJyb3Igd2hlbiB0aGUgdXBkYXRlIGZhaWxzXG4gKi9cblBCLk5ldC51cGRhdGVVc2VyUmVjb3JkID0gZnVuY3Rpb24ocHVmZikge1xuICAgIHZhciBkYXRhID0geyB0eXBlOiAndXBkYXRlVXNpbmdQdWZmJ1xuICAgICAgICAgICAgICAgLCBwdWZmOiBwdWZmXG4gICAgICAgICAgICAgICB9XG5cbiAgICB2YXIgcHJvbSA9IFBCLk5ldC5QQnBvc3QoUEIuQ09ORklHLnVzZXJBcGksIGRhdGEpXG4gICAgXG4gICAgcmV0dXJuIHByb20uY2F0Y2goUEIuY2F0Y2hFcnJvcignU2VuZGluZyB1c2VyIHJlY29yZCBtb2RpZmljYXRpb24gcHVmZiBmYWlsZWQnKSlcbiAgICAgICAgICAgICAgIC50aGVuKEpTT04ucGFyc2UpIC8vIFRISU5LOiB0aGlzIHRocm93cyBvbiBpbnZhbGlkIEpTT05cbiAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHVzZXJSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gUEIuVXNlcnMucHJvY2Vzcyh1c2VyUmVjb3JkKVxuICAgICAgICAgICAgICAgICAgICAgICB8fCBQQi50aHJvd0Vycm9yKCdJbnZhbGlkIHVzZXIgcmVjb3JkJywgSlNPTi5zdHJpbmdpZnkodXNlclJlY29yZCkpXG4gICAgICAgICAgICAgICB9KVxufVxuXG5cblxuLyoqXG4gKiBQQi5OZXQgcHJvbWlzZS1iYXNlZCBYSFIgbGF5ZXJcbiAqIFxuICogV2UgdXNlIHByb21pc2VzIGFzIG91ciBkZWZhdWx0IGNvbmN1cnJlbmN5IGNvbnN0cnVjdCwgXG4gKiBiZWNhdXNlIHVsdGltYXRlbHkgdGhpcyBwbGF0Zm9ybSBpcyBjb21wb3NlZCBvZiBhIFxuICogaHVnZSBzZXQgb2YgaW50ZXJkZXBlbmRlbnQgYXN5bmMgY2FsbHMgd2hpY2ggbW9zdGx5IFxuICogZWFjaCByZXNvbHZlIHRvIGEgc2luZ2xlIGltbXV0YWJsZSBlbnRpdHkgXG4gKiAtLSBha2EgdGhlIHByb21pc2Ugc3dlZXQgc3BvdC5cbiAqIFxuICogQHBhcmFtICB7c3RyaW5nfSB1cmwgICAgIHJlcXVlc3RlZCB1cmxcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBcbiAqIEBwYXJhbSAge29iamVjdH0gZGF0YSAgICBcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuUEIuTmV0LnhociA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucywgZGF0YSkge1xuICAgIC8vLy8gdmVyeSBzaW1wbGUgcHJvbWlzZS1iYXNlZCBYSFIgaW1wbGVtZW50YXRpb25cbiAgICBcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICAgICAgICByZXEub3BlbihvcHRpb25zLm1ldGhvZCB8fCAnR0VUJywgdXJsKVxuICAgICAgICBcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5oZWFkZXJzIHx8IHt9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgb3B0aW9ucy5oZWFkZXJzW2tleV0pXG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICB2YXIgZm9ybWRhdGEgPSBuZXcgRm9ybURhdGEoKVxuICAgICAgICBPYmplY3Qua2V5cyhkYXRhIHx8IHt9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBkYXR1bSA9IHR5cGVvZiBkYXRhW2tleV0gPT0gJ29iamVjdCcgPyBQQi5zdHJpbmdpZnlKU09OKGRhdGFba2V5XSkgOiBkYXRhW2tleV1cbiAgICAgICAgICAgIGZvcm1kYXRhLmFwcGVuZChrZXksIGRhdHVtKVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLnR5cGUpXG4gICAgICAgICAgICByZXEucmVzcG9uc2VUeXBlID0gb3B0aW9ucy50eXBlXG4gICAgICAgICAgICAgICAgXG4gICAgICAgIHJlcS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHJlcS5zdGF0dXMgIT0gMjAwKSAvLyBzaWxseSBzYWZhcmlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KFBCLm1ha2VFcnJvcihyZXEuc3RhdHVzVGV4dCkpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHJlcS5yZXNwb25zZVR5cGUgPT0gJ2pzb24nICYmIHJlcS5yZXNwb25zZSA9PT0gbnVsbCkgLy8gTk9URTogdHJhcHMgSlNPTmlmaWVkICdudWxsJyByZXNwb25zZXMgYWxzbzogdXNlIGVtcHR5IHN0cmluZyBvciBbXSB0byBpbmRpY2F0ZSBhbiBlbXB0eSByZXN1bHRcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KFBCLm1ha2VFcnJvcihcIkludmFsaWQgSlNPTiBpbiByZXNwb25zZVwiLCByZXEucmVzcG9uc2UpKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXNvbHZlKCAocmVxLnJlc3BvbnNlVHlwZSAhPSBvcHRpb25zLnR5cGUpIC8vIG1hbnVhbGx5IGNvbnZlcnQganNvbiBmb3Igb2xkIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgICAmJiBvcHRpb25zLnR5cGUgPT0gJ2pzb24nID8gUEIucGFyc2VKU09OKHJlcS5yZXNwb25zZSkgOiByZXEucmVzcG9uc2UpXG4gICAgICAgIH1cblxuICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICByZWplY3QoUEIubWFrZUVycm9yKFwiTmV0d29yayBFcnJvclwiLCBldmVudCwgJ25ldHdvcmtFcnJvcicpKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXEub250aW1lb3V0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHJlamVjdChQQi5tYWtlRXJyb3IoXCJUaW1lb3V0IEVycm9yXCIsIGV2ZW50LCAndGltZW91dEVycm9yJykpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJlcS50aW1lb3V0ID0gUEIuQ09ORklHLm5ldHdvcmtUaW1lb3V0XG5cbiAgICAgICAgcmVxLnNlbmQoZm9ybWRhdGEpXG4gICAgfSlcbn1cblxuLyoqXG4gKiByZXF1ZXN0IGFuIHVybCwgZ2V0IHJlc3VsdCBpbiBKU09OXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVybCAgICBcbiAqIEBwYXJhbSAge29iamVjdH0gcGFyYW1zIFxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5QQi5OZXQuZ2V0SlNPTiA9IGZ1bmN0aW9uKHVybCwgcGFyYW1zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7IGhlYWRlcnM6IHsgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICAgICAgICAsICBtZXRob2Q6ICdHRVQnXG4gICAgICAgICAgICAgICAgICAsICAgIHR5cGU6ICdqc29uJ1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9IHBhcmFtcyB8fCB7fVxuICAgIHZhciBlbmMgPSBmdW5jdGlvbihwYXJhbSkge3JldHVybiAhcGFyYW0gJiYgcGFyYW0hPT0wID8gJycgOiBlbmNvZGVVUklDb21wb25lbnQocGFyYW0pfVxuICAgIHZhciBxc3RyaW5nID0gT2JqZWN0LmtleXMocGFyYW1zKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBrZXkpIHtyZXR1cm4gYWNjICsgZW5jKGtleSkgKyc9JysgZW5jKHBhcmFtc1trZXldKSArJyYnfSwgJz8nKVxuXG4gICAgcmV0dXJuIFBCLk5ldC54aHIodXJsICsgcXN0cmluZywgb3B0aW9ucykgXG59XG5cblxuLyoqXG4gKiBzZW5kIGEgcG9zdCByZXF1ZXN0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVybCAgcmVxdWVzdGVkIHVybFxuICogQHBhcmFtICB7b2JqZWN0fSBkYXRhIFxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5QQi5OZXQucG9zdCA9IGZ1bmN0aW9uKHVybCwgZGF0YSkge1xuICAgIHZhciBvcHRpb25zID0geyBoZWFkZXJzOiB7ICAgXG4vLyAgICAgICAgICdDb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgLCAnQ29udGVudC1sZW5ndGgnOiBwYXJhbXMubGVuZ3RoXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICwgICAgICdDb25uZWN0aW9uJzogJ2Nsb3NlJyAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICwgIG1ldGhvZDogJ1BPU1QnXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICByZXR1cm4gUEIuTmV0Lnhocih1cmwsIG9wdGlvbnMsIGRhdGEpXG59XG5cblxuXG4vKipcbiAqIEEgY3VzdG9taXplZCB3cmFwcGVyIG92ZXIgdGhlIGJhc2UgeGhyIHByb21pc2Ugd3JhcHBlclxuICogQHBhcmFtICB7c3RyaW5nfSB1cmwgICAgXG4gKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtcyBcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuUEIuTmV0LlBCeGhyID0gZnVuY3Rpb24odXJsLCBvcHRpb25zLCBkYXRhKSB7XG4gICAgdmFyIHByb20gPSBQQi5OZXQueGhyKHVybCwgb3B0aW9ucywgZGF0YSlcbiAgICAgICAgXG4gICAgcmV0dXJuIHByb20udGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBpZihyZXNwb25zZS5GQUlMKVxuICAgICAgICAgICAgcmV0dXJuIFBCLnRocm93REhURXJyb3IocmVzcG9uc2UuRkFJTClcblxuICAgICAgICBpZih0eXBlb2YgcmVzcG9uc2UgPT0gJ3N0cmluZycgJiYgcmVzcG9uc2Uuc2xpY2UoMCw2KSA9PSAne1wiRkFJTCcpXG4gICAgICAgICAgICByZXR1cm4gUEIudGhyb3dESFRFcnJvcigoUEIucGFyc2VKU09OKHJlc3BvbnNlKXx8e30pLkZBSUwpXG5cbiAgICAgICAgUEIucnVuSGFuZGxlcnMoJ25ldHdvcmtyZXNwb25zZScsIHJlc3BvbnNlKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgfSlcbn1cblxuUEIuTmV0LlBCcG9zdCA9IGZ1bmN0aW9uKHVybCwgZGF0YSkge1xuICAgIC8vIFRISU5LOiBzaG91bGQgd2UgcGFyYW1ldHJpemUgb3ZlciB0aGUgZGlzcGF0Y2ggZnVuY3Rpb24/XG4gICAgdmFyIG9wdGlvbnMgPSB7IGhlYWRlcnM6IHt9XG4gICAgICAgICAgICAgICAgICAsICBtZXRob2Q6ICdQT1NUJ1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXG4gICAgcmV0dXJuIFBCLk5ldC5QQnhocih1cmwsIG9wdGlvbnMsIGRhdGEpXG59XG5cblBCLk5ldC5QQmdldEpTT04gPSBmdW5jdGlvbih1cmwsIHBhcmFtcykge1xuICAgIC8vIFRISU5LOiBzaG91bGQgd2UgcGFyYW1ldHJpemUgb3ZlciB0aGUgZGlzcGF0Y2ggZnVuY3Rpb24/XG4gICAgdmFyIG9wdGlvbnMgPSB7IGhlYWRlcnM6IHsgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICAgICAgICAsICBtZXRob2Q6ICdHRVQnXG4gICAgICAgICAgICAgICAgICAsICAgIHR5cGU6ICdqc29uJ1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9IHBhcmFtcyB8fCB7fVxuICAgIHZhciBlbmMgPSBmdW5jdGlvbihwYXJhbSkge3JldHVybiAhcGFyYW0gJiYgcGFyYW0hPT0wID8gJycgOiBlbmNvZGVVUklDb21wb25lbnQocGFyYW0pfVxuICAgIHZhciBxc3RyaW5nID0gT2JqZWN0LmtleXMocGFyYW1zKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBrZXkpIHtyZXR1cm4gYWNjICsgZW5jKGtleSkgKyc9JysgZW5jKHBhcmFtc1trZXldKSArJyYnfSwgJz8nKVxuXG4gICAgcmV0dXJuIFBCLk5ldC5QQnhocih1cmwgKyBxc3RyaW5nLCBvcHRpb25zKSBcbn1cblxuXG5cblxuXG5cblxuXG4vKlxuXG4gICAgUEIuTmV0IFBlZXItdG8tUGVlciBsYXllclxuXG4gICAgV2UncmUgY3VycmVudGx5IHVzaW5nIHBlZXIuanMgdG8gbmVnb3RpYXRlIHRoZSBXZWJSVEMgY29ubmVjdGlvbi4gVGhlcmUncyBhIGxvdCBvZiB3b3JrIGxlZnQgdG8gYmUgZG9uZSBoZXJlLlxuXG4qL1xuXG5cblBCLk5ldC5QMlAgPSB7fVxuUEIuTmV0LlAyUC5wZWVycyA9IHt9XG5cbi8qKlxuICogaW5pdGlhbGl6ZSB0aGUgcGVlci10by1wZWVyIGxheWVyXG4gKi9cblBCLk5ldC5QMlAuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIE5PVEU6IHlvdSBoYXZlIHRvIG1hbnVhbGx5IGVuYWJsZSB0aGUgUDJQIGxheWVyIHZpYSBjb25maWcgb3IgaW5pdCBvcHRpb25zXG4gICAgLy8gZS5nLiBQQi5pbml0KHtlbmFibGVQMlA6IHRydWV9KVxuICAgIC8vIG9yICAgUEIuQ09ORklHLmVuYWJsZVAyUCA9IHRydWVcbiAgICBpZighUEIuQ09ORklHLmVuYWJsZVAyUCkgcmV0dXJuIGZhbHNlXG4gICAgXG4gICAgUEIuTmV0LlAyUC5QZWVyID0gbmV3IFBlZXIoeyBob3N0OiAgJzE2Mi4yMTkuMTYyLjU2J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgcG9ydDogIDkwMDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHBhdGg6ICAnLydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIGRlYnVnOiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICBcbiAgICBQQi5OZXQuUDJQLlBlZXIub24oJ29wZW4nLCBQQi5OZXQuUDJQLm9wZW5QZWVyQ29ubmVjdGlvbilcbiAgICBQQi5OZXQuUDJQLlBlZXIub24oJ2Nvbm5lY3Rpb24nLCBQQi5OZXQuUDJQLmNvbm5lY3Rpb24pXG59XG5cbi8qKlxuICogdG8gcmVsb2FkIHBlZXJzXG4gKiBAcmV0dXJuIHtvYmplY3R9IFxuICovXG5QQi5OZXQuUDJQLnJlbG9hZFBlZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFBCLk5ldC5QMlAuUGVlci5saXN0QWxsUGVlcnMoUEIuTmV0LlAyUC5oYW5kbGVQZWVycylcbn1cblxuLyoqXG4gKiBvcGVuIHBlZXIgY29ubmVjdGlvblxuICogQHBhcmFtICB7c3RyaW5nfSBpZCBcbiAqIEByZXR1cm4ge29iamVjdFtdfVxuICovXG5QQi5OZXQuUDJQLm9wZW5QZWVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgLy8gT1BUOiBkbyB3ZSByZWFsbHkgbmVlZCB0aGlzPyBcbiAgICAvLyBUSElOSzogd2h5IG5vdCBqdXN0IGNhbGwgUEIuTmV0LlAyUC5yZWxvYWRQZWVycz9cbiAgICByZXR1cm4gUEIuTmV0LlAyUC5QZWVyLmxpc3RBbGxQZWVycyhQQi5OZXQuUDJQLmhhbmRsZVBlZXJzKVxufVxuXG4vKipcbiAqIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBjb25uZWN0aW9uXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuUEIuTmV0LlAyUC5jb25uZWN0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgIFBCLk5ldC5QMlAucmVsb2FkUGVlcnMoKSAvLyBPUFQ6IGRvIHdlIHJlYWxseSBuZWVkIHRoaXM/IFxuXG4gICAgcmV0dXJuIGNvbm5lY3Rpb24ub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIFBCLkRhdGEuYWRkU2hlbGxzVGhlbk1ha2VBdmFpbGFibGUoZGF0YSkgLy8gVE9ETzogcGFzcyBhIGNhbGxiYWNrIGluIHRvIFBCLk5ldCBpbnN0ZWFkIG9mIGNhbGxpbmcgdGhpcyBkaXJlY3RseVxuICAgIH0pXG59XG5cbi8qKlxuICogdG8gaGFuZGxlIHBlZXJzXG4gKiBAcGFyYW0gIHtvYmplY3R9IHBlZXJzIFxuICogQHJldHVybiB7Ym9vbGVhbn0gICBcbiAqL1xuUEIuTmV0LlAyUC5oYW5kbGVQZWVycyA9IGZ1bmN0aW9uKHBlZXJzKSB7XG4gICAgcGVlcnMuZm9yRWFjaChmdW5jdGlvbihwZWVyKSB7XG4gICAgICAgIGlmKFBCLk5ldC5QMlAucGVlcnNbcGVlcl0pIFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIFBCLk5ldC5QMlAucGVlcnNbcGVlcl0gPSBQQi5OZXQuUDJQLlBlZXIuY29ubmVjdChwZWVyKVxuICAgIH0pXG59XG5cbi8qKlxuICogdG8gc2VuZCBwdWZmIHRvIHBlZXJzXG4gKiBAcGFyYW0gIHtvYmplY3R9IHB1ZmZcbiAqL1xuUEIuTmV0LlAyUC5zZW5kUHVmZlRvUGVlcnMgPSBmdW5jdGlvbihwdWZmKSB7XG4gICAgZm9yKHZhciBwZWVyIGluIFBCLk5ldC5QMlAucGVlcnMpIHtcbiAgICAgICAgUEIuTmV0LlAyUC5wZWVyc1twZWVyXS5zZW5kKHB1ZmYpXG4gICAgfVxufSIsIi8qXG5cbiAgICBEYXRhIG1hbmFnZW1lbnQgZm9yIHRoZSBFdmVyeUJpdCBwbGF0Zm9ybS5cbiAgICBcbiAgICBBbGwgcHVmZi1yZWxhdGVkIGRhdGEgZmxvd3MgdGhyb3VnaCBoZXJlOlxuICAgIGNhY2hpbmcsIHBlcnNpc3RlbmNlLCBvcHRpbWl6YXRpb25zIGFuZCBuZXR3b3JrIGFjY2VzcyBhcmUgIGhhbmRsZWQgd2l0aGluIHRoaXMgbW9kdWxlLlxuXG4gICAgQ29weXJpZ2h0IDIwMTQgRXZlcnlCaXQuIFNlZSBSRUFETUUgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbiAqL1xuXG5QQi5EYXRhID0ge31cbi8vIFBCLkRhdGEucHVmZnMgPSBbXVxuUEIuRGF0YS5ib25paSA9IHt9XG5QQi5EYXRhLnNoZWxscyA9IFtdXG5QQi5EYXRhLnNoZWxsU29ydCA9IHt9XG4vLyBQQi5EYXRhLnNoZWxmID0gW11cblBCLkRhdGEucGVuZGluZ1B1ZmZQcm9taXNlcyA9IHt9XG5cblBCLkRhdGEucHJvZmlsZXMgPSB7fVxuXG5QQi5EYXRhLmluaXQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYoIW9wdGlvbnMuZGlzYWJsZVB1YmxpY1B1ZmZzKVxuICAgICAgICBQQi5EYXRhLmltcG9ydFNoZWxscygpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlbG9hZCByZWxldmFudCBzaGVsbHNcbiAgICBQQi5hZGRCZWZvcmVTd2l0Y2hJZGVudGl0eUhhbmRsZXIoUEIuRGF0YS5yZW1vdmVBbGxQcml2YXRlU2hlbGxzKSAgIC8vIGNsZWFyIHByaXZhdGUgY2FjaGVzXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8gbmV3IGdyYXBoIHN0dWZmIC8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblBCLkRhdGEuYWRkU2lnQXNWZXJ0ZXggPSBmdW5jdGlvbihzaWcpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IFBCLkRhdGEuZ3JhcGgudihzaWcpLnJ1bigpXG4gICAgXG4gICAgaWYobWF0Y2hlcy5sZW5ndGgpIHJldHVybiBmYWxzZSAgICAgICAgIC8vIHJldHVybnMgZmFsc2UgaWYgbm90aGluZyBoYXBwZW5zXG4gICAgXG4gICAgcmV0dXJuIFBCLkRhdGEuZ3JhcGguYWRkVmVydGV4KHtfaWQ6IHNpZywgbmFtZTogc2lnLCB0eXBlOiAnc2hlbGwnfSkgfHwgdHJ1ZVxufVxuXG5QQi5EYXRhLmFkZFNoZWxsQXNWZXJ0ZXggPSBmdW5jdGlvbihzaGVsbCkge1xuICAgIHZhciBtYXRjaGVzID0gUEIuRGF0YS5ncmFwaC52KHNoZWxsLnNpZykucnVuKClcbiAgICBcbiAgICBpZighbWF0Y2hlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBQQi5EYXRhLmdyYXBoLmFkZFZlcnRleCh7IF9pZDogc2hlbGwuc2lnLCBuYW1lOiBzaGVsbC5zaWcsIHNoZWxsOiBzaGVsbCwgdHlwZTogJ3NoZWxsJyB9KSB8fCB0cnVlXG4gICAgXG4gICAgdmFyIHZlcnRleCA9IG1hdGNoZXNbMF1cbiAgICBpZih2ZXJ0ZXguc2hlbGwpIHJldHVybiBmYWxzZSAgICAgICAgICAgLy8gTk9URTogcmV0dXJucyBmYWxzZSBpZiBpdCBkb2VzIG5vdGhpbmdcbiAgICBcbiAgICByZXR1cm4gdmVydGV4LnNoZWxsID0gc2hlbGwgICAgICAgICAgICAgLy8gTk9URTogbXV0YXRpb24gJiBwb2ludGVyIHNldHRpbmdcbn1cblxuUEIuRGF0YS5hZGRTaGVsbFVzZXJuYW1lQXNWZXJ0ZXggPSBmdW5jdGlvbihzaGVsbCkge1xuICAgIC8vLy8gYWRkIHNoZWxsLnVzZXJuYW1lIHRvIGdyYXBoIGFuZCBjb25uZWN0IHRoZW0gdXBcbiAgICBcbiAgICB2YXIgdXNlcm5hbWUgPSBzaGVsbC51c2VybmFtZVxuICAgIHZhciBtYXRjaGVzID0gUEIuRGF0YS5ncmFwaC52KHVzZXJuYW1lKS5ydW4oKVxuICAgIHZhciB2ZXJ0ZXggPSBtYXRjaGVzWzBdXG4gICAgXG4gICAgaWYoIXZlcnRleCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRISU5LOiBtYWtlIHVzZXJuYW1lcyB1bmlxdWUgbGlrZSBVU0VSTkFNRTo6PHVzZXJuYW1lPiBvciBzb21ldGhpbmdcbiAgICAgICAgdmVydGV4ID0gUEIuRGF0YS5ncmFwaC5hZGRWZXJ0ZXgoeyBfaWQ6IHVzZXJuYW1lLCBuYW1lOiB1c2VybmFtZSwgdHlwZTogJ3VzZXJuYW1lJyB9KVxuICAgIGVsc2VcbiAgICAgICAgaWYoUEIuRGF0YS5ncmFwaC52KHNoZWxsLnNpZykub3V0KCdhdXRob3InKS5wcm9wZXJ0eSgnbmFtZScpLnJ1bigpWzBdID09IHVzZXJuYW1lKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIFxuICAgIC8vIFRPRE86IGFkZCBlYXN5IGZpbHRlcmluZyBieSB2ZXJ0ZXggdHlwZSBmb3IgYm90aCAndicgYW5kIGFsc28gb3V0ViBldGNcbiAgICBQQi5EYXRhLmdyYXBoLmFkZEVkZ2UoeyBfb3V0OiBzaGVsbC5zaWcsIF9pbjogc2hlbGwudXNlcm5hbWUsIF9sYWJlbDogJ2F1dGhvcid9KVxufVxuXG5QQi5EYXRhLmdyYXBoID0gRGFnb2JhLmdyYXBoKClcblxuUEIuRGF0YS5hZGRUb0dyYXBoID0gZnVuY3Rpb24oc2hlbGxzKSB7XG4gICAgc2hlbGxzLmZvckVhY2goUEIuRGF0YS5hZGRTaGVsbEFzVmVydGV4KVxuICAgIHNoZWxscy5mb3JFYWNoKFBCLkRhdGEuYWRkU2hlbGxVc2VybmFtZUFzVmVydGV4KVxuICAgIFBCLnJ1bkhhbmRsZXJzKCdyZWxhdGlvbnNoaXAnLCBzaGVsbHMpXG59XG5cbi8vIFRPRE86IGFsaWFzIGNoaWxkcmVuKCkgYXMgLmluKCdwYXJlbnQnKSBhbmQgcGFyZW50cygpIGFzIC5vdXQoJ3BhcmVudCcpIGFuZCB1c2UgdGhvc2UgaW5zdGVhZCAoaGFsdmVzICMgb2YgZWRnZXMpXG5cbi8vLy8vLy8vLy8vLy8vLy8vIGVuZCBuZXcgZ3JhcGggc3R1ZmYgLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5cblBCLkRhdGEuZ2V0QWxsTXlTaGVsbHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcHVibGljU2hlbGxzID0gUEIuRGF0YS5nZXRQdWJsaWNTaGVsbHMoKVxuICAgIHZhciBwcml2YXRlU2hlbGxzID0gUEIuRGF0YS5nZXRDdXJyZW50RGVjcnlwdGVkTGV0dGVycygpXG4gICAgcmV0dXJuIHB1YmxpY1NoZWxscy5jb25jYXQocHJpdmF0ZVNoZWxscylcbn1cblxuXG4vKipcbiAqIGdldCBhbGwgY3VycmVudGx5IGtub3duIHNoZWxsc1xuICogQHJldHVybiB7U2hlbGxbXX1cbiAqL1xuUEIuRGF0YS5nZXRTaGVsbHMgPSBmdW5jdGlvbigpIHtcbiAgICAvLy8vIEdldCBhbGwgY3VycmVudGx5IGtub3duIHNoZWxsc1xuICAgIC8vIE5PVEU6IGFsd2F5cyB1c2UgdGhpcyBhY2Nlc3NvciBpbnN0ZWFkIG9mIHJlZmVyZW5jaW5nIFBCLkRhdGEuc2hlbGxzIGRpcmVjdGx5LCBhcyB3aGF0IHRoaXMgZnVuY3Rpb24gZG9lcyB3aWxsIGNoYW5nZS5cbiAgICByZXR1cm4gUEIuRGF0YS5zaGVsbHNcbn1cblxuLyoqXG4gKiBnZXQgYWxsIHB1YmxpYyBzaGVsbHNcbiAqIEByZXR1cm5zIHtTaGVsbFtdfVxuICovXG5QQi5EYXRhLmdldFB1YmxpY1NoZWxscyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vLy8gR2V0IGFsbCBwdWJsaWMgc2hlbGxzXG4gICAgdmFyIHNoZWxscyA9IFBCLkRhdGEuZ2V0U2hlbGxzKClcbiAgICByZXR1cm4gc2hlbGxzLmZpbHRlcihmdW5jdGlvbihzaGVsbCkge3JldHVybiAhc2hlbGwua2V5c30pXG59XG5cbi8qKlxuICogR2V0IGNhY2hlZCBzaGVsbHMgYnkgc2lnXG4gKiBAcGFyYW0ge3N0cmluZ30gc2lnXG4gKiBAcmV0dXJucyB7c2hlbGxbXX1cbiAqL1xuUEIuRGF0YS5nZXRDYWNoZWRTaGVsbEJ5U2lnID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgcmV0dXJuIFBCLkRhdGEuc2hlbGxTb3J0W3NpZ11cbiAgICAvLyByZXR1cm4gUEIuRGF0YS5nZXRTaGVsbHMoKS5maWx0ZXIoZnVuY3Rpb24oc2hlbGwpIHsgcmV0dXJuIHNpZyA9PT0gc2hlbGwuc2lnIH0pWzBdXG59XG5cbi8qKlxuICogYWRkcyBib251c1xuICogQHBhcmFtIHtvYmplY3R9IHB1ZmZcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5QQi5EYXRhLmFkZEJvbnVzID0gZnVuY3Rpb24ocHVmZiwga2V5LCB2YWx1ZSkge1xuICAgIC8vLy8gdGhpcyBzaW11bGF0ZXMgYSBXZWFrTWFwXG4gICAgLy8gVEhJTks6IHdlJ2xsIG5lZWQgdG8gcHJvdmlkZSBzb21lIEdDIGhlcmVcbiAgICB2YXIgaWQgPSBwdWZmLnNpZ1xuICAgIFxuICAgIGlmKCFQQi5EYXRhLmJvbmlpW2lkXSlcbiAgICAgICAgUEIuRGF0YS5ib25paVtpZF0gPSB7fVxuICAgIFxuICAgIFBCLkRhdGEuYm9uaWlbaWRdW2tleV0gPSB2YWx1ZVxufVxuXG4vKipcbiAqIGdldHMgYm9udXNcbiAqIEBwYXJhbSBwdWZmXG4gKiBAcGFyYW0ga2V5XG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5QQi5EYXRhLmdldEJvbnVzID0gZnVuY3Rpb24ocHVmZiwga2V5KSB7XG4gICAgLy8vLyBwdWxsIGZyb20gb3VyIEZhdXhXZWFrTWFwXG4gICAgdmFyIGlkID0gcHVmZi5zaWdcbiAgICB2YXIgcHVmZkJvbmlpID0gUEIuRGF0YS5ib25paVtpZF1cbiAgICByZXR1cm4gcHVmZkJvbmlpICYmIHB1ZmZCb25paVtrZXldXG59XG5cblxuXG5cblxuXG5cblxuUEIuRGF0YS5hZGRTdGFyID0gZnVuY3Rpb24oc2lnLCB1c2VybmFtZSwgc3RhcnNpZykge1xuICAgIC8vIFRPRE86IGNvbnNpZGVyIG1vdmluZyB0aGlzIHRvIGEgbW9kdWxlXG4gICAgXG4gICAgdmFyIGZhdXhzaGVsbCA9IHtzaWc6IHNpZ30gLy8gVEhJTks6IGNhbiB3ZSBmb3JtYWxpemUgdGhpcz9cbiAgICB2YXIgc3RhclN0YXRzID0gUEIuRGF0YS5nZXRCb251cyhmYXV4c2hlbGwsICdzdGFyU3RhdHMnKSB8fCB7c2NvcmU6IDAsIGZyb206IHt9fVxuICAgIFxuICAgIHN0YXJTdGF0cy5mcm9tW3VzZXJuYW1lXSA9IHN0YXJzaWcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRtaXR0ZWRseSBzdHJhbmdlLCBidXQgaGVscGZ1bCB3aGVuIHVuc3RhcnJpbmdcbiAgICBzdGFyU3RhdHMuc2NvcmUgPSBQQi5EYXRhLnNjb3JlU3RhcnMoT2JqZWN0LmtleXMoc3RhclN0YXRzLmZyb20pKSAgLy8gT1BUOiBPKG5eMikgaW4gc3RhcnMtcGVyLXB1ZmZcbiAgICBcbiAgICBQQi5EYXRhLmFkZEJvbnVzKGZhdXhzaGVsbCwgJ3N0YXJTdGF0cycsIHN0YXJTdGF0cylcbn1cblxuUEIuRGF0YS5yZW1vdmVTdGFyID0gZnVuY3Rpb24oc2lnLCB1c2VybmFtZSkge1xuICAgIC8vIFRPRE86IGNvbnNpZGVyIG1vdmluZyB0aGlzIHRvIGEgbW9kdWxlXG4gICAgXG4gICAgdmFyIGZhdXhzaGVsbCA9IHtzaWc6IHNpZ30gLy8gVEhJTks6IHllIGdhZHMgaXMgdGhpcyB1Z2x5XG4gICAgdmFyIHN0YXJTdGF0cyA9IFBCLkRhdGEuZ2V0Qm9udXMoZmF1eHNoZWxsLCAnc3RhclN0YXRzJykgfHwge3Njb3JlOiAwLCBmcm9tOiB7fX1cbiAgICBcbiAgICBkZWxldGUgc3RhclN0YXRzLmZyb21bdXNlcm5hbWVdXG4gICAgXG4gICAgc3RhclN0YXRzLnNjb3JlID0gUEIuRGF0YS5zY29yZVN0YXJzKE9iamVjdC5rZXlzKHN0YXJTdGF0cy5mcm9tKSkgIC8vIE9QVDogTyhuXjIpIGluIHN0YXJzLXBlci1wdWZmXG4gICAgXG4gICAgUEIuRGF0YS5hZGRCb251cyhmYXV4c2hlbGwsICdzdGFyU3RhdHMnLCBzdGFyU3RhdHMpXG59XG5cblBCLkRhdGEuc2NvcmVTdGFycyA9IGZ1bmN0aW9uKHVzZXJuYW1lcykge1xuICAgIFxuICAgIHJldHVybiAwXG4gICAgXG4gICAgLy8gVE9ETzogbW92ZSB0aGlzIGludG8gYSBtb2R1bGVcbiAgICAvKlxuICAgIHZhciB0bHVTY29yZSA9IDA7XG4gICAgdmFyIHN1U2NvcmUgPSAwO1xuICAgIHZhciBzY29yZVByZWYgPSBCb3Jvbi5zaGFsbG93X2NvcHkocHVmZndvcmxkcHJvcHMudmlldy5zY29yZSk7XG4gICAgZm9yICh2YXIgayBpbiBzY29yZVByZWYpIHtcbiAgICAgICAgaWYgKHNjb3JlUHJlZltrXSkge1xuICAgICAgICAgICAgdmFyIHMgPSBwYXJzZUZsb2F0KHNjb3JlUHJlZltrXSk7XG4gICAgICAgICAgICBpZiAoaXNOYU4ocykpXG4gICAgICAgICAgICAgICAgcyA9IHBhcnNlRmxvYXQocHVmZndvcmxkZGVmYXVsdHMudmlldy5zY29yZVtrXSk7XG4gICAgICAgICAgICBzY29yZVByZWZba10gPSBzO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHVzZXJuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKHVzZXJuYW1lKSB7XG4gICAgICAgIGlmICh1c2VybmFtZS5pbmRleE9mKCcuJykgPT0gLTEpIHtcbiAgICAgICAgICAgIHRsdVNjb3JlICs9IHNjb3JlUHJlZi50bHVWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1U2NvcmUgKz0gc2NvcmVQcmVmLnN1VmFsdWU7XG4gICAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIHZhciBzY29yZSA9IHRsdVNjb3JlICsgTWF0aC5taW4oc2NvcmVQcmVmLm1heFN1VmFsdWUsIHN1U2NvcmUpO1xuICAgIHNjb3JlID0gc2NvcmUudG9GaXhlZCgxKTtcbiAgICBpZiAoc2NvcmUgPT0gcGFyc2VJbnQoc2NvcmUpKSBzY29yZSA9IHBhcnNlSW50KHNjb3JlKTtcbiAgICByZXR1cm4gc2NvcmVcbiAgICAqL1xufVxuXG5cblxuXG5cblxuXG5cbi8qXG4gICAgU29tZSBuZXcgc2hlbGwgaGFuZGxpbmcgZXF1aXBtZW50LiBOZWVkIHRvIGludGVncmF0ZSB0aGlzIG1vcmUgZGVlcGx5IGFuZCBjbGVhbiBhbmQgdGVzdC5cbiovXG5cblBCLkRhdGEuYWRkU2hlbGxzVGhlbk1ha2VBdmFpbGFibGUgPSBmdW5jdGlvbihzaGVsbHMpIHtcbiAgICAvLy8vIGFkZHMgc2hlbGxzIHRvIHRoZSBzeXN0ZW0sIHRoZW4gcmV0dXJucyBhIHJlcG9ydCBvbiBpdHMgcHJvZ3Jlc3NcbiAgICBcbiAgICAvLyByZXBvcnQuZGVsaXZlcmVkOiAxMFxuICAgIC8vIHJlcG9ydC52YWxpZDogOFxuICAgIC8vIHJlcG9ydC5uZXdfc2hlbGxzOiA3XG4gICAgLy8gcmVwb3J0Lm5ld19wdWZmczogNVxuICAgIC8vIHJlcG9ydC5HQzogMFxuICAgIFxuICAgIC8vIHJlcG9ydC5wdWJsaWM6IDJcbiAgICAvLyByZXBvcnQuc3RhcnM6IDBcbiAgICBcbiAgICAvLyByZXBvcnQucHJpdmF0ZV9wcm9taXNlOiB7c2lnczpbXSwgZmFpbGVkOiB9XG4gICAgXG4gICAgLy8gcmVwb3J0LnB1YmxpY19wdWZmX3NpZ3M6IFtdXG4gICAgXG4gICAgZnVuY3Rpb24gbm90KGZ1bikge3JldHVybiBmdW5jdGlvbih4KSB7cmV0dXJuICFmdW4oeCl9fVxuICAgIFxuICAgIHZhciByZXBvcnQgPSB7Y291bnRzOiB7fX1cbiAgICBcbiAgICBzaGVsbHMgPSBBcnJheS5pc0FycmF5KHNoZWxscykgPyBzaGVsbHMgOiBbc2hlbGxzXVxuICAgIHJlcG9ydC5jb3VudHMuZGVsaXZlcmVkID0gc2hlbGxzLmxlbmd0aFxuICAgIFxuICAgIHNoZWxscyA9IHNoZWxscy5maWx0ZXIoUEIuaXNWYWxpZFNoZWxsKVxuICAgIHJlcG9ydC5jb3VudHMudmFsaWQgPSBzaGVsbHMubGVuZ3RoXG4gICAgXG4gICAgcmVwb3J0Lm1ldGEgPSBQQi5EYXRhLmhhbmRsZU1ldGFQdWZmcyhzaGVsbHMpXG4gICAgXG4gICAgc2hlbGxzID0gc2hlbGxzLmZpbHRlcihub3QoUEIuRGF0YS5pc01ldGFQdWZmKSlcbiAgICByZXBvcnQuY291bnRzLm5vbm1ldGEgPSBzaGVsbHMubGVuZ3RoXG4gICAgXG4gICAgcmVwb3J0LnByaXZhdGVfcHJvbWlzZSA9IFBCLkRhdGEuaGFuZGxlUHJpdmF0ZVB1ZmZzKHNoZWxscylcbiAgICBcbiAgICBzaGVsbHMgPSBzaGVsbHMuZmlsdGVyKG5vdChQQi5EYXRhLmlzUHJpdmF0ZVB1ZmYpKVxuICAgIHJlcG9ydC5jb3VudHMucHVibGljID0gc2hlbGxzLmxlbmd0aFxuICAgIFxuICAgIHNoZWxscyA9IFBCLkRhdGEuaGFuZGxlQW5kRmlsdGVyRXhpc3RpbmdTaGVsbHMoc2hlbGxzKVxuICAgIHJlcG9ydC5jb3VudHMubmV3X3B1YmxpYyA9IHJlcG9ydC5jb3VudHMucHVibGljIC0gc2hlbGxzLmxlbmd0aFxuICAgIFxuICAgIFBCLkRhdGEuaGFuZGxlTmV3UHVibGljU2hlbGxzKHNoZWxscylcbiAgICBcbiAgICBzaGVsbHMgPSBQQi5EYXRhLmhhbmRsZUFuZEZpbHRlckJ5R0Moc2hlbGxzKVxuICAgIHJlcG9ydC5jb3VudHMuZ2MgPSByZXBvcnQuY291bnRzLm5ld19wdWJsaWMgLSBzaGVsbHMubGVuZ3RoXG5cbiAgICByZXBvcnQucHVibGljX3B1ZmZfc2lncyA9IHNoZWxscy5tYXAoUEIucHJvcCgnc2lnJykpXG4gICAgXG4gICAgUEIucnVuSGFuZGxlcnMoJ25ld1B1ZmZzJywgc2hlbGxzKVxuICAgIFBCLnJ1bkhhbmRsZXJzKCduZXdQdWZmUmVwb3J0JywgcmVwb3J0KVxuICAgIFxuICAgIHJldHVybiByZXBvcnRcbn1cblxuXG5QQi5EYXRhLmhhbmRsZU1ldGFQdWZmcyA9IGZ1bmN0aW9uKHNoZWxscykge1xuICAgIC8vIFRPRE86IG1vdmUgdGhpcyB0byBhIG1vZHVsZVxuICAgIHZhciBtZXRhcHVmZnMgPSBzaGVsbHMuZmlsdGVyKFBCLkRhdGEuaXNNZXRhUHVmZilcbiAgICBcbiAgICBtZXRhcHVmZnMuZm9yRWFjaChmdW5jdGlvbihzaGVsbCkge1xuICAgICAgICB2YXIgc2lnID0gc2hlbGwucGF5bG9hZC5jb250ZW50XG4gICAgICAgIFBCLkRhdGEuYWRkU3RhcihzaWcsIHNoZWxsLnVzZXJuYW1lLCBzaGVsbC5zaWcpXG4gICAgfSlcbiAgICBcbiAgICByZXR1cm4ge3N0YXJzOiBtZXRhcHVmZnMubGVuZ3RofVxufVxuXG5QQi5EYXRhLmlzTWV0YVB1ZmYgPSBmdW5jdGlvbihzaGVsbCkge1xuICAgIC8vIFRPRE86IG1vdmUgdGhpcyB0byBhIG1vZHVsZVxuICAgIHJldHVybiBzaGVsbC5wYXlsb2FkLnR5cGUgPT0gJ3N0YXInICAgIFxufVxuXG5cblBCLkRhdGEuaGFuZGxlUHJpdmF0ZVB1ZmZzID0gZnVuY3Rpb24oc2hlbGxzKSB7XG4gICAgdmFyIHByaXZhdGVwdWZmcyA9IHNoZWxscy5maWx0ZXIoUEIuRGF0YS5pc1ByaXZhdGVQdWZmKSAgICBcbiAgICByZXR1cm4gUEIuRGF0YS5pbmdlc3RFbmNyeXB0ZWRTaGVsbHMocHJpdmF0ZXB1ZmZzKSAvLyBUT0RPOiB0aGlzIHJldHVybnMgb3VyIHByb21pc2UgcmVwb3J0XG59XG5cblxuUEIuRGF0YS5pc1ByaXZhdGVQdWZmID0gZnVuY3Rpb24oc2hlbGwpIHtcbiAgICByZXR1cm4gc2hlbGwucGF5bG9hZC50eXBlID09ICdlbmNyeXB0ZWRwdWZmJ1xufVxuXG5cblBCLkRhdGEuaGFuZGxlQW5kRmlsdGVyRXhpc3RpbmdTaGVsbHMgPSBmdW5jdGlvbihzaGVsbHMpIHtcbiAgICAvLyBUSElOSzogdGhpcyBjYW4ndCBhbnN3ZXIgdGhlIHF1ZXN0aW9uIG9mIFwiZGlkIHdlIHVwZGF0ZWQgYW4gZXhpc3Rpbmcgc2hlbGwgd2l0aCBjb250ZW50XCI/XG4gICAgcmV0dXJuIHNoZWxscy5maWx0ZXIoZnVuY3Rpb24oc2hlbGwpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gUEIuRGF0YS5nZXRDYWNoZWRTaGVsbEJ5U2lnKHNoZWxsLnNpZylcblxuICAgICAgICBpZihleGlzdGluZykge1xuICAgICAgICAgICAgaWYoZXhpc3RpbmcucGF5bG9hZC5jb250ZW50KSByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIGlmKHNoZWxsLnBheWxvYWQuY29udGVudCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2UgICAgLy8gaXQncyBhbiBlbXB0eSBzaGVsbFxuICAgICAgICAgICAgZXhpc3RpbmcucGF5bG9hZC5jb250ZW50ID0gc2hlbGwucGF5bG9hZC5jb250ZW50ICAgICAgICAvLyBhZGQgdGhlIG1pc3NpbmcgY29udGVudFxuICAgICAgICAgICAgcmV0dXJuIHRydWUgLy8gdHJ1ZSBiZWNhdXNlIHdlIGNoYW5nZWQgaXRcbiAgICAgICAgfVxuICAgIH0pXG59XG5cblxuUEIuRGF0YS5oYW5kbGVOZXdQdWJsaWNTaGVsbHMgPSBmdW5jdGlvbihzaGVsbHMpIHtcbiAgICBzaGVsbHMuZm9yRWFjaChmdW5jdGlvbihzaGVsbCkge1xuICAgICAgICBQQi5EYXRhLnNoZWxscy5wdXNoKHNoZWxsKVxuICAgICAgICBQQi5EYXRhLnNoZWxsU29ydFtzaGVsbC5zaWddID0gc2hlbGxcbiAgICB9KVxuXG4gICAgUEIuRGF0YS5hZGRUb0dyYXBoKHNoZWxscylcbiAgICBQQi5EYXRhLnJhdGVTb21lUHVmZnMoc2hlbGxzKVxuICAgIFBCLkRhdGEucGVyc2lzdFNoZWxscygpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyb3AgbmV3IHN0dWZmIGludG8gbG9jYWxTdG9yYWdlXG59XG5cblxuUEIuRGF0YS5oYW5kbGVBbmRGaWx0ZXJCeUdDID0gZnVuY3Rpb24oc2hlbGxzKSB7XG4gICAgdmFyIGNvbXBhY3RlZCA9IFBCLkRhdGEuZ2FyYmFnZUNvbXBhY3RvcigpICAgICAgICAgICAgICAgICAgLy8gT1BUOiBjYWxsIHRoaXMgZWFybGllclxuICAgIGlmKCFjb21wYWN0ZWQpIHJldHVybiBzaGVsbHNcbiAgICBcbiAgICByZXR1cm4gc2hlbGxzLm1hcChQQi5wcm9wKCdzaWcnKSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgR0MgZWF0cyBwdWZmcyB0aGlzIHNwaXRzIHRoZW0gb3V0XG4gICAgICAgICAgICAgICAgIC5tYXAoUEIuRGF0YS5nZXRDYWNoZWRTaGVsbEJ5U2lnKVxuICAgICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG59XG5cblxuLyoqXG4gKiB0byBwZXJzaXN0IHNoZWxsc1xuICogQHBhcmFtIHtTaGVsbFtdfVxuICogQHJldHVybnMgeyhib29sZWFufCopfVxuICovXG5QQi5EYXRhLnBlcnNpc3RTaGVsbHMgPSBmdW5jdGlvbihzaGVsbHMpIHtcbiAgICBpZihQQi5DT05GSUcubm9Mb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAvLyBUSElOSzogdGhpcyBpcyBvbmx5IGZvciBkZWJ1Z2dpbmcgYW5kIGRldmVsb3BtZW50XG4gICAgXG4gICAgLy8gVEhJTks6IHdoZW4gd2UgcmVjZWl2ZSBzaGVsbHMgZGlyZWN0bHkgd2Ugc2hvdWxkIGNvbXBhY3QgdGhlbSB0b29cbiAgICBpZighc2hlbGxzKSBcbiAgICAgICAgc2hlbGxzID0gZnVuY3Rpb24oKSB7cmV0dXJuIFBCLkRhdGEuZ2V0U2hlbGxzRm9yTG9jYWxTdG9yYWdlKCl9IC8vIHRodW5rZWQgZm9yIHBlcmZcbiAgICBcbiAgICAvLyB3aGVuIHlvdSBzYXZlIHNoZWxscywgR0Mgb2xkZXIgXCJ1bmludGVyZXN0aW5nXCIgc2hlbGxzIGFuZCBqdXN0IHNhdmUgdGhlIGxhdGVzdCBvbmVzXG4gICAgLy8gVEhJTks6IGlzIHRoaXMgbXkgcHVmZj8gdGhlbiBzYXZlIGl0LiBvdGhlcndpc2UsIGlmIHRoZSBjb250ZW50IGlzID4xayBzdHJpcCBpdCBkb3duLlxuICAgIC8vIFRISU5LOiB3ZSBuZWVkIGtub3dsZWRnZSBvZiBvdXIgdXNlciByZWNvcmRzIGhlcmUuLi4gaG93IGRvIHdlIGdldCB0aGF0PyBcbiAgICAvLyBQQi5EYXRhLmludGVyZXN0aW5nX3VzZXJuYW1lcz9cbiAgICBcbiAgICAvLyBzaGVsbHMgPSBzaGVsbHMuZmlsdGVyKGZ1bmN0aW9uKHNoZWxsKSB7IHJldHVybiAhc2hlbGwucGF5bG9hZC5jb250ZW50IHx8IChzaGVsbC5wYXlsb2FkLmNvbnRlbnQubGVuZ3RoIDwgMTAwMCkgfSlcbiAgICBcbiAgICBQQi5QZXJzaXN0LnNhdmUoJ3NoZWxscycsIHNoZWxscylcbn1cblxuXG5cblBCLkRhdGEuZ2V0Q29udmVyc2F0aW9uUHVmZnMgPSBmdW5jdGlvbihjb252b0lkLCBvZmZzZXQsIGJhdGNoc2l6ZSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gICAgYmF0Y2hzaXplID0gYmF0Y2hzaXplIHx8IFBCLkNPTkZJRy5wYWdlQmF0Y2hTaXplIHx8IDEwXG4gICAgXG4gICAgdmFyIHByb21cbiAgICBwcm9tID0gUEIuTmV0LmdldENvbnZlcnNhdGlvblB1ZmZzKGNvbnZvSWQsIGJhdGNoc2l6ZSwgb2Zmc2V0KVxuICAgIHByb20gPSBwcm9tLnRoZW4oUEIuRGF0YS5hZGRTaGVsbHNUaGVuTWFrZUF2YWlsYWJsZSlcbiAgICByZXR1cm4gcHJvbVxufVxuXG5QQi5EYXRhLmdldENvbnZlcnNhdGlvblB1ZmZzID0gUEIucHJvbWlzZU1lbW9pemUoUEIuRGF0YS5nZXRDb252ZXJzYXRpb25QdWZmcywgZnVuY3Rpb24oa2V5LCByZXBvcnQpIHtcbiAgICByZXBvcnQucHJpdmF0ZV9wcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIFBCLnJlbW92ZVByb21pc2VQZW5kaW5nKGtleSlcbiAgICB9KVxufSlcblxuXG4vKipcbiAqIHRvIGltcG9ydCBzaGVsbHMgZnJvbSBsb2NhbCBhbmQgcmVtb3RlIHNvdXJjZXNcbiAqL1xuUEIuRGF0YS5pbXBvcnRTaGVsbHMgPSBmdW5jdGlvbigpIHtcbiAgICAvLy8vIGZldGNoIHNoZWxscyBmcm9tIGxvY2FsIGFuZCByZW1vdGUgc291cmNlc1xuICAgIFxuICAgIC8vIFRISU5LOiB0aGlzIHNob3VsZCB0YWtlIGEgc2V0IG9mIHJvdXRlcyBzbyB3ZSBjYW4gcGFzcyB0aGVtIHRvIGltcG9ydFJlbW90ZVNoZWxsc1xuICAgIFxuICAgIC8vIGdyYWIgdGhlIGxvY2FsIHNoZWxscyBhbmQgYWRkIHRoZW0gdG8gdGhlIHN5c3RlbVxuICAgIC8vIHRoZW4gZ3JhYiBzb21lIHJlbW90ZSBzaGVsbHMgKGxhdGVzdCAxMDApIGFuZCBjb21wYXJlIHRoZW1cbiAgICAvLyBnbyBiYWNrIHVudGlsIHdlIGZpbGwgaW4gdGhlIGdhcHMsIG9yIGhpdCB0aGUgdGhyZXNob2xkICg1MDA/KVxuICAgIFxuICAgIC8vIHdoZW4geW91IHdhbnQgdG8gbG9vayBhdCBzaGVsbHMgdGhhdCBkb24ndCBleGlzdCwgbGlrZSB3aGVuIHNjcm9sbGluZywgZ3JhYiB0aGVtIGFzIGEgYmF0Y2hcbiAgICBcbiAgICBQQi5EYXRhLmltcG9ydExvY2FsU2hlbGxzKClcbiAgICAvLyBQQi5EYXRhLmdldE1vcmVTaGVsbHMoKVxuICAgIFBCLkRhdGEuaW1wb3J0UmVtb3RlU2hlbGxzKClcbiAgICAvLyBQQi5EYXRhLmltcG9ydEFsbFN0YXJzKClcbn1cblxuLyoqXG4gKiB0byBpbXBvcnQgbG9jYWwgc2hlbGxzXG4gKi9cblBCLkRhdGEuaW1wb3J0TG9jYWxTaGVsbHMgPSBmdW5jdGlvbigpIHsgICAvLyBjYWxsYmFjaykge1xuICAgIC8vIFBCLkRhdGEuc2hlbGxzID0gUEIuUGVyc2lzdC5nZXQoJ3NoZWxscycpIHx8IFtdXG4gICAgdmFyIGxvY2FsU2hlbGxzID0gUEIuUGVyc2lzdC5nZXQoJ3NoZWxscycpIHx8IFtdXG4gICAgXG4gICAgUEIuRGF0YS5hZGRTaGVsbHNUaGVuTWFrZUF2YWlsYWJsZShsb2NhbFNoZWxscylcbn1cblxuXG5QQi5EYXRhLmltcG9ydEFsbFN0YXJzID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETzogY29uc2lkZXIgbW92aW5nIHRoaXMgdG8gYSBtb2R1bGVcbiAgICB2YXIgcHJvbSA9IFBCLk5ldC5nZXRTdGFyU2hlbGxzKClcbiAgICBwcm9tLnRoZW4oUEIuRGF0YS5hZGRTaGVsbHNUaGVuTWFrZUF2YWlsYWJsZSlcbn1cblxuXG5QQi5EYXRhLmhvcnJpZFN0YXNoID0ge31cblxuUEIuRGF0YS5pc0JhZEVudmVsb3BlID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgcmV0dXJuIFBCLkRhdGEuaG9ycmlkU3Rhc2hbc2lnXVxufVxuXG5QQi5EYXRhLmFkZEJhZEVudmVsb3BlID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgUEIuRGF0YS5ob3JyaWRTdGFzaFtzaWddID0gdHJ1ZVxufVxuXG5cblBCLkRhdGEuY3VycmVudERlY3J5cHRlZExldHRlcnMgPSBbXVxuUEIuRGF0YS5jdXJyZW50RGVjcnlwdGVkTGV0dGVyTWFwID0ge31cblxuUEIuRGF0YS5nZXRDdXJyZW50RGVjcnlwdGVkTGV0dGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vLy8gTk9URTogYWx3YXlzIHVzZSB0aGlzIGluc3RlYWQgb2YgaGl0dGluZyBjdXJyZW50RGVjcnlwdGVkTGV0dGVycyBkaXJlY3RseSwgYXMgdGhpcyBmdW5jdGlvbiBtYXkgY2hhbmdlXG4gICAgcmV0dXJuIFBCLkRhdGEuY3VycmVudERlY3J5cHRlZExldHRlcnNcbn1cblxuUEIuRGF0YS5nZXREZWNyeXB0ZWRMZXR0ZXJCeVNpZyA9IGZ1bmN0aW9uKHNpZykge1xuICAgIGlmKFBCLkRhdGEuY3VycmVudERlY3J5cHRlZExldHRlck1hcFtzaWddKVxuICAgICAgICByZXR1cm4gUEIuRGF0YS5jdXJyZW50RGVjcnlwdGVkTGV0dGVyTWFwW3NpZ11cbn1cblxuXG5QQi5EYXRhLmFkZERlY3J5cHRlZExldHRlciA9IGZ1bmN0aW9uKGxldHRlciwgZW52ZWxvcGUpIHtcbiAgICAvLyBUSElOSzogaG93IGNhbiB3ZSBhdm9pZCBkb2luZyB0aGlzICdleGlzdGluZyBsZXR0ZXInIGNoZWNrIHR3aWNlP1xuICAgIHZhciBtYXliZUxldHRlciA9IFBCLkRhdGEuZ2V0RGVjcnlwdGVkTGV0dGVyQnlTaWcoZW52ZWxvcGUuc2lnKVxuICAgIGlmKG1heWJlTGV0dGVyKSByZXR1cm4gZmFsc2VcbiAgICBcbiAgICBpZihsZXR0ZXIucGF5bG9hZC50eXBlID09ICdpZGVudGl0eScpIHJldHVybiBmYWxzZSAgICAgICAgICAgICAvLyBUSElOSzogd2hlcmUgc2hvdWxkIHRoaXMgbGl2ZT9cbiAgICBcbiAgICBQQi5EYXRhLmN1cnJlbnREZWNyeXB0ZWRMZXR0ZXJzLnB1c2gobGV0dGVyKVxuICAgIFxuICAgIFBCLkRhdGEuY3VycmVudERlY3J5cHRlZExldHRlck1hcFtlbnZlbG9wZS5zaWddID0gbGV0dGVyICAgICAgIC8vIGxldHRlciBpcyBhIHB1ZmYgdG9vXG4gICAgUEIuRGF0YS5jdXJyZW50RGVjcnlwdGVkTGV0dGVyTWFwW2xldHRlci5zaWddID0gbGV0dGVyICAgICAgICAgLy8gc3Rhc2ggaXQgYm90aCB3YXlzXG4gICAgUEIuRGF0YS5hZGRCb251cyhsZXR0ZXIsICdlbnZlbG9wZScsIGVudmVsb3BlKSAgICAgICAgICAgICAgICAgLy8gbWFyayBpdCBmb3IgbGF0ZXJcbiAgICBcbiAgICBQQi5EYXRhLmFkZFRvR3JhcGgoW2xldHRlcl0pXG5cbiAgICByZXR1cm4gdHJ1ZVxufVxuXG5QQi5EYXRhLnJlbW92ZUFsbFByaXZhdGVTaGVsbHMgPSBmdW5jdGlvbigpIHtcbiAgICBQQi5EYXRhLmN1cnJlbnREZWNyeXB0ZWRMZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24oc2hlbGwpIHtcbiAgICAgICAgUEIuRGF0YS5yZW1vdmVTaGVsbEZyb21DYWNoZShzaGVsbC5zaWcpXG4gICAgfSlcbiAgICBcbiAgICBQQi5EYXRhLmN1cnJlbnREZWNyeXB0ZWRMZXR0ZXJNYXAgPSB7fVxuICAgIFBCLkRhdGEuY3VycmVudERlY3J5cHRlZExldHRlcnMgPSBbXSBcbn1cblxuXG5cblBCLkRhdGEuZW5jcnlwdFB1ZmYgPSBmdW5jdGlvbihsZXR0ZXIsIG15UHJpdmF0ZVdpZiwgdXNlclJlY29yZHMsIHByaXZhdGVFbnZlbG9wZUFsaWFzKSB7XG4gICAgLy8vLyBzdGljayBhIGxldHRlciBpbiBhbiBlbnZlbG9wZS4gdXNlclJlY29yZHMgbXVzdCBiZSBmdWxseSBpbnN0YW50aWF0ZWQuXG4gICAgdmFyIHB1ZmZrZXkgPSBQQi5DcnlwdG8uZ2V0UmFuZG9tS2V5KCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGEgbmV3IHJhbmRvbSBrZXlcbiAgICBcbiAgICB2YXIgbGV0dGVyQ2lwaGVyID0gUEIuQ3J5cHRvLmVuY3J5cHRXaXRoQUVTKEpTT04uc3RyaW5naWZ5KGxldHRlciksIHB1ZmZrZXkpICAvLyBlbmNyeXB0IHRoZSBsZXR0ZXJcbiAgICB2YXIgdmVyc2lvbmVkVXNlcm5hbWUgPSBsZXR0ZXIudXNlcm5hbWVcbiAgICBcbiAgICBpZihwcml2YXRlRW52ZWxvcGVBbGlhcykge1xuICAgICAgICBteVByaXZhdGVXaWYgPSBwcml2YXRlRW52ZWxvcGVBbGlhcy5kZWZhdWx0XG4gICAgICAgIHZlcnNpb25lZFVzZXJuYW1lID0gUEIuVXNlcnMubWFrZVZlcnNpb25lZChwcml2YXRlRW52ZWxvcGVBbGlhcy51c2VybmFtZSwgcHJpdmF0ZUVudmVsb3BlQWxpYXMuY2FwYSlcbiAgICB9XG4gICAgXG4gICAgdmFyIGVudmVsb3BlID0gUEIuRGF0YS5wYWNrYWdlUHVmZlN0cnVjdHVyZSh2ZXJzaW9uZWRVc2VybmFtZSwgbGV0dGVyLnJvdXRlcyAgLy8gZW52ZWxvcGUgaXMgYWxzbyBhIHB1ZmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICwgJ2VuY3J5cHRlZHB1ZmYnLCBsZXR0ZXJDaXBoZXIsIHt9LCBsZXR0ZXIucHJldmlvdXMpICAvLyBpdCBpbmNsdWRlcyB0aGUgbGV0dGVyXG4gICAgXG4gICAgZW52ZWxvcGUua2V5cyA9IFBCLkNyeXB0by5jcmVhdGVLZXlQYWlycyhwdWZma2V5LCBteVByaXZhdGVXaWYsIHVzZXJSZWNvcmRzKSAgLy8gYWRkIGRlY3J5cHRpb24ga2V5c1xuICAgIGVudmVsb3BlLnNpZyA9IFBCLkNyeXB0by5zaWduUHVmZihlbnZlbG9wZSwgbXlQcml2YXRlV2lmKSAgICAgICAgICAgICAgICAgICAgIC8vIHNpZ24gdGhlIGVudmVsb3BlXG4gICAgXG4gICAgcmV0dXJuIGVudmVsb3BlXG59XG5cblBCLkRhdGEuZXh0cmFjdExldHRlckZyb21FbnZlbG9wZSA9IGZ1bmN0aW9uKGVudmVsb3BlKSB7ICAgICAgICAgICAgICAgIC8vIHRoZSBlbnZlbG9wZSBpcyBhIHB1ZmZcbiAgICBpZihQQi5EYXRhLmlzQmFkRW52ZWxvcGUoZW52ZWxvcGUuc2lnKSkgXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQmFkIGVudmVsb3BlJykgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmbGFnZ2VkIGFzIGludmFsaWQgZW52ZWxvcGVcblxuICAgIHZhciBtYXliZUxldHRlciA9IFBCLkRhdGEuZ2V0RGVjcnlwdGVkTGV0dGVyQnlTaWcoZW52ZWxvcGUuc2lnKSAgICAgLy8gaGF2ZSB3ZSBhbHJlYWR5IG9wZW5lZCBpdD9cbiAgICBcbiAgICBpZihtYXliZUxldHRlcilcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYXliZUxldHRlcikgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmUgdG8gZXhpc3RpbmcgbGV0dGVyXG4gICAgXG4gICAgdmFyIHByb20gPSBQQi5EYXRhLmdldERlY3J5cHRlZFB1ZmZQcm9taXNlKGVudmVsb3BlKSAgICAgICAgICAgICAgICAvLyBkbyB0aGUgZGVjcnlwdGlvblxuICAgIFxuICAgIHJldHVybiBwcm9tLmNhdGNoKGZ1bmN0aW9uKGVycikgeyByZXR1cm4gZmFsc2UgfSlcbiAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGxldHRlcikge1xuICAgICAgICAgICAgICAgICAgIGlmKCFsZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgUEIuRGF0YS5hZGRCYWRFbnZlbG9wZShlbnZlbG9wZS5zaWcpICAgICAgICAgICAgIC8vIGRlY3J5cHRpb24gZmFpbGVkOiBmbGFnIGVudmVsb3BlXG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQQi50aHJvd0Vycm9yKCdJbnZhbGlkIGVudmVsb3BlJykgICAgICAgICAvLyBiYWlsIG91dFxuICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgIHJldHVybiBsZXR0ZXJcbiAgICAgICAgICAgICAgIH0pXG4gICAgXG59XG5cblBCLkRhdGEuZ2V0RGVjcnlwdGVkUHVmZlByb21pc2UgPSBmdW5jdGlvbihlbnZlbG9wZSkge1xuICAgIC8vLy8gcHVsbCBhIGxldHRlciBvdXQgb2YgdGhlIGVudmVsb3BlIC0tIHJldHVybnMgYSBwcm9taXNlIVxuXG4gICAgaWYoIWVudmVsb3BlIHx8ICFlbnZlbG9wZS5rZXlzKSBcbiAgICAgICAgcmV0dXJuIFBCLmVtcHR5UHJvbWlzZSgnRW52ZWxvcGUgZG9lcyBub3QgY29udGFpbiBhbiBlbmNyeXB0ZWQgbGV0dGVyJylcbiAgICBcbiAgICB2YXIgc2VuZGVyVmVyc2lvbmVkVXNlcm5hbWUgPSBlbnZlbG9wZS51c2VybmFtZVxuICAgIHZhciB1c2VyUHJvbSA9IFBCLlVzZXJzLmdldFVzZXJSZWNvcmRQcm9taXNlKHNlbmRlclZlcnNpb25lZFVzZXJuYW1lKVxuICAgIFxuICAgIHZhciBwdWZmcHJvbSA9IHVzZXJQcm9tXG4gICAgLmNhdGNoKFBCLmNhdGNoRXJyb3IoJ1VzZXIgcmVjb3JkIGFjcXVpc2l0aW9uIGZhaWxlZCcpKVxuICAgIC50aGVuKGZ1bmN0aW9uKHNlbmRlclZlcnNpb25lZFVzZXJSZWNvcmQpIHtcbiAgICAgICAgdmFyIHByb20gLy8gdXNlZCBmb3IgbGVha2luZyBzZWN1cmUgcHJvbWlzZVxuXG4gICAgICAgIFBCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oaWRlbnRpdGllcywgY3VycmVudFVzZXJuYW1lKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBsZWFrcyBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdW5lbmNyeXB0ZWQgcHVmZlxuICAgICAgICBcbiAgICAgICAgICAgIHZhciBpZGVudGl0eSA9IGlkZW50aXRpZXNbY3VycmVudFVzZXJuYW1lXVxuICAgICAgICAgICAgdmFyIGFsaWFzZXMgID0gaWRlbnRpdHkuYWxpYXNlc1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nVXNlcm5hbWUgPSAnJ1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdG9wOiBmb3IodmFyIGtleWtleSBpbiBlbnZlbG9wZS5rZXlzKSB7ICAgICAgICAgICAgIC8vIG1hdGNoIG91ciBhbGlhc2VzIGFnYWluc3QgYWxsIHJlY2lwaWVudHNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsaWFzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsaWFzID0gYWxpYXNlc1tpXVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoYWxpYXMudXNlcm5hbWUgPT0ga2V5a2V5KSB7ICAgICAgICAgICAgICAvLyBvbmx5IGZvciBvbGQsIHVudmVyc2lvbmVkIHVzZXJuYW1lc1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdVc2VybmFtZSA9IGFsaWFzLnVzZXJuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayB0b3BcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnNpb25Vc2VybmFtZSA9IFBCLlVzZXJzLm1ha2VWZXJzaW9uZWQoYWxpYXMudXNlcm5hbWUsIGFsaWFzLmNhcGEpXG4gICAgICAgICAgICAgICAgICAgIGlmKHZlcnNpb25Vc2VybmFtZSA9PSBrZXlrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nVXNlcm5hbWUgPSB2ZXJzaW9uVXNlcm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighbWF0Y2hpbmdVc2VybmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUEIudGhyb3dFcnJvcignTm8ga2V5IGZvdW5kIGZvciBjdXJyZW50IHVzZXInKVxuXG4gICAgICAgICAgICB2YXIgcmVjaXBpZW50UHJpdmF0ZUtleSA9IGFsaWFzLnByaXZhdGVEZWZhdWx0S2V5XG4gICAgICAgICAgICB2YXIgc2VuZGVyUHVibGljS2V5ID0gc2VuZGVyVmVyc2lvbmVkVXNlclJlY29yZC5kZWZhdWx0S2V5XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHByb20gPSBQQi5EYXRhLmRlY3J5cHRQdWZmQWxtb3N0Rm9yUmVhbHMoZW52ZWxvcGUsIHNlbmRlclB1YmxpY0tleSwgbWF0Y2hpbmdVc2VybmFtZSwgcmVjaXBpZW50UHJpdmF0ZUtleSlcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gcHJvbVxuICAgIH0pXG4gICAgXG4gICAgcmV0dXJuIHB1ZmZwcm9tXG59XG5cblBCLkRhdGEuZGVjcnlwdFB1ZmZBbG1vc3RGb3JSZWFscyA9IGZ1bmN0aW9uKGVudmVsb3BlLCBzZW5kZXJQdWJsaWNLZXksIHJlY2lwaWVudFVzZXJuYW1lLCByZWNpcGllbnRQcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZXR1cm4gUEIuY3J5cHRvd29ya2VyXG4gICAgICAgICAgICAgPyBQQi53b3JrZXJzZW5kKCAnZGVjcnlwdFB1ZmZGb3JSZWFscydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIFsgZW52ZWxvcGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgc2VuZGVyUHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHJlY2lwaWVudFVzZXJuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHJlY2lwaWVudFByaXZhdGVLZXkgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgcmVzb2x2ZSwgcmVqZWN0IClcbiAgICAgICAgICAgICA6IHJlc29sdmUoIFBCLmRlY3J5cHRQdWZmRm9yUmVhbHMoIGVudmVsb3BlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBzZW5kZXJQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHJlY2lwaWVudFVzZXJuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCByZWNpcGllbnRQcml2YXRlS2V5ICkgKVxuICAgIH0pXG59XG5cblxuUEIuRGF0YS5wYWNrYWdlUHVmZlN0cnVjdHVyZSA9IGZ1bmN0aW9uKHZlcnNpb25lZFVzZXJuYW1lLCByb3V0ZXMsIHR5cGUsIGNvbnRlbnQsIHBheWxvYWQsIHByZXZpb3VzKSB7XG4gICAgLy8vLyBwYWNrIGFsbCB0aGUgcGFyYW1ldGVycyBpbnRvIGFuIG9iamVjdCB3aXRoIHB1ZmYgc3RydWN0dXJlICh3aXRob3V0IHNpZ25hdHVyZSlcbiAgICBcbiAgICBwYXlsb2FkID0gcGF5bG9hZCB8fCB7fSAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGNoZWNrIGFsbCBvZiB0aGVzZSB2YWx1ZXMgbW9yZSBjYXJlZnVsbHlcbiAgICBwYXlsb2FkLmNvbnRlbnQgPSBjb250ZW50XG4gICAgcGF5bG9hZC50eXBlID0gdHlwZVxuXG4gICAgcm91dGVzID0gcm91dGVzIHx8IFtdXG4gICAgcHJldmlvdXMgPSBwcmV2aW91cyB8fCBmYWxzZSAgICAgICAgICAgICAgICAvLyBmYWxzZSBmb3IgREhUIHJlcXVlc3RzIGFuZCBiZWdpbm5pbmcgb2YgYmxvY2tjaGFpbiwgZWxzZSB2YWxpZCBzaWdcblxuICAgIHZhciBwdWZmID0geyB1c2VybmFtZTogdmVyc2lvbmVkVXNlcm5hbWVcbiAgICAgICAgICAgICAgICwgICByb3V0ZXM6IHJvdXRlc1xuICAgICAgICAgICAgICAgLCBwcmV2aW91czogcHJldmlvdXNcbiAgICAgICAgICAgICAgICwgIHZlcnNpb246ICcwLjEuMCcgICAgICAgICAgICAgIC8vIHZlcnNpb24gYWNjb3VudHMgZm9yIGNyeXB0byB0eXBlIGFuZCBwdWZmIHNoYXBlXG4gICAgICAgICAgICAgICAsICBwYXlsb2FkOiBwYXlsb2FkICAgICAgICAgICAgICAvLyBlYXJseSB2ZXJzaW9ucyB3aWxsIGJlIGFnZ3Jlc3NpdmVseSBkZXByZWNhdGVkIGFuZCB1bnN1cHBvcnRlZFxuICAgICAgICAgICAgICAgfVxuICAgIFxuICAgIHJldHVybiBwdWZmXG59XG5cblxuXG5cblxuXG5cblxuXG5cblxuUEIuRGF0YS5nZXRNb3JlUHJpdmF0ZVB1ZmZzID0gZnVuY3Rpb24odXNlcm5hbWUsIG9mZnNldCwgYmF0Y2hzaXplKSB7XG4gICAgLy8gVEhJTks6IHJhY2UgY29uZGl0aW9uIHdoaWxlIHRvZ2dsaW5nIGlkZW50aXRpZXM/XG4gICAgaWYoIXVzZXJuYW1lKSB1c2VybmFtZSA9IFBCLmdldEN1cnJlbnRVc2VybmFtZSgpXG4gICAgXG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDBcbiAgICAvLyBvZmZzZXQgPSBvZmZzZXQgfHwgUEIuQ09ORklHLmluaXRMb2FkQmF0Y2hTaXplIHx8IDIwXG4gICAgYmF0Y2hzaXplID0gYmF0Y2hzaXplIHx8IFBCLkNPTkZJRy5wYWdlQmF0Y2hTaXplIHx8IDEwXG4gICAgXG4gICAgdmFyIHByb21cbiAgICBwcm9tID0gUEIuTmV0LmdldE15UHJpdmF0ZVB1ZmZzKFBCLmdldEN1cnJlbnRVc2VybmFtZSgpLCBiYXRjaHNpemUsIG9mZnNldCkgLy8gVEhJTks6IHdoeSBzd2l0Y2hlZCBwYXJhbSBvcmRlcj9cbiAgICBwcm9tID0gcHJvbS50aGVuKFBCLkRhdGEuYWRkU2hlbGxzVGhlbk1ha2VBdmFpbGFibGUpXG4gICAgcmV0dXJuIHByb21cbn1cblxuXG5QQi5EYXRhLnVwZGF0ZVByaXZhdGVTaGVsbHMgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICB2YXIgdXNlcm5hbWUgPSBQQi5nZXRDdXJyZW50VXNlcm5hbWUoKVxuICAgIHZhciBiYXRjaHNpemUgPSAxXG4gICAgdmFyIGZ1bGxPclNoZWxsID0gJ2Z1bGwnIC8vIE9QVDoganVzdCBnYXRoZXIgdGhlIHNoZWxsIChvciBzaWcpIGhlcmUgd2hlbiBjaGVja2luZyBsYXRlc3RcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMCAgICAgLy8gICAgICBhY3R1YWxseS4uLiB3ZSBuZWVkIGEgbGlzdCBvZiBhbGwgc2lncyB3ZSd2ZSBlbmNvdW50ZXJlZCAobm90IGp1c3QgZ29vZCBvbmVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgIG90aGVyd2lzZSBiYWQgZW52ZWxvcGVzIChldGMpIGNvdWxkIGJsb2NrIHByaW9yIGdvb2QgY29udGVudC5cblxuICAgIFBCLk5ldC5nZXRNeVByaXZhdGVQdWZmcyh1c2VybmFtZSwgYmF0Y2hzaXplLCBvZmZzZXQsIGZ1bGxPclNoZWxsKVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHNoZWxscykge1xuICAgICAgICAgICAgICB2YXIgc2hlbGwgPSBzaGVsbHNbMF1cbiAgICAgICAgICAgICAgaWYoIXNoZWxsKSByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHZhciBwcm9tID0gUEIuRGF0YS5pbmdlc3RBbkVuY3J5cHRlZFNoZWxsKHNoZWxsKSAvLyBtYW51YWwgYmVjYXVzZSB3ZSBuZWVkIHRoZSBkZWNyeXB0aW9uIHByb21pc2VcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHByb20udGhlbihmdW5jdGlvbihmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgaWYoZnJlc2gpXG4gICAgICAgICAgICAgICAgICAgICAgUEIuRGF0YS51cGRhdGVQcml2YXRlU2hlbGxzKDErb2Zmc2V0KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG59XG5cblxuUEIuRGF0YS5pbmdlc3RFbmNyeXB0ZWRTaGVsbHMgPSBmdW5jdGlvbihzaGVsbHMpIHtcbiAgICB2YXIgcHJvbXMgPSBzaGVsbHMubWFwKFBCLkRhdGEuaW5nZXN0QW5FbmNyeXB0ZWRTaGVsbClcbiAgICBcbiAgICAvLyBOT1RFOiBQcm9taXNlLmFsbCByZWplY3RzIGltbWVkaWF0ZWx5IHVwb24gYW55IHJlamVjdGlvbiwgc28gd2UgaGF2ZSB0byBkbyB0aGlzIG1hbnVhbGx5XG4gICAgXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gcHJvbXMubGVuZ3RoXG4gICAgICAgIHZhciByZXBvcnQgPSB7Z29vZDogMCwgYmFkOiAwLCBnb29kc2lnczogW119XG4gICAgICAgIFxuICAgICAgICAvLyBUT0RPOiBhZGQgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IHdlbnQgd3JvbmcgdG8gdGhlIHJlcG9ydFxuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gdW5oYXBweV9wYXRoKCkge1xuICAgICAgICAgICAgcmVwb3J0LmJhZCsrXG4gICAgICAgICAgICBpZighLS1yZW1haW5pbmcpIHJlc29sdmUocmVwb3J0KVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBwcm9tcy5mb3JFYWNoKGZ1bmN0aW9uKHByb20pIHtcbiAgICAgICAgICAgIHByb20udGhlbihmdW5jdGlvbihsZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZighbGV0dGVyKSByZXR1cm4gdW5oYXBweV9wYXRoKCkgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhdGNoZXMgb2xkIG9yIHdlaXJkIHB1ZmZzIFxuICAgICAgICAgICAgICAgIHJlcG9ydC5nb29kKysgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGlmZmVyZW50aWF0ZSBhYm92ZSBjYXNlc1xuICAgICAgICAgICAgICAgIHJlcG9ydC5nb29kc2lncy5wdXNoKGxldHRlci5zaWcpXG4gICAgICAgICAgICAgICAgaWYoIS0tcmVtYWluaW5nKSByZXNvbHZlKHJlcG9ydClcbiAgICAgICAgICAgIH0sIHVuaGFwcHlfcGF0aCApICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhdGNoZXMgZGVjcnlwdGlvbiBlcnJvcnNcbiAgICAgICAgfSlcbiAgICB9KVxufVxuXG5cblBCLkRhdGEuaW5nZXN0QW5FbmNyeXB0ZWRTaGVsbCA9IGZ1bmN0aW9uKGVudmVsb3BlKSB7XG4gICAgdmFyIHByb20gPSBQQi5EYXRhLmV4dHJhY3RMZXR0ZXJGcm9tRW52ZWxvcGUoZW52ZWxvcGUpXG5cbiAgICBwcm9tID0gcHJvbS50aGVuKGZ1bmN0aW9uKGxldHRlcikge1xuICAgICAgICBpZighbGV0dGVyKSByZXR1cm4gZmFsc2VcbiAgICAgICAgXG4gICAgICAgIHZhciBmcmVzaCA9IFBCLkRhdGEuYWRkRGVjcnlwdGVkTGV0dGVyKGxldHRlciwgZW52ZWxvcGUpICAgICAgICAvLyBhZGQgdGhlIGxldHRlciB0byBvdXIgc3lzdGVtXG4gICAgICAgIGlmKCFmcmVzaCkgcmV0dXJuIGZhbHNlXG4gICAgICAgIFxuICAgICAgICBQQi5ydW5IYW5kbGVycygnbmV3UHVmZnMnLCBbbGV0dGVyXSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIHJlY2VpdmVzIGFuIGFycmF5IG9mIHB1ZmZzXG4gICAgICAgIHJldHVybiBsZXR0ZXJcbiAgICB9KVxuICAgIFxuICAgIHJldHVybiBwcm9tXG4gICAgXG4gICAgLy8gTk9URTogdGhpcyBkb2Vzbid0IGFwcGVhciB0byBkbyBtdWNoLCBtb3N0bHkgYmVjYXVzZSBleHRyYWN0TGV0dGVyRnJvbUVudmVsb3BlIGlzIHF1aXRlIGVmZmVjdGZ1bC5cbiAgICAvLyAgICAgICBpdCBjYWxscyBQQi5EYXRhLmFkZERlY3J5cHRlZExldHRlciBhcyBwYXJ0IG9mIGl0cyBwcm9jZXNzaW5nLCB3aGljaCBkb2VzIGFsbCB0aGUgcmVhbCB3b3JrLlxuICAgIFxuICAgIC8vIFRISU5LOiBjb25zaWRlciBhZGRpbmcgdGhpcyBiYWNrIGluLCB0aG91Z2ggcmVtZW1iZXIgdGhhdCBlYWNoIGRlY3J5cHRpb24gcHVzaGVzIGl0cyBvd24gZXJyb3JzLi4uXG4gICAgLy8gaWYgKGxldHRlcnMubGVuZ3RoICE9IHByaXZhdGVTaGVsbHMubGVuZ3RoKSB7XG4gICAgLy8gICAgIEV2ZW50cy5wdWIoJ3RyYWNrL2RlY3J5cHQvc29tZS1kZWNyeXB0LWZhaWxzJyxcbiAgICAvLyAgICAgICAgICAgICAgICAge2xldHRlcnM6IGxldHRlcnMubWFwKGZ1bmN0aW9uKHApe3JldHVybiBwLnNpZ30pLFxuICAgIC8vICAgICAgICAgICAgICAgICAgcHJpdmF0ZVNoZWxsczogcHJpdmF0ZVNoZWxscy5tYXAoZnVuY3Rpb24ocCl7cmV0dXJuIHAuc2lnfSl9KVxuICAgIC8vIH1cbn1cblxuXG5cblxuLy8gdGhlIHNsb3QgbG9ja2VyIGNvbnRhaW5zIGluZm9ybWF0aW9uIG9uIHF1ZXJpZXMgbWFkZSB0byBmaWxsIHNsb3RzLiBcbi8vIGluIHBhcnRpY3VsYXIgaXQgaG9sZHMgdGhlIG9mZnNldCwgd2hpY2ggd2lsbCBiZSAtMSB3aGVuIFtdIGlzIHJldHVybmVkLlxuLy8gaXQga2VlcHMgcXVlcmllcyBmcm9tIHJlLXJlcXVlc3RpbmcgdGhlIHNhbWUgc2hlbGxzIG92ZXIgYW5kIG92ZXIsIFxuLy8gYW5kIHByb3ZpZGVzIHNvbWUgY29uY3VycmVuY3kgLyBmbG93IGNvbnRyb2wgYnkgYWxsb3dpbmcgYSBxdWVyeVxuLy8gdG8gc2V0IGl0IHRvIC0xIHdoZW4gaXQgaXMgcnVubmluZyBhbmQgdGhlbiByZXBsYWNlIGl0IHdoZW4gZG9uZS5cblBCLkRhdGEuc2xvdExvY2tlciA9IHt9XG5cbi8vIFRISU5LOiB3ZSdyZSBjYWxsaW5nIHRoaXMgZnJvbSB0aGUgJ3JlZnJlc2gnIGJ1dHRvbiBub3cuLi5cblxuXG5QQi5EYXRhLmltcG9ydFJlbW90ZVNoZWxscyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vLy8gb25seSBjYWxsZWQgZHVyaW5nIGluaXRpYWwgYXBwbGljYXRpb24gYm9vdHVwLiBoYW5kbGVzIGJvdGggY29sZCBsb2FkcyBhbmQgaG90IGxvYWRzLlxuICAgIFxuICAgIHZhciBvZmZzZXQgPSAwXG4gICAgdmFyIGdpdmV1cCA9IFBCLkNPTkZJRy5pbml0TG9hZEdpdmV1cFxuICAgIHZhciBsaW1pdCAgPSBQQi5DT05GSUcuaW5pdExvYWRCYXRjaFNpemVcbiAgICB2YXIgbmV3X3NoZWxscyA9IFtdXG4gICAgdmFyIGtlZXBfZ29pbmcgPSB0cnVlXG4gICAgXG4gICAgdmFyIGtleSA9ICdbe1wic29ydFwiOlwiREVTQ1wifSx7XCJ0YWdzXCI6W10sXCJ0eXBlc1wiOltdLFwidXNlcnNcIjpbXSxcInJvdXRlc1wiOltdfV0nIC8vIFRPRE86IHVwZ3JhZGUgdGhpcyBkZWZhdWx0IHF1ZXJ5XG4gICAgUEIuRGF0YS5zbG90TG9ja2VyW2tleV0gPSAtMVxuICAgIFxuICAgIC8vIFRPRE86IGluZGV4IGJ5IHVzZXJuYW1lXG4gICAgLy8gVE9ETzogaWYgZHVwbGljYXRlIGNoZWNrIHVwZGF0ZSB0aW1lcyBmb3IgbGF0ZXN0XG4gICAgLy8gVE9ETzogcGVyc2lzdCB0byBMUyAobWF5YmUgb25seSBzb21ldGltZXM/IG9udW5sb2FkPyBwcm9iYWJpbGlzdGljPylcbiAgICAgICAgIFxuICAgIGZ1bmN0aW9uIGdldE1lU29tZVNoZWxscyhwdWZmcykge1xuICAgICAgICBpZihwdWZmcykge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gUEIuRGF0YS5hZGRTaGVsbHNUaGVuTWFrZUF2YWlsYWJsZShwdWZmcylcbiAgICAgICAgICAgIC8vIG5ld19zaGVsbHMgPSBuZXdfc2hlbGxzLmNvbmNhdChteV9uZXdfc2hlbGxzKVxuICAgICAgICAgICAgLy8gdmFyIGRlbHRhID0gbXlfbmV3X3NoZWxscy5sZW5ndGhcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoZGVsdGEgIT0gbGltaXQpIC8vIHNvbWUgc2hlbGxzIHdlcmUgYWxyZWFkeSBpbiBvdXIgY2FjaGVcbiAgICAgICAgICAgICAgICBrZWVwX2dvaW5nID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYob2Zmc2V0ID4gZ2l2ZXVwKVxuICAgICAgICAgICAga2VlcF9nb2luZyA9IGZhbHNlXG5cbiAgICAgICAgaWYoIWtlZXBfZ29pbmcpIHtcbiAgICAgICAgICAgIFBCLkRhdGEuc2xvdExvY2tlcltrZXldID0gMVxuICAgICAgICAgICAgLy8gUEIuRGF0YS5zdHVwaWRIb3JyaWJsZUdsb2JhbFRoaW5nID0gdHJ1ZVxuICAgICAgICAgICAgLy8gUEIuRGF0YS5tYWtlU2hlbGxzQXZhaWxhYmxlKG5ld19zaGVsbHMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHByb20gPSBQQi5OZXQuZ2V0U29tZVNoZWxscyh7fSwge30sIGxpbWl0LCBvZmZzZXQpXG4gICAgICAgIHByb20udGhlbihnZXRNZVNvbWVTaGVsbHMpXG5cbiAgICAgICAgb2Zmc2V0ICs9IGxpbWl0XG4gICAgfVxuICAgIFxuICAgIGdldE1lU29tZVNoZWxscygpXG59XG5cblxuLyoqXG4gKiB0byBmaWxsIHNvbWUgc2xvdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWVkXG4gKiBAcGFyYW0ge251bWJlcn0gaGF2ZVxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsdGVyc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblBCLkRhdGEuZmlsbFNvbWVTbG90c1BsZWFzZSA9IGZ1bmN0aW9uKG5lZWQsIGhhdmUsIHF1ZXJ5LCBmaWx0ZXJzKSB7XG4gICAgLy8vLyB3ZSBoYXZlIGVtcHR5IHNsb3RzIG9uIHNjcmVlbi4gZmlsbCB0aGVtIHdpdGggcHVmZnMuXG4gICAgXG4gICAgaWYoaGF2ZSA+PSBuZWVkKSByZXR1cm4gZmFsc2VcbiAgICBcbiAgICAvLyAtLSByZWRyYXcgc2NyZWVuIG9uIG5ldyBwdWZmcyBiZWluZyBpbmdlc3RlZCAody9vIGxvb3BpbmcpXG4gICAgLy8gLS0gY3ljbGUgYWxsIG5ldyBwdWZmcyB0aHJvdWdoIGdyYXBoIHN0dWZmXG4gICAgLy8gLS0gY2FsbCBmaWxsU29tZVNsb3RzUGxlYXNlIGV2ZXJ5IHRpbWUgd2UgaGF2ZSBzbG90cyB0byBmaWxsXG4gICAgLy8gLS0gZ2V0IGZvY3VzZWQgcHVmZiBpbW1lZGlhdGVseVxuICAgIFxuICAgIC8vIC0gcGVyZm9ybSBHQyBvbiBpbi1tZW1vcnkgcHVmZnMgKGNhbiByZW1vdmUgY29udGVudCBhbHNvKVxuICAgIC8vIC0gdXNlIEdDIGZ1bnMgZm9yIHBlcnNpc3Rpbmcgc2hlbGxzXG4gICAgLy8gLSBzdG9yZSBzaXplIG9mIGVhY2ggc2hlbGwvcHVmZiBmb3IgR0NcbiAgICAvLyAtIG1hbmFnZSBlbXB0eSB2ZXJ0aWNlcyBiZXR0ZXIgKGRpZmZlcmVudCB0eXBlPylcblxuICAgIHZhciBhcmdzID0gW3F1ZXJ5LCBmaWx0ZXJzXVxuICAgIC8vIHZhciBhcmdzID0gW3F1ZXJ5LCBmaWx0ZXJzLCBuZWVkXVxuICAgIC8vIGlmKCFxdWVyeS5tb2RlKSBhcmdzLnB1c2goaGF2ZSkgLy8gaGFjayBmb3IgYWx0ZXJuYXRlIHF1ZXJ5IG1vZGVzXG5cbiAgICB2YXIga2V5ID0gSlNPTi5zdHJpbmdpZnkoYXJncylcbiAgICB2YXIgbXlfb2Zmc2V0ID0gUEIuRGF0YS5zbG90TG9ja2VyW2tleV0gfHwgMFxuICAgIFxuICAgIGlmKG15X29mZnNldCA8IDApXG4gICAgICAgIHJldHVybiBmYWxzZSAvLyBzbG90IGlzIGxvY2tlZCwgZ28gZWxzZXdoZXJlXG4gICAgXG4gICAgUEIuRGF0YS5zbG90TG9ja2VyW2tleV0gPSAtMSAvLyBwcmV2ZW50IGNvbmN1cnJlbnQgdmVyc2lvbnMgb2YgdGhlIHNhbWUgcmVxdWVzdFxuICAgIFxuICAgIC8vLy8vL1xuXG4gICAgLy8gdmFyIGxpbWl0ID0gbmVlZCAtIGhhdmUgKyAzIC8vIDMgZm9yIGx1Y2tcbiAgICBcbiAgICB2YXIgbGltaXQgPSBuZWVkIC8vIHNvLi4uIGlmIHdlIG9ubHkgZG8gdGhpcyBvbmNlLCBhbmQgd2UgaGF2ZSBoYWxmIHRoZSBwdWZmcyBhbHJlYWR5LCB3ZSBtaWdodCBvbmx5IGdyYWIgdGhhdCBoYWxmIGFnYWluLiB0aGlzIGlzIHRydWUgZXZlbiBpZiB3ZSBzZW5kIGFuIG9mZnNldCBvZiAnaGF2ZScgdG8gdGhlIHNlcnZlciwgYmVjYXVzZSB3aGF0IHdlIGhhdmUgbWlnaHQgbWFwIHRvIHRoYXQgc2xpY2UgKG9yIHRvIGFueXRoaW5nIGVsc2UgLS0gb3VyIG9mZnNldHMgYXJlIHRvdGFsbHkgZGlmZmVyZW50IHRoYW4gdGhlIHNlcnZlcnMpLiBzbyB3ZSBoYXZlIHRvIGdyYWIgZW5vdWdoIHRvIGNvdmVyIHRoZSBkaWZmZXJlbmNlLCB3aGljaCBtZWFucyBncmFiYmluZyB0aGUgc2FtZSBzaGVsbHMgbXVsdGlwbGUgdGltZXMuLi4gKGJ1dCBvbmx5IGVtcHR5IHNoZWxscywgZm9ydHVuYXRlbHkuIGJ1dCBzdGlsbC4pXG4gICAgXG4gICAgLy8gdmFyIHJlY2VpdmVkX3NoZWxscyA9IDBcbiAgICBcbiAgICB2YXIgcHJvbSA9IFBCLk5ldC5nZXRTb21lU2hlbGxzKHF1ZXJ5LCBmaWx0ZXJzLCBsaW1pdCwgcXVlcnkub2Zmc2V0KVxuICAgIC8vIHByb20udGhlbihmdW5jdGlvbihzaGVsbHMpIHtyZWNlaXZlZF9zaGVsbHMgPSBzaGVsbHMubGVuZ3RoOyByZXR1cm4gc2hlbGxzfSlcbiAgICBwcm9tLnRoZW4oUEIuRGF0YS5hZGRTaGVsbHNUaGVuTWFrZUF2YWlsYWJsZSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGVsdGEpIHsgXG4gICAgICAgICAgICBQQi5EYXRhLnNsb3RMb2NrZXJba2V5XSA9IGRlbHRhID8gMSA6IC0xfSkgXG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVxdWVzdCBpcyBmcnVpdGZ1bCwgdW5sb2NrIGl0IChidXQgYmUgY2FyZWZ1bCBvZiBvZmZzZXRzIGhlcmUpLlxuICAgICAgICAgICAgLy8gYWxzbywgdGhpcyBsb2NrcyB3aGVuIHdlIHJlY2VpdmVkIGRhdGEgYnV0IGNob3NlIG5vdCB0byBrZWVwIGl0IChlaXRoZXIgZHVwcyBvciBHQyksXG4gICAgICAgICAgICAvLyBzbyB3ZSBjb3VsZCBoYXZlIGFuIGlzc3VlIHdpdGggbG9ja2VkIHF1ZXJpZXMgdGhhdCB3b3VsZCBiZSBmcnVpdGZ1bCB3LyBkaWZmZXJlbnQgb2Zmc2V0IC8gbGltaXRzLi4uXG4gICAgXG4gICAgXG4gICAgLy8gVE9ETzogdGhlIHNsb3RMb2NrZXIgcmVhbGx5IHNob3VsZCBrZWVwIHRyYWNrIG9mIHdoYXQgJ3NsaWNlcycgb2YgdGhlIHNlcnZlciB5b3UndmUgc2Vlbiwgc28gd2Uga25vdyBub3QgdG8gcmUtcmVxdWVzdCB0aG9zZSBvdmVyIGFuZCBvdmVyLiB0aGlzIGlzLi4uIGNvbXBsaWNhdGVkLiBcbiAgICAvLyAgICAgICBzbyBzZW5kIHF1ZXJ5Lm9mZnNldCtoYXZlIHRvIGdldFNvbWVTaGVsbHMsIGFuZCBzdG9yZSB0aGF0IHNhbWUgb2Zmc2V0IGFzIHBhcnQgb2YgdGhlIHNsb3RMb2NrZXIuXG4gICAgLy8gICAgICAgdGhlbiB5b3UgY2FuIHRyYWNrIGhvdyBtdWNoIG9mIHNvbWUgdHlwZSBvZiBzdHVmZiBpcyBvbiB0aGUgc2VydmVyLi4uIGV4Y2VwdCB0aGF0IGRvZXNuJ3Qgd29yayBmb3IgdGhlIFAyUCBuZXR3b3JrLlxuICAgIFxuICAgIHJldHVybiB0cnVlXG4gICAgXG4gICAgLy8vLy8vXG5cblxuICAgIC8vIE9MRCBTVFVGRiBTQVZFIEZPUiBSRUZFUkVOQ0VcblxuICAgIC8vIHZhciBiYXRjaFNpemUgPSBQQi5DT05GSUcuZmlsbFNsb3RzQmF0Y2hTaXplXG4gICAgLy8gdmFyIGdpdmV1cCA9IFBCLkNPTkZJRy5maWxsU2xvdHNHaXZldXBcbiAgICAvLyB2YXIgbmV3X3NoZWxscyA9IFtdXG4gICAgLy9cbiAgICAvLyBnaXZldXAgPSBnaXZldXAgKyBteV9vZmZzZXRcbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uIGdldE1lU29tZVNoZWxscyhwdWZmcykge1xuICAgIC8vICAgICBpZihwdWZmcykge1xuICAgIC8vICAgICAgICAgdmFyIG15X25ld19zaGVsbHMgPSBQQi5EYXRhLmhlcmVIYXZlU29tZU5ld1NoZWxscyhwdWZmcylcbiAgICAvLyAgICAgICAgIG5ld19zaGVsbHMgPSBuZXdfc2hlbGxzLmNvbmNhdChteV9uZXdfc2hlbGxzKVxuICAgIC8vICAgICAgICAgdmFyIGRlbHRhID0gbXlfbmV3X3NoZWxscy5sZW5ndGhcbiAgICAvLyAgICAgICAgIC8vIFRISU5LOiBidXQgZG8gdGhleSBwYXNzIHRoZSBmaWx0ZXI/XG4gICAgLy8gICAgICAgICAvLyBUT0RPOiBjYW4gd2UgbWFrZSBhdmFpbGFibGUgaGVyZSBub3cgdGhhdCB3ZSdyZSBsb2NraW5nP1xuICAgIC8vICAgICAgICAgaGF2ZSArPSBkZWx0YSB8fCAwXG4gICAgLy8gICAgIH1cbiAgICAvL1xuICAgIC8vICAgICBpZihoYXZlID49IG5lZWQgfHwgbXlfb2Zmc2V0ID4gZ2l2ZXVwIHx8IChxdWVyeS5tb2RlICYmIChteV9vZmZzZXQgLSBnaXZldXAgPCAwKSkpIHtcbiAgICAvLyAgICAgICAgIFBCLkRhdGEubWFrZVNoZWxsc0F2YWlsYWJsZShuZXdfc2hlbGxzKVxuICAgIC8vICAgICAgICAgUEIuRGF0YS5zbG90TG9ja2VyW2tleV0gPSBteV9vZmZzZXQtbGltaXRcbiAgICAvLyAgICAgICAgIHJldHVybiBmYWxzZVxuICAgIC8vICAgICB9XG4gICAgLy9cbiAgICAvLyAgICAgdmFyIGxpbWl0ID0gbmVlZCAtIGhhdmVcbiAgICAvLyAgICAgLy8gaWYoIXF1ZXJ5Lm1vZGUpIGxpbWl0ICs9IDUwIC8vIGdyYWIgYSBmZXcgZXh0cmFzIHRvIGhlbHAgd29yayB0aHJvdWdoIGJhcmUgcGF0Y2hlc1xuICAgIC8vXG4gICAgLy8gICAgIHZhciBwcm9tID0gUEIuTmV0LmdldFNvbWVTaGVsbHMocXVlcnksIGZpbHRlcnMsIGxpbWl0LCBteV9vZmZzZXQpXG4gICAgLy8gICAgIHByb20udGhlbihnZXRNZVNvbWVTaGVsbHMpXG4gICAgLy9cbiAgICAvLyAgICAgbXlfb2Zmc2V0ICs9IGxpbWl0XG4gICAgLy8gfVxuICAgIC8vXG4gICAgLy8gZ2V0TWVTb21lU2hlbGxzKClcbn1cblxuXG4vKlxuICAgIEVuZCBzaGVsbCBjb2xsZWN0aW9uIGludGFrZSBlcXVpcG1lbnRcbiovXG5cblxuLyoqXG4gKiByZXR1cm5zIGEgcHVmZiBmcm9tIGEgc2hlbGxcbiAqIEBwYXJhbSAgeyhzdHJpbmd8b2JqZWN0KX0gc2hlbGwgXG4gKiBAcmV0dXJuIHtvYmplY3R9IHJldHVybnMgYSBwdWZmIGJhc2VkIG9uIHRoZSBzaGVsbDsgcmV0dXJucyBmYWxzZSBpZiB0aGUgc2hlbGwgaXMgZW1wdHlcbiAqL1xuUEIuRGF0YS5nZXRQdWZmRnJvbVNoZWxsID0gZnVuY3Rpb24oc2hlbGwpIHtcbiAgICBpZighc2hlbGwpXG4gICAgICAgIHJldHVybiBmYWxzZSAvLyBzbyB3ZSBjYW4gZmlsdGVyIGVtcHR5IHNoZWxscyBvdXQgZWFzaWx5LCB3aGlsZSBzdGlsbCBsb2FkaW5nIHRoZW0gb24gZGVtYW5kXG4gICAgXG4gICAgaWYoc2hlbGwucGF5bG9hZCAmJiBzaGVsbC5wYXlsb2FkLmNvbnRlbnQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHNoZWxsIC8vIGl0J3MgYWN0dWFsbHkgYSBmdWxsIGJsb3duIHB1ZmZcbiAgICBcbiAgICByZXR1cm4gUEIuRGF0YS5nZXRQdWZmQnlTaWcoc2hlbGwuc2lnKSAvLyByZXR1cm5zIGEgcHVmZiwgb3IgYXNrcyB0aGUgbmV0d29yayBhbmQgcmV0dXJucyBmYWxzZVxufVxuXG4vKipcbiAqIHRvIGdldCBwdWZmIGJ5IGl0cyBzaWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaWdcbiAqIEByZXR1cm5zIHsob2JqZWN0fGZhbHNlKX1cbiAqL1xuUEIuRGF0YS5nZXRQdWZmQnlTaWcgPSBmdW5jdGlvbihzaWcpIHtcbiAgICB2YXIgc2hlbGwgPSBQQi5EYXRhLmdldENhY2hlZFNoZWxsQnlTaWcoc2lnKSAvLyBPUFQ6IHRoaXMgaGFwcGVucyB0d2ljZSBhbG1vc3QgYWx3YXlzXG4gICAgXG4gICAgaWYoc2hlbGwgJiYgc2hlbGwucGF5bG9hZCAmJiB0eXBlb2Ygc2hlbGwucGF5bG9hZC5jb250ZW50ICE9ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gc2hlbGxcbiAgICBcbiAgICBpZihQQi5EYXRhLnBlbmRpbmdQdWZmUHJvbWlzZXNbc2lnXSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIFxuICAgIC8vIGxvY2FsbHkgY2FjaGVkIHNoZWxscyB0aGF0IGFyZSBtaXNzaW5nIGNvbnRlbnQgb24gdGhlIG5ldHdvcmsgcHJldmVudCBzbG90ZmlsbHMgZnJvbSByZXNvbHZpbmcsXG4gICAgLy8gc28gd2UgY2xlYXIgaXQgZnJvbSBvdXIgY2FjaGUgaWYgd2UgY2FuJ3QgZmluZCBpdC5cbiAgICBmdW5jdGlvbiBiYWRTaGVsbENsZWFyQ2FjaGUoc2hlbGxzKSB7XG4gICAgICAgIGlmKCFzaGVsbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZmF1eHNoZWxsID0ge3NpZzogc2lnfVxuICAgICAgICAgICAgaWYoIVBCLkRhdGEuZ2V0Qm9udXMoZmF1eHNoZWxsLCAnZW52ZWxvcGUnKSkge1xuICAgICAgICAgICAgICAgIFBCLkRhdGEucmVtb3ZlU2hlbGxGcm9tQ2FjaGUoc2lnKVxuICAgICAgICAgICAgICAgIHJldHVybiBQQi5vbkVycm9yKFwiQ29udGVudCBjYW4gbm90IGJlIGZvdW5kIGZvciBzaGVsbCAnXCIgKyBzaWcgKyBcIidcIikgLy8gVEhJTks6IHdoeSB3YXMgdGhpcyB0aHJvd0Vycm9yP1xuICAgICAgICAgICAgICAgIC8vIFRISU5LOiB1bmxvY2sgUEIuRGF0YS5wZW5kaW5nUHVmZlByb21pc2VzW3NpZ10/IHByb2JhYmx5IG5vdCwgYnV0IGl0IG1pZ2h0IHJlLWFwcGVhciBsYXRlci4uLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGVsbHNcbiAgICB9XG4gICAgXG4gICAgUEIuRGF0YS5wZW5kaW5nUHVmZlByb21pc2VzW3NpZ10gPSBQQi5OZXQuZ2V0UHVmZkJ5U2lnKHNpZykgICAgICAvLyBUT0RPOiBkcm9wIHRoaXMgZG93biBpbiB0byBQQi5OZXQgaW5zdGVhZFxuICAgIFBCLkRhdGEucGVuZGluZ1B1ZmZQcm9taXNlc1tzaWddLnRoZW4oYmFkU2hlbGxDbGVhckNhY2hlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oUEIuRGF0YS5hZGRTaGVsbHNUaGVuTWFrZUF2YWlsYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlbGF5IEdDIHRvIHN0b3AgcnVuYXdheSBuZXR3b3JrIHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgZGVsZXRlIFBCLkRhdGEucGVuZGluZ1B1ZmZQcm9taXNlc1tzaWddIH0sIDEwMDAwKSB9KVxuICAgIFxuICAgIHJldHVybiBmYWxzZVxufVxuXG5QQi5EYXRhLnJlbW92ZVNoZWxsRnJvbUNhY2hlID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgLy8gcmVtb3ZlIGZyb20gUEIuRGF0YS5zaGVsbHNcbiAgICB2YXIgc2hlbGwgPSBQQi5EYXRhLmdldENhY2hlZFNoZWxsQnlTaWcoc2lnKVxuICAgIFBCLkRhdGEuc2hlbGxzLnNwbGljZSggUEIuRGF0YS5zaGVsbHMuaW5kZXhPZihzaGVsbCksIDEgKVxuICAgIFxuICAgIC8vIHJlbW92ZSBmcm9tIFBCLkRhdGEuc2hlbGxTb3J0XG4gICAgZGVsZXRlIFBCLkRhdGEuc2hlbGxTb3J0W3NpZ11cbiAgICBcbiAgICAvLyByZW1vdmUgc2hlbGwncyBib25paVxuICAgIGRlbGV0ZSBQQi5EYXRhLmJvbmlpW3NpZ11cbiAgICBcbiAgICBQQi5EYXRhLnB1cmdlU2hlbGxGcm9tR3JhcGgoc2lnKVxuICAgIFxuICAgIFBCLkRhdGEucmVtb3ZlQ2FjaGVkUHVmZlNjb3JlKHNoZWxsKVxufVxuXG5QQi5EYXRhLnB1cmdlU2hlbGxGcm9tR3JhcGggPSBmdW5jdGlvbihzaWcpIHtcbiAgICAvLyBjaGFuZ2UgZ3JhcGggdmVydGV4IHRvICdwc2V1ZG8tc2hlbGwnIHR5cGUgKG9yICdwdXJnZWQnIHR5cGU/KVxuICAgIC8vICAgYW5kIHJlbW92ZSB0aGUgY29udGVudCBvZiB0aGUgJ3NoZWxsJyBwcm9wZXJ0eVxuICAgIC8vIFRPRE86IHRoaXMgaXMgaWNreSBtYWtlIGl0IGJldHRlclxuICAgIHZhciB2ZXJ0ZXggPSBQQi5EYXRhLmdyYXBoLnYoc2lnKS5ydW4oKVswXVxuICAgIGlmKHZlcnRleCkge1xuICAgICAgICB2ZXJ0ZXgudHlwZSA9ICdwdXJnZWQnXG4gICAgICAgIHZlcnRleC5zaGVsbCA9IHVuZGVmaW5lZFxuICAgIH1cbn1cblxuXG4vKipcbiAqIHRvIGdldCBteSBwdWZmIGNoYWluXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVzZXJuYW1lIFxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5QQi5EYXRhLmdldE15UHVmZkNoYWluID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAvLyBDVVJSRU5UTFkgVU5VU0VEXG4gICAgLy8gVE9ETzogdGhpcyBzaG91bGQgZ3JhYiBteSBwdWZmcyBmcm9tIGEgZmlsZSBvciBsb2NhbFN0b3JhZ2Ugb3Igd2hlcmV2ZXIgbXkgaWRlbnRpdHkncyBwdWZmcyBnZXQgc3RvcmVkXG4gICAgLy8gVE9ETzogdGhhdCBjb2xsZWN0aW9uIHNob3VsZCBiZSB1cGRhdGVkIGF1dG9tYXRpY2FsbHkgd2l0aCBuZXcgcHVmZnMgY3JlYXRlZCB0aHJvdWdoIG90aGVyIGRldmljZXNcbiAgICAvLyBUT0RPOiB0aGUgcHVmZmNoYWluIHNob3VsZCBhbHNvIGJlIHNvcnRlZCBpbiBjaGFpbiBvcmRlciwgbm90IGdlbmVyYWwgY29sbGVjdGlvbiBvcmRlclxuICAgIFxuICAgIHZhciBzaGVsbHMgPSBQQi5EYXRhLmdldFNoZWxscygpXG4gICAgXG4gICAgcmV0dXJuIHNoZWxscy5maWx0ZXIoZnVuY3Rpb24ocHVmZikgeyByZXR1cm4gcHVmZiAmJiBwdWZmLnVzZXJuYW1lID09IHVzZXJuYW1lIH0pIC8vIFRPRE86IHVzZSB0aGUgZ3JhcGhcbiAgICAvLyByZXR1cm4gUEIuTS5Gb3J1bS5nZXRCeVVzZXIodXNlcm5hbWUpIC8vIFRPRE86IHRlc3QgdGhpcyBcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbi8vICAgICAgIEdhcmJhZ2UgQ29sbGVjdG9yIFRoaW5nICAgICAgICAgLy9cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5cblBCLkRhdGEucnVubmluZ1NpemVUYWxseSA9IDBcblBCLkRhdGEuc2NvcmVTb3J0ID0ge31cblxuUEIuRGF0YS5oZXVyaXN0aWNzID0gW11cblBCLkRhdGEuYWRkSGV1cmlzdGljcyA9IGZ1bmN0aW9uKGZ1bikge1xuICAgIFBCLkRhdGEuaGV1cmlzdGljcy5wdXNoKGZ1bilcbn1cblxuUEIuRGF0YS5hZGRIZXVyaXN0aWNzKGZ1bmN0aW9uKHNoZWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoIChQQi5EYXRhLmdldEJvbnVzKHNoZWxsLCAnc3RhclN0YXRzJykgfHwge30pLnNjb3JlIHx8IDAgKSAqIDEwMFxufSlcblxuLy8gVE9ETzogYWRkIGhldXJpc3RpY3MgZm9yOiBteSBwdWZmcyAod2hpY2ggZ28gZWxzZXdoZXJlLCB1bHRpbWF0ZWx5KSwgcmVwbGllcyB0byBteSBwdWZmcywgbXkgcHVmZidzIHBhcmVudHMsIFxuLy8gICAgICAgZnJpZW5kJ3MgcHVmZnMgKHdoYXRldmVyIHRoYXQgbWVhbnMpLCBwdWZmIGZyZXNobmVzcywgbGFzdCBzZWVuLCBldGNcblxuXG5QQi5EYXRhLnJhdGVNeVB1ZmYgPSBmdW5jdGlvbihwdWZmKSB7XG4gICAgdmFyIHNjb3JlcyA9IFBCLkRhdGEuaGV1cmlzdGljcy5tYXAoZnVuY3Rpb24oaCkge3JldHVybiBoKHB1ZmYpfSkgICAgICAgICAgIC8vIGFwcGx5IGhldXJpc3RpY3NcbiAgICB2YXIgdG90YWwgID0gc2NvcmVzLnJlZHVjZShmdW5jdGlvbihhY2MsIHNjb3JlKSB7cmV0dXJuIGFjYysoc2NvcmV8fDApfSwgMCkgLy8gZ2V0IHRvdGFsIC8vIFRPRE86IGltcHJvdmUgYWxnb1xuICAgIHJldHVybiB0b3RhbFxufVxuXG5QQi5EYXRhLnJhdGVTb21lUHVmZnMgPSBmdW5jdGlvbihwdWZmcykge1xuICAgIHB1ZmZzLmZvckVhY2goZnVuY3Rpb24ocHVmZikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByYXRlIGVhY2ggcHVmZlxuICAgICAgICB2YXIgc2NvcmUgPSBQQi5EYXRhLnJhdGVNeVB1ZmYocHVmZilcbiAgICAgICAgUEIuRGF0YS5kb1N0dWZmV2l0aFNjb3JlKHB1ZmYsIHNjb3JlKVxuICAgICAgICBQQi5EYXRhLmRvU3R1ZmZXaXRoUHVmZiAocHVmZilcbiAgICB9KVxuICAgIC8vIFRISU5LOiBzb21lIGhldXJpc3RpY3MgcmVseSBvbiBzY29yZXMgb2YgcmVsYXRlZCBwdWZmcy4uLiBwb3NzaWJsZSBmZWVkYmFjayBsb29wPyB0b3BvbG9naWNhbCBvcmRlcmluZz9cbiAgICAvLyAgICAgICAgYSB0b3Bvc29ydCBpcyBlYXN5LWlzaCB3LyBncmFwaCBkYi4uLlxufVxuXG4vLyBUT0RPOiB3aGVuIHlvdSBzd2l0Y2ggaWRlbnRpdGllcywgcmVzY29yZSB0aGUgcHVmZnNcblxuXG5QQi5EYXRhLmRvU3R1ZmZXaXRoU2NvcmUgPSBmdW5jdGlvbihwdWZmLCBzY29yZSkge1xuICAgIFBCLkRhdGEucmVtb3ZlQ2FjaGVkUHVmZlNjb3JlKHB1ZmYpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBoYXMgdG8gY29tZSBiZWZvcmUgYm9uaWlcbiAgICBQQi5EYXRhLmFkZEJvbnVzKHB1ZmYsICdyYXRpbmcnLCBzY29yZSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHJhdGluZyB0byBib25paVxuICAgIFBCLkRhdGEuY2FjaGVQdWZmU2NvcmUocHVmZiwgc2NvcmUpICAgIFxuICAgIC8vIE9QVDogY2FjaGUgc29ydGVkIHZlcnNpb25cbiAgICAvLyBtYXliZSBiaW5zW3Njb3JlLmZsb29yXS5wdXNoKHB1ZmYpIG9yIHNvbWV0aGluZy4uLlxufVxuXG5QQi5EYXRhLmRvU3R1ZmZXaXRoUHVmZiA9IGZ1bmN0aW9uKHB1ZmYpIHtcbiAgICB2YXIgcHVmZnNpemUgPSBKU09OLnN0cmluZ2lmeShwdWZmKS5sZW5ndGhcbiAgICBQQi5EYXRhLmFkZEJvbnVzKHB1ZmYsICdzaXplJywgcHVmZnNpemUpXG4gICAgUEIuRGF0YS5ydW5uaW5nU2l6ZVRhbGx5ICs9IHB1ZmZzaXplIHx8IDAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmxvY2sgTmFOc1xufVxuXG5QQi5EYXRhLmNhY2hlUHVmZlNjb3JlID0gZnVuY3Rpb24ocHVmZiwgc2NvcmUpIHtcbiAgICB2YXIga2V5ID0gUEIuRGF0YS5jb252ZXJ0U2NvcmVUb0tleShzY29yZSlcbiAgICBQQi5EYXRhLnNjb3JlU29ydFtrZXldID0gUEIuRGF0YS5zY29yZVNvcnRba2V5XSB8fCBbXVxuICAgIFBCLkRhdGEuc2NvcmVTb3J0W2tleV0ucHVzaChwdWZmKVxufVxuXG5QQi5EYXRhLnJlbW92ZUNhY2hlZFB1ZmZTY29yZSA9IGZ1bmN0aW9uKHB1ZmYpIHtcbiAgICBpZighcHVmZikgcmV0dXJuIGZhbHNlXG4gICAgXG4gICAgdmFyIHNjb3JlID0gUEIuRGF0YS5nZXRCb251cyhwdWZmLCAnc2NvcmUnKVxuICAgIHZhciBrZXkgPSBQQi5EYXRhLmNvbnZlcnRTY29yZVRvS2V5KHNjb3JlKVxuICAgIHZhciBiaW4gPSBQQi5EYXRhLnNjb3JlU29ydFtrZXldXG4gICAgaWYoIWJpbikgcmV0dXJuIGZhbHNlXG4gICAgaWYoIWJpbi5sZW5ndGgpIHJldHVybiBmYWxzZVxuICAgIFxuICAgIGZvcih2YXIgaSA9IGJpbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZihiaW5baV0uc2lnID09IHB1ZmYuc2lnKSB7XG4gICAgICAgICAgICBiaW4uc3BsaWNlKGksIDEpXG4gICAgICAgICAgICB2YXIgcHVmZnNpemUgPSBQQi5EYXRhLmdldEJvbnVzKHB1ZmYsICdzaXplJylcbiAgICAgICAgICAgIFBCLkRhdGEucnVubmluZ1NpemVUYWxseSAtPSBwdWZmc2l6ZSB8fCAwICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBibG9jayBOYU5zXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cbn1cblxuUEIuRGF0YS5nZXRDYWNoZWRQdWZmcyA9IGZ1bmN0aW9uKGxpbWl0LCBib3R0b20pIHtcbiAgICB2YXIgc2VlbiA9IDBcbiAgICB2YXIgcmVzdWx0ID0gW11cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKFBCLkRhdGEuc2NvcmVTb3J0KS5tYXAocGFyc2VGbG9hdCkuc29ydCgpXG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldXG4gICAgICAgIHZhciBwdWZmcyA9IFBCLkRhdGEuc2NvcmVTb3J0W2tleV0gLy8gT1BUOiBzaG9ydC1jaXJjdWl0IG9uICFib3R0b21cbiAgICAgICAgXG4gICAgICAgIHB1ZmZzLnJlZHVjZShmdW5jdGlvbihzZWVuLCBwdWZmKSB7XG4gICAgICAgICAgICBpZihzZWVuID4gbGltaXQgPT0gISFib3R0b20pIHJlc3VsdC5wdXNoKHB1ZmYpXG4gICAgICAgICAgICByZXR1cm4gc2VlbisxXG4gICAgICAgIH0sIDApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZXN1bHRcbn1cblxuUEIuRGF0YS5jb252ZXJ0U2NvcmVUb0tleSA9IGZ1bmN0aW9uKHNjb3JlKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3Ioc2NvcmUgLyAxMCkgfHwgMCAvLyBUT0RPOiBtYWtlIHRoaXMgc21hcnRlclxufVxuXG5cblBCLkRhdGEuZ2V0VG9wUHVmZnMgPSBmdW5jdGlvbihsaW1pdCkge1xuICAgIHJldHVybiBQQi5EYXRhLmdldENhY2hlZFB1ZmZzKGxpbWl0KVxufVxuXG5QQi5EYXRhLmdldE5vdFRvcFB1ZmZzID0gZnVuY3Rpb24obGltaXQpIHtcbiAgICAvLyBncmFiIHRoZSBwdWZmcyBiZWxvdyB0aGUgbGltaXQgdGhyZXNob2xkICh3LyAzMDAgcHVmZnMgYW5kIGxpbWl0PTEwMCB0aGlzIHJldHVybnMgdGhlIDIwMCB3b3JzdCBwdWZmcylcbiAgICByZXR1cm4gUEIuRGF0YS5nZXRDYWNoZWRQdWZmcyhsaW1pdCwgJ2JvdHRvbScpXG59XG5cbi8vIFBCLkRhdGEuZ2V0VG9wUHVmZnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4vLyAgICAgdmFyIG51bWJlckxpbWl0ID0gIG9wdGlvbnMubnVtYmVyIHx8IDBcbi8vICAgICB2YXIgc2l6ZUxpbWl0ICAgPSAgICBvcHRpb25zLnNpemUgfHwgMFxuLy8gICAgIHZhciBjb21wYWN0ICAgICA9IG9wdGlvbnMuY29tcGFjdCB8fCBmYWxzZSAgLy8gd2hldGhlciB0byBhbGxvdyBjb21wYWN0aW9uIG9mIHJldHVybmVkIHB1ZmZzXG4vLyAgICAgdmFyIHJldmVyc2UgICAgID0gb3B0aW9ucy5yZXZlcnNlIHx8IGZhbHNlICAvLyByZXR1cm4gYm90dG9tIHB1ZmZzIGluc3RlYWQgb2YgdG9wIHB1ZmZzXG4vLyB9XG5cblBCLkRhdGEuZ2FyYmFnZUNvbXBhY3RvciA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGFyZSB3ZSBvdmVyIHRoZSBsaW1pdHM/XG4gICAgdmFyIGxpbWl0ICAgICA9IFBCLkNPTkZJRy5pbk1lbW9yeVNoZWxsTGltaXRcbiAgICB2YXIgbWVtbGltaXQgID0gUEIuQ09ORklHLmluTWVtb3J5TWVtb3J5TGltaXRcbiAgICB2YXIgc2l6ZWxpbWl0ID0gUEIuQ09ORklHLnNoZWxsQ29udGVudFRocmVzaG9sZFxuICAgIHZhciBkaWRTdHVmZiAgPSBmYWxzZVxuXG4gICAgaWYoUEIuRGF0YS5zaGVsbHMubGVuZ3RoID4gbGltaXQpIHtcbiAgICAgICAgZGlkU3R1ZmYgPSB0cnVlXG4gICAgICAgIFBCLkRhdGEuc2hlbGxzLnNsaWNlKGxpbWl0KS5tYXAoUEIucHJvcCgnc2lnJykpLmZvckVhY2goUEIuRGF0YS5yZW1vdmVTaGVsbEZyb21DYWNoZSlcbiAgICB9XG4gICAgXG4gICAgaWYoUEIuRGF0YS5ydW5uaW5nU2l6ZVRhbGx5ID4gbWVtbGltaXQpIHtcbiAgICAgICAgZGlkU3R1ZmYgPSB0cnVlXG4gICAgICAgIGZvciAodmFyIGkgPSBQQi5EYXRhLnNoZWxscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIHNoZWxsID0gUEIuRGF0YS5zaGVsbHNbaV1cbiAgICAgICAgICAgIHZhciBjb250ZW50X3NpemUgPSAoc2hlbGwucGF5bG9hZC5jb250ZW50fHxcIlwiKS50b1N0cmluZygpLmxlbmd0aCAvLyBUSElOSzogbm9uLWZsYXQgY29udGVudCBib3JrcyB0aGlzXG4gICAgICAgICAgICBpZiAoY29udGVudF9zaXplID4gc2l6ZWxpbWl0KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNoZWxsLnBheWxvYWQuY29udGVudCAvLyBUSElOSzogdGhpcyBpcyBoYXJkY29yZVxuICAgICAgICAgICAgICAgIHRvdGFsIC09IGNvbnRlbnRfc2l6ZSArIDEzIC8vIE5PVEU6IG1hZ2ljIG51bWJlciA9PSAnXCJjb250ZW50XCI6XCJcIiwnLmxlbmd0aFxuICAgICAgICAgICAgICAgIGlmKHRvdGFsIDw9IG1lbWxpbWl0KSBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBkaWRTdHVmZlxufVxuXG5cblBCLkRhdGEuZ2V0U2hlbGxzRm9yTG9jYWxTdG9yYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxpbWl0ICAgICA9IFBCLkNPTkZJRy5sb2NhbFN0b3JhZ2VTaGVsbExpbWl0XG4gICAgdmFyIG1lbWxpbWl0ICA9IFBCLkNPTkZJRy5sb2NhbFN0b3JhZ2VNZW1vcnlMaW1pdFxuICAgIHZhciBzaXplbGltaXQgPSBQQi5DT05GSUcuc2hlbGxDb250ZW50VGhyZXNob2xkXG4gICAgXG4gICAgdmFyIHNoZWxscyA9IFBCLkRhdGEuZ2V0VG9wUHVmZnMobGltaXQpXG4gICAgdmFyIHRvdGFsID0gc2hlbGxzLnJlZHVjZShmdW5jdGlvbihzaXplLCBzaGVsbCkge1xuICAgICAgICByZXR1cm4gc2l6ZSArIChQQi5EYXRhLmdldEJvbnVzKHNoZWxsLCAnc2l6ZScpIHx8IDApXG4gICAgfSwgMClcbiAgICBcbiAgICBpZiAodG90YWwgPD0gbWVtbGltaXQpIHJldHVybiBzaGVsbHNcbiAgICBcbiAgICAvLyBjb21wYWN0IHRoZSBwdWZmc1xuICAgIGZvciAodmFyIGkgPSBzaGVsbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHNoZWxsID0gc2hlbGxzW2ldXG4gICAgICAgIHZhciBjb250ZW50X3NpemUgPSAoc2hlbGwucGF5bG9hZC5jb250ZW50fHxcIlwiKS50b1N0cmluZygpLmxlbmd0aCAvLyBUSElOSzogbm9uLWZsYXQgY29udGVudCBib3JrcyB0aGlzXG4gICAgICAgIGlmIChjb250ZW50X3NpemUgPiBzaXplbGltaXQpIHtcbiAgICAgICAgICAgIHZhciBuZXdfc2hlbGwgPSBQQi5EYXRhLmNvbXBhY3RQdWZmKHNoZWxsKVxuICAgICAgICAgICAgc2hlbGxzW2ldID0gbmV3X3NoZWxsXG4gICAgICAgICAgICB0b3RhbCAtPSBjb250ZW50X3NpemUgKyAxMyAvLyBOT1RFOiBtYWdpYyBudW1iZXIgPT0gJ1wiY29udGVudFwiOlwiXCIsJy5sZW5ndGhcbiAgICAgICAgICAgIGlmKHRvdGFsIDw9IG1lbWxpbWl0KSBicmVha1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmICh0b3RhbCA8PSBtZW1saW1pdCkgcmV0dXJuIHNoZWxsc1xuICAgIFxuICAgIC8vIHJlbW92ZSBzaGVsbHMgdW50aWwgdW5kZXIgbWVtbGltaXRcbiAgICBmb3IgKHZhciBpID0gc2hlbGxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjb250ZW50X3NpemUgPSBKU09OLnN0cmluZ2lmeShzaGVsbCkubGVuZ3RoXG4gICAgICAgIHRvdGFsIC09IGNvbnRlbnRfc2l6ZVxuICAgICAgICBpZih0b3RhbCA8PSBtZW1saW1pdCkgYnJlYWtcbiAgICB9XG4gICAgXG4gICAgc2hlbGxzID0gc2hlbGxzLnNsaWNlKDAsIE1hdGgubWF4KGksIDEpKSAvLyBwcmV2ZW50IC0xIFxuICAgIFxuICAgIHJldHVybiBzaGVsbHNcbn1cblxuXG5QQi5EYXRhLmNvbXBhY3RQdWZmID0gZnVuY3Rpb24ocHVmZikge1xuICAgIC8vIFRISU5LOiBpbnN0ZWFkIG9mIHJlYnVpbGRpbmcgdGhlIHB1ZmYsIHVzZSBhIEpTT04uc3RyaW5naWZ5IHJlZHVjZXIgdGhhdCBzdHJpcHMgb3V0IHRoZSBjb250ZW50XG4gICAgdmFyIG5ld19zaGVsbCA9IEJvcm9uLmV4dGVuZChwdWZmKVxuICAgIHZhciBuZXdfcGF5bG9hZCA9IHt9XG4gICAgZm9yKHZhciBwcm9wIGluIHB1ZmYucGF5bG9hZClcbiAgICAgICAgaWYocHJvcCAhPSAnY29udGVudCcpXG4gICAgICAgICAgICBuZXdfcGF5bG9hZFtwcm9wXSA9IHB1ZmYucGF5bG9hZFtwcm9wXSBcblxuICAgIG5ld19zaGVsbC5wYXlsb2FkID0gbmV3X3BheWxvYWRcbiAgICByZXR1cm4gbmV3X3NoZWxsXG59XG4iLCIvKlxuXG4gICAgVXNlciBtYW5hZ2VtZW50IGZvciB0aGUgRXZlcnlCaXQgcGxhdGZvcm0uXG5cbiAgICBNb3N0IGZ1bmN0aW9ucyByZWxhdGVkIHRvIHVzZXJSZWNvcmRzIGxpdmUgaGVyZS5cbiAgICBOb3RlIHRoYXQgdXNlclJlY29yZHMgYXJlIGVudGlyZWx5IHB1YmxpYztcbiAgICBwcml2YXRlIGtleSBpZGVudGl0aWVzIGFyZSBoYW5kbGVkIGVsc2V3aGVyZS5cblxuICAgIENvcHlyaWdodCAyMDE0IEV2ZXJ5Qml0LiBTZWUgUkVBRE1FIGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG4gKi9cblxuUEIuVXNlcnMgPSB7fVxuXG5QQi5Vc2Vycy5yZWNvcmRzICA9IHt9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFwcyB2ZXJzaW9uZWQgdXNlcm5hbWUgdG8gYW4gYXJyYXkgb2YgREhUIHVzZXJSZWNvcmRzXG5QQi5Vc2Vycy5wcm9taXNlcyA9IHt9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGVuZGluZyB1c2VyUmVjb3JkIHJlcXVlc3RzXG5cblxuUEIuVXNlcnMuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBQQi5Vc2Vycy5kZXBlcnNpc3QoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3AgdXNlclJlY29yZHMgb3V0IG9mIGxvY2FsU3RvcmFnZVxufVxuXG5cblBCLlVzZXJzLnByb2Nlc3MgPSBmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgLy8vLyBQcm9jZXNzZXMgYWxsIGluY29taW5nIHVzZXJSZWNvcmRzXG4gICAgXG4gICAgdXNlclJlY29yZCA9IFBCLlVzZXJzLmJ1aWxkKCB1c2VyUmVjb3JkLnVzZXJuYW1lLCB1c2VyUmVjb3JkLmRlZmF1bHRLZXksIHVzZXJSZWNvcmQuYWRtaW5LZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHVzZXJSZWNvcmQucm9vdEtleSwgIHVzZXJSZWNvcmQubGF0ZXN0LCAgICAgdXNlclJlY29yZC5jcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCB1c2VyUmVjb3JkLnVwZGF0ZWQsICB1c2VyUmVjb3JkLnByb2ZpbGUsICAgIHVzZXJSZWNvcmQuaWRlbnRpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHVzZXJSZWNvcmQuY2FwYSApXG4gICAgXG4gICAgaWYoIXVzZXJSZWNvcmQpXG4gICAgICAgIHJldHVybiBQQi5vbkVycm9yKCdUaGF0IGlzIG5vdCBhbiBhY2NlcHRhYmxlIHVzZXIgcmVjb3JkJywgdXNlclJlY29yZClcbiAgICBcbiAgICBQQi5Vc2Vycy5jYWNoZSh1c2VyUmVjb3JkKVxuICAgIFxuICAgIHJldHVybiB1c2VyUmVjb3JkXG59XG5cblxuUEIuVXNlcnMuZ2V0Q2FjaGVkVXNlclJlY29yZCA9IGZ1bmN0aW9uKHVzZXJuYW1lKSB7XG4gICAgaWYoUEIuVXNlcnMubWFrZVZlcnNpb25lZCh1c2VybmFtZSkgPT0gdXNlcm5hbWUpICAgIC8vIHVzZXJuYW1lIGlzIHZlcnNpb25lZFxuICAgICAgICByZXR1cm4gUEIuVXNlcnMucmVjb3Jkc1t1c2VybmFtZV1cbiAgICBcbiAgICByZXR1cm4gUEIuVXNlcnMuZmluZEZyZXNoZXN0KHVzZXJuYW1lKSAgICAgICAgICAgICAgLy8gdXNlcm5hbWUgaXNuJ3QgdmVyc2lvbmVkXG59XG5cblxuLyoqXG4gKiBDaGVja3MgdGhlIGNhY2hlLCBhbmQgYWx3YXlzIHJldHVybnMgYSBwcm9taXNlXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWVcbiAqIEBwYXJhbSB7aW50fSBjYXBhIGlzIHRoZSB2ZXJzaW9uIG9mIHRoZSB1c2VybmFtZSBrZXlzXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBQcm9taXNlIGZvciBhIHVzZXIgcmVjb3JkXG4gKiBMb29rcyBmaXJzdCBpbiB0aGUgY2FjaGUsIHRoZW4gZ3JhYnMgZnJvbSB0aGUgbmV0d29ya1xuICovXG5QQi5Vc2Vycy5nZXRVc2VyUmVjb3JkUHJvbWlzZSA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBjYXBhKSB7XG4gICAgLy8vLyBUaGlzIGFsd2F5cyBjaGVja3MgdGhlIGNhY2hlLCBhbmQgYWx3YXlzIHJldHVybnMgYSBwcm9taXNlXG4gICAgXG4gICAgdmFyIHZlcnNpb25lZFVzZXJuYW1lID0gUEIuVXNlcnMubWFrZVZlcnNpb25lZCh1c2VybmFtZSwgY2FwYSlcbiAgICBcbiAgICB2YXIgdXNlclJlY29yZCA9IFBCLlVzZXJzLmdldENhY2hlZFVzZXJSZWNvcmQodmVyc2lvbmVkVXNlcm5hbWUpXG4gICAgXG4gICAgaWYodXNlclJlY29yZClcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1c2VyUmVjb3JkKVxuICAgIFxuICAgIHZhciB1c2VyUHJvbWlzZSA9IFBCLlVzZXJzLnByb21pc2VzW3ZlcnNpb25lZFVzZXJuYW1lXVxuICAgIFxuICAgIGlmKHVzZXJQcm9taXNlKVxuICAgICAgICByZXR1cm4gdXNlclByb21pc2VcbiAgICBcbiAgICByZXR1cm4gUEIuVXNlcnMuZ2V0VXNlclJlY29yZE5vQ2FjaGUodmVyc2lvbmVkVXNlcm5hbWUpXG59XG5cblxuLyoqXG4gKiBGb3JjZXMgYSByZXF1ZXN0IHRvIHRoZSBuZXR3b3JrLCBpZ25vcmVzIGNhY2hlZFxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lXG4gKiBAcGFyYW0ge2ludH0gY2FwYSBpcyB0aGUgdmVyc2lvbiBvZiB0aGUgdXNlcm5hbWUga2V5c1xuICogQHJldHVybnMge29iamVjdH0gUHJvbWlzZSBmb3IgYSB1c2VyIHJlY29yZFxuICovXG5QQi5Vc2Vycy5nZXRVc2VyUmVjb3JkTm9DYWNoZSA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBjYXBhKSB7XG4gICAgLy8vLyBUaGlzIG5ldmVyIGNoZWNrcyB0aGUgY2FjaGVcbiAgICBcbiAgICBjYXBhID0gY2FwYSB8fCAwIC8vIDAgc2lnbmFscyBQQi5OZXQuZ2V0VXNlclJlY29yZCB0byBnZXQgdGhlIGxhdGVzdCB1c2VyUmVjb3JkXG4gICAgXG4gICAgdmFyIHByb20gPSBQQi5OZXQuZ2V0VXNlclJlY29yZCh1c2VybmFtZSwgY2FwYSkgXG4gICAgXG4gICAgcHJvbSA9IHByb20udGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1c2VyUmVjb3JkID0gUEIuVXNlcnMucHJvY2Vzcyh1c2VyUmVjb3JkKVxuICAgICAgICAgICAgICAgICAgICBpZighdXNlclJlY29yZCkgIFBCLnRocm93RXJyb3IoJ0ludmFsaWQgdXNlciByZWNvcmQgcmV0dXJuZWQnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNlclJlY29yZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAsIFBCLmNhdGNoRXJyb3IoJ1VuYWJsZSB0byBhY2Nlc3MgdXNlciBpbmZvcm1hdGlvbiBmcm9tIHRoZSBESFQnKSlcbiAgICBcbiAgICB2YXIgdmVyc2lvbmVkVXNlcm5hbWUgPSBQQi5Vc2Vycy5tYWtlVmVyc2lvbmVkKHVzZXJuYW1lLCBjYXBhKVxuICAgIFBCLlVzZXJzLnByb21pc2VzW3ZlcnNpb25lZFVzZXJuYW1lXSA9IHByb21cbiAgICBcbiAgICByZXR1cm4gcHJvbVxufVxuXG5QQi5Vc2Vycy5kb2VzVXNlckV4aXN0ID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICByZXR1cm4gUEIuTmV0LmdldFVzZXJSZWNvcmQodXNlcm5hbWUpLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24odXNlclJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICBpZighdXNlclJlY29yZCB8fCB1c2VyUmVjb3JkLkZBSUwpIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1VzZXIgZG9lcyBub3QgZXhpc3QnXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICwgUEIuY2F0Y2hFcnJvcignVW5hYmxlIHRvIGFjY2VzcyB1c2VyIGluZm9ybWF0aW9uIGZyb20gdGhlIERIVCcpKVxufVxuXG5cbi8vXG4vLyBVU0VSTkFNRSBIRUxQRVJTXG4vL1xuXG5QQi5Vc2Vycy51c2VyUmVjb3JkVG9WZXJzaW9uZWRVc2VybmFtZSA9IGZ1bmN0aW9uKHVzZXJSZWNvcmQpIHtcbiAgICByZXR1cm4gUEIuVXNlcnMubWFrZVZlcnNpb25lZCh1c2VyUmVjb3JkLnVzZXJuYW1lLCB1c2VyUmVjb3JkLmNhcGEpXG59XG5cblBCLlVzZXJzLmp1c3RVc2VybmFtZSA9IGZ1bmN0aW9uKHZlcnNpb25lZFVzZXJuYW1lKSB7XG4gICAgdmFyIHVjID0gUEIuVXNlcnMuYnJlYWtWZXJzaW9uZWRVc2VybmFtZSh2ZXJzaW9uZWRVc2VybmFtZSlcbiAgICByZXR1cm4gdWMudXNlcm5hbWVcbn1cblxuUEIuVXNlcnMuanVzdENhcGEgPSBmdW5jdGlvbih2ZXJzaW9uZWRVc2VybmFtZSkge1xuICAgIHZhciB1YyA9IFBCLlVzZXJzLmJyZWFrVmVyc2lvbmVkVXNlcm5hbWUodmVyc2lvbmVkVXNlcm5hbWUpXG4gICAgcmV0dXJuIHVjLmNhcGFcbn1cblxuUEIuVXNlcnMubWFrZVZlcnNpb25lZCA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBjYXBhKSB7XG4gICAgaWYoIXVzZXJuYW1lIHx8ICF1c2VybmFtZS5pbmRleE9mKVxuICAgICAgICByZXR1cm4gJydcbiAgICBcbiAgICBpZihjYXBhKVxuICAgICAgICByZXR1cm4gYWN0dWFsbHlWZXJzaW9uVGhpc1VzZXJuYW1lT2theSh1c2VybmFtZSwgY2FwYSlcbiAgICBcbiAgICBpZih1c2VybmFtZS5pbmRleE9mKCc6JykgPiAwKVxuICAgICAgICByZXR1cm4gdXNlcm5hbWVcbiAgICBcbiAgICByZXR1cm4gYWN0dWFsbHlWZXJzaW9uVGhpc1VzZXJuYW1lT2theSh1c2VybmFtZSlcbiAgICBcbiAgICBmdW5jdGlvbiBhY3R1YWxseVZlcnNpb25UaGlzVXNlcm5hbWVPa2F5KHVzZXJuYW1lLCBjYXBhKSB7XG4gICAgICAgIGNhcGEgPSBjYXBhIHx8IDEgLy8gTk9URTogZGVmYXVsdCBjYXBhXG4gICAgICAgIHJldHVybiB1c2VybmFtZSArICc6JyArIGNhcGFcbiAgICB9XG59XG5cblBCLlVzZXJzLmJyZWFrVmVyc2lvbmVkVXNlcm5hbWUgPSBmdW5jdGlvbih2ZXJzaW9uZWRVc2VybmFtZSkge1xuICAgIHZhciBsaXN0ID0gKHZlcnNpb25lZFVzZXJuYW1lfHwnJykuc3BsaXQoJzonKVxuXG4gICAgcmV0dXJuIHsgdXNlcm5hbWU6IGxpc3RbMF1cbiAgICAgICAgICAgLCBjYXBhOiAgICAgbGlzdFsxXSB8fCAxIC8vIE5PVEU6IGRlZmF1bHQgY2FwYVxuICAgICAgICAgICB9XG59XG5cblxuLy9cbi8vIEdFTkVSQUwgSEVMUEVSU1xuLy9cblxuXG5QQi5Vc2Vycy5idWlsZCA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBkZWZhdWx0S2V5LCBhZG1pbktleSwgcm9vdEtleSwgbGF0ZXN0LCBjcmVhdGVkLCB1cGRhdGVkLCBwcm9maWxlLCBpZGVudGl0eSwgY2FwYSkge1xuICAgIC8vLy8gcmV0dXJucyBhIGNhbm9uaWNhbCB1c2VyIG9iamVjdDogdXNlIHRoaXMgZXZlcnl3aGVyZSB1c2VyIG9iamVjdHMgYXJlIG5lZWRlZCAoREhULCBpZGVudGl0aWVzLCBldGMpXG5cbiAgICBsYXRlc3QgICA9IGxhdGVzdCAgIHx8IFwiXCIgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpZ25hdHVyZSBvZiB0aGUgbW9zdCByZWNlbnQgcHVmZiBwdWJsaXNoZWQgYnkgdGhlIHVzZXJcbiAgICB1cGRhdGVkICA9IHVwZGF0ZWQgIHx8IFwiXCIgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGUgb2YgdGhlIG1vc3QgcmVjZW50IHVwZGF0ZSB0byB0aGUgdXNlcm5hbWVcbiAgICBwcm9maWxlICA9IHByb2ZpbGUgIHx8IFwiXCIgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2ZpbGUgcHVmZiBzaWduYXR1cmVcbiAgICBpZGVudGl0eSA9IGlkZW50aXR5IHx8IFwiXCIgICAgICAgICAgICAgICAgICAgICAgIC8vIGlkZW50aXR5IHB1ZmYgc2lnbmF0dXJlXG4gICAgY2FwYSAgICAgPSBjYXBhICAgICB8fCAxICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmVyc2lvbiBvZiB0aGUgdXNlcm5hbWVcbiAgICBcbiAgICAvLyBUSElOSzogc2hvdWxkIHdlIGNoZWNrIGZvciB2YWxpZCBrZXlzPyB2YWxpZCB0aW1lc3RhbXAgZm9yIHVwZGF0ZWQ/IHdoYXQgaWYgeW91IHdhbnQgYSBwYXJ0aWFsbHkgaW52YWxpZCB1c2VyIGxpa2UgYW5vbj9cbiAgICBcbiAgICAvLyBUSElOSzogc3BsaXQgdXNlcm5hbWUgYW5kIGNhcGEgaWYgaXQncyBhIHZlcnNpb25lZFVzZXJuYW1lP1xuXG4gICAgaWYoIVBCLnZhbGlkYXRlVXNlcm5hbWUodXNlcm5hbWUpKVxuICAgICAgICByZXR1cm4gZmFsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVycm9yIGlzIGxvZ2dlZCBpbnNpZGUgUEIudmFsaWRhdGVVc2VybmFtZVxuICAgIFxuICAgIHJldHVybiB7ICAgdXNlcm5hbWU6IHVzZXJuYW1lICAgICAgICAgICAgICAgICAgIC8vIHVudmVyc2lvbmVkIHVzZXJuYW1lXG4gICAgICAgICAgICwgICAgICAgY2FwYTogY2FwYVxuICAgICAgICAgICAsICAgIHJvb3RLZXk6IHJvb3RLZXkgICAgICAgICAgICAgICAgICAgIC8vIHB1YmxpYyByb290IGtleVxuICAgICAgICAgICAsICAgYWRtaW5LZXk6IGFkbWluS2V5ICAgICAgICAgICAgICAgICAgIC8vIHB1YmxpYyBhZG1pbiBrZXlcbiAgICAgICAgICAgLCBkZWZhdWx0S2V5OiBkZWZhdWx0S2V5ICAgICAgICAgICAgICAgICAvLyBwdWJsaWMgZGVmYXVsdCBrZXlcbiAgICAgICAgICAgLCAgICBjcmVhdGVkOiBjcmVhdGVkICAgICAgICAgICAgICAgICAgICAvLyBEYXRlIHRoZSByZWNvcmQgd2FzIGNyZWF0ZWRcbiAgICAgICAgICAgLCAgICAgbGF0ZXN0OiBsYXRlc3RcbiAgICAgICAgICAgLCAgICB1cGRhdGVkOiB1cGRhdGVkXG4gICAgICAgICAgICwgICAgcHJvZmlsZTogcHJvZmlsZVxuICAgICAgICAgICAsICAgaWRlbnRpdHk6IGlkZW50aXR5XG4gICAgICAgICAgIH1cbn1cblxuXG5QQi5Vc2Vycy51c2VybmFtZXNUb1VzZXJSZWNvcmRzUHJvbWlzZSA9IGZ1bmN0aW9uKHVzZXJuYW1lcykge1xuICAgIC8vLy8gcmV0dXJucyBhIHByb21pc2Ugb2YgdXNlclJlY29yZHMuIHRoYW5rcyB0byBjYXBhIHdlIHVzdWFsbHkgZG9uJ3QgbmVlZCB0aGUgbGF0ZXN0IGFuZCBjYW4gdXNlIGNhY2hlZCB2ZXJzaW9ucy5cbiAgICBpZighdXNlcm5hbWVzIHx8ICF1c2VybmFtZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKVxuICAgIFxuICAgIGlmKCFBcnJheS5pc0FycmF5KHVzZXJuYW1lcykpXG4gICAgICAgIHVzZXJuYW1lcyA9IFt1c2VybmFtZXNdXG4gICAgICAgIFxuICAgIHZhciB1c2VyUmVjb3JkcyA9IHVzZXJuYW1lcy5tYXAoUEIuVXNlcnMuZ2V0Q2FjaGVkVXNlclJlY29yZCkuZmlsdGVyKEJvb2xlYW4pXG4gICAgXG4gICAgaWYgKHVzZXJSZWNvcmRzLmxlbmd0aCA9PSB1c2VybmFtZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVzZXJSZWNvcmRzKSAvLyBnb3QgJ2VtIGFsbCFcbiAgICBcbiAgICB2YXIgcHJvbSA9IFByb21pc2UucmVzb2x2ZSgpIC8vIGEgcHJvbWlzZSB3ZSB1c2UgdG8gc3RyaW5nIGV2ZXJ5dGhpbmcgYWxvbmdcblxuICAgIHZhciB1c2VyUmVjb3JkVXNlcm5hbWVzID0gdXNlclJlY29yZHMubWFwKGZ1bmN0aW9uICh1c2VyUmVjb3JkKSB7XG4gICAgICAgIHJldHVybiB1c2VyUmVjb3JkLnVzZXJuYW1lXG4gICAgfSlcbiAgICBcbiAgICB1c2VybmFtZXMuZm9yRWFjaChmdW5jdGlvbiAodXNlcm5hbWUpIHtcbiAgICAgICAgaWYgKCF+dXNlclJlY29yZFVzZXJuYW1lcy5pbmRleE9mKHVzZXJuYW1lKSkgeyAvLyB3ZSBuZWVkIHRoaXMgb25lXG4gICAgICAgICAgICBwcm9tID0gcHJvbS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQQi5Vc2Vycy5nZXRVc2VyUmVjb3JkTm9DYWNoZSh1c2VybmFtZSkudGhlbihmdW5jdGlvbiAodXNlclJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICB1c2VyUmVjb3Jkcy5wdXNoKHVzZXJSZWNvcmQpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIHJldHVybiBwcm9tLnRoZW4oZnVuY3Rpb24oKSB7IHJldHVybiB1c2VyUmVjb3JkcyB9KSAvLyB3aGVuIGl0J3MgYWxsIGRvbmUsIGdpdmUgYmFjayB0aGUgdXNlclJlY29yZHNcbn1cblxuUEIuVXNlcnMuY2FjaGUgPSBmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgLy8vLyBUaGlzIGNhY2hlcyB3aXRoIG5vIHZhbGlkYXRpb246IHVzZSBQQi5Vc2Vycy5wcm9jZXNzIGluc3RlYWRcbiAgICBcbiAgICB2YXIgdmVyc2lvbmVkVXNlcm5hbWUgPSBQQi5Vc2Vycy51c2VyUmVjb3JkVG9WZXJzaW9uZWRVc2VybmFtZSh1c2VyUmVjb3JkKVxuICAgIFxuICAgIFBCLlVzZXJzLnJlY29yZHNbdmVyc2lvbmVkVXNlcm5hbWVdID0gdXNlclJlY29yZFxuICAgIFxuICAgIGRlbGV0ZSBQQi5Vc2Vycy5wcm9taXNlc1t2ZXJzaW9uZWRVc2VybmFtZV1cbiAgICBcbiAgICBQQi5QZXJzaXN0LnNhdmUoJ3VzZXJSZWNvcmRzJywgUEIuVXNlcnMucmVjb3JkcylcbiAgICBcbiAgICByZXR1cm4gdXNlclJlY29yZFxufVxuXG5QQi5Vc2Vycy5kZXBlcnNpc3QgPSBmdW5jdGlvbigpIHtcbiAgICAvLy8vIGdyYWIgdXNlclJlY29yZHMgZnJvbSBsb2NhbCBzdG9yYWdlLiB0aGlzIHNtYXNoZXMgdGhlIGN1cnJlbnQgdXNlclJlY29yZHMgaW4gbWVtb3J5LCBzbyBkb24ndCBjYWxsIGl0IGFmdGVyIGluaXQhXG4gICAgUEIuVXNlcnMucmVjb3JkcyA9IFBCLlBlcnNpc3QuZ2V0KCd1c2VyUmVjb3JkcycpIHx8IHt9XG59XG5cblxuUEIuVXNlcnMuZmluZEZyZXNoZXN0ID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICB1c2VybmFtZSA9IFBCLlVzZXJzLmp1c3RVc2VybmFtZSh1c2VybmFtZSlcbiAgICBcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKFBCLlVzZXJzLnJlY29yZHMpXG4gICAgdmFyIGNhcGEgPSAwXG4gICAgXG4gICAga2V5cy5maWx0ZXIoZnVuY3Rpb24odmVyc2lvbmVkVXNlcm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFBCLlVzZXJzLmp1c3RVc2VybmFtZSh2ZXJzaW9uZWRVc2VybmFtZSkgPT0gdXNlcm5hbWVcbiAgICB9KS5mb3JFYWNoKCBmdW5jdGlvbih2ZXJzaW9uZWRVc2VybmFtZSkge1xuICAgICAgICB2YXIgdGhpc19jYXBhID0gK1BCLlVzZXJzLmp1c3RDYXBhKHZlcnNpb25lZFVzZXJuYW1lKVxuICAgICAgICBpZih0aGlzX2NhcGEgPiBjYXBhKVxuICAgICAgICAgICAgY2FwYSA9IHRoaXNfY2FwYVxuICAgIH0pXG4gICAgXG4gICAgdmFyIHZlcnNpb25lZFVzZXJuYW1lID0gUEIuVXNlcnMubWFrZVZlcnNpb25lZCh1c2VybmFtZSwgY2FwYSlcbiAgICByZXR1cm4gUEIuVXNlcnMucmVjb3Jkc1t2ZXJzaW9uZWRVc2VybmFtZV1cbn1cblxuXG5cblxuLy9cbi8vIENMRUFOVVAgUkVRVUlSRURcbi8vXG5cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgdXNlcidzIERIVCByZWNvcmQsIG9yIGNyZWF0ZSBhIG5ldyBhbm9uIHVzZXIsIG9yIGRpZSB0cnlpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuUEIuVXNlcnMuZ2V0VXBUb0RhdGVVc2VyQXRBbnlDb3N0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8vLyBFaXRoZXIgZ2V0IHRoZSBjdXJyZW50IHVzZXIncyBESFQgcmVjb3JkLCBvciBjcmVhdGUgYSBuZXcgYW5vbiB1c2VyLCBvciBkaWUgdHJ5aW5nXG5cbiAgICB2YXIgdXNlcm5hbWUgPSBQQi5nZXRDdXJyZW50VXNlcm5hbWUoKVxuXG4gICAgaWYodXNlcm5hbWUpXG4gICAgICAgIHJldHVybiBQQi5Vc2Vycy5nZXRVc2VyUmVjb3JkTm9DYWNoZSh1c2VybmFtZSwgMCkgLy8gMCB0ZWxscyBQQi5OZXQuZ2V0VXNlclJlY29yZCB0byBmZXRjaCB0aGUgbGF0ZXN0XG4gICAgXG4gICAgdmFyIHByb20gPSBQQi5Vc2Vycy5hZGROZXdBbm9uVXNlcigpXG4gICAgXG4gICAgcmV0dXJuIHByb20udGhlbihmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgICAgIFBCLnN3aXRjaElkZW50aXR5VG8odXNlclJlY29yZC51c2VybmFtZSlcbiAgICAgICAgY29uc29sZS5sb2coXCJTZXR0aW5nIGN1cnJlbnQgdXNlciB0byBcIiArIHVzZXJSZWNvcmQudXNlcm5hbWUpXG4gICAgICAgIHJldHVybiB1c2VyUmVjb3JkXG4gICAgfSlcbn1cblxuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIHVzZXJuYW1lXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblBCLlVzZXJzLmdlbmVyYXRlUmFuZG9tVXNlcm5hbWUgPSBmdW5jdGlvbihsZW4pIHtcblxuICAgIC8vIFNldCBhIGRlZmF1bHQgdmFsdWUgZm9yIGxlbmd0aFxuICAgIGlmKCFsZW4gfHwgbGVuICE9IE1hdGgucm91bmQobGVuKSlcbiAgICAgICAgbGVuPTEwXG5cbiAgICB2YXIgZ2VuZXJhdGVkTmFtZSA9ICcnXG4gICAgdmFyIGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSdcbiAgICBmb3IodmFyIGk9MDsgaTwxMDsgaSsrKSB7XG4gICAgICAgIGdlbmVyYXRlZE5hbWUgKz0gUEIuQ3J5cHRvLmdldFJhbmRvbUl0ZW0oYWxwaGFiZXQpXG4gICAgfVxuICAgIHJldHVybiBnZW5lcmF0ZWROYW1lXG59XG5cbi8qKlxuICpcbiAqIFJlZ2lzdGVyIGEgbmV3IGFub255bW91cyB1c2VyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFzc3BocmFzZSBvcHRpb25hbCBpZiBpbmNsdWRlZCB0aGVuIHVzZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRhY2hUb1VzZXJuYW1lXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHVzZXIgcmVjb3JkIG9yIGZhaWxzXG4gKi9cblBCLlVzZXJzLmFkZE5ld0Fub25Vc2VyID0gZnVuY3Rpb24ocGFzc3BocmFzZSwgYXR0YWNoVG9Vc2VybmFtZSkge1xuICAgIC8vLy8gY3JlYXRlIGEgbmV3IGFub255bW91cyBhbGlhcy4gaWYgYXR0YWNoVG9Vc2VybmFtZSBpcyBwcm92aWRlZCBpdCBiZWNvbWVzIGFuIGFsaWFzIGZvciB0aGF0IGlkZW50aXR5LlxuICAgIC8vLy8gaWYgYXR0YWNoVG9Vc2VybmFtZSBpcyBmYWxzZSB0aGUgYWxpYXMgYmVjb21lcyBwcmltYXJ5IGZvciBpdHMgb3duIGlkZW50aXR5LlxuICAgIC8vIFRPRE86IG1ha2UgYXR0YWNoVG9Vc2VybmFtZSB3b3JrXG4gICAgLy8gVEhJTks6IERvbid0IHdhbnQgdG8gc3dpdGNoIHRvIHRoaXMgdXNlciwgYnV0IHdoYXQgYWJvdXQgYWxpYXMgaXNzdWUgYW5kIHNhdmluZyBib251cyBpbmZvP1xuICAgIC8vIFRPRE86IFNwbGl0IHRoaXMgaW50byB0d28gZnVuY3Rpb25zLCBvbmUgdGhhdCByZWdpc3RlcnMgYW4gYW5vbiB1c2VyIGJhc2VkIG9uIGdpdmVuIGluZm9cbiAgICAvLyBhbm90aGVyIHRoYXQgcmVnaXN0ZXJzIGFub24gdXNlciBBTkQgc3dpdGNoZXMgY3VycmVudCB0byB0aGF0IHVzZXIuIE9yIGZsYWcgaW4gZnVuY3Rpb24gdG8gc3dpdGNoIHRvIHRoYXQgdXNlci5cblxuICAgIHZhciBuZXdVc2VybmFtZSA9ICdhbm9uLicgKyBQQi5Vc2Vycy5nZW5lcmF0ZVJhbmRvbVVzZXJuYW1lKDEyKVxuXG4gICAgaWYodHlwZW9mIHBhc3NwaHJhc2UgIT09IHVuZGVmaW5lZCAmJiBwYXNzcGhyYXNlKSB7XG4gICAgICAgIHZhciBwcmVwZW5kZWRQYXNzcGhyYXNlID0gbmV3VXNlcm5hbWUgKyBwYXNzcGhyYXNlXG4gICAgICAgIHZhciBwcml2YXRlS2V5ID0gUEIuQ3J5cHRvLnBhc3NwaHJhc2VUb1ByaXZhdGVLZXlXaWYocHJlcGVuZGVkUGFzc3BocmFzZSlcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJpdmF0ZUtleSA9IFBCLkNyeXB0by5nZW5lcmF0ZVByaXZhdGVLZXkoKVxuICAgIH1cblxuICAgIC8vIFNldCBwcml2YXRlIGtleXNcbiAgICB2YXIgcHJpdmF0ZVJvb3RLZXkgPSAgICBwcml2YXRlS2V5XG4gICAgdmFyIHByaXZhdGVBZG1pbktleSA9ICAgcHJpdmF0ZUtleVxuICAgIHZhciBwcml2YXRlRGVmYXVsdEtleSA9IHByaXZhdGVLZXlcblxuICAgIC8vIEdlbmVyYXRlIHB1YmxpYyBrZXlzXG4gICAgdmFyIHJvb3RLZXkgICAgPSBQQi5DcnlwdG8ucHJpdmF0ZVRvUHVibGljKHByaXZhdGVLZXkpXG4gICAgdmFyIGFkbWluS2V5ICAgPSBQQi5DcnlwdG8ucHJpdmF0ZVRvUHVibGljKHByaXZhdGVLZXkpXG4gICAgdmFyIGRlZmF1bHRLZXkgPSBQQi5DcnlwdG8ucHJpdmF0ZVRvUHVibGljKHByaXZhdGVLZXkpXG5cbiAgICAvLyBidWlsZCBvdXIgREhUIHVwZGF0ZSBwdWZmXG4gICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICAgIHJlcXVlc3RlZFVzZXJuYW1lOiBuZXdVc2VybmFtZSxcbiAgICAgICAgZGVmYXVsdEtleTogZGVmYXVsdEtleSxcbiAgICAgICAgYWRtaW5LZXk6IGFkbWluS2V5LFxuICAgICAgICByb290S2V5OiByb290S2V5LFxuICAgICAgICB0aW1lOiBEYXRlLm5vdygpXG4gICAgfVxuXG4gICAgdmFyIHJvdXRpbmcgPSBbXSAvLyBUSElOSzogREhUP1xuICAgIHZhciBjb250ZW50ID0gJ3JlcXVlc3RVc2VybmFtZSdcbiAgICB2YXIgdHlwZSAgICA9ICd1cGRhdGVVc2VyUmVjb3JkJ1xuXG4gICAgdmFyIHB1ZmYgPSBQQi5idWlsZFB1ZmYoJ2Fub24nLCBQQi5DT05GSUcuYW5vblByaXZhdGVBZG1pbktleSwgcm91dGluZywgdHlwZSwgY29udGVudCwgcGF5bG9hZClcblxuICAgIHJldHVybiBQQi5OZXQudXBkYXRlVXNlclJlY29yZChwdWZmKVxuXG59XG5cblBCLlVzZXJzLmNyZWF0ZUFub25Vc2VyQW5kTWFrZUN1cnJlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmV3VXNlcm5hbWUgPSAnYW5vbi4nICsgUEIuVXNlcnMuZ2VuZXJhdGVSYW5kb21Vc2VybmFtZSgxMilcbiAgICB2YXIgcGFzc3BocmFzZSA9IFBCLkNyeXB0by5nZW5lcmF0ZVByaXZhdGVLZXkoKS5zbGljZSgtMTIpXG4gICAgdmFyIHByZXBlbmRlZFBhc3NwaHJhc2UgPSBuZXdVc2VybmFtZSArIHBhc3NwaHJhc2VcbiAgICB2YXIgcHJpdmF0ZUtleSA9IFBCLkNyeXB0by5wYXNzcGhyYXNlVG9Qcml2YXRlS2V5V2lmKHByZXBlbmRlZFBhc3NwaHJhc2UpXG4gICAgdmFyIHB1YmxpY0tleSA9IFBCLkNyeXB0by5wcml2YXRlVG9QdWJsaWMocHJpdmF0ZUtleSlcblxuICAgIC8vIEJ1aWxkIHB1ZmYgdG8gcmVnaXN0ZXIgdGhpcyB1c2VyXG4gICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICAgIHJlcXVlc3RlZFVzZXJuYW1lOiBuZXdVc2VybmFtZSxcbiAgICAgICAgZGVmYXVsdEtleTogcHVibGljS2V5LFxuICAgICAgICBhZG1pbktleTogcHVibGljS2V5LFxuICAgICAgICByb290S2V5OiBwdWJsaWNLZXksXG4gICAgICAgIHRpbWU6IERhdGUubm93KClcbiAgICB9XG5cbiAgICB2YXIgcm91dGluZyA9IFtdIC8vIFRISU5LOiBESFQ/XG4gICAgdmFyIGNvbnRlbnQgPSAncmVxdWVzdFVzZXJuYW1lJ1xuICAgIHZhciB0eXBlICAgID0gJ3VwZGF0ZVVzZXJSZWNvcmQnXG5cbiAgICB2YXIgcHVmZiA9IFBCLmJ1aWxkUHVmZignYW5vbicsIFBCLkNPTkZJRy5hbm9uUHJpdmF0ZUFkbWluS2V5LCByb3V0aW5nLCB0eXBlLCBjb250ZW50LCBwYXlsb2FkKVxuXG4gICAgdmFyIHByb20gPSBQQi5OZXQudXBkYXRlVXNlclJlY29yZChwdWZmKVxuXG4gICAgLy8gV29ya3M/XG4gICAgcmV0dXJuIHByb20udGhlbihmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgICAgIC8vIFN3aXRjaCB0byB0aGlzIHVzZXJcbiAgICAgICAgUEIuYWRkQWxpYXModXNlclJlY29yZC51c2VybmFtZSwgdXNlclJlY29yZC51c2VybmFtZSwgMSwgcHJpdmF0ZUtleSwgcHJpdmF0ZUtleSwgcHJpdmF0ZUtleSwge3Bhc3NwaHJhc2U6IHBhc3NwaHJhc2V9KVxuXG4gICAgICAgIFBCLnN3aXRjaElkZW50aXR5VG8odXNlclJlY29yZC51c2VybmFtZSlcblxuICAgIH0pXG59XG5cbiIsIi8qXG4gICAgQ3J5cHRvZ3JhcGhpYyBtYW5hZ2VtZW50IGZvciB0aGUgRXZlcnlCaXQgcGxhdGZvcm0uXG5cbiAgICBDb250YWlucyB2YXJpb3VzIGZ1bmN0aW9ucyB0aGF0IHJlbHkgb24gYml0Y29pbi1saWIuanMgZm9yIHRoZWlyIGNyeXB0b2dyYXBoaWMgZnVuY3Rpb25hbGl0eSxcbiAgICBhbiBFQ0RIIGltcGxlbWVudGF0aW9uLCBhIHJhbmRvbSBudW1iZXIgc2hpbSBmb3Igb2xkZXIgYnJvd3NlcnMsIGFuZCByYW5kb20gaGVscGVyIGZ1bmN0aW9ucy5cblxuICAgIENvcHlyaWdodCAyMDE0IEV2ZXJ5Qml0LiBTZWUgUkVBRE1FIGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG4qL1xuXG5QQi5DcnlwdG8gPSB7fTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBwcml2YXRlIGtleVxuICogQHJldHVybiB7c3RyaW5nfSBcbiAqL1xuUEIuQ3J5cHRvLmdlbmVyYXRlUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIE9QVDogcmVtb3ZlIHRoaXMgdGVzdCBvbmNlIEJpdGNvaW4uRUNLZXkgbm8gbG9uZ2VyIGdlbmVyYXRlcyBpbnZhbGlkIGtleXMgKGFib3V0IDEgaW4gMSwwMDAgcmlnaHQgbm93KVxuICAgIHZhciBwcmlrZXkgPSBuZXcgQml0Y29pbi5FQ0tleSgpLnRvV2lmKClcbiAgICBpZihQQi5DcnlwdG8ud2lmVG9QcmlLZXkocHJpa2V5KSlcbiAgICAgICAgcmV0dXJuIHByaWtleVxuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIFBCLkNyeXB0by5nZW5lcmF0ZVByaXZhdGVLZXkoKSAgLy8gVEhJTks6IHRoaXMgY291bGQgZ2VuZXJhdGUgYW4gZXRlcm5hbCBlcnJvciBleHBsb3Npb25cbn1cblxuXG4vKipcbiAqIENvbnZlcnQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHByaXZhdGVLZXlXSUZcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuUEIuQ3J5cHRvLnByaXZhdGVUb1B1YmxpYyA9IGZ1bmN0aW9uKHByaXZhdGVLZXlXSUYpIHtcbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCByZXR1cm4gZmFsc2UgaWYgc3RyaW5nIGlzIGVtcHR5XG4gICAgaWYoIXByaXZhdGVLZXlXSUYpXG4gICAgICAgIHJldHVybiBQQi5vbkVycm9yKCdUaGF0IHByaXZhdGUga2V5IGNvbnRhaW5lZCBubyBkYXRhJylcbiAgICAgICAgXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFBCLkNyeXB0by53aWZUb1ByaUtleShwcml2YXRlS2V5V0lGKS5nZXRQdWIodHJ1ZSkudG9XaWYoKVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIHJldHVybiBQQi5vbkVycm9yKCdJbnZhbGlkIHByaXZhdGUga2V5OiBjb3VsZCBub3QgY29udmVydCB0byBwdWJsaWMga2V5JywgW3ByaXZhdGVLZXlXSUYsIGVycl0pXG4gICAgfVxufVxuXG5cbi8qKlxuICogU2lnbiB0aGUgaGFzaCBvZiBzb21lIGRhdGEgd2l0aCBhIHByaXZhdGUga2V5IGFuZCByZXR1cm4gdGhlIHNpZyBpbiBiYXNlIDU4XG4gKiBAcGFyYW0gIHtvYmplY3R9IHVuc2lnbmVkUHVmZlxuICogQHBhcmFtICB7c3RyaW5nfSBwcml2YXRlS2V5V0lGXG4gKiBAcmV0dXJuIHsoYm9vbGVhbnxlcnJvcil9XG4gKi9cblBCLkNyeXB0by5zaWduUHVmZiA9IGZ1bmN0aW9uKHVuc2lnbmVkUHVmZiwgcHJpdmF0ZUtleVdJRikge1xuICAgIC8vLy8gc2lnbiB0aGUgaGFzaCBvZiBzb21lIGRhdGEgd2l0aCBhIHByaXZhdGUga2V5IGFuZCByZXR1cm4gdGhlIHNpZyBpbiBiYXNlIDU4XG5cbiAgICB2YXIgcHJpa2V5ID0gUEIuQ3J5cHRvLndpZlRvUHJpS2V5KHByaXZhdGVLZXlXSUYpXG4gICAgdmFyIG1lc3NhZ2UgPSBQQi5DcnlwdG8ucHVmZlRvU2lnbGVzc1N0cmluZyh1bnNpZ25lZFB1ZmYpXG4gICAgdmFyIG1lc3NhZ2VIYXNoID0gUEIuQ3J5cHRvLmNyZWF0ZU1lc3NhZ2VIYXNoKG1lc3NhZ2UpXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEJpdGNvaW4uYmFzZTU4LmVuY29kZShwcmlrZXkuc2lnbihtZXNzYWdlSGFzaCkpXG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ0NvdWxkIG5vdCBwcm9wZXJseSBlbmNvZGUgc2lnbmF0dXJlJywgW3ByaWtleSwgbWVzc2FnZUhhc2gsIGVycl0pXG4gICAgfVxufVxuXG5cbi8qKlxuICogdG8gdmVyaWZ5IHB1ZmYgc2lnXG4gKiBAcGFyYW0gIHtvYmplY3R9IHB1ZmZcbiAqIEBwYXJhbSAge3N0cmluZ30gZGVmYXVsdEtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuUEIuQ3J5cHRvLnZlcmlmeVB1ZmZTaWcgPSBmdW5jdGlvbihwdWZmLCBkZWZhdWx0S2V5KSB7XG4gICAgdmFyIHB1ZmZTdHJpbmcgPSBQQi5DcnlwdG8ucHVmZlRvU2lnbGVzc1N0cmluZyhwdWZmKTtcbiAgICByZXR1cm4gUEIuQ3J5cHRvLnZlcmlmeU1lc3NhZ2UocHVmZlN0cmluZywgcHVmZi5zaWcsIGRlZmF1bHRLZXkpO1xufVxuXG4vKipcbiAqIGFjY2VwdCBhIGJhc2UgNTggc2lnLCBhIG1lc3NhZ2UgKG11c3QgYmUgYSBzdHJpbmcpIGFuZCBhIGJhc2UgNTggcHVibGljIGtleS4gcmV0dXJucyB0cnVlIGlmIHRoZXkgbWF0Y2gsIGZhbHNlIG90aGVyd2lzZVxuICogQHBhcmFtICB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNpZ1xuICogQHBhcmFtICB7c3RyaW5nfSBwdWJsaWNLZXlXSUZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblBCLkNyeXB0by52ZXJpZnlNZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSwgc2lnLCBwdWJsaWNLZXlXSUYpIHtcbiAgICAvLy8vIGFjY2VwdCBhIGJhc2UgNTggc2lnLCBhIG1lc3NhZ2UgKG11c3QgYmUgYSBzdHJpbmcpIGFuZCBhIGJhc2UgNTggcHVibGljIGtleS4gcmV0dXJucyB0cnVlIGlmIHRoZXkgbWF0Y2gsIGZhbHNlIG90aGVyd2lzZVxuICBcbiAgICB0cnkge1xuICAgICAgICB2YXIgcHVia2V5ID0gUEIuQ3J5cHRvLndpZlRvUHViS2V5KHB1YmxpY0tleVdJRilcbiAgICAgICAgXG4gICAgICAgIHZhciBzaWdCeXRlcyA9IEJpdGNvaW4uYmFzZTU4LmRlY29kZShzaWcpLnRvSlNPTigpXG4gICAgICAgIHNpZ0J5dGVzID0gc2lnQnl0ZXMuZGF0YSB8fCBzaWdCeXRlc1xuICAgICAgICBcbiAgICAgICAgdmFyIG1lc3NhZ2VIYXNoID0gUEIuQ3J5cHRvLmNyZWF0ZU1lc3NhZ2VIYXNoKG1lc3NhZ2UpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcHVia2V5LnZlcmlmeShtZXNzYWdlSGFzaCwgc2lnQnl0ZXMpXG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ0ludmFsaWQga2V5IG9yIHNpZzogY291bGQgbm90IHZlcmlmeSBtZXNzYWdlJywgW21lc3NhZ2VIYXNoLCBzaWcsIHB1YmxpY0tleVdJRiwgZXJyXSlcbiAgICB9XG59XG5cbi8qKlxuICogdG8gY3JlYXRlIG1lc3NhZ2UgaGFzaFxuICogQHBhcmFtICB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblBCLkNyeXB0by5jcmVhdGVNZXNzYWdlSGFzaCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gQml0Y29pbi5DcnlwdG8uU0hBMjU2KG1lc3NhZ2UpLnRvU3RyaW5nKClcbn1cblxuLyoqXG4gKiBjcnlwdCB3aWYgdG8gcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSAge3N0cmluZ30gcHJpdmF0ZUtleVdJRlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuUEIuQ3J5cHRvLndpZlRvUHJpS2V5ID0gZnVuY3Rpb24ocHJpdmF0ZUtleVdJRikge1xuICAgIGlmKCFwcml2YXRlS2V5V0lGKVxuICAgICAgICByZXR1cm4gUEIub25FcnJvcignVGhhdCBwcml2YXRlIGtleSB3aWYgY29udGFpbnMgbm8gZGF0YScpXG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IEJpdGNvaW4uRUNLZXkocHJpdmF0ZUtleVdJRiwgdHJ1ZSlcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICByZXR1cm4gUEIub25FcnJvcignSW52YWxpZCBwcml2YXRlIGtleTogYXJlIHlvdSBzdXJlIGl0IGlzIHByb3Blcmx5IFdJRmZlZD8nLCBbcHJpdmF0ZUtleVdJRiwgZXJyXSlcbiAgICB9XG59XG5cbi8qKlxuICogY3J5cHQgd2lmIHRvIHB1YmxpYyB0cnlcbiAqIEBwYXJhbSAge3N0cmluZ30gcHVibGljS2V5V0lGXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5QQi5DcnlwdG8ud2lmVG9QdWJLZXkgPSBmdW5jdGlvbihwdWJsaWNLZXlXSUYpIHtcbiAgICBpZighcHVibGljS2V5V0lGKVxuICAgICAgICByZXR1cm4gUEIub25FcnJvcignVGhhdCBwdWJsaWMga2V5IHdpZiBjb250YWlucyBubyBkYXRhJylcblxuICAgIHRyeSB7XG4gICAgICAgIHZhciBwdWJrZXlCeXRlcyA9IEJpdGNvaW4uYmFzZTU4Y2hlY2suZGVjb2RlKHB1YmxpY0tleVdJRikucGF5bG9hZC50b0pTT04oKVxuICAgICAgICBwdWJrZXlCeXRlcyA9IHB1YmtleUJ5dGVzLmRhdGEgfHwgcHVia2V5Qnl0ZXNcbiAgICAgICAgcmV0dXJuIG5ldyBCaXRjb2luLkVDUHViS2V5KHB1YmtleUJ5dGVzLCB0cnVlKVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIHJldHVybiBQQi5vbkVycm9yKCdJbnZhbGlkIHB1YmxpYyBrZXk6IGFyZSB5b3Ugc3VyZSBpdCBpcyBwcm9wZXJseSBXSUZmZWQ/JywgW3B1YmxpY0tleVdJRiwgZXJyXSlcbiAgICB9XG59XG5cbi8qKlxuICogY3J5cHQgcHVmZiB0byBzdHJpbmcgd2l0aG91dCBzaWdcbiAqIEBwYXJhbSAge29iamVjdH0gcHVmZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5QQi5DcnlwdG8ucHVmZlRvU2lnbGVzc1N0cmluZyA9IGZ1bmN0aW9uKHB1ZmYpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocHVmZiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge2lmKGtleSA9PSAnc2lnJykgcmV0dXJuIHVuZGVmaW5lZDsgcmV0dXJuIHZhbHVlfSlcbn1cblxuXG5QQi5DcnlwdG8ucGFzc3BocmFzZVRvUHJpdmF0ZUtleVdpZiA9IGZ1bmN0aW9uKHBhc3NwaHJhc2UpIHtcbiAgICB2YXIgaGFzaFN0ciA9IEJpdGNvaW4uQ3J5cHRvLlNIQTI1NihwYXNzcGhyYXNlKS50b1N0cmluZygpXG4gICAgaGFzaCA9IEJpdGNvaW4uY29udmVydC5oZXhUb0J5dGVzKGhhc2hTdHIpXG4gICAgcmV0dXJuIEJpdGNvaW4uRUNLZXkoaGFzaCkudG9XaWYoKVxufVxuXG5cbi8qKlxuICogdG8gZW5jcnlwdCB3aXRoIEFFU1xuICogQHBhcmFtICB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5QQi5DcnlwdG8uZW5jcnlwdFdpdGhBRVMgPSBmdW5jdGlvbihtZXNzYWdlLCBrZXkpIHtcbiAgICB2YXIgZW5jID0gQml0Y29pbi5DcnlwdG8uQUVTLmVuY3J5cHQobWVzc2FnZSwga2V5KVxuICAgIHJldHVybiBCaXRjb2luLkNyeXB0by5mb3JtYXQuT3BlblNTTC5zdHJpbmdpZnkoZW5jKVxufVxuXG4vKipcbiAqIHRvIGRlY3J5cHQgd2l0aCBBRVNcbiAqIEBwYXJhbSAge3N0cmluZ30gbWVzc2FnZVxuICogQHBhcmFtICB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuUEIuQ3J5cHRvLmRlY3J5cHRXaXRoQUVTID0gZnVuY3Rpb24oZW5jLCBrZXkpIHtcbiAgICBpZigha2V5IHx8ICFlbmMpIHJldHVybiBmYWxzZVxuICAgIHZhciBtZXNzYWdlID0gQml0Y29pbi5DcnlwdG8uZm9ybWF0Lk9wZW5TU0wucGFyc2UoZW5jKVxuICAgIHZhciB3b3JkcyA9IEJpdGNvaW4uQ3J5cHRvLkFFUy5kZWNyeXB0KG1lc3NhZ2UsIGtleSlcbiAgICB2YXIgYnl0ZXMgPSBCaXRjb2luLmNvbnZlcnQud29yZHNUb0J5dGVzKHdvcmRzLndvcmRzKSBcbiAgICAvLyB2YXIgdWdseVJlZ2V4ID0gL1tcXHUwMDAyXFx1MDAwNFxcdTAwMDdcXHUwMDBlXSskL2dcbiAgICB2YXIgdWdseVJlZ2V4ID0gL1tcXHUwMDAwLVxcdTAwMTBdKyQvZyAvLyBUT0RPOiBjb250YWluIEFFUyBwYWRkaW5nXG4gICAgcmV0dXJuIGJ5dGVzLm1hcChmdW5jdGlvbih4KSB7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoeCl9KS5qb2luKCcnKS5yZXBsYWNlKHVnbHlSZWdleCwgJycpXG59XG5cbi8qKlxuICogR2V0IHRoZSBzaGFyZWQgc2VjcmV0IG9mIHR3byB1c2Vyc1xuICogQHBhcmFtICB7c3RyaW5nfSB5b3VyUHVibGljV2lmXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG15UHJpdmF0ZVdpZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5QQi5DcnlwdG8uZ2V0T3VyU2hhcmVkU2VjcmV0ID0gZnVuY3Rpb24oeW91clB1YmxpY1dpZiwgbXlQcml2YXRlV2lmKSB7XG4gICAgLy8gVE9ETzogdW5pdCB0ZXN0aW5nIGZvciBFQ0RIIG1hdGhzXG4gICAgdmFyIHB1YmtleSA9IFBCLkNyeXB0by53aWZUb1B1YktleSh5b3VyUHVibGljV2lmKVxuICAgIHZhciBwcmlrZXkgPSBQQi5DcnlwdG8ud2lmVG9QcmlLZXkobXlQcml2YXRlV2lmKVxuICAgIGlmKCFwdWJrZXkgfHwgIXByaWtleSkgcmV0dXJuIGZhbHNlICBcbiAgICB2YXIgc2VjcmV0ID0gcHVia2V5Lm11bHRpcGx5KHByaWtleSkudG9XaWYoKVxuICAgIHZhciBrZXkgPSBCaXRjb2luLkNyeXB0by5TSEEyNTYoc2VjcmV0KS50b1N0cmluZygpXG4gICAgXG4gICAgcmV0dXJuIGtleVxufVxuXG4vKipcbiAqIEVuY29kZSBwcml2YXRlIG1lc3NhZ2VcbiAqIEBwYXJhbSAge3N0cmluZ30gcGxhaW50ZXh0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHlvdXJQdWJsaWNXaWZcbiAqIEBwYXJhbSAge3N0cmluZ30gbXlQcml2YXRlV2lmXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblBCLkNyeXB0by5lbmNyeXB0UHJpdmF0ZU1lc3NhZ2UgPSBmdW5jdGlvbihwbGFpbnRleHQsIHlvdXJQdWJsaWNXaWYsIG15UHJpdmF0ZVdpZikge1xuICAgIHZhciBrZXkgPSBQQi5DcnlwdG8uZ2V0T3VyU2hhcmVkU2VjcmV0KHlvdXJQdWJsaWNXaWYsIG15UHJpdmF0ZVdpZilcbiAgICBpZigha2V5KSByZXR1cm4gZmFsc2VcbiAgICB2YXIgY2lwaGVydGV4dCA9IFBCLkNyeXB0by5lbmNyeXB0V2l0aEFFUyhwbGFpbnRleHQsIGtleSlcbiAgICByZXR1cm4gY2lwaGVydGV4dFxufVxuXG4vKipcbiAqIHRvIGRlY29kZSBwcml2YXRlIG1lc3NhZ2VcbiAqIEBwYXJhbSAge3N0cmluZ30gcGxhaW50ZXh0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHlvdXJQdWJsaWNXaWZcbiAqIEBwYXJhbSAge3N0cmluZ30gbXlQcml2YXRlV2lmXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblBCLkNyeXB0by5kZWNyeXB0UHJpdmF0ZU1lc3NhZ2UgPSBmdW5jdGlvbihjaXBoZXJ0ZXh0LCB5b3VyUHVibGljV2lmLCBteVByaXZhdGVXaWYpIHtcbiAgICB2YXIga2V5ID0gUEIuQ3J5cHRvLmdldE91clNoYXJlZFNlY3JldCh5b3VyUHVibGljV2lmLCBteVByaXZhdGVXaWYpXG4gICAgaWYoIWtleSB8fCAhY2lwaGVydGV4dCkgcmV0dXJuIGZhbHNlXG4gICAgdmFyIHBsYWludGV4dCA9IFBCLkNyeXB0by5kZWNyeXB0V2l0aEFFUyhjaXBoZXJ0ZXh0LCBrZXkpXG4gICAgcmV0dXJuIHBsYWludGV4dCAvLyAucmVwbGFjZSgvXFxuKyQvZywgJycpXG59XG5cblxuUEIuQ3J5cHRvLnJhbmRvbSA9IGZ1bmN0aW9uKCkgeyAvLyBqdXN0IGxpa2UgTWF0aC5yYW5kb20sIGJ1dCBiZXR0ZXJcbiAgICAvLyB2aWEgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzY5NDYyNi9nZW5lcmF0aW5nLXJhbmRvbS1udW1iZXJzLTAtdG8tMS13aXRoLWNyeXB0by1nZW5lcmF0ZXZhbHVlc1xuXG4gICAgdmFyIGxpc3QgPSBQQi5DcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKDIsIDMyKVxuXG4gICAgLy8ga2VlcCBhbGwgMzIgYml0cyBvZiB0aGUgdGhlIGZpcnN0LCB0b3AgMjAgb2YgdGhlIHNlY29uZCBmb3IgNTIgcmFuZG9tIGJpdHNcbiAgICB2YXIgbWFudGlzc2EgPSAobGlzdFswXSAqIE1hdGgucG93KDIsMjApKSArIChsaXN0WzFdID4+IDEyKVxuXG4gICAgLy8gc2hpZnQgYWxsIDUyIGJpdHMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkZWNpbWFsIHBvaW50XG4gICAgdmFyIHJlc3VsdCA9IG1hbnRpc3NhICogTWF0aC5wb3coMiwtNTIpXG4gICAgXG4gICAgcmV0dXJuIHJlc3VsdFxuICAgIFxuICAgIC8vIHZhciBsb2cyID0gTWF0aC5sb2cobWF4KSAvIE1hdGguTE4yXG4gICAgLy8gdmFyIHNpemUgPSBNYXRoLmNlaWwobG9nMikgKyAxIC8vIE5PVEU6IHRoaXMgaXMgYWJvdXQgOCB0aW1lcyBoaWdoZXIgdGhhbiBuZWNlc3Nhcnlcbn1cblxuUEIuQ3J5cHRvLmdldFJhbmRvbUludGVnZXIgPSBmdW5jdGlvbihtYXgsIG1pbikgeyAvLyBOT1RFOiBtaW4gaXMgaW5jbHVzaXZlLCBtYXggaXMgZXhjbHVzaXZlXG4gICAgLy8gVE9ETzogZXJyb3IgaWYgbWF4IGFuZCBtaW4gYXJlIG5vdCBwcm9wZXIgKG5vbi1OYU4pIG51bWJlcnNcbiAgICBtaW4gPSBNYXRoLmZsb29yKG1pbiB8fCAwKVxuICAgIG1heCA9IE1hdGguZmxvb3IobWF4IHx8IDB4N2ZmZmZmZmYpIC8vIDB4N2ZmZmZmZmYgPT0gTWF0aC5wb3coMiwgMzEpIC0gMSAvLyB0aGUgbGFyZ2VzdCBiaXRvcCBzYWZlIGludFxuICAgIHZhciByYW5nZSA9IG1heCAtIG1pblxuICAgIHZhciByYW5kRmxvYXQgPSBQQi5DcnlwdG8ucmFuZG9tKClcbiAgICByZXR1cm4gTWF0aC5mbG9vcihyYW5kRmxvYXQqcmFuZ2UgKyBtaW4pXG59XG5cblBCLkNyeXB0by5nZXRSYW5kb21JdGVtID0gZnVuY3Rpb24obGlzdCkge1xuICAgIC8vIFRPRE86IGVycm9yIGlmIGxpc3QgaXMgbm90IGFuIGFycmF5IG9yIHN0cmluZ1xuICAgIHZhciBpbmRleCA9IFBCLkNyeXB0by5nZXRSYW5kb21JbnRlZ2VyKGxpc3QubGVuZ3RoKVxuICAgIHJldHVybiBsaXN0W2luZGV4XVxufVxuXG4vKipcbiAqIEdldCBhIG5ldyBBRVMga2V5XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGxlbiBMZW5ndGggaW4gYnl0ZXMgKGRlZmF1bHRzIHRvIDI1NiBiaXRzKVxuICogQHJldHVybiB7c3RyaW5nfSBBRVMga2V5XG4gKi9cblBCLkNyeXB0by5nZXRSYW5kb21LZXkgPSBmdW5jdGlvbihsZW4pIHtcbiAgICBsZW4gPSBsZW4gfHwgMjU2LzggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFFUyBrZXkgc2l6ZSBpcyAyNTYgYml0c1xuICAgIHZhciBieXRlcyA9IFBCLkNyeXB0by5nZXRSYW5kb21WYWx1ZXMobGVuLCA4KVxuICAgIC8vIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgLy8gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcylcbiAgICByZXR1cm4gQml0Y29pbi5jb252ZXJ0LmJ5dGVzVG9CYXNlNjQoYnl0ZXMpXG59XG5cblBCLkNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPSBmdW5jdGlvbihudW1iZXIsIHNpemUpIHtcbiAgICBpZih3aW5kb3cuY3J5cHRvICYmIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgIHZhciBieXRlc1xuICAgICAgICBpZihzaXplID09IDMyKVxuICAgICAgICAgICAgYnl0ZXMgPSBuZXcgVWludDMyQXJyYXkoc2l6ZSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgIFxuICAgICAgICByZXR1cm4gd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpXG4gICAgfVxuXG4gICAgcmV0dXJuIFBCLkNyeXB0by5nZXRSYW5kb21WYWx1ZXNTaGltKG51bWJlciwgc2l6ZSlcbn1cblxuUEIuQ3J5cHRvLmdldFJhbmRvbVZhbHVlc1NoaW0gPSBmdW5jdGlvbihudW1iZXIsIHNpemUpIHtcbiAgICAvLyB2aWEgaHR0cHM6Ly9naXRodWIuY29tL2V2YW52b3NiZXJnL2NyeXB0by1qcy9pc3N1ZXMvN1xuICAgIC8vIGZhbGxiYWNrIGZvciBvbGQgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGNyeXB0by5nZXRSYW5kb21WYWx1ZXNcbiAgICAvLyBiZXR0ZXIgdGhhbiBwbGFpbiBNYXRoLnJhbmRvbSgpLCB3b3JzZSB0aGFuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoKVxuICAgIHZhciB3b3JkcyA9IFtdO1xuXG4gICAgdmFyIHIgPSAoZnVuY3Rpb24gKG1fdykge1xuICAgICAgICB2YXIgbV93ID0gbV93O1xuICAgICAgICB2YXIgbV96ID0gMHgzYWRlNjhiMTtcbiAgICAgICAgdmFyIG1hc2sgPSAweGZmZmZmZmZmO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtX3ogPSAoMHg5MDY5ICogKG1feiAmIDB4RkZGRikgKyAobV96ID4+IDB4MTApKSAmIG1hc2s7XG4gICAgICAgICAgICBtX3cgPSAoMHg0NjUwICogKG1fdyAmIDB4RkZGRikgKyAobV93ID4+IDB4MTApKSAmIG1hc2s7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gKChtX3ogPDwgMHgxMCkgKyBtX3cpICYgbWFzaztcbiAgICAgICAgICAgIHJlc3VsdCAvPSAweDEwMDAwMDAwMDtcbiAgICAgICAgICAgIHJlc3VsdCArPSAwLjU7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKE1hdGgucmFuZG9tKCkgPiAuNSA/IDEgOiAtMSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCByY2FjaGU7IGkgPCBudW1iZXI7IGkgKz0gNCkge1xuICAgICAgICB2YXIgX3IgPSByKChyY2FjaGUgfHwgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwMDAwMCk7XG5cbiAgICAgICAgcmNhY2hlID0gX3IoKSAqIDB4M2FkZTY3Yjc7XG5cbiAgICAgICAgaWYoc2l6ZSA9PSAzMikge1xuICAgICAgICAgICAgd29yZHMucHVzaChNYXRoLmFicyggKF9yKCkgKiAweDEwMDAwMDAwMCkgfCAwICkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSB3YW50IGJ5dGVzIGluc3RlYWQgb2YgMzItYml0IGNodW5rc1xuICAgICAgICAgICAgdmFyIGludDMyID0gKF9yKCkgKiAweDEwMDAwMDAwMCkgfCAwO1xuICAgICAgICAgICAgd29yZHMucHVzaChNYXRoLmFicyhpbnQzMiAmIDB4RkYwMDAwMDApID4+IDI0KTtcbiAgICAgICAgICAgIHdvcmRzLnB1c2goTWF0aC5hYnMoaW50MzIgJiAweDAwRkYwMDAwKSA+PiAxNik7XG4gICAgICAgICAgICB3b3Jkcy5wdXNoKE1hdGguYWJzKGludDMyICYgMHgwMDAwRkYwMCkgPj4gOCk7XG4gICAgICAgICAgICB3b3Jkcy5wdXNoKE1hdGguYWJzKGludDMyICYgMHgwMDAwMDBGRikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmRzO1xufVxuXG5cbi8qKlxuICogdG8gY3JlYXRlIGtleSBwYWlyc1xuICogQHBhcmFtICB7c3RyaW5nfSBwdWZma2V5XG4gKiBAcGFyYW0gIHtzdHJpbmd9IG15UHJpdmF0ZVdpZlxuICogQHBhcmFtICB7b2JqZWN0fSB1c2VyUmVjb3Jkc1xuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5QQi5DcnlwdG8uY3JlYXRlS2V5UGFpcnMgPSBmdW5jdGlvbihwdWZma2V5LCBteVByaXZhdGVXaWYsIHVzZXJSZWNvcmRzKSB7XG4gICAgaWYoIUFycmF5LmlzQXJyYXkodXNlclJlY29yZHMpKVxuICAgICAgICByZXR1cm4gUEIudGhyb3dFcnJvcignSW52YWxpZCB1c2VyUmVjb3JkcycpXG4gICAgXG4gICAgcmV0dXJuIHVzZXJSZWNvcmRzLnJlZHVjZShmdW5jdGlvbihhY2MsIHVzZXJSZWNvcmQpIHtcbiAgICAgICAgdmFyIHZlcnNpb25lZFVzZXJuYW1lID0gUEIuVXNlcnMudXNlclJlY29yZFRvVmVyc2lvbmVkVXNlcm5hbWUodXNlclJlY29yZClcbiAgICAgICAgYWNjW3ZlcnNpb25lZFVzZXJuYW1lXSA9IFBCLkNyeXB0by5lbmNyeXB0UHJpdmF0ZU1lc3NhZ2UocHVmZmtleSwgdXNlclJlY29yZC5kZWZhdWx0S2V5LCBteVByaXZhdGVXaWYpXG4gICAgICAgIHJldHVybiBhY2NcbiAgICB9LCB7fSlcbn1cblxuXG4vLyBQQi5DcnlwdG8udmVyaWZ5QmxvY2sgPSBmdW5jdGlvbihibG9jaywgcHVibGljS2V5QmFzZTU4KSB7XG4vLyAgICAgcmV0dXJuIFBCLkNyeXB0by52ZXJpZnlNZXNzYWdlKGJsb2NrLmJsb2NrUGF5bG9hZCwgYmxvY2suYmxvY2tTaWcucmVwbGFjZSgvXFwqL2csIFwiXCIpLCBwdWJsaWNLZXlCYXNlNTgpO1xuLy8gfVxuXG4vLyBQQi5DcnlwdG8uc2lnbkJsb2NrID0gZnVuY3Rpb24oYmxvY2tQYXlsb2FkLCBwcml2YXRlS2V5V0lGKSB7XG4vLyAgICAgcmV0dXJuIFBCLkNyeXB0by5zaWduUGF5bG9hZChibG9ja1BheWxvYWQsIHByaXZhdGVLZXlXSUYpO1xuLy8gfVxuIiwiLypcblxuICAgIFBlcnNpc3RlbmNlIGxheWVyIGZvciB0aGUgRXZlcnlCaXQgcGxhdGZvcm0uXG5cbiAgICBJdCdzIGxpa2UgYSBuZXR3b3JrIG9uIHlvdXIgaGFyZCBkcml2ZS4uLiB3aGljaCBtZWFucyB0aGlzIGNvdWxkIGJlIHBhcnQgb2YgUEIuTmV0LlxuXG4gICAgQ29weXJpZ2h0IDIwMTQgRXZlcnlCaXQuIFNlZSBSRUFETUUgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbiAqL1xuXG5QQi5QZXJzaXN0ID0ge307XG5QQi5QZXJzaXN0LnRvZG8gPSB7fVxuUEIuUGVyc2lzdC50b2RvZmxhZyA9IGZhbHNlXG5cbi8qKlxuICogdG8gc2F2ZSBrZXkvdmFsdWVcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlXG4gKi9cblBCLlBlcnNpc3Quc2F2ZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBpZih2YWx1ZSA9PSBudWxsKVxuICAgICAgICB2YWx1ZSA9IGZhbHNlXG4gICAgUEIuUGVyc2lzdC50b2RvW2tleV0gPSB2YWx1ZVxuICAgIGlmKCFQQi5QZXJzaXN0LnRvZG9mbGFnKSB7XG4gICAgICAgIG9uY2VJbkF3aGlsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIFBCLlBlcnNpc3QudG9kbykge1xuICAgICAgICAgICAgICAgIHZhciByZWFsa2V5ID0gJ1BVRkY6OicgKyBrZXk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlcGVuZCBQVUZGOjogc28gd2UncmUgZ29vZCBuZWlnaGJvcnNcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBQQi5QZXJzaXN0LnRvZG9ba2V5XTtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGNhc2Ugd2UncmUgcGFzc2VkIGEgdGh1bmtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgICAgICAgICAgICAgIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHJlYWxrZXksIHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQQi5QZXJzaXN0LnRvZG8gPSB7fTtcbiAgICAgICAgICAgIFBCLlBlcnNpc3QudG9kb2ZsYWcgPSBmYWxzZTtcbiAgICAgICAgfSwgMTAwKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgYXQgbW9zdCBldmVyeSAxMDBtc1xuICAgIH1cbiAgICBQQi5QZXJzaXN0LnRvZG9mbGFnID0gdHJ1ZVxufVxuXG4vKipcbiAqIGdldCB0aGUgcGFyc2VkIEpTT04gaW5mbyBmcm9tIHRoZSBnaXZlbiBrZXlcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHthbnl0aGluZ31cbiAqL1xuUEIuUGVyc2lzdC5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAvLyBUT0RPOiByZXR1cm4gZW1wdHkgc3RyaW5nIGluc3RlYWQgb2YgZmFsc2VcblxuICAgIHZhciByZWFsa2V5ID0gJ1BVRkY6OicgKyBrZXk7XG4gICAgdmFyIHN0ciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHJlYWxrZXkpO1xuICAgIGlmKCFzdHIpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gUEIucGFyc2VKU09OKHN0cik7XG59XG5cbi8qKlxuICogdG8gcmVtb3ZlIHRoZSBpdGVtIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4ga2V5XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICovXG5QQi5QZXJzaXN0LnJlbW92ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciByZWFsa2V5ID0gJ1BVRkY6OicgKyBrZXk7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0ocmVhbGtleSk7XG59XG4iLCIvKlxuICAgIENvbXByZWhlbnNpdmUgKGluIHByb2dyZXNzISksIGNhbm9uaWNhbCBzZXQgb2YgZnVuY3Rpb25zIGRlZmluaW5nIGFuZCB2YWxpZGF0aW5nIGEgcHVmZi5cblxuICAgIEFsbCBvZiB0aGVzZSBhcmUgU1RSSUNUTFkgRk9STUFMIHZhbGlkYXRpb25zOiB0aGV5IGRvbid0IGRlcGVuZCBvbiB0aGUgc3RhdGUgb2YgdGhlIHVuaXZlcnNlLlxuXG4gICAgQ29weXJpZ2h0IDIwMTQgRXZlcnlCaXQuIFNlZSBSRUFETUUgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbiAqL1xuXG5cblBCLlNwZWMgPSB7fVxuXG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIHVzZXJuYW1lXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVzZXJuYW1lXG4gKi9cblBCLlNwZWMuaXNWYWxpZFVzZXJuYW1lID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAvKlxuICAgIFJVTEVTOlxuICAgIC0gTWluaW11bSBsZW5ndGggaXMgMVxuICAgIC0gTWF4aW11bSBsZW5ndGggb2YgZnVsbCB1c2VybmFtZSAoaW5jbHVkaW5nIHN1YnVzZXJzIGFuZCAuKSBpcyAyNTUgY2hhcmFjdGVyc1xuICAgIC0gT25seSBhbHBoYW51bWVyaWNcbiAgICAtIE9ubHkgbG93ZXJjYXNlXG4gICAgLSBDYW5ub3QgYmVnaW4gb3IgZW5kIHdpdGggYSAuXG4gICAgICovXG5cbiAgICBQQi5TcGVjLmlzVmFsaWRVc2VybmFtZS5ydWxlc1N0YXRlbWVudCA9ICdVc2VybmFtZXMgY2FuIG9ubHkgY29udGFpbiBsb3dlcmNhc2UgbGV0dGVycywgbnVtYmVycywgYW5kIHBlcmlvZHMuIFRoZXkgY2Fubm90ICcgK1xuICAgICAgICAnYmUgbG9uZ2VyIHRoYW4gMjU1IGNoYXJhY3RlcnMsIG9yIGJlZ2luIG9yIGVuZCB3aXRoIGEgcGVyaW9kLidcblxuICAgIGlmKCF1c2VybmFtZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICBpZih1c2VybmFtZS5sZW5ndGggPiAyNTUpXG4gICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgaWYoIXVzZXJuYW1lLm1hdGNoKC9eW2EtejAtOS5dKyQvKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICBpZih1c2VybmFtZS5zbGljZSgwLCAxKSA9PSAnLicpXG4gICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgaWYodXNlcm5hbWUuc2xpY2UoLTEpID09ICcuJylcbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICByZXR1cm4gdHJ1ZVxufVxuXG5cbi8qKlxuICogRG9lcyBldmVyeXRoaW5nIHBvc3NpYmxlIHRvIG1ha2UgYSB1c2VybmFtZSB2YWxpZFxuICogTm90ZTogVGhpcyBtYXkgaGF2ZSB1bmludGVuZGVkIGNvbnNlcXVlbmNlcyBmb3IgdGhlIHVzZXJcbiAqL1xuUEIuU3BlYy5zYW5pdGl6ZVVzZXJuYW1lID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAvKlxuICAgICBUUkFOU0ZPUk1BVElPTlM6XG4gICAgIC0gUmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlXG4gICAgIC0gQ29udmVydCB0byBsb3dlcmNhc2VcbiAgICAgLSBSZW1vdmUgYWxsIGlsbGVnYWwgY2hhcmFjdGVycywgaW5jbHVkaW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nIC5cbiAgICAgKi9cbiAgICB1c2VybmFtZSA9IHVzZXJuYW1lLnRyaW0oKVxuXG4gICAgdXNlcm5hbWUgPSB1c2VybmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICBpZih1c2VybmFtZS5zbGljZSgwLCAxKSA9PSAnLicpXG4gICAgICAgIHVzZXJuYW1lID0gdXNlcm5hbWUuc2xpY2UoMSlcblxuICAgIGlmKHVzZXJuYW1lLnNsaWNlKC0xKSA9PSAnLicpXG4gICAgICAgIHVzZXJuYW1lID0gdXNlcm5hbWUuc2xpY2UoMCwtMSlcblxuICAgIHVzZXJuYW1lID0gdXNlcm5hbWUucmVwbGFjZSgvW15hLXowLTkuXSsvZywgJycpXG5cbiAgICByZXR1cm4gdXNlcm5hbWVcbn1cblxuXG4vKipcbiAqIGNoZWNrIGlmIGl0IGlzIGEgdmFsaWQgcHVibGljIGtleVxuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0tleVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblBCLlNwZWMuaXNWYWxpZFB1YmxpY0tleSA9IGZ1bmN0aW9uKHB1YmxpY0tleSkge1xuICAgIC8vIFRPRE86IGRvIFwiY2hlY2tzdW1cIiB2YWxpZGF0aW9uXG5cbiAgICBpZighaXNzZXQocHVibGljS2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG59XG5cbi8qKlxuICogY2hlY2sgaWYgaXQgaXMgYSB2YWxpZCBwcml2YXRlIGtleVxuICogQHBhcmFtIHtzdHJpbmd9IHByaXZhdGVLZXlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5QQi5TcGVjLmlzVmFsaWRQcml2YXRlS2V5ID0gZnVuY3Rpb24ocHJpdmF0ZUtleSkge1xuICAgIC8vIFRPRE86IFZhbGlkYXRlIGJ5IHRlc3RpbmcgaWYgY2FuIGJlIGNvbnZlcnRlZCB0byBwdWJsaWMga2V5XG5cbiAgICBpZighaXNzZXQocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGlzIGEgdmFsaWQgY2FwYVxuICogQHBhcmFtIGNhcGFcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5QQi5TcGVjLmlzVmFsaWRDYXBhID0gZnVuY3Rpb24oY2FwYSkge1xuXG4gICAgLypcbiAgICAgUlVMRVM6XG4gICAgIC0gTXVzdCBiZSBhIG5hdHVyYWwgbnVtYmVyICgxIG9yIGdyZWF0ZXIpXG4gICAgICovXG5cbiAgICBQQi5TcGVjLmlzVmFsaWRDYXBhLnJ1bGVzU3RhdGVtZW50ID0gJ2NhcGEgbXVzdCBiZSBhIG5hdHVyYWwgbnVtYmVyLic7XG5cblxuICAgIGNhcGEgPSBjYXBhLnRvU3RyaW5nKCk7IC8vIENvbnZlcnQgdG8gc3RyaW5nXG4gICAgdmFyIG4xID0gTWF0aC5hYnMobik7XG4gICAgdmFyIG4yID0gcGFyc2VJbnQobiwgMTApO1xuXG4gICAgaWYobjIgPCAxKVxuICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgIHJldHVybiAhaXNOYU4objEpICYmIG4yID09PSBuMSAmJiBuMS50b1N0cmluZygpID09PSBuO1xufSIsIi8qIFxuICAgICAgICAgICAgICAgICAgIF9fX19fICBfX19fXyAgX19fX18gICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBfX19fX18gIF9fIF9fXy8gX19fX1xcLyBfX19fXFwvIF9fX19cXF9fX19fX19fX19fIF9fIF9fICBfX19fXyAgXG4gICAgXFxfX19fIFxcfCAgfCAgXFwgICBfX1xcXFwgICBfX1xcXFwgICBfX1xcLyAgXyBcXF8gIF9fIFxcICB8ICBcXC8gICAgIFxcIFxuICAgIHwgIHxfPiA+ICB8ICAvfCAgfCAgIHwgIHwgICB8ICB8ICggIDxfPiApICB8IFxcLyAgfCAgLyAgWSBZICBcXFxuICAgIHwgICBfXy98X19fXy8gfF9ffCAgIHxfX3wgICB8X198ICBcXF9fX18vfF9ffCAgfF9fX18vfF9ffF98ICAvXG4gICAgfF9ffCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcLyBcbiAgXG4gIFxuICBBIFB1ZmZiYWxsIG1vZHVsZSBmb3IgbWFuYWdpbmcgZm9ydW0tc3R5bGUgcHVmZnMuIFdyYXBzIHRoZSBjb3JlIFB1ZmZiYWxsIEFQSSBpbiBhIGZsdWZmeSBsYXllciBvZiBzeW50YWN0aWMgc3B1biBzdWdhci5cblxuICBVc2FnZSBleGFtcGxlOlxuICBQQi5NLkZvcnVtLmluaXQoKVxuICAuLi5cblxuKi9cblxuUEIuTS5Gb3J1bSA9IHt9O1xuXG5QQi5NLkZvcnVtLmNvbnRlbnRUeXBlcyA9IHt9XG5cblxuLyoqXG4gKiBCb290c3RyYXAgdGhlIGZvcnVtIG1vZHVsZVxuICovXG5QQi5NLkZvcnVtLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICBQQi5hZGRSZWxhdGlvbnNoaXBIYW5kbGVyKFBCLk0uRm9ydW0uYWRkRmFtaWxpYWxFZGdlcykgICAgICAgICAgICAgIC8vIG1hbmFnZXMgcGFyZW50LWNoaWxkIHJlbGF0aW9uc2hpcHNcbiAgICBQQi5hZGRCZWZvcmVTd2l0Y2hJZGVudGl0eUhhbmRsZXIoUEIuTS5Gb3J1bS5jbGVhclB1ZmZDb250ZW50U3Rhc2gpICAgIC8vIGNsZWFyIHByaXZhdGUgY2FjaGVzIFxuICAgIFBCLmFkZFBheWxvYWRNb2RpZmllckhhbmRsZXIoUEIuTS5Gb3J1bS5hZGRUaW1lc3RhbXApICAgICAgICAgICAgICAgLy8gYWRkIHRpbWVzdGFtcCB0byBhbGwgbmV3IHB1ZmZzXG59XG5cblxuLyoqXG4gKiBJbmplY3QgYSB0aW1lc3RhbXAgaW50byB0aGUgcGF5bG9hZFxuICogdGhlIFwidGltZVwiIGZpZWxkIGlzIG9wdGlvbmFsIGZvciBwdWZmcywgYnV0IG1hbmRhdG9yeSBmb3IgXCJmb3J1bSBzdHlsZVwiIHB1ZmZzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAqIEByZXR1cm5zIHtPYmplY3R8e319XG4gKi9cblBCLk0uRm9ydW0uYWRkVGltZXN0YW1wID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuICAgIHBheWxvYWQgPSBwYXlsb2FkIHx8IHt9XG4gICAgcGF5bG9hZC50aW1lID0gRGF0ZS5ub3coKVxuICAgIHJldHVybiBwYXlsb2FkXG59XG5cblxuLyoqXG4gKiBGaWx0ZXIgcHVmZnMgYnkgcHJvcCBmaWx0ZXJzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbHRlcnNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblBCLk0uRm9ydW0uZmlsdGVyQnlGaWx0ZXJzID0gZnVuY3Rpb24oZmlsdGVycykge1xuXG4gICAgaWYoIWZpbHRlcnMpIHJldHVybiBmdW5jdGlvbigpIHtyZXR1cm4gdHJ1ZX1cbiAgICBcbiAgICAvLy8vIGdldCBhIGZpbHRlcmluZyBmdW5jdGlvblxuICAgIHJldHVybiBmdW5jdGlvbihzaGVsbCkge1xuXG4gICAgICAgIC8vIFJPVVRFU1xuICAgICAgICBpZiAoZmlsdGVycy5yb3V0ZXMgJiYgZmlsdGVycy5yb3V0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHJvdXRlTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVycy5yb3V0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hlbGwucm91dGVzLmluZGV4T2YoZmlsdGVycy5yb3V0ZXNbaV0pID4gLTEpIHJvdXRlTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyb3V0ZU1hdGNoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUQUdTXG4gICAgICAgIGlmIChmaWx0ZXJzLnRhZ3MgJiYgZmlsdGVycy50YWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICghc2hlbGwucGF5bG9hZC50YWdzIHx8ICFzaGVsbC5wYXlsb2FkLnRhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRhZ01hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlcnMudGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzaGVsbC5wYXlsb2FkLnRhZ3MuaW5kZXhPZihmaWx0ZXJzLnRhZ3NbaV0pID4gLTEpIHRhZ01hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFnTWF0Y2gpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRZUEVTXG4gICAgICAgIGlmIChmaWx0ZXJzLnR5cGVzICYmIGZpbHRlcnMudHlwZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKCF+ZmlsdGVycy50eXBlcy5pbmRleE9mKHNoZWxsLnBheWxvYWQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhzaGVsbC50eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVVNFUlNcbiAgICAgICAgaWYoZmlsdGVycy51c2VycyAmJiBmaWx0ZXJzLnVzZXJzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBpZighfmZpbHRlcnMudXNlcnMuaW5kZXhPZihQQi5Vc2Vycy5qdXN0VXNlcm5hbWUoc2hlbGwudXNlcm5hbWUpKSkgcmV0dXJuIGZhbHNlXG5cblxuICAgICAgICBpZihmaWx0ZXJzLnJvb3RzKVxuICAgICAgICAgICAgaWYoKHNoZWxsLnBheWxvYWQucGFyZW50c3x8W10pLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgaWYoZmlsdGVycy5hbmNlc3RvcnMgJiYgZmlsdGVycy5mb2N1cykge1xuICAgICAgICAgICAgdmFyIGZvY3VzID0gUEIuZ2V0UHVmZkJ5U2lnKGZpbHRlcnMuZm9jdXMpIC8vIFRPRE86IGZpbmQgYmV0dGVyIHdheSB0byBkbyB0aGlzXG4gICAgICAgICAgICBpZihmb2N1cy5wYXlsb2FkICYmICF+Zm9jdXMucGF5bG9hZC5wYXJlbnRzLmluZGV4T2Yoc2hlbGwuc2lnKSkgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZihmaWx0ZXJzLmRlc2NlbmRhbnRzICYmIGZpbHRlcnMuZm9jdXMpXG4gICAgICAgICAgICBpZighfnNoZWxsLnBheWxvYWQucGFyZW50cy5pbmRleE9mKGZpbHRlcnMuZm9jdXMpKSByZXR1cm4gZmFsc2VcblxuICAgICAgICAvLyBUT0RPOiBkZXByZWNhdGUgdGhpcywgYXMgaXQncyBoYW5kbGVkIGFib3ZlOlxuICAgICAgICBpZiAoZmlsdGVycy50eXBlICYmIGZpbHRlcnMudHlwZS5sZW5ndGgpXG4gICAgICAgICAgICBpZiAoIX5maWx0ZXJzLnR5cGUuaW5kZXhPZihzaGVsbC5wYXlsb2FkLnR5cGUpKSByZXR1cm4gZmFsc2VcblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbn1cblxuXG5cbi8qKlxuICogSGVscGVyIGZvciBzb3J0aW5nIGJ5IHBheWxvYWQudGltZVxuICogQHBhcmFtICB7T2JqZWN0fSBhXG4gKiBAcGFyYW0gIHtvYmplY3R9IGJcbiAqIEByZXR1cm4ge251bWJlcn0gYmFzZWQgb24gZGVzaXJlZCBzb3J0aW5nIG9yZGVyXG4gKi9cblBCLk0uRm9ydW0uc29ydEJ5UGF5bG9hZCA9IGZ1bmN0aW9uKGEsYikge1xuICAgIC8vLy8gaGVscGVyIGZvciBzb3J0aW5nIGJ5IHBheWxvYWQudGltZVxuICAgIGlmKHB1ZmZ3b3JsZHByb3BzLnZpZXcucXVlcnkuc29ydCA9PSAnREVTQycpXG4gICAgICAgIHJldHVybiBiLnBheWxvYWQudGltZSAtIGEucGF5bG9hZC50aW1lO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGEucGF5bG9hZC50aW1lIC0gYi5wYXlsb2FkLnRpbWU7XG59XG5cblxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBwdWZmJ3MgcGFyZW50c1xuICogQHBhcmFtICB7T2JqZWN0fSBwdWZmXG4gKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgcGFyZW50c1xuICovXG5QQi5NLkZvcnVtLmdldFBhcmVudENvdW50ID0gZnVuY3Rpb24ocHVmZiwgcHJvcHMpIHtcbiAgICBpZighcHVmZikgcmV0dXJuIDBcbiAgICBcbiAgICB2YXIgc2lnID0gcHVmZi5zaWcgfHwgcHVmZlxuICAgIFxuICAgIHJldHVybiBQQi5EYXRhLmdyYXBoLnYoc2lnKS5vdXQoJ3BhcmVudCcpLnJ1bigpLmxlbmd0aFxufVxuXG5cbi8qKlxuICogR2V0IGEgY291bnQgb2YgdGhlIGN1cnJlbnQgcHVmZidzIGNoaWxkcmVuXG4gKiBAcGFyYW0gIHtPYmplY3R9IHB1ZmZcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlblxuICovXG5QQi5NLkZvcnVtLmdldENoaWxkQ291bnQgPSBmdW5jdGlvbihwdWZmKSB7XG4gICAgaWYoIXB1ZmYpIHJldHVybiAwXG4gICAgXG4gICAgdmFyIHNpZyA9IHB1ZmYuc2lnIHx8IHB1ZmZcbiAgICBcbiAgICByZXR1cm4gUEIuRGF0YS5ncmFwaC52KHNpZykub3V0KCdjaGlsZCcpLnJ1bigpLmxlbmd0aFxufVxuXG5cbi8qKlxuICogRmlsdGVyIHB1ZmZzIGFjY29yZGluZyB0byBjcml0ZXJpYVxuICogQHBhcmFtICB7c3RyaW5nfSBxdWVyeVxuICogQHBhcmFtICB7c3RyaW5nfSBmaWx0ZXJzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGxpbWl0XG4gKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgcHVmZnNcbiAqL1xuUEIuTS5Gb3J1bS5nZXRQdWZmTGlzdCA9IGZ1bmN0aW9uKHF1ZXJ5LCBmaWx0ZXJzLCBsaW1pdCkge1xuICAgIC8vLy8gcmV0dXJucyBhIGxpc3Qgb2YgcHVmZnNcblxuICAgIC8vIFRISU5LOiB0aGUgZ3JhcGggY2FuIGhlbHAgdXMgaGVyZSwgYnV0IG9ubHkgaWYgd2UncmUgbW9yZSBjbGV2ZXIgYWJvdXQgZm9ybWluZyByZWxhdGlvbnNoaXBzIGFuZCB1c2luZyB0aG9zZSBpbiBvdXIgZmlsdGVycy5cblxuICAgIGxpbWl0ID0gbGltaXQgfHwgSW5maW5pdHlcbiAgICB2YXIgb2Zmc2V0ID0gK3F1ZXJ5Lm9mZnNldHx8MFxuXG4gICAgLy8gdmFyIHNoZWxscyA9IFBCLk0uRm9ydW0uZ2V0U2hlbGxzKHF1ZXJ5LCBmaWx0ZXJzKVxuICAgIHZhciBzaGVsbHMgPSBQQi5EYXRhLmdldEFsbE15U2hlbGxzKClcbiAgICBcbiAgICB2YXIgZmlsdGVyZWRfc2hlbGxzID0gc2hlbGxzLmZpbHRlcihQQi5NLkZvcnVtLmZpbHRlckJ5RmlsdGVycyhCb3Jvbi5leHRlbmQoe30sIHF1ZXJ5LCBmaWx0ZXJzKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KFBCLk0uRm9ydW0uc29ydEJ5UGF5bG9hZCkgLy8gVE9ETzogc29ydCBieSBxdWVyeVxuXG4gICAgdmFyIHNsaWNlZF9zaGVsbHMgPSBmaWx0ZXJlZF9zaGVsbHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQrbGltaXQpXG4gICAgXG4gICAgdmFyIHB1ZmZzID0gc2xpY2VkX3NoZWxscy5tYXAoUEIuRGF0YS5nZXRQdWZmRnJvbVNoZWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG5cbiAgICB2YXIgaGF2ZSA9IHNsaWNlZF9zaGVsbHMubGVuZ3RoXG4gICAgLy8gdmFyIGhhdmUgPSBwdWZmcy5sZW5ndGhcbiAgICBpZihoYXZlID49IGxpbWl0KVxuICAgICAgICByZXR1cm4gcHVmZnMgIC8vIGFzIGxvbmcgYXMgd2UgaGF2ZSBlbm91Z2ggZmlsdGVyZWQgc2hlbGxzIHRoZSBwdWZmcyB3aWxsIGV2ZW50dWFsbHkgZmlsbCBpbiBlbXB0eSBzcG90c1xuXG4gICAgUEIuRGF0YS5maWxsU29tZVNsb3RzUGxlYXNlKGxpbWl0LCBoYXZlLCBxdWVyeSwgZmlsdGVycylcbiAgICBcbiAgICByZXR1cm4gcHVmZnM7XG59XG5cblxuLyoqXG4gKiBUYWtlcyBhIHN0cmluZyBvZiBjb250ZW50LCBjcmVhdGUgYSBwdWZmIGFuZCBwdXNoIGl0IGludG8gdGhlIHN5c3RlbVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcGFyYW0ge2FycmF5fSBwYXJlbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gbWV0YWRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nW119IHVzZXJSZWNvcmRzRm9yV2hvbVRvRW5jcnlwdFxuICogQHBhcmFtIHtzdHJpbmdbXX0gcHJpdmF0ZUVudmVsb3BlQWxpYXNcbiAqIEByZXR1cm5zIHtwcm9taXNlfVxuICovXG5QQi5NLkZvcnVtLmFkZFBvc3QgPSBmdW5jdGlvbih0eXBlLCBjb250ZW50LCBwYXJlbnRzLCBtZXRhZGF0YSwgdXNlclJlY29yZHNGb3JXaG9tVG9FbmNyeXB0LCBwcml2YXRlRW52ZWxvcGVBbGlhcykge1xuICAgIC8vLy8gR2l2ZW4gYSBzdHJpbmcgb2YgY29udGVudCwgY3JlYXRlIGEgcHVmZiBhbmQgcHVzaCBpdCBpbnRvIHRoZSBzeXN0ZW1cbiAgICBcbiAgICAvLyBlbnN1cmUgcGFyZW50cyBpcyBhbiBhcnJheVxuICAgIGlmKCFwYXJlbnRzKSBwYXJlbnRzID0gW11cbiAgICBpZighQXJyYXkuaXNBcnJheShwYXJlbnRzKSkgcGFyZW50cyA9IFtwYXJlbnRzXVxuICAgIFxuICAgIC8vIGVuc3VyZSBwYXJlbnRzIGNvbnRhaW5zIG9ubHkgcHVmZiBpZHNcbiAgICBpZihwYXJlbnRzLm1hcChQQi5nZXRQdWZmQnlTaWcpLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiB4ICE9IG51bGwgfSkubGVuZ3RoICE9IHBhcmVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gUEIuZW1wdHlQcm9taXNlKCdUaG9zZSBhcmUgbm90IGdvb2QgcGFyZW50cycpXG4gICAgXG4gICAgLy8gZW5zdXJlIHBhcmVudHMgYXJlIHVuaXF1ZVxuICAgIHBhcmVudHMgPSBQQi51bmlxdWlmeShwYXJlbnRzKVxuXG4gICAgLy8gZmluZCB0aGUgcm91dGVzIHVzaW5nIHBhcmVudHNcbiAgICB2YXIgcm91dGVzID0gcGFyZW50cy5tYXAoZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIFBCLmdldFB1ZmZCeVNpZyhpZCkudXNlcm5hbWVcbiAgICB9KTtcbiAgICBpZiAobWV0YWRhdGEucm91dGVzKSB7XG4gICAgICAgIHJvdXRlcyA9IG1ldGFkYXRhLnJvdXRlcyAvLyBUSElOSzogdGhpcyBzaG91bGQgcHJvYmFibHkgbWVyZ2Ugd2l0aCBhYm92ZSBpbnN0ZWFkIG9mIHJlcGxhY2luZyBpdC4uLlxuICAgICAgICBkZWxldGUgbWV0YWRhdGFbJ3JvdXRlcyddXG4gICAgfVxuICAgIFxuICAgIC8vIGVuc3VyZSBhbGwgcm91dGVzIGFyZSB1bmlxdWVcbiAgICByb3V0ZXMgPSBQQi51bmlxdWlmeShyb3V0ZXMpXG4gICAgXG4gICAgdmFyIHRha2VVc2VyTWFrZVB1ZmYgPSBQQi5NLkZvcnVtLnBhcnRpYWxseUFwcGx5UHVmZk1ha2VyKHR5cGUsIGNvbnRlbnQsIHBhcmVudHMsIG1ldGFkYXRhLCByb3V0ZXMsIHVzZXJSZWNvcmRzRm9yV2hvbVRvRW5jcnlwdCwgcHJpdmF0ZUVudmVsb3BlQWxpYXMpXG4gICAgXG4gICAgLy8gZ2V0IGEgdXNlciBwcm9taXNlXG4gICAgdmFyIHVzZXJwcm9tID0gUEIuVXNlcnMuZ2V0VXBUb0RhdGVVc2VyQXRBbnlDb3N0KClcbiAgICBcbiAgICB2YXIgcHJvbSA9IHVzZXJwcm9tLmNhdGNoKFBCLmNhdGNoRXJyb3IoJ0ZhaWxlZCB0byBhZGQgcG9zdDogY291bGQgbm90IGFjY2VzcyBvciBjcmVhdGUgYSB2YWxpZCB1c2VyJykpXG4gICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHRha2VVc2VyTWFrZVB1ZmYpXG4gICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChQQi5jYXRjaEVycm9yKCdQb3N0aW5nIGZhaWxlZCcpKVxuICAgIFxuICAgIHJldHVybiBwcm9tXG4gICAgXG4gICAgLy8gTk9URTogYW55IHB1ZmYgdGhhdCBoYXMgJ3RpbWUnIGFuZCAncGFyZW50cycgZmllbGRzIGZ1bGZpbGxzIHRoZSBmb3J1bSBpbnRlcmZhY2VcbiAgICAvLyBUT0RPOiBtYWtlIGFuIG9mZmljaWFsIGludGVyZmFjZSBmdWxmaWxsbWVudCB0aGluZ1xufVxuXG5cbi8qKlxuICogTWFrZSBhIHB1ZmYuLi4gZXhjZXB0IHRoZSBwYXJ0cyB0aGF0IHJlcXVpcmUgYSB1c2VyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7YXJyYXl9IHBhcmVudHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhZGF0YVxuICogQHBhcmFtIHthcnJheX0gcm91dGVzXG4gKiBAcGFyYW0ge2FycmF5fSB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHRcbiAqIEBwYXJhbSB7YXJyYXl9IHByaXZhdGVFbnZlbG9wZUFsaWFzXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cblBCLk0uRm9ydW0ucGFydGlhbGx5QXBwbHlQdWZmTWFrZXIgPSBmdW5jdGlvbih0eXBlLCBjb250ZW50LCBwYXJlbnRzLCBtZXRhZGF0YSwgcm91dGVzLCB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHQsIHByaXZhdGVFbnZlbG9wZUFsaWFzKSB7XG4gICAgLy8vLyBNYWtlIGEgcHVmZi4uLiBleGNlcHQgdGhlIHBhcnRzIHRoYXQgcmVxdWlyZSBhIHVzZXJcbiAgICBcbiAgICAvLyBUSElOSzogaWYgeW91IHVzZSB0aGUgc2FtZSBtZXRhZGF0YSBvYmplY3QgZm9yIG11bHRpcGxlIHB1ZmZzIHlvdXIgY2FjaGVkIHZlcnNpb24gb2YgdGhlIG9sZGVyIHB1ZmZzIHdpbGwgZ2V0IG1lc3NlZCB1cFxuICAgIFxuICAgIHZhciBwYXlsb2FkID0gbWV0YWRhdGEgfHwge30gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWV0YWRhdGEgYmVjb21lcyB0aGUgYmFzaXMgb2YgcGF5bG9hZFxuICAgIHBheWxvYWQucGFyZW50cyA9IHBheWxvYWQucGFyZW50cyB8fCBwYXJlbnRzICAgICAgICAgICAgLy8gaWRzIG9mIHRoZSBwYXJlbnQgcHVmZnNcbiAgICBwYXlsb2FkLnRpbWUgPSBtZXRhZGF0YS50aW1lIHx8IERhdGUubm93KCkgICAgICAgICAgICAgIC8vIHRpbWUgaXMgYWx3YXlzIGEgdW5peCB0aW1lc3RhbXBcbiAgICBwYXlsb2FkLnRhZ3MgPSBtZXRhZGF0YS50YWdzIHx8IFtdICAgICAgICAgICAgICAgICAgICAgIC8vIGFuIGFycmF5IG9mIHRhZ3MgLy8gVE9ETzogbWFrZSB0aGVzZSB3b3JrXG5cbiAgICB2YXIgdHlwZSAgPSB0eXBlIHx8ICd0ZXh0J1xuICAgIHZhciByb3V0ZXMgPSByb3V0ZXMgPyByb3V0ZXMgOiBbXTtcbiAgICByb3V0ZXMgPSByb3V0ZXMuY29uY2F0KFBCLkNPTkZJRy56b25lKTtcbiAgICBcbiAgICByZXR1cm4gZnVuY3Rpb24odXNlclJlY29yZCkge1xuICAgICAgICAvLyB1c2VyUmVjb3JkIGlzIGFsd2F5cyBhbiB1cC10by1kYXRlIHJlY29yZCBmcm9tIHRoZSBESFQsIHNvIHdlIGNhbiB1c2UgaXRzICdsYXRlc3QnIHZhbHVlIGhlcmUgXG5cbiAgICAgICAgdmFyIHByZXZpb3VzID0gdXNlclJlY29yZC5sYXRlc3RcbiAgICAgICAgdmFyIHB1ZmYgPSBQQi5zaW1wbGVCdWlsZFB1ZmYodHlwZSwgY29udGVudCwgcGF5bG9hZCwgcm91dGVzLCB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHQsIHByaXZhdGVFbnZlbG9wZUFsaWFzKVxuXG4gICAgICAgIHJldHVybiBQQi5hZGRQdWZmVG9TeXN0ZW0ocHVmZikgLy8gVEhJTks6IHRoaXMgZmFpbHMgc2lsZW50bHkgaWYgdGhlIHNpZyBleGlzdHMgYWxyZWFkeVxuICAgIH1cbn1cblxuLy8vIGdyYXBoIHJlbGF0aW9uc2hpcHMgLy8vXG5cblBCLk0uRm9ydW0uYWRkRmFtaWxpYWxFZGdlcyA9IGZ1bmN0aW9uKHNoZWxscykge1xuICAgIHNoZWxscy5mb3JFYWNoKFBCLk0uRm9ydW0uYWRkRmFtaWxpYWxFZGdlc0ZvclNoZWxsKVxufVxuXG5QQi5NLkZvcnVtLmFkZEZhbWlsaWFsRWRnZXNGb3JTaGVsbCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgdmFyIGFkZFBhcmVudEVkZ2VzID0gUEIuTS5Gb3J1bS5hZGRGYW1pbGlhbEVkZ2VzRm9yUGFyZW50KGNoaWxkKTtcbiAgICAoY2hpbGQucGF5bG9hZC5wYXJlbnRzfHxbXSkuZm9yRWFjaChhZGRQYXJlbnRFZGdlcyk7XG59XG5cblBCLk0uRm9ydW0uYWRkRmFtaWxpYWxFZGdlc0ZvclBhcmVudCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgdmFyIGV4aXN0aW5nUGFyZW50cyA9IFBCLkRhdGEuZ3JhcGgudihjaGlsZC5zaWcpLm91dCgncGFyZW50JykucHJvcGVydHkoJ3NoZWxsJykucnVuKCkubWFwKFBCLnByb3AoJ3NpZycpKVxuICAgIFxuICAgIHJldHVybiBmdW5jdGlvbihwYXJlbnRTaWcpIHtcbiAgICAgICAgaWYofmV4aXN0aW5nUGFyZW50cy5pbmRleE9mKHBhcmVudFNpZykpIHJldHVybiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uZT9cbiAgICAgICAgUEIuRGF0YS5hZGRTaWdBc1ZlcnRleChwYXJlbnRTaWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWRlbXBvdGVudFxuICAgICAgICBQQi5EYXRhLmdyYXBoLmFkZEVkZ2Uoe19sYWJlbDogJ3BhcmVudCcsIF9pbjogcGFyZW50U2lnLCBfb3V0OiBjaGlsZC5zaWd9KSAvLyBub3QgaWRlbXBvdGVudFxuICAgICAgICBQQi5EYXRhLmdyYXBoLmFkZEVkZ2Uoe19sYWJlbDogJ2NoaWxkJywgX291dDogcGFyZW50U2lnLCAgX2luOiBjaGlsZC5zaWd9KVxuICAgIH1cbn1cblxuLy8vIGVuZCBncmFwaCByZWxhdGlvbnNoaXBzIC8vL1xuXG5cbi8qKlxuICogdG8gcHJvY2VzcyB0aGUgY29udGVudFxuICogQHBhcmFtICB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSAge3B1ZmZ9IHB1ZmZcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuUEIuTS5Gb3J1bS5wcm9jZXNzQ29udGVudCA9IGZ1bmN0aW9uKHR5cGUsIGNvbnRlbnQsIHB1ZmYpIHtcbiAgICB2YXIgdHlwZU9iaiA9IFBCLk0uRm9ydW0uY29udGVudFR5cGVzW3R5cGVdXG4gICAgXG4gICAgaWYoIXR5cGVPYmopXG4gICAgICAgIHR5cGVPYmogPSBQQi5NLkZvcnVtLmNvbnRlbnRUeXBlc1sndGV4dCddXG5cbiAgICByZXR1cm4gdHlwZU9iai50b0h0bWwoY29udGVudCwgcHVmZilcbn1cblxuXG4vLyBUT0RPOiB0aGlzIG1pZ2h0IGdldCBiaWcsIG5lZWQgc29tZSBHQyBoZXJlXG5QQi5NLkZvcnVtLnB1ZmZDb250ZW50U3Rhc2ggPSB7fVxuXG5QQi5NLkZvcnVtLmNsZWFyUHVmZkNvbnRlbnRTdGFzaCA9IGZ1bmN0aW9uKCkge1xuICAgIFBCLk0uRm9ydW0ucHVmZkNvbnRlbnRTdGFzaCA9IHt9XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb250ZW50IG9mIGEgcHVmZlxuICogQHBhcmFtICB7cHVmZn0gcHVmZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5QQi5NLkZvcnVtLmdldFByb2Nlc3NlZFB1ZmZDb250ZW50ID0gZnVuY3Rpb24ocHVmZikge1xuICAgIC8vIFRISU5LOiB3ZSd2ZSBhbHJlYWR5IGVuc3VyZWQgdGhlc2UgYXJlIHByb3BlciBwdWZmcywgc28gd2UgZG9uJ3QgaGF2ZSB0byBjaGVjayBmb3IgcGF5bG9hZC4uLiByaWdodD9cbiAgICBpZihQQi5NLkZvcnVtLnB1ZmZDb250ZW50U3Rhc2hbcHVmZi5zaWddKVxuICAgICAgICByZXR1cm4gUEIuTS5Gb3J1bS5wdWZmQ29udGVudFN0YXNoW3B1ZmYuc2lnXVxuICAgIFxuICAgIHZhciBjb250ZW50ID0gUEIuTS5Gb3J1bS5wcm9jZXNzQ29udGVudChwdWZmLnBheWxvYWQudHlwZSwgcHVmZi5wYXlsb2FkLmNvbnRlbnQsIHB1ZmYpXG4gICAgUEIuTS5Gb3J1bS5wdWZmQ29udGVudFN0YXNoW3B1ZmYuc2lnXSA9IGNvbnRlbnRcbiAgICBcbiAgICByZXR1cm4gY29udGVudFxufVxuXG4vKipcbiAqIEFkZCBzdXBwb3J0IGZvciB0eXBlcyBvZiBjb250ZW50IHRvIHRoZSBzeXN0ZW1cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICovXG5QQi5NLkZvcnVtLmFkZENvbnRlbnRUeXBlID0gZnVuY3Rpb24obmFtZSwgdHlwZSkge1xuICAgIC8vIFRISU5LOiBtb3ZlIHRoaXMgZG93biBpbnRvIFBCP1xuICAgIFxuICAgIGlmKCFuYW1lKSBcbiAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ0ludmFsaWQgY29udGVudCB0eXBlIG5hbWUnKVxuICAgIGlmKFBCLkNPTkZJRy5zdXBwb3J0ZWRDb250ZW50VHlwZXMgJiYgUEIuQ09ORklHLnN1cHBvcnRlZENvbnRlbnRUeXBlcy5pbmRleE9mKG5hbWUpID09IC0xKVxuICAgICAgICByZXR1cm4gUEIub25FcnJvcignVW5zdXBwb3J0ZWQgY29udGVudCB0eXBlOiAnICsgbmFtZSlcbiAgICBpZighdHlwZS50b0h0bWwpIFxuICAgICAgICByZXR1cm4gUEIub25FcnJvcignSW52YWxpZCBjb250ZW50IHR5cGU6IG9iamVjdCBpcyBtaXNzaW5nIHRvSHRtbCBtZXRob2QnLCBuYW1lKVxuICAgIFxuICAgIFBCLk0uRm9ydW0uY29udGVudFR5cGVzW25hbWVdID0gdHlwZVxufVxuXG5cbi8vIERFRkFVTFQgQ09OVEVOVCBUWVBFU1xuXG5QQi5NLkZvcnVtLmFkZENvbnRlbnRUeXBlKCd0ZXh0Jywge1xuICAgIHRvSHRtbDogZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICB2YXIgc2FmZV9jb250ZW50ID0gWEJCQ09ERS5wcm9jZXNzKHsgdGV4dDogY29udGVudCB9KSAgIC8vIG5vdCBpZGVhbCwgYnV0IGl0IGRvZXMgc2VlbSB0byBzdHJpcCBvdXQgcmF3IGh0bWxcbiAgICAgICAgc2FmZV9jb250ZW50Lmh0bWwgPSBzYWZlX2NvbnRlbnQuaHRtbC5yZXBsYWNlKC9cXG4vZywgJzwvYnI+Jyk7ICAvLyBTZXQgbGluZSBicmVha3NcbiAgICAgICAgcmV0dXJuICc8c3Bhbj4nICsgc2FmZV9jb250ZW50Lmh0bWwgKyAnPC9zcGFuPidcbiAgICB9XG59KVxuXG5QQi5NLkZvcnVtLmFkZENvbnRlbnRUeXBlKCdiYmNvZGUnLCB7XG4gICAgdG9IdG1sOiBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgIHZhciBiYmNvZGVQYXJzZSA9IFhCQkNPREUucHJvY2Vzcyh7IHRleHQ6IGNvbnRlbnQgfSk7XG4gICAgICAgIHZhciBwYXJzZWRUZXh0ICA9IGJiY29kZVBhcnNlLmh0bWwucmVwbGFjZSgvXFxuL2csICc8YnIgLz4nKTsgXG4gICAgICAgIHJldHVybiBwYXJzZWRUZXh0O1xuICAgIH1cbn0pXG5cblBCLk0uRm9ydW0uYWRkQ29udGVudFR5cGUoJ2ltYWdlJywge1xuICAgIHRvSHRtbDogZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICBpZihwdWZmd29ybGRwcm9wcy52aWV3Lm1vZGUgPT0gXCJ0YWJsZVZpZXdcIilcbiAgICAgICAgICAgIHJldHVybiAnPGltZyBzcmM9JyArIGNvbnRlbnQgKyAnIC8+JztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuICc8aW1nIGNsYXNzPVwiaW1nSW5Cb3hcIiBzcmM9JyArIGNvbnRlbnQgKyAnIC8+JztcbiAgICB9XG59KVxuXG5QQi5NLkZvcnVtLmFkZENvbnRlbnRUeXBlKCdtYXJrZG93bicsIHtcbiAgICB0b0h0bWw6IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIGNvbnZlcnRlciA9IG5ldyBNYXJrZG93bi5Db252ZXJ0ZXIoKTtcbiAgICAgICAgcmV0dXJuICc8c3Bhbj4nK2NvbnZlcnRlci5tYWtlSHRtbChjb250ZW50KSsnPC9zcGFuPic7XG4gICAgfVxufSlcblxuLy8gVXNlZCB0byBkaXNwbGF5IGNoZXNzIGJvYXJkc1xuUEIuTS5Gb3J1bS5hZGRDb250ZW50VHlwZSgnUEdOJywge1xuICAgIHRvSHRtbDogZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICByZXR1cm4gY2hlc3NCb2FyZChjb250ZW50KTtcbiAgICB9XG59KVxuXG5QQi5NLkZvcnVtLmFkZENvbnRlbnRUeXBlKCdpZGVudGl0eScsIHtcbiAgICB0b0h0bWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJydcbiAgICB9XG59KVxuXG5QQi5NLkZvcnVtLmFkZENvbnRlbnRUeXBlKCdwcm9maWxlJywge1xuICAgIHRvSHRtbDogZnVuY3Rpb24oY29udGVudCwgcHVmZikge1xuICAgICAgICBpZihwdWZmd29ybGRwcm9wcy52aWV3Lm1vZGUgPT0gXCJ0YWJsZVZpZXdcIilcbiAgICAgICAgICAgIHJldHVybiAnPGltZyBzcmM9JyArIGNvbnRlbnQgKyAnIC8+JztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuICc8aW1nIGNsYXNzPVwiaW1nSW5Cb3hcIiBzcmM9JyArIGNvbnRlbnQgKyAnIC8+JztcbiAgICAgICAgLyp2YXIga2V5c05vdFNob3cgPSBbJ2NvbnRlbnQnLCAndHlwZSddO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHVmZi5wYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwdWZmLnBheWxvYWRba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXlzTm90U2hvdy5pbmRleE9mKGtleSk9PS0xICYmIHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRvUmV0ICs9ICc8ZGl2PjxzcGFuIGNsYXNzPVwicHJvZmlsZUtleVwiPicgKyBrZXkgKyAnOiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJwcm9maWxlVmFsdWVcIj4nICsgdmFsdWUgKyAnPC9zcGFuPjwvZGl2Pic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0qL1xuICAgIH1cbn0pXG5cblBCLk0uRm9ydW0uYWRkQ29udGVudFR5cGUoJ2ZpbGUnLCB7XG4gICAgdG9IdG1sOiBmdW5jdGlvbihjb250ZW50LCBwdWZmKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwdWZmLnBheWxvYWQuZmlsZW5hbWVcbiAgICAgICAgICAgIClcbiAgICB9XG5cbn0pXG5cbi8vIFRPRE86IEFkZCBzdXBwb3J0IGZvciBMYVRleFxuLypQQi5NLkZvcnVtLmFkZENvbnRlbnRUeXBlKCdMYVRleCcsIHtcbiAgICB0b0h0bWw6IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIHNhZmVfY29udGVudCA9IFhCQkNPREUucHJvY2Vzcyh7IHRleHQ6IGNvbnRlbnQgfSkgXG4gICAgICAgIHJldHVybiAnPHA+JyArIHNhZmVfY29udGVudC5odG1sICsgJzwvcD4nXG4gICAgfVxufSkgKi9cblxuXG4vLyBGbGFnIGEgcHVmZlxuUEIuTS5Gb3J1bS5mbGFnUHVmZiA9IGZ1bmN0aW9uIChzaWcpIHtcblxuICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgdmFyIHJvdXRlcyA9IFtdO1xuICAgIHZhciB0eXBlID0gJ2ZsYWdQdWZmJztcbiAgICB2YXIgY29udGVudCA9IHNpZztcbiAgICBcbiAgICBwYXlsb2FkLnRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgUEIudXNlU2VjdXJlSW5mbyhmdW5jdGlvbihpZGVudGl0aWVzLCBjdXJyZW50VXNlcm5hbWUsIHByaXZhdGVSb290S2V5LCBwcml2YXRlQWRtaW5LZXksIHByaXZhdGVEZWZhdWx0S2V5KSB7ICAgIFxuXG4gICAgICAgIGlmKCFjdXJyZW50VXNlcm5hbWUpIHtcbiAgICAgICAgICAgIGFsZXJ0KFwiWW91IG11c3QgZmlyc3Qgc2V0IHlvdXIgdXNlcm5hbWUgYmVmb3JlIHlvdSBjYW4gZmxhZyBjb250ZW50XCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qaWYoIWN1cnJlbnRVc2VybmFtZSA9PSBQQi5nZXRQdWZmQnlTaWcoc2lnKS51c2VybmFtZSkge1xuICAgICAgICAgICAgYWxlcnQoXCJZb3UgbXVzdCBzZXQgeW91ciBpZGVudGl0eSB0byB0aGUgYXV0aG9yIG9mIHRoZSBwdWZmIHlvdSB3YW50IHRvIGZsYWdcIik7XG4gICAgICAgIH0qL1xuICAgICAgICBpZighcHJpdmF0ZUFkbWluS2V5KSB7XG4gICAgICAgICAgICBhbGVydChcIllvdSBtdXN0IGZpcnN0IHNldCB5b3VyIHByaXZhdGUgYWRtaW4ga2V5IGJlZm9yZSB5b3UgY2FuIGZsYWcgY29udGVudFwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICB2YXIgcHVmZiA9IFBCLmJ1aWxkUHVmZihjdXJyZW50VXNlcm5hbWUsIHByaXZhdGVBZG1pbktleSwgcm91dGVzLCB0eXBlLCBjb250ZW50LCBwYXlsb2FkKTtcbiAgICB9KVxuXG4gICAgdmFyIGRhdGEgPSB7IHR5cGU6ICdmbGFnUHVmZidcbiAgICAgICAgICAgICAgICwgcHVmZjogcHVmZlxuICAgICAgICAgICAgICAgfTtcblxuICAgIHZhciBwcm9tID0gUEIuTmV0LlBCcG9zdChQQi5DT05GSUcucHVmZkFwaSwgZGF0YSk7XG4gICAgXG4gICAgcHJvbSA9IHByb20udGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAvLyB2YXIgc3RvcmVkU2hlbGxzID0gUEIuUGVyc2lzdC5nZXQoJ3NoZWxscycpO1xuICAgICAgICAvLyB2YXIgZmlsdGVyZWRTaGVsbHMgPSBzdG9yZWRTaGVsbHMuZmlsdGVyKGZ1bmN0aW9uKHMpe3JldHVybiBzLnNpZyAhPSBjb250ZW50ICYmIHMuY29udGVudCAhPSBjb250ZW50fSk7XG4gICAgICAgIHZhciBmbGFnZ2VkU2lnID0gUEIuUGVyc2lzdC5nZXQoJ2ZsYWdnZWQnKSB8fCBbXTtcbiAgICAgICAgZmxhZ2dlZFNpZy5wdXNoKGNvbnRlbnQpO1xuXG4gICAgICAgIC8vIFBCLlBlcnNpc3Quc2F2ZSgnc2hlbGxzJywgZmlsdGVyZWRTaGVsbHMpO1xuICAgICAgICBQQi5QZXJzaXN0LnNhdmUoJ2ZsYWdnZWQnLCBmbGFnZ2VkU2lnKTtcbiAgICAgICAgLy8gcmVsb2FkP1xuICAgICAgICAvLyBkb2N1bWVudC5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgRXZlbnRzLnB1YigndWkvZmxhZycsIHt9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KVxuICAgIHJldHVybiBwcm9tO1xufVxuXG5cbi8vIEFkZGluZyBkZWZhdWx0IG1ldGFmaWVsZHMgdG8gaW5jbHVkZWQgaW4gYSBwdWZmXG5QQi5NLkZvcnVtLm1ldGFGaWVsZHMgPSBbXVxuUEIuTS5Gb3J1bS5jb250ZXh0ID0ge307XG5QQi5NLkZvcnVtLmFkZE1ldGFGaWVsZHMgPSBmdW5jdGlvbihmaWVsZEluZm8sIGNvbnRleHQsIGV4Y2x1ZGVDb250ZXh0KSB7XG4gICAgLy8gTk9URTogdGhpcyBpc24ndCB1c2VkIG91dHNpZGUgb2YgcHVibGlzaEVtYmVkLmpzLCBidXQgaXQgbWlnaHQgcHJvdmlkZSBhIGdvb2QgYmFzaXMgZm9yIGdlbmVyaWMvcmVxdWlyZWQgbWV0YWRhdGFcbiAgICBcbiAgICBpZiAoIWZpZWxkSW5mby5uYW1lKSByZXR1cm4gY29uc29sZS5sb2coJ0ludmFsaWQgbWV0YSBmaWVsZCBuYW1lLicpO1xuXG4gICAgLy8gc3VwcG9ydGVkIHR5cGU6IHRleHQsIHRleHRhcmVhLCBwdWxsZG93biwgYXJyYXlcbiAgICBpZiAoIWZpZWxkSW5mby50eXBlKSByZXR1cm4gY29uc29sZS5sb2coJ0ludmFsaWQgbWV0YSBmaWVsZCB0eXBlLicpO1xuXG4gICAgaWYgKCFmaWVsZEluZm8udmFsaWRhdG9yIHx8IHR5cGVvZiBmaWVsZEluZm8udmFsaWRhdG9yICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmllbGRJbmZvLnZhbGlkYXRvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IE9iamVjdC5rZXlzKFBCLk0uRm9ydW0uY29udGVudFR5cGVzKTtcbiAgICBpZiAodHlwZW9mIGNvbnRleHQgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29udGV4dCA9IFtjb250ZXh0XTtcbiAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGNvbnRleHQpKSB7XG4gICAgICAgIHJldHVybiBQQi5vbkVycm9yKCdJbnZhbGlkIGNvbnRleHQuJylcbiAgICB9XG5cbiAgICBleGNsdWRlQ29udGV4dCA9IGV4Y2x1ZGVDb250ZXh0IHx8IFtdO1xuICAgIGlmICh0eXBlb2YgZXhjbHVkZUNvbnRleHQgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXhjbHVkZUNvbnRleHQgPSBbZXhjbHVkZUNvbnRleHRdO1xuICAgIH1lbHNlIGlmICghQXJyYXkuaXNBcnJheShleGNsdWRlQ29udGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ0ludmFsaWQgY29udGV4dC4nKVxuICAgIH1cblxuICAgIFBCLk0uRm9ydW0ubWV0YUZpZWxkcy5wdXNoKGZpZWxkSW5mbyk7XG4gICAgZm9yICh2YXIgaT0wOyBpPGNvbnRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGV4Y2x1ZGVDb250ZXh0LmluZGV4T2YoY29udGV4dFtpXSkgIT0gLTEpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdmFyIGNvbnRleHRGaWVsZHMgPSBQQi5NLkZvcnVtLmNvbnRleHRbY29udGV4dFtpXV0gfHwgW107XG4gICAgICAgIGNvbnRleHRGaWVsZHMucHVzaChmaWVsZEluZm8ubmFtZSk7XG4gICAgICAgIFBCLk0uRm9ydW0uY29udGV4dFtjb250ZXh0W2ldXSA9IGNvbnRleHRGaWVsZHM7XG4gICAgfVxufVxuXG5QQi5NLkZvcnVtLmFkZE1ldGFGaWVsZHMoXG4gICAge25hbWU6ICdyZXBseSBwcml2YWN5JyxcbiAgICAgdHlwZTogJ3B1bGxkb3duJyxcbiAgICAgZW51bTogWycnLCAncHVibGljJywgJ3ByaXZhdGUnLCAnYW5vbnltb3VzJywgJ2ludmlzaWJsZSddLFxuICAgICBkZWZhdWx0VmFsdWU6ICcnfSk7XG5cblBCLk0uRm9ydW0uYWRkTWV0YUZpZWxkcyhcbiAgICB7bmFtZTogJ2NvbnRlbnQgbGljZW5zZScsXG4gICAgIHR5cGU6ICdwdWxsZG93bicsXG4gICAgIGVudW06IFsnJywgJ0NyZWF0aXZlQ29tbW9uc0F0dHJpYnV0aW9uJywgJ0dOVVB1YmxpY0xpY2Vuc2UnLCAnUHVibGljZG9tYWluJywgJ1JpZ2h0cy1tYW5hZ2VkJywgJ1JveWFsdHktZnJlZSddLFxuICAgICBkZWZhdWx0VmFsdWU6ICcnfSk7XG5cblBCLk0uRm9ydW0uYWRkTWV0YUZpZWxkcyhcbiAgICB7bmFtZTogJ3RhZ3MnLFxuICAgICB0eXBlOiAnYXJyYXknLFxuICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uKHYpe3JldHVybiAvXlthLXowLTldKyQvaS50ZXN0KHYpfVxuICAgICB9LFxuICAgIGZhbHNlLCAncHJvZmlsZScpO1xuXG5QQi5NLkZvcnVtLmFkZE1ldGFGaWVsZHMoXG4gICAge25hbWU6ICdsYW5ndWFnZScsXG4gICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgZGVmYXVsdFZhbHVlOiBmdW5jdGlvbigpe3JldHVybiBwdWZmd29ybGRwcm9wcy52aWV3Lmxhbmd1YWdlfX0pO1xuXG5QQi5NLkZvcnVtLmFkZE1ldGFGaWVsZHMoXG4gICAge25hbWU6ICduYW1lJyxcbiAgICAgdHlwZTogJ3RleHQnfSxcbiAgICAncHJvZmlsZScpOyIsIi8qIFxuICAgICAgICAgICAgICAgICAgIF9fX19fICBfX19fXyAgICAgICAgICAgICAgICAgICAgICAgICAgLl9fXyAgICAgICAgICAgIF9fXy4gICAgICAgICAgIFxuICAgIF9fX19fXyAgX18gX19fLyBfX19fXFwvIF9fX19cXF8gIF8gIF9fX19fX18gX19fX19fXyAgX198IF8vX19fX19fICBfX19fXFxfIHxfXyAgIF9fX18gIFxuICAgIFxcX19fXyBcXHwgIHwgIFxcICAgX19cXFxcICAgX19cXFxcIFxcLyBcXC8gL1xcX18gIFxcXFxfICBfXyBcXC8gX18gfFxcXyAgX18gXFwvICBfIFxcfCBfXyBcXF8vIF9fIFxcIFxuICAgIHwgIHxfPiA+ICB8ICAvfCAgfCAgIHwgIHwgICBcXCAgICAgLyAgLyBfXyBcXHwgIHwgXFwvIC9fLyB8IHwgIHwgXFwoICA8Xz4gKSBcXF9cXCBcXCAgX19fLyBcbiAgICB8ICAgX18vfF9fX18vIHxfX3wgICB8X198ICAgIFxcL1xcXy8gIChfX19fICAvX198ICBcXF9fX18gfCB8X198ICAgXFxfX19fL3xfX18gIC9cXF9fXyAgPlxuICAgIHxfX3wgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFwvICAgICAgICAgICBcXC8gICAgICAgICAgICAgICAgICBcXC8gICAgIFxcLyBcbiAgXG4gIEEgUHVmZmJhbGwgbW9kdWxlIGZvciBtYW5hZ2luZyBpZGVudGl0aWVzIGFuZCBwcml2YXRlIGRhdGEgbG9jYWxseS5cbiAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBUaGUgV2FyZHJvYmUgbWFuYWdlcyBpZGVudGl0aWVzLCBhbGlhc2VzLCBhbmQgcHJpdmF0ZSBkYXRhLlxuXG4gIEFuIGlkZW50aXR5IGlzIGEgdXNlcm5hbWUgYW5kIGEgbGlzdCBvZiBhbGwga25vd24gYWxpYXNlcy4gVGhlIGlkZW50aXR5IGFsc28gbGlzdHMgdGhlIGxhc3Qga25vd24gcHJpbWFyeSBhbGlhcywgaWYgdGhlcmUgaXMgb25lLCBhbmQgdGhlIGlkZW50aXR5J3MgcHJpdmF0ZSBwcmVmZXJlbmNlcy4gXG5cbiAgQW4gYWxpYXMgaXMgYSB1c2VybmFtZSwgYSAnY2FwYScsIGFuZCBhIHNldCBvZiBwcml2YXRlIGtleXMuIEFkZGl0aW9uYWwgcHJpdmF0ZSBpbmZvcm1hdGlvbiAobGlrZSBhIHBhc3NwaHJhc2UpIG1heSBiZSBzdG9yZWQgaW4gdGhlIGFsaWFzJ3MgJ3NlY3JldHMnIGZpZWxkLlxuXG4gIEFsaWFzZXMgZ2VuZXJhbGx5IGNvcnJlc3BvbmQgZWl0aGVyIHRvIHByZXZpb3VzIHZlcnNpb25zIG9mIHRoZSBpZGVudGl0eSdzIHVzZXJuYW1lIChwcmV2aW91cyBwcmltYXJpZXMpLCBvciB0byBhbm9ueW1vdXMgdXNlcm5hbWVzIGNyZWF0ZWQgZm9yIG9uZS10aW1lIGVuY3J5cHRlZCB0cmFuc2Zlci4gXG5cbiAgVXNlcm5hbWUgYW5kIGNhcGEgZGVmaW5lIGEgdW5pcXVlIGFsaWFzLiBUaGUgY2FwYSBmaWVsZCByZWZlcmVuY2VzIGEgc3BlY2lmaWMgbW9tZW50IGluIHRoZSB1c2VybmFtZSdzIGxpZmVjeWNsZSwgYW5kIGNvcnJlbGF0ZXMgdG8gdGhlIHVzZXJSZWNvcmQgd2l0aCB0aGUgc2FtZSB1c2VybmFtZSBhbmQgY2FwYSB3aG9zZSBwdWJsaWMga2V5cyBtYXRjaCB0aGUgYWxpYXMncyBwcml2YXRlIGtleXMuIEluIG90aGVyIHdvcmRzLCBjYXBhID09IHZlcnNpb24uXG5cbiAgQ3VycmVudGx5IGNhcGEgY291bnRzIGJ5IGNvbnNlY3V0aXZlIGludGVnZXJzLiBUaGlzIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS4gQW55IHNldCBkZXJpdmluZyBFcSBhbmQgT3JkIHdpbGwgd29yay5cblxuICBBbiBpZGVudGl0eSBmaWxlIGNhbiBiZSBleHBvcnRlZCB0byB0aGUgbG9jYWwgZmlsZXN5c3RlbSBhbmQgaW1wb3J0ZWQgYmFjayBpbiB0byB0aGUgc3lzdGVtLlxuXG4gIFByaXZhdGUgZGF0YSBpcyBhIGJsYWNrIGJveCBmb3IgXG5cbiAgVXNhZ2UgZXhhbXBsZXM6XG4gICAgICBQQi5zd2l0Y2hJZGVudGl0eVRvKHVzZXJuYW1lKVxuXG4qL1xuXG4vKlxuICBUSElOSzpcbiAgICAtIHJlZ2lzdGVyIGNhbGxiYWNrIGhhbmRsZXJzIGZvciB1c2VyIHJlY29yZCBjcmVhdGlvbiBhbmQgbW9kaWZpY2F0aW9uXG4gICAgLSBQQi5NLldhcmRyb2JlLmluaXQgcmVnaXN0ZXJzIHRob3NlIHdpdGggUEIub25Vc2VyQ3JlYXRpb24gYW5kIFBCLm9uVXNlck1vZGlmaWNhdGlvblxuICAgIC0gaWRlbnRpdHkgZmlsZSBlbmNyeXB0aW9uIHVzaW5nIGEgcGFzc3BocmFzZVxuKi9cblxuXG5QQi5NLldhcmRyb2JlID0ge31cblxufmZ1bmN0aW9uKCkgeyAvLyBiZWdpbiB0aGUgY2xvc3VyZVxuXG4gICAgdmFyIGlkZW50aXRpZXMgPSB7fVxuICAgIHZhciBhbGlhc2VzID0ge31cbiAgICAvLyB7YXNkZjogeyB1c2VybmFtZTogJ2FzZGYnLCBwcmltYXJ5OiBhc2RmLTEyLCBhbGlhc2VzOiBbYXNkZi0xMSwgYXNkZi0xMF0sIHByZWZlcmVuY2VzOiB7fSB9IH1cblxuICAgIC8vIGFuIGFsaWFzOiB7IHVzZXJuYW1lOiAnYXNkZicsIGNhcGE6IDEyLCBwcml2YXRlUm9vdEtleTogJzEyMycsIHByaXZhdGVBZG1pbktleTogJzMzMycsIHByaXZhdGVEZWZhdWx0S2V5OiAnNDQ0Jywgc2VjcmV0czoge30gfVxuXG4gICAgdmFyIGN1cnJlbnRVc2VybmFtZSA9IGZhbHNlXG5cblxuICAgIC8vIFRPRE86IGludGVncmF0ZSBjYXBhIHdpdGggdXNlclJlY29yZHMgYW5kIHB1ZmZzIGV2ZXJ5d2hlcmVcbiAgICAvLyBUT0RPOiB1c2UgY2FwYSByZXR1cm5lZCBmcm9tIHNlcnZlciBvbiB1cGRhdGUgcGFzc3BocmFzZVxuICAgIC8vIFRPRE86IGdldCBhbm9uIGNyZWF0aW9uIHdvcmtpbmdcblxuXG4gICAgUEIuTS5XYXJkcm9iZS5pbml0ID0gaW5pdFxuICAgIFxuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIFBCLmltcGxlbWVudFNlY3VyZUludGVyZmFjZSh1c2VTZWN1cmVJbmZvLCBhZGRJZGVudGl0eSwgYWRkQWxpYXMsIHNldFByaW1hcnlBbGlhcywgc2V0UHJlZmVyZW5jZSwgc3dpdGNoSWRlbnRpdHlUbywgcmVtb3ZlSWRlbnRpdHkpXG4gICAgICAgIFxuICAgICAgICBQQi5hZGRJZGVudGl0eVVwZGF0ZUhhbmRsZXIoZnVuY3Rpb24oKSB7IC8vIFRISU5LOiB3aGVyZSBzaG91bGQgdGhpcyBsaXZlP1xuICAgICAgICAgICAgaWYoIVBCLkNPTkZJRy5kaXNhYmxlQ2xvdWRJZGVudGl0eSlcbiAgICAgICAgICAgICAgICBQQi5zdG9yZUlkZW50aXR5RmlsZUluQ2xvdWQoKVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciB3YXkgdG8gZG8gdGhpc1xuICAgICAgICB2YXIgb2xkQ29uZmlnVmFsdWUgPSBQQi5DT05GSUcuZGlzYWJsZUNsb3VkSWRlbnRpdHlcbiAgICAgICAgUEIuQ09ORklHLmRpc2FibGVDbG91ZElkZW50aXR5ID0gdHJ1ZVxuICAgICAgICBcbiAgICAgICAgdmFyIHN0b3JlZElkZW50aXRpZXMgPSBQQi5QZXJzaXN0LmdldCgnaWRlbnRpdGllcycpIHx8IHt9XG4gICAgXG4gICAgICAgIE9iamVjdC5rZXlzKHN0b3JlZElkZW50aXRpZXMpLmZvckVhY2goZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAgICAgICAgIHZhciBpZGVudGl0eSA9IHN0b3JlZElkZW50aXRpZXNbdXNlcm5hbWVdXG4gICAgICAgICAgICBhZGRJZGVudGl0eSh1c2VybmFtZSwgaWRlbnRpdHkuYWxpYXNlcywgaWRlbnRpdHkucHJlZmVyZW5jZXMsIHRydWUpXG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICBQQi5DT05GSUcuZGlzYWJsZUNsb3VkSWRlbnRpdHkgPSBvbGRDb25maWdWYWx1ZVxuICAgICAgICBcbiAgICAgICAgdmFyIGxhc3RVc2VybmFtZSA9IFBCLlBlcnNpc3QuZ2V0KCdjdXJyZW50VXNlcm5hbWUnKVxuICAgICAgICBcbiAgICAgICAgaWYgKGxhc3RVc2VybmFtZSlcbiAgICAgICAgICAgIFBCLnN3aXRjaElkZW50aXR5VG8obGFzdFVzZXJuYW1lKSAvLyBOT1RFOiBjYWxsIHdyYXBwZWQgdmVyc2lvbiB0byBnZXQgaGFuZGxlcnNcbiAgICB9XG4gICAgXG4gICAgXG4gICAgLy8vLyBleHBvcnRlZCB2aWEgaW1wbGVtZW50U2VjdXJlSW50ZXJmYWNlXG5cbiAgICB2YXIgdXNlU2VjdXJlSW5mbyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpZGVudGl0eSA9IGdldEN1cnJlbnRJZGVudGl0eSgpIHx8IHt9XG4gICAgICAgIHZhciBwcmltYXJ5ID0gaWRlbnRpdHkucHJpbWFyeSB8fCB7fVxuXG4gICAgICAgIC8vIHdlIGhhdmUgdG8gcmV0dXJuIGFsbCB0aGUgaWRlbnRpdGllcyBiZWNhdXNlIHRoZSB1c2VyIG1pZ2h0IGJlIHRyeWluZyB0byBsaXN0IHRoZW1cbiAgICAgICAgY2FsbGJhY2soaWRlbnRpdGllcywgY3VycmVudFVzZXJuYW1lLCBwcmltYXJ5LnByaXZhdGVSb290S2V5LCBwcmltYXJ5LnByaXZhdGVBZG1pbktleSwgcHJpbWFyeS5wcml2YXRlRGVmYXVsdEtleSlcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgdmFyIGFkZElkZW50aXR5ID0gZnVuY3Rpb24odXNlcm5hbWUsIGFsaWFzZXMsIHByZWZlcmVuY2VzLCBub3NhdmUpIHsgLy8gVE9ETzogY2hlY2sgaWYgbm9zYXZlIGlzIG5lZWRlZFxuICAgICAgICAvLyBUT0RPOiB2YWxpZGF0aW9uIG9uIGFsbCBhdmFpbGFibGUgdmFsdWVzXG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGZvciBleGlzdGluZyBpZGVudGl0eVxuICAgICAgICAvLyBUT0RPOiBhZGQgYW55IHVua25vd24gYWxpYXNlc1xuICAgICAgICAvLyBUSElOSzogd2hhdCBhYm91dCBhbGlhc2VzIHRoYXQgYmVsb25nIHRvIG90aGVyIGlkZW50aXRpZXM/XG4gICAgICAgIC8vIFRISU5LOiBlbnN1cmUgcHJpbWFyeSBhbGlhcyBleGlzdHM/XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSBwcmltYXJ5ICh1c2UgdXNlcm5hbWUrbWF4Y2FwYSBpbnN0ZWFkKVxuXG4gICAgICAgIHZhciBpZGVudGl0eSA9IHsgdXNlcm5hbWU6IHVzZXJuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICwgcHJpbWFyeToge31cbiAgICAgICAgICAgICAgICAgICAgICAgLCBhbGlhc2VzOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAsIHByZWZlcmVuY2VzOiBwcmVmZXJlbmNlcyB8fCB7fVxuICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgaWRlbnRpdGllc1t1c2VybmFtZV0gPSBpZGVudGl0eVxuICAgICAgICBcbiAgICAgICAgaWYoIUFycmF5LmlzQXJyYXkoYWxpYXNlcykpXG4gICAgICAgICAgICBhbGlhc2VzID0gYWxpYXNlcyA/IFthbGlhc2VzXSA6IFtdXG4gICAgICAgIFxuICAgICAgICBhbGlhc2VzLmZvckVhY2goXG4gICAgICAgICAgICBmdW5jdGlvbihhbGlhcykge1xuICAgICAgICAgICAgICAgIGFkZEFsaWFzKHVzZXJuYW1lLCBhbGlhcy51c2VybmFtZSwgYWxpYXMuY2FwYSwgYWxpYXMucHJpdmF0ZVJvb3RLZXksIGFsaWFzLnByaXZhdGVBZG1pbktleSwgYWxpYXMucHJpdmF0ZURlZmF1bHRLZXksIGFsaWFzLnNlY3JldHMpfSlcbiAgICAgICAgXG4gICAgICAgIC8vIFRPRE86IGhhbmRsZSBwcmVmc1xuICAgICAgICBcbiAgICAgICAgaWYoIW5vc2F2ZSkgLy8gVE9ETzogY2hhbmdlIHByb2Nlc3NVcGRhdGVzIHNvIGl0IG9ubHkgc2F2ZXMgaWYgd2UncmUgbm90IGJ1c3kgb3BlbmluZyBhbGwgaWRlbnRpdGllcz8gb3IganVzdCBsZXQgdGhlIDEwMG1zIHRocm90dGxlIGhhbmRsZSBpdC4uLlxuICAgICAgICAgICAgcHJvY2Vzc1VwZGF0ZXMoKVxuICAgICAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgdmFyIGFkZEFsaWFzID0gZnVuY3Rpb24oaWRlbnRpdHlVc2VybmFtZSwgYWxpYXNVc2VybmFtZSwgY2FwYSwgcHJpdmF0ZVJvb3RLZXksIHByaXZhdGVBZG1pbktleSwgcHJpdmF0ZURlZmF1bHRLZXksIHNlY3JldHMpIHtcbiAgICAgICAgLy8gVE9ETzogdmFsaWRhdGlvbiBvbiBhbGwgYXZhaWxhYmxlIHZhbHVlc1xuICAgICAgICAvLyBUT0RPOiBjaGVjayBmb3IgZXhpc3RpbmcgdXNlcm5hbWUvY2FwYVxuICAgICAgICAvLyBUSElOSzogaGl0IG5ldHdvcmsgZm9yIGNvbmZpcm1hdGlvbj9cbiAgICAgICAgLy8gVEhJTks6IG1heWJlIG9ubHkgaW5jbHVkZSB2aWFibGUgdmFsdWVzP1xuXG4gICAgICAgIHZhciBhbGlhcyA9IHsgdXNlcm5hbWU6IGFsaWFzVXNlcm5hbWVcbiAgICAgICAgICAgICAgICAgICAgLCBjYXBhOiBjYXBhIHx8IDEgLy8gTk9URTogZGVmYXVsdCBjYXBhXG4gICAgICAgICAgICAgICAgICAgICwgcHJpdmF0ZVJvb3RLZXk6IHByaXZhdGVSb290S2V5IHx8IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICwgcHJpdmF0ZUFkbWluS2V5OiBwcml2YXRlQWRtaW5LZXkgfHwgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgLCBwcml2YXRlRGVmYXVsdEtleTogcHJpdmF0ZURlZmF1bHRLZXkgfHwgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgLCBzZWNyZXRzOiBzZWNyZXRzIHx8IHt9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICB2YXIgaWRlbnRpdHkgPSBnZXRJZGVudGl0eShpZGVudGl0eVVzZXJuYW1lKVxuICAgICAgICBcbiAgICAgICAgaWYoIWlkZW50aXR5KSB7XG4gICAgICAgICAgICBhZGRJZGVudGl0eShpZGVudGl0eVVzZXJuYW1lKSAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVzIGFuIGVtcHR5IGlkZW50aXR5XG4gICAgICAgICAgICBpZGVudGl0eSA9IGdldElkZW50aXR5KGlkZW50aXR5VXNlcm5hbWUpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIG1lcmdlIGFsaWFzXG4gICAgICAgIHZhciBvbGRfYWxpYXMgPSBnZXRPbGRBbGlhcyhpZGVudGl0eSwgYWxpYXMpXG4gICAgICAgIGlmKG9sZF9hbGlhcykge1xuICAgICAgICAgICAgYWxpYXMuc2VjcmV0cyA9IEJvcm9uLmV4dGVuZChvbGRfYWxpYXMuc2VjcmV0cywgYWxpYXMuc2VjcmV0cylcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIGFsaWFzKSBcbiAgICAgICAgICAgICAgICBpZihhbGlhc1trZXldKVxuICAgICAgICAgICAgICAgICAgICBvbGRfYWxpYXNba2V5XSA9IGFsaWFzW2tleV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlkZW50aXR5LmFsaWFzZXMucHVzaChhbGlhcylcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoYWxpYXNVc2VybmFtZSA9PSBpZGVudGl0eVVzZXJuYW1lICYmIGFsaWFzLmNhcGEgPj0gKGlkZW50aXR5LmNhcGF8fDApKSB7XG4gICAgICAgICAgICBpZGVudGl0eS5wcmltYXJ5ID0gYWxpYXMgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgcHJpbWFyeSBmb3IgaWRlbnRpdHkgKHdoaWNoIG1heSBoYXZlIGJlZW4gZW1wdHkpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGFsaWFzZXNbYWxpYXNVc2VybmFtZV0gPSBpZGVudGl0eSAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhpcyB0byB0aGUgYWxpYXMtaWRlbnRpdHkgbWFwcGluZ1xuXG4gICAgICAgIHByb2Nlc3NVcGRhdGVzKClcblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHZhciBzZXRQcmltYXJ5QWxpYXMgPSBmdW5jdGlvbihpZGVudGl0eVVzZXJuYW1lLCBhbGlhc1VzZXJuYW1lKSB7XG4gICAgICAgIHZhciBpZGVudGl0eSA9IGdldElkZW50aXR5KGlkZW50aXR5VXNlcm5hbWUpXG4gICAgICAgIFxuICAgICAgICBpZighaWRlbnRpdHkpXG4gICAgICAgICAgICByZXR1cm4gUEIub25FcnJvcignUHJpbWFyeSBhbGlhcyBjYW4gb25seSBiZSBzZXQgZm9yIGtub3duIGlkZW50aXRpZXMnKVxuICAgICAgICAgICAgXG4gICAgICAgIHZhciBhbGlhcyA9IGdldExhdGVzdEFsaWFzKGlkZW50aXR5LCBhbGlhc1VzZXJuYW1lKVxuICAgICAgICBcbiAgICAgICAgaWYoIWFsaWFzKVxuICAgICAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ1RoYXQgYWxpYXMgaXMgbm90IGFzc29jaWF0ZWQgd2l0aCB0aGF0IGlkZW50aXR5JylcbiAgICBcbiAgICAgICAgLy8gYWxsIGNsZWFyIVxuICAgICAgICBcbiAgICAgICAgaWRlbnRpdHkudXNlcm5hbWUgPSBhbGlhc1VzZXJuYW1lXG4gICAgICAgIGlkZW50aXR5LnByaW1hcnkgPSBhbGlhc1xuXG4gICAgICAgIGRlbGV0ZSBpZGVudGl0aWVzW2lkZW50aXR5VXNlcm5hbWVdXG4gICAgICAgIGlkZW50aXRpZXNbYWxpYXNVc2VybmFtZV0gPSBpZGVudGl0eVxuICAgICAgICBcbiAgICAgICAgaWYoaWRlbnRpdHlVc2VybmFtZSA9PSBjdXJyZW50VXNlcm5hbWUpXG4gICAgICAgICAgICBzd2l0Y2hJZGVudGl0eVRvKGFsaWFzVXNlcm5hbWUpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAgXG4gICAgdmFyIHNldFByZWZlcmVuY2UgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIC8vIE5PVEU6IHRoaXMgb25seSB3b3JrcyBmb3IgdGhlIGN1cnJlbnQgaWRlbnRpdHlcbiAgICAgICAgdmFyIGlkZW50aXR5ID0gZ2V0Q3VycmVudElkZW50aXR5KClcbiAgICBcbiAgICAgICAgaWYoIWlkZW50aXR5KVxuICAgICAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ1ByZWZlcmVuY2VzIGNhbiBvbmx5IGJlIHNldCBmb3IgYW4gYWN0aXZlIGlkZW50aXR5JylcbiAgICBcbiAgICAgICAgaWRlbnRpdHkucHJlZmVyZW5jZXNba2V5XSA9IHZhbHVlXG5cbiAgICAgICAgcHJvY2Vzc1VwZGF0ZXMoKVxuICAgIH1cbiAgICBcbiAgICB2YXIgc3dpdGNoSWRlbnRpdHlUbyA9IGZ1bmN0aW9uKHVzZXJuYW1lKSB7XG4gICAgICAgIGlmKHVzZXJuYW1lKSB7XG4gICAgICAgICAgICB2YXIgaWRlbnRpdHkgPSBnZXRJZGVudGl0eSh1c2VybmFtZSlcblxuICAgICAgICAgICAgaWYoIWlkZW50aXR5KVxuICAgICAgICAgICAgICAgIHJldHVybiBQQi5vbkVycm9yKCdObyBpZGVudGl0eSBmb3VuZCB3aXRoIHVzZXJuYW1lIFwiJyArIHVzZXJuYW1lICsgJ1wiJylcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY3VycmVudFVzZXJuYW1lID0gdXNlcm5hbWUgfHwgZmFsc2VcblxuICAgICAgICBpZighUEIuY3VycmVudElkZW50aXR5SGFzaCkgLy8gVEhJTks6IHdoYXQgYXJlIHRoZSBjYXNlcz9cbiAgICAgICAgICAgIFBCLmN1cnJlbnRJZGVudGl0eUhhc2ggPSBQQi5DcnlwdG8uY3JlYXRlTWVzc2FnZUhhc2goSlNPTi5zdHJpbmdpZnkoUEIuZm9ybWF0SWRlbnRpdHlGaWxlKCkpKVxuICAgICAgICBcbiAgICAgICAgcHJvY2Vzc1VwZGF0ZXMoKVxuICAgICAgICBcbiAgICAgICAgaWYodXNlcm5hbWUgJiYgaWRlbnRpdHkgJiYgaWRlbnRpdHkucHJpbWFyeSlcbiAgICAgICAgICAgIFBCLlVzZXJzLmdldFVzZXJSZWNvcmRQcm9taXNlKHVzZXJuYW1lLCBpZGVudGl0eS5wcmltYXJ5LmNhcGEpIC8vIGZldGNoIG91ciB1c2VyUmVjb3JkIFxuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIFxuICAgIHZhciByZW1vdmVJZGVudGl0eSA9IGZ1bmN0aW9uKHVzZXJuYW1lKSB7XG4gICAgICAgIHZhciBpZGVudGl0eSA9IGdldElkZW50aXR5KHVzZXJuYW1lKVxuXG4gICAgICAgIGlmKCFpZGVudGl0eSlcbiAgICAgICAgICAgIHJldHVybiBQQi5vbkVycm9yKCdDb3VsZCBub3QgZmluZCB0aGF0IGlkZW50aXR5IGZvciByZW1vdmFsJylcblxuICAgICAgICBkZWxldGUgaWRlbnRpdGllc1t1c2VybmFtZV1cblxuICAgICAgICBpZihjdXJyZW50VXNlcm5hbWUgPT0gdXNlcm5hbWUpXG4gICAgICAgICAgICBjdXJyZW50VXNlcm5hbWUgPSBmYWxzZVxuXG4gICAgICAgIHByb2Nlc3NVcGRhdGVzKClcbiAgICB9XG5cbiAgICAvLy8vXG4gICAgLy8vLyBpbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb25zLiBub3QgZXhwb3J0ZWQuXG4gICAgLy8vL1xuXG4gICAgZnVuY3Rpb24gZ2V0TGF0ZXN0QWxpYXMoaWRlbnRpdHksIGFsaWFzVXNlcm5hbWUpIHtcbiAgICAgICAgdmFyIG1heGNhcGEgPSAwXG4gICAgICAgIHZhciBhbGlhcyA9IGZhbHNlXG4gICAgICAgIFxuICAgICAgICBmb3IodmFyIGk9MCwgbD1pZGVudGl0eS5hbGlhc2VzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZXN0ID0gaWRlbnRpdHkuYWxpYXNlc1tpXVxuICAgICAgICAgICAgaWYodGVzdC51c2VybmFtZSA9PSBhbGlhc1VzZXJuYW1lICYmIHRlc3QuY2FwYSA+IG1heGNhcGEpIHtcbiAgICAgICAgICAgICAgICBhbGlhcyA9IHRlc3RcbiAgICAgICAgICAgICAgICBtYXhjYXBhID0gdGVzdC5jYXBhXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhbGlhc1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE9sZEFsaWFzKGlkZW50aXR5LCBhbGlhcykge1xuICAgICAgICBmb3IodmFyIGk9MCwgbD1pZGVudGl0eS5hbGlhc2VzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZXN0ID0gaWRlbnRpdHkuYWxpYXNlc1tpXVxuICAgICAgICAgICAgaWYoYWxpYXMudXNlcm5hbWUgPT0gdGVzdC51c2VybmFtZSAmJiBhbGlhcy5jYXBhID09IHRlc3QuY2FwYSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVzdFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQcml2YXRlS2V5cyh1c2VybmFtZSwgY2FwYSwgcHJpdmF0ZVJvb3RLZXksIHByaXZhdGVBZG1pbktleSwgcHJpdmF0ZURlZmF1bHRLZXkpIHtcbiAgICAgICAgLy8gQ1VSUkVOVExZIFVOVVNFRFxuICAgICAgICAvLy8vIEVuc3VyZSBrZXlzIG1hdGNoIHRoZSB1c2VyUmVjb3JkXG4gICAgXG4gICAgICAgIHZhciBwcm9tID0gUEIuVXNlcnMuZ2V0VXNlclJlY29yZFByb21pc2UodXNlcm5hbWUsIGNhcGEpXG4gICAgXG4gICAgICAgIHJldHVybiBwcm9tXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgLy8gdmFsaWRhdGUgYW55IHByb3ZpZGVkIHByaXZhdGUga2V5cyBhZ2FpbnN0IHRoZSB1c2VyUmVjb3JkJ3MgcHVibGljIGtleXNcbiAgICAgICAgICAgICAgICBpZiggICBwcml2YXRlUm9vdEtleSAmJiBQQi5DcnlwdG8ucHJpdmF0ZVRvUHVibGljKHByaXZhdGVSb290S2V5KSAhPSB1c2VyUmVjb3JkLnJvb3RLZXkpXG4gICAgICAgICAgICAgICAgICAgIFBCLnRocm93RXJyb3IoJ1RoYXQgcHJpdmF0ZSByb290IGtleSBkb2VzIG5vdCBtYXRjaCB0aGUgcHVibGljIHJvb3Qga2V5IG9uIHJlY29yZCcpXG4gICAgICAgICAgICAgICAgaWYoICBwcml2YXRlQWRtaW5LZXkgJiYgUEIuQ3J5cHRvLnByaXZhdGVUb1B1YmxpYyhwcml2YXRlQWRtaW5LZXkpICE9IHVzZXJSZWNvcmQuYWRtaW5LZXkpXG4gICAgICAgICAgICAgICAgICAgIFBCLnRocm93RXJyb3IoJ1RoYXQgcHJpdmF0ZSBhZG1pbiBrZXkgZG9lcyBub3QgbWF0Y2ggdGhlIHB1YmxpYyBhZG1pbiBrZXkgb24gcmVjb3JkJylcbiAgICAgICAgICAgICAgICBpZihwcml2YXRlRGVmYXVsdEtleSAmJiBQQi5DcnlwdG8ucHJpdmF0ZVRvUHVibGljKHByaXZhdGVEZWZhdWx0S2V5KSAhPSB1c2VyUmVjb3JkLmRlZmF1bHRLZXkpXG4gICAgICAgICAgICAgICAgICAgIFBCLnRocm93RXJyb3IoJ1RoYXQgcHJpdmF0ZSBkZWZhdWx0IGtleSBkb2VzIG5vdCBtYXRjaCB0aGUgcHVibGljIGRlZmF1bHQga2V5IG9uIHJlY29yZCcpXG4gICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VyUmVjb3JkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAsIFBCLmNhdGNoRXJyb3IoJ0NvdWxkIG5vdCBzdG9yZSBwcml2YXRlIGtleXMgZHVlIHRvIGZhdWx0eSB1c2VyIHJlY29yZCcpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVzKCkge1xuICAgICAgICBpZighUEIuQ09ORklHLmVwaGVtZXJhbEtleWNoYWluKVxuICAgICAgICAgICAgUEIuUGVyc2lzdC5zYXZlKCdpZGVudGl0aWVzJywgaWRlbnRpdGllcylcblxuICAgICAgICAvLyBUSElOSzogY29uc2lkZXIgemlwcGluZyBpZGVudGl0aWVzIGluIGxvY2FsU3RvcmFnZSB0byBwcmV2ZW50IHNob3VsZGVyLXN1cmZpbmcgYW5kIHNhdmUgc3BhY2UgKHNhbWUgZm9yIHB1ZmZzKVxuICAgICAgICAvLyBUSElOSzogY29uc2lkZXIgcGFzc3BocmFzZSBwcm90ZWN0aW5nIGlkZW50aXRpZXMgYW5kIHByaXZhdGUgcHVmZnMgaW4gbG9jYWxTdG9yYWdlXG4gICAgICAgIC8vIFRPRE86IGRvbid0IHBlcnNpc3QgcHJpbWFyeSAtLSByZWdlbmVyYXRlIGl0IGF0IGxvYWQgdGltZSwgc28gd2UgZG9uJ3QgZHVwbGljYXRlIHRoZSBhbGlhc1xuICAgICAgICBQQi5QZXJzaXN0LnNhdmUoJ2N1cnJlbnRVc2VybmFtZScsIGN1cnJlbnRVc2VybmFtZSlcblxuICAgICAgICBQQi5ydW5IYW5kbGVycygnaWRlbnRpdHlVcGRhdGUnKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRJZGVudGl0eSgpIHtcbiAgICAgICAgcmV0dXJuIGdldElkZW50aXR5KGN1cnJlbnRVc2VybmFtZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJZGVudGl0eSh1c2VybmFtZSkge1xuICAgICAgICBpZighdXNlcm5hbWUpIFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgdmFyIGlkZW50aXR5ID0gaWRlbnRpdGllc1t1c2VybmFtZV1cblxuICAgICAgICAvLyBUSElOSzogd2UgY291bGQgY2hlY2sgdGhlIGFsaWFzZXMgbWFwIGhlcmUgaW4gY2FzZSB0aGUgdXNlcm5hbWUgaXNuJ3QgcHJpbWFyeVxuXG4gICAgICAgIGlmKCFpZGVudGl0eSkgXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICByZXR1cm4gaWRlbnRpdHlcbiAgICB9XG5cbn0oKSAvLyBlbmQgdGhlIGNsb3N1cmUiXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=