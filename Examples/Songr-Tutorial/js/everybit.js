!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Bitcoin=e()}}(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(_dereq_,module,exports){var util=_dereq_("util/");var pSlice=Array.prototype.slice;var hasOwn=Object.prototype.hasOwnProperty;var assert=module.exports=ok;assert.AssertionError=function AssertionError(options){this.name="AssertionError";this.actual=options.actual;this.expected=options.expected;this.operator=options.operator;if(options.message){this.message=options.message;this.generatedMessage=false}else{this.message=getMessage(this);this.generatedMessage=true}var stackStartFunction=options.stackStartFunction||fail;if(Error.captureStackTrace){Error.captureStackTrace(this,stackStartFunction)}else{var err=new Error;if(err.stack){var out=err.stack;var fn_name=stackStartFunction.name;var idx=out.indexOf("\n"+fn_name);if(idx>=0){var next_line=out.indexOf("\n",idx+1);out=out.substring(next_line+1)}this.stack=out}}};util.inherits(assert.AssertionError,Error);function replacer(key,value){if(util.isUndefined(value)){return""+value}if(util.isNumber(value)&&(isNaN(value)||!isFinite(value))){return value.toString()}if(util.isFunction(value)||util.isRegExp(value)){return value.toString()}return value}function truncate(s,n){if(util.isString(s)){return s.length<n?s:s.slice(0,n)}else{return s}}function getMessage(self){return truncate(JSON.stringify(self.actual,replacer),128)+" "+self.operator+" "+truncate(JSON.stringify(self.expected,replacer),128)}function fail(actual,expected,message,operator,stackStartFunction){throw new assert.AssertionError({message:message,actual:actual,expected:expected,operator:operator,stackStartFunction:stackStartFunction})}assert.fail=fail;function ok(value,message){if(!value)fail(value,true,message,"==",assert.ok)}assert.ok=ok;assert.equal=function equal(actual,expected,message){if(actual!=expected)fail(actual,expected,message,"==",assert.equal)};assert.notEqual=function notEqual(actual,expected,message){if(actual==expected){fail(actual,expected,message,"!=",assert.notEqual)}};assert.deepEqual=function deepEqual(actual,expected,message){if(!_deepEqual(actual,expected)){fail(actual,expected,message,"deepEqual",assert.deepEqual)}};function _deepEqual(actual,expected){if(actual===expected){return true}else if(util.isBuffer(actual)&&util.isBuffer(expected)){if(actual.length!=expected.length)return false;for(var i=0;i<actual.length;i++){if(actual[i]!==expected[i])return false}return true}else if(util.isDate(actual)&&util.isDate(expected)){return actual.getTime()===expected.getTime()}else if(util.isRegExp(actual)&&util.isRegExp(expected)){return actual.source===expected.source&&actual.global===expected.global&&actual.multiline===expected.multiline&&actual.lastIndex===expected.lastIndex&&actual.ignoreCase===expected.ignoreCase}else if(!util.isObject(actual)&&!util.isObject(expected)){return actual==expected}else{return objEquiv(actual,expected)}}function isArguments(object){return Object.prototype.toString.call(object)=="[object Arguments]"}function objEquiv(a,b){if(util.isNullOrUndefined(a)||util.isNullOrUndefined(b))return false;if(a.prototype!==b.prototype)return false;if(isArguments(a)){if(!isArguments(b)){return false}a=pSlice.call(a);b=pSlice.call(b);return _deepEqual(a,b)}try{var ka=objectKeys(a),kb=objectKeys(b),key,i}catch(e){return false}if(ka.length!=kb.length)return false;ka.sort();kb.sort();for(i=ka.length-1;i>=0;i--){if(ka[i]!=kb[i])return false}for(i=ka.length-1;i>=0;i--){key=ka[i];if(!_deepEqual(a[key],b[key]))return false}return true}assert.notDeepEqual=function notDeepEqual(actual,expected,message){if(_deepEqual(actual,expected)){fail(actual,expected,message,"notDeepEqual",assert.notDeepEqual)}};assert.strictEqual=function strictEqual(actual,expected,message){if(actual!==expected){fail(actual,expected,message,"===",assert.strictEqual)}};assert.notStrictEqual=function notStrictEqual(actual,expected,message){if(actual===expected){fail(actual,expected,message,"!==",assert.notStrictEqual)}};function expectedException(actual,expected){if(!actual||!expected){return false}if(Object.prototype.toString.call(expected)=="[object RegExp]"){return expected.test(actual)}else if(actual instanceof expected){return true}else if(expected.call({},actual)===true){return true}return false}function _throws(shouldThrow,block,expected,message){var actual;if(util.isString(expected)){message=expected;expected=null}try{block()}catch(e){actual=e}message=(expected&&expected.name?" ("+expected.name+").":".")+(message?" "+message:".");if(shouldThrow&&!actual){fail(actual,expected,"Missing expected exception"+message)}if(!shouldThrow&&expectedException(actual,expected)){fail(actual,expected,"Got unwanted exception"+message)}if(shouldThrow&&actual&&expected&&!expectedException(actual,expected)||!shouldThrow&&actual){throw actual}}assert.throws=function(block,error,message){_throws.apply(this,[true].concat(pSlice.call(arguments)))};assert.doesNotThrow=function(block,message){_throws.apply(this,[false].concat(pSlice.call(arguments)))};assert.ifError=function(err){if(err){throw err}};var objectKeys=Object.keys||function(obj){var keys=[];for(var key in obj){if(hasOwn.call(obj,key))keys.push(key)}return keys}},{"util/":3}],2:[function(_dereq_,module,exports){module.exports=function isBuffer(arg){return arg&&typeof arg==="object"&&typeof arg.copy==="function"&&typeof arg.fill==="function"&&typeof arg.readUInt8==="function"}},{}],3:[function(_dereq_,module,exports){(function(process,global){var formatRegExp=/%[sdj%]/g;exports.format=function(f){if(!isString(f)){var objects=[];for(var i=0;i<arguments.length;i++){objects.push(inspect(arguments[i]))}return objects.join(" ")}var i=1;var args=arguments;var len=args.length;var str=String(f).replace(formatRegExp,function(x){if(x==="%%")return"%";if(i>=len)return x;switch(x){case"%s":return String(args[i++]);case"%d":return Number(args[i++]);case"%j":try{return JSON.stringify(args[i++])}catch(_){return"[Circular]"}default:return x}});for(var x=args[i];i<len;x=args[++i]){if(isNull(x)||!isObject(x)){str+=" "+x}else{str+=" "+inspect(x)}}return str};exports.deprecate=function(fn,msg){if(isUndefined(global.process)){return function(){return exports.deprecate(fn,msg).apply(this,arguments)}}if(process.noDeprecation===true){return fn}var warned=false;function deprecated(){if(!warned){if(process.throwDeprecation){throw new Error(msg)}else if(process.traceDeprecation){console.trace(msg)}else{console.error(msg)}warned=true}return fn.apply(this,arguments)}return deprecated};var debugs={};var debugEnviron;exports.debuglog=function(set){if(isUndefined(debugEnviron))debugEnviron=process.env.NODE_DEBUG||"";set=set.toUpperCase();if(!debugs[set]){if(new RegExp("\\b"+set+"\\b","i").test(debugEnviron)){var pid=process.pid;debugs[set]=function(){var msg=exports.format.apply(exports,arguments);console.error("%s %d: %s",set,pid,msg)}}else{debugs[set]=function(){}}}return debugs[set]};function inspect(obj,opts){var ctx={seen:[],stylize:stylizeNoColor};if(arguments.length>=3)ctx.depth=arguments[2];if(arguments.length>=4)ctx.colors=arguments[3];if(isBoolean(opts)){ctx.showHidden=opts}else if(opts){exports._extend(ctx,opts)}if(isUndefined(ctx.showHidden))ctx.showHidden=false;if(isUndefined(ctx.depth))ctx.depth=2;if(isUndefined(ctx.colors))ctx.colors=false;if(isUndefined(ctx.customInspect))ctx.customInspect=true;if(ctx.colors)ctx.stylize=stylizeWithColor;return formatValue(ctx,obj,ctx.depth)}exports.inspect=inspect;inspect.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]};inspect.styles={special:"cyan",number:"yellow","boolean":"yellow",undefined:"grey","null":"bold",string:"green",date:"magenta",regexp:"red"};function stylizeWithColor(str,styleType){var style=inspect.styles[styleType];if(style){return"["+inspect.colors[style][0]+"m"+str+"["+inspect.colors[style][1]+"m"}else{return str}}function stylizeNoColor(str,styleType){return str}function arrayToHash(array){var hash={};array.forEach(function(val,idx){hash[val]=true});return hash}function formatValue(ctx,value,recurseTimes){if(ctx.customInspect&&value&&isFunction(value.inspect)&&value.inspect!==exports.inspect&&!(value.constructor&&value.constructor.prototype===value)){var ret=value.inspect(recurseTimes,ctx);if(!isString(ret)){ret=formatValue(ctx,ret,recurseTimes)}return ret}var primitive=formatPrimitive(ctx,value);if(primitive){return primitive}var keys=Object.keys(value);var visibleKeys=arrayToHash(keys);if(ctx.showHidden){keys=Object.getOwnPropertyNames(value)}if(isError(value)&&(keys.indexOf("message")>=0||keys.indexOf("description")>=0)){return formatError(value)}if(keys.length===0){if(isFunction(value)){var name=value.name?": "+value.name:"";return ctx.stylize("[Function"+name+"]","special")}if(isRegExp(value)){return ctx.stylize(RegExp.prototype.toString.call(value),"regexp")}if(isDate(value)){return ctx.stylize(Date.prototype.toString.call(value),"date")}if(isError(value)){return formatError(value)}}var base="",array=false,braces=["{","}"];if(isArray(value)){array=true;braces=["[","]"]}if(isFunction(value)){var n=value.name?": "+value.name:"";base=" [Function"+n+"]"}if(isRegExp(value)){base=" "+RegExp.prototype.toString.call(value)}if(isDate(value)){base=" "+Date.prototype.toUTCString.call(value)}if(isError(value)){base=" "+formatError(value)}if(keys.length===0&&(!array||value.length==0)){return braces[0]+base+braces[1]}if(recurseTimes<0){if(isRegExp(value)){return ctx.stylize(RegExp.prototype.toString.call(value),"regexp")}else{return ctx.stylize("[Object]","special")}}ctx.seen.push(value);var output;if(array){output=formatArray(ctx,value,recurseTimes,visibleKeys,keys)}else{output=keys.map(function(key){return formatProperty(ctx,value,recurseTimes,visibleKeys,key,array)})}ctx.seen.pop();return reduceToSingleString(output,base,braces)}function formatPrimitive(ctx,value){if(isUndefined(value))return ctx.stylize("undefined","undefined");if(isString(value)){var simple="'"+JSON.stringify(value).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return ctx.stylize(simple,"string")}if(isNumber(value))return ctx.stylize(""+value,"number");if(isBoolean(value))return ctx.stylize(""+value,"boolean");if(isNull(value))return ctx.stylize("null","null")}function formatError(value){return"["+Error.prototype.toString.call(value)+"]"}function formatArray(ctx,value,recurseTimes,visibleKeys,keys){var output=[];for(var i=0,l=value.length;i<l;++i){if(hasOwnProperty(value,String(i))){output.push(formatProperty(ctx,value,recurseTimes,visibleKeys,String(i),true))}else{output.push("")}}keys.forEach(function(key){if(!key.match(/^\d+$/)){output.push(formatProperty(ctx,value,recurseTimes,visibleKeys,key,true))}});return output}function formatProperty(ctx,value,recurseTimes,visibleKeys,key,array){var name,str,desc;desc=Object.getOwnPropertyDescriptor(value,key)||{value:value[key]};if(desc.get){if(desc.set){str=ctx.stylize("[Getter/Setter]","special")}else{str=ctx.stylize("[Getter]","special")}}else{if(desc.set){str=ctx.stylize("[Setter]","special")}}if(!hasOwnProperty(visibleKeys,key)){name="["+key+"]"}if(!str){if(ctx.seen.indexOf(desc.value)<0){if(isNull(recurseTimes)){str=formatValue(ctx,desc.value,null)}else{str=formatValue(ctx,desc.value,recurseTimes-1)}if(str.indexOf("\n")>-1){if(array){str=str.split("\n").map(function(line){return"  "+line}).join("\n").substr(2)}else{str="\n"+str.split("\n").map(function(line){return"   "+line}).join("\n")}}}else{str=ctx.stylize("[Circular]","special")}}if(isUndefined(name)){if(array&&key.match(/^\d+$/)){return str}name=JSON.stringify(""+key);if(name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)){name=name.substr(1,name.length-2);name=ctx.stylize(name,"name")}else{name=name.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'");name=ctx.stylize(name,"string")}}return name+": "+str}function reduceToSingleString(output,base,braces){var numLinesEst=0;var length=output.reduce(function(prev,cur){numLinesEst++;if(cur.indexOf("\n")>=0)numLinesEst++;return prev+cur.replace(/\u001b\[\d\d?m/g,"").length+1},0);if(length>60){return braces[0]+(base===""?"":base+"\n ")+" "+output.join(",\n  ")+" "+braces[1]}return braces[0]+base+" "+output.join(", ")+" "+braces[1]}function isArray(ar){return Array.isArray(ar)}exports.isArray=isArray;function isBoolean(arg){return typeof arg==="boolean"}exports.isBoolean=isBoolean;function isNull(arg){return arg===null}exports.isNull=isNull;function isNullOrUndefined(arg){return arg==null}exports.isNullOrUndefined=isNullOrUndefined;function isNumber(arg){return typeof arg==="number"}exports.isNumber=isNumber;function isString(arg){return typeof arg==="string"}exports.isString=isString;function isSymbol(arg){return typeof arg==="symbol"}exports.isSymbol=isSymbol;function isUndefined(arg){return arg===void 0}exports.isUndefined=isUndefined;function isRegExp(re){return isObject(re)&&objectToString(re)==="[object RegExp]"}exports.isRegExp=isRegExp;function isObject(arg){return typeof arg==="object"&&arg!==null}exports.isObject=isObject;function isDate(d){return isObject(d)&&objectToString(d)==="[object Date]"}exports.isDate=isDate;function isError(e){return isObject(e)&&(objectToString(e)==="[object Error]"||e instanceof Error)}exports.isError=isError;function isFunction(arg){return typeof arg==="function"}exports.isFunction=isFunction;function isPrimitive(arg){return arg===null||typeof arg==="boolean"||typeof arg==="number"||typeof arg==="string"||typeof arg==="symbol"||typeof arg==="undefined"}exports.isPrimitive=isPrimitive;exports.isBuffer=_dereq_("./support/isBuffer");function objectToString(o){return Object.prototype.toString.call(o)}function pad(n){return n<10?"0"+n.toString(10):n.toString(10)}var months=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function timestamp(){var d=new Date;var time=[pad(d.getHours()),pad(d.getMinutes()),pad(d.getSeconds())].join(":");return[d.getDate(),months[d.getMonth()],time].join(" ")}exports.log=function(){console.log("%s - %s",timestamp(),exports.format.apply(exports,arguments))};exports.inherits=_dereq_("inherits");exports._extend=function(origin,add){if(!add||!isObject(add))return origin;var keys=Object.keys(add);var i=keys.length;while(i--){origin[keys[i]]=add[keys[i]]}return origin};function hasOwnProperty(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop)}}).call(this,_dereq_("FWaASH"),typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./support/isBuffer":2,FWaASH:15,inherits:14}],4:[function(_dereq_,module,exports){},{}],5:[function(_dereq_,module,exports){var base64=_dereq_("base64-js");var ieee754=_dereq_("ieee754");exports.Buffer=Buffer;exports.SlowBuffer=Buffer;exports.INSPECT_MAX_BYTES=50;Buffer.poolSize=8192;Buffer._useTypedArrays=function(){try{var buf=new ArrayBuffer(0);var arr=new Uint8Array(buf);arr.foo=function(){return 42};return 42===arr.foo()&&typeof arr.subarray==="function"}catch(e){return false}}();function Buffer(subject,encoding,noZero){if(!(this instanceof Buffer))return new Buffer(subject,encoding,noZero);var type=typeof subject;if(encoding==="base64"&&type==="string"){subject=stringtrim(subject);while(subject.length%4!==0){subject=subject+"="}}var length;if(type==="number")length=coerce(subject);else if(type==="string")length=Buffer.byteLength(subject,encoding);else if(type==="object")length=coerce(subject.length);else throw new Error("First argument needs to be a number, array or string.");var buf;if(Buffer._useTypedArrays){buf=Buffer._augment(new Uint8Array(length))}else{buf=this;buf.length=length;buf._isBuffer=true}var i;if(Buffer._useTypedArrays&&typeof subject.byteLength==="number"){buf._set(subject)}else if(isArrayish(subject)){if(Buffer.isBuffer(subject)){for(i=0;i<length;i++)buf[i]=subject.readUInt8(i)}else{for(i=0;i<length;i++)buf[i]=(subject[i]%256+256)%256}}else if(type==="string"){buf.write(subject,0,encoding)}else if(type==="number"&&!Buffer._useTypedArrays&&!noZero){for(i=0;i<length;i++){buf[i]=0}}return buf}Buffer.isEncoding=function(encoding){switch(String(encoding).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"raw":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return true;default:return false}};Buffer.isBuffer=function(b){return!!(b!==null&&b!==undefined&&b._isBuffer)};Buffer.byteLength=function(str,encoding){var ret;str=str.toString();switch(encoding||"utf8"){case"hex":ret=str.length/2;break;case"utf8":case"utf-8":ret=utf8ToBytes(str).length;break;case"ascii":case"binary":case"raw":ret=str.length;break;case"base64":ret=base64ToBytes(str).length;break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":ret=str.length*2;break;default:throw new Error("Unknown encoding")}return ret};Buffer.concat=function(list,totalLength){assert(isArray(list),"Usage: Buffer.concat(list[, length])");if(list.length===0){return new Buffer(0)}else if(list.length===1){return list[0]}var i;if(totalLength===undefined){totalLength=0;for(i=0;i<list.length;i++){totalLength+=list[i].length}}var buf=new Buffer(totalLength);var pos=0;for(i=0;i<list.length;i++){var item=list[i];item.copy(buf,pos);pos+=item.length}return buf};Buffer.compare=function(a,b){assert(Buffer.isBuffer(a)&&Buffer.isBuffer(b),"Arguments must be Buffers");var x=a.length;var y=b.length;for(var i=0,len=Math.min(x,y);i<len&&a[i]===b[i];i++){}if(i!==len){x=a[i];y=b[i]}if(x<y){return-1}if(y<x){return 1}return 0};function hexWrite(buf,string,offset,length){offset=Number(offset)||0;var remaining=buf.length-offset;if(!length){length=remaining}else{length=Number(length);if(length>remaining){length=remaining}}var strLen=string.length;assert(strLen%2===0,"Invalid hex string");if(length>strLen/2){length=strLen/2}for(var i=0;i<length;i++){var byte=parseInt(string.substr(i*2,2),16);assert(!isNaN(byte),"Invalid hex string");buf[offset+i]=byte}return i}function utf8Write(buf,string,offset,length){var charsWritten=blitBuffer(utf8ToBytes(string),buf,offset,length);return charsWritten}function asciiWrite(buf,string,offset,length){var charsWritten=blitBuffer(asciiToBytes(string),buf,offset,length);return charsWritten}function binaryWrite(buf,string,offset,length){return asciiWrite(buf,string,offset,length)}function base64Write(buf,string,offset,length){var charsWritten=blitBuffer(base64ToBytes(string),buf,offset,length);return charsWritten}function utf16leWrite(buf,string,offset,length){var charsWritten=blitBuffer(utf16leToBytes(string),buf,offset,length);return charsWritten}Buffer.prototype.write=function(string,offset,length,encoding){if(isFinite(offset)){if(!isFinite(length)){encoding=length;length=undefined}}else{var swap=encoding;encoding=offset;offset=length;length=swap}offset=Number(offset)||0;var remaining=this.length-offset;if(!length){length=remaining}else{length=Number(length);if(length>remaining){length=remaining}}encoding=String(encoding||"utf8").toLowerCase();var ret;switch(encoding){case"hex":ret=hexWrite(this,string,offset,length);break;case"utf8":case"utf-8":ret=utf8Write(this,string,offset,length);break;case"ascii":ret=asciiWrite(this,string,offset,length);break;case"binary":ret=binaryWrite(this,string,offset,length);break;case"base64":ret=base64Write(this,string,offset,length);break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":ret=utf16leWrite(this,string,offset,length);break;default:throw new Error("Unknown encoding")}return ret};Buffer.prototype.toString=function(encoding,start,end){var self=this;encoding=String(encoding||"utf8").toLowerCase();start=Number(start)||0;end=end===undefined?self.length:Number(end);if(end===start)return"";var ret;switch(encoding){case"hex":ret=hexSlice(self,start,end);break;case"utf8":case"utf-8":ret=utf8Slice(self,start,end);break;case"ascii":ret=asciiSlice(self,start,end);break;case"binary":ret=binarySlice(self,start,end);break;case"base64":ret=base64Slice(self,start,end);break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":ret=utf16leSlice(self,start,end);break;default:throw new Error("Unknown encoding")}return ret};Buffer.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};Buffer.prototype.equals=function(b){assert(Buffer.isBuffer(b),"Argument must be a Buffer");return Buffer.compare(this,b)===0};Buffer.prototype.compare=function(b){assert(Buffer.isBuffer(b),"Argument must be a Buffer");return Buffer.compare(this,b)};Buffer.prototype.copy=function(target,target_start,start,end){var source=this;if(!start)start=0;if(!end&&end!==0)end=this.length;if(!target_start)target_start=0;if(end===start)return;if(target.length===0||source.length===0)return;assert(end>=start,"sourceEnd < sourceStart");assert(target_start>=0&&target_start<target.length,"targetStart out of bounds");assert(start>=0&&start<source.length,"sourceStart out of bounds");assert(end>=0&&end<=source.length,"sourceEnd out of bounds");if(end>this.length)end=this.length;if(target.length-target_start<end-start)end=target.length-target_start+start;var len=end-start;if(len<100||!Buffer._useTypedArrays){for(var i=0;i<len;i++){target[i+target_start]=this[i+start]}}else{target._set(this.subarray(start,start+len),target_start)}};function base64Slice(buf,start,end){if(start===0&&end===buf.length){return base64.fromByteArray(buf)}else{return base64.fromByteArray(buf.slice(start,end))}}function utf8Slice(buf,start,end){var res="";var tmp="";end=Math.min(buf.length,end);for(var i=start;i<end;i++){if(buf[i]<=127){res+=decodeUtf8Char(tmp)+String.fromCharCode(buf[i]);tmp=""}else{tmp+="%"+buf[i].toString(16)}}return res+decodeUtf8Char(tmp)}function asciiSlice(buf,start,end){var ret="";end=Math.min(buf.length,end);for(var i=start;i<end;i++){ret+=String.fromCharCode(buf[i])}return ret}function binarySlice(buf,start,end){return asciiSlice(buf,start,end)}function hexSlice(buf,start,end){var len=buf.length;if(!start||start<0)start=0;if(!end||end<0||end>len)end=len;var out="";for(var i=start;i<end;i++){out+=toHex(buf[i])}return out}function utf16leSlice(buf,start,end){var bytes=buf.slice(start,end);var res="";for(var i=0;i<bytes.length;i+=2){res+=String.fromCharCode(bytes[i]+bytes[i+1]*256)}return res}Buffer.prototype.slice=function(start,end){var len=this.length;start=clamp(start,len,0);end=clamp(end,len,len);if(Buffer._useTypedArrays){return Buffer._augment(this.subarray(start,end))}else{var sliceLen=end-start;var newBuf=new Buffer(sliceLen,undefined,true);for(var i=0;i<sliceLen;i++){newBuf[i]=this[i+start]}return newBuf}};Buffer.prototype.get=function(offset){console.log(".get() is deprecated. Access using array indexes instead.");return this.readUInt8(offset)};Buffer.prototype.set=function(v,offset){console.log(".set() is deprecated. Access using array indexes instead.");return this.writeUInt8(v,offset)};Buffer.prototype.readUInt8=function(offset,noAssert){if(!noAssert){assert(offset!==undefined&&offset!==null,"missing offset");assert(offset<this.length,"Trying to read beyond buffer length")}if(offset>=this.length)return;return this[offset]};function readUInt16(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+1<buf.length,"Trying to read beyond buffer length")}var len=buf.length;if(offset>=len)return;var val;if(littleEndian){val=buf[offset];if(offset+1<len)val|=buf[offset+1]<<8}else{val=buf[offset]<<8;if(offset+1<len)val|=buf[offset+1]}return val}Buffer.prototype.readUInt16LE=function(offset,noAssert){return readUInt16(this,offset,true,noAssert)};Buffer.prototype.readUInt16BE=function(offset,noAssert){return readUInt16(this,offset,false,noAssert)};function readUInt32(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+3<buf.length,"Trying to read beyond buffer length")}var len=buf.length;if(offset>=len)return;var val;if(littleEndian){if(offset+2<len)val=buf[offset+2]<<16;if(offset+1<len)val|=buf[offset+1]<<8;val|=buf[offset];if(offset+3<len)val=val+(buf[offset+3]<<24>>>0)}else{if(offset+1<len)val=buf[offset+1]<<16;if(offset+2<len)val|=buf[offset+2]<<8;if(offset+3<len)val|=buf[offset+3];val=val+(buf[offset]<<24>>>0)}return val}Buffer.prototype.readUInt32LE=function(offset,noAssert){return readUInt32(this,offset,true,noAssert)};Buffer.prototype.readUInt32BE=function(offset,noAssert){return readUInt32(this,offset,false,noAssert)};Buffer.prototype.readInt8=function(offset,noAssert){if(!noAssert){assert(offset!==undefined&&offset!==null,"missing offset");assert(offset<this.length,"Trying to read beyond buffer length")}if(offset>=this.length)return;var neg=this[offset]&128;if(neg)return(255-this[offset]+1)*-1;else return this[offset]};function readInt16(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+1<buf.length,"Trying to read beyond buffer length")}var len=buf.length;if(offset>=len)return;var val=readUInt16(buf,offset,littleEndian,true);var neg=val&32768;if(neg)return(65535-val+1)*-1;else return val}Buffer.prototype.readInt16LE=function(offset,noAssert){return readInt16(this,offset,true,noAssert)};Buffer.prototype.readInt16BE=function(offset,noAssert){return readInt16(this,offset,false,noAssert)};function readInt32(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+3<buf.length,"Trying to read beyond buffer length")}var len=buf.length;if(offset>=len)return;var val=readUInt32(buf,offset,littleEndian,true);var neg=val&2147483648;if(neg)return(4294967295-val+1)*-1;else return val}Buffer.prototype.readInt32LE=function(offset,noAssert){return readInt32(this,offset,true,noAssert)};Buffer.prototype.readInt32BE=function(offset,noAssert){return readInt32(this,offset,false,noAssert)};function readFloat(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset+3<buf.length,"Trying to read beyond buffer length")}return ieee754.read(buf,offset,littleEndian,23,4)}Buffer.prototype.readFloatLE=function(offset,noAssert){return readFloat(this,offset,true,noAssert)};Buffer.prototype.readFloatBE=function(offset,noAssert){return readFloat(this,offset,false,noAssert)};function readDouble(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset+7<buf.length,"Trying to read beyond buffer length")}return ieee754.read(buf,offset,littleEndian,52,8)}Buffer.prototype.readDoubleLE=function(offset,noAssert){return readDouble(this,offset,true,noAssert)};Buffer.prototype.readDoubleBE=function(offset,noAssert){return readDouble(this,offset,false,noAssert)};Buffer.prototype.writeUInt8=function(value,offset,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset<this.length,"trying to write beyond buffer length");verifuint(value,255)}if(offset>=this.length)return;this[offset]=value;return offset+1};function writeUInt16(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+1<buf.length,"trying to write beyond buffer length");verifuint(value,65535)}var len=buf.length;if(offset>=len)return;for(var i=0,j=Math.min(len-offset,2);i<j;i++){buf[offset+i]=(value&255<<8*(littleEndian?i:1-i))>>>(littleEndian?i:1-i)*8}return offset+2}Buffer.prototype.writeUInt16LE=function(value,offset,noAssert){return writeUInt16(this,value,offset,true,noAssert)};Buffer.prototype.writeUInt16BE=function(value,offset,noAssert){return writeUInt16(this,value,offset,false,noAssert)};function writeUInt32(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+3<buf.length,"trying to write beyond buffer length");verifuint(value,4294967295)}var len=buf.length;if(offset>=len)return;for(var i=0,j=Math.min(len-offset,4);i<j;i++){buf[offset+i]=value>>>(littleEndian?i:3-i)*8&255}return offset+4}Buffer.prototype.writeUInt32LE=function(value,offset,noAssert){return writeUInt32(this,value,offset,true,noAssert)};Buffer.prototype.writeUInt32BE=function(value,offset,noAssert){return writeUInt32(this,value,offset,false,noAssert)};Buffer.prototype.writeInt8=function(value,offset,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset<this.length,"Trying to write beyond buffer length");verifsint(value,127,-128)}if(offset>=this.length)return;if(value>=0)this.writeUInt8(value,offset,noAssert);else this.writeUInt8(255+value+1,offset,noAssert);return offset+1};function writeInt16(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+1<buf.length,"Trying to write beyond buffer length");verifsint(value,32767,-32768)}var len=buf.length;if(offset>=len)return;if(value>=0)writeUInt16(buf,value,offset,littleEndian,noAssert);else writeUInt16(buf,65535+value+1,offset,littleEndian,noAssert);return offset+2}Buffer.prototype.writeInt16LE=function(value,offset,noAssert){return writeInt16(this,value,offset,true,noAssert)};Buffer.prototype.writeInt16BE=function(value,offset,noAssert){return writeInt16(this,value,offset,false,noAssert)};function writeInt32(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+3<buf.length,"Trying to write beyond buffer length");verifsint(value,2147483647,-2147483648)}var len=buf.length;if(offset>=len)return;if(value>=0)writeUInt32(buf,value,offset,littleEndian,noAssert);else writeUInt32(buf,4294967295+value+1,offset,littleEndian,noAssert);return offset+4}Buffer.prototype.writeInt32LE=function(value,offset,noAssert){return writeInt32(this,value,offset,true,noAssert)};Buffer.prototype.writeInt32BE=function(value,offset,noAssert){return writeInt32(this,value,offset,false,noAssert)};function writeFloat(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+3<buf.length,"Trying to write beyond buffer length");verifIEEE754(value,3.4028234663852886e38,-3.4028234663852886e38)}var len=buf.length;if(offset>=len)return;ieee754.write(buf,value,offset,littleEndian,23,4);return offset+4
}Buffer.prototype.writeFloatLE=function(value,offset,noAssert){return writeFloat(this,value,offset,true,noAssert)};Buffer.prototype.writeFloatBE=function(value,offset,noAssert){return writeFloat(this,value,offset,false,noAssert)};function writeDouble(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+7<buf.length,"Trying to write beyond buffer length");verifIEEE754(value,1.7976931348623157e308,-1.7976931348623157e308)}var len=buf.length;if(offset>=len)return;ieee754.write(buf,value,offset,littleEndian,52,8);return offset+8}Buffer.prototype.writeDoubleLE=function(value,offset,noAssert){return writeDouble(this,value,offset,true,noAssert)};Buffer.prototype.writeDoubleBE=function(value,offset,noAssert){return writeDouble(this,value,offset,false,noAssert)};Buffer.prototype.fill=function(value,start,end){if(!value)value=0;if(!start)start=0;if(!end)end=this.length;assert(end>=start,"end < start");if(end===start)return;if(this.length===0)return;assert(start>=0&&start<this.length,"start out of bounds");assert(end>=0&&end<=this.length,"end out of bounds");var i;if(typeof value==="number"){for(i=start;i<end;i++){this[i]=value}}else{var bytes=utf8ToBytes(value.toString());var len=bytes.length;for(i=start;i<end;i++){this[i]=bytes[i%len]}}return this};Buffer.prototype.inspect=function(){var out=[];var len=this.length;for(var i=0;i<len;i++){out[i]=toHex(this[i]);if(i===exports.INSPECT_MAX_BYTES){out[i+1]="...";break}}return"<Buffer "+out.join(" ")+">"};Buffer.prototype.toArrayBuffer=function(){if(typeof Uint8Array!=="undefined"){if(Buffer._useTypedArrays){return new Buffer(this).buffer}else{var buf=new Uint8Array(this.length);for(var i=0,len=buf.length;i<len;i+=1){buf[i]=this[i]}return buf.buffer}}else{throw new Error("Buffer.toArrayBuffer not supported in this browser")}};var BP=Buffer.prototype;Buffer._augment=function(arr){arr._isBuffer=true;arr._get=arr.get;arr._set=arr.set;arr.get=BP.get;arr.set=BP.set;arr.write=BP.write;arr.toString=BP.toString;arr.toLocaleString=BP.toString;arr.toJSON=BP.toJSON;arr.equals=BP.equals;arr.compare=BP.compare;arr.copy=BP.copy;arr.slice=BP.slice;arr.readUInt8=BP.readUInt8;arr.readUInt16LE=BP.readUInt16LE;arr.readUInt16BE=BP.readUInt16BE;arr.readUInt32LE=BP.readUInt32LE;arr.readUInt32BE=BP.readUInt32BE;arr.readInt8=BP.readInt8;arr.readInt16LE=BP.readInt16LE;arr.readInt16BE=BP.readInt16BE;arr.readInt32LE=BP.readInt32LE;arr.readInt32BE=BP.readInt32BE;arr.readFloatLE=BP.readFloatLE;arr.readFloatBE=BP.readFloatBE;arr.readDoubleLE=BP.readDoubleLE;arr.readDoubleBE=BP.readDoubleBE;arr.writeUInt8=BP.writeUInt8;arr.writeUInt16LE=BP.writeUInt16LE;arr.writeUInt16BE=BP.writeUInt16BE;arr.writeUInt32LE=BP.writeUInt32LE;arr.writeUInt32BE=BP.writeUInt32BE;arr.writeInt8=BP.writeInt8;arr.writeInt16LE=BP.writeInt16LE;arr.writeInt16BE=BP.writeInt16BE;arr.writeInt32LE=BP.writeInt32LE;arr.writeInt32BE=BP.writeInt32BE;arr.writeFloatLE=BP.writeFloatLE;arr.writeFloatBE=BP.writeFloatBE;arr.writeDoubleLE=BP.writeDoubleLE;arr.writeDoubleBE=BP.writeDoubleBE;arr.fill=BP.fill;arr.inspect=BP.inspect;arr.toArrayBuffer=BP.toArrayBuffer;return arr};function stringtrim(str){if(str.trim)return str.trim();return str.replace(/^\s+|\s+$/g,"")}function clamp(index,len,defaultValue){if(typeof index!=="number")return defaultValue;index=~~index;if(index>=len)return len;if(index>=0)return index;index+=len;if(index>=0)return index;return 0}function coerce(length){length=~~Math.ceil(+length);return length<0?0:length}function isArray(subject){return(Array.isArray||function(subject){return Object.prototype.toString.call(subject)==="[object Array]"})(subject)}function isArrayish(subject){return isArray(subject)||Buffer.isBuffer(subject)||subject&&typeof subject==="object"&&typeof subject.length==="number"}function toHex(n){if(n<16)return"0"+n.toString(16);return n.toString(16)}function utf8ToBytes(str){var byteArray=[];for(var i=0;i<str.length;i++){var b=str.charCodeAt(i);if(b<=127){byteArray.push(b)}else{var start=i;if(b>=55296&&b<=57343)i++;var h=encodeURIComponent(str.slice(start,i+1)).substr(1).split("%");for(var j=0;j<h.length;j++){byteArray.push(parseInt(h[j],16))}}}return byteArray}function asciiToBytes(str){var byteArray=[];for(var i=0;i<str.length;i++){byteArray.push(str.charCodeAt(i)&255)}return byteArray}function utf16leToBytes(str){var c,hi,lo;var byteArray=[];for(var i=0;i<str.length;i++){c=str.charCodeAt(i);hi=c>>8;lo=c%256;byteArray.push(lo);byteArray.push(hi)}return byteArray}function base64ToBytes(str){return base64.toByteArray(str)}function blitBuffer(src,dst,offset,length){for(var i=0;i<length;i++){if(i+offset>=dst.length||i>=src.length)break;dst[i+offset]=src[i]}return i}function decodeUtf8Char(str){try{return decodeURIComponent(str)}catch(err){return String.fromCharCode(65533)}}function verifuint(value,max){assert(typeof value==="number","cannot write a non-number as a number");assert(value>=0,"specified a negative value for writing an unsigned value");assert(value<=max,"value is larger than maximum value for type");assert(Math.floor(value)===value,"value has a fractional component")}function verifsint(value,max,min){assert(typeof value==="number","cannot write a non-number as a number");assert(value<=max,"value larger than maximum allowed value");assert(value>=min,"value smaller than minimum allowed value");assert(Math.floor(value)===value,"value has a fractional component")}function verifIEEE754(value,max,min){assert(typeof value==="number","cannot write a non-number as a number");assert(value<=max,"value larger than maximum allowed value");assert(value>=min,"value smaller than minimum allowed value")}function assert(test,message){if(!test)throw new Error(message||"Failed assertion")}},{"base64-js":6,ieee754:7}],6:[function(_dereq_,module,exports){var lookup="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";(function(exports){"use strict";var Arr=typeof Uint8Array!=="undefined"?Uint8Array:Array;var ZERO="0".charCodeAt(0);var PLUS="+".charCodeAt(0);var SLASH="/".charCodeAt(0);var NUMBER="0".charCodeAt(0);var LOWER="a".charCodeAt(0);var UPPER="A".charCodeAt(0);function decode(elt){var code=elt.charCodeAt(0);if(code===PLUS)return 62;if(code===SLASH)return 63;if(code<NUMBER)return-1;if(code<NUMBER+10)return code-NUMBER+26+26;if(code<UPPER+26)return code-UPPER;if(code<LOWER+26)return code-LOWER+26}function b64ToByteArray(b64){var i,j,l,tmp,placeHolders,arr;if(b64.length%4>0){throw new Error("Invalid string. Length must be a multiple of 4")}var len=b64.length;placeHolders="="===b64.charAt(len-2)?2:"="===b64.charAt(len-1)?1:0;arr=new Arr(b64.length*3/4-placeHolders);l=placeHolders>0?b64.length-4:b64.length;var L=0;function push(v){arr[L++]=v}for(i=0,j=0;i<l;i+=4,j+=3){tmp=decode(b64.charAt(i))<<18|decode(b64.charAt(i+1))<<12|decode(b64.charAt(i+2))<<6|decode(b64.charAt(i+3));push((tmp&16711680)>>16);push((tmp&65280)>>8);push(tmp&255)}if(placeHolders===2){tmp=decode(b64.charAt(i))<<2|decode(b64.charAt(i+1))>>4;push(tmp&255)}else if(placeHolders===1){tmp=decode(b64.charAt(i))<<10|decode(b64.charAt(i+1))<<4|decode(b64.charAt(i+2))>>2;push(tmp>>8&255);push(tmp&255)}return arr}function uint8ToBase64(uint8){var i,extraBytes=uint8.length%3,output="",temp,length;function encode(num){return lookup.charAt(num)}function tripletToBase64(num){return encode(num>>18&63)+encode(num>>12&63)+encode(num>>6&63)+encode(num&63)}for(i=0,length=uint8.length-extraBytes;i<length;i+=3){temp=(uint8[i]<<16)+(uint8[i+1]<<8)+uint8[i+2];output+=tripletToBase64(temp)}switch(extraBytes){case 1:temp=uint8[uint8.length-1];output+=encode(temp>>2);output+=encode(temp<<4&63);output+="==";break;case 2:temp=(uint8[uint8.length-2]<<8)+uint8[uint8.length-1];output+=encode(temp>>10);output+=encode(temp>>4&63);output+=encode(temp<<2&63);output+="=";break}return output}module.exports.toByteArray=b64ToByteArray;module.exports.fromByteArray=uint8ToBase64})()},{}],7:[function(_dereq_,module,exports){exports.read=function(buffer,offset,isLE,mLen,nBytes){var e,m,eLen=nBytes*8-mLen-1,eMax=(1<<eLen)-1,eBias=eMax>>1,nBits=-7,i=isLE?nBytes-1:0,d=isLE?-1:1,s=buffer[offset+i];i+=d;e=s&(1<<-nBits)-1;s>>=-nBits;nBits+=eLen;for(;nBits>0;e=e*256+buffer[offset+i],i+=d,nBits-=8);m=e&(1<<-nBits)-1;e>>=-nBits;nBits+=mLen;for(;nBits>0;m=m*256+buffer[offset+i],i+=d,nBits-=8);if(e===0){e=1-eBias}else if(e===eMax){return m?NaN:(s?-1:1)*Infinity}else{m=m+Math.pow(2,mLen);e=e-eBias}return(s?-1:1)*m*Math.pow(2,e-mLen)};exports.write=function(buffer,value,offset,isLE,mLen,nBytes){var e,m,c,eLen=nBytes*8-mLen-1,eMax=(1<<eLen)-1,eBias=eMax>>1,rt=mLen===23?Math.pow(2,-24)-Math.pow(2,-77):0,i=isLE?0:nBytes-1,d=isLE?1:-1,s=value<0||value===0&&1/value<0?1:0;value=Math.abs(value);if(isNaN(value)||value===Infinity){m=isNaN(value)?1:0;e=eMax}else{e=Math.floor(Math.log(value)/Math.LN2);if(value*(c=Math.pow(2,-e))<1){e--;c*=2}if(e+eBias>=1){value+=rt/c}else{value+=rt*Math.pow(2,1-eBias)}if(value*c>=2){e++;c/=2}if(e+eBias>=eMax){m=0;e=eMax}else if(e+eBias>=1){m=(value*c-1)*Math.pow(2,mLen);e=e+eBias}else{m=value*Math.pow(2,eBias-1)*Math.pow(2,mLen);e=0}}for(;mLen>=8;buffer[offset+i]=m&255,i+=d,m/=256,mLen-=8);e=e<<mLen|m;eLen+=mLen;for(;eLen>0;buffer[offset+i]=e&255,i+=d,e/=256,eLen-=8);buffer[offset+i-d]|=s*128}},{}],8:[function(_dereq_,module,exports){var Buffer=_dereq_("buffer").Buffer;var intSize=4;var zeroBuffer=new Buffer(intSize);zeroBuffer.fill(0);var chrsz=8;function toArray(buf,bigEndian){if(buf.length%intSize!==0){var len=buf.length+(intSize-buf.length%intSize);buf=Buffer.concat([buf,zeroBuffer],len)}var arr=[];var fn=bigEndian?buf.readInt32BE:buf.readInt32LE;for(var i=0;i<buf.length;i+=intSize){arr.push(fn.call(buf,i))}return arr}function toBuffer(arr,size,bigEndian){var buf=new Buffer(size);var fn=bigEndian?buf.writeInt32BE:buf.writeInt32LE;for(var i=0;i<arr.length;i++){fn.call(buf,arr[i],i*4,true)}return buf}function hash(buf,fn,hashSize,bigEndian){if(!Buffer.isBuffer(buf))buf=new Buffer(buf);var arr=fn(toArray(buf,bigEndian),buf.length*chrsz);return toBuffer(arr,hashSize,bigEndian)}module.exports={hash:hash}},{buffer:5}],9:[function(_dereq_,module,exports){var Buffer=_dereq_("buffer").Buffer;var sha=_dereq_("./sha");var sha256=_dereq_("./sha256");var rng=_dereq_("./rng");var md5=_dereq_("./md5");var algorithms={sha1:sha,sha256:sha256,md5:md5};var blocksize=64;var zeroBuffer=new Buffer(blocksize);zeroBuffer.fill(0);function hmac(fn,key,data){if(!Buffer.isBuffer(key))key=new Buffer(key);if(!Buffer.isBuffer(data))data=new Buffer(data);if(key.length>blocksize){key=fn(key)}else if(key.length<blocksize){key=Buffer.concat([key,zeroBuffer],blocksize)}var ipad=new Buffer(blocksize),opad=new Buffer(blocksize);for(var i=0;i<blocksize;i++){ipad[i]=key[i]^54;opad[i]=key[i]^92}var hash=fn(Buffer.concat([ipad,data]));return fn(Buffer.concat([opad,hash]))}function hash(alg,key){alg=alg||"sha1";var fn=algorithms[alg];var bufs=[];var length=0;if(!fn)error("algorithm:",alg,"is not yet supported");return{update:function(data){if(!Buffer.isBuffer(data))data=new Buffer(data);bufs.push(data);length+=data.length;return this},digest:function(enc){var buf=Buffer.concat(bufs);var r=key?hmac(fn,key,buf):fn(buf);bufs=null;return enc?r.toString(enc):r}}}function error(){var m=[].slice.call(arguments).join(" ");throw new Error([m,"we accept pull requests","http://github.com/dominictarr/crypto-browserify"].join("\n"))}exports.createHash=function(alg){return hash(alg)};exports.createHmac=function(alg,key){return hash(alg,key)};exports.randomBytes=function(size,callback){if(callback&&callback.call){try{callback.call(this,undefined,new Buffer(rng(size)))}catch(err){callback(err)}}else{return new Buffer(rng(size))}};function each(a,f){for(var i in a)f(a[i],i)}each(["createCredentials","createCipher","createCipheriv","createDecipher","createDecipheriv","createSign","createVerify","createDiffieHellman","pbkdf2"],function(name){exports[name]=function(){error("sorry,",name,"is not implemented yet")}})},{"./md5":10,"./rng":11,"./sha":12,"./sha256":13,buffer:5}],10:[function(_dereq_,module,exports){var helpers=_dereq_("./helpers");function md5_vm_test(){return hex_md5("abc")=="900150983cd24fb0d6963f7d28e17f72"}function core_md5(x,len){x[len>>5]|=128<<len%32;x[(len+64>>>9<<4)+14]=len;var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;a=md5_ff(a,b,c,d,x[i+0],7,-680876936);d=md5_ff(d,a,b,c,x[i+1],12,-389564586);c=md5_ff(c,d,a,b,x[i+2],17,606105819);b=md5_ff(b,c,d,a,x[i+3],22,-1044525330);a=md5_ff(a,b,c,d,x[i+4],7,-176418897);d=md5_ff(d,a,b,c,x[i+5],12,1200080426);c=md5_ff(c,d,a,b,x[i+6],17,-1473231341);b=md5_ff(b,c,d,a,x[i+7],22,-45705983);a=md5_ff(a,b,c,d,x[i+8],7,1770035416);d=md5_ff(d,a,b,c,x[i+9],12,-1958414417);c=md5_ff(c,d,a,b,x[i+10],17,-42063);b=md5_ff(b,c,d,a,x[i+11],22,-1990404162);a=md5_ff(a,b,c,d,x[i+12],7,1804603682);d=md5_ff(d,a,b,c,x[i+13],12,-40341101);c=md5_ff(c,d,a,b,x[i+14],17,-1502002290);b=md5_ff(b,c,d,a,x[i+15],22,1236535329);a=md5_gg(a,b,c,d,x[i+1],5,-165796510);d=md5_gg(d,a,b,c,x[i+6],9,-1069501632);c=md5_gg(c,d,a,b,x[i+11],14,643717713);b=md5_gg(b,c,d,a,x[i+0],20,-373897302);a=md5_gg(a,b,c,d,x[i+5],5,-701558691);d=md5_gg(d,a,b,c,x[i+10],9,38016083);c=md5_gg(c,d,a,b,x[i+15],14,-660478335);b=md5_gg(b,c,d,a,x[i+4],20,-405537848);a=md5_gg(a,b,c,d,x[i+9],5,568446438);d=md5_gg(d,a,b,c,x[i+14],9,-1019803690);c=md5_gg(c,d,a,b,x[i+3],14,-187363961);b=md5_gg(b,c,d,a,x[i+8],20,1163531501);a=md5_gg(a,b,c,d,x[i+13],5,-1444681467);d=md5_gg(d,a,b,c,x[i+2],9,-51403784);c=md5_gg(c,d,a,b,x[i+7],14,1735328473);b=md5_gg(b,c,d,a,x[i+12],20,-1926607734);a=md5_hh(a,b,c,d,x[i+5],4,-378558);d=md5_hh(d,a,b,c,x[i+8],11,-2022574463);c=md5_hh(c,d,a,b,x[i+11],16,1839030562);b=md5_hh(b,c,d,a,x[i+14],23,-35309556);a=md5_hh(a,b,c,d,x[i+1],4,-1530992060);d=md5_hh(d,a,b,c,x[i+4],11,1272893353);c=md5_hh(c,d,a,b,x[i+7],16,-155497632);b=md5_hh(b,c,d,a,x[i+10],23,-1094730640);a=md5_hh(a,b,c,d,x[i+13],4,681279174);d=md5_hh(d,a,b,c,x[i+0],11,-358537222);c=md5_hh(c,d,a,b,x[i+3],16,-722521979);b=md5_hh(b,c,d,a,x[i+6],23,76029189);a=md5_hh(a,b,c,d,x[i+9],4,-640364487);d=md5_hh(d,a,b,c,x[i+12],11,-421815835);c=md5_hh(c,d,a,b,x[i+15],16,530742520);b=md5_hh(b,c,d,a,x[i+2],23,-995338651);a=md5_ii(a,b,c,d,x[i+0],6,-198630844);d=md5_ii(d,a,b,c,x[i+7],10,1126891415);c=md5_ii(c,d,a,b,x[i+14],15,-1416354905);b=md5_ii(b,c,d,a,x[i+5],21,-57434055);a=md5_ii(a,b,c,d,x[i+12],6,1700485571);d=md5_ii(d,a,b,c,x[i+3],10,-1894986606);c=md5_ii(c,d,a,b,x[i+10],15,-1051523);b=md5_ii(b,c,d,a,x[i+1],21,-2054922799);a=md5_ii(a,b,c,d,x[i+8],6,1873313359);d=md5_ii(d,a,b,c,x[i+15],10,-30611744);c=md5_ii(c,d,a,b,x[i+6],15,-1560198380);b=md5_ii(b,c,d,a,x[i+13],21,1309151649);a=md5_ii(a,b,c,d,x[i+4],6,-145523070);d=md5_ii(d,a,b,c,x[i+11],10,-1120210379);c=md5_ii(c,d,a,b,x[i+2],15,718787259);b=md5_ii(b,c,d,a,x[i+9],21,-343485551);a=safe_add(a,olda);b=safe_add(b,oldb);c=safe_add(c,oldc);d=safe_add(d,oldd)}return Array(a,b,c,d)}function md5_cmn(q,a,b,x,s,t){return safe_add(bit_rol(safe_add(safe_add(a,q),safe_add(x,t)),s),b)}function md5_ff(a,b,c,d,x,s,t){return md5_cmn(b&c|~b&d,a,b,x,s,t)}function md5_gg(a,b,c,d,x,s,t){return md5_cmn(b&d|c&~d,a,b,x,s,t)}function md5_hh(a,b,c,d,x,s,t){return md5_cmn(b^c^d,a,b,x,s,t)}function md5_ii(a,b,c,d,x,s,t){return md5_cmn(c^(b|~d),a,b,x,s,t)}function safe_add(x,y){var lsw=(x&65535)+(y&65535);var msw=(x>>16)+(y>>16)+(lsw>>16);return msw<<16|lsw&65535}function bit_rol(num,cnt){return num<<cnt|num>>>32-cnt}module.exports=function md5(buf){return helpers.hash(buf,core_md5,16)}},{"./helpers":8}],11:[function(_dereq_,module,exports){(function(){var _global=this;var mathRNG,whatwgRNG;mathRNG=function(size){var bytes=new Array(size);var r;for(var i=0,r;i<size;i++){if((i&3)==0)r=Math.random()*4294967296;bytes[i]=r>>>((i&3)<<3)&255}return bytes};if(_global.crypto&&crypto.getRandomValues){whatwgRNG=function(size){var bytes=new Uint8Array(size);crypto.getRandomValues(bytes);return bytes}}module.exports=whatwgRNG||mathRNG})()},{}],12:[function(_dereq_,module,exports){var helpers=_dereq_("./helpers");function core_sha1(x,len){x[len>>5]|=128<<24-len%32;x[(len+64>>9<<4)+15]=len;var w=Array(80);var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;var e=-1009589776;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;var olde=e;for(var j=0;j<80;j++){if(j<16)w[j]=x[i+j];else w[j]=rol(w[j-3]^w[j-8]^w[j-14]^w[j-16],1);var t=safe_add(safe_add(rol(a,5),sha1_ft(j,b,c,d)),safe_add(safe_add(e,w[j]),sha1_kt(j)));e=d;d=c;c=rol(b,30);b=a;a=t}a=safe_add(a,olda);b=safe_add(b,oldb);c=safe_add(c,oldc);d=safe_add(d,oldd);e=safe_add(e,olde)}return Array(a,b,c,d,e)}function sha1_ft(t,b,c,d){if(t<20)return b&c|~b&d;if(t<40)return b^c^d;if(t<60)return b&c|b&d|c&d;return b^c^d}function sha1_kt(t){return t<20?1518500249:t<40?1859775393:t<60?-1894007588:-899497514}function safe_add(x,y){var lsw=(x&65535)+(y&65535);var msw=(x>>16)+(y>>16)+(lsw>>16);return msw<<16|lsw&65535}function rol(num,cnt){return num<<cnt|num>>>32-cnt}module.exports=function sha1(buf){return helpers.hash(buf,core_sha1,20,true)}},{"./helpers":8}],13:[function(_dereq_,module,exports){var helpers=_dereq_("./helpers");var safe_add=function(x,y){var lsw=(x&65535)+(y&65535);var msw=(x>>16)+(y>>16)+(lsw>>16);return msw<<16|lsw&65535};var S=function(X,n){return X>>>n|X<<32-n};var R=function(X,n){return X>>>n};var Ch=function(x,y,z){return x&y^~x&z};var Maj=function(x,y,z){return x&y^x&z^y&z};var Sigma0256=function(x){return S(x,2)^S(x,13)^S(x,22)};var Sigma1256=function(x){return S(x,6)^S(x,11)^S(x,25)};var Gamma0256=function(x){return S(x,7)^S(x,18)^R(x,3)};var Gamma1256=function(x){return S(x,17)^S(x,19)^R(x,10)};var core_sha256=function(m,l){var K=new Array(1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298);var HASH=new Array(1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225);var W=new Array(64);var a,b,c,d,e,f,g,h,i,j;var T1,T2;m[l>>5]|=128<<24-l%32;m[(l+64>>9<<4)+15]=l;for(var i=0;i<m.length;i+=16){a=HASH[0];b=HASH[1];c=HASH[2];d=HASH[3];e=HASH[4];f=HASH[5];g=HASH[6];h=HASH[7];for(var j=0;j<64;j++){if(j<16){W[j]=m[j+i]}else{W[j]=safe_add(safe_add(safe_add(Gamma1256(W[j-2]),W[j-7]),Gamma0256(W[j-15])),W[j-16])}T1=safe_add(safe_add(safe_add(safe_add(h,Sigma1256(e)),Ch(e,f,g)),K[j]),W[j]);T2=safe_add(Sigma0256(a),Maj(a,b,c));h=g;g=f;f=e;e=safe_add(d,T1);d=c;c=b;b=a;a=safe_add(T1,T2)}HASH[0]=safe_add(a,HASH[0]);HASH[1]=safe_add(b,HASH[1]);HASH[2]=safe_add(c,HASH[2]);HASH[3]=safe_add(d,HASH[3]);HASH[4]=safe_add(e,HASH[4]);HASH[5]=safe_add(f,HASH[5]);HASH[6]=safe_add(g,HASH[6]);HASH[7]=safe_add(h,HASH[7])}return HASH};module.exports=function sha256(buf){return helpers.hash(buf,core_sha256,32,true)}},{"./helpers":8}],14:[function(_dereq_,module,exports){if(typeof Object.create==="function"){module.exports=function inherits(ctor,superCtor){ctor.super_=superCtor;ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:false,writable:true,configurable:true}})}}else{module.exports=function inherits(ctor,superCtor){ctor.super_=superCtor;var TempCtor=function(){};TempCtor.prototype=superCtor.prototype;ctor.prototype=new TempCtor;ctor.prototype.constructor=ctor}}},{}],15:[function(_dereq_,module,exports){var process=module.exports={};process.nextTick=function(){var canSetImmediate=typeof window!=="undefined"&&window.setImmediate;var canPost=typeof window!=="undefined"&&window.postMessage&&window.addEventListener;if(canSetImmediate){return function(f){return window.setImmediate(f)}}if(canPost){var queue=[];window.addEventListener("message",function(ev){var source=ev.source;if((source===window||source===null)&&ev.data==="process-tick"){ev.stopPropagation();if(queue.length>0){var fn=queue.shift();fn()}}},true);return function nextTick(fn){queue.push(fn);window.postMessage("process-tick","*")}}return function nextTick(fn){setTimeout(fn,0)}}();process.title="browser";process.browser=true;process.env={};process.argv=[];function noop(){}process.on=noop;process.addListener=noop;process.once=noop;process.off=noop;process.removeListener=noop;process.removeAllListeners=noop;process.emit=noop;process.binding=function(name){throw new Error("process.binding is not supported")};process.cwd=function(){return"/"};process.chdir=function(dir){throw new Error("process.chdir is not supported")}},{}],16:[function(_dereq_,module,exports){module.exports=_dereq_(2)},{}],17:[function(_dereq_,module,exports){module.exports=_dereq_(3)},{"./support/isBuffer":16,FWaASH:15,inherits:14}],18:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./evpkdf"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var BlockCipher=C_lib.BlockCipher;var C_algo=C.algo;var SBOX=[];var INV_SBOX=[];var SUB_MIX_0=[];var SUB_MIX_1=[];var SUB_MIX_2=[];var SUB_MIX_3=[];var INV_SUB_MIX_0=[];var INV_SUB_MIX_1=[];var INV_SUB_MIX_2=[];var INV_SUB_MIX_3=[];(function(){var d=[];for(var i=0;i<256;i++){if(i<128){d[i]=i<<1}else{d[i]=i<<1^283}}var x=0;var xi=0;for(var i=0;i<256;i++){var sx=xi^xi<<1^xi<<2^xi<<3^xi<<4;sx=sx>>>8^sx&255^99;SBOX[x]=sx;INV_SBOX[sx]=x;var x2=d[x];var x4=d[x2];var x8=d[x4];var t=d[sx]*257^sx*16843008;SUB_MIX_0[x]=t<<24|t>>>8;SUB_MIX_1[x]=t<<16|t>>>16;SUB_MIX_2[x]=t<<8|t>>>24;SUB_MIX_3[x]=t;var t=x8*16843009^x4*65537^x2*257^x*16843008;INV_SUB_MIX_0[sx]=t<<24|t>>>8;INV_SUB_MIX_1[sx]=t<<16|t>>>16;INV_SUB_MIX_2[sx]=t<<8|t>>>24;INV_SUB_MIX_3[sx]=t;if(!x){x=xi=1}else{x=x2^d[d[d[x8^x2]]];xi^=d[d[xi]]}}})();var RCON=[0,1,2,4,8,16,32,64,128,27,54];var AES=C_algo.AES=BlockCipher.extend({_doReset:function(){var key=this._key;var keyWords=key.words;var keySize=key.sigBytes/4;var nRounds=this._nRounds=keySize+6;var ksRows=(nRounds+1)*4;var keySchedule=this._keySchedule=[];for(var ksRow=0;ksRow<ksRows;ksRow++){if(ksRow<keySize){keySchedule[ksRow]=keyWords[ksRow]}else{var t=keySchedule[ksRow-1];if(!(ksRow%keySize)){t=t<<8|t>>>24;t=SBOX[t>>>24]<<24|SBOX[t>>>16&255]<<16|SBOX[t>>>8&255]<<8|SBOX[t&255];t^=RCON[ksRow/keySize|0]<<24}else if(keySize>6&&ksRow%keySize==4){t=SBOX[t>>>24]<<24|SBOX[t>>>16&255]<<16|SBOX[t>>>8&255]<<8|SBOX[t&255]}keySchedule[ksRow]=keySchedule[ksRow-keySize]^t}}var invKeySchedule=this._invKeySchedule=[];for(var invKsRow=0;invKsRow<ksRows;invKsRow++){var ksRow=ksRows-invKsRow;if(invKsRow%4){var t=keySchedule[ksRow]}else{var t=keySchedule[ksRow-4]}if(invKsRow<4||ksRow<=4){invKeySchedule[invKsRow]=t}else{invKeySchedule[invKsRow]=INV_SUB_MIX_0[SBOX[t>>>24]]^INV_SUB_MIX_1[SBOX[t>>>16&255]]^INV_SUB_MIX_2[SBOX[t>>>8&255]]^INV_SUB_MIX_3[SBOX[t&255]]}}},encryptBlock:function(M,offset){this._doCryptBlock(M,offset,this._keySchedule,SUB_MIX_0,SUB_MIX_1,SUB_MIX_2,SUB_MIX_3,SBOX)},decryptBlock:function(M,offset){var t=M[offset+1];M[offset+1]=M[offset+3];M[offset+3]=t;this._doCryptBlock(M,offset,this._invKeySchedule,INV_SUB_MIX_0,INV_SUB_MIX_1,INV_SUB_MIX_2,INV_SUB_MIX_3,INV_SBOX);var t=M[offset+1];M[offset+1]=M[offset+3];M[offset+3]=t},_doCryptBlock:function(M,offset,keySchedule,SUB_MIX_0,SUB_MIX_1,SUB_MIX_2,SUB_MIX_3,SBOX){var nRounds=this._nRounds;var s0=M[offset]^keySchedule[0];var s1=M[offset+1]^keySchedule[1];var s2=M[offset+2]^keySchedule[2];var s3=M[offset+3]^keySchedule[3];var ksRow=4;for(var round=1;round<nRounds;round++){var t0=SUB_MIX_0[s0>>>24]^SUB_MIX_1[s1>>>16&255]^SUB_MIX_2[s2>>>8&255]^SUB_MIX_3[s3&255]^keySchedule[ksRow++];var t1=SUB_MIX_0[s1>>>24]^SUB_MIX_1[s2>>>16&255]^SUB_MIX_2[s3>>>8&255]^SUB_MIX_3[s0&255]^keySchedule[ksRow++];var t2=SUB_MIX_0[s2>>>24]^SUB_MIX_1[s3>>>16&255]^SUB_MIX_2[s0>>>8&255]^SUB_MIX_3[s1&255]^keySchedule[ksRow++];var t3=SUB_MIX_0[s3>>>24]^SUB_MIX_1[s0>>>16&255]^SUB_MIX_2[s1>>>8&255]^SUB_MIX_3[s2&255]^keySchedule[ksRow++];s0=t0;s1=t1;s2=t2;s3=t3}var t0=(SBOX[s0>>>24]<<24|SBOX[s1>>>16&255]<<16|SBOX[s2>>>8&255]<<8|SBOX[s3&255])^keySchedule[ksRow++];var t1=(SBOX[s1>>>24]<<24|SBOX[s2>>>16&255]<<16|SBOX[s3>>>8&255]<<8|SBOX[s0&255])^keySchedule[ksRow++];var t2=(SBOX[s2>>>24]<<24|SBOX[s3>>>16&255]<<16|SBOX[s0>>>8&255]<<8|SBOX[s1&255])^keySchedule[ksRow++];var t3=(SBOX[s3>>>24]<<24|SBOX[s0>>>16&255]<<16|SBOX[s1>>>8&255]<<8|SBOX[s2&255])^keySchedule[ksRow++];M[offset]=t0;M[offset+1]=t1;M[offset+2]=t2;M[offset+3]=t3},keySize:256/32});C.AES=BlockCipher._createHelper(AES)})();return CryptoJS.AES})},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":29}],19:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.lib.Cipher||function(undefined){var C=CryptoJS;var C_lib=C.lib;var Base=C_lib.Base;var WordArray=C_lib.WordArray;var BufferedBlockAlgorithm=C_lib.BufferedBlockAlgorithm;var C_enc=C.enc;var Utf8=C_enc.Utf8;var Base64=C_enc.Base64;var C_algo=C.algo;var EvpKDF=C_algo.EvpKDF;var Cipher=C_lib.Cipher=BufferedBlockAlgorithm.extend({cfg:Base.extend(),createEncryptor:function(key,cfg){return this.create(this._ENC_XFORM_MODE,key,cfg)},createDecryptor:function(key,cfg){return this.create(this._DEC_XFORM_MODE,key,cfg)},init:function(xformMode,key,cfg){this.cfg=this.cfg.extend(cfg);this._xformMode=xformMode;this._key=key;this.reset()},reset:function(){BufferedBlockAlgorithm.reset.call(this);this._doReset()},process:function(dataUpdate){this._append(dataUpdate);return this._process()},finalize:function(dataUpdate){if(dataUpdate){this._append(dataUpdate)}var finalProcessedData=this._doFinalize();return finalProcessedData},keySize:128/32,ivSize:128/32,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(){function selectCipherStrategy(key){if(typeof key=="string"){return PasswordBasedCipher}else{return SerializableCipher}}return function(cipher){return{encrypt:function(message,key,cfg){return selectCipherStrategy(key).encrypt(cipher,message,key,cfg)},decrypt:function(ciphertext,key,cfg){return selectCipherStrategy(key).decrypt(cipher,ciphertext,key,cfg)}}}}()});var StreamCipher=C_lib.StreamCipher=Cipher.extend({_doFinalize:function(){var finalProcessedBlocks=this._process(!!"flush");return finalProcessedBlocks},blockSize:1});var C_mode=C.mode={};var BlockCipherMode=C_lib.BlockCipherMode=Base.extend({createEncryptor:function(cipher,iv){return this.Encryptor.create(cipher,iv)},createDecryptor:function(cipher,iv){return this.Decryptor.create(cipher,iv)},init:function(cipher,iv){this._cipher=cipher;this._iv=iv}});var CBC=C_mode.CBC=function(){var CBC=BlockCipherMode.extend();CBC.Encryptor=CBC.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;xorBlock.call(this,words,offset,blockSize);cipher.encryptBlock(words,offset);this._prevBlock=words.slice(offset,offset+blockSize)}});CBC.Decryptor=CBC.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;var thisBlock=words.slice(offset,offset+blockSize);cipher.decryptBlock(words,offset);xorBlock.call(this,words,offset,blockSize);this._prevBlock=thisBlock}});function xorBlock(words,offset,blockSize){var iv=this._iv;if(iv){var block=iv;this._iv=undefined}else{var block=this._prevBlock}for(var i=0;i<blockSize;i++){words[offset+i]^=block[i]}}return CBC}();var C_pad=C.pad={};var Pkcs7=C_pad.Pkcs7={pad:function(data,blockSize){var blockSizeBytes=blockSize*4;var nPaddingBytes=blockSizeBytes-data.sigBytes%blockSizeBytes;var paddingWord=nPaddingBytes<<24|nPaddingBytes<<16|nPaddingBytes<<8|nPaddingBytes;var paddingWords=[];for(var i=0;i<nPaddingBytes;i+=4){paddingWords.push(paddingWord)}var padding=WordArray.create(paddingWords,nPaddingBytes);data.concat(padding)},unpad:function(data){var nPaddingBytes=data.words[data.sigBytes-1>>>2]&255;data.sigBytes-=nPaddingBytes}};var BlockCipher=C_lib.BlockCipher=Cipher.extend({cfg:Cipher.cfg.extend({mode:CBC,padding:Pkcs7}),reset:function(){Cipher.reset.call(this);var cfg=this.cfg;var iv=cfg.iv;var mode=cfg.mode;if(this._xformMode==this._ENC_XFORM_MODE){var modeCreator=mode.createEncryptor}else{var modeCreator=mode.createDecryptor;this._minBufferSize=1}this._mode=modeCreator.call(mode,this,iv&&iv.words)},_doProcessBlock:function(words,offset){this._mode.processBlock(words,offset)},_doFinalize:function(){var padding=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){padding.pad(this._data,this.blockSize);var finalProcessedBlocks=this._process(!!"flush")}else{var finalProcessedBlocks=this._process(!!"flush");padding.unpad(finalProcessedBlocks)}return finalProcessedBlocks},blockSize:128/32});var CipherParams=C_lib.CipherParams=Base.extend({init:function(cipherParams){this.mixIn(cipherParams)},toString:function(formatter){return(formatter||this.formatter).stringify(this)}});var C_format=C.format={};var OpenSSLFormatter=C_format.OpenSSL={stringify:function(cipherParams){var ciphertext=cipherParams.ciphertext;var salt=cipherParams.salt;if(salt){var wordArray=WordArray.create([1398893684,1701076831]).concat(salt).concat(ciphertext)}else{var wordArray=ciphertext}return wordArray.toString(Base64)},parse:function(openSSLStr){var ciphertext=Base64.parse(openSSLStr);var ciphertextWords=ciphertext.words;if(ciphertextWords[0]==1398893684&&ciphertextWords[1]==1701076831){var salt=WordArray.create(ciphertextWords.slice(2,4));ciphertextWords.splice(0,4);ciphertext.sigBytes-=16}return CipherParams.create({ciphertext:ciphertext,salt:salt})}};var SerializableCipher=C_lib.SerializableCipher=Base.extend({cfg:Base.extend({format:OpenSSLFormatter}),encrypt:function(cipher,message,key,cfg){cfg=this.cfg.extend(cfg);var encryptor=cipher.createEncryptor(key,cfg);var ciphertext=encryptor.finalize(message);var cipherCfg=encryptor.cfg;return CipherParams.create({ciphertext:ciphertext,key:key,iv:cipherCfg.iv,algorithm:cipher,mode:cipherCfg.mode,padding:cipherCfg.padding,blockSize:cipher.blockSize,formatter:cfg.format})},decrypt:function(cipher,ciphertext,key,cfg){cfg=this.cfg.extend(cfg);ciphertext=this._parse(ciphertext,cfg.format);var plaintext=cipher.createDecryptor(key,cfg).finalize(ciphertext.ciphertext);return plaintext},_parse:function(ciphertext,format){if(typeof ciphertext=="string"){return format.parse(ciphertext,this)}else{return ciphertext}}});var C_kdf=C.kdf={};var OpenSSLKdf=C_kdf.OpenSSL={execute:function(password,keySize,ivSize,salt){if(!salt){salt=WordArray.random(64/8)}var key=EvpKDF.create({keySize:keySize+ivSize}).compute(password,salt);var iv=WordArray.create(key.words.slice(keySize),ivSize*4);key.sigBytes=keySize*4;return CipherParams.create({key:key,iv:iv,salt:salt})}};var PasswordBasedCipher=C_lib.PasswordBasedCipher=SerializableCipher.extend({cfg:SerializableCipher.cfg.extend({kdf:OpenSSLKdf}),encrypt:function(cipher,message,password,cfg){cfg=this.cfg.extend(cfg);var derivedParams=cfg.kdf.execute(password,cipher.keySize,cipher.ivSize);cfg.iv=derivedParams.iv;var ciphertext=SerializableCipher.encrypt.call(this,cipher,message,derivedParams.key,cfg);
ciphertext.mixIn(derivedParams);return ciphertext},decrypt:function(cipher,ciphertext,password,cfg){cfg=this.cfg.extend(cfg);ciphertext=this._parse(ciphertext,cfg.format);var derivedParams=cfg.kdf.execute(password,cipher.keySize,cipher.ivSize,ciphertext.salt);cfg.iv=derivedParams.iv;var plaintext=SerializableCipher.decrypt.call(this,cipher,ciphertext,derivedParams.key,cfg);return plaintext}})}()})},{"./core":20}],20:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory()}else if(typeof define==="function"&&define.amd){define([],factory)}else{root.CryptoJS=factory()}})(this,function(){var CryptoJS=CryptoJS||function(Math,undefined){var C={};var C_lib=C.lib={};var Base=C_lib.Base=function(){function F(){}return{extend:function(overrides){F.prototype=this;var subtype=new F;if(overrides){subtype.mixIn(overrides)}if(!subtype.hasOwnProperty("init")){subtype.init=function(){subtype.$super.init.apply(this,arguments)}}subtype.init.prototype=subtype;subtype.$super=this;return subtype},create:function(){var instance=this.extend();instance.init.apply(instance,arguments);return instance},init:function(){},mixIn:function(properties){for(var propertyName in properties){if(properties.hasOwnProperty(propertyName)){this[propertyName]=properties[propertyName]}}if(properties.hasOwnProperty("toString")){this.toString=properties.toString}},clone:function(){return this.init.prototype.extend(this)}}}();var WordArray=C_lib.WordArray=Base.extend({init:function(words,sigBytes){words=this.words=words||[];if(sigBytes!=undefined){this.sigBytes=sigBytes}else{this.sigBytes=words.length*4}},toString:function(encoder){return(encoder||Hex).stringify(this)},concat:function(wordArray){var thisWords=this.words;var thatWords=wordArray.words;var thisSigBytes=this.sigBytes;var thatSigBytes=wordArray.sigBytes;this.clamp();if(thisSigBytes%4){for(var i=0;i<thatSigBytes;i++){var thatByte=thatWords[i>>>2]>>>24-i%4*8&255;thisWords[thisSigBytes+i>>>2]|=thatByte<<24-(thisSigBytes+i)%4*8}}else if(thatWords.length>256){for(var i=0;i<thatSigBytes;i+=4){thisWords[thisSigBytes+i>>>2]=thatWords[i>>>2]}}else{thisWords.push.apply(thisWords,thatWords)}this.sigBytes+=thatSigBytes;return this},clamp:function(){var words=this.words;var sigBytes=this.sigBytes;words[sigBytes>>>2]&=4294967295<<32-sigBytes%4*8;words.length=Math.ceil(sigBytes/4)},clone:function(){var clone=Base.clone.call(this);clone.words=this.words.slice(0);return clone},random:function(nBytes){var words=[];for(var i=0;i<nBytes;i+=4){words.push(Math.random()*4294967296|0)}return new WordArray.init(words,nBytes)}});var C_enc=C.enc={};var Hex=C_enc.Hex={stringify:function(wordArray){var words=wordArray.words;var sigBytes=wordArray.sigBytes;var hexChars=[];for(var i=0;i<sigBytes;i++){var bite=words[i>>>2]>>>24-i%4*8&255;hexChars.push((bite>>>4).toString(16));hexChars.push((bite&15).toString(16))}return hexChars.join("")},parse:function(hexStr){var hexStrLength=hexStr.length;var words=[];for(var i=0;i<hexStrLength;i+=2){words[i>>>3]|=parseInt(hexStr.substr(i,2),16)<<24-i%8*4}return new WordArray.init(words,hexStrLength/2)}};var Latin1=C_enc.Latin1={stringify:function(wordArray){var words=wordArray.words;var sigBytes=wordArray.sigBytes;var latin1Chars=[];for(var i=0;i<sigBytes;i++){var bite=words[i>>>2]>>>24-i%4*8&255;latin1Chars.push(String.fromCharCode(bite))}return latin1Chars.join("")},parse:function(latin1Str){var latin1StrLength=latin1Str.length;var words=[];for(var i=0;i<latin1StrLength;i++){words[i>>>2]|=(latin1Str.charCodeAt(i)&255)<<24-i%4*8}return new WordArray.init(words,latin1StrLength)}};var Utf8=C_enc.Utf8={stringify:function(wordArray){try{return decodeURIComponent(escape(Latin1.stringify(wordArray)))}catch(e){throw new Error("Malformed UTF-8 data")}},parse:function(utf8Str){return Latin1.parse(unescape(encodeURIComponent(utf8Str)))}};var BufferedBlockAlgorithm=C_lib.BufferedBlockAlgorithm=Base.extend({reset:function(){this._data=new WordArray.init;this._nDataBytes=0},_append:function(data){if(typeof data=="string"){data=Utf8.parse(data)}this._data.concat(data);this._nDataBytes+=data.sigBytes},_process:function(doFlush){var data=this._data;var dataWords=data.words;var dataSigBytes=data.sigBytes;var blockSize=this.blockSize;var blockSizeBytes=blockSize*4;var nBlocksReady=dataSigBytes/blockSizeBytes;if(doFlush){nBlocksReady=Math.ceil(nBlocksReady)}else{nBlocksReady=Math.max((nBlocksReady|0)-this._minBufferSize,0)}var nWordsReady=nBlocksReady*blockSize;var nBytesReady=Math.min(nWordsReady*4,dataSigBytes);if(nWordsReady){for(var offset=0;offset<nWordsReady;offset+=blockSize){this._doProcessBlock(dataWords,offset)}var processedWords=dataWords.splice(0,nWordsReady);data.sigBytes-=nBytesReady}return new WordArray.init(processedWords,nBytesReady)},clone:function(){var clone=Base.clone.call(this);clone._data=this._data.clone();return clone},_minBufferSize:0});var Hasher=C_lib.Hasher=BufferedBlockAlgorithm.extend({cfg:Base.extend(),init:function(cfg){this.cfg=this.cfg.extend(cfg);this.reset()},reset:function(){BufferedBlockAlgorithm.reset.call(this);this._doReset()},update:function(messageUpdate){this._append(messageUpdate);this._process();return this},finalize:function(messageUpdate){if(messageUpdate){this._append(messageUpdate)}var hash=this._doFinalize();return hash},blockSize:512/32,_createHelper:function(hasher){return function(message,cfg){return new hasher.init(cfg).finalize(message)}},_createHmacHelper:function(hasher){return function(message,key){return new C_algo.HMAC.init(hasher,key).finalize(message)}}});var C_algo=C.algo={};return C}(Math);return CryptoJS})},{}],21:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var C_enc=C.enc;var Base64=C_enc.Base64={stringify:function(wordArray){var words=wordArray.words;var sigBytes=wordArray.sigBytes;var map=this._map;wordArray.clamp();var base64Chars=[];for(var i=0;i<sigBytes;i+=3){var byte1=words[i>>>2]>>>24-i%4*8&255;var byte2=words[i+1>>>2]>>>24-(i+1)%4*8&255;var byte3=words[i+2>>>2]>>>24-(i+2)%4*8&255;var triplet=byte1<<16|byte2<<8|byte3;for(var j=0;j<4&&i+j*.75<sigBytes;j++){base64Chars.push(map.charAt(triplet>>>6*(3-j)&63))}}var paddingChar=map.charAt(64);if(paddingChar){while(base64Chars.length%4){base64Chars.push(paddingChar)}}return base64Chars.join("")},parse:function(base64Str){var base64StrLength=base64Str.length;var map=this._map;var paddingChar=map.charAt(64);if(paddingChar){var paddingIndex=base64Str.indexOf(paddingChar);if(paddingIndex!=-1){base64StrLength=paddingIndex}}var words=[];var nBytes=0;for(var i=0;i<base64StrLength;i++){if(i%4){var bits1=map.indexOf(base64Str.charAt(i-1))<<i%4*2;var bits2=map.indexOf(base64Str.charAt(i))>>>6-i%4*2;words[nBytes>>>2]|=(bits1|bits2)<<24-nBytes%4*8;nBytes++}}return WordArray.create(words,nBytes)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();return CryptoJS.enc.Base64})},{"./core":20}],22:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var C_enc=C.enc;var Utf16BE=C_enc.Utf16=C_enc.Utf16BE={stringify:function(wordArray){var words=wordArray.words;var sigBytes=wordArray.sigBytes;var utf16Chars=[];for(var i=0;i<sigBytes;i+=2){var codePoint=words[i>>>2]>>>16-i%4*8&65535;utf16Chars.push(String.fromCharCode(codePoint))}return utf16Chars.join("")},parse:function(utf16Str){var utf16StrLength=utf16Str.length;var words=[];for(var i=0;i<utf16StrLength;i++){words[i>>>1]|=utf16Str.charCodeAt(i)<<16-i%2*16}return WordArray.create(words,utf16StrLength*2)}};C_enc.Utf16LE={stringify:function(wordArray){var words=wordArray.words;var sigBytes=wordArray.sigBytes;var utf16Chars=[];for(var i=0;i<sigBytes;i+=2){var codePoint=swapEndian(words[i>>>2]>>>16-i%4*8&65535);utf16Chars.push(String.fromCharCode(codePoint))}return utf16Chars.join("")},parse:function(utf16Str){var utf16StrLength=utf16Str.length;var words=[];for(var i=0;i<utf16StrLength;i++){words[i>>>1]|=swapEndian(utf16Str.charCodeAt(i)<<16-i%2*16)}return WordArray.create(words,utf16StrLength*2)}};function swapEndian(word){return word<<8&4278255360|word>>>8&16711935}})();return CryptoJS.enc.Utf16})},{"./core":20}],23:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./sha1"),_dereq_("./hmac"))}else if(typeof define==="function"&&define.amd){define(["./core","./sha1","./hmac"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var Base=C_lib.Base;var WordArray=C_lib.WordArray;var C_algo=C.algo;var MD5=C_algo.MD5;var EvpKDF=C_algo.EvpKDF=Base.extend({cfg:Base.extend({keySize:128/32,hasher:MD5,iterations:1}),init:function(cfg){this.cfg=this.cfg.extend(cfg)},compute:function(password,salt){var cfg=this.cfg;var hasher=cfg.hasher.create();var derivedKey=WordArray.create();var derivedKeyWords=derivedKey.words;var keySize=cfg.keySize;var iterations=cfg.iterations;while(derivedKeyWords.length<keySize){if(block){hasher.update(block)}var block=hasher.update(password).finalize(salt);hasher.reset();for(var i=1;i<iterations;i++){block=hasher.finalize(block);hasher.reset()}derivedKey.concat(block)}derivedKey.sigBytes=keySize*4;return derivedKey}});C.EvpKDF=function(password,salt,cfg){return EvpKDF.create(cfg).compute(password,salt)}})();return CryptoJS.EvpKDF})},{"./core":20,"./hmac":26,"./sha1":45}],24:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(undefined){var C=CryptoJS;var C_lib=C.lib;var CipherParams=C_lib.CipherParams;var C_enc=C.enc;var Hex=C_enc.Hex;var C_format=C.format;var HexFormatter=C_format.Hex={stringify:function(cipherParams){return cipherParams.ciphertext.toString(Hex)},parse:function(input){var ciphertext=Hex.parse(input);return CipherParams.create({ciphertext:ciphertext})}}})();return CryptoJS.format.Hex})},{"./cipher-core":19,"./core":20}],25:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./sha256"),_dereq_("./hmac"))}else if(typeof define==="function"&&define.amd){define(["./core","./sha256","./hmac"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){return CryptoJS.HmacSHA256})},{"./core":20,"./hmac":26,"./sha256":47}],26:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var Base=C_lib.Base;var C_enc=C.enc;var Utf8=C_enc.Utf8;var C_algo=C.algo;var HMAC=C_algo.HMAC=Base.extend({init:function(hasher,key){hasher=this._hasher=new hasher.init;if(typeof key=="string"){key=Utf8.parse(key)}var hasherBlockSize=hasher.blockSize;var hasherBlockSizeBytes=hasherBlockSize*4;if(key.sigBytes>hasherBlockSizeBytes){key=hasher.finalize(key)}key.clamp();var oKey=this._oKey=key.clone();var iKey=this._iKey=key.clone();var oKeyWords=oKey.words;var iKeyWords=iKey.words;for(var i=0;i<hasherBlockSize;i++){oKeyWords[i]^=1549556828;iKeyWords[i]^=909522486}oKey.sigBytes=iKey.sigBytes=hasherBlockSizeBytes;this.reset()},reset:function(){var hasher=this._hasher;hasher.reset();hasher.update(this._iKey)},update:function(messageUpdate){this._hasher.update(messageUpdate);return this},finalize:function(messageUpdate){var hasher=this._hasher;var innerHash=hasher.finalize(messageUpdate);hasher.reset();var hmac=hasher.finalize(this._oKey.clone().concat(innerHash));return hmac}})})()})},{"./core":20}],27:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./x64-core"),_dereq_("./lib-typedarrays"),_dereq_("./enc-utf16"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./sha1"),_dereq_("./sha256"),_dereq_("./sha224"),_dereq_("./sha512"),_dereq_("./sha384"),_dereq_("./sha3"),_dereq_("./ripemd160"),_dereq_("./hmac"),_dereq_("./pbkdf2"),_dereq_("./evpkdf"),_dereq_("./cipher-core"),_dereq_("./mode-cfb"),_dereq_("./mode-ctr"),_dereq_("./mode-ctr-gladman"),_dereq_("./mode-ofb"),_dereq_("./mode-ecb"),_dereq_("./pad-ansix923"),_dereq_("./pad-iso10126"),_dereq_("./pad-iso97971"),_dereq_("./pad-zeropadding"),_dereq_("./pad-nopadding"),_dereq_("./format-hex"),_dereq_("./aes"),_dereq_("./tripledes"),_dereq_("./rc4"),_dereq_("./rabbit"),_dereq_("./rabbit-legacy"))}else if(typeof define==="function"&&define.amd){define(["./core","./x64-core","./lib-typedarrays","./enc-utf16","./enc-base64","./md5","./sha1","./sha256","./sha224","./sha512","./sha384","./sha3","./ripemd160","./hmac","./pbkdf2","./evpkdf","./cipher-core","./mode-cfb","./mode-ctr","./mode-ctr-gladman","./mode-ofb","./mode-ecb","./pad-ansix923","./pad-iso10126","./pad-iso97971","./pad-zeropadding","./pad-nopadding","./format-hex","./aes","./tripledes","./rc4","./rabbit","./rabbit-legacy"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){return CryptoJS})},{"./aes":18,"./cipher-core":19,"./core":20,"./enc-base64":21,"./enc-utf16":22,"./evpkdf":23,"./format-hex":24,"./hmac":26,"./lib-typedarrays":28,"./md5":29,"./mode-cfb":30,"./mode-ctr":32,"./mode-ctr-gladman":31,"./mode-ecb":33,"./mode-ofb":34,"./pad-ansix923":35,"./pad-iso10126":36,"./pad-iso97971":37,"./pad-nopadding":38,"./pad-zeropadding":39,"./pbkdf2":40,"./rabbit":42,"./rabbit-legacy":41,"./rc4":43,"./ripemd160":44,"./sha1":45,"./sha224":46,"./sha256":47,"./sha3":48,"./sha384":49,"./sha512":50,"./tripledes":51,"./x64-core":52}],28:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){if(typeof ArrayBuffer!="function"){return}var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var superInit=WordArray.init;var subInit=WordArray.init=function(typedArray){if(typedArray instanceof ArrayBuffer){typedArray=new Uint8Array(typedArray)}if(typedArray instanceof Int8Array||typedArray instanceof Uint8ClampedArray||typedArray instanceof Int16Array||typedArray instanceof Uint16Array||typedArray instanceof Int32Array||typedArray instanceof Uint32Array||typedArray instanceof Float32Array||typedArray instanceof Float64Array){typedArray=new Uint8Array(typedArray.buffer,typedArray.byteOffset,typedArray.byteLength)}if(typedArray instanceof Uint8Array){var typedArrayByteLength=typedArray.byteLength;var words=[];for(var i=0;i<typedArrayByteLength;i++){words[i>>>2]|=typedArray[i]<<24-i%4*8}superInit.call(this,words,typedArrayByteLength)}else{superInit.apply(this,arguments)}};subInit.prototype=WordArray})();return CryptoJS.lib.WordArray})},{"./core":20}],29:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(Math){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var Hasher=C_lib.Hasher;var C_algo=C.algo;var T=[];(function(){for(var i=0;i<64;i++){T[i]=Math.abs(Math.sin(i+1))*4294967296|0}})();var MD5=C_algo.MD5=Hasher.extend({_doReset:function(){this._hash=new WordArray.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(M,offset){for(var i=0;i<16;i++){var offset_i=offset+i;var M_offset_i=M[offset_i];M[offset_i]=(M_offset_i<<8|M_offset_i>>>24)&16711935|(M_offset_i<<24|M_offset_i>>>8)&4278255360}var H=this._hash.words;var M_offset_0=M[offset+0];var M_offset_1=M[offset+1];var M_offset_2=M[offset+2];var M_offset_3=M[offset+3];var M_offset_4=M[offset+4];var M_offset_5=M[offset+5];var M_offset_6=M[offset+6];var M_offset_7=M[offset+7];var M_offset_8=M[offset+8];var M_offset_9=M[offset+9];var M_offset_10=M[offset+10];var M_offset_11=M[offset+11];var M_offset_12=M[offset+12];var M_offset_13=M[offset+13];var M_offset_14=M[offset+14];var M_offset_15=M[offset+15];var a=H[0];var b=H[1];var c=H[2];var d=H[3];a=FF(a,b,c,d,M_offset_0,7,T[0]);d=FF(d,a,b,c,M_offset_1,12,T[1]);c=FF(c,d,a,b,M_offset_2,17,T[2]);b=FF(b,c,d,a,M_offset_3,22,T[3]);a=FF(a,b,c,d,M_offset_4,7,T[4]);d=FF(d,a,b,c,M_offset_5,12,T[5]);c=FF(c,d,a,b,M_offset_6,17,T[6]);b=FF(b,c,d,a,M_offset_7,22,T[7]);a=FF(a,b,c,d,M_offset_8,7,T[8]);d=FF(d,a,b,c,M_offset_9,12,T[9]);c=FF(c,d,a,b,M_offset_10,17,T[10]);b=FF(b,c,d,a,M_offset_11,22,T[11]);a=FF(a,b,c,d,M_offset_12,7,T[12]);d=FF(d,a,b,c,M_offset_13,12,T[13]);c=FF(c,d,a,b,M_offset_14,17,T[14]);b=FF(b,c,d,a,M_offset_15,22,T[15]);a=GG(a,b,c,d,M_offset_1,5,T[16]);d=GG(d,a,b,c,M_offset_6,9,T[17]);c=GG(c,d,a,b,M_offset_11,14,T[18]);b=GG(b,c,d,a,M_offset_0,20,T[19]);a=GG(a,b,c,d,M_offset_5,5,T[20]);d=GG(d,a,b,c,M_offset_10,9,T[21]);c=GG(c,d,a,b,M_offset_15,14,T[22]);b=GG(b,c,d,a,M_offset_4,20,T[23]);a=GG(a,b,c,d,M_offset_9,5,T[24]);d=GG(d,a,b,c,M_offset_14,9,T[25]);c=GG(c,d,a,b,M_offset_3,14,T[26]);b=GG(b,c,d,a,M_offset_8,20,T[27]);a=GG(a,b,c,d,M_offset_13,5,T[28]);d=GG(d,a,b,c,M_offset_2,9,T[29]);c=GG(c,d,a,b,M_offset_7,14,T[30]);b=GG(b,c,d,a,M_offset_12,20,T[31]);a=HH(a,b,c,d,M_offset_5,4,T[32]);d=HH(d,a,b,c,M_offset_8,11,T[33]);c=HH(c,d,a,b,M_offset_11,16,T[34]);b=HH(b,c,d,a,M_offset_14,23,T[35]);a=HH(a,b,c,d,M_offset_1,4,T[36]);d=HH(d,a,b,c,M_offset_4,11,T[37]);c=HH(c,d,a,b,M_offset_7,16,T[38]);b=HH(b,c,d,a,M_offset_10,23,T[39]);a=HH(a,b,c,d,M_offset_13,4,T[40]);d=HH(d,a,b,c,M_offset_0,11,T[41]);c=HH(c,d,a,b,M_offset_3,16,T[42]);b=HH(b,c,d,a,M_offset_6,23,T[43]);a=HH(a,b,c,d,M_offset_9,4,T[44]);d=HH(d,a,b,c,M_offset_12,11,T[45]);c=HH(c,d,a,b,M_offset_15,16,T[46]);b=HH(b,c,d,a,M_offset_2,23,T[47]);a=II(a,b,c,d,M_offset_0,6,T[48]);d=II(d,a,b,c,M_offset_7,10,T[49]);c=II(c,d,a,b,M_offset_14,15,T[50]);b=II(b,c,d,a,M_offset_5,21,T[51]);a=II(a,b,c,d,M_offset_12,6,T[52]);d=II(d,a,b,c,M_offset_3,10,T[53]);c=II(c,d,a,b,M_offset_10,15,T[54]);b=II(b,c,d,a,M_offset_1,21,T[55]);a=II(a,b,c,d,M_offset_8,6,T[56]);d=II(d,a,b,c,M_offset_15,10,T[57]);c=II(c,d,a,b,M_offset_6,15,T[58]);b=II(b,c,d,a,M_offset_13,21,T[59]);a=II(a,b,c,d,M_offset_4,6,T[60]);d=II(d,a,b,c,M_offset_11,10,T[61]);c=II(c,d,a,b,M_offset_2,15,T[62]);b=II(b,c,d,a,M_offset_9,21,T[63]);H[0]=H[0]+a|0;H[1]=H[1]+b|0;H[2]=H[2]+c|0;H[3]=H[3]+d|0},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;var nBitsTotalH=Math.floor(nBitsTotal/4294967296);var nBitsTotalL=nBitsTotal;dataWords[(nBitsLeft+64>>>9<<4)+15]=(nBitsTotalH<<8|nBitsTotalH>>>24)&16711935|(nBitsTotalH<<24|nBitsTotalH>>>8)&4278255360;dataWords[(nBitsLeft+64>>>9<<4)+14]=(nBitsTotalL<<8|nBitsTotalL>>>24)&16711935|(nBitsTotalL<<24|nBitsTotalL>>>8)&4278255360;data.sigBytes=(dataWords.length+1)*4;this._process();var hash=this._hash;var H=hash.words;for(var i=0;i<4;i++){var H_i=H[i];H[i]=(H_i<<8|H_i>>>24)&16711935|(H_i<<24|H_i>>>8)&4278255360}return hash},clone:function(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone}});function FF(a,b,c,d,x,s,t){var n=a+(b&c|~b&d)+x+t;return(n<<s|n>>>32-s)+b}function GG(a,b,c,d,x,s,t){var n=a+(b&d|c&~d)+x+t;return(n<<s|n>>>32-s)+b}function HH(a,b,c,d,x,s,t){var n=a+(b^c^d)+x+t;return(n<<s|n>>>32-s)+b}function II(a,b,c,d,x,s,t){var n=a+(c^(b|~d))+x+t;return(n<<s|n>>>32-s)+b}C.MD5=Hasher._createHelper(MD5);C.HmacMD5=Hasher._createHmacHelper(MD5)})(Math);return CryptoJS.MD5})},{"./core":20}],30:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.mode.CFB=function(){var CFB=CryptoJS.lib.BlockCipherMode.extend();CFB.Encryptor=CFB.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;generateKeystreamAndEncrypt.call(this,words,offset,blockSize,cipher);this._prevBlock=words.slice(offset,offset+blockSize)}});CFB.Decryptor=CFB.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;var thisBlock=words.slice(offset,offset+blockSize);generateKeystreamAndEncrypt.call(this,words,offset,blockSize,cipher);this._prevBlock=thisBlock}});function generateKeystreamAndEncrypt(words,offset,blockSize,cipher){var iv=this._iv;if(iv){var keystream=iv.slice(0);this._iv=undefined}else{var keystream=this._prevBlock}cipher.encryptBlock(keystream,0);for(var i=0;i<blockSize;i++){words[offset+i]^=keystream[i]}}return CFB}();return CryptoJS.mode.CFB})},{"./cipher-core":19,"./core":20}],31:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.mode.CTRGladman=function(){var CTRGladman=CryptoJS.lib.BlockCipherMode.extend();function incWord(word){if((word>>24&255)===255){var b1=word>>16&255;var b2=word>>8&255;var b3=word&255;if(b1===255){b1=0;if(b2===255){b2=0;if(b3===255){b3=0}else{++b3}}else{++b2}}else{++b1}word=0;word+=b1<<16;word+=b2<<8;word+=b3}else{word+=1<<24}return word}function incCounter(counter){if((counter[0]=incWord(counter[0]))===0){counter[1]=incWord(counter[1])}return counter}var Encryptor=CTRGladman.Encryptor=CTRGladman.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;var iv=this._iv;var counter=this._counter;if(iv){counter=this._counter=iv.slice(0);this._iv=undefined}incCounter(counter);var keystream=counter.slice(0);cipher.encryptBlock(keystream,0);for(var i=0;i<blockSize;i++){words[offset+i]^=keystream[i]}}});CTRGladman.Decryptor=Encryptor;return CTRGladman}();return CryptoJS.mode.CTRGladman})},{"./cipher-core":19,"./core":20}],32:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.mode.CTR=function(){var CTR=CryptoJS.lib.BlockCipherMode.extend();var Encryptor=CTR.Encryptor=CTR.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;var iv=this._iv;var counter=this._counter;if(iv){counter=this._counter=iv.slice(0);this._iv=undefined}var keystream=counter.slice(0);cipher.encryptBlock(keystream,0);counter[blockSize-1]=counter[blockSize-1]+1|0;for(var i=0;i<blockSize;i++){words[offset+i]^=keystream[i]}}});CTR.Decryptor=Encryptor;return CTR}();return CryptoJS.mode.CTR})},{"./cipher-core":19,"./core":20}],33:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.mode.ECB=function(){var ECB=CryptoJS.lib.BlockCipherMode.extend();ECB.Encryptor=ECB.extend({processBlock:function(words,offset){this._cipher.encryptBlock(words,offset)}});ECB.Decryptor=ECB.extend({processBlock:function(words,offset){this._cipher.decryptBlock(words,offset)}});return ECB}();return CryptoJS.mode.ECB})},{"./cipher-core":19,"./core":20}],34:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.mode.OFB=function(){var OFB=CryptoJS.lib.BlockCipherMode.extend();var Encryptor=OFB.Encryptor=OFB.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;var iv=this._iv;var keystream=this._keystream;if(iv){keystream=this._keystream=iv.slice(0);this._iv=undefined}cipher.encryptBlock(keystream,0);for(var i=0;i<blockSize;i++){words[offset+i]^=keystream[i]}}});OFB.Decryptor=Encryptor;return OFB}();return CryptoJS.mode.OFB})},{"./cipher-core":19,"./core":20}],35:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.pad.AnsiX923={pad:function(data,blockSize){var dataSigBytes=data.sigBytes;var blockSizeBytes=blockSize*4;var nPaddingBytes=blockSizeBytes-dataSigBytes%blockSizeBytes;var lastBytePos=dataSigBytes+nPaddingBytes-1;data.clamp();data.words[lastBytePos>>>2]|=nPaddingBytes<<24-lastBytePos%4*8;data.sigBytes+=nPaddingBytes},unpad:function(data){var nPaddingBytes=data.words[data.sigBytes-1>>>2]&255;data.sigBytes-=nPaddingBytes}};return CryptoJS.pad.Ansix923})},{"./cipher-core":19,"./core":20}],36:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.pad.Iso10126={pad:function(data,blockSize){var blockSizeBytes=blockSize*4;var nPaddingBytes=blockSizeBytes-data.sigBytes%blockSizeBytes;data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes-1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes<<24],1))},unpad:function(data){var nPaddingBytes=data.words[data.sigBytes-1>>>2]&255;data.sigBytes-=nPaddingBytes}};return CryptoJS.pad.Iso10126})},{"./cipher-core":19,"./core":20}],37:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.pad.Iso97971={pad:function(data,blockSize){data.concat(CryptoJS.lib.WordArray.create([2147483648],1));CryptoJS.pad.ZeroPadding.pad(data,blockSize)},unpad:function(data){CryptoJS.pad.ZeroPadding.unpad(data);data.sigBytes--}};return CryptoJS.pad.Iso97971})},{"./cipher-core":19,"./core":20}],38:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.pad.NoPadding={pad:function(){},unpad:function(){}};return CryptoJS.pad.NoPadding})},{"./cipher-core":19,"./core":20}],39:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.pad.ZeroPadding={pad:function(data,blockSize){var blockSizeBytes=blockSize*4;data.clamp();data.sigBytes+=blockSizeBytes-(data.sigBytes%blockSizeBytes||blockSizeBytes)},unpad:function(data){var dataWords=data.words;var i=data.sigBytes-1;while(!(dataWords[i>>>2]>>>24-i%4*8&255)){i--}data.sigBytes=i+1}};return CryptoJS.pad.ZeroPadding})},{"./cipher-core":19,"./core":20}],40:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./sha1"),_dereq_("./hmac"))}else if(typeof define==="function"&&define.amd){define(["./core","./sha1","./hmac"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var Base=C_lib.Base;var WordArray=C_lib.WordArray;var C_algo=C.algo;var SHA1=C_algo.SHA1;var HMAC=C_algo.HMAC;var PBKDF2=C_algo.PBKDF2=Base.extend({cfg:Base.extend({keySize:128/32,hasher:SHA1,iterations:1}),init:function(cfg){this.cfg=this.cfg.extend(cfg)},compute:function(password,salt){var cfg=this.cfg;var hmac=HMAC.create(cfg.hasher,password);var derivedKey=WordArray.create();var blockIndex=WordArray.create([1]);var derivedKeyWords=derivedKey.words;var blockIndexWords=blockIndex.words;var keySize=cfg.keySize;var iterations=cfg.iterations;while(derivedKeyWords.length<keySize){var block=hmac.update(salt).finalize(blockIndex);hmac.reset();var blockWords=block.words;var blockWordsLength=blockWords.length;var intermediate=block;for(var i=1;i<iterations;i++){intermediate=hmac.finalize(intermediate);hmac.reset();var intermediateWords=intermediate.words;for(var j=0;j<blockWordsLength;j++){blockWords[j]^=intermediateWords[j]}}derivedKey.concat(block);blockIndexWords[0]++}derivedKey.sigBytes=keySize*4;return derivedKey}});C.PBKDF2=function(password,salt,cfg){return PBKDF2.create(cfg).compute(password,salt)}})();return CryptoJS.PBKDF2})},{"./core":20,"./hmac":26,"./sha1":45}],41:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./evpkdf"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var StreamCipher=C_lib.StreamCipher;var C_algo=C.algo;var S=[];var C_=[];var G=[];var RabbitLegacy=C_algo.RabbitLegacy=StreamCipher.extend({_doReset:function(){var K=this._key.words;var iv=this.cfg.iv;var X=this._X=[K[0],K[3]<<16|K[2]>>>16,K[1],K[0]<<16|K[3]>>>16,K[2],K[1]<<16|K[0]>>>16,K[3],K[2]<<16|K[1]>>>16];var C=this._C=[K[2]<<16|K[2]>>>16,K[0]&4294901760|K[1]&65535,K[3]<<16|K[3]>>>16,K[1]&4294901760|K[2]&65535,K[0]<<16|K[0]>>>16,K[2]&4294901760|K[3]&65535,K[1]<<16|K[1]>>>16,K[3]&4294901760|K[0]&65535];this._b=0;for(var i=0;i<4;i++){nextState.call(this)}for(var i=0;i<8;i++){C[i]^=X[i+4&7]}if(iv){var IV=iv.words;var IV_0=IV[0];var IV_1=IV[1];var i0=(IV_0<<8|IV_0>>>24)&16711935|(IV_0<<24|IV_0>>>8)&4278255360;var i2=(IV_1<<8|IV_1>>>24)&16711935|(IV_1<<24|IV_1>>>8)&4278255360;var i1=i0>>>16|i2&4294901760;var i3=i2<<16|i0&65535;C[0]^=i0;C[1]^=i1;C[2]^=i2;C[3]^=i3;C[4]^=i0;C[5]^=i1;C[6]^=i2;C[7]^=i3;for(var i=0;i<4;i++){nextState.call(this)}}},_doProcessBlock:function(M,offset){var X=this._X;nextState.call(this);S[0]=X[0]^X[5]>>>16^X[3]<<16;S[1]=X[2]^X[7]>>>16^X[5]<<16;S[2]=X[4]^X[1]>>>16^X[7]<<16;S[3]=X[6]^X[3]>>>16^X[1]<<16;for(var i=0;i<4;i++){S[i]=(S[i]<<8|S[i]>>>24)&16711935|(S[i]<<24|S[i]>>>8)&4278255360;M[offset+i]^=S[i]}},blockSize:128/32,ivSize:64/32});
function nextState(){var X=this._X;var C=this._C;for(var i=0;i<8;i++){C_[i]=C[i]}C[0]=C[0]+1295307597+this._b|0;C[1]=C[1]+3545052371+(C[0]>>>0<C_[0]>>>0?1:0)|0;C[2]=C[2]+886263092+(C[1]>>>0<C_[1]>>>0?1:0)|0;C[3]=C[3]+1295307597+(C[2]>>>0<C_[2]>>>0?1:0)|0;C[4]=C[4]+3545052371+(C[3]>>>0<C_[3]>>>0?1:0)|0;C[5]=C[5]+886263092+(C[4]>>>0<C_[4]>>>0?1:0)|0;C[6]=C[6]+1295307597+(C[5]>>>0<C_[5]>>>0?1:0)|0;C[7]=C[7]+3545052371+(C[6]>>>0<C_[6]>>>0?1:0)|0;this._b=C[7]>>>0<C_[7]>>>0?1:0;for(var i=0;i<8;i++){var gx=X[i]+C[i];var ga=gx&65535;var gb=gx>>>16;var gh=((ga*ga>>>17)+ga*gb>>>15)+gb*gb;var gl=((gx&4294901760)*gx|0)+((gx&65535)*gx|0);G[i]=gh^gl}X[0]=G[0]+(G[7]<<16|G[7]>>>16)+(G[6]<<16|G[6]>>>16)|0;X[1]=G[1]+(G[0]<<8|G[0]>>>24)+G[7]|0;X[2]=G[2]+(G[1]<<16|G[1]>>>16)+(G[0]<<16|G[0]>>>16)|0;X[3]=G[3]+(G[2]<<8|G[2]>>>24)+G[1]|0;X[4]=G[4]+(G[3]<<16|G[3]>>>16)+(G[2]<<16|G[2]>>>16)|0;X[5]=G[5]+(G[4]<<8|G[4]>>>24)+G[3]|0;X[6]=G[6]+(G[5]<<16|G[5]>>>16)+(G[4]<<16|G[4]>>>16)|0;X[7]=G[7]+(G[6]<<8|G[6]>>>24)+G[5]|0}C.RabbitLegacy=StreamCipher._createHelper(RabbitLegacy)})();return CryptoJS.RabbitLegacy})},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":29}],42:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./evpkdf"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var StreamCipher=C_lib.StreamCipher;var C_algo=C.algo;var S=[];var C_=[];var G=[];var Rabbit=C_algo.Rabbit=StreamCipher.extend({_doReset:function(){var K=this._key.words;var iv=this.cfg.iv;for(var i=0;i<4;i++){K[i]=(K[i]<<8|K[i]>>>24)&16711935|(K[i]<<24|K[i]>>>8)&4278255360}var X=this._X=[K[0],K[3]<<16|K[2]>>>16,K[1],K[0]<<16|K[3]>>>16,K[2],K[1]<<16|K[0]>>>16,K[3],K[2]<<16|K[1]>>>16];var C=this._C=[K[2]<<16|K[2]>>>16,K[0]&4294901760|K[1]&65535,K[3]<<16|K[3]>>>16,K[1]&4294901760|K[2]&65535,K[0]<<16|K[0]>>>16,K[2]&4294901760|K[3]&65535,K[1]<<16|K[1]>>>16,K[3]&4294901760|K[0]&65535];this._b=0;for(var i=0;i<4;i++){nextState.call(this)}for(var i=0;i<8;i++){C[i]^=X[i+4&7]}if(iv){var IV=iv.words;var IV_0=IV[0];var IV_1=IV[1];var i0=(IV_0<<8|IV_0>>>24)&16711935|(IV_0<<24|IV_0>>>8)&4278255360;var i2=(IV_1<<8|IV_1>>>24)&16711935|(IV_1<<24|IV_1>>>8)&4278255360;var i1=i0>>>16|i2&4294901760;var i3=i2<<16|i0&65535;C[0]^=i0;C[1]^=i1;C[2]^=i2;C[3]^=i3;C[4]^=i0;C[5]^=i1;C[6]^=i2;C[7]^=i3;for(var i=0;i<4;i++){nextState.call(this)}}},_doProcessBlock:function(M,offset){var X=this._X;nextState.call(this);S[0]=X[0]^X[5]>>>16^X[3]<<16;S[1]=X[2]^X[7]>>>16^X[5]<<16;S[2]=X[4]^X[1]>>>16^X[7]<<16;S[3]=X[6]^X[3]>>>16^X[1]<<16;for(var i=0;i<4;i++){S[i]=(S[i]<<8|S[i]>>>24)&16711935|(S[i]<<24|S[i]>>>8)&4278255360;M[offset+i]^=S[i]}},blockSize:128/32,ivSize:64/32});function nextState(){var X=this._X;var C=this._C;for(var i=0;i<8;i++){C_[i]=C[i]}C[0]=C[0]+1295307597+this._b|0;C[1]=C[1]+3545052371+(C[0]>>>0<C_[0]>>>0?1:0)|0;C[2]=C[2]+886263092+(C[1]>>>0<C_[1]>>>0?1:0)|0;C[3]=C[3]+1295307597+(C[2]>>>0<C_[2]>>>0?1:0)|0;C[4]=C[4]+3545052371+(C[3]>>>0<C_[3]>>>0?1:0)|0;C[5]=C[5]+886263092+(C[4]>>>0<C_[4]>>>0?1:0)|0;C[6]=C[6]+1295307597+(C[5]>>>0<C_[5]>>>0?1:0)|0;C[7]=C[7]+3545052371+(C[6]>>>0<C_[6]>>>0?1:0)|0;this._b=C[7]>>>0<C_[7]>>>0?1:0;for(var i=0;i<8;i++){var gx=X[i]+C[i];var ga=gx&65535;var gb=gx>>>16;var gh=((ga*ga>>>17)+ga*gb>>>15)+gb*gb;var gl=((gx&4294901760)*gx|0)+((gx&65535)*gx|0);G[i]=gh^gl}X[0]=G[0]+(G[7]<<16|G[7]>>>16)+(G[6]<<16|G[6]>>>16)|0;X[1]=G[1]+(G[0]<<8|G[0]>>>24)+G[7]|0;X[2]=G[2]+(G[1]<<16|G[1]>>>16)+(G[0]<<16|G[0]>>>16)|0;X[3]=G[3]+(G[2]<<8|G[2]>>>24)+G[1]|0;X[4]=G[4]+(G[3]<<16|G[3]>>>16)+(G[2]<<16|G[2]>>>16)|0;X[5]=G[5]+(G[4]<<8|G[4]>>>24)+G[3]|0;X[6]=G[6]+(G[5]<<16|G[5]>>>16)+(G[4]<<16|G[4]>>>16)|0;X[7]=G[7]+(G[6]<<8|G[6]>>>24)+G[5]|0}C.Rabbit=StreamCipher._createHelper(Rabbit)})();return CryptoJS.Rabbit})},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":29}],43:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./evpkdf"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var StreamCipher=C_lib.StreamCipher;var C_algo=C.algo;var RC4=C_algo.RC4=StreamCipher.extend({_doReset:function(){var key=this._key;var keyWords=key.words;var keySigBytes=key.sigBytes;var S=this._S=[];for(var i=0;i<256;i++){S[i]=i}for(var i=0,j=0;i<256;i++){var keyByteIndex=i%keySigBytes;var keyByte=keyWords[keyByteIndex>>>2]>>>24-keyByteIndex%4*8&255;j=(j+S[i]+keyByte)%256;var t=S[i];S[i]=S[j];S[j]=t}this._i=this._j=0},_doProcessBlock:function(M,offset){M[offset]^=generateKeystreamWord.call(this)},keySize:256/32,ivSize:0});function generateKeystreamWord(){var S=this._S;var i=this._i;var j=this._j;var keystreamWord=0;for(var n=0;n<4;n++){i=(i+1)%256;j=(j+S[i])%256;var t=S[i];S[i]=S[j];S[j]=t;keystreamWord|=S[(S[i]+S[j])%256]<<24-n*8}this._i=i;this._j=j;return keystreamWord}C.RC4=StreamCipher._createHelper(RC4);var RC4Drop=C_algo.RC4Drop=RC4.extend({cfg:RC4.cfg.extend({drop:192}),_doReset:function(){RC4._doReset.call(this);for(var i=this.cfg.drop;i>0;i--){generateKeystreamWord.call(this)}}});C.RC4Drop=StreamCipher._createHelper(RC4Drop)})();return CryptoJS.RC4})},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":29}],44:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(Math){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var Hasher=C_lib.Hasher;var C_algo=C.algo;var _zl=WordArray.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]);var _zr=WordArray.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]);var _sl=WordArray.create([11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]);var _sr=WordArray.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]);var _hl=WordArray.create([0,1518500249,1859775393,2400959708,2840853838]);var _hr=WordArray.create([1352829926,1548603684,1836072691,2053994217,0]);var RIPEMD160=C_algo.RIPEMD160=Hasher.extend({_doReset:function(){this._hash=WordArray.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(M,offset){for(var i=0;i<16;i++){var offset_i=offset+i;var M_offset_i=M[offset_i];M[offset_i]=(M_offset_i<<8|M_offset_i>>>24)&16711935|(M_offset_i<<24|M_offset_i>>>8)&4278255360}var H=this._hash.words;var hl=_hl.words;var hr=_hr.words;var zl=_zl.words;var zr=_zr.words;var sl=_sl.words;var sr=_sr.words;var al,bl,cl,dl,el;var ar,br,cr,dr,er;ar=al=H[0];br=bl=H[1];cr=cl=H[2];dr=dl=H[3];er=el=H[4];var t;for(var i=0;i<80;i+=1){t=al+M[offset+zl[i]]|0;if(i<16){t+=f1(bl,cl,dl)+hl[0]}else if(i<32){t+=f2(bl,cl,dl)+hl[1]}else if(i<48){t+=f3(bl,cl,dl)+hl[2]}else if(i<64){t+=f4(bl,cl,dl)+hl[3]}else{t+=f5(bl,cl,dl)+hl[4]}t=t|0;t=rotl(t,sl[i]);t=t+el|0;al=el;el=dl;dl=rotl(cl,10);cl=bl;bl=t;t=ar+M[offset+zr[i]]|0;if(i<16){t+=f5(br,cr,dr)+hr[0]}else if(i<32){t+=f4(br,cr,dr)+hr[1]}else if(i<48){t+=f3(br,cr,dr)+hr[2]}else if(i<64){t+=f2(br,cr,dr)+hr[3]}else{t+=f1(br,cr,dr)+hr[4]}t=t|0;t=rotl(t,sr[i]);t=t+er|0;ar=er;er=dr;dr=rotl(cr,10);cr=br;br=t}t=H[1]+cl+dr|0;H[1]=H[2]+dl+er|0;H[2]=H[3]+el+ar|0;H[3]=H[4]+al+br|0;H[4]=H[0]+bl+cr|0;H[0]=t},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;dataWords[(nBitsLeft+64>>>9<<4)+14]=(nBitsTotal<<8|nBitsTotal>>>24)&16711935|(nBitsTotal<<24|nBitsTotal>>>8)&4278255360;data.sigBytes=(dataWords.length+1)*4;this._process();var hash=this._hash;var H=hash.words;for(var i=0;i<5;i++){var H_i=H[i];H[i]=(H_i<<8|H_i>>>24)&16711935|(H_i<<24|H_i>>>8)&4278255360}return hash},clone:function(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone}});function f1(x,y,z){return x^y^z}function f2(x,y,z){return x&y|~x&z}function f3(x,y,z){return(x|~y)^z}function f4(x,y,z){return x&z|y&~z}function f5(x,y,z){return x^(y|~z)}function rotl(x,n){return x<<n|x>>>32-n}C.RIPEMD160=Hasher._createHelper(RIPEMD160);C.HmacRIPEMD160=Hasher._createHmacHelper(RIPEMD160)})(Math);return CryptoJS.RIPEMD160})},{"./core":20}],45:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var Hasher=C_lib.Hasher;var C_algo=C.algo;var W=[];var SHA1=C_algo.SHA1=Hasher.extend({_doReset:function(){this._hash=new WordArray.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(M,offset){var H=this._hash.words;var a=H[0];var b=H[1];var c=H[2];var d=H[3];var e=H[4];for(var i=0;i<80;i++){if(i<16){W[i]=M[offset+i]|0}else{var n=W[i-3]^W[i-8]^W[i-14]^W[i-16];W[i]=n<<1|n>>>31}var t=(a<<5|a>>>27)+e+W[i];if(i<20){t+=(b&c|~b&d)+1518500249}else if(i<40){t+=(b^c^d)+1859775393}else if(i<60){t+=(b&c|b&d|c&d)-1894007588}else{t+=(b^c^d)-899497514}e=d;d=c;c=b<<30|b>>>2;b=a;a=t}H[0]=H[0]+a|0;H[1]=H[1]+b|0;H[2]=H[2]+c|0;H[3]=H[3]+d|0;H[4]=H[4]+e|0},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;dataWords[(nBitsLeft+64>>>9<<4)+14]=Math.floor(nBitsTotal/4294967296);dataWords[(nBitsLeft+64>>>9<<4)+15]=nBitsTotal;data.sigBytes=dataWords.length*4;this._process();return this._hash},clone:function(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone}});C.SHA1=Hasher._createHelper(SHA1);C.HmacSHA1=Hasher._createHmacHelper(SHA1)})();return CryptoJS.SHA1})},{"./core":20}],46:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./sha256"))}else if(typeof define==="function"&&define.amd){define(["./core","./sha256"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var C_algo=C.algo;var SHA256=C_algo.SHA256;var SHA224=C_algo.SHA224=SHA256.extend({_doReset:function(){this._hash=new WordArray.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var hash=SHA256._doFinalize.call(this);hash.sigBytes-=4;return hash}});C.SHA224=SHA256._createHelper(SHA224);C.HmacSHA224=SHA256._createHmacHelper(SHA224)})();return CryptoJS.SHA224})},{"./core":20,"./sha256":47}],47:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(Math){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var Hasher=C_lib.Hasher;var C_algo=C.algo;var H=[];var K=[];(function(){function isPrime(n){var sqrtN=Math.sqrt(n);for(var factor=2;factor<=sqrtN;factor++){if(!(n%factor)){return false}}return true}function getFractionalBits(n){return(n-(n|0))*4294967296|0}var n=2;var nPrime=0;while(nPrime<64){if(isPrime(n)){if(nPrime<8){H[nPrime]=getFractionalBits(Math.pow(n,1/2))}K[nPrime]=getFractionalBits(Math.pow(n,1/3));nPrime++}n++}})();var W=[];var SHA256=C_algo.SHA256=Hasher.extend({_doReset:function(){this._hash=new WordArray.init(H.slice(0))},_doProcessBlock:function(M,offset){var H=this._hash.words;var a=H[0];var b=H[1];var c=H[2];var d=H[3];var e=H[4];var f=H[5];var g=H[6];var h=H[7];for(var i=0;i<64;i++){if(i<16){W[i]=M[offset+i]|0}else{var gamma0x=W[i-15];var gamma0=(gamma0x<<25|gamma0x>>>7)^(gamma0x<<14|gamma0x>>>18)^gamma0x>>>3;var gamma1x=W[i-2];var gamma1=(gamma1x<<15|gamma1x>>>17)^(gamma1x<<13|gamma1x>>>19)^gamma1x>>>10;W[i]=gamma0+W[i-7]+gamma1+W[i-16]}var ch=e&f^~e&g;var maj=a&b^a&c^b&c;var sigma0=(a<<30|a>>>2)^(a<<19|a>>>13)^(a<<10|a>>>22);var sigma1=(e<<26|e>>>6)^(e<<21|e>>>11)^(e<<7|e>>>25);var t1=h+sigma1+ch+K[i]+W[i];var t2=sigma0+maj;h=g;g=f;f=e;e=d+t1|0;d=c;c=b;b=a;a=t1+t2|0}H[0]=H[0]+a|0;H[1]=H[1]+b|0;H[2]=H[2]+c|0;H[3]=H[3]+d|0;H[4]=H[4]+e|0;H[5]=H[5]+f|0;H[6]=H[6]+g|0;H[7]=H[7]+h|0},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;dataWords[(nBitsLeft+64>>>9<<4)+14]=Math.floor(nBitsTotal/4294967296);dataWords[(nBitsLeft+64>>>9<<4)+15]=nBitsTotal;data.sigBytes=dataWords.length*4;this._process();return this._hash},clone:function(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone}});C.SHA256=Hasher._createHelper(SHA256);C.HmacSHA256=Hasher._createHmacHelper(SHA256)})(Math);return CryptoJS.SHA256})},{"./core":20}],48:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./x64-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./x64-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(Math){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var Hasher=C_lib.Hasher;var C_x64=C.x64;var X64Word=C_x64.Word;var C_algo=C.algo;var RHO_OFFSETS=[];var PI_INDEXES=[];var ROUND_CONSTANTS=[];(function(){var x=1,y=0;for(var t=0;t<24;t++){RHO_OFFSETS[x+5*y]=(t+1)*(t+2)/2%64;var newX=y%5;var newY=(2*x+3*y)%5;x=newX;y=newY}for(var x=0;x<5;x++){for(var y=0;y<5;y++){PI_INDEXES[x+5*y]=y+(2*x+3*y)%5*5}}var LFSR=1;for(var i=0;i<24;i++){var roundConstantMsw=0;var roundConstantLsw=0;for(var j=0;j<7;j++){if(LFSR&1){var bitPosition=(1<<j)-1;if(bitPosition<32){roundConstantLsw^=1<<bitPosition}else{roundConstantMsw^=1<<bitPosition-32}}if(LFSR&128){LFSR=LFSR<<1^113}else{LFSR<<=1}}ROUND_CONSTANTS[i]=X64Word.create(roundConstantMsw,roundConstantLsw)}})();var T=[];(function(){for(var i=0;i<25;i++){T[i]=X64Word.create()}})();var SHA3=C_algo.SHA3=Hasher.extend({cfg:Hasher.cfg.extend({outputLength:512}),_doReset:function(){var state=this._state=[];for(var i=0;i<25;i++){state[i]=new X64Word.init}this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(M,offset){var state=this._state;var nBlockSizeLanes=this.blockSize/2;for(var i=0;i<nBlockSizeLanes;i++){var M2i=M[offset+2*i];var M2i1=M[offset+2*i+1];M2i=(M2i<<8|M2i>>>24)&16711935|(M2i<<24|M2i>>>8)&4278255360;M2i1=(M2i1<<8|M2i1>>>24)&16711935|(M2i1<<24|M2i1>>>8)&4278255360;var lane=state[i];lane.high^=M2i1;lane.low^=M2i}for(var round=0;round<24;round++){for(var x=0;x<5;x++){var tMsw=0,tLsw=0;for(var y=0;y<5;y++){var lane=state[x+5*y];tMsw^=lane.high;tLsw^=lane.low}var Tx=T[x];Tx.high=tMsw;Tx.low=tLsw}for(var x=0;x<5;x++){var Tx4=T[(x+4)%5];var Tx1=T[(x+1)%5];var Tx1Msw=Tx1.high;var Tx1Lsw=Tx1.low;var tMsw=Tx4.high^(Tx1Msw<<1|Tx1Lsw>>>31);var tLsw=Tx4.low^(Tx1Lsw<<1|Tx1Msw>>>31);for(var y=0;y<5;y++){var lane=state[x+5*y];lane.high^=tMsw;lane.low^=tLsw}}for(var laneIndex=1;laneIndex<25;laneIndex++){var lane=state[laneIndex];var laneMsw=lane.high;var laneLsw=lane.low;var rhoOffset=RHO_OFFSETS[laneIndex];if(rhoOffset<32){var tMsw=laneMsw<<rhoOffset|laneLsw>>>32-rhoOffset;var tLsw=laneLsw<<rhoOffset|laneMsw>>>32-rhoOffset}else{var tMsw=laneLsw<<rhoOffset-32|laneMsw>>>64-rhoOffset;var tLsw=laneMsw<<rhoOffset-32|laneLsw>>>64-rhoOffset}var TPiLane=T[PI_INDEXES[laneIndex]];TPiLane.high=tMsw;TPiLane.low=tLsw}var T0=T[0];var state0=state[0];T0.high=state0.high;T0.low=state0.low;for(var x=0;x<5;x++){for(var y=0;y<5;y++){var laneIndex=x+5*y;var lane=state[laneIndex];var TLane=T[laneIndex];var Tx1Lane=T[(x+1)%5+5*y];var Tx2Lane=T[(x+2)%5+5*y];lane.high=TLane.high^~Tx1Lane.high&Tx2Lane.high;lane.low=TLane.low^~Tx1Lane.low&Tx2Lane.low}}var lane=state[0];var roundConstant=ROUND_CONSTANTS[round];lane.high^=roundConstant.high;lane.low^=roundConstant.low}},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;var blockSizeBits=this.blockSize*32;dataWords[nBitsLeft>>>5]|=1<<24-nBitsLeft%32;dataWords[(Math.ceil((nBitsLeft+1)/blockSizeBits)*blockSizeBits>>>5)-1]|=128;data.sigBytes=dataWords.length*4;this._process();var state=this._state;var outputLengthBytes=this.cfg.outputLength/8;var outputLengthLanes=outputLengthBytes/8;var hashWords=[];for(var i=0;i<outputLengthLanes;i++){var lane=state[i];var laneMsw=lane.high;var laneLsw=lane.low;laneMsw=(laneMsw<<8|laneMsw>>>24)&16711935|(laneMsw<<24|laneMsw>>>8)&4278255360;laneLsw=(laneLsw<<8|laneLsw>>>24)&16711935|(laneLsw<<24|laneLsw>>>8)&4278255360;hashWords.push(laneLsw);hashWords.push(laneMsw)}return new WordArray.init(hashWords,outputLengthBytes)},clone:function(){var clone=Hasher.clone.call(this);var state=clone._state=this._state.slice(0);for(var i=0;i<25;i++){state[i]=state[i].clone()}return clone}});C.SHA3=Hasher._createHelper(SHA3);C.HmacSHA3=Hasher._createHmacHelper(SHA3)})(Math);return CryptoJS.SHA3})},{"./core":20,"./x64-core":52}],49:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./x64-core"),_dereq_("./sha512"))}else if(typeof define==="function"&&define.amd){define(["./core","./x64-core","./sha512"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_x64=C.x64;var X64Word=C_x64.Word;var X64WordArray=C_x64.WordArray;var C_algo=C.algo;var SHA512=C_algo.SHA512;var SHA384=C_algo.SHA384=SHA512.extend({_doReset:function(){this._hash=new X64WordArray.init([new X64Word.init(3418070365,3238371032),new X64Word.init(1654270250,914150663),new X64Word.init(2438529370,812702999),new X64Word.init(355462360,4144912697),new X64Word.init(1731405415,4290775857),new X64Word.init(2394180231,1750603025),new X64Word.init(3675008525,1694076839),new X64Word.init(1203062813,3204075428)])},_doFinalize:function(){var hash=SHA512._doFinalize.call(this);hash.sigBytes-=16;return hash}});C.SHA384=SHA512._createHelper(SHA384);C.HmacSHA384=SHA512._createHmacHelper(SHA384)})();return CryptoJS.SHA384})},{"./core":20,"./sha512":50,"./x64-core":52}],50:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./x64-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./x64-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var Hasher=C_lib.Hasher;var C_x64=C.x64;var X64Word=C_x64.Word;var X64WordArray=C_x64.WordArray;var C_algo=C.algo;function X64Word_create(){return X64Word.create.apply(X64Word,arguments)}var K=[X64Word_create(1116352408,3609767458),X64Word_create(1899447441,602891725),X64Word_create(3049323471,3964484399),X64Word_create(3921009573,2173295548),X64Word_create(961987163,4081628472),X64Word_create(1508970993,3053834265),X64Word_create(2453635748,2937671579),X64Word_create(2870763221,3664609560),X64Word_create(3624381080,2734883394),X64Word_create(310598401,1164996542),X64Word_create(607225278,1323610764),X64Word_create(1426881987,3590304994),X64Word_create(1925078388,4068182383),X64Word_create(2162078206,991336113),X64Word_create(2614888103,633803317),X64Word_create(3248222580,3479774868),X64Word_create(3835390401,2666613458),X64Word_create(4022224774,944711139),X64Word_create(264347078,2341262773),X64Word_create(604807628,2007800933),X64Word_create(770255983,1495990901),X64Word_create(1249150122,1856431235),X64Word_create(1555081692,3175218132),X64Word_create(1996064986,2198950837),X64Word_create(2554220882,3999719339),X64Word_create(2821834349,766784016),X64Word_create(2952996808,2566594879),X64Word_create(3210313671,3203337956),X64Word_create(3336571891,1034457026),X64Word_create(3584528711,2466948901),X64Word_create(113926993,3758326383),X64Word_create(338241895,168717936),X64Word_create(666307205,1188179964),X64Word_create(773529912,1546045734),X64Word_create(1294757372,1522805485),X64Word_create(1396182291,2643833823),X64Word_create(1695183700,2343527390),X64Word_create(1986661051,1014477480),X64Word_create(2177026350,1206759142),X64Word_create(2456956037,344077627),X64Word_create(2730485921,1290863460),X64Word_create(2820302411,3158454273),X64Word_create(3259730800,3505952657),X64Word_create(3345764771,106217008),X64Word_create(3516065817,3606008344),X64Word_create(3600352804,1432725776),X64Word_create(4094571909,1467031594),X64Word_create(275423344,851169720),X64Word_create(430227734,3100823752),X64Word_create(506948616,1363258195),X64Word_create(659060556,3750685593),X64Word_create(883997877,3785050280),X64Word_create(958139571,3318307427),X64Word_create(1322822218,3812723403),X64Word_create(1537002063,2003034995),X64Word_create(1747873779,3602036899),X64Word_create(1955562222,1575990012),X64Word_create(2024104815,1125592928),X64Word_create(2227730452,2716904306),X64Word_create(2361852424,442776044),X64Word_create(2428436474,593698344),X64Word_create(2756734187,3733110249),X64Word_create(3204031479,2999351573),X64Word_create(3329325298,3815920427),X64Word_create(3391569614,3928383900),X64Word_create(3515267271,566280711),X64Word_create(3940187606,3454069534),X64Word_create(4118630271,4000239992),X64Word_create(116418474,1914138554),X64Word_create(174292421,2731055270),X64Word_create(289380356,3203993006),X64Word_create(460393269,320620315),X64Word_create(685471733,587496836),X64Word_create(852142971,1086792851),X64Word_create(1017036298,365543100),X64Word_create(1126000580,2618297676),X64Word_create(1288033470,3409855158),X64Word_create(1501505948,4234509866),X64Word_create(1607167915,987167468),X64Word_create(1816402316,1246189591)];var W=[];(function(){for(var i=0;i<80;i++){W[i]=X64Word_create()}})();var SHA512=C_algo.SHA512=Hasher.extend({_doReset:function(){this._hash=new X64WordArray.init([new X64Word.init(1779033703,4089235720),new X64Word.init(3144134277,2227873595),new X64Word.init(1013904242,4271175723),new X64Word.init(2773480762,1595750129),new X64Word.init(1359893119,2917565137),new X64Word.init(2600822924,725511199),new X64Word.init(528734635,4215389547),new X64Word.init(1541459225,327033209)])},_doProcessBlock:function(M,offset){var H=this._hash.words;var H0=H[0];var H1=H[1];var H2=H[2];var H3=H[3];var H4=H[4];var H5=H[5];var H6=H[6];var H7=H[7];var H0h=H0.high;var H0l=H0.low;var H1h=H1.high;var H1l=H1.low;var H2h=H2.high;var H2l=H2.low;var H3h=H3.high;var H3l=H3.low;var H4h=H4.high;var H4l=H4.low;var H5h=H5.high;var H5l=H5.low;var H6h=H6.high;var H6l=H6.low;var H7h=H7.high;var H7l=H7.low;var ah=H0h;var al=H0l;var bh=H1h;var bl=H1l;var ch=H2h;var cl=H2l;var dh=H3h;var dl=H3l;var eh=H4h;var el=H4l;var fh=H5h;var fl=H5l;var gh=H6h;var gl=H6l;var hh=H7h;var hl=H7l;for(var i=0;i<80;i++){var Wi=W[i];if(i<16){var Wih=Wi.high=M[offset+i*2]|0;var Wil=Wi.low=M[offset+i*2+1]|0}else{var gamma0x=W[i-15];var gamma0xh=gamma0x.high;var gamma0xl=gamma0x.low;var gamma0h=(gamma0xh>>>1|gamma0xl<<31)^(gamma0xh>>>8|gamma0xl<<24)^gamma0xh>>>7;var gamma0l=(gamma0xl>>>1|gamma0xh<<31)^(gamma0xl>>>8|gamma0xh<<24)^(gamma0xl>>>7|gamma0xh<<25);var gamma1x=W[i-2];var gamma1xh=gamma1x.high;var gamma1xl=gamma1x.low;var gamma1h=(gamma1xh>>>19|gamma1xl<<13)^(gamma1xh<<3|gamma1xl>>>29)^gamma1xh>>>6;var gamma1l=(gamma1xl>>>19|gamma1xh<<13)^(gamma1xl<<3|gamma1xh>>>29)^(gamma1xl>>>6|gamma1xh<<26);var Wi7=W[i-7];var Wi7h=Wi7.high;var Wi7l=Wi7.low;var Wi16=W[i-16];var Wi16h=Wi16.high;var Wi16l=Wi16.low;var Wil=gamma0l+Wi7l;var Wih=gamma0h+Wi7h+(Wil>>>0<gamma0l>>>0?1:0);var Wil=Wil+gamma1l;var Wih=Wih+gamma1h+(Wil>>>0<gamma1l>>>0?1:0);var Wil=Wil+Wi16l;var Wih=Wih+Wi16h+(Wil>>>0<Wi16l>>>0?1:0);Wi.high=Wih;Wi.low=Wil}var chh=eh&fh^~eh&gh;var chl=el&fl^~el&gl;var majh=ah&bh^ah&ch^bh&ch;var majl=al&bl^al&cl^bl&cl;var sigma0h=(ah>>>28|al<<4)^(ah<<30|al>>>2)^(ah<<25|al>>>7);var sigma0l=(al>>>28|ah<<4)^(al<<30|ah>>>2)^(al<<25|ah>>>7);var sigma1h=(eh>>>14|el<<18)^(eh>>>18|el<<14)^(eh<<23|el>>>9);var sigma1l=(el>>>14|eh<<18)^(el>>>18|eh<<14)^(el<<23|eh>>>9);var Ki=K[i];var Kih=Ki.high;var Kil=Ki.low;var t1l=hl+sigma1l;var t1h=hh+sigma1h+(t1l>>>0<hl>>>0?1:0);var t1l=t1l+chl;var t1h=t1h+chh+(t1l>>>0<chl>>>0?1:0);var t1l=t1l+Kil;var t1h=t1h+Kih+(t1l>>>0<Kil>>>0?1:0);var t1l=t1l+Wil;var t1h=t1h+Wih+(t1l>>>0<Wil>>>0?1:0);var t2l=sigma0l+majl;var t2h=sigma0h+majh+(t2l>>>0<sigma0l>>>0?1:0);hh=gh;hl=gl;gh=fh;gl=fl;fh=eh;fl=el;el=dl+t1l|0;eh=dh+t1h+(el>>>0<dl>>>0?1:0)|0;dh=ch;dl=cl;ch=bh;cl=bl;bh=ah;bl=al;al=t1l+t2l|0;ah=t1h+t2h+(al>>>0<t1l>>>0?1:0)|0}H0l=H0.low=H0l+al;H0.high=H0h+ah+(H0l>>>0<al>>>0?1:0);H1l=H1.low=H1l+bl;H1.high=H1h+bh+(H1l>>>0<bl>>>0?1:0);H2l=H2.low=H2l+cl;H2.high=H2h+ch+(H2l>>>0<cl>>>0?1:0);H3l=H3.low=H3l+dl;H3.high=H3h+dh+(H3l>>>0<dl>>>0?1:0);H4l=H4.low=H4l+el;H4.high=H4h+eh+(H4l>>>0<el>>>0?1:0);H5l=H5.low=H5l+fl;H5.high=H5h+fh+(H5l>>>0<fl>>>0?1:0);H6l=H6.low=H6l+gl;H6.high=H6h+gh+(H6l>>>0<gl>>>0?1:0);H7l=H7.low=H7l+hl;H7.high=H7h+hh+(H7l>>>0<hl>>>0?1:0)},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;dataWords[(nBitsLeft+128>>>10<<5)+30]=Math.floor(nBitsTotal/4294967296);dataWords[(nBitsLeft+128>>>10<<5)+31]=nBitsTotal;data.sigBytes=dataWords.length*4;this._process();var hash=this._hash.toX32();return hash},clone:function(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone},blockSize:1024/32});C.SHA512=Hasher._createHelper(SHA512);C.HmacSHA512=Hasher._createHmacHelper(SHA512)})();return CryptoJS.SHA512})},{"./core":20,"./x64-core":52}],51:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./evpkdf"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var BlockCipher=C_lib.BlockCipher;var C_algo=C.algo;var PC1=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4];var PC2=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32];var BIT_SHIFTS=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28];var SBOX_P=[{0:8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{0:1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{0:260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{0:2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{0:128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{0:268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{0:1048576,16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{0:134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}];
var SBOX_MASK=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679];var DES=C_algo.DES=BlockCipher.extend({_doReset:function(){var key=this._key;var keyWords=key.words;var keyBits=[];for(var i=0;i<56;i++){var keyBitPos=PC1[i]-1;keyBits[i]=keyWords[keyBitPos>>>5]>>>31-keyBitPos%32&1}var subKeys=this._subKeys=[];for(var nSubKey=0;nSubKey<16;nSubKey++){var subKey=subKeys[nSubKey]=[];var bitShift=BIT_SHIFTS[nSubKey];for(var i=0;i<24;i++){subKey[i/6|0]|=keyBits[(PC2[i]-1+bitShift)%28]<<31-i%6;subKey[4+(i/6|0)]|=keyBits[28+(PC2[i+24]-1+bitShift)%28]<<31-i%6}subKey[0]=subKey[0]<<1|subKey[0]>>>31;for(var i=1;i<7;i++){subKey[i]=subKey[i]>>>(i-1)*4+3}subKey[7]=subKey[7]<<5|subKey[7]>>>27}var invSubKeys=this._invSubKeys=[];for(var i=0;i<16;i++){invSubKeys[i]=subKeys[15-i]}},encryptBlock:function(M,offset){this._doCryptBlock(M,offset,this._subKeys)},decryptBlock:function(M,offset){this._doCryptBlock(M,offset,this._invSubKeys)},_doCryptBlock:function(M,offset,subKeys){this._lBlock=M[offset];this._rBlock=M[offset+1];exchangeLR.call(this,4,252645135);exchangeLR.call(this,16,65535);exchangeRL.call(this,2,858993459);exchangeRL.call(this,8,16711935);exchangeLR.call(this,1,1431655765);for(var round=0;round<16;round++){var subKey=subKeys[round];var lBlock=this._lBlock;var rBlock=this._rBlock;var f=0;for(var i=0;i<8;i++){f|=SBOX_P[i][((rBlock^subKey[i])&SBOX_MASK[i])>>>0]}this._lBlock=rBlock;this._rBlock=lBlock^f}var t=this._lBlock;this._lBlock=this._rBlock;this._rBlock=t;exchangeLR.call(this,1,1431655765);exchangeRL.call(this,8,16711935);exchangeRL.call(this,2,858993459);exchangeLR.call(this,16,65535);exchangeLR.call(this,4,252645135);M[offset]=this._lBlock;M[offset+1]=this._rBlock},keySize:64/32,ivSize:64/32,blockSize:64/32});function exchangeLR(offset,mask){var t=(this._lBlock>>>offset^this._rBlock)&mask;this._rBlock^=t;this._lBlock^=t<<offset}function exchangeRL(offset,mask){var t=(this._rBlock>>>offset^this._lBlock)&mask;this._lBlock^=t;this._rBlock^=t<<offset}C.DES=BlockCipher._createHelper(DES);var TripleDES=C_algo.TripleDES=BlockCipher.extend({_doReset:function(){var key=this._key;var keyWords=key.words;this._des1=DES.createEncryptor(WordArray.create(keyWords.slice(0,2)));this._des2=DES.createEncryptor(WordArray.create(keyWords.slice(2,4)));this._des3=DES.createEncryptor(WordArray.create(keyWords.slice(4,6)))},encryptBlock:function(M,offset){this._des1.encryptBlock(M,offset);this._des2.decryptBlock(M,offset);this._des3.encryptBlock(M,offset)},decryptBlock:function(M,offset){this._des3.decryptBlock(M,offset);this._des2.encryptBlock(M,offset);this._des1.decryptBlock(M,offset)},keySize:192/32,ivSize:64/32,blockSize:64/32});C.TripleDES=BlockCipher._createHelper(TripleDES)})();return CryptoJS.TripleDES})},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":29}],52:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(undefined){var C=CryptoJS;var C_lib=C.lib;var Base=C_lib.Base;var X32WordArray=C_lib.WordArray;var C_x64=C.x64={};var X64Word=C_x64.Word=Base.extend({init:function(high,low){this.high=high;this.low=low}});var X64WordArray=C_x64.WordArray=Base.extend({init:function(words,sigBytes){words=this.words=words||[];if(sigBytes!=undefined){this.sigBytes=sigBytes}else{this.sigBytes=words.length*8}},toX32:function(){var x64Words=this.words;var x64WordsLength=x64Words.length;var x32Words=[];for(var i=0;i<x64WordsLength;i++){var x64Word=x64Words[i];x32Words.push(x64Word.high);x32Words.push(x64Word.low)}return X32WordArray.create(x32Words,this.sigBytes)},clone:function(){var clone=Base.clone.call(this);var words=clone.words=this.words.slice(0);var wordsLength=words.length;for(var i=0;i<wordsLength;i++){words[i]=words[i].clone()}return clone}})})();return CryptoJS})},{"./core":20}],53:[function(_dereq_,module,exports){(function(process){!function(globals){"use strict";if(typeof define!=="undefined"&&define.amd){define([],function(){return secureRandom})}else if(typeof module!=="undefined"&&module.exports){module.exports=secureRandom}else{globals.secureRandom=secureRandom}function secureRandom(count,options){options=options||{};if(typeof process!="undefined"&&typeof process.pid=="number"){return nodeRandom(count,options)}else{if(!window.crypto)throw new Error("Your browser does not support window.crypto.");return browserRandom(count,options)}}function nodeRandom(count,options){var crypto=_dereq_("crypto");var buf=crypto.randomBytes(count);if(options.array)var ret=[];else var ret=new Uint8Array(count);for(var i=0;i<count;++i){ret[i]=buf.readUInt8(i)}return ret}function browserRandom(count,options){var nativeArr=new Uint8Array(count);window.crypto.getRandomValues(nativeArr);if(options.array){var ret=[];for(var i=0;i<nativeArr.length;++i){ret[i]=nativeArr[i]}}else{ret=nativeArr}return ret}}(this)}).call(this,_dereq_("FWaASH"))},{FWaASH:15,crypto:4}],54:[function(_dereq_,module,exports){var base58=_dereq_("./base58");var base58check=_dereq_("./base58check");var convert=_dereq_("./convert");var error=_dereq_("./util").error;var mainnet=_dereq_("./network").mainnet.addressVersion;function Address(bytes,version){if(!(this instanceof Address)){return new Address(bytes,version)}if(bytes instanceof Address){this.hash=bytes.hash;this.version=bytes.version}else if(typeof bytes==="string"){if(bytes.length<=35){var decode=base58check.decode(bytes);this.hash=decode.payload;this.version=decode.version}else if(bytes.length<=40){this.hash=convert.hexToBytes(bytes);this.version=version||mainnet}else{error("invalid or unrecognized input")}}else{this.hash=bytes;this.version=version||mainnet}}Address.prototype.toString=function(){return base58check.encode(this.hash.slice(0),this.version)};Address.getVersion=function(address){return base58.decode(address)[0]};Address.validate=function(address){try{base58check.decode(address);return true}catch(e){return false}};module.exports=Address},{"./base58":55,"./base58check":56,"./convert":57,"./network":66,"./util":70}],55:[function(_dereq_,module,exports){(function(Buffer){var BigInteger=_dereq_("./jsbn/jsbn");var alphabet="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";var base=BigInteger.valueOf(58);var alphabetMap={};for(var i=0;i<alphabet.length;++i){var chr=alphabet[i];alphabetMap[chr]=BigInteger.valueOf(i)}function encode(buffer){var bi=BigInteger.fromByteArrayUnsigned(buffer);var chars=[];while(bi.compareTo(base)>=0){var mod=bi.mod(base);bi=bi.subtract(mod).divide(base);chars.push(alphabet[mod.intValue()])}chars.push(alphabet[bi.intValue()]);for(var i=0;i<buffer.length;i++){if(buffer[i]!==0)break;chars.push(alphabet[0])}return chars.reverse().join("")}function decode(str){var num=BigInteger.valueOf(0);var leading_zero=0;var seen_other=false;for(var i=0;i<str.length;++i){var chr=str[i];var bi=alphabetMap[chr];if(bi===undefined){throw new Error("invalid base58 string: "+str)}num=num.multiply(base).add(bi);if(chr==="1"&&!seen_other){++leading_zero}else{seen_other=true}}var bytes=num.toByteArrayUnsigned();while(leading_zero-->0){bytes.unshift(0)}return new Buffer(bytes)}module.exports={encode:encode,decode:decode}}).call(this,_dereq_("buffer").Buffer)},{"./jsbn/jsbn":63,buffer:5}],56:[function(_dereq_,module,exports){(function(Buffer){var assert=_dereq_("assert");var base58=_dereq_("./base58");var crypto=_dereq_("crypto");function sha256(buf){var hash=crypto.createHash("sha256");hash.update(buf);return hash.digest()}function encode(buffer,version){version=version||0;var version=new Buffer([version]);var payload=new Buffer(buffer);var message=Buffer.concat([version,payload]);var checksum=sha256(sha256(message)).slice(0,4);return base58.encode(Buffer.concat([message,checksum]))}function decode(string){var buffer=base58.decode(string);var message=buffer.slice(0,-4);var checksum=buffer.slice(-4);var newChecksum=sha256(sha256(message)).slice(0,4);assert.deepEqual(newChecksum,checksum);var version=message.readUInt8(0);var payload=message.slice(1);return{version:version,payload:payload,checksum:checksum}}module.exports={encode:encode,decode:decode}}).call(this,_dereq_("buffer").Buffer)},{"./base58":55,assert:1,buffer:5,crypto:9}],57:[function(_dereq_,module,exports){(function(Buffer){var Crypto=_dereq_("crypto-js");var WordArray=Crypto.lib.WordArray;var base64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";function lpad(str,padString,length){while(str.length<length)str=padString+str;return str}function bytesToHex(bytes){if(Buffer.isBuffer(bytes)){return bytes.toString("hex")}return bytes.map(function(x){return lpad(x.toString(16),"0",2)}).join("")}function hexToBytes(hex){return hex.match(/../g).map(function(x){return parseInt(x,16)})}function bytesToBase64(bytes){var base64=[];for(var i=0;i<bytes.length;i+=3){var triplet=bytes[i]<<16|bytes[i+1]<<8|bytes[i+2];for(var j=0;j<4;j++){if(i*8+j*6<=bytes.length*8){base64.push(base64map.charAt(triplet>>>6*(3-j)&63))}else{base64.push("=")}}}return base64.join("")}function base64ToBytes(base64){base64=base64.replace(/[^A-Z0-9+\/]/gi,"");var bytes=[];var imod4=0;for(var i=0;i<base64.length;imod4=++i%4){if(!imod4)continue;bytes.push((base64map.indexOf(base64.charAt(i-1))&Math.pow(2,-2*imod4+8)-1)<<imod4*2|base64map.indexOf(base64.charAt(i))>>>6-imod4*2)}return bytes}function coerceToBytes(input){if(typeof input!="string")return input;return hexToBytes(input)}function binToBytes(bin){return bin.match(/......../g).map(function(x){return parseInt(x,2)})}function bytesToBin(bytes){return bytes.map(function(x){return lpad(x.toString(2),"0",8)}).join("")}function bytesToString(bytes){return bytes.map(function(x){return String.fromCharCode(x)}).join("")}function stringToBytes(string){return string.split("").map(function(x){return x.charCodeAt(0)})}function numToBytes(num,bytes){if(bytes===undefined)bytes=8;if(bytes===0)return[];return[num%256].concat(numToBytes(Math.floor(num/256),bytes-1))}function bytesToNum(bytes){if(bytes.length===0)return 0;return bytes[0]+256*bytesToNum(bytes.slice(1))}function numToVarInt(num){if(num<253)return[num];if(num<65536)return[253].concat(numToBytes(num,2));if(num<4294967296)return[254].concat(numToBytes(num,4));return[255].concat(numToBytes(num,8))}function varIntToNum(bytes){var prefix=bytes[0];var viBytes=prefix<253?bytes.slice(0,1):prefix===253?bytes.slice(1,3):prefix===254?bytes.slice(1,5):bytes.slice(1,9);return{bytes:prefix<253?viBytes:bytes.slice(0,viBytes.length+1),number:bytesToNum(viBytes)}}function bytesToWords(bytes){var words=[];for(var i=0,b=0;i<bytes.length;i++,b+=8){words[b>>>5]|=bytes[i]<<24-b%32}return words}function wordsToBytes(words){var bytes=[];for(var b=0;b<words.length*32;b+=8){bytes.push(words[b>>>5]>>>24-b%32&255)}return bytes}function bytesToWordArray(bytes){return new WordArray.init(bytesToWords(bytes),bytes.length)}function wordArrayToBytes(wordArray){return wordsToBytes(wordArray.words)}function reverseEndian(hex){return bytesToHex(hexToBytes(hex).reverse())}module.exports={lpad:lpad,bytesToHex:bytesToHex,hexToBytes:hexToBytes,bytesToBase64:bytesToBase64,base64ToBytes:base64ToBytes,coerceToBytes:coerceToBytes,binToBytes:binToBytes,bytesToBin:bytesToBin,bytesToString:bytesToString,stringToBytes:stringToBytes,numToBytes:numToBytes,bytesToNum:bytesToNum,numToVarInt:numToVarInt,varIntToNum:varIntToNum,bytesToWords:bytesToWords,wordsToBytes:wordsToBytes,bytesToWordArray:bytesToWordArray,wordArrayToBytes:wordArrayToBytes,reverseEndian:reverseEndian}}).call(this,_dereq_("buffer").Buffer)},{buffer:5,"crypto-js":27}],58:[function(_dereq_,module,exports){var sec=_dereq_("./jsbn/sec");var rng=_dereq_("secure-random");var BigInteger=_dereq_("./jsbn/jsbn");var convert=_dereq_("./convert");var HmacSHA256=_dereq_("crypto-js/hmac-sha256");var ECPointFp=_dereq_("./jsbn/ec").ECPointFp;var ecparams=sec("secp256k1");var P_OVER_FOUR=null;function implShamirsTrick(P,k,Q,l){var m=Math.max(k.bitLength(),l.bitLength());var Z=P.add2D(Q);var R=P.curve.getInfinity();for(var i=m-1;i>=0;--i){R=R.twice2D();R.z=BigInteger.ONE;if(k.testBit(i)){if(l.testBit(i)){R=R.add2D(Z)}else{R=R.add2D(P)}}else{if(l.testBit(i)){R=R.add2D(Q)}}}return R}function deterministicGenerateK(hash,key){var vArr=[];var kArr=[];for(var i=0;i<32;i++)vArr.push(1);for(var i=0;i<32;i++)kArr.push(0);var v=convert.bytesToWordArray(vArr);var k=convert.bytesToWordArray(kArr);k=HmacSHA256(convert.bytesToWordArray(vArr.concat([0]).concat(key).concat(hash)),k);v=HmacSHA256(v,k);vArr=convert.wordArrayToBytes(v);k=HmacSHA256(convert.bytesToWordArray(vArr.concat([1]).concat(key).concat(hash)),k);v=HmacSHA256(v,k);v=HmacSHA256(v,k);vArr=convert.wordArrayToBytes(v);return BigInteger.fromByteArrayUnsigned(vArr)}var ECDSA={getBigRandom:function(limit){return new BigInteger(limit.bitLength(),rng).mod(limit.subtract(BigInteger.ONE)).add(BigInteger.ONE)},sign:function(hash,priv){var d=priv;var n=ecparams.getN();var e=BigInteger.fromByteArrayUnsigned(hash);var k=deterministicGenerateK(hash,priv.toByteArrayUnsigned());var G=ecparams.getG();var Q=G.multiply(k);var r=Q.getX().toBigInteger().mod(n);var s=k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);return ECDSA.serializeSig(r,s)},verify:function(hash,sig,pubkey){var r,s;if(Array.isArray(sig)){var obj=ECDSA.parseSig(sig);r=obj.r;s=obj.s}else if("object"===typeof sig&&sig.r&&sig.s){r=sig.r;s=sig.s}else{throw new Error("Invalid value for signature")}var Q;if(pubkey instanceof ECPointFp){Q=pubkey}else if(Array.isArray(pubkey)){Q=ECPointFp.decodeFrom(ecparams.getCurve(),pubkey)}else{throw new Error("Invalid format for pubkey value, must be byte array or ECPointFp")}var e=BigInteger.fromByteArrayUnsigned(hash);return ECDSA.verifyRaw(e,r,s,Q)},verifyRaw:function(e,r,s,Q){var n=ecparams.getN();var G=ecparams.getG();if(r.compareTo(BigInteger.ONE)<0||r.compareTo(n)>=0){return false}if(s.compareTo(BigInteger.ONE)<0||s.compareTo(n)>=0){return false}var c=s.modInverse(n);var u1=e.multiply(c).mod(n);var u2=r.multiply(c).mod(n);var point=G.multiply(u1).add(Q.multiply(u2));var v=point.getX().toBigInteger().mod(n);return v.equals(r)},serializeSig:function(r,s){var rBa=r.toByteArraySigned();var sBa=s.toByteArraySigned();var sequence=[];sequence.push(2);sequence.push(rBa.length);sequence=sequence.concat(rBa);sequence.push(2);sequence.push(sBa.length);sequence=sequence.concat(sBa);sequence.unshift(sequence.length);sequence.unshift(48);return sequence},parseSig:function(sig){var cursor;if(sig[0]!=48){throw new Error("Signature not a valid DERSequence")}cursor=2;if(sig[cursor]!=2){throw new Error("First element in signature must be a DERInteger")}var rBa=sig.slice(cursor+2,cursor+2+sig[cursor+1]);cursor+=2+sig[cursor+1];if(sig[cursor]!=2){throw new Error("Second element in signature must be a DERInteger")}var sBa=sig.slice(cursor+2,cursor+2+sig[cursor+1]);cursor+=2+sig[cursor+1];var r=BigInteger.fromByteArrayUnsigned(rBa);var s=BigInteger.fromByteArrayUnsigned(sBa);return{r:r,s:s}},parseSigCompact:function(sig){if(sig.length!==65){throw new Error("Signature has the wrong length")}var i=sig[0]-27;if(i<0||i>7){throw new Error("Invalid signature type")}var n=ecparams.getN();var r=BigInteger.fromByteArrayUnsigned(sig.slice(1,33)).mod(n);var s=BigInteger.fromByteArrayUnsigned(sig.slice(33,65)).mod(n);return{r:r,s:s,i:i}},recoverPubKey:function(r,s,hash,i){i=i&3;var isYEven=i&1;var isSecondKey=i>>1;var n=ecparams.getN();var G=ecparams.getG();var curve=ecparams.getCurve();var p=curve.getQ();var a=curve.getA().toBigInteger();var b=curve.getB().toBigInteger();if(!P_OVER_FOUR){P_OVER_FOUR=p.add(BigInteger.ONE).divide(BigInteger.valueOf(4))}var x=isSecondKey?r.add(n):r;var alpha=x.multiply(x).multiply(x).add(a.multiply(x)).add(b).mod(p);var beta=alpha.modPow(P_OVER_FOUR,p);var y=(beta.isEven()?!isYEven:isYEven)?beta:p.subtract(beta);var R=new ECPointFp(curve,curve.fromBigInteger(x),curve.fromBigInteger(y));R.validate();var e=BigInteger.fromByteArrayUnsigned(hash);var eNeg=BigInteger.ZERO.subtract(e).mod(n);var rInv=r.modInverse(n);var Q=implShamirsTrick(R,s,G,eNeg).multiply(rInv);Q.validate();if(!ECDSA.verifyRaw(e,r,s,Q)){throw new Error("Pubkey recovery unsuccessful")}return Q},calcPubKeyRecoveryParam:function(origPubKey,r,s,hash){for(var i=0;i<4;i++){var pubKey=ECDSA.recoverPubKey(r,s,hash,i);if(pubKey.equals(origPubKey)){return i}}throw new Error("Unable to find valid recovery factor")}};module.exports=ECDSA},{"./convert":57,"./jsbn/ec":62,"./jsbn/jsbn":63,"./jsbn/sec":64,"crypto-js/hmac-sha256":25,"secure-random":53}],59:[function(_dereq_,module,exports){var Address=_dereq_("./address");var assert=_dereq_("assert");var convert=_dereq_("./convert");var base58check=_dereq_("./base58check");var BigInteger=_dereq_("./jsbn/jsbn");var ecdsa=_dereq_("./ecdsa");var ECPointFp=_dereq_("./jsbn/ec").ECPointFp;var sec=_dereq_("./jsbn/sec");var Network=_dereq_("./network");var util=_dereq_("./util");var ecparams=sec("secp256k1");var ECKey=function(input,compressed){if(!(this instanceof ECKey)){return new ECKey(input,compressed)}if(!input){var n=ecparams.getN();this.priv=ecdsa.getBigRandom(n);this.compressed=compressed||false}else this.import(input,compressed)};ECKey.prototype.import=function(input,compressed){function has(li,v){return li.indexOf(v)>=0}function fromBin(x){return BigInteger.fromByteArrayUnsigned(x)}this.priv=input instanceof ECKey?input.priv:input instanceof BigInteger?input.mod(ecparams.getN()):Array.isArray(input)?fromBin(input.slice(0,32)):typeof input!="string"?null:input.length==44?fromBin(convert.base64ToBytes(input)):input.length==51&&input[0]=="5"?fromBin(base58check.decode(input).payload):input.length==51&&input[0]=="9"?fromBin(base58check.decode(input).payload):input.length==52&&has("LK",input[0])?fromBin(base58check.decode(input).payload.slice(0,32)):input.length==52&&input[0]=="c"?fromBin(base58check.decode(input).payload.slice(0,32)):has([64,65],input.length)?fromBin(convert.hexToBytes(input.slice(0,64))):null;assert(this.priv!==null);this.compressed=compressed!==undefined?compressed:input instanceof ECKey?input.compressed:input instanceof BigInteger?false:Array.isArray(input)?false:typeof input!="string"?null:input.length==44?false:input.length==51&&input[0]=="5"?false:input.length==51&&input[0]=="9"?false:input.length==52&&has("LK",input[0])?true:input.length==52&&input[0]=="c"?true:input.length==64?false:input.length==65?true:null;assert(this.compressed!==null)};ECKey.prototype.getPub=function(compressed){if(compressed===undefined)compressed=this.compressed;return ECPubKey(ecparams.getG().multiply(this.priv),compressed)};ECKey.prototype.toBin=function(){return convert.bytesToString(this.toBytes())};ECKey.version_bytes={0:128,111:239};ECKey.prototype.toWif=function(version){version=version||Network.mainnet.addressVersion;return base58check.encode(this.toBytes(),ECKey.version_bytes[version])};ECKey.prototype.toHex=function(){return convert.bytesToHex(this.toBytes())};ECKey.prototype.toBytes=function(){var bytes=this.priv.toByteArrayUnsigned();if(this.compressed)bytes.push(1);return bytes};ECKey.prototype.toBase64=function(){return convert.bytesToBase64(this.toBytes())};ECKey.prototype.toString=ECKey.prototype.toHex;ECKey.prototype.getAddress=function(version){return this.getPub().getAddress(version)};ECKey.prototype.add=function(key){return ECKey(this.priv.add(ECKey(key).priv),this.compressed)};ECKey.prototype.multiply=function(key){return ECKey(this.priv.multiply(ECKey(key).priv),this.compressed)};ECKey.prototype.sign=function(hash){return ecdsa.sign(hash,this.priv)};ECKey.prototype.verify=function(hash,sig){return this.getPub().verify(hash,sig)};var ECPubKey=function(input,compressed){if(!(this instanceof ECPubKey)){return new ECPubKey(input,compressed)}this.import(input,compressed)};ECPubKey.prototype.import=function(input,compressed){var decode=function(x){return ECPointFp.decodeFrom(ecparams.getCurve(),x)};this.pub=input instanceof ECPointFp?input:input instanceof ECKey?ecparams.getG().multiply(input.priv):input instanceof ECPubKey?input.pub:typeof input=="string"?decode(convert.hexToBytes(input)):Array.isArray(input)?decode(input):null;assert(this.pub!==null);this.compressed=compressed?compressed:input instanceof ECPointFp?input.compressed:input instanceof ECPubKey?input.compressed:this.pub[0]<4};ECPubKey.prototype.add=function(key){return ECPubKey(this.pub.add(ECPubKey(key).pub),this.compressed)};ECPubKey.prototype.multiply=function(key){return ECPubKey(this.pub.multiply(ECKey(key).priv),this.compressed)};ECPubKey.prototype.toBytes=function(compressed){if(compressed===undefined)compressed=this.compressed;return this.pub.getEncoded(compressed)};ECPubKey.prototype.toHex=function(compressed){return convert.bytesToHex(this.toBytes(compressed))};ECPubKey.prototype.toBin=function(compressed){return convert.bytesToString(this.toBytes(compressed))};ECPubKey.prototype.toWif=function(version){version=version||Network.mainnet.addressVersion;return base58check.encode(this.toBytes(),version)};ECPubKey.prototype.toString=ECPubKey.prototype.toHex;ECPubKey.prototype.getAddress=function(version){version=version||Network.mainnet.addressVersion;return new Address(util.sha256ripe160(this.toBytes()),version)};ECPubKey.prototype.verify=function(hash,sig){return ecdsa.verify(hash,sig,this.toBytes())};module.exports={ECKey:ECKey,ECPubKey:ECPubKey}},{"./address":54,"./base58check":56,"./convert":57,"./ecdsa":58,"./jsbn/ec":62,"./jsbn/jsbn":63,"./jsbn/sec":64,"./network":66,"./util":70,assert:1}],60:[function(_dereq_,module,exports){(function(Buffer){var convert=_dereq_("./convert.js");var base58=_dereq_("./base58.js");var assert=_dereq_("assert");var format=_dereq_("util").format;var util=_dereq_("./util.js");var Crypto=_dereq_("crypto-js");var HmacSHA512=Crypto.HmacSHA512;var HMAC=Crypto.algo.HMAC;var ECKey=_dereq_("./eckey.js").ECKey;var ECPubKey=_dereq_("./eckey.js").ECPubKey;var Address=_dereq_("./address.js");var Network=_dereq_("./network");var crypto=_dereq_("crypto");function sha256(buf){var hash=crypto.createHash("sha256");hash.update(buf);return hash.digest()}function HDWallet(seed,network){if(seed===undefined)return;var seedWords=convert.bytesToWordArray(seed);var I=convert.wordArrayToBytes(HmacSHA512(seedWords,"Bitcoin seed"));this.chaincode=I.slice(32);this.network=network||"mainnet";if(!Network.hasOwnProperty(this.network)){throw new Error("Unknown network: "+this.network)}this.priv=new ECKey(I.slice(0,32).concat([1]),true);this.pub=this.priv.getPub();this.index=0;this.depth=0}HDWallet.HIGHEST_BIT=2147483648;HDWallet.LENGTH=78;function arrayEqual(a,b){return!(a<b||a>b)}HDWallet.fromSeedHex=function(hex,network){return new HDWallet(convert.hexToBytes(hex),network)};HDWallet.fromSeedString=function(string,network){return new HDWallet(convert.stringToBytes(string),network)};HDWallet.fromBase58=function(string){var buffer=base58.decode(string);var payload=buffer.slice(0,-4);var checksum=buffer.slice(-4);var newChecksum=sha256(sha256(payload)).slice(0,4);assert.deepEqual(newChecksum,checksum);assert.equal(payload.length,HDWallet.LENGTH);return HDWallet.fromBytes(payload)};HDWallet.fromHex=function(input){return HDWallet.fromBytes(convert.hexToBytes(input))};HDWallet.fromBytes=function(input){if(input.length!=HDWallet.LENGTH){throw new Error(format("Invalid input length, %s. Expected %s.",input.length,HDWallet.LENGTH))}if(Buffer.isBuffer(input)){input=Array.prototype.map.bind(input,function(x){return x})()}var hd=new HDWallet;var versionBytes=input.slice(0,4);var versionWord=convert.bytesToWords(versionBytes)[0];var type;for(var name in Network){var network=Network[name];for(var t in network.hdVersions){if(versionWord!=network.hdVersions[t])continue;type=t;hd.network=name}}if(!hd.network){throw new Error(format("Could not find version %s",convert.bytesToHex(versionBytes)))}hd.depth=input[4];hd.parentFingerprint=input.slice(5,9);assert(hd.depth===0==arrayEqual(hd.parentFingerprint,[0,0,0,0]));hd.index=convert.bytesToNum(input.slice(9,13).reverse());assert(hd.depth>0||hd.index===0);hd.chaincode=input.slice(13,45);if(type=="priv"){hd.priv=new ECKey(input.slice(46,78).concat([1]),true);hd.pub=hd.priv.getPub()}else{hd.pub=new ECPubKey(input.slice(45,78),true)}return hd};HDWallet.prototype.getIdentifier=function(){return util.sha256ripe160(this.pub.toBytes())};HDWallet.prototype.getFingerprint=function(){return this.getIdentifier().slice(0,4)};HDWallet.prototype.getAddress=function(){return new Address(util.sha256ripe160(this.pub.toBytes()),this.getKeyVersion())};HDWallet.prototype.toBytes=function(priv){var buffer=[];var version=Network[this.network].hdVersions[priv?"priv":"pub"];var vBytes=convert.wordsToBytes([version]);buffer=buffer.concat(vBytes);assert.equal(buffer.length,4);buffer.push(this.depth);assert.equal(buffer.length,4+1);buffer=buffer.concat(this.depth?this.parentFingerprint:[0,0,0,0]);assert.equal(buffer.length,4+1+4);buffer=buffer.concat(convert.numToBytes(this.index,4).reverse());assert.equal(buffer.length,4+1+4+4);buffer=buffer.concat(this.chaincode);assert.equal(buffer.length,4+1+4+4+32);if(priv){assert(this.priv,"Cannot serialize to private without private key");buffer.push(0);buffer=buffer.concat(this.priv.toBytes().slice(0,32))}else{buffer=buffer.concat(this.pub.toBytes(true))}return buffer};HDWallet.prototype.toHex=function(priv){var bytes=this.toBytes(priv);return convert.bytesToHex(bytes)};HDWallet.prototype.toBase58=function(priv){var buffer=new Buffer(this.toBytes(priv));var checksum=sha256(sha256(buffer)).slice(0,4);return base58.encode(Buffer.concat([buffer,checksum]))};HDWallet.prototype.derive=function(i){var I,iBytes=convert.numToBytes(i,4).reverse(),cPar=this.chaincode,usePriv=i>=HDWallet.HIGHEST_BIT,SHA512=Crypto.algo.SHA512;if(usePriv){assert(this.priv,"Private derive on public key");var kPar=this.priv.toBytes().slice(0,32);I=HmacFromBytesToBytes(SHA512,[0].concat(kPar,iBytes),cPar)}else{var KPar=this.pub.toBytes(true);I=HmacFromBytesToBytes(SHA512,KPar.concat(iBytes),cPar)}var IL=I.slice(0,32),IR=I.slice(32);var hd=new HDWallet;hd.network=this.network;if(this.priv){hd.priv=this.priv.add(new ECKey(IL.concat([1])));hd.priv.compressed=true;hd.priv.version=this.getKeyVersion();hd.pub=hd.priv.getPub()}else{hd.pub=this.pub.add(new ECKey(IL.concat([1]),true).getPub())}hd.chaincode=IR;hd.parentFingerprint=this.getFingerprint();hd.depth=this.depth+1;hd.index=i;hd.pub.compressed=true;return hd};HDWallet.prototype.derivePrivate=function(index){return this.derive(index+HDWallet.HIGHEST_BIT)};HDWallet.prototype.getKeyVersion=function(){return Network[this.network].addressVersion};HDWallet.prototype.toString=HDWallet.prototype.toBase58;function HmacFromBytesToBytes(hasher,message,key){var hmac=HMAC.create(hasher,convert.bytesToWordArray(key));hmac.update(convert.bytesToWordArray(message));return convert.wordArrayToBytes(hmac.finalize())}module.exports=HDWallet}).call(this,_dereq_("buffer").Buffer)},{"./address.js":54,"./base58.js":55,"./convert.js":57,"./eckey.js":59,"./network":66,"./util.js":70,assert:1,buffer:5,crypto:9,"crypto-js":27,util:17}],61:[function(_dereq_,module,exports){var Key=_dereq_("./eckey");var T=_dereq_("./transaction");module.exports={Address:_dereq_("./address"),Key:Key.ECKey,ECKey:Key.ECKey,ECPubKey:Key.ECPubKey,Message:_dereq_("./message"),BigInteger:_dereq_("./jsbn/jsbn"),Crypto:_dereq_("crypto-js"),Script:_dereq_("./script"),Opcode:_dereq_("./opcode"),Transaction:T.Transaction,Util:_dereq_("./util"),TransactionIn:T.TransactionIn,TransactionOut:T.TransactionOut,ECPointFp:_dereq_("./jsbn/ec").ECPointFp,Wallet:_dereq_("./wallet"),network:_dereq_("./network"),ecdsa:_dereq_("./ecdsa"),HDWallet:_dereq_("./hdwallet.js"),base58:_dereq_("./base58"),base58check:_dereq_("./base58check"),convert:_dereq_("./convert")}},{"./address":54,"./base58":55,"./base58check":56,"./convert":57,"./ecdsa":58,"./eckey":59,"./hdwallet.js":60,"./jsbn/ec":62,"./jsbn/jsbn":63,"./message":65,"./network":66,"./opcode":67,"./script":68,"./transaction":69,"./util":70,"./wallet":71,"crypto-js":27}],62:[function(_dereq_,module,exports){var BigInteger=_dereq_("./jsbn"),sec=_dereq_("./sec");function ECFieldElementFp(q,x){this.x=x;this.q=q}function feFpEquals(other){if(other==this)return true;return this.q.equals(other.q)&&this.x.equals(other.x)}function feFpToBigInteger(){return this.x}function feFpNegate(){return new ECFieldElementFp(this.q,this.x.negate().mod(this.q))}function feFpAdd(b){return new ECFieldElementFp(this.q,this.x.add(b.toBigInteger()).mod(this.q))}function feFpSubtract(b){return new ECFieldElementFp(this.q,this.x.subtract(b.toBigInteger()).mod(this.q))}function feFpMultiply(b){return new ECFieldElementFp(this.q,this.x.multiply(b.toBigInteger()).mod(this.q))}function feFpSquare(){return new ECFieldElementFp(this.q,this.x.square().mod(this.q))}function feFpDivide(b){return new ECFieldElementFp(this.q,this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q))}ECFieldElementFp.prototype.equals=feFpEquals;ECFieldElementFp.prototype.toBigInteger=feFpToBigInteger;ECFieldElementFp.prototype.negate=feFpNegate;ECFieldElementFp.prototype.add=feFpAdd;ECFieldElementFp.prototype.subtract=feFpSubtract;ECFieldElementFp.prototype.multiply=feFpMultiply;ECFieldElementFp.prototype.square=feFpSquare;ECFieldElementFp.prototype.divide=feFpDivide;function ECPointFp(curve,x,y,z){this.curve=curve;this.x=x;this.y=y;if(z==null){this.z=BigInteger.ONE}else{this.z=z}this.zinv=null}function pointFpGetX(){if(this.zinv==null){this.zinv=this.z.modInverse(this.curve.q)}return this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q))}function pointFpGetY(){if(this.zinv==null){this.zinv=this.z.modInverse(this.curve.q)}return this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q))}function pointFpEquals(other){if(other==this)return true;if(this.isInfinity())return other.isInfinity();if(other.isInfinity())return this.isInfinity();var u,v;u=other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);if(!u.equals(BigInteger.ZERO))return false;v=other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);return v.equals(BigInteger.ZERO)}function pointFpIsInfinity(){if(this.x==null&&this.y==null)return true;return this.z.equals(BigInteger.ZERO)&&!this.y.toBigInteger().equals(BigInteger.ZERO)}function pointFpNegate(){return new ECPointFp(this.curve,this.x,this.y.negate(),this.z)}function pointFpAdd(b){if(this.isInfinity())return b;if(b.isInfinity())return this;var u=b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);var v=b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);if(BigInteger.ZERO.equals(v)){if(BigInteger.ZERO.equals(u)){return this.twice()}return this.curve.getInfinity()}var THREE=new BigInteger("3");var x1=this.x.toBigInteger();var y1=this.y.toBigInteger();var x2=b.x.toBigInteger();var y2=b.y.toBigInteger();var v2=v.square();var v3=v2.multiply(v);var x1v2=x1.multiply(v2);var zu2=u.square().multiply(this.z);var x3=zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);var y3=x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);var z3=v3.multiply(this.z).multiply(b.z).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(x3),this.curve.fromBigInteger(y3),z3)}function pointFpTwice(){if(this.isInfinity())return this;if(this.y.toBigInteger().signum()==0)return this.curve.getInfinity();var THREE=new BigInteger("3");var x1=this.x.toBigInteger();var y1=this.y.toBigInteger();var y1z1=y1.multiply(this.z);var y1sqz1=y1z1.multiply(y1).mod(this.curve.q);var a=this.curve.a.toBigInteger();
var w=x1.square().multiply(THREE);if(!BigInteger.ZERO.equals(a)){w=w.add(this.z.square().multiply(a))}w=w.mod(this.curve.q);var x3=w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);var y3=w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);var z3=y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(x3),this.curve.fromBigInteger(y3),z3)}function pointFpMultiply(k){if(this.isInfinity())return this;if(k.signum()==0)return this.curve.getInfinity();var e=k;var h=e.multiply(new BigInteger("3"));var neg=this.negate();var R=this;var i;for(i=h.bitLength()-2;i>0;--i){R=R.twice();var hBit=h.testBit(i);var eBit=e.testBit(i);if(hBit!=eBit){R=R.add(hBit?this:neg)}}return R}function pointFpMultiplyTwo(j,x,k){var i;if(j.bitLength()>k.bitLength())i=j.bitLength()-1;else i=k.bitLength()-1;var R=this.curve.getInfinity();var both=this.add(x);while(i>=0){R=R.twice();if(j.testBit(i)){if(k.testBit(i)){R=R.add(both)}else{R=R.add(this)}}else{if(k.testBit(i)){R=R.add(x)}}--i}return R}ECPointFp.prototype.getX=pointFpGetX;ECPointFp.prototype.getY=pointFpGetY;ECPointFp.prototype.equals=pointFpEquals;ECPointFp.prototype.isInfinity=pointFpIsInfinity;ECPointFp.prototype.negate=pointFpNegate;ECPointFp.prototype.add=pointFpAdd;ECPointFp.prototype.twice=pointFpTwice;ECPointFp.prototype.multiply=pointFpMultiply;ECPointFp.prototype.multiplyTwo=pointFpMultiplyTwo;function ECCurveFp(q,a,b){this.q=q;this.a=this.fromBigInteger(a);this.b=this.fromBigInteger(b);this.infinity=new ECPointFp(this,null,null)}function curveFpGetQ(){return this.q}function curveFpGetA(){return this.a}function curveFpGetB(){return this.b}function curveFpEquals(other){if(other==this)return true;return this.q.equals(other.q)&&this.a.equals(other.a)&&this.b.equals(other.b)}function curveFpGetInfinity(){return this.infinity}function curveFpFromBigInteger(x){return new ECFieldElementFp(this.q,x)}function curveFpDecodePointHex(s){switch(parseInt(s.substr(0,2),16)){case 0:return this.infinity;case 2:case 3:return null;case 4:case 6:case 7:var len=(s.length-2)/2;var xHex=s.substr(2,len);var yHex=s.substr(len+2,len);return new ECPointFp(this,this.fromBigInteger(new BigInteger(xHex,16)),this.fromBigInteger(new BigInteger(yHex,16)));default:return null}}ECCurveFp.prototype.getQ=curveFpGetQ;ECCurveFp.prototype.getA=curveFpGetA;ECCurveFp.prototype.getB=curveFpGetB;ECCurveFp.prototype.equals=curveFpEquals;ECCurveFp.prototype.getInfinity=curveFpGetInfinity;ECCurveFp.prototype.fromBigInteger=curveFpFromBigInteger;ECCurveFp.prototype.decodePointHex=curveFpDecodePointHex;function integerToBytes(i,len){var bytes=i.toByteArrayUnsigned();if(len<bytes.length){bytes=bytes.slice(bytes.length-len)}else while(len>bytes.length){bytes.unshift(0)}return bytes}ECFieldElementFp.prototype.getByteLength=function(){return Math.floor((this.toBigInteger().bitLength()+7)/8)};ECPointFp.prototype.getEncoded=function(compressed){var x=this.getX().toBigInteger();var y=this.getY().toBigInteger();var enc=integerToBytes(x,32);if(compressed){if(y.isEven()){enc.unshift(2)}else{enc.unshift(3)}}else{enc.unshift(4);enc=enc.concat(integerToBytes(y,32))}return enc};ECPointFp.decodeFrom=function(ecparams,enc){var type=enc[0];var dataLen=enc.length-1;if(type==4){var xBa=enc.slice(1,1+dataLen/2),yBa=enc.slice(1+dataLen/2,1+dataLen),x=BigInteger.fromByteArrayUnsigned(xBa),y=BigInteger.fromByteArrayUnsigned(yBa)}else{var xBa=enc.slice(1),x=BigInteger.fromByteArrayUnsigned(xBa),p=ecparams.getQ(),xCubedPlus7=x.multiply(x).multiply(x).add(new BigInteger("7")).mod(p),pPlus1Over4=p.add(new BigInteger("1")).divide(new BigInteger("4")),y=xCubedPlus7.modPow(pPlus1Over4,p);if(y.mod(new BigInteger("2")).toString()!=""+type%2){y=p.subtract(y)}}return new ECPointFp(ecparams,ecparams.fromBigInteger(x),ecparams.fromBigInteger(y))};ECPointFp.prototype.add2D=function(b){if(this.isInfinity())return b;if(b.isInfinity())return this;if(this.x.equals(b.x)){if(this.y.equals(b.y)){return this.twice()}return this.curve.getInfinity()}var x_x=b.x.subtract(this.x);var y_y=b.y.subtract(this.y);var gamma=y_y.divide(x_x);var x3=gamma.square().subtract(this.x).subtract(b.x);var y3=gamma.multiply(this.x.subtract(x3)).subtract(this.y);return new ECPointFp(this.curve,x3,y3)};ECPointFp.prototype.twice2D=function(){if(this.isInfinity())return this;if(this.y.toBigInteger().signum()==0){return this.curve.getInfinity()}var TWO=this.curve.fromBigInteger(BigInteger.valueOf(2));var THREE=this.curve.fromBigInteger(BigInteger.valueOf(3));var gamma=this.x.square().multiply(THREE).add(this.curve.a).divide(this.y.multiply(TWO));var x3=gamma.square().subtract(this.x.multiply(TWO));var y3=gamma.multiply(this.x.subtract(x3)).subtract(this.y);return new ECPointFp(this.curve,x3,y3)};ECPointFp.prototype.multiply2D=function(k){if(this.isInfinity())return this;if(k.signum()==0)return this.curve.getInfinity();var e=k;var h=e.multiply(new BigInteger("3"));var neg=this.negate();var R=this;var i;for(i=h.bitLength()-2;i>0;--i){R=R.twice();var hBit=h.testBit(i);var eBit=e.testBit(i);if(hBit!=eBit){R=R.add2D(hBit?this:neg)}}return R};ECPointFp.prototype.isOnCurve=function(){var x=this.getX().toBigInteger();var y=this.getY().toBigInteger();var a=this.curve.getA().toBigInteger();var b=this.curve.getB().toBigInteger();var n=this.curve.getQ();var lhs=y.multiply(y).mod(n);var rhs=x.multiply(x).multiply(x).add(a.multiply(x)).add(b).mod(n);return lhs.equals(rhs)};ECPointFp.prototype.toString=function(){return"("+this.getX().toBigInteger().toString()+","+this.getY().toBigInteger().toString()+")"};ECPointFp.prototype.validate=function(){var n=this.curve.getQ();if(this.isInfinity()){throw new Error("Point is at infinity.")}var x=this.getX().toBigInteger();var y=this.getY().toBigInteger();if(x.compareTo(BigInteger.ONE)<0||x.compareTo(n.subtract(BigInteger.ONE))>0){throw new Error("x coordinate out of bounds")}if(y.compareTo(BigInteger.ONE)<0||y.compareTo(n.subtract(BigInteger.ONE))>0){throw new Error("y coordinate out of bounds")}if(!this.isOnCurve()){throw new Error("Point is not on the curve.")}if(this.multiply(n).isInfinity()){throw new Error("Point is not a scalar multiple of G.")}return true};module.exports=ECCurveFp;module.exports.ECPointFp=ECPointFp},{"./jsbn":63,"./sec":64}],63:[function(_dereq_,module,exports){(function(Buffer){var dbits;var canary=0xdeadbeefcafe;var j_lm=(canary&16777215)==15715070;function BigInteger(a,b,c){if(!(this instanceof BigInteger)){return new BigInteger(a,b,c)}if(a!=null){if("number"==typeof a)this.fromNumber(a,b,c);else if(b==null&&"string"!=typeof a)this.fromString(a,256);else this.fromString(a,b)}}var proto=BigInteger.prototype;function nbi(){return new BigInteger(null)}function am1(i,x,w,j,c,n){while(--n>=0){var v=x*this[i++]+w[j]+c;c=Math.floor(v/67108864);w[j++]=v&67108863}return c}function am2(i,x,w,j,c,n){var xl=x&32767,xh=x>>15;while(--n>=0){var l=this[i]&32767;var h=this[i++]>>15;var m=xh*l+h*xl;l=xl*l+((m&32767)<<15)+w[j]+(c&1073741823);c=(l>>>30)+(m>>>15)+xh*h+(c>>>30);w[j++]=l&1073741823}return c}function am3(i,x,w,j,c,n){var xl=x&16383,xh=x>>14;while(--n>=0){var l=this[i]&16383;var h=this[i++]>>14;var m=xh*l+h*xl;l=xl*l+((m&16383)<<14)+w[j]+c;c=(l>>28)+(m>>14)+xh*h;w[j++]=l&268435455}return c}BigInteger.prototype.am=am1;dbits=26;BigInteger.prototype.DB=dbits;BigInteger.prototype.DM=(1<<dbits)-1;var DV=BigInteger.prototype.DV=1<<dbits;var BI_FP=52;BigInteger.prototype.FV=Math.pow(2,BI_FP);BigInteger.prototype.F1=BI_FP-dbits;BigInteger.prototype.F2=2*dbits-BI_FP;var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz";var BI_RC=new Array;var rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv)BI_RC[rr++]=vv;rr="a".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;rr="A".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;function int2char(n){return BI_RM.charAt(n)}function intAt(s,i){var c=BI_RC[s.charCodeAt(i)];return c==null?-1:c}function bnpCopyTo(r){for(var i=this.t-1;i>=0;--i)r[i]=this[i];r.t=this.t;r.s=this.s}function bnpFromInt(x){this.t=1;this.s=x<0?-1:0;if(x>0)this[0]=x;else if(x<-1)this[0]=x+DV;else this.t=0}function nbv(i){var r=nbi();r.fromInt(i);return r}function bnpFromString(s,b){var self=this;var k;if(b==16)k=4;else if(b==8)k=3;else if(b==256)k=8;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else{self.fromRadix(s,b);return}self.t=0;self.s=0;var i=s.length,mi=false,sh=0;while(--i>=0){var x=k==8?s[i]&255:intAt(s,i);if(x<0){if(s.charAt(i)=="-")mi=true;continue}mi=false;if(sh==0)self[self.t++]=x;else if(sh+k>self.DB){self[self.t-1]|=(x&(1<<self.DB-sh)-1)<<sh;self[self.t++]=x>>self.DB-sh}else self[self.t-1]|=x<<sh;sh+=k;if(sh>=self.DB)sh-=self.DB}if(k==8&&(s[0]&128)!=0){self.s=-1;if(sh>0)self[self.t-1]|=(1<<self.DB-sh)-1<<sh}self.clamp();if(mi)BigInteger.ZERO.subTo(self,self)}function bnpClamp(){var c=this.s&this.DM;while(this.t>0&&this[this.t-1]==c)--this.t}function bnToString(b){var self=this;if(self.s<0)return"-"+self.negate().toString(b);var k;if(b==16)k=4;else if(b==8)k=3;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else return self.toRadix(b);var km=(1<<k)-1,d,m=false,r="",i=self.t;var p=self.DB-i*self.DB%k;if(i-->0){if(p<self.DB&&(d=self[i]>>p)>0){m=true;r=int2char(d)}while(i>=0){if(p<k){d=(self[i]&(1<<p)-1)<<k-p;d|=self[--i]>>(p+=self.DB-k)}else{d=self[i]>>(p-=k)&km;if(p<=0){p+=self.DB;--i}}if(d>0)m=true;if(m)r+=int2char(d)}}return m?r:"0"}function bnNegate(){var r=nbi();BigInteger.ZERO.subTo(this,r);return r}function bnAbs(){return this.s<0?this.negate():this}function bnCompareTo(a){var r=this.s-a.s;if(r!=0)return r;var i=this.t;r=i-a.t;if(r!=0)return this.s<0?-r:r;while(--i>=0)if((r=this[i]-a[i])!=0)return r;return 0}function nbits(x){var r=1,t;if((t=x>>>16)!=0){x=t;r+=16}if((t=x>>8)!=0){x=t;r+=8}if((t=x>>4)!=0){x=t;r+=4}if((t=x>>2)!=0){x=t;r+=2}if((t=x>>1)!=0){x=t;r+=1}return r}function bnBitLength(){if(this.t<=0)return 0;return this.DB*(this.t-1)+nbits(this[this.t-1]^this.s&this.DM)}function bnpDLShiftTo(n,r){var i;for(i=this.t-1;i>=0;--i)r[i+n]=this[i];for(i=n-1;i>=0;--i)r[i]=0;r.t=this.t+n;r.s=this.s}function bnpDRShiftTo(n,r){for(var i=n;i<this.t;++i)r[i-n]=this[i];r.t=Math.max(this.t-n,0);r.s=this.s}function bnpLShiftTo(n,r){var self=this;var bs=n%self.DB;var cbs=self.DB-bs;var bm=(1<<cbs)-1;var ds=Math.floor(n/self.DB),c=self.s<<bs&self.DM,i;for(i=self.t-1;i>=0;--i){r[i+ds+1]=self[i]>>cbs|c;c=(self[i]&bm)<<bs}for(i=ds-1;i>=0;--i)r[i]=0;r[ds]=c;r.t=self.t+ds+1;r.s=self.s;r.clamp()}function bnpRShiftTo(n,r){var self=this;r.s=self.s;var ds=Math.floor(n/self.DB);if(ds>=self.t){r.t=0;return}var bs=n%self.DB;var cbs=self.DB-bs;var bm=(1<<bs)-1;r[0]=self[ds]>>bs;for(var i=ds+1;i<self.t;++i){r[i-ds-1]|=(self[i]&bm)<<cbs;r[i-ds]=self[i]>>bs}if(bs>0)r[self.t-ds-1]|=(self.s&bm)<<cbs;r.t=self.t-ds;r.clamp()}function bnpSubTo(a,r){var self=this;var i=0,c=0,m=Math.min(a.t,self.t);while(i<m){c+=self[i]-a[i];r[i++]=c&self.DM;c>>=self.DB}if(a.t<self.t){c-=a.s;while(i<self.t){c+=self[i];r[i++]=c&self.DM;c>>=self.DB}c+=self.s}else{c+=self.s;while(i<a.t){c-=a[i];r[i++]=c&self.DM;c>>=self.DB}c-=a.s}r.s=c<0?-1:0;if(c<-1)r[i++]=self.DV+c;else if(c>0)r[i++]=c;r.t=i;r.clamp()}function bnpMultiplyTo(a,r){var x=this.abs(),y=a.abs();var i=x.t;r.t=i+y.t;while(--i>=0)r[i]=0;for(i=0;i<y.t;++i)r[i+x.t]=x.am(0,y[i],r,i,0,x.t);r.s=0;r.clamp();if(this.s!=a.s)BigInteger.ZERO.subTo(r,r)}function bnpSquareTo(r){var x=this.abs();var i=r.t=2*x.t;while(--i>=0)r[i]=0;for(i=0;i<x.t-1;++i){var c=x.am(i,x[i],r,2*i,0,1);if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1))>=x.DV){r[i+x.t]-=x.DV;r[i+x.t+1]=1}}if(r.t>0)r[r.t-1]+=x.am(i,x[i],r,2*i,0,1);r.s=0;r.clamp()}function bnpDivRemTo(m,q,r){var self=this;var pm=m.abs();if(pm.t<=0)return;var pt=self.abs();if(pt.t<pm.t){if(q!=null)q.fromInt(0);if(r!=null)self.copyTo(r);return}if(r==null)r=nbi();var y=nbi(),ts=self.s,ms=m.s;var nsh=self.DB-nbits(pm[pm.t-1]);if(nsh>0){pm.lShiftTo(nsh,y);pt.lShiftTo(nsh,r)}else{pm.copyTo(y);pt.copyTo(r)}var ys=y.t;var y0=y[ys-1];if(y0==0)return;var yt=y0*(1<<self.F1)+(ys>1?y[ys-2]>>self.F2:0);var d1=self.FV/yt,d2=(1<<self.F1)/yt,e=1<<self.F2;var i=r.t,j=i-ys,t=q==null?nbi():q;y.dlShiftTo(j,t);if(r.compareTo(t)>=0){r[r.t++]=1;r.subTo(t,r)}BigInteger.ONE.dlShiftTo(ys,t);t.subTo(y,y);while(y.t<ys)y[y.t++]=0;while(--j>=0){var qd=r[--i]==y0?self.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);if((r[i]+=y.am(0,qd,r,j,0,ys))<qd){y.dlShiftTo(j,t);r.subTo(t,r);while(r[i]<--qd)r.subTo(t,r)}}if(q!=null){r.drShiftTo(ys,q);if(ts!=ms)BigInteger.ZERO.subTo(q,q)}r.t=ys;r.clamp();if(nsh>0)r.rShiftTo(nsh,r);if(ts<0)BigInteger.ZERO.subTo(r,r)}function bnMod(a){var r=nbi();this.abs().divRemTo(a,null,r);if(this.s<0&&r.compareTo(BigInteger.ZERO)>0)a.subTo(r,r);return r}function Classic(m){this.m=m}function cConvert(x){if(x.s<0||x.compareTo(this.m)>=0)return x.mod(this.m);else return x}function cRevert(x){return x}function cReduce(x){x.divRemTo(this.m,null,x)}function cMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r)}function cSqrTo(x,r){x.squareTo(r);this.reduce(r)}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;function bnpInvDigit(){if(this.t<1)return 0;var x=this[0];if((x&1)==0)return 0;var y=x&3;y=y*(2-(x&15)*y)&15;y=y*(2-(x&255)*y)&255;y=y*(2-((x&65535)*y&65535))&65535;y=y*(2-x*y%this.DV)%this.DV;return y>0?this.DV-y:-y}function Montgomery(m){this.m=m;this.mp=m.invDigit();this.mpl=this.mp&32767;this.mph=this.mp>>15;this.um=(1<<m.DB-15)-1;this.mt2=2*m.t}function montConvert(x){var r=nbi();x.abs().dlShiftTo(this.m.t,r);r.divRemTo(this.m,null,r);if(x.s<0&&r.compareTo(BigInteger.ZERO)>0)this.m.subTo(r,r);return r}function montRevert(x){var r=nbi();x.copyTo(r);this.reduce(r);return r}function montReduce(x){while(x.t<=this.mt2)x[x.t++]=0;for(var i=0;i<this.m.t;++i){var j=x[i]&32767;var u0=j*this.mpl+((j*this.mph+(x[i]>>15)*this.mpl&this.um)<<15)&x.DM;j=i+this.m.t;x[j]+=this.m.am(0,u0,x,i,0,this.m.t);while(x[j]>=x.DV){x[j]-=x.DV;x[++j]++}}x.clamp();x.drShiftTo(this.m.t,x);if(x.compareTo(this.m)>=0)x.subTo(this.m,x)}function montSqrTo(x,r){x.squareTo(r);this.reduce(r)}function montMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r)}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;function bnpIsEven(){return(this.t>0?this[0]&1:this.s)==0}function bnpExp(e,z){if(e>4294967295||e<1)return BigInteger.ONE;var r=nbi(),r2=nbi(),g=z.convert(this),i=nbits(e)-1;g.copyTo(r);while(--i>=0){z.sqrTo(r,r2);if((e&1<<i)>0)z.mulTo(r2,g,r);else{var t=r;r=r2;r2=t}}return z.revert(r)}function bnModPowInt(e,m){var z;if(e<256||m.isEven())z=new Classic(m);else z=new Montgomery(m);return this.exp(e,z)}proto.copyTo=bnpCopyTo;proto.fromInt=bnpFromInt;proto.fromString=bnpFromString;proto.clamp=bnpClamp;proto.dlShiftTo=bnpDLShiftTo;proto.drShiftTo=bnpDRShiftTo;proto.lShiftTo=bnpLShiftTo;proto.rShiftTo=bnpRShiftTo;proto.subTo=bnpSubTo;proto.multiplyTo=bnpMultiplyTo;proto.squareTo=bnpSquareTo;proto.divRemTo=bnpDivRemTo;proto.invDigit=bnpInvDigit;proto.isEven=bnpIsEven;proto.exp=bnpExp;proto.toString=bnToString;proto.negate=bnNegate;proto.abs=bnAbs;proto.compareTo=bnCompareTo;proto.bitLength=bnBitLength;proto.mod=bnMod;proto.modPowInt=bnModPowInt;function nbi(){return new BigInteger(null)}function bnClone(){var r=nbi();this.copyTo(r);return r}function bnIntValue(){if(this.s<0){if(this.t==1)return this[0]-this.DV;else if(this.t==0)return-1}else if(this.t==1)return this[0];else if(this.t==0)return 0;return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]}function bnByteValue(){return this.t==0?this.s:this[0]<<24>>24}function bnShortValue(){return this.t==0?this.s:this[0]<<16>>16}function bnpChunkSize(r){return Math.floor(Math.LN2*this.DB/Math.log(r))}function bnSigNum(){if(this.s<0)return-1;else if(this.t<=0||this.t==1&&this[0]<=0)return 0;else return 1}function bnpToRadix(b){if(b==null)b=10;if(this.signum()==0||b<2||b>36)return"0";var cs=this.chunkSize(b);var a=Math.pow(b,cs);var d=nbv(a),y=nbi(),z=nbi(),r="";this.divRemTo(d,y,z);while(y.signum()>0){r=(a+z.intValue()).toString(b).substr(1)+r;y.divRemTo(d,y,z)}return z.intValue().toString(b)+r}function bnpFromRadix(s,b){var self=this;self.fromInt(0);if(b==null)b=10;var cs=self.chunkSize(b);var d=Math.pow(b,cs),mi=false,j=0,w=0;for(var i=0;i<s.length;++i){var x=intAt(s,i);if(x<0){if(s.charAt(i)=="-"&&self.signum()==0)mi=true;continue}w=b*w+x;if(++j>=cs){self.dMultiply(d);self.dAddOffset(w,0);j=0;w=0}}if(j>0){self.dMultiply(Math.pow(b,j));self.dAddOffset(w,0)}if(mi)BigInteger.ZERO.subTo(self,self)}function bnpFromNumber(a,b,c){var self=this;if("number"==typeof b){if(a<2)self.fromInt(1);else{self.fromNumber(a,c);if(!self.testBit(a-1))self.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,self);if(self.isEven())self.dAddOffset(1,0);while(!self.isProbablePrime(b)){self.dAddOffset(2,0);if(self.bitLength()>a)self.subTo(BigInteger.ONE.shiftLeft(a-1),self)}}}else{var t=a&7;var length=(a>>3)+1;var x=b(length,{array:true});if(t>0)x[0]&=(1<<t)-1;else x[0]=0;self.fromString(x,256)}}function bnToByteArray(){var self=this;var i=self.t,r=new Array;r[0]=self.s;var p=self.DB-i*self.DB%8,d,k=0;if(i-->0){if(p<self.DB&&(d=self[i]>>p)!=(self.s&self.DM)>>p)r[k++]=d|self.s<<self.DB-p;while(i>=0){if(p<8){d=(self[i]&(1<<p)-1)<<8-p;d|=self[--i]>>(p+=self.DB-8)}else{d=self[i]>>(p-=8)&255;if(p<=0){p+=self.DB;--i}}if((d&128)!=0)d|=-256;if(k===0&&(self.s&128)!=(d&128))++k;if(k>0||d!=self.s)r[k++]=d}}return r}function bnEquals(a){return this.compareTo(a)==0}function bnMin(a){return this.compareTo(a)<0?this:a}function bnMax(a){return this.compareTo(a)>0?this:a}function bnpBitwiseTo(a,op,r){var self=this;var i,f,m=Math.min(a.t,self.t);for(i=0;i<m;++i)r[i]=op(self[i],a[i]);if(a.t<self.t){f=a.s&self.DM;for(i=m;i<self.t;++i)r[i]=op(self[i],f);r.t=self.t}else{f=self.s&self.DM;for(i=m;i<a.t;++i)r[i]=op(f,a[i]);r.t=a.t}r.s=op(self.s,a.s);r.clamp()}function op_and(x,y){return x&y}function bnAnd(a){var r=nbi();this.bitwiseTo(a,op_and,r);return r}function op_or(x,y){return x|y}function bnOr(a){var r=nbi();this.bitwiseTo(a,op_or,r);return r}function op_xor(x,y){return x^y}function bnXor(a){var r=nbi();this.bitwiseTo(a,op_xor,r);return r}function op_andnot(x,y){return x&~y}function bnAndNot(a){var r=nbi();this.bitwiseTo(a,op_andnot,r);return r}function bnNot(){var r=nbi();for(var i=0;i<this.t;++i)r[i]=this.DM&~this[i];r.t=this.t;r.s=~this.s;return r}function bnShiftLeft(n){var r=nbi();if(n<0)this.rShiftTo(-n,r);else this.lShiftTo(n,r);return r}function bnShiftRight(n){var r=nbi();if(n<0)this.lShiftTo(-n,r);else this.rShiftTo(n,r);return r}function lbit(x){if(x==0)return-1;var r=0;if((x&65535)==0){x>>=16;r+=16}if((x&255)==0){x>>=8;r+=8}if((x&15)==0){x>>=4;r+=4}if((x&3)==0){x>>=2;r+=2}if((x&1)==0)++r;return r}function bnGetLowestSetBit(){for(var i=0;i<this.t;++i)if(this[i]!=0)return i*this.DB+lbit(this[i]);if(this.s<0)return this.t*this.DB;return-1}function cbit(x){var r=0;while(x!=0){x&=x-1;++r}return r}function bnBitCount(){var r=0,x=this.s&this.DM;for(var i=0;i<this.t;++i)r+=cbit(this[i]^x);return r}function bnTestBit(n){var j=Math.floor(n/this.DB);if(j>=this.t)return this.s!=0;return(this[j]&1<<n%this.DB)!=0}function bnpChangeBit(n,op){var r=BigInteger.ONE.shiftLeft(n);this.bitwiseTo(r,op,r);return r}function bnSetBit(n){return this.changeBit(n,op_or)}function bnClearBit(n){return this.changeBit(n,op_andnot)}function bnFlipBit(n){return this.changeBit(n,op_xor)}function bnpAddTo(a,r){var self=this;var i=0,c=0,m=Math.min(a.t,self.t);while(i<m){c+=self[i]+a[i];r[i++]=c&self.DM;c>>=self.DB}if(a.t<self.t){c+=a.s;while(i<self.t){c+=self[i];r[i++]=c&self.DM;c>>=self.DB}c+=self.s}else{c+=self.s;while(i<a.t){c+=a[i];r[i++]=c&self.DM;c>>=self.DB}c+=a.s}r.s=c<0?-1:0;if(c>0)r[i++]=c;else if(c<-1)r[i++]=self.DV+c;r.t=i;r.clamp()}function bnAdd(a){var r=nbi();this.addTo(a,r);return r}function bnSubtract(a){var r=nbi();this.subTo(a,r);return r}function bnMultiply(a){var r=nbi();this.multiplyTo(a,r);return r}function bnSquare(){var r=nbi();this.squareTo(r);return r}function bnDivide(a){var r=nbi();this.divRemTo(a,r,null);return r}function bnRemainder(a){var r=nbi();this.divRemTo(a,null,r);return r}function bnDivideAndRemainder(a){var q=nbi(),r=nbi();this.divRemTo(a,q,r);return new Array(q,r)}function bnpDMultiply(n){this[this.t]=this.am(0,n-1,this,0,0,this.t);++this.t;this.clamp()}function bnpDAddOffset(n,w){if(n==0)return;while(this.t<=w)this[this.t++]=0;this[w]+=n;while(this[w]>=this.DV){this[w]-=this.DV;if(++w>=this.t)this[this.t++]=0;++this[w]}}function NullExp(){}function nNop(x){return x}function nMulTo(x,y,r){x.multiplyTo(y,r)}function nSqrTo(x,r){x.squareTo(r)}NullExp.prototype.convert=nNop;NullExp.prototype.revert=nNop;NullExp.prototype.mulTo=nMulTo;NullExp.prototype.sqrTo=nSqrTo;function bnPow(e){return this.exp(e,new NullExp)}function bnpMultiplyLowerTo(a,n,r){var i=Math.min(this.t+a.t,n);r.s=0;r.t=i;while(i>0)r[--i]=0;var j;for(j=r.t-this.t;i<j;++i)r[i+this.t]=this.am(0,a[i],r,i,0,this.t);for(j=Math.min(a.t,n);i<j;++i)this.am(0,a[i],r,i,0,n-i);r.clamp()}function bnpMultiplyUpperTo(a,n,r){--n;var i=r.t=this.t+a.t-n;r.s=0;while(--i>=0)r[i]=0;for(i=Math.max(n-this.t,0);i<a.t;++i)r[this.t+i-n]=this.am(n-i,a[i],r,0,0,this.t+i-n);r.clamp();r.drShiftTo(1,r)}function Barrett(m){this.r2=nbi();this.q3=nbi();BigInteger.ONE.dlShiftTo(2*m.t,this.r2);this.mu=this.r2.divide(m);this.m=m}function barrettConvert(x){if(x.s<0||x.t>2*this.m.t)return x.mod(this.m);else if(x.compareTo(this.m)<0)return x;else{var r=nbi();x.copyTo(r);this.reduce(r);return r}}function barrettRevert(x){return x}function barrettReduce(x){var self=this;x.drShiftTo(self.m.t-1,self.r2);if(x.t>self.m.t+1){x.t=self.m.t+1;x.clamp()}self.mu.multiplyUpperTo(self.r2,self.m.t+1,self.q3);self.m.multiplyLowerTo(self.q3,self.m.t+1,self.r2);while(x.compareTo(self.r2)<0)x.dAddOffset(1,self.m.t+1);x.subTo(self.r2,x);while(x.compareTo(self.m)>=0)x.subTo(self.m,x)}function barrettSqrTo(x,r){x.squareTo(r);this.reduce(r)}function barrettMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r)}Barrett.prototype.convert=barrettConvert;Barrett.prototype.revert=barrettRevert;Barrett.prototype.reduce=barrettReduce;Barrett.prototype.mulTo=barrettMulTo;Barrett.prototype.sqrTo=barrettSqrTo;function bnModPow(e,m){var i=e.bitLength(),k,r=nbv(1),z;if(i<=0)return r;else if(i<18)k=1;else if(i<48)k=3;else if(i<144)k=4;else if(i<768)k=5;else k=6;if(i<8)z=new Classic(m);else if(m.isEven())z=new Barrett(m);else z=new Montgomery(m);var g=new Array,n=3,k1=k-1,km=(1<<k)-1;g[1]=z.convert(this);if(k>1){var g2=nbi();z.sqrTo(g[1],g2);while(n<=km){g[n]=nbi();z.mulTo(g2,g[n-2],g[n]);n+=2}}var j=e.t-1,w,is1=true,r2=nbi(),t;i=nbits(e[j])-1;while(j>=0){if(i>=k1)w=e[j]>>i-k1&km;else{w=(e[j]&(1<<i+1)-1)<<k1-i;if(j>0)w|=e[j-1]>>this.DB+i-k1}n=k;while((w&1)==0){w>>=1;--n}if((i-=n)<0){i+=this.DB;--j}if(is1){g[w].copyTo(r);is1=false}else{while(n>1){z.sqrTo(r,r2);z.sqrTo(r2,r);n-=2}if(n>0)z.sqrTo(r,r2);else{t=r;r=r2;r2=t}z.mulTo(r2,g[w],r)}while(j>=0&&(e[j]&1<<i)==0){z.sqrTo(r,r2);t=r;r=r2;r2=t;if(--i<0){i=this.DB-1;--j}}}return z.revert(r)}function bnGCD(a){var x=this.s<0?this.negate():this.clone();var y=a.s<0?a.negate():a.clone();if(x.compareTo(y)<0){var t=x;x=y;y=t}var i=x.getLowestSetBit(),g=y.getLowestSetBit();if(g<0)return x;if(i<g)g=i;if(g>0){x.rShiftTo(g,x);y.rShiftTo(g,y)}while(x.signum()>0){if((i=x.getLowestSetBit())>0)x.rShiftTo(i,x);if((i=y.getLowestSetBit())>0)y.rShiftTo(i,y);if(x.compareTo(y)>=0){x.subTo(y,x);x.rShiftTo(1,x)}else{y.subTo(x,y);y.rShiftTo(1,y)}}if(g>0)y.lShiftTo(g,y);return y}function bnpModInt(n){if(n<=0)return 0;var d=this.DV%n,r=this.s<0?n-1:0;if(this.t>0)if(d==0)r=this[0]%n;else for(var i=this.t-1;i>=0;--i)r=(d*r+this[i])%n;return r}function bnModInverse(m){var ac=m.isEven();if(this.isEven()&&ac||m.signum()==0)return BigInteger.ZERO;var u=m.clone(),v=this.clone();var a=nbv(1),b=nbv(0),c=nbv(0),d=nbv(1);while(u.signum()!=0){while(u.isEven()){u.rShiftTo(1,u);if(ac){if(!a.isEven()||!b.isEven()){a.addTo(this,a);b.subTo(m,b)}a.rShiftTo(1,a)}else if(!b.isEven())b.subTo(m,b);b.rShiftTo(1,b)}while(v.isEven()){v.rShiftTo(1,v);if(ac){if(!c.isEven()||!d.isEven()){c.addTo(this,c);d.subTo(m,d)}c.rShiftTo(1,c)}else if(!d.isEven())d.subTo(m,d);d.rShiftTo(1,d)}if(u.compareTo(v)>=0){u.subTo(v,u);if(ac)a.subTo(c,a);b.subTo(d,b)}else{v.subTo(u,v);if(ac)c.subTo(a,c);d.subTo(b,d)}}if(v.compareTo(BigInteger.ONE)!=0)return BigInteger.ZERO;if(d.compareTo(m)>=0)return d.subtract(m);if(d.signum()<0)d.addTo(m,d);else return d;if(d.signum()<0)return d.add(m);else return d}proto.chunkSize=bnpChunkSize;proto.toRadix=bnpToRadix;proto.fromRadix=bnpFromRadix;proto.fromNumber=bnpFromNumber;proto.bitwiseTo=bnpBitwiseTo;proto.changeBit=bnpChangeBit;proto.addTo=bnpAddTo;proto.dMultiply=bnpDMultiply;proto.dAddOffset=bnpDAddOffset;proto.multiplyLowerTo=bnpMultiplyLowerTo;proto.multiplyUpperTo=bnpMultiplyUpperTo;proto.modInt=bnpModInt;proto.clone=bnClone;proto.intValue=bnIntValue;proto.byteValue=bnByteValue;proto.shortValue=bnShortValue;proto.signum=bnSigNum;proto.toByteArray=bnToByteArray;proto.equals=bnEquals;proto.min=bnMin;proto.max=bnMax;proto.and=bnAnd;proto.or=bnOr;proto.xor=bnXor;proto.andNot=bnAndNot;proto.not=bnNot;proto.shiftLeft=bnShiftLeft;proto.shiftRight=bnShiftRight;proto.getLowestSetBit=bnGetLowestSetBit;proto.bitCount=bnBitCount;proto.testBit=bnTestBit;proto.setBit=bnSetBit;proto.clearBit=bnClearBit;proto.flipBit=bnFlipBit;proto.add=bnAdd;proto.subtract=bnSubtract;proto.multiply=bnMultiply;proto.divide=bnDivide;proto.remainder=bnRemainder;proto.divideAndRemainder=bnDivideAndRemainder;proto.modPow=bnModPow;proto.modInverse=bnModInverse;proto.pow=bnPow;proto.gcd=bnGCD;proto.square=bnSquare;BigInteger.ZERO=nbv(0);BigInteger.ONE=nbv(1);BigInteger.valueOf=nbv;BigInteger.fromByteArrayUnsigned=function(ba){if(Buffer.isBuffer(ba)){ba=Array.prototype.map.bind(ba,function(x){return x})()}if(!ba.length){return new BigInteger.valueOf(0)}else if(ba[0]&128){return new BigInteger([0].concat(ba))}else{return new BigInteger(ba)}};BigInteger.fromByteArraySigned=function(ba){if(ba[0]&128){ba[0]&=127;return BigInteger.fromByteArrayUnsigned(ba).negate()}else{return BigInteger.fromByteArrayUnsigned(ba)}};BigInteger.prototype.toByteArrayUnsigned=function(){var ba=this.abs().toByteArray();if(!ba.length){return ba}if(ba[0]===0){ba=ba.slice(1)}for(var i=0;i<ba.length;++i){ba[i]=ba[i]<0?ba[i]+256:ba[i]}return ba};BigInteger.prototype.toByteArraySigned=function(){var val=this.toByteArrayUnsigned();var neg=this.s<0;if(val[0]&128){val.unshift(neg?128:0)}else if(neg){val[0]|=128}return val};module.exports=BigInteger}).call(this,_dereq_("buffer").Buffer)},{buffer:5}],64:[function(_dereq_,module,exports){var ECCurveFp=_dereq_("./ec");var BigInteger=_dereq_("./jsbn");function X9ECParameters(curve,g,n,h){this.curve=curve;this.g=g;this.n=n;this.h=h}function x9getCurve(){return this.curve}function x9getG(){return this.g}function x9getN(){return this.n}function x9getH(){return this.h}X9ECParameters.prototype.getCurve=x9getCurve;X9ECParameters.prototype.getG=x9getG;X9ECParameters.prototype.getN=x9getN;X9ECParameters.prototype.getH=x9getH;function fromHex(s){return new BigInteger(s,16)}function secp128r1(){var p=fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");var a=fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");var b=fromHex("E87579C11079F43DD824993C2CEE5ED3");var n=fromHex("FFFFFFFE0000000075A30D1B9038A115");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"161FF7528B899B2D0C28607CA52C5B86"+"CF5AC8395BAFEB13C02DA292DDED7A83");return new X9ECParameters(curve,G,n,h)}function secp160k1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");var a=BigInteger.ZERO;var b=fromHex("7");var n=fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"3B4C382CE37AA192A4019E763036F4F5DD4D7EBB"+"938CF935318FDCED6BC28286531733C3F03C4FEE");return new X9ECParameters(curve,G,n,h)}function secp160r1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");var a=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");var b=fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");var n=fromHex("0100000000000000000001F4C8F927AED3CA752257");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"4A96B5688EF573284664698968C38BB913CBFC82"+"23A628553168947D59DCC912042351377AC5FB32");return new X9ECParameters(curve,G,n,h)}function secp192k1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");var a=BigInteger.ZERO;var b=fromHex("3");var n=fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D"+"9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");return new X9ECParameters(curve,G,n,h)}function secp192r1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");var a=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");var b=fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");var n=fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012"+"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811");return new X9ECParameters(curve,G,n,h)}function secp224r1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");var a=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");var b=fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");var n=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21"+"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");return new X9ECParameters(curve,G,n,h)}function secp256k1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F");var a=BigInteger.ZERO;var b=fromHex("7");var n=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798"+"483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8");return new X9ECParameters(curve,G,n,h)}function secp256r1(){var p=fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");var a=fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");var b=fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");var n=fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296"+"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");return new X9ECParameters(curve,G,n,h)}function getSECCurveByName(name){if(name=="secp128r1")return secp128r1();if(name=="secp160k1")return secp160k1();if(name=="secp160r1")return secp160r1();if(name=="secp192k1")return secp192k1();if(name=="secp192r1")return secp192r1();if(name=="secp224r1")return secp224r1();if(name=="secp256k1")return secp256k1();if(name=="secp256r1")return secp256r1();return null}module.exports=getSECCurveByName},{"./ec":62,"./jsbn":63}],65:[function(_dereq_,module,exports){var Address=_dereq_("./address");var convert=_dereq_("./convert");var ecdsa=_dereq_("./ecdsa");var ECPubKey=_dereq_("./eckey").ECPubKey;var SHA256=_dereq_("crypto-js/sha256");var magicBytes=convert.stringToBytes("Bitcoin Signed Message:\n");function magicHash(message){var messageBytes=convert.stringToBytes(message);var buffer=[].concat(convert.numToVarInt(magicBytes.length),magicBytes,convert.numToVarInt(messageBytes.length),messageBytes);
return convert.wordArrayToBytes(SHA256(SHA256(convert.bytesToWordArray(buffer))))}function sign(key,message){var hash=magicHash(message);var sig=key.sign(hash);var obj=ecdsa.parseSig(sig);var i=ecdsa.calcPubKeyRecoveryParam(key.getPub().pub,obj.r,obj.s,hash);i+=27;if(key.compressed){i+=4}var rBa=obj.r.toByteArrayUnsigned();var sBa=obj.s.toByteArrayUnsigned();while(rBa.length<32)rBa.unshift(0);while(sBa.length<32)sBa.unshift(0);sig=[i].concat(rBa,sBa);return sig}function verify(address,sig,message){sig=ecdsa.parseSigCompact(sig);var pubKey=new ECPubKey(ecdsa.recoverPubKey(sig.r,sig.s,magicHash(message),sig.i));var isCompressed=!!(sig.i&4);pubKey.compressed=isCompressed;address=new Address(address);return pubKey.getAddress(address.version).toString()===address.toString()}module.exports={magicHash:magicHash,sign:sign,verify:verify}},{"./address":54,"./convert":57,"./ecdsa":58,"./eckey":59,"crypto-js/sha256":47}],66:[function(_dereq_,module,exports){module.exports={mainnet:{addressVersion:0,p2shVersion:5,hdVersions:{pub:76067358,priv:76066276}},testnet:{addressVersion:111,p2shVersion:196,hdVersions:{pub:70617039,priv:70615956}}}},{}],67:[function(_dereq_,module,exports){var Opcode={map:{OP_0:0,OP_FALSE:0,OP_PUSHDATA1:76,OP_PUSHDATA2:77,OP_PUSHDATA4:78,OP_1NEGATE:79,OP_RESERVED:80,OP_1:81,OP_TRUE:81,OP_2:82,OP_3:83,OP_4:84,OP_5:85,OP_6:86,OP_7:87,OP_8:88,OP_9:89,OP_10:90,OP_11:91,OP_12:92,OP_13:93,OP_14:94,OP_15:95,OP_16:96,OP_NOP:97,OP_VER:98,OP_IF:99,OP_NOTIF:100,OP_VERIF:101,OP_VERNOTIF:102,OP_ELSE:103,OP_ENDIF:104,OP_VERIFY:105,OP_RETURN:106,OP_TOALTSTACK:107,OP_FROMALTSTACK:108,OP_2DROP:109,OP_2DUP:110,OP_3DUP:111,OP_2OVER:112,OP_2ROT:113,OP_2SWAP:114,OP_IFDUP:115,OP_DEPTH:116,OP_DROP:117,OP_DUP:118,OP_NIP:119,OP_OVER:120,OP_PICK:121,OP_ROLL:122,OP_ROT:123,OP_SWAP:124,OP_TUCK:125,OP_CAT:126,OP_SUBSTR:127,OP_LEFT:128,OP_RIGHT:129,OP_SIZE:130,OP_INVERT:131,OP_AND:132,OP_OR:133,OP_XOR:134,OP_EQUAL:135,OP_EQUALVERIFY:136,OP_RESERVED1:137,OP_RESERVED2:138,OP_1ADD:139,OP_1SUB:140,OP_2MUL:141,OP_2DIV:142,OP_NEGATE:143,OP_ABS:144,OP_NOT:145,OP_0NOTEQUAL:146,OP_ADD:147,OP_SUB:148,OP_MUL:149,OP_DIV:150,OP_MOD:151,OP_LSHIFT:152,OP_RSHIFT:153,OP_BOOLAND:154,OP_BOOLOR:155,OP_NUMEQUAL:156,OP_NUMEQUALVERIFY:157,OP_NUMNOTEQUAL:158,OP_LESSTHAN:159,OP_GREATERTHAN:160,OP_LESSTHANOREQUAL:161,OP_GREATERTHANOREQUAL:162,OP_MIN:163,OP_MAX:164,OP_WITHIN:165,OP_RIPEMD160:166,OP_SHA1:167,OP_SHA256:168,OP_HASH160:169,OP_HASH256:170,OP_CODESEPARATOR:171,OP_CHECKSIG:172,OP_CHECKSIGVERIFY:173,OP_CHECKMULTISIG:174,OP_CHECKMULTISIGVERIFY:175,OP_NOP1:176,OP_NOP2:177,OP_NOP3:178,OP_NOP4:179,OP_NOP5:180,OP_NOP6:181,OP_NOP7:182,OP_NOP8:183,OP_NOP9:184,OP_NOP10:185,OP_PUBKEYHASH:253,OP_PUBKEY:254,OP_INVALIDOPCODE:255},reverseMap:[]};for(var i in Opcode.map){Opcode.reverseMap[Opcode.map[i]]=i}module.exports=Opcode},{}],68:[function(_dereq_,module,exports){(function(Buffer){var Opcode=_dereq_("./opcode");var util=_dereq_("./util");var convert=_dereq_("./convert");var Address=_dereq_("./address");var network=_dereq_("./network");var Script=function(data){this.buffer=data||[];if(!Array.isArray(this.buffer)){throw new Error("expect Script to be initialized with Array, but got "+data)}this.parse()};Script.fromHex=function(data){return new Script(convert.hexToBytes(data))};Script.fromPubKey=function(str){var script=new Script;var s=str.split(" ");for(var i in s){if(Opcode.map.hasOwnProperty(s[i])){script.writeOp(Opcode.map[s[i]])}else{script.writeBytes(convert.hexToBytes(s[i]))}}return script};Script.fromScriptSig=function(str){var script=new Script;var s=str.split(" ");for(var i in s){if(Opcode.map.hasOwnProperty(s[i])){script.writeOp(Opcode.map[s[i]])}else{script.writeBytes(convert.hexToBytes(s[i]))}}return script};Script.prototype.parse=function(){var self=this;this.chunks=[];var i=0;function readChunk(n){self.chunks.push(self.buffer.slice(i,i+n));i+=n}while(i<this.buffer.length){var opcode=this.buffer[i++];if(opcode>=240){opcode=opcode<<8|this.buffer[i++]}var len;if(opcode>0&&opcode<Opcode.map.OP_PUSHDATA1){readChunk(opcode)}else if(opcode==Opcode.map.OP_PUSHDATA1){len=this.buffer[i++];readChunk(len)}else if(opcode==Opcode.map.OP_PUSHDATA2){len=this.buffer[i++]<<8|this.buffer[i++];readChunk(len)}else if(opcode==Opcode.map.OP_PUSHDATA4){len=this.buffer[i++]<<24|this.buffer[i++]<<16|this.buffer[i++]<<8|this.buffer[i++];readChunk(len)}else{this.chunks.push(opcode)}}};Script.prototype.getOutType=function(){if(this.chunks[this.chunks.length-1]==Opcode.map.OP_EQUAL&&this.chunks[0]==Opcode.map.OP_HASH160&&this.chunks.length==3){return"P2SH"}else if(this.chunks.length==5&&this.chunks[0]==Opcode.map.OP_DUP&&this.chunks[1]==Opcode.map.OP_HASH160&&this.chunks[3]==Opcode.map.OP_EQUALVERIFY&&this.chunks[4]==Opcode.map.OP_CHECKSIG){return"Pubkey"}else{return"Strange"}};Script.prototype.toScriptHash=function(){var outType=this.getOutType();if(outType=="Pubkey"){return this.chunks[2]}if(outType=="P2SH"){return util.sha256ripe160(this.buffer)}return util.sha256ripe160(this.buffer)};Script.prototype.getToAddress=function(){var outType=this.getOutType();if(outType=="Pubkey"){return new Address(this.chunks[2])}if(outType=="P2SH"){return new Address(this.chunks[1],5)}return new Address(this.chunks[1],5)};Script.prototype.getFromAddress=function(){return new Address(this.simpleInHash())};Script.prototype.getInType=function(){if(this.chunks.length==1&&Array.isArray(this.chunks[0])){return"Pubkey"}else if(this.chunks.length==2&&Array.isArray(this.chunks[0])&&Array.isArray(this.chunks[1])){return"Address"}else if(this.chunks[0]==Opcode.map.OP_0&&this.chunks.slice(1).reduce(function(t,chunk,i){return t&&Array.isArray(chunk)&&(chunk[0]==48||i==this.chunks.length-1)},true)){return"Multisig"}else{return"Strange"}};Script.prototype.simpleInPubKey=function(){switch(this.getInType()){case"Address":return this.chunks[1];case"Pubkey":throw new Error("Script does not contain pubkey");default:throw new Error("Encountered non-standard scriptSig")}};Script.prototype.simpleInHash=function(){return util.sha256ripe160(this.simpleInPubKey())};Script.prototype.simpleInPubKeyHash=Script.prototype.simpleInHash;Script.prototype.writeOp=function(opcode){this.buffer.push(opcode);this.chunks.push(opcode)};Script.prototype.writeBytes=function(data){if(Buffer.isBuffer(data)){data=Array.prototype.map.bind(data,function(x){return x})()}if(data.length<Opcode.map.OP_PUSHDATA1){this.buffer.push(data.length)}else if(data.length<=255){this.buffer.push(Opcode.map.OP_PUSHDATA1);this.buffer.push(data.length)}else if(data.length<=65535){this.buffer.push(Opcode.map.OP_PUSHDATA2);this.buffer.push(data.length&255);this.buffer.push(data.length>>>8&255)}else{this.buffer.push(Opcode.map.OP_PUSHDATA4);this.buffer.push(data.length&255);this.buffer.push(data.length>>>8&255);this.buffer.push(data.length>>>16&255);this.buffer.push(data.length>>>24&255)}this.buffer=this.buffer.concat(data);this.chunks.push(data)};Script.createOutputScript=function(address){var script=new Script;address=new Address(address);if(address.version==network.mainnet.p2shVersion||address.version==network.testnet.p2shVersion){script.writeOp(Opcode.map.OP_HASH160);script.writeBytes(address.hash);script.writeOp(Opcode.map.OP_EQUAL)}else{script.writeOp(Opcode.map.OP_DUP);script.writeOp(Opcode.map.OP_HASH160);script.writeBytes(address.hash);script.writeOp(Opcode.map.OP_EQUALVERIFY);script.writeOp(Opcode.map.OP_CHECKSIG)}return script};Script.prototype.extractPubkeys=function(){return this.chunks.filter(function(chunk){return chunk[0]==4&&chunk.length==65||chunk[0]<4&&chunk.length==33})};Script.createMultiSigOutputScript=function(m,pubkeys){var script=new Script;pubkeys=pubkeys.sort();script.writeOp(Opcode.map.OP_1+m-1);for(var i=0;i<pubkeys.length;++i){script.writeBytes(pubkeys[i])}script.writeOp(Opcode.map.OP_1+pubkeys.length-1);script.writeOp(Opcode.map.OP_CHECKMULTISIG);return script};Script.createInputScript=function(signature,pubKey){var script=new Script;script.writeBytes(signature);script.writeBytes(pubKey);return script};Script.createMultiSigInputScript=function(signatures,script){script=new Script(script);var k=script.chunks[0][0];if(signatures.length<k)return false;var inScript=new Script;inScript.writeOp(Opcode.map.OP_0);signatures.map(function(sig){inScript.writeBytes(sig)});inScript.writeBytes(script.buffer);return inScript};Script.prototype.clone=function(){return new Script(this.buffer)};module.exports=Script}).call(this,_dereq_("buffer").Buffer)},{"./address":54,"./convert":57,"./network":66,"./opcode":67,"./util":70,buffer:5}],69:[function(_dereq_,module,exports){var BigInteger=_dereq_("./jsbn/jsbn");var Script=_dereq_("./script");var util=_dereq_("./util");var convert=_dereq_("./convert");var ECKey=_dereq_("./eckey").ECKey;var ECDSA=_dereq_("./ecdsa");var Address=_dereq_("./address");var SHA256=_dereq_("crypto-js/sha256");var Transaction=function(doc){if(!(this instanceof Transaction)){return new Transaction(doc)}this.version=1;this.locktime=0;this.ins=[];this.outs=[];this.defaultSequence=[255,255,255,255];if(doc){if(typeof doc=="string"||Array.isArray(doc)){doc=Transaction.deserialize(doc)}if(doc.hash)this.hash=doc.hash;if(doc.version)this.version=doc.version;if(doc.locktime)this.locktime=doc.locktime;if(doc.ins&&doc.ins.length){doc.ins.forEach(function(input){this.addInput(new TransactionIn(input))},this)}if(doc.outs&&doc.outs.length){doc.outs.forEach(function(output){this.addOutput(new TransactionOut(output))},this)}this.hash=this.hash||this.getHash()}};Transaction.prototype.addInput=function(tx,outIndex){if(arguments[0]instanceof TransactionIn){this.ins.push(arguments[0])}else if(arguments[0].length>65){var args=arguments[0].split(":");return this.addInput(args[0],args[1])}else{var hash=typeof tx==="string"?tx:tx.hash;hash=Array.isArray(hash)?convert.bytesToHex(hash):hash;this.ins.push(new TransactionIn({outpoint:{hash:hash,index:outIndex},script:new Script,sequence:this.defaultSequence}))}};Transaction.prototype.addOutput=function(address,value){if(arguments[0]instanceof TransactionOut){this.outs.push(arguments[0]);return}if(arguments[0].indexOf(":")>=0){var args=arguments[0].split(":");address=args[0];value=parseInt(args[1])}this.outs.push(new TransactionOut({value:value,script:Script.createOutputScript(address)}))};Transaction.prototype.serialize=function(){var buffer=[];buffer=buffer.concat(convert.numToBytes(parseInt(this.version),4));buffer=buffer.concat(convert.numToVarInt(this.ins.length));this.ins.forEach(function(txin){buffer=buffer.concat(convert.hexToBytes(txin.outpoint.hash).reverse());buffer=buffer.concat(convert.numToBytes(parseInt(txin.outpoint.index),4));var scriptBytes=txin.script.buffer;buffer=buffer.concat(convert.numToVarInt(scriptBytes.length));buffer=buffer.concat(scriptBytes);buffer=buffer.concat(txin.sequence)});buffer=buffer.concat(convert.numToVarInt(this.outs.length));this.outs.forEach(function(txout){buffer=buffer.concat(convert.numToBytes(txout.value,8));var scriptBytes=txout.script.buffer;buffer=buffer.concat(convert.numToVarInt(scriptBytes.length));buffer=buffer.concat(scriptBytes)});buffer=buffer.concat(convert.numToBytes(parseInt(this.locktime),4));return buffer};Transaction.prototype.serializeHex=function(){return convert.bytesToHex(this.serialize())};var SIGHASH_ALL=1;var SIGHASH_NONE=2;var SIGHASH_SINGLE=3;var SIGHASH_ANYONECANPAY=80;Transaction.prototype.hashTransactionForSignature=function(connectedScript,inIndex,hashType){var txTmp=this.clone();txTmp.ins.forEach(function(txin){txin.script=new Script});txTmp.ins[inIndex].script=connectedScript;if((hashType&31)==SIGHASH_NONE){txTmp.outs=[];txTmp.ins.forEach(function(txin,i){if(i!=inIndex){txTmp.ins[i].sequence=0}})}else if((hashType&31)==SIGHASH_SINGLE){}if(hashType&SIGHASH_ANYONECANPAY){txTmp.ins=[txTmp.ins[inIndex]]}var buffer=txTmp.serialize();buffer=buffer.concat(convert.numToBytes(parseInt(hashType),4));buffer=convert.bytesToWordArray(buffer);return convert.wordArrayToBytes(SHA256(SHA256(buffer)))};Transaction.prototype.getHash=function(){var buffer=convert.bytesToWordArray(this.serialize());return convert.wordArrayToBytes(SHA256(SHA256(buffer))).reverse()};Transaction.prototype.clone=function(){var newTx=new Transaction;newTx.version=this.version;newTx.locktime=this.locktime;this.ins.forEach(function(txin){newTx.addInput(txin.clone())});this.outs.forEach(function(txout){newTx.addOutput(txout.clone())});return newTx};Transaction.deserialize=function(buffer){if(typeof buffer=="string"){buffer=convert.hexToBytes(buffer)}var pos=0;var readAsInt=function(bytes){if(bytes===0)return 0;pos++;return buffer[pos-1]+readAsInt(bytes-1)*256};var readVarInt=function(){var bytes=buffer.slice(pos,pos+9);var result=convert.varIntToNum(bytes);pos+=result.bytes.length;return result.number};var readBytes=function(bytes){pos+=bytes;return buffer.slice(pos-bytes,pos)};var readVarString=function(){var size=readVarInt();return readBytes(size)};var obj={ins:[],outs:[]};obj.version=readAsInt(4);var ins=readVarInt();var i;for(i=0;i<ins;i++){obj.ins.push({outpoint:{hash:convert.bytesToHex(readBytes(32).reverse()),index:readAsInt(4)},script:new Script(readVarString()),sequence:readBytes(4)})}var outs=readVarInt();for(i=0;i<outs;i++){obj.outs.push({value:convert.bytesToNum(readBytes(8)),script:new Script(readVarString())})}obj.locktime=readAsInt(4);return new Transaction(obj)};Transaction.prototype.sign=function(index,key,type){type=type||SIGHASH_ALL;key=new ECKey(key);var pub=key.getPub().toBytes(),hash160=util.sha256ripe160(pub),script=Script.createOutputScript(new Address(hash160)),hash=this.hashTransactionForSignature(script,index,type),sig=key.sign(hash).concat([type]);this.ins[index].script=Script.createInputScript(sig,pub)};Transaction.prototype.signWithKeys=function(keys,outputs,type){type=type||SIGHASH_ALL;var addrdata=keys.map(function(key){key=new ECKey(key);return{key:key,address:key.getAddress().toString()}});var hmap={};outputs.forEach(function(o){hmap[o.output]=o});for(var i=0;i<this.ins.length;i++){var outpoint=this.ins[i].outpoint.hash+":"+this.ins[i].outpoint.index;var histItem=hmap[outpoint];if(!histItem)continue;var thisInputAddrdata=addrdata.filter(function(a){return a.address==histItem.address});if(thisInputAddrdata.length===0)continue;this.sign(i,thisInputAddrdata[0].key)}};Transaction.prototype.p2shsign=function(index,script,key,type){script=new Script(script);key=new ECKey(key);type=type||SIGHASH_ALL;var hash=this.hashTransactionForSignature(script,index,type),sig=key.sign(hash).concat([type]);return sig};Transaction.prototype.multisign=Transaction.prototype.p2shsign;Transaction.prototype.applyMultisigs=function(index,script,sigs){this.ins[index].script=Script.createMultiSigInputScript(sigs,script)};Transaction.prototype.validateSig=function(index,script,sig,pub){script=new Script(script);var hash=this.hashTransactionForSignature(script,index,1);return ECDSA.verify(hash,convert.coerceToBytes(sig),convert.coerceToBytes(pub))};Transaction.feePerKb=2e4;Transaction.prototype.estimateFee=function(feePerKb){var uncompressedInSize=180;var outSize=34;var fixedPadding=34;if(feePerKb==undefined)feePerKb=Transaction.feePerKb;var size=this.ins.length*uncompressedInSize+this.outs.length*outSize+fixedPadding;return feePerKb*Math.ceil(size/1e3)};var TransactionIn=function(data){if(typeof data=="string"){this.outpoint={hash:data.split(":")[0],index:data.split(":")[1]}}else if(data.outpoint){this.outpoint=data.outpoint}else{this.outpoint={hash:data.hash,index:data.index}}if(data.scriptSig){this.script=Script.fromScriptSig(data.scriptSig)}else if(data.script){this.script=data.script}else{this.script=new Script(data.script)}this.sequence=data.sequence||this.defaultSequence};TransactionIn.prototype.clone=function(){return new TransactionIn({outpoint:{hash:this.outpoint.hash,index:this.outpoint.index},script:this.script.clone(),sequence:this.sequence})};var TransactionOut=function(data){this.script=data.script instanceof Script?data.script.clone():Array.isArray(data.script)?new Script(data.script):typeof data.script=="string"?new Script(convert.hexToBytes(data.script)):data.scriptPubKey?Script.fromScriptSig(data.scriptPubKey):data.address?Script.createOutputScript(data.address):new Script;if(this.script.buffer.length>0)this.address=this.script.getToAddress();this.value=Array.isArray(data.value)?convert.bytesToNum(data.value):"string"==typeof data.value?parseInt(data.value):data.value instanceof BigInteger?parseInt(data.value.toString()):data.value};TransactionOut.prototype.clone=function(){var newTxout=new TransactionOut({script:this.script.clone(),value:this.value});return newTxout};TransactionOut.prototype.scriptPubKey=function(){return convert.bytesToHex(this.script.buffer)};module.exports={Transaction:Transaction,TransactionIn:TransactionIn,TransactionOut:TransactionOut}},{"./address":54,"./convert":57,"./ecdsa":58,"./eckey":59,"./jsbn/jsbn":63,"./script":68,"./util":70,"crypto-js/sha256":47}],70:[function(_dereq_,module,exports){var convert=_dereq_("./convert.js");var Crypto=_dereq_("crypto-js");var RIPEMD160=Crypto.RIPEMD160;var SHA256=Crypto.SHA256;exports.sha256ripe160=function(data){var wordArray=RIPEMD160(SHA256(convert.bytesToWordArray(data)));return convert.wordArrayToBytes(wordArray)};exports.error=function(msg){throw new Error(msg)}},{"./convert.js":57,"crypto-js":27}],71:[function(_dereq_,module,exports){(function(process){var convert=_dereq_("./convert");var Transaction=_dereq_("./transaction").Transaction;var HDNode=_dereq_("./hdwallet.js");var rng=_dereq_("secure-random");function Wallet(seed,options){if(!(this instanceof Wallet)){return new Wallet(seed,options)}var options=options||{};var network=options.network||"mainnet";var masterkey=null;var me=this;var accountZero=null;var internalAccount=null;var externalAccount=null;this.addresses=[];this.changeAddresses=[];this.outputs={};this.newMasterKey=function(seed,network){if(!seed)seed=rng(32,{array:true});masterkey=new HDNode(seed,network);accountZero=masterkey.derivePrivate(0);externalAccount=accountZero.derive(0);internalAccount=accountZero.derive(1);me.addresses=[];me.changeAddresses=[];me.outputs={}};this.newMasterKey(seed,network);this.generateAddress=function(){var key=externalAccount.derive(this.addresses.length);this.addresses.push(key.getAddress().toString());return this.addresses[this.addresses.length-1]};this.generateChangeAddress=function(){var key=internalAccount.derive(this.changeAddresses.length);this.changeAddresses.push(key.getAddress().toString());return this.changeAddresses[this.changeAddresses.length-1]};this.getBalance=function(){return this.getUnspentOutputs().reduce(function(memo,output){return memo+output.value},0)};this.getUnspentOutputs=function(){var utxo=[];for(var key in this.outputs){var output=this.outputs[key];if(!output.spend)utxo.push(outputToUnspentOutput(output))}return utxo};this.setUnspentOutputs=function(utxo){var outputs={};utxo.forEach(function(uo){validateUnspentOutput(uo);var o=unspentOutputToOutput(uo);outputs[o.receive]=o});this.outputs=outputs};this.setUnspentOutputsAsync=function(utxo,callback){var error=null;try{this.setUnspentOutputs(utxo)}catch(err){error=err}finally{process.nextTick(function(){callback(error)})}};function outputToUnspentOutput(output){var hashAndIndex=output.receive.split(":");return{hash:hashAndIndex[0],hashLittleEndian:convert.reverseEndian(hashAndIndex[0]),outputIndex:parseInt(hashAndIndex[1]),address:output.address,value:output.value}}function unspentOutputToOutput(o){var hash=o.hash||convert.reverseEndian(o.hashLittleEndian);var key=hash+":"+o.outputIndex;return{receive:key,address:o.address,value:o.value}}function validateUnspentOutput(uo){var missingField;if(isNullOrUndefined(uo.hash)&&isNullOrUndefined(uo.hashLittleEndian)){missingField="hash(or hashLittleEndian)"}var requiredKeys=["outputIndex","address","value"];requiredKeys.forEach(function(key){if(isNullOrUndefined(uo[key])){missingField=key}});if(missingField){var message=["Invalid unspent output: key",missingField,"is missing.","A valid unspent output must contain"];message.push(requiredKeys.join(", "));message.push("and hash(or hashLittleEndian)");throw new Error(message.join(" "))}}function isNullOrUndefined(value){return value==undefined}this.processTx=function(tx){var txhash=convert.bytesToHex(tx.getHash());tx.outs.forEach(function(txOut,i){var address=txOut.address.toString();if(isMyAddress(address)){var output=txhash+":"+i;me.outputs[output]={receive:output,value:txOut.value,address:address}}});tx.ins.forEach(function(txIn,i){var op=txIn.outpoint;var o=me.outputs[op.hash+":"+op.index];if(o){o.spend=txhash+":"+i}})};this.createTx=function(to,value,fixedFee){checkDust(value);var tx=new Transaction;tx.addOutput(to,value);var utxo=getCandidateOutputs(value);var totalInValue=0;for(var i=0;i<utxo.length;i++){var output=utxo[i];tx.addInput(output.receive);totalInValue+=output.value;if(totalInValue<value)continue;var fee=fixedFee==undefined?estimateFeePadChangeOutput(tx):fixedFee;if(totalInValue<value+fee)continue;var change=totalInValue-value-fee;if(change>0&&!isDust(change)){tx.addOutput(getChangeAddress(),change)}break}checkInsufficientFund(totalInValue,value,fee);this.sign(tx);return tx};this.createTxAsync=function(to,value,fixedFee,callback){if(fixedFee instanceof Function){callback=fixedFee;fixedFee=undefined}var tx=null;var error=null;try{tx=this.createTx(to,value,fixedFee)}catch(err){error=err}finally{process.nextTick(function(){callback(error,tx)})}};this.dustThreshold=5430;function isDust(amount){return amount<=me.dustThreshold}function checkDust(value){if(isNullOrUndefined(value)||isDust(value)){throw new Error("Value must be above dust threshold")}}function getCandidateOutputs(value){var unspent=[];for(var key in me.outputs){var output=me.outputs[key];if(!output.spend)unspent.push(output)}var sortByValueDesc=unspent.sort(function(o1,o2){return o2.value-o1.value});return sortByValueDesc}function estimateFeePadChangeOutput(tx){var tmpTx=tx.clone();tmpTx.addOutput(getChangeAddress(),0);return tmpTx.estimateFee()}function getChangeAddress(){if(me.changeAddresses.length===0)me.generateChangeAddress();return me.changeAddresses[me.changeAddresses.length-1]}function checkInsufficientFund(totalInValue,value,fee){if(totalInValue<value+fee){throw new Error("Not enough money to send funds including transaction fee. Have: "+totalInValue+", needed: "+(value+fee))}}this.sign=function(tx){tx.ins.forEach(function(inp,i){var output=me.outputs[inp.outpoint.hash+":"+inp.outpoint.index];if(output){tx.sign(i,me.getPrivateKeyForAddress(output.address))}});return tx};this.getMasterKey=function(){return masterkey};this.getAccountZero=function(){return accountZero};this.getInternalAccount=function(){return internalAccount};this.getExternalAccount=function(){return externalAccount};this.getPrivateKey=function(index){return externalAccount.derive(index).priv};this.getInternalPrivateKey=function(index){return internalAccount.derive(index).priv};this.getPrivateKeyForAddress=function(address){var index;if((index=this.addresses.indexOf(address))>-1){return this.getPrivateKey(index)}else if((index=this.changeAddresses.indexOf(address))>-1){return this.getInternalPrivateKey(index)}else{throw new Error("Unknown address. Make sure the address is from the keychain and has been generated.")}};function isReceiveAddress(address){return me.addresses.indexOf(address)>-1}function isChangeAddress(address){return me.changeAddresses.indexOf(address)>-1}function isMyAddress(address){return isReceiveAddress(address)||isChangeAddress(address)}}module.exports=Wallet}).call(this,_dereq_("FWaASH"))},{"./convert":57,"./hdwallet.js":60,"./transaction":69,FWaASH:15,"secure-random":53}]},{},[61])(61)});
/*! peerjs build:0.3.13, development. Copyright(c) 2013 Michelle Bu <michelle@michellebu.com> */(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports.RTCSessionDescription = window.RTCSessionDescription ||
	window.mozRTCSessionDescription;
module.exports.RTCPeerConnection = window.RTCPeerConnection ||
	window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
module.exports.RTCIceCandidate = window.RTCIceCandidate ||
	window.mozRTCIceCandidate;

},{}],2:[function(require,module,exports){
var util = require('./util');
var EventEmitter = require('eventemitter3');
var Negotiator = require('./negotiator');
var Reliable = require('reliable');

/**
 * Wraps a DataChannel between two Peers.
 */
function DataConnection(peer, provider, options) {
  if (!(this instanceof DataConnection)) return new DataConnection(peer, provider, options);
  EventEmitter.call(this);

  this.options = util.extend({
    serialization: 'binary',
    reliable: false
  }, options);

  // Connection is not open yet.
  this.open = false;
  this.type = 'data';
  this.peer = peer;
  this.provider = provider;

  this.id = this.options.connectionId || DataConnection._idPrefix + util.randomToken();

  this.label = this.options.label || this.id;
  this.metadata = this.options.metadata;
  this.serialization = this.options.serialization;
  this.reliable = this.options.reliable;

  // Data channel buffering.
  this._buffer = [];
  this._buffering = false;
  this.bufferSize = 0;

  // For storing large data.
  this._chunkedData = {};

  if (this.options._payload) {
    this._peerBrowser = this.options._payload.browser;
  }

  Negotiator.startConnection(
    this,
    this.options._payload || {
      originator: true
    }
  );
}

util.inherits(DataConnection, EventEmitter);

DataConnection._idPrefix = 'dc_';

/** Called by the Negotiator when the DataChannel is ready. */
DataConnection.prototype.initialize = function(dc) {
  this._dc = this.dataChannel = dc;
  this._configureDataChannel();
}

DataConnection.prototype._configureDataChannel = function() {
  var self = this;
  if (util.supports.sctp) {
    this._dc.binaryType = 'arraybuffer';
  }
  this._dc.onopen = function() {
    util.log('Data channel connection success');
    self.open = true;
    self.emit('open');
  }

  // Use the Reliable shim for non Firefox browsers
  if (!util.supports.sctp && this.reliable) {
    this._reliable = new Reliable(this._dc, util.debug);
  }

  if (this._reliable) {
    this._reliable.onmessage = function(msg) {
      self.emit('data', msg);
    };
  } else {
    this._dc.onmessage = function(e) {
      self._handleDataMessage(e);
    };
  }
  this._dc.onclose = function(e) {
    util.log('DataChannel closed for:', self.peer);
    self.close();
  };
}

// Handles a DataChannel message.
DataConnection.prototype._handleDataMessage = function(e) {
  var self = this;
  var data = e.data;
  var datatype = data.constructor;
  if (this.serialization === 'binary' || this.serialization === 'binary-utf8') {
    if (datatype === Blob) {
      // Datatype should never be blob
      util.blobToArrayBuffer(data, function(ab) {
        data = util.unpack(ab);
        self.emit('data', data);
      });
      return;
    } else if (datatype === ArrayBuffer) {
      data = util.unpack(data);
    } else if (datatype === String) {
      // String fallback for binary data for browsers that don't support binary yet
      var ab = util.binaryStringToArrayBuffer(data);
      data = util.unpack(ab);
    }
  } else if (this.serialization === 'json') {
    data = JSON.parse(data);
  }

  // Check if we've chunked--if so, piece things back together.
  // We're guaranteed that this isn't 0.
  if (data.__peerData) {
    var id = data.__peerData;
    var chunkInfo = this._chunkedData[id] || {data: [], count: 0, total: data.total};

    chunkInfo.data[data.n] = data.data;
    chunkInfo.count += 1;

    if (chunkInfo.total === chunkInfo.count) {
      // Clean up before making the recursive call to `_handleDataMessage`.
      delete this._chunkedData[id];

      // We've received all the chunks--time to construct the complete data.
      data = new Blob(chunkInfo.data);
      this._handleDataMessage({data: data});
    }

    this._chunkedData[id] = chunkInfo;
    return;
  }

  this.emit('data', data);
}

/**
 * Exposed functionality for users.
 */

/** Allows user to close connection. */
DataConnection.prototype.close = function() {
  if (!this.open) {
    return;
  }
  this.open = false;
  Negotiator.cleanup(this);
  this.emit('close');
}

/** Allows user to send data. */
DataConnection.prototype.send = function(data, chunked) {
  if (!this.open) {
    this.emit('error', new Error('Connection is not open. You should listen for the `open` event before sending messages.'));
    return;
  }
  if (this._reliable) {
    // Note: reliable shim sending will make it so that you cannot customize
    // serialization.
    this._reliable.send(data);
    return;
  }
  var self = this;
  if (this.serialization === 'json') {
    this._bufferedSend(JSON.stringify(data));
  } else if (this.serialization === 'binary' || this.serialization === 'binary-utf8') {
    var blob = util.pack(data);

    // For Chrome-Firefox interoperability, we need to make Firefox "chunk"
    // the data it sends out.
    var needsChunking = util.chunkedBrowsers[this._peerBrowser] || util.chunkedBrowsers[util.browser];
    if (needsChunking && !chunked && blob.size > util.chunkedMTU) {
      this._sendChunks(blob);
      return;
    }

    // DataChannel currently only supports strings.
    if (!util.supports.sctp) {
      util.blobToBinaryString(blob, function(str) {
        self._bufferedSend(str);
      });
    } else if (!util.supports.binaryBlob) {
      // We only do this if we really need to (e.g. blobs are not supported),
      // because this conversion is costly.
      util.blobToArrayBuffer(blob, function(ab) {
        self._bufferedSend(ab);
      });
    } else {
      this._bufferedSend(blob);
    }
  } else {
    this._bufferedSend(data);
  }
}

DataConnection.prototype._bufferedSend = function(msg) {
  if (this._buffering || !this._trySend(msg)) {
    this._buffer.push(msg);
    this.bufferSize = this._buffer.length;
  }
}

// Returns true if the send succeeds.
DataConnection.prototype._trySend = function(msg) {
  try {
    this._dc.send(msg);
  } catch (e) {
    this._buffering = true;

    var self = this;
    setTimeout(function() {
      // Try again.
      self._buffering = false;
      self._tryBuffer();
    }, 100);
    return false;
  }
  return true;
}

// Try to send the first message in the buffer.
DataConnection.prototype._tryBuffer = function() {
  if (this._buffer.length === 0) {
    return;
  }

  var msg = this._buffer[0];

  if (this._trySend(msg)) {
    this._buffer.shift();
    this.bufferSize = this._buffer.length;
    this._tryBuffer();
  }
}

DataConnection.prototype._sendChunks = function(blob) {
  var blobs = util.chunk(blob);
  for (var i = 0, ii = blobs.length; i < ii; i += 1) {
    var blob = blobs[i];
    this.send(blob, true);
  }
}

DataConnection.prototype.handleMessage = function(message) {
  var payload = message.payload;

  switch (message.type) {
    case 'ANSWER':
      this._peerBrowser = payload.browser;

      // Forward to negotiator
      Negotiator.handleSDP(message.type, this, payload.sdp);
      break;
    case 'CANDIDATE':
      Negotiator.handleCandidate(this, payload.candidate);
      break;
    default:
      util.warn('Unrecognized message type:', message.type, 'from peer:', this.peer);
      break;
  }
}

module.exports = DataConnection;

},{"./negotiator":5,"./util":8,"eventemitter3":9,"reliable":12}],3:[function(require,module,exports){
  if(typeof window == 'undefined') return false;
window.Socket = require('./socket');
window.MediaConnection = require('./mediaconnection');
window.DataConnection = require('./dataconnection');
window.Peer = require('./peer');
window.RTCPeerConnection = require('./adapter').RTCPeerConnection;
window.RTCSessionDescription = require('./adapter').RTCSessionDescription;
window.RTCIceCandidate = require('./adapter').RTCIceCandidate;
window.Negotiator = require('./negotiator');
window.util = require('./util');
window.BinaryPack = require('js-binarypack');

},{"./adapter":1,"./dataconnection":2,"./mediaconnection":4,"./negotiator":5,"./peer":6,"./socket":7,"./util":8,"js-binarypack":10}],4:[function(require,module,exports){
var util = require('./util');
var EventEmitter = require('eventemitter3');
var Negotiator = require('./negotiator');

/**
 * Wraps the streaming interface between two Peers.
 */
function MediaConnection(peer, provider, options) {
  if (!(this instanceof MediaConnection)) return new MediaConnection(peer, provider, options);
  EventEmitter.call(this);

  this.options = util.extend({}, options);

  this.open = false;
  this.type = 'media';
  this.peer = peer;
  this.provider = provider;
  this.metadata = this.options.metadata;
  this.localStream = this.options._stream;

  this.id = this.options.connectionId || MediaConnection._idPrefix + util.randomToken();
  if (this.localStream) {
    Negotiator.startConnection(
      this,
      {_stream: this.localStream, originator: true}
    );
  }
};

util.inherits(MediaConnection, EventEmitter);

MediaConnection._idPrefix = 'mc_';

MediaConnection.prototype.addStream = function(remoteStream) {
  util.log('Receiving stream', remoteStream);

  this.remoteStream = remoteStream;
  this.emit('stream', remoteStream); // Should we call this `open`?

};

MediaConnection.prototype.handleMessage = function(message) {
  var payload = message.payload;

  switch (message.type) {
    case 'ANSWER':
      // Forward to negotiator
      Negotiator.handleSDP(message.type, this, payload.sdp);
      this.open = true;
      break;
    case 'CANDIDATE':
      Negotiator.handleCandidate(this, payload.candidate);
      break;
    default:
      util.warn('Unrecognized message type:', message.type, 'from peer:', this.peer);
      break;
  }
}

MediaConnection.prototype.answer = function(stream) {
  if (this.localStream) {
    util.warn('Local stream already exists on this MediaConnection. Are you answering a call twice?');
    return;
  }

  this.options._payload._stream = stream;

  this.localStream = stream;
  Negotiator.startConnection(
    this,
    this.options._payload
  )
  // Retrieve lost messages stored because PeerConnection not set up.
  var messages = this.provider._getMessages(this.id);
  for (var i = 0, ii = messages.length; i < ii; i += 1) {
    this.handleMessage(messages[i]);
  }
  this.open = true;
};

/**
 * Exposed functionality for users.
 */

/** Allows user to close connection. */
MediaConnection.prototype.close = function() {
  if (!this.open) {
    return;
  }
  this.open = false;
  Negotiator.cleanup(this);
  this.emit('close')
};

module.exports = MediaConnection;

},{"./negotiator":5,"./util":8,"eventemitter3":9}],5:[function(require,module,exports){
var util = require('./util');
var RTCPeerConnection = require('./adapter').RTCPeerConnection;
var RTCSessionDescription = require('./adapter').RTCSessionDescription;
var RTCIceCandidate = require('./adapter').RTCIceCandidate;

/**
 * Manages all negotiations between Peers.
 */
var Negotiator = {
  pcs: {
    data: {},
    media: {}
  }, // type => {peerId: {pc_id: pc}}.
  //providers: {}, // provider's id => providers (there may be multiple providers/client.
  queue: [] // connections that are delayed due to a PC being in use.
}

Negotiator._idPrefix = 'pc_';

/** Returns a PeerConnection object set up correctly (for data, media). */
Negotiator.startConnection = function(connection, options) {
  var pc = Negotiator._getPeerConnection(connection, options);

  if (connection.type === 'media' && options._stream) {
    // Add the stream.
    pc.addStream(options._stream);
  }

  // Set the connection's PC.
  connection.pc = connection.peerConnection = pc;
  // What do we need to do now?
  if (options.originator) {
    if (connection.type === 'data') {
      // Create the datachannel.
      var config = {};
      // Dropping reliable:false support, since it seems to be crashing
      // Chrome.
      /*if (util.supports.sctp && !options.reliable) {
        // If we have canonical reliable support...
        config = {maxRetransmits: 0};
      }*/
      // Fallback to ensure older browsers don't crash.
      if (!util.supports.sctp) {
        config = {reliable: options.reliable};
      }
      var dc = pc.createDataChannel(connection.label, config);
      connection.initialize(dc);
    }

    if (!util.supports.onnegotiationneeded) {
      Negotiator._makeOffer(connection);
    }
  } else {
    Negotiator.handleSDP('OFFER', connection, options.sdp);
  }
}

Negotiator._getPeerConnection = function(connection, options) {
  if (!Negotiator.pcs[connection.type]) {
    util.error(connection.type + ' is not a valid connection type. Maybe you overrode the `type` property somewhere.');
  }

  if (!Negotiator.pcs[connection.type][connection.peer]) {
    Negotiator.pcs[connection.type][connection.peer] = {};
  }
  var peerConnections = Negotiator.pcs[connection.type][connection.peer];

  var pc;
  // Not multiplexing while FF and Chrome have not-great support for it.
  /*if (options.multiplex) {
    ids = Object.keys(peerConnections);
    for (var i = 0, ii = ids.length; i < ii; i += 1) {
      pc = peerConnections[ids[i]];
      if (pc.signalingState === 'stable') {
        break; // We can go ahead and use this PC.
      }
    }
  } else */
  if (options.pc) { // Simplest case: PC id already provided for us.
    pc = Negotiator.pcs[connection.type][connection.peer][options.pc];
  }

  if (!pc || pc.signalingState !== 'stable') {
    pc = Negotiator._startPeerConnection(connection);
  }
  return pc;
}

/*
Negotiator._addProvider = function(provider) {
  if ((!provider.id && !provider.disconnected) || !provider.socket.open) {
    // Wait for provider to obtain an ID.
    provider.on('open', function(id) {
      Negotiator._addProvider(provider);
    });
  } else {
    Negotiator.providers[provider.id] = provider;
  }
}*/


/** Start a PC. */
Negotiator._startPeerConnection = function(connection) {
  util.log('Creating RTCPeerConnection.');

  var id = Negotiator._idPrefix + util.randomToken();
  var optional = {};

  if (connection.type === 'data' && !util.supports.sctp) {
    optional = {optional: [{RtpDataChannels: true}]};
  } else if (connection.type === 'media') {
    // Interop req for chrome.
    optional = {optional: [{DtlsSrtpKeyAgreement: true}]};
  }

  var pc = new RTCPeerConnection(connection.provider.options.config, optional);
  Negotiator.pcs[connection.type][connection.peer][id] = pc;

  Negotiator._setupListeners(connection, pc, id);

  return pc;
}

/** Set up various WebRTC listeners. */
Negotiator._setupListeners = function(connection, pc, pc_id) {
  var peerId = connection.peer;
  var connectionId = connection.id;
  var provider = connection.provider;

  // ICE CANDIDATES.
  util.log('Listening for ICE candidates.');
  pc.onicecandidate = function(evt) {
    if (evt.candidate) {
      util.log('Received ICE candidates for:', connection.peer);
      provider.socket.send({
        type: 'CANDIDATE',
        payload: {
          candidate: evt.candidate,
          type: connection.type,
          connectionId: connection.id
        },
        dst: peerId
      });
    }
  };

  pc.oniceconnectionstatechange = function() {
    switch (pc.iceConnectionState) {
      case 'disconnected':
      case 'failed':
        util.log('iceConnectionState is disconnected, closing connections to ' + peerId);
        connection.close();
        break;
      case 'completed':
        pc.onicecandidate = util.noop;
        break;
    }
  };

  // Fallback for older Chrome impls.
  pc.onicechange = pc.oniceconnectionstatechange;

  // ONNEGOTIATIONNEEDED (Chrome)
  util.log('Listening for `negotiationneeded`');
  pc.onnegotiationneeded = function() {
    util.log('`negotiationneeded` triggered');
    if (pc.signalingState == 'stable') {
      Negotiator._makeOffer(connection);
    } else {
      util.log('onnegotiationneeded triggered when not stable. Is another connection being established?');
    }
  };

  // DATACONNECTION.
  util.log('Listening for data channel');
  // Fired between offer and answer, so options should already be saved
  // in the options hash.
  pc.ondatachannel = function(evt) {
    util.log('Received data channel');
    var dc = evt.channel;
    var connection = provider.getConnection(peerId, connectionId);
    connection.initialize(dc);
  };

  // MEDIACONNECTION.
  util.log('Listening for remote stream');
  pc.onaddstream = function(evt) {
    util.log('Received remote stream');
    var stream = evt.stream;
    var connection = provider.getConnection(peerId, connectionId);
    // 10/10/2014: looks like in Chrome 38, onaddstream is triggered after
    // setting the remote description. Our connection object in these cases
    // is actually a DATA connection, so addStream fails.
    // TODO: This is hopefully just a temporary fix. We should try to
    // understand why this is happening.
    if (connection.type === 'media') {
      connection.addStream(stream);
    }
  };
}

Negotiator.cleanup = function(connection) {
  util.log('Cleaning up PeerConnection to ' + connection.peer);

  var pc = connection.pc;

  if (!!pc && (pc.readyState !== 'closed' || pc.signalingState !== 'closed')) {
    pc.close();
    connection.pc = null;
  }
}

Negotiator._makeOffer = function(connection) {
  var pc = connection.pc;
  pc.createOffer(function(offer) {
    util.log('Created offer.');

    if (!util.supports.sctp && connection.type === 'data' && connection.reliable) {
      offer.sdp = Reliable.higherBandwidthSDP(offer.sdp);
    }

    pc.setLocalDescription(offer, function() {
      util.log('Set localDescription: offer', 'for:', connection.peer);
      connection.provider.socket.send({
        type: 'OFFER',
        payload: {
          sdp: offer,
          type: connection.type,
          label: connection.label,
          connectionId: connection.id,
          reliable: connection.reliable,
          serialization: connection.serialization,
          metadata: connection.metadata,
          browser: util.browser
        },
        dst: connection.peer
      });
    }, function(err) {
      connection.provider.emitError('webrtc', err);
      util.log('Failed to setLocalDescription, ', err);
    });
  }, function(err) {
    connection.provider.emitError('webrtc', err);
    util.log('Failed to createOffer, ', err);
  }, connection.options.constraints);
}

Negotiator._makeAnswer = function(connection) {
  var pc = connection.pc;

  pc.createAnswer(function(answer) {
    util.log('Created answer.');

    if (!util.supports.sctp && connection.type === 'data' && connection.reliable) {
      answer.sdp = Reliable.higherBandwidthSDP(answer.sdp);
    }

    pc.setLocalDescription(answer, function() {
      util.log('Set localDescription: answer', 'for:', connection.peer);
      connection.provider.socket.send({
        type: 'ANSWER',
        payload: {
          sdp: answer,
          type: connection.type,
          connectionId: connection.id,
          browser: util.browser
        },
        dst: connection.peer
      });
    }, function(err) {
      connection.provider.emitError('webrtc', err);
      util.log('Failed to setLocalDescription, ', err);
    });
  }, function(err) {
    connection.provider.emitError('webrtc', err);
    util.log('Failed to create answer, ', err);
  });
}

/** Handle an SDP. */
Negotiator.handleSDP = function(type, connection, sdp) {
  sdp = new RTCSessionDescription(sdp);
  var pc = connection.pc;

  util.log('Setting remote description', sdp);
  pc.setRemoteDescription(sdp, function() {
    util.log('Set remoteDescription:', type, 'for:', connection.peer);

    if (type === 'OFFER') {
      Negotiator._makeAnswer(connection);
    }
  }, function(err) {
    connection.provider.emitError('webrtc', err);
    util.log('Failed to setRemoteDescription, ', err);
  });
}

/** Handle a candidate. */
Negotiator.handleCandidate = function(connection, ice) {
  var candidate = ice.candidate;
  var sdpMLineIndex = ice.sdpMLineIndex;
  connection.pc.addIceCandidate(new RTCIceCandidate({
    sdpMLineIndex: sdpMLineIndex,
    candidate: candidate
  }));
  util.log('Added ICE candidate for:', connection.peer);
}

module.exports = Negotiator;

},{"./adapter":1,"./util":8}],6:[function(require,module,exports){
var util = require('./util');
var EventEmitter = require('eventemitter3');
var Socket = require('./socket');
var MediaConnection = require('./mediaconnection');
var DataConnection = require('./dataconnection');

/**
 * A peer who can initiate connections with other peers.
 */
function Peer(id, options) {
  if (!(this instanceof Peer)) return new Peer(id, options);
  EventEmitter.call(this);

  // Deal with overloading
  if (id && id.constructor == Object) {
    options = id;
    id = undefined;
  } else if (id) {
    // Ensure id is a string
    id = id.toString();
  }
  //

  // Configurize options
  options = util.extend({
    debug: 0, // 1: Errors, 2: Warnings, 3: All logs
    host: util.CLOUD_HOST,
    port: util.CLOUD_PORT,
    key: 'peerjs',
    path: '/',
    token: util.randomToken(),
    config: util.defaultConfig
  }, options);
  this.options = options;
  // Detect relative URL host.
  if (options.host === '/') {
    options.host = window.location.hostname;
  }
  // Set path correctly.
  if (options.path[0] !== '/') {
    options.path = '/' + options.path;
  }
  if (options.path[options.path.length - 1] !== '/') {
    options.path += '/';
  }

  // Set whether we use SSL to same as current host
  if (options.secure === undefined && options.host !== util.CLOUD_HOST) {
    options.secure = util.isSecure();
  }
  // Set a custom log function if present
  if (options.logFunction) {
    util.setLogFunction(options.logFunction);
  }
  util.setLogLevel(options.debug);
  //

  // Sanity checks
  // Ensure WebRTC supported
  if (!util.supports.audioVideo && !util.supports.data ) {
    this._delayedAbort('browser-incompatible', 'The current browser does not support WebRTC');
    return;
  }
  // Ensure alphanumeric id
  if (!util.validateId(id)) {
    this._delayedAbort('invalid-id', 'ID "' + id + '" is invalid');
    return;
  }
  // Ensure valid key
  if (!util.validateKey(options.key)) {
    this._delayedAbort('invalid-key', 'API KEY "' + options.key + '" is invalid');
    return;
  }
  // Ensure not using unsecure cloud server on SSL page
  if (options.secure && options.host === '0.peerjs.com') {
    this._delayedAbort('ssl-unavailable',
      'The cloud server currently does not support HTTPS. Please run your own PeerServer to use HTTPS.');
    return;
  }
  //

  // States.
  this.destroyed = false; // Connections have been killed
  this.disconnected = false; // Connection to PeerServer killed but P2P connections still active
  this.open = false; // Sockets and such are not yet open.
  //

  // References
  this.connections = {}; // DataConnections for this peer.
  this._lostMessages = {}; // src => [list of messages]
  //

  // Start the server connection
  this._initializeServerConnection();
  if (id) {
    this._initialize(id);
  } else {
    this._retrieveId();
  }
  //
}

util.inherits(Peer, EventEmitter);

// Initialize the 'socket' (which is actually a mix of XHR streaming and
// websockets.)
Peer.prototype._initializeServerConnection = function() {
  var self = this;
  this.socket = new Socket(this.options.secure, this.options.host, this.options.port, this.options.path, this.options.key);
  this.socket.on('message', function(data) {
    self._handleMessage(data);
  });
  this.socket.on('error', function(error) {
    self._abort('socket-error', error);
  });
  this.socket.on('disconnected', function() {
    // If we haven't explicitly disconnected, emit error and disconnect.
    if (!self.disconnected) {
      self.emitError('network', 'Lost connection to server.');
      self.disconnect();
    }
  });
  this.socket.on('close', function() {
    // If we haven't explicitly disconnected, emit error.
    if (!self.disconnected) {
      self._abort('socket-closed', 'Underlying socket is already closed.');
    }
  });
};

/** Get a unique ID from the server via XHR. */
Peer.prototype._retrieveId = function(cb) {
  var self = this;
  var http = new XMLHttpRequest();
  var protocol = this.options.secure ? 'https://' : 'http://';
  var url = protocol + this.options.host + ':' + this.options.port +
    this.options.path + this.options.key + '/id';
  var queryString = '?ts=' + new Date().getTime() + '' + Math.random();
  url += queryString;

  // If there's no ID we need to wait for one before trying to init socket.
  http.open('get', url, true);
  http.onerror = function(e) {
    util.error('Error retrieving ID', e);
    var pathError = '';
    if (self.options.path === '/' && self.options.host !== util.CLOUD_HOST) {
      pathError = ' If you passed in a `path` to your self-hosted PeerServer, ' +
        'you\'ll also need to pass in that same path when creating a new ' +
        'Peer.';
    }
    self._abort('server-error', 'Could not get an ID from the server.' + pathError);
  };
  http.onreadystatechange = function() {
    if (http.readyState !== 4) {
      return;
    }
    if (http.status !== 200) {
      http.onerror();
      return;
    }
    self._initialize(http.responseText);
  };
  http.send(null);
};

/** Initialize a connection with the server. */
Peer.prototype._initialize = function(id) {
  this.id = id;
  this.socket.start(this.id, this.options.token);
};

/** Handles messages from the server. */
Peer.prototype._handleMessage = function(message) {
  var type = message.type;
  var payload = message.payload;
  var peer = message.src;
  var connection;

  switch (type) {
    case 'OPEN': // The connection to the server is open.
      this.emit('open', this.id);
      this.open = true;
      break;
    case 'ERROR': // Server error.
      this._abort('server-error', payload.msg);
      break;
    case 'ID-TAKEN': // The selected ID is taken.
      this._abort('unavailable-id', 'ID `' + this.id + '` is taken');
      break;
    case 'INVALID-KEY': // The given API key cannot be found.
      this._abort('invalid-key', 'API KEY "' + this.options.key + '" is invalid');
      break;

    //
    case 'LEAVE': // Another peer has closed its connection to this peer.
      util.log('Received leave message from', peer);
      this._cleanupPeer(peer);
      break;

    case 'EXPIRE': // The offer sent to a peer has expired without response.
      this.emitError('peer-unavailable', 'Could not connect to peer ' + peer);
      break;
    case 'OFFER': // we should consider switching this to CALL/CONNECT, but this is the least breaking option.
      var connectionId = payload.connectionId;
      connection = this.getConnection(peer, connectionId);

      if (connection) {
        util.warn('Offer received for existing Connection ID:', connectionId);
        //connection.handleMessage(message);
      } else {
        // Create a new connection.
        if (payload.type === 'media') {
          connection = new MediaConnection(peer, this, {
            connectionId: connectionId,
            _payload: payload,
            metadata: payload.metadata
          });
          this._addConnection(peer, connection);
          this.emit('call', connection);
        } else if (payload.type === 'data') {
          connection = new DataConnection(peer, this, {
            connectionId: connectionId,
            _payload: payload,
            metadata: payload.metadata,
            label: payload.label,
            serialization: payload.serialization,
            reliable: payload.reliable
          });
          this._addConnection(peer, connection);
          this.emit('connection', connection);
        } else {
          util.warn('Received malformed connection type:', payload.type);
          return;
        }
        // Find messages.
        var messages = this._getMessages(connectionId);
        for (var i = 0, ii = messages.length; i < ii; i += 1) {
          connection.handleMessage(messages[i]);
        }
      }
      break;
    default:
      if (!payload) {
        util.warn('You received a malformed message from ' + peer + ' of type ' + type);
        return;
      }

      var id = payload.connectionId;
      connection = this.getConnection(peer, id);

      if (connection && connection.pc) {
        // Pass it on.
        connection.handleMessage(message);
      } else if (id) {
        // Store for possible later use
        this._storeMessage(id, message);
      } else {
        util.warn('You received an unrecognized message:', message);
      }
      break;
  }
};

/** Stores messages without a set up connection, to be claimed later. */
Peer.prototype._storeMessage = function(connectionId, message) {
  if (!this._lostMessages[connectionId]) {
    this._lostMessages[connectionId] = [];
  }
  this._lostMessages[connectionId].push(message);
};

/** Retrieve messages from lost message store */
Peer.prototype._getMessages = function(connectionId) {
  var messages = this._lostMessages[connectionId];
  if (messages) {
    delete this._lostMessages[connectionId];
    return messages;
  } else {
    return [];
  }
};

/**
 * Returns a DataConnection to the specified peer. See documentation for a
 * complete list of options.
 */
Peer.prototype.connect = function(peer, options) {
  if (this.disconnected) {
    util.warn('You cannot connect to a new Peer because you called ' +
      '.disconnect() on this Peer and ended your connection with the ' +
      'server. You can create a new Peer to reconnect, or call reconnect ' +
      'on this peer if you believe its ID to still be available.');
    this.emitError('disconnected', 'Cannot connect to new Peer after disconnecting from server.');
    return;
  }
  var connection = new DataConnection(peer, this, options);
  this._addConnection(peer, connection);
  return connection;
};

/**
 * Returns a MediaConnection to the specified peer. See documentation for a
 * complete list of options.
 */
Peer.prototype.call = function(peer, stream, options) {
  if (this.disconnected) {
    util.warn('You cannot connect to a new Peer because you called ' +
      '.disconnect() on this Peer and ended your connection with the ' +
      'server. You can create a new Peer to reconnect.');
    this.emitError('disconnected', 'Cannot connect to new Peer after disconnecting from server.');
    return;
  }
  if (!stream) {
    util.error('To call a peer, you must provide a stream from your browser\'s `getUserMedia`.');
    return;
  }
  options = options || {};
  options._stream = stream;
  var call = new MediaConnection(peer, this, options);
  this._addConnection(peer, call);
  return call;
};

/** Add a data/media connection to this peer. */
Peer.prototype._addConnection = function(peer, connection) {
  if (!this.connections[peer]) {
    this.connections[peer] = [];
  }
  this.connections[peer].push(connection);
};

/** Retrieve a data/media connection for this peer. */
Peer.prototype.getConnection = function(peer, id) {
  var connections = this.connections[peer];
  if (!connections) {
    return null;
  }
  for (var i = 0, ii = connections.length; i < ii; i++) {
    if (connections[i].id === id) {
      return connections[i];
    }
  }
  return null;
};

Peer.prototype._delayedAbort = function(type, message) {
  var self = this;
  util.setZeroTimeout(function(){
    self._abort(type, message);
  });
};

/**
 * Destroys the Peer and emits an error message.
 * The Peer is not destroyed if it's in a disconnected state, in which case
 * it retains its disconnected state and its existing connections.
 */
Peer.prototype._abort = function(type, message) {
  util.error('Aborting!');
  if (!this._lastServerId) {
    this.destroy();
  } else {
    this.disconnect();
  }
  this.emitError(type, message);
};

/** Emits a typed error message. */
Peer.prototype.emitError = function(type, err) {
  util.error('Error:', err);
  if (typeof err === 'string') {
    err = new Error(err);
  }
  err.type = type;
  this.emit('error', err);
};

/**
 * Destroys the Peer: closes all active connections as well as the connection
 *  to the server.
 * Warning: The peer can no longer create or accept connections after being
 *  destroyed.
 */
Peer.prototype.destroy = function() {
  if (!this.destroyed) {
    this._cleanup();
    this.disconnect();
    this.destroyed = true;
  }
};


/** Disconnects every connection on this peer. */
Peer.prototype._cleanup = function() {
  if (this.connections) {
    var peers = Object.keys(this.connections);
    for (var i = 0, ii = peers.length; i < ii; i++) {
      this._cleanupPeer(peers[i]);
    }
  }
  this.emit('close');
};

/** Closes all connections to this peer. */
Peer.prototype._cleanupPeer = function(peer) {
  var connections = this.connections[peer];
  for (var j = 0, jj = connections.length; j < jj; j += 1) {
    connections[j].close();
  }
};

/**
 * Disconnects the Peer's connection to the PeerServer. Does not close any
 *  active connections.
 * Warning: The peer can no longer create or accept connections after being
 *  disconnected. It also cannot reconnect to the server.
 */
Peer.prototype.disconnect = function() {
  var self = this;
  util.setZeroTimeout(function(){
    if (!self.disconnected) {
      self.disconnected = true;
      self.open = false;
      if (self.socket) {
        self.socket.close();
      }
      self.emit('disconnected', self.id);
      self._lastServerId = self.id;
      self.id = null;
    }
  });
};

/** Attempts to reconnect with the same ID. */
Peer.prototype.reconnect = function() {
  if (this.disconnected && !this.destroyed) {
    util.log('Attempting reconnection to server with ID ' + this._lastServerId);
    this.disconnected = false;
    this._initializeServerConnection();
    this._initialize(this._lastServerId);
  } else if (this.destroyed) {
    throw new Error('This peer cannot reconnect to the server. It has already been destroyed.');
  } else if (!this.disconnected && !this.open) {
    // Do nothing. We're still connecting the first time.
    util.error('In a hurry? We\'re still trying to make the initial connection!');
  } else {
    throw new Error('Peer ' + this.id + ' cannot reconnect because it is not disconnected from the server!');
  }
};

/**
 * Get a list of available peer IDs. If you're running your own server, you'll
 * want to set allow_discovery: true in the PeerServer options. If you're using
 * the cloud server, email team@peerjs.com to get the functionality enabled for
 * your key.
 */
Peer.prototype.listAllPeers = function(cb) {
  cb = cb || function() {};
  var self = this;
  var http = new XMLHttpRequest();
  var protocol = this.options.secure ? 'https://' : 'http://';
  var url = protocol + this.options.host + ':' + this.options.port +
    this.options.path + this.options.key + '/peers';
  var queryString = '?ts=' + new Date().getTime() + '' + Math.random();
  url += queryString;

  // If there's no ID we need to wait for one before trying to init socket.
  http.open('get', url, true);
  http.onerror = function(e) {
    self._abort('server-error', 'Could not get peers from the server.');
    cb([]);
  };
  http.onreadystatechange = function() {
    if (http.readyState !== 4) {
      return;
    }
    if (http.status === 401) {
      var helpfulError = '';
      if (self.options.host !== util.CLOUD_HOST) {
        helpfulError = 'It looks like you\'re using the cloud server. You can email ' +
          'team@peerjs.com to enable peer listing for your API key.';
      } else {
        helpfulError = 'You need to enable `allow_discovery` on your self-hosted ' +
          'PeerServer to use this feature.';
      }
      cb([]);
      throw new Error('It doesn\'t look like you have permission to list peers IDs. ' + helpfulError);
    } else if (http.status !== 200) {
      cb([]);
    } else {
      cb(JSON.parse(http.responseText));
    }
  };
  http.send(null);
};

module.exports = Peer;

},{"./dataconnection":2,"./mediaconnection":4,"./socket":7,"./util":8,"eventemitter3":9}],7:[function(require,module,exports){
var util = require('./util');
var EventEmitter = require('eventemitter3');

/**
 * An abstraction on top of WebSockets and XHR streaming to provide fastest
 * possible connection for peers.
 */
function Socket(secure, host, port, path, key) {
  if (!(this instanceof Socket)) return new Socket(secure, host, port, path, key);

  EventEmitter.call(this);

  // Disconnected manually.
  this.disconnected = false;
  this._queue = [];

  var httpProtocol = secure ? 'https://' : 'http://';
  var wsProtocol = secure ? 'wss://' : 'ws://';
  this._httpUrl = httpProtocol + host + ':' + port + path + key;
  this._wsUrl = wsProtocol + host + ':' + port + path + 'peerjs?key=' + key;
}

util.inherits(Socket, EventEmitter);


/** Check in with ID or get one from server. */
Socket.prototype.start = function(id, token) {
  this.id = id;

  this._httpUrl += '/' + id + '/' + token;
  this._wsUrl += '&id=' + id + '&token=' + token;

  this._startXhrStream();
  this._startWebSocket();
}


/** Start up websocket communications. */
Socket.prototype._startWebSocket = function(id) {
  var self = this;

  if (this._socket) {
    return;
  }

  this._socket = new WebSocket(this._wsUrl);

  this._socket.onmessage = function(event) {
    try {
      var data = JSON.parse(event.data);
    } catch(e) {
      util.log('Invalid server message', event.data);
      return;
    }
    self.emit('message', data);
  };

  this._socket.onclose = function(event) {
    util.log('Socket closed.');
    self.disconnected = true;
    self.emit('disconnected');
  };

  // Take care of the queue of connections if necessary and make sure Peer knows
  // socket is open.
  this._socket.onopen = function() {
    if (self._timeout) {
      clearTimeout(self._timeout);
      setTimeout(function(){
        self._http.abort();
        self._http = null;
      }, 5000);
    }
    self._sendQueuedMessages();
    util.log('Socket open');
  };
}

/** Start XHR streaming. */
Socket.prototype._startXhrStream = function(n) {
  try {
    var self = this;
    this._http = new XMLHttpRequest();
    this._http._index = 1;
    this._http._streamIndex = n || 0;
    this._http.open('post', this._httpUrl + '/id?i=' + this._http._streamIndex, true);
    this._http.onerror = function() {
      // If we get an error, likely something went wrong.
      // Stop streaming.
      clearTimeout(self._timeout);
      self.emit('disconnected');
    }
    this._http.onreadystatechange = function() {
      if (this.readyState == 2 && this.old) {
        this.old.abort();
        delete this.old;
      } else if (this.readyState > 2 && this.status === 200 && this.responseText) {
        self._handleStream(this);
      }
    };
    this._http.send(null);
    this._setHTTPTimeout();
  } catch(e) {
    util.log('XMLHttpRequest not available; defaulting to WebSockets');
  }
}


/** Handles onreadystatechange response as a stream. */
Socket.prototype._handleStream = function(http) {
  // 3 and 4 are loading/done state. All others are not relevant.
  var messages = http.responseText.split('\n');

  // Check to see if anything needs to be processed on buffer.
  if (http._buffer) {
    while (http._buffer.length > 0) {
      var index = http._buffer.shift();
      var bufferedMessage = messages[index];
      try {
        bufferedMessage = JSON.parse(bufferedMessage);
      } catch(e) {
        http._buffer.shift(index);
        break;
      }
      this.emit('message', bufferedMessage);
    }
  }

  var message = messages[http._index];
  if (message) {
    http._index += 1;
    // Buffering--this message is incomplete and we'll get to it next time.
    // This checks if the httpResponse ended in a `\n`, in which case the last
    // element of messages should be the empty string.
    if (http._index === messages.length) {
      if (!http._buffer) {
        http._buffer = [];
      }
      http._buffer.push(http._index - 1);
    } else {
      try {
        message = JSON.parse(message);
      } catch(e) {
        util.log('Invalid server message', message);
        return;
      }
      this.emit('message', message);
    }
  }
}

Socket.prototype._setHTTPTimeout = function() {
  var self = this;
  this._timeout = setTimeout(function() {
    var old = self._http;
    if (!self._wsOpen()) {
      self._startXhrStream(old._streamIndex + 1);
      self._http.old = old;
    } else {
      old.abort();
    }
  }, 25000);
}

/** Is the websocket currently open? */
Socket.prototype._wsOpen = function() {
  return this._socket && this._socket.readyState == 1;
}

/** Send queued messages. */
Socket.prototype._sendQueuedMessages = function() {
  for (var i = 0, ii = this._queue.length; i < ii; i += 1) {
    this.send(this._queue[i]);
  }
}

/** Exposed send for DC & Peer. */
Socket.prototype.send = function(data) {
  if (this.disconnected) {
    return;
  }

  // If we didn't get an ID yet, we can't yet send anything so we should queue
  // up these messages.
  if (!this.id) {
    this._queue.push(data);
    return;
  }

  if (!data.type) {
    this.emit('error', 'Invalid message');
    return;
  }

  var message = JSON.stringify(data);
  if (this._wsOpen()) {
    this._socket.send(message);
  } else {
    var http = new XMLHttpRequest();
    var url = this._httpUrl + '/' + data.type.toLowerCase();
    http.open('post', url, true);
    http.setRequestHeader('Content-Type', 'application/json');
    http.send(message);
  }
}

Socket.prototype.close = function() {
  if (!this.disconnected && this._wsOpen()) {
    this._socket.close();
    this.disconnected = true;
  }
}

module.exports = Socket;

},{"./util":8,"eventemitter3":9}],8:[function(require,module,exports){
var defaultConfig = {'iceServers': [{ 'url': 'stun:stun.l.google.com:19302' }]};
var dataCount = 1;

var BinaryPack = require('js-binarypack');
var RTCPeerConnection = require('./adapter').RTCPeerConnection;

var util = {
  noop: function() {},

  CLOUD_HOST: '0.peerjs.com',
  CLOUD_PORT: 9000,

  // Browsers that need chunking:
  chunkedBrowsers: {'Chrome': 1},
  chunkedMTU: 16300, // The original 60000 bytes setting does not work when sending data from Firefox to Chrome, which is "cut off" after 16384 bytes and delivered individually.

  // Logging logic
  logLevel: 0,
  setLogLevel: function(level) {
    var debugLevel = parseInt(level, 10);
    if (!isNaN(parseInt(level, 10))) {
      util.logLevel = debugLevel;
    } else {
      // If they are using truthy/falsy values for debug
      util.logLevel = level ? 3 : 0;
    }
    util.log = util.warn = util.error = util.noop;
    if (util.logLevel > 0) {
      util.error = util._printWith('ERROR');
    }
    if (util.logLevel > 1) {
      util.warn = util._printWith('WARNING');
    }
    if (util.logLevel > 2) {
      util.log = util._print;
    }
  },
  setLogFunction: function(fn) {
    if (fn.constructor !== Function) {
      util.warn('The log function you passed in is not a function. Defaulting to regular logs.');
    } else {
      util._print = fn;
    }
  },

  _printWith: function(prefix) {
    return function() {
      var copy = Array.prototype.slice.call(arguments);
      copy.unshift(prefix);
      util._print.apply(util, copy);
    };
  },
  _print: function () {
    var err = false;
    var copy = Array.prototype.slice.call(arguments);
    copy.unshift('PeerJS: ');
    for (var i = 0, l = copy.length; i < l; i++){
      if (copy[i] instanceof Error) {
        copy[i] = '(' + copy[i].name + ') ' + copy[i].message;
        err = true;
      }
    }
    err ? console.error.apply(console, copy) : console.log.apply(console, copy);
  },
  //

  // Returns browser-agnostic default config
  defaultConfig: defaultConfig,
  //

  // Returns the current browser.
  browser: (function() {
    if (window.mozRTCPeerConnection) {
      return 'Firefox';
    } else if (window.webkitRTCPeerConnection) {
      return 'Chrome';
    } else if (window.RTCPeerConnection) {
      return 'Supported';
    } else {
      return 'Unsupported';
    }
  })(),
  //

  // Lists which features are supported
  supports: (function() {
    if (typeof RTCPeerConnection === 'undefined') {
      return {};
    }

    var data = true;
    var audioVideo = true;

    var binaryBlob = false;
    var sctp = false;
    var onnegotiationneeded = !!window.webkitRTCPeerConnection;

    var pc, dc;
    try {
      pc = new RTCPeerConnection(defaultConfig, {optional: [{RtpDataChannels: true}]});
    } catch (e) {
      data = false;
      audioVideo = false;
    }

    if (data) {
      try {
        dc = pc.createDataChannel('_PEERJSTEST');
      } catch (e) {
        data = false;
      }
    }

    if (data) {
      // Binary test
      try {
        dc.binaryType = 'blob';
        binaryBlob = true;
      } catch (e) {
      }

      // Reliable test.
      // Unfortunately Chrome is a bit unreliable about whether or not they
      // support reliable.
      var reliablePC = new RTCPeerConnection(defaultConfig, {});
      try {
        var reliableDC = reliablePC.createDataChannel('_PEERJSRELIABLETEST', {});
        sctp = reliableDC.reliable;
      } catch (e) {
      }
      reliablePC.close();
    }

    // FIXME: not really the best check...
    if (audioVideo) {
      audioVideo = !!pc.addStream;
    }

    // FIXME: this is not great because in theory it doesn't work for
    // av-only browsers (?).
    if (!onnegotiationneeded && data) {
      // sync default check.
      var negotiationPC = new RTCPeerConnection(defaultConfig, {optional: [{RtpDataChannels: true}]});
      negotiationPC.onnegotiationneeded = function() {
        onnegotiationneeded = true;
        // async check.
        if (util && util.supports) {
          util.supports.onnegotiationneeded = true;
        }
      };
      negotiationPC.createDataChannel('_PEERJSNEGOTIATIONTEST');

      setTimeout(function() {
        negotiationPC.close();
      }, 1000);
    }

    if (pc) {
      pc.close();
    }

    return {
      audioVideo: audioVideo,
      data: data,
      binaryBlob: binaryBlob,
      binary: sctp, // deprecated; sctp implies binary support.
      reliable: sctp, // deprecated; sctp implies reliable data.
      sctp: sctp,
      onnegotiationneeded: onnegotiationneeded
    };
  }()),
  //

  // Ensure alphanumeric ids
  validateId: function(id) {
    // Allow empty ids
    return !id || /^[A-Za-z0-9_-]+(?:[ _-][A-Za-z0-9]+)*$/.exec(id);
  },

  validateKey: function(key) {
    // Allow empty keys
    return !key || /^[A-Za-z0-9_-]+(?:[ _-][A-Za-z0-9]+)*$/.exec(key);
  },


  debug: false,

  inherits: function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  },
  extend: function(dest, source) {
    for(var key in source) {
      if(source.hasOwnProperty(key)) {
        dest[key] = source[key];
      }
    }
    return dest;
  },
  pack: BinaryPack.pack,
  unpack: BinaryPack.unpack,

  log: function () {
    if (util.debug) {
      var err = false;
      var copy = Array.prototype.slice.call(arguments);
      copy.unshift('PeerJS: ');
      for (var i = 0, l = copy.length; i < l; i++){
        if (copy[i] instanceof Error) {
          copy[i] = '(' + copy[i].name + ') ' + copy[i].message;
          err = true;
        }
      }
      err ? console.error.apply(console, copy) : console.log.apply(console, copy);
    }
  },

  setZeroTimeout: (function(global) {
    var timeouts = [];
    var messageName = 'zero-timeout-message';

    // Like setTimeout, but only takes a function argument.	 There's
    // no time argument (always zero) and no arguments (you have to
    // use a closure).
    function setZeroTimeoutPostMessage(fn) {
      timeouts.push(fn);
      global.postMessage(messageName, '*');
    }

    function handleMessage(event) {
      if (event.source == global && event.data == messageName) {
        if (event.stopPropagation) {
          event.stopPropagation();
        }
        if (timeouts.length) {
          timeouts.shift()();
        }
      }
    }
    if (global.addEventListener) {
      global.addEventListener('message', handleMessage, true);
    } else if (global.attachEvent) {
      global.attachEvent('onmessage', handleMessage);
    }
    return setZeroTimeoutPostMessage;
  }(window)),

  // Binary stuff

  // chunks a blob.
  chunk: function(bl) {
    var chunks = [];
    var size = bl.size;
    var start = index = 0;
    var total = Math.ceil(size / util.chunkedMTU);
    while (start < size) {
      var end = Math.min(size, start + util.chunkedMTU);
      var b = bl.slice(start, end);

      var chunk = {
        __peerData: dataCount,
        n: index,
        data: b,
        total: total
      };

      chunks.push(chunk);

      start = end;
      index += 1;
    }
    dataCount += 1;
    return chunks;
  },

  blobToArrayBuffer: function(blob, cb){
    var fr = new FileReader();
    fr.onload = function(evt) {
      cb(evt.target.result);
    };
    fr.readAsArrayBuffer(blob);
  },
  blobToBinaryString: function(blob, cb){
    var fr = new FileReader();
    fr.onload = function(evt) {
      cb(evt.target.result);
    };
    fr.readAsBinaryString(blob);
  },
  binaryStringToArrayBuffer: function(binary) {
    var byteArray = new Uint8Array(binary.length);
    for (var i = 0; i < binary.length; i++) {
      byteArray[i] = binary.charCodeAt(i) & 0xff;
    }
    return byteArray.buffer;
  },
  randomToken: function () {
    return Math.random().toString(36).substr(2);
  },
  //

  isSecure: function() {
    return location.protocol === 'https:';
  }
};

module.exports = util;

},{"./adapter":1,"js-binarypack":10}],9:[function(require,module,exports){
'use strict';

/**
 * Representation of a single EventEmitter function.
 *
 * @param {Function} fn Event handler to be called.
 * @param {Mixed} context Context for function execution.
 * @param {Boolean} once Only emit once
 * @api private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Minimal EventEmitter interface that is molded against the Node.js
 * EventEmitter interface.
 *
 * @constructor
 * @api public
 */
function EventEmitter() { /* Nothing to set */ }

/**
 * Holds the assigned EventEmitters by name.
 *
 * @type {Object}
 * @private
 */
EventEmitter.prototype._events = undefined;

/**
 * Return a list of assigned event listeners.
 *
 * @param {String} event The events that should be listed.
 * @returns {Array}
 * @api public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  if (!this._events || !this._events[event]) return [];

  for (var i = 0, l = this._events[event].length, ee = []; i < l; i++) {
    ee.push(this._events[event][i].fn);
  }

  return ee;
};

/**
 * Emit an event to all registered event listeners.
 *
 * @param {String} event The name of the event.
 * @returns {Boolean} Indication if we've emitted an event.
 * @api public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  if (!this._events || !this._events[event]) return false;

  var listeners = this._events[event]
    , length = listeners.length
    , len = arguments.length
    , ee = listeners[0]
    , args
    , i, j;

  if (1 === length) {
    if (ee.once) this.removeListener(event, ee.fn, true);

    switch (len) {
      case 1: return ee.fn.call(ee.context), true;
      case 2: return ee.fn.call(ee.context, a1), true;
      case 3: return ee.fn.call(ee.context, a1, a2), true;
      case 4: return ee.fn.call(ee.context, a1, a2, a3), true;
      case 5: return ee.fn.call(ee.context, a1, a2, a3, a4), true;
      case 6: return ee.fn.call(ee.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    ee.fn.apply(ee.context, args);
  } else {
    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Register a new EventListener for the given event.
 *
 * @param {String} event Name of the event.
 * @param {Functon} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  if (!this._events) this._events = {};
  if (!this._events[event]) this._events[event] = [];
  this._events[event].push(new EE( fn, context || this ));

  return this;
};

/**
 * Add an EventListener that's only called once.
 *
 * @param {String} event Name of the event.
 * @param {Function} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  if (!this._events) this._events = {};
  if (!this._events[event]) this._events[event] = [];
  this._events[event].push(new EE(fn, context || this, true ));

  return this;
};

/**
 * Remove event listeners.
 *
 * @param {String} event The event we want to remove.
 * @param {Function} fn The listener that we need to find.
 * @param {Boolean} once Only remove once listeners.
 * @api public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, once) {
  if (!this._events || !this._events[event]) return this;

  var listeners = this._events[event]
    , events = [];

  if (fn) for (var i = 0, length = listeners.length; i < length; i++) {
    if (listeners[i].fn !== fn && listeners[i].once !== once) {
      events.push(listeners[i]);
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) this._events[event] = events;
  else this._events[event] = null;

  return this;
};

/**
 * Remove all listeners or only the listeners for the specified event.
 *
 * @param {String} event The event want to remove all listeners for.
 * @api public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  if (!this._events) return this;

  if (event) this._events[event] = null;
  else this._events = {};

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// This function doesn't apply anymore.
//
EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
  return this;
};

//
// Expose the module.
//
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.EventEmitter2 = EventEmitter;
EventEmitter.EventEmitter3 = EventEmitter;

if ('object' === typeof module && module.exports) {
  module.exports = EventEmitter;
}

},{}],10:[function(require,module,exports){
var BufferBuilder = require('./bufferbuilder').BufferBuilder;
var binaryFeatures = require('./bufferbuilder').binaryFeatures;

var BinaryPack = {
  unpack: function(data){
    var unpacker = new Unpacker(data);
    return unpacker.unpack();
  },
  pack: function(data){
    var packer = new Packer();
    packer.pack(data);
    var buffer = packer.getBuffer();
    return buffer;
  }
};

module.exports = BinaryPack;

function Unpacker (data){
  // Data is ArrayBuffer
  this.index = 0;
  this.dataBuffer = data;
  this.dataView = new Uint8Array(this.dataBuffer);
  this.length = this.dataBuffer.byteLength;
}

Unpacker.prototype.unpack = function(){
  var type = this.unpack_uint8();
  if (type < 0x80){
    var positive_fixnum = type;
    return positive_fixnum;
  } else if ((type ^ 0xe0) < 0x20){
    var negative_fixnum = (type ^ 0xe0) - 0x20;
    return negative_fixnum;
  }
  var size;
  if ((size = type ^ 0xa0) <= 0x0f){
    return this.unpack_raw(size);
  } else if ((size = type ^ 0xb0) <= 0x0f){
    return this.unpack_string(size);
  } else if ((size = type ^ 0x90) <= 0x0f){
    return this.unpack_array(size);
  } else if ((size = type ^ 0x80) <= 0x0f){
    return this.unpack_map(size);
  }
  switch(type){
    case 0xc0:
      return null;
    case 0xc1:
      return undefined;
    case 0xc2:
      return false;
    case 0xc3:
      return true;
    case 0xca:
      return this.unpack_float();
    case 0xcb:
      return this.unpack_double();
    case 0xcc:
      return this.unpack_uint8();
    case 0xcd:
      return this.unpack_uint16();
    case 0xce:
      return this.unpack_uint32();
    case 0xcf:
      return this.unpack_uint64();
    case 0xd0:
      return this.unpack_int8();
    case 0xd1:
      return this.unpack_int16();
    case 0xd2:
      return this.unpack_int32();
    case 0xd3:
      return this.unpack_int64();
    case 0xd4:
      return undefined;
    case 0xd5:
      return undefined;
    case 0xd6:
      return undefined;
    case 0xd7:
      return undefined;
    case 0xd8:
      size = this.unpack_uint16();
      return this.unpack_string(size);
    case 0xd9:
      size = this.unpack_uint32();
      return this.unpack_string(size);
    case 0xda:
      size = this.unpack_uint16();
      return this.unpack_raw(size);
    case 0xdb:
      size = this.unpack_uint32();
      return this.unpack_raw(size);
    case 0xdc:
      size = this.unpack_uint16();
      return this.unpack_array(size);
    case 0xdd:
      size = this.unpack_uint32();
      return this.unpack_array(size);
    case 0xde:
      size = this.unpack_uint16();
      return this.unpack_map(size);
    case 0xdf:
      size = this.unpack_uint32();
      return this.unpack_map(size);
  }
}

Unpacker.prototype.unpack_uint8 = function(){
  var byte = this.dataView[this.index] & 0xff;
  this.index++;
  return byte;
};

Unpacker.prototype.unpack_uint16 = function(){
  var bytes = this.read(2);
  var uint16 =
    ((bytes[0] & 0xff) * 256) + (bytes[1] & 0xff);
  this.index += 2;
  return uint16;
}

Unpacker.prototype.unpack_uint32 = function(){
  var bytes = this.read(4);
  var uint32 =
     ((bytes[0]  * 256 +
       bytes[1]) * 256 +
       bytes[2]) * 256 +
       bytes[3];
  this.index += 4;
  return uint32;
}

Unpacker.prototype.unpack_uint64 = function(){
  var bytes = this.read(8);
  var uint64 =
   ((((((bytes[0]  * 256 +
       bytes[1]) * 256 +
       bytes[2]) * 256 +
       bytes[3]) * 256 +
       bytes[4]) * 256 +
       bytes[5]) * 256 +
       bytes[6]) * 256 +
       bytes[7];
  this.index += 8;
  return uint64;
}


Unpacker.prototype.unpack_int8 = function(){
  var uint8 = this.unpack_uint8();
  return (uint8 < 0x80 ) ? uint8 : uint8 - (1 << 8);
};

Unpacker.prototype.unpack_int16 = function(){
  var uint16 = this.unpack_uint16();
  return (uint16 < 0x8000 ) ? uint16 : uint16 - (1 << 16);
}

Unpacker.prototype.unpack_int32 = function(){
  var uint32 = this.unpack_uint32();
  return (uint32 < Math.pow(2, 31) ) ? uint32 :
    uint32 - Math.pow(2, 32);
}

Unpacker.prototype.unpack_int64 = function(){
  var uint64 = this.unpack_uint64();
  return (uint64 < Math.pow(2, 63) ) ? uint64 :
    uint64 - Math.pow(2, 64);
}

Unpacker.prototype.unpack_raw = function(size){
  if ( this.length < this.index + size){
    throw new Error('BinaryPackFailure: index is out of range'
      + ' ' + this.index + ' ' + size + ' ' + this.length);
  }
  var buf = this.dataBuffer.slice(this.index, this.index + size);
  this.index += size;

    //buf = util.bufferToString(buf);

  return buf;
}

Unpacker.prototype.unpack_string = function(size){
  var bytes = this.read(size);
  var i = 0, str = '', c, code;
  while(i < size){
    c = bytes[i];
    if ( c < 128){
      str += String.fromCharCode(c);
      i++;
    } else if ((c ^ 0xc0) < 32){
      code = ((c ^ 0xc0) << 6) | (bytes[i+1] & 63);
      str += String.fromCharCode(code);
      i += 2;
    } else {
      code = ((c & 15) << 12) | ((bytes[i+1] & 63) << 6) |
        (bytes[i+2] & 63);
      str += String.fromCharCode(code);
      i += 3;
    }
  }
  this.index += size;
  return str;
}

Unpacker.prototype.unpack_array = function(size){
  var objects = new Array(size);
  for(var i = 0; i < size ; i++){
    objects[i] = this.unpack();
  }
  return objects;
}

Unpacker.prototype.unpack_map = function(size){
  var map = {};
  for(var i = 0; i < size ; i++){
    var key  = this.unpack();
    var value = this.unpack();
    map[key] = value;
  }
  return map;
}

Unpacker.prototype.unpack_float = function(){
  var uint32 = this.unpack_uint32();
  var sign = uint32 >> 31;
  var exp  = ((uint32 >> 23) & 0xff) - 127;
  var fraction = ( uint32 & 0x7fffff ) | 0x800000;
  return (sign == 0 ? 1 : -1) *
    fraction * Math.pow(2, exp - 23);
}

Unpacker.prototype.unpack_double = function(){
  var h32 = this.unpack_uint32();
  var l32 = this.unpack_uint32();
  var sign = h32 >> 31;
  var exp  = ((h32 >> 20) & 0x7ff) - 1023;
  var hfrac = ( h32 & 0xfffff ) | 0x100000;
  var frac = hfrac * Math.pow(2, exp - 20) +
    l32   * Math.pow(2, exp - 52);
  return (sign == 0 ? 1 : -1) * frac;
}

Unpacker.prototype.read = function(length){
  var j = this.index;
  if (j + length <= this.length) {
    return this.dataView.subarray(j, j + length);
  } else {
    throw new Error('BinaryPackFailure: read index out of range');
  }
}

function Packer(){
  this.bufferBuilder = new BufferBuilder();
}

Packer.prototype.getBuffer = function(){
  return this.bufferBuilder.getBuffer();
}

Packer.prototype.pack = function(value){
  var type = typeof(value);
  if (type == 'string'){
    this.pack_string(value);
  } else if (type == 'number'){
    if (Math.floor(value) === value){
      this.pack_integer(value);
    } else{
      this.pack_double(value);
    }
  } else if (type == 'boolean'){
    if (value === true){
      this.bufferBuilder.append(0xc3);
    } else if (value === false){
      this.bufferBuilder.append(0xc2);
    }
  } else if (type == 'undefined'){
    this.bufferBuilder.append(0xc0);
  } else if (type == 'object'){
    if (value === null){
      this.bufferBuilder.append(0xc0);
    } else {
      var constructor = value.constructor;
      if (constructor == Array){
        this.pack_array(value);
      } else if (constructor == Blob || constructor == File) {
        this.pack_bin(value);
      } else if (constructor == ArrayBuffer) {
        if(binaryFeatures.useArrayBufferView) {
          this.pack_bin(new Uint8Array(value));
        } else {
          this.pack_bin(value);
        }
      } else if ('BYTES_PER_ELEMENT' in value){
        if(binaryFeatures.useArrayBufferView) {
          this.pack_bin(new Uint8Array(value.buffer));
        } else {
          this.pack_bin(value.buffer);
        }
      } else if (constructor == Object){
        this.pack_object(value);
      } else if (constructor == Date){
        this.pack_string(value.toString());
      } else if (typeof value.toBinaryPack == 'function'){
        this.bufferBuilder.append(value.toBinaryPack());
      } else {
        throw new Error('Type "' + constructor.toString() + '" not yet supported');
      }
    }
  } else {
    throw new Error('Type "' + type + '" not yet supported');
  }
  this.bufferBuilder.flush();
}


Packer.prototype.pack_bin = function(blob){
  var length = blob.length || blob.byteLength || blob.size;
  if (length <= 0x0f){
    this.pack_uint8(0xa0 + length);
  } else if (length <= 0xffff){
    this.bufferBuilder.append(0xda) ;
    this.pack_uint16(length);
  } else if (length <= 0xffffffff){
    this.bufferBuilder.append(0xdb);
    this.pack_uint32(length);
  } else{
    throw new Error('Invalid length');
  }
  this.bufferBuilder.append(blob);
}

Packer.prototype.pack_string = function(str){
  var length = utf8Length(str);

  if (length <= 0x0f){
    this.pack_uint8(0xb0 + length);
  } else if (length <= 0xffff){
    this.bufferBuilder.append(0xd8) ;
    this.pack_uint16(length);
  } else if (length <= 0xffffffff){
    this.bufferBuilder.append(0xd9);
    this.pack_uint32(length);
  } else{
    throw new Error('Invalid length');
  }
  this.bufferBuilder.append(str);
}

Packer.prototype.pack_array = function(ary){
  var length = ary.length;
  if (length <= 0x0f){
    this.pack_uint8(0x90 + length);
  } else if (length <= 0xffff){
    this.bufferBuilder.append(0xdc)
    this.pack_uint16(length);
  } else if (length <= 0xffffffff){
    this.bufferBuilder.append(0xdd);
    this.pack_uint32(length);
  } else{
    throw new Error('Invalid length');
  }
  for(var i = 0; i < length ; i++){
    this.pack(ary[i]);
  }
}

Packer.prototype.pack_integer = function(num){
  if ( -0x20 <= num && num <= 0x7f){
    this.bufferBuilder.append(num & 0xff);
  } else if (0x00 <= num && num <= 0xff){
    this.bufferBuilder.append(0xcc);
    this.pack_uint8(num);
  } else if (-0x80 <= num && num <= 0x7f){
    this.bufferBuilder.append(0xd0);
    this.pack_int8(num);
  } else if ( 0x0000 <= num && num <= 0xffff){
    this.bufferBuilder.append(0xcd);
    this.pack_uint16(num);
  } else if (-0x8000 <= num && num <= 0x7fff){
    this.bufferBuilder.append(0xd1);
    this.pack_int16(num);
  } else if ( 0x00000000 <= num && num <= 0xffffffff){
    this.bufferBuilder.append(0xce);
    this.pack_uint32(num);
  } else if (-0x80000000 <= num && num <= 0x7fffffff){
    this.bufferBuilder.append(0xd2);
    this.pack_int32(num);
  } else if (-0x8000000000000000 <= num && num <= 0x7FFFFFFFFFFFFFFF){
    this.bufferBuilder.append(0xd3);
    this.pack_int64(num);
  } else if (0x0000000000000000 <= num && num <= 0xFFFFFFFFFFFFFFFF){
    this.bufferBuilder.append(0xcf);
    this.pack_uint64(num);
  } else{
    throw new Error('Invalid integer');
  }
}

Packer.prototype.pack_double = function(num){
  var sign = 0;
  if (num < 0){
    sign = 1;
    num = -num;
  }
  var exp  = Math.floor(Math.log(num) / Math.LN2);
  var frac0 = num / Math.pow(2, exp) - 1;
  var frac1 = Math.floor(frac0 * Math.pow(2, 52));
  var b32   = Math.pow(2, 32);
  var h32 = (sign << 31) | ((exp+1023) << 20) |
      (frac1 / b32) & 0x0fffff;
  var l32 = frac1 % b32;
  this.bufferBuilder.append(0xcb);
  this.pack_int32(h32);
  this.pack_int32(l32);
}

Packer.prototype.pack_object = function(obj){
  var keys = Object.keys(obj);
  var length = keys.length;
  if (length <= 0x0f){
    this.pack_uint8(0x80 + length);
  } else if (length <= 0xffff){
    this.bufferBuilder.append(0xde);
    this.pack_uint16(length);
  } else if (length <= 0xffffffff){
    this.bufferBuilder.append(0xdf);
    this.pack_uint32(length);
  } else{
    throw new Error('Invalid length');
  }
  for(var prop in obj){
    if (obj.hasOwnProperty(prop)){
      this.pack(prop);
      this.pack(obj[prop]);
    }
  }
}

Packer.prototype.pack_uint8 = function(num){
  this.bufferBuilder.append(num);
}

Packer.prototype.pack_uint16 = function(num){
  this.bufferBuilder.append(num >> 8);
  this.bufferBuilder.append(num & 0xff);
}

Packer.prototype.pack_uint32 = function(num){
  var n = num & 0xffffffff;
  this.bufferBuilder.append((n & 0xff000000) >>> 24);
  this.bufferBuilder.append((n & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((n & 0x0000ff00) >>>  8);
  this.bufferBuilder.append((n & 0x000000ff));
}

Packer.prototype.pack_uint64 = function(num){
  var high = num / Math.pow(2, 32);
  var low  = num % Math.pow(2, 32);
  this.bufferBuilder.append((high & 0xff000000) >>> 24);
  this.bufferBuilder.append((high & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((high & 0x0000ff00) >>>  8);
  this.bufferBuilder.append((high & 0x000000ff));
  this.bufferBuilder.append((low  & 0xff000000) >>> 24);
  this.bufferBuilder.append((low  & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((low  & 0x0000ff00) >>>  8);
  this.bufferBuilder.append((low  & 0x000000ff));
}

Packer.prototype.pack_int8 = function(num){
  this.bufferBuilder.append(num & 0xff);
}

Packer.prototype.pack_int16 = function(num){
  this.bufferBuilder.append((num & 0xff00) >> 8);
  this.bufferBuilder.append(num & 0xff);
}

Packer.prototype.pack_int32 = function(num){
  this.bufferBuilder.append((num >>> 24) & 0xff);
  this.bufferBuilder.append((num & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((num & 0x0000ff00) >>> 8);
  this.bufferBuilder.append((num & 0x000000ff));
}

Packer.prototype.pack_int64 = function(num){
  var high = Math.floor(num / Math.pow(2, 32));
  var low  = num % Math.pow(2, 32);
  this.bufferBuilder.append((high & 0xff000000) >>> 24);
  this.bufferBuilder.append((high & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((high & 0x0000ff00) >>>  8);
  this.bufferBuilder.append((high & 0x000000ff));
  this.bufferBuilder.append((low  & 0xff000000) >>> 24);
  this.bufferBuilder.append((low  & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((low  & 0x0000ff00) >>>  8);
  this.bufferBuilder.append((low  & 0x000000ff));
}

function _utf8Replace(m){
  var code = m.charCodeAt(0);

  if(code <= 0x7ff) return '00';
  if(code <= 0xffff) return '000';
  if(code <= 0x1fffff) return '0000';
  if(code <= 0x3ffffff) return '00000';
  return '000000';
}

function utf8Length(str){
  if (str.length > 600) {
    // Blob method faster for large strings
    return (new Blob([str])).size;
  } else {
    return str.replace(/[^\u0000-\u007F]/g, _utf8Replace).length;
  }
}

},{"./bufferbuilder":11}],11:[function(require,module,exports){
var binaryFeatures = {};
binaryFeatures.useBlobBuilder = (function(){
  try {
    new Blob([]);
    return false;
  } catch (e) {
    return true;
  }
})();

binaryFeatures.useArrayBufferView = !binaryFeatures.useBlobBuilder && (function(){
  try {
    return (new Blob([new Uint8Array([])])).size === 0;
  } catch (e) {
    return true;
  }
})();

module.exports.binaryFeatures = binaryFeatures;
var BlobBuilder = module.exports.BlobBuilder;
if (typeof window != 'undefined') {
  BlobBuilder = module.exports.BlobBuilder = window.WebKitBlobBuilder ||
    window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder;
}

function BufferBuilder(){
  this._pieces = [];
  this._parts = [];
}

BufferBuilder.prototype.append = function(data) {
  if(typeof data === 'number') {
    this._pieces.push(data);
  } else {
    this.flush();
    this._parts.push(data);
  }
};

BufferBuilder.prototype.flush = function() {
  if (this._pieces.length > 0) {
    var buf = new Uint8Array(this._pieces);
    if(!binaryFeatures.useArrayBufferView) {
      buf = buf.buffer;
    }
    this._parts.push(buf);
    this._pieces = [];
  }
};

BufferBuilder.prototype.getBuffer = function() {
  this.flush();
  if(binaryFeatures.useBlobBuilder) {
    var builder = new BlobBuilder();
    for(var i = 0, ii = this._parts.length; i < ii; i++) {
      builder.append(this._parts[i]);
    }
    return builder.getBlob();
  } else {
    return new Blob(this._parts);
  }
};

module.exports.BufferBuilder = BufferBuilder;

},{}],12:[function(require,module,exports){
var util = require('./util');

/**
 * Reliable transfer for Chrome Canary DataChannel impl.
 * Author: @michellebu
 */
function Reliable(dc, debug) {
  if (!(this instanceof Reliable)) return new Reliable(dc);
  this._dc = dc;

  util.debug = debug;

  // Messages sent/received so far.
  // id: { ack: n, chunks: [...] }
  this._outgoing = {};
  // id: { ack: ['ack', id, n], chunks: [...] }
  this._incoming = {};
  this._received = {};

  // Window size.
  this._window = 1000;
  // MTU.
  this._mtu = 500;
  // Interval for setInterval. In ms.
  this._interval = 0;

  // Messages sent.
  this._count = 0;

  // Outgoing message queue.
  this._queue = [];

  this._setupDC();
};

// Send a message reliably.
Reliable.prototype.send = function(msg) {
  // Determine if chunking is necessary.
  var bl = util.pack(msg);
  if (bl.size < this._mtu) {
    this._handleSend(['no', bl]);
    return;
  }

  this._outgoing[this._count] = {
    ack: 0,
    chunks: this._chunk(bl)
  };

  if (util.debug) {
    this._outgoing[this._count].timer = new Date();
  }

  // Send prelim window.
  this._sendWindowedChunks(this._count);
  this._count += 1;
};

// Set up interval for processing queue.
Reliable.prototype._setupInterval = function() {
  // TODO: fail gracefully.

  var self = this;
  this._timeout = setInterval(function() {
    // FIXME: String stuff makes things terribly async.
    var msg = self._queue.shift();
    if (msg._multiple) {
      for (var i = 0, ii = msg.length; i < ii; i += 1) {
        self._intervalSend(msg[i]);
      }
    } else {
      self._intervalSend(msg);
    }
  }, this._interval);
};

Reliable.prototype._intervalSend = function(msg) {
  var self = this;
  msg = util.pack(msg);
  util.blobToBinaryString(msg, function(str) {
    self._dc.send(str);
  });
  if (self._queue.length === 0) {
    clearTimeout(self._timeout);
    self._timeout = null;
    //self._processAcks();
  }
};

// Go through ACKs to send missing pieces.
Reliable.prototype._processAcks = function() {
  for (var id in this._outgoing) {
    if (this._outgoing.hasOwnProperty(id)) {
      this._sendWindowedChunks(id);
    }
  }
};

// Handle sending a message.
// FIXME: Don't wait for interval time for all messages...
Reliable.prototype._handleSend = function(msg) {
  var push = true;
  for (var i = 0, ii = this._queue.length; i < ii; i += 1) {
    var item = this._queue[i];
    if (item === msg) {
      push = false;
    } else if (item._multiple && item.indexOf(msg) !== -1) {
      push = false;
    }
  }
  if (push) {
    this._queue.push(msg);
    if (!this._timeout) {
      this._setupInterval();
    }
  }
};

// Set up DataChannel handlers.
Reliable.prototype._setupDC = function() {
  // Handle various message types.
  var self = this;
  this._dc.onmessage = function(e) {
    var msg = e.data;
    var datatype = msg.constructor;
    // FIXME: msg is String until binary is supported.
    // Once that happens, this will have to be smarter.
    if (datatype === String) {
      var ab = util.binaryStringToArrayBuffer(msg);
      msg = util.unpack(ab);
      self._handleMessage(msg);
    }
  };
};

// Handles an incoming message.
Reliable.prototype._handleMessage = function(msg) {
  var id = msg[1];
  var idata = this._incoming[id];
  var odata = this._outgoing[id];
  var data;
  switch (msg[0]) {
    // No chunking was done.
    case 'no':
      var message = id;
      if (!!message) {
        this.onmessage(util.unpack(message));
      }
      break;
    // Reached the end of the message.
    case 'end':
      data = idata;

      // In case end comes first.
      this._received[id] = msg[2];

      if (!data) {
        break;
      }

      this._ack(id);
      break;
    case 'ack':
      data = odata;
      if (!!data) {
        var ack = msg[2];
        // Take the larger ACK, for out of order messages.
        data.ack = Math.max(ack, data.ack);

        // Clean up when all chunks are ACKed.
        if (data.ack >= data.chunks.length) {
          util.log('Time: ', new Date() - data.timer);
          delete this._outgoing[id];
        } else {
          this._processAcks();
        }
      }
      // If !data, just ignore.
      break;
    // Received a chunk of data.
    case 'chunk':
      // Create a new entry if none exists.
      data = idata;
      if (!data) {
        var end = this._received[id];
        if (end === true) {
          break;
        }
        data = {
          ack: ['ack', id, 0],
          chunks: []
        };
        this._incoming[id] = data;
      }

      var n = msg[2];
      var chunk = msg[3];
      data.chunks[n] = new Uint8Array(chunk);

      // If we get the chunk we're looking for, ACK for next missing.
      // Otherwise, ACK the same N again.
      if (n === data.ack[2]) {
        this._calculateNextAck(id);
      }
      this._ack(id);
      break;
    default:
      // Shouldn't happen, but would make sense for message to just go
      // through as is.
      this._handleSend(msg);
      break;
  }
};

// Chunks BL into smaller messages.
Reliable.prototype._chunk = function(bl) {
  var chunks = [];
  var size = bl.size;
  var start = 0;
  while (start < size) {
    var end = Math.min(size, start + this._mtu);
    var b = bl.slice(start, end);
    var chunk = {
      payload: b
    }
    chunks.push(chunk);
    start = end;
  }
  util.log('Created', chunks.length, 'chunks.');
  return chunks;
};

// Sends ACK N, expecting Nth blob chunk for message ID.
Reliable.prototype._ack = function(id) {
  var ack = this._incoming[id].ack;

  // if ack is the end value, then call _complete.
  if (this._received[id] === ack[2]) {
    this._complete(id);
    this._received[id] = true;
  }

  this._handleSend(ack);
};

// Calculates the next ACK number, given chunks.
Reliable.prototype._calculateNextAck = function(id) {
  var data = this._incoming[id];
  var chunks = data.chunks;
  for (var i = 0, ii = chunks.length; i < ii; i += 1) {
    // This chunk is missing!!! Better ACK for it.
    if (chunks[i] === undefined) {
      data.ack[2] = i;
      return;
    }
  }
  data.ack[2] = chunks.length;
};

// Sends the next window of chunks.
Reliable.prototype._sendWindowedChunks = function(id) {
  util.log('sendWindowedChunks for: ', id);
  var data = this._outgoing[id];
  var ch = data.chunks;
  var chunks = [];
  var limit = Math.min(data.ack + this._window, ch.length);
  for (var i = data.ack; i < limit; i += 1) {
    if (!ch[i].sent || i === data.ack) {
      ch[i].sent = true;
      chunks.push(['chunk', id, i, ch[i].payload]);
    }
  }
  if (data.ack + this._window >= ch.length) {
    chunks.push(['end', id, ch.length])
  }
  chunks._multiple = true;
  this._handleSend(chunks);
};

// Puts together a message from chunks.
Reliable.prototype._complete = function(id) {
  util.log('Completed called for', id);
  var self = this;
  var chunks = this._incoming[id].chunks;
  var bl = new Blob(chunks);
  util.blobToArrayBuffer(bl, function(ab) {
    self.onmessage(util.unpack(ab));
  });
  delete this._incoming[id];
};

// Ups bandwidth limit on SDP. Meant to be called during offer/answer.
Reliable.higherBandwidthSDP = function(sdp) {
  // AS stands for Application-Specific Maximum.
  // Bandwidth number is in kilobits / sec.
  // See RFC for more info: http://www.ietf.org/rfc/rfc2327.txt

  // Chrome 31+ doesn't want us munging the SDP, so we'll let them have their
  // way.
  var version = navigator.appVersion.match(/Chrome\/(.*?) /);
  if (version) {
    version = parseInt(version[1].split('.').shift());
    if (version < 31) {
      var parts = sdp.split('b=AS:30');
      var replace = 'b=AS:102400'; // 100 Mbps
      if (parts.length > 1) {
        return parts[0] + replace + parts[1];
      }
    }
  }

  return sdp;
};

// Overwritten, typically.
Reliable.prototype.onmessage = function(msg) {};

module.exports.Reliable = Reliable;

},{"./util":13}],13:[function(require,module,exports){
var BinaryPack = require('js-binarypack');

var util = {
  debug: false,
  
  inherits: function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  },
  extend: function(dest, source) {
    for(var key in source) {
      if(source.hasOwnProperty(key)) {
        dest[key] = source[key];
      }
    }
    return dest;
  },
  pack: BinaryPack.pack,
  unpack: BinaryPack.unpack,
  
  log: function () {
    if (util.debug) {
      var copy = [];
      for (var i = 0; i < arguments.length; i++) {
        copy[i] = arguments[i];
      }
      copy.unshift('Reliable: ');
      console.log.apply(console, copy);
    }
  },

  setZeroTimeout: (function(global) {
    var timeouts = [];
    var messageName = 'zero-timeout-message';

    // Like setTimeout, but only takes a function argument.	 There's
    // no time argument (always zero) and no arguments (you have to
    // use a closure).
    function setZeroTimeoutPostMessage(fn) {
      timeouts.push(fn);
      global.postMessage(messageName, '*');
    }		

    function handleMessage(event) {
      if (event.source == global && event.data == messageName) {
        if (event.stopPropagation) {
          event.stopPropagation();
        }
        if (timeouts.length) {
          timeouts.shift()();
        }
      }
    }
    if (global.addEventListener) {
      global.addEventListener('message', handleMessage, true);
    } else if (global.attachEvent) {
      global.attachEvent('onmessage', handleMessage);
    }
    return setZeroTimeoutPostMessage;
  }(this)),
  
  blobToArrayBuffer: function(blob, cb){
    var fr = new FileReader();
    fr.onload = function(evt) {
      cb(evt.target.result);
    };
    fr.readAsArrayBuffer(blob);
  },
  blobToBinaryString: function(blob, cb){
    var fr = new FileReader();
    fr.onload = function(evt) {
      cb(evt.target.result);
    };
    fr.readAsBinaryString(blob);
  },
  binaryStringToArrayBuffer: function(binary) {
    var byteArray = new Uint8Array(binary.length);
    for (var i = 0; i < binary.length; i++) {
      byteArray[i] = binary.charCodeAt(i) & 0xff;
    }
    return byteArray.buffer;
  },
  randomToken: function () {
    return Math.random().toString(36).substr(2);
  }
};

module.exports = util;

},{"js-binarypack":10}]},{},[3]);
/* https://github.com/jakearchibald/es6-promise */
!function(){var a,b,c,d;!function(){var e={},f={};a=function(a,b,c){e[a]={deps:b,callback:c}},d=c=b=function(a){function c(b){if("."!==b.charAt(0))return b;for(var c=b.split("/"),d=a.split("/").slice(0,-1),e=0,f=c.length;f>e;e++){var g=c[e];if(".."===g)d.pop();else{if("."===g)continue;d.push(g)}}return d.join("/")}if(d._eak_seen=e,f[a])return f[a];if(f[a]={},!e[a])throw new Error("Could not find module "+a);for(var g,h=e[a],i=h.deps,j=h.callback,k=[],l=0,m=i.length;m>l;l++)"exports"===i[l]?k.push(g={}):k.push(b(c(i[l])));var n=j.apply(this,k);return f[a]=g||n}}(),a("promise/all",["./utils","exports"],function(a,b){"use strict";function c(a){var b=this;if(!d(a))throw new TypeError("You must pass an array to all.");return new b(function(b,c){function d(a){return function(b){f(a,b)}}function f(a,c){h[a]=c,0===--i&&b(h)}var g,h=[],i=a.length;0===i&&b([]);for(var j=0;j<a.length;j++)g=a[j],g&&e(g.then)?g.then(d(j),c):f(j,g)})}var d=a.isArray,e=a.isFunction;b.all=c}),a("promise/asap",["exports"],function(a){"use strict";function b(){return function(){process.nextTick(e)}}function c(){var a=0,b=new i(e),c=document.createTextNode("");return b.observe(c,{characterData:!0}),function(){c.data=a=++a%2}}function d(){return function(){j.setTimeout(e,1)}}function e(){for(var a=0;a<k.length;a++){var b=k[a],c=b[0],d=b[1];c(d)}k=[]}function f(a,b){var c=k.push([a,b]);1===c&&g()}var g,h="undefined"!=typeof window?window:{},i=h.MutationObserver||h.WebKitMutationObserver,j="undefined"!=typeof global?global:void 0===this?window:this,k=[];g="undefined"!=typeof process&&"[object process]"==={}.toString.call(process)?b():i?c():d(),a.asap=f}),a("promise/config",["exports"],function(a){"use strict";function b(a,b){return 2!==arguments.length?c[a]:(c[a]=b,void 0)}var c={instrument:!1};a.config=c,a.configure=b}),a("promise/polyfill",["./promise","./utils","exports"],function(a,b,c){"use strict";function d(){var a;a="undefined"!=typeof global?global:"undefined"!=typeof window&&window.document?window:self;var b="Promise"in a&&"resolve"in a.Promise&&"reject"in a.Promise&&"all"in a.Promise&&"race"in a.Promise&&function(){var b;return new a.Promise(function(a){b=a}),f(b)}();b||(a.Promise=e)}var e=a.Promise,f=b.isFunction;c.polyfill=d}),a("promise/promise",["./config","./utils","./all","./race","./resolve","./reject","./asap","exports"],function(a,b,c,d,e,f,g,h){"use strict";function i(a){if(!v(a))throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");if(!(this instanceof i))throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");this._subscribers=[],j(a,this)}function j(a,b){function c(a){o(b,a)}function d(a){q(b,a)}try{a(c,d)}catch(e){d(e)}}function k(a,b,c,d){var e,f,g,h,i=v(c);if(i)try{e=c(d),g=!0}catch(j){h=!0,f=j}else e=d,g=!0;n(b,e)||(i&&g?o(b,e):h?q(b,f):a===D?o(b,e):a===E&&q(b,e))}function l(a,b,c,d){var e=a._subscribers,f=e.length;e[f]=b,e[f+D]=c,e[f+E]=d}function m(a,b){for(var c,d,e=a._subscribers,f=a._detail,g=0;g<e.length;g+=3)c=e[g],d=e[g+b],k(b,c,d,f);a._subscribers=null}function n(a,b){var c,d=null;try{if(a===b)throw new TypeError("A promises callback cannot return that same promise.");if(u(b)&&(d=b.then,v(d)))return d.call(b,function(d){return c?!0:(c=!0,b!==d?o(a,d):p(a,d),void 0)},function(b){return c?!0:(c=!0,q(a,b),void 0)}),!0}catch(e){return c?!0:(q(a,e),!0)}return!1}function o(a,b){a===b?p(a,b):n(a,b)||p(a,b)}function p(a,b){a._state===B&&(a._state=C,a._detail=b,t.async(r,a))}function q(a,b){a._state===B&&(a._state=C,a._detail=b,t.async(s,a))}function r(a){m(a,a._state=D)}function s(a){m(a,a._state=E)}var t=a.config,u=(a.configure,b.objectOrFunction),v=b.isFunction,w=(b.now,c.all),x=d.race,y=e.resolve,z=f.reject,A=g.asap;t.async=A;var B=void 0,C=0,D=1,E=2;i.prototype={constructor:i,_state:void 0,_detail:void 0,_subscribers:void 0,then:function(a,b){var c=this,d=new this.constructor(function(){});if(this._state){var e=arguments;t.async(function(){k(c._state,d,e[c._state-1],c._detail)})}else l(this,d,a,b);return d},"catch":function(a){return this.then(null,a)}},i.all=w,i.race=x,i.resolve=y,i.reject=z,h.Promise=i}),a("promise/race",["./utils","exports"],function(a,b){"use strict";function c(a){var b=this;if(!d(a))throw new TypeError("You must pass an array to race.");return new b(function(b,c){for(var d,e=0;e<a.length;e++)d=a[e],d&&"function"==typeof d.then?d.then(b,c):b(d)})}var d=a.isArray;b.race=c}),a("promise/reject",["exports"],function(a){"use strict";function b(a){var b=this;return new b(function(b,c){c(a)})}a.reject=b}),a("promise/resolve",["exports"],function(a){"use strict";function b(a){if(a&&"object"==typeof a&&a.constructor===this)return a;var b=this;return new b(function(b){b(a)})}a.resolve=b}),a("promise/utils",["exports"],function(a){"use strict";function b(a){return c(a)||"object"==typeof a&&null!==a}function c(a){return"function"==typeof a}function d(a){return"[object Array]"===Object.prototype.toString.call(a)}var e=Date.now||function(){return(new Date).getTime()};a.objectOrFunction=b,a.isFunction=c,a.isArray=d,a.now=e}),b("promise/polyfill").polyfill()}();
/*
Copyright (C) 2011 Patrick Gillespie, http://patorjk.com/

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

/*
    Extendible BBCode Parser v1.0.0
    By Patrick Gillespie (patorjk@gmail.com)
    Website: http://patorjk.com/

    This module allows you to parse BBCode and to extend to the mark-up language
    to add in your own tags.
*/

"use strict";

var XBBCODE = (function() {

    // -----------------------------------------------------------------------------
    // Set up private variables
    // -----------------------------------------------------------------------------

    var me = {},
        urlPattern = /^(?:https?|file|c):(?:\/{1,3}|\\{1})[-a-zA-Z0-9:@#%&()~_?\+=\/\\\.]*$/,
        colorNamePattern = /^(?:red|green|blue|orange|yellow|black|white|brown|gray|silver|purple|maroon|fushsia|lime|olive|navy|teal|aqua)$/,
        colorCodePattern = /^#?[a-fA-F0-9]{6}$/,
        tags,
        tagList,
        tagsNoParseList = [],
        bbRegExp,
        pbbRegExp,
        pbbRegExp2,
        openTags,
        closeTags;
        
    /* -----------------------------------------------------------------------------
     * tags
     * This object contains a list of tags that your code will be able to understand.
     * Each tag object has the following properties:
     *
     *   openTag - A function that takes in the tag's parameters (if any) and its
     *             contents, and returns what its HTML open tag should be. 
     *             Example: [color=red]test[/color] would take in "=red" as a
     *             parameter input, and "test" as a content input.
     *             It should be noted that any BBCode inside of "content" will have 
     *             been processed by the time it enter the openTag function.
     *
     *   closeTag - A function that takes in the tag's parameters (if any) and its
     *              contents, and returns what its HTML close tag should be.
     *
     *   displayContent - Defaults to true. If false, the content for the tag will
     *                    not be displayed. This is useful for tags like IMG where
     *                    its contents are actually a parameter input.
     *
     *   restrictChildrenTo - A list of BBCode tags which are allowed to be nested
     *                        within this BBCode tag. If this property is omitted,
     *                        any BBCode tag may be nested within the tag.
     *
     *   restrictParentsTo - A list of BBCode tags which are allowed to be parents of
     *                       this BBCode tag. If this property is omitted, any BBCode 
     *                       tag may be a parent of the tag.
     *
     *   noParse - true or false. If true, none of the content WITHIN this tag will be
     *             parsed by the XBBCode parser.
     *       
     *
     *
     * LIMITIONS on adding NEW TAGS:
     *  - Tag names should be alphanumeric (including underscores) and all tags should have an opening tag
     *    and a closing tag. 
     *    The [*] tag is an exception because it was already a standard
     *    bbcode tag. Technecially tags don't *have* to be alphanumeric, but since 
     *    regular expressions are used to parse the text, if you use a non-alphanumeric 
     *    tag names, just make sure the tag name gets escaped properly (if needed).
     * --------------------------------------------------------------------------- */
        
    tags = {
        "b": {
            openTag: function(params,content) {
                return '<span class="xbbcode-b">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        /*
            This tag does nothing and is here mostly to be used as a classification for
            the bbcode input when evaluating parent-child tag relationships
        */
        "bbcode": {
            openTag: function(params,content) {
                return '';
            },
            closeTag: function(params,content) {
                return '';
            }
        },
        "code": {
            openTag: function(params,content) {
                return '<span class="xbbcode-code">';
            },
            closeTag: function(params,content) {
                return '</span>';
            },
            noParse: true
        },
        "color": {
            openTag: function(params,content) {
            
                var colorCode = params.substr(1) || "black";
                colorNamePattern.lastIndex = 0;
                colorCodePattern.lastIndex = 0;
                if ( !colorNamePattern.test( colorCode ) ) {
                    if ( !colorCodePattern.test( colorCode ) ) {
                        colorCode = "black";
                    } else {
                        if (colorCode.substr(0,1) !== "#") {
                            colorCode = "#" + colorCode;
                        }
                    }
                }
            
                return '<span style="color:' + colorCode + '">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        "i": {
            openTag: function(params,content) {
                return '<span class="xbbcode-i">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        "img": {
            openTag: function(params,content) {
            
                var myUrl = content;
                
                urlPattern.lastIndex = 0;
                if ( !urlPattern.test( myUrl ) ) {
                    myUrl = "";
                }
            
                return '<img src="' + myUrl + '" />';
            },
            closeTag: function(params,content) {
                return '';
            },
            displayContent: false
        },
        "list": {
            openTag: function(params,content) {
                return '<ul>';
            },
            closeTag: function(params,content) {
                return '</ul>';
            },
            restrictChildrenTo: ["*", "li"]
        },
        "noparse": {
            openTag: function(params,content) {
                return '';
            },
            closeTag: function(params,content) {
                return '';
            },
            noParse: true
        },
        "php": {
            openTag: function(params,content) {
                return '<span class="xbbcode-code">';
            },
            closeTag: function(params,content) {
                return '</span>';
            },
            noParse: true
        },
        "quote": {
            openTag: function(params,content) {
                return '<blockquote class="xbbcode-blockquote">';
            },
            closeTag: function(params,content) {
                return '</blockquote>';
            }
        },
        "s": {
            openTag: function(params,content) {
                return '<span class="xbbcode-s">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        "size": {
            openTag: function(params,content) {
            
                var mySize = parseInt(params.substr(1),10) || 0;
                if (mySize < 4 || mySize > 40) {
                    mySize = 14;
                }
            
                return '<span class="xbbcode-size-' + mySize + '">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        "table": {
            openTag: function(params,content) {
                return '<table class="xbbcode-table">';
            },
            closeTag: function(params,content) {
                return '</table>';
            },
            restrictChildrenTo: ["tbody","thead", "tfoot", "tr"]
        },
        "tbody": {
            openTag: function(params,content) {
                return '<tbody>';
            },
            closeTag: function(params,content) {
                return '</tbody>';
            },
            restrictChildrenTo: ["tr"],
            restrictParentsTo: ["table"]
        },
        "tfoot": {
            openTag: function(params,content) {
                return '<tfoot>';
            },
            closeTag: function(params,content) {
                return '</tfoot>';
            },
            restrictChildrenTo: ["tr"],
            restrictParentsTo: ["table"]
        },
        "thead": {
            openTag: function(params,content) {
                return '<thead class="xbbcode-thead">';
            },
            closeTag: function(params,content) {
                return '</thead>';
            },
            restrictChildrenTo: ["tr"],
            restrictParentsTo: ["table"]
        },
        "td": {
            openTag: function(params,content) {
                return '<td class="xbbcode-td">';
            },
            closeTag: function(params,content) {
                return '</td>';
            },
            restrictParentsTo: ["tr"]
        },
        "th": {
            openTag: function(params,content) {
                return '<td class="xbbcode-th">';
            },
            closeTag: function(params,content) {
                return '</td>';
            },
            restrictParentsTo: ["tr"]
        },
        "tr": {
            openTag: function(params,content) {
                return '<tr class="xbbcode-tr">';
            },
            closeTag: function(params,content) {
                return '</tr>';
            },
            restrictChildrenTo: ["td","th"],
            restrictParentsTo: ["table","tbody","tfoot","thead"]
        },
        "u": {
            openTag: function(params,content) {
                return '<span class="xbbcode-u">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        "url": {
            openTag: function(params,content) {
            
                var myUrl;
            
                if (!params) {
                    myUrl = content.replace(/<.*?>/g,"");
                } else {
                    myUrl = params.substr(1);
                }
                
                urlPattern.lastIndex = 0;
                if ( !urlPattern.test( myUrl ) ) {
                    myUrl = "#";
                }
            
                return '<a href="' + myUrl + '">';
            },
            closeTag: function(params,content) {
                return '</a>';
            }
        },
        /*
            The [*] tag is special since the user does not define a closing [/*] tag when writing their bbcode.
            Instead this module parses the code and adds the closing [/*] tag in for them. None of the tags you
            add will act like this and this tag is an exception to the others.
        */
        "*": {
            openTag: function(params,content) {
                return "<li>";
            },
            closeTag: function(params,content) {
                return "</li>";
            },
            restrictParentsTo: ["list"]
        }
    };
    
    // create tag list and lookup fields
    tagList = [];
    (function() {
        var prop,
            ii,
            len;
        for (prop in tags) {
            if (tags.hasOwnProperty(prop)) {
                if (prop === "*") {
                    tagList.push("\\" + prop);
                } else {
                    tagList.push(prop);
                    if ( tags[prop].noParse ) {
                        tagsNoParseList.push(prop);
                    }
                }
                
                tags[prop].validChildLookup = {};
                tags[prop].validParentLookup = {};
                tags[prop].restrictParentsTo = tags[prop].restrictParentsTo || [];
                tags[prop].restrictChildrenTo = tags[prop].restrictChildrenTo || [];
                
                len = tags[prop].restrictChildrenTo.length;
                for (ii = 0; ii < len; ii++) {
                    tags[prop].validChildLookup[ tags[prop].restrictChildrenTo[ii] ] = true;
                }
                len = tags[prop].restrictParentsTo.length;
                for (ii = 0; ii < len; ii++) {
                    tags[prop].validParentLookup[ tags[prop].restrictParentsTo[ii] ] = true;
                }
            }
        }
    })();
    
    bbRegExp = new RegExp("<bbcl=([0-9]+) (" + tagList.join("|") + ")([ =][^>]*?)?>((?:.|[\\r\\n])*?)<bbcl=\\1 /\\2>", "gi"); 
    pbbRegExp = new RegExp("\\[(" + tagList.join("|") + ")([ =][^\\]]*?)?\\]([^\\[]*?)\\[/\\1\\]", "gi"); 
    pbbRegExp2 = new RegExp("\\[(" + tagsNoParseList.join("|") + ")([ =][^\\]]*?)?\\]([\\s\\S]*?)\\[/\\1\\]", "gi");    

    // create the regex for escaping ['s that aren't apart of tags
    (function() {
        var closeTagList = [];
        for (var ii = 0; ii < tagList.length; ii++) {
            if ( tagList[ii] !== "\\*" ) { // the * tag doesn't have an offical closing tag
                closeTagList.push ( "/" + tagList[ii] );
            }
        }

        openTags = new RegExp("(\\[)((?:" + tagList.join("|") + ")(?:[ =][^\\]]*?)?)(\\])", "gi"); 
        closeTags = new RegExp("(\\[)(" + closeTagList.join("|") + ")(\\])", "gi"); 
    })();
    
    // -----------------------------------------------------------------------------
    // private functions
    // -----------------------------------------------------------------------------
    
    function checkParentChildRestrictions(parentTag, bbcode, bbcodeLevel, tagName, tagParams, tagContents, errQueue) {
        
        errQueue = errQueue || [];
        bbcodeLevel++;
        
        // get a list of all of the child tags to this tag
        var reTagNames = new RegExp("(<bbcl=" + bbcodeLevel + " )(" + tagList.join("|") + ")([ =>])","gi"),
            reTagNamesParts = new RegExp("(<bbcl=" + bbcodeLevel + " )(" + tagList.join("|") + ")([ =>])","i"),
            matchingTags = tagContents.match(reTagNames) || [],
            cInfo,
            errStr,
            ii,
            childTag,
            pInfo = tags[parentTag] || {};
        
        reTagNames.lastIndex = 0;
        
        if (!matchingTags) {
            tagContents = "";
        }
        
        for (ii = 0; ii < matchingTags.length; ii++) {
            reTagNamesParts.lastIndex = 0;
            childTag = (matchingTags[ii].match(reTagNamesParts))[2].toLowerCase();
            
            if ( pInfo.restrictChildrenTo.length > 0 ) {
                if ( !pInfo.validChildLookup[childTag] ) {
                    errStr = "The tag \"" + childTag + "\" is not allowed as a child of the tag \"" + parentTag + "\".";
                    errQueue.push(errStr);
                }
            }
            cInfo = tags[childTag] || {};
            if ( cInfo.restrictParentsTo.length > 0 ) {
                if ( !cInfo.validParentLookup[parentTag] ) {
                    errStr = "The tag \"" + parentTag + "\" is not allowed as a parent of the tag \"" + childTag + "\".";
                    errQueue.push(errStr);
                }
            }
            
        }
        
        tagContents = tagContents.replace(bbRegExp, function(matchStr, bbcodeLevel, tagName, tagParams, tagContents ) {
            errQueue = checkParentChildRestrictions(tagName, matchStr, bbcodeLevel, tagName, tagParams, tagContents, errQueue);
            return matchStr;
        });
        return errQueue;
    }
    
    /*
        This function updates or adds a piece of metadata to each tag called "bbcl" which 
        indicates how deeply nested a particular tag was in the bbcode. This property is removed
        from the HTML code tags at the end of the processing.
    */
    function updateTagDepths(tagContents) {
        tagContents = tagContents.replace(/\<([^\>][^\>]*?)\>/gi, function(matchStr, subMatchStr) {
            var bbCodeLevel = subMatchStr.match(/^bbcl=([0-9]+) /);
            if (bbCodeLevel === null) {
                return "<bbcl=0 " + subMatchStr + ">";
            } else {
                return "<" + subMatchStr.replace(/^(bbcl=)([0-9]+)/, function(matchStr, m1, m2) {
                    return m1 + (parseInt(m2, 10) + 1);
                }) + ">";
            }
        });
        return tagContents;
    }
    
    /*
        This function removes the metadata added by the updateTagDepths function
    */
    function unprocess(tagContent) {
        return tagContent.replace(/<bbcl=[0-9]+ \/\*>/gi,"").replace(/<bbcl=[0-9]+ /gi,"&#91;").replace(/>/gi,"&#93;");
    }
    
    var replaceFunct = function(matchStr, bbcodeLevel, tagName, tagParams, tagContents) {
    
        tagName = tagName.toLowerCase();

        var processedContent = tags[tagName].noParse ? unprocess(tagContents) : tagContents.replace(bbRegExp, replaceFunct),
            openTag = tags[tagName].openTag(tagParams,processedContent),
            closeTag = tags[tagName].closeTag(tagParams,processedContent);
            
        if ( tags[tagName].displayContent === false) {
            processedContent = "";
        }
        
        return openTag + processedContent + closeTag;
    };

    function parse(config) {
        var output = config.text;
        output = output.replace(bbRegExp, replaceFunct);
        return output;
    }
    
    /*
        The star tag [*] is special in that it does not use a closing tag. Since this parser requires that tags to have a closing
        tag, we must pre-process the input and add in closing tags [/*] for the star tag.
        We have a little levaridge in that we know the text we're processing wont contain the <> characters (they have been
        changed into their HTML entity form to prevent XSS and code injection), so we can use those characters as markers to
        help us define boundaries and figure out where to place the [/*] tags.
    */
    function fixStarTag(text) {
        text = text.replace(/\[(?!\*[ =\]]|list([ =][^\]]*)?\]|\/list[\]])/ig, "<");
        text = text.replace(/\[(?=list([ =][^\]]*)?\]|\/list[\]])/ig, ">");

        while (text !== (text = text.replace(/>list([ =][^\]]*)?\]([^>]*?)(>\/list])/gi, function(matchStr,contents,endTag) {
            
            var innerListTxt = matchStr;
            while (innerListTxt !== (innerListTxt = innerListTxt.replace(/\[\*\]([^\[]*?)(\[\*\]|>\/list])/i, function(matchStr,contents,endTag) {
                if (endTag === ">/list]") {
                    endTag = "</*]</list]";
                } else {
                    endTag = "</*][*]";
                }
                var tmp = "<*]" + contents + endTag;
                return tmp;
            })));
            
            innerListTxt = innerListTxt.replace(/>/g, "<");            
            return innerListTxt;
        })));
        
        // add ['s for our tags back in
        text = text.replace(/</g, "[");
        return text;
    };
    
    function addBbcodeLevels(text) {
        while ( text !== (text = text.replace(pbbRegExp, function(matchStr, tagName, tagParams, tagContents) {
            matchStr = matchStr.replace(/\[/g, "<");
            matchStr = matchStr.replace(/\]/g, ">");
            return updateTagDepths(matchStr);
        })) );
        return text;
    }
    
    // -----------------------------------------------------------------------------
    // public functions
    // -----------------------------------------------------------------------------
    
    me.process = function(config) {
    
        var ret = {html: "", error: false},
            errQueue = [];

        config.text = config.text.replace(/</g, "&lt;"); // escape HTML tag brackets
        config.text = config.text.replace(/>/g, "&gt;"); // escape HTML tag brackets
        
        config.text = config.text.replace(openTags, function(matchStr, openB, contents, closeB) {
            return "<" + contents + ">";
        });
        config.text = config.text.replace(closeTags, function(matchStr, openB, contents, closeB) {
            return "<" + contents + ">";
        });
        
        config.text = config.text.replace(/\[/g, "&#91;"); // escape ['s that aren't apart of tags
        config.text = config.text.replace(/\]/g, "&#93;"); // escape ['s that aren't apart of tags
        config.text = config.text.replace(/</g, "["); // escape ['s that aren't apart of tags
        config.text = config.text.replace(/>/g, "]"); // escape ['s that aren't apart of tags

        // process tags that don't have their content parsed
        while ( config.text !== (config.text = config.text.replace(pbbRegExp2, function(matchStr, tagName, tagParams, tagContents) {
            tagContents = tagContents.replace(/\[/g, "&#91;");
            tagContents = tagContents.replace(/\]/g, "&#93;");
            tagParams = tagParams || "";
            tagContents = tagContents || "";
            return "[" + tagName + tagParams + "]" + tagContents + "[/" + tagName + "]";
        })) );

        config.text = fixStarTag(config.text); // add in closing tags for the [*] tag
        config.text = addBbcodeLevels(config.text); // add in level metadata

        errQueue = checkParentChildRestrictions("bbcode", config.text, -1, "", "", config.text);
        
        ret.html = parse(config);

        if ( ret.html.indexOf("[") !== -1 || ret.html.indexOf("]") !== -1) {
            errQueue.push("Some tags appear to be misaligned.");
        }
    
        if (config.removeMisalignedTags) {
            ret.html = ret.html.replace(/\[.*?\]/g,"");
        }
        if (config.addInLineBreaks) {
            ret.html = ret.html.replace(/\r\n/g, "\n");
            ret.html = ret.html.replace(/(\r|\n)/g, "$1<br/>");
        }
    
        ret.html = ret.html.replace("&#91;", "["); // put ['s back in
        ret.html = ret.html.replace("&#93;", "]"); // put ['s back in
        
        ret.error = (errQueue.length === 0) ? false : true;
        ret.errorQueue = errQueue;
        
        return ret;
    }
    
    return me;
})();
/*
    boron: some utilities for immutability
*/


Boron = {}

Boron.persistent_merge = function(props, data) {
    /// merges a 'flattened' data array into props in a persistent fashion
    /// the new object reuses old data where possible, so requires ~log N additional space
    
    /// given props {fun: {yay:123, ok:123}, cat:{dog:123}}    
    ///   and  data {'fun.yay':0, 'cat.ant.bear':0}}          
    ///     returns {fun: {yay:0, ok:123}, cat:{ant:{bear:0}}}
    
    data = data || []
    
    if(Array.isArray(data) || Array.isArray(data)) {
        // THINK: what do we do with arrays?
        if(Array.isArray(data) !== Array.isArray(props)) {
            // THINK: how to deal with array / object mismatch?
        }
    }
    
    // THINK: what about when data is {cat:{'ant.bear':0}} ?
    
    return Object.keys(data).reduce(function(props, key) {              // OPT: combine these instead of doing them separately
        return Boron.set_deep_value(props, key, data[key])
    }, props)
}

Boron.set_deep_value = function(props, path, value) {
    /// set a value from a flattened path
    
    /// given props {fun: {yay:123, ok:123}, cat:{dog:123}}
    ///   and  path 'fun.ok' 
    ///   and value 456
    ///     returns {fun: {yay:123, ok:456}, cat:{dog:123}}
    
    // var segs = path.split('.')
    // THINK: this is vaguely awful, but without lookbehind it's hard to say "only split on dots that aren't slashed"
    // var segs = path.split('').reverse().join('')
    //                .split(/\.(?!\\)/).reverse()
    //                .map(function(chunk) {return chunk.split('').reverse().join('')})
    //                .map(function(chunk) {return chunk.replace(/[\\]$/, '')})
    
    // THINK: this is vaguely awfuller, but works and is fairly fast and readable. 
    var magic = "___MAGIC___"
    var magic_regex = new RegExp(magic, 'g');
    var path = path.replace(/\\\./g, magic)
    var segs = path.split('.').map(function(chunk) {return chunk.replace(magic_regex, '.')})
    
    var last = segs.pop()
    var next
    var final = next = Boron.shallow_copy(props)

    segs.forEach(function(seg) {
        next[seg] = Boron.shallow_copy(next[seg])
        next = next[seg]
    })

    next[last] = value
    return final
}

Boron.shallow_copy = function(obj) {
    if(Array.isArray(obj)) return obj.slice()
    return Object.keys(obj || {}).reduce(function(acc, key) {acc[key] = obj[key]; return acc}, {})
}

Boron.shallow_diff = function(oldObj, newObj) {                         // results come from newObj
    return Object.keys(oldObj).reduce(function(acc, key) {
        if(JSON.stringify(oldObj[key]) != JSON.stringify(newObj[key]))
            acc[key] = newObj[key]                                      // this pointer copies deep data
        return acc
    }, oldObj.constructor())
}

Boron.deep_diff = function(oldObj, newObj) {                            // results come from newObj
    return Object.keys(newObj).reduce(function(acc, key) {
        var oldtype = typeof oldObj[key]
        var newtype = typeof newObj[key]
        
        if(oldtype != newtype) {
            acc[key] = newObj[key]                                      // this pointer copies deep data
            return acc
        }
        
        if(oldtype == 'object') {
            var diff = Boron.deep_diff(oldObj[key], newObj[key])
            if(Object.keys(diff).length)
                acc[key] = diff
            return acc
        }
        
        if(oldObj[key] !== newObj[key])
            acc[key] = newObj[key]
        return acc
    }, newObj.constructor())
}

Boron.flatten = function(obj, prefix) {
    /// convert {fun: {yay: 123}} into {'fun.yay': 123}
    
    if(!Boron.proper_object(obj)) return {}
    
    var newobj = {}
    prefix = prefix ? prefix + '.' : ''
    
    for(var key in obj) {
        if(!Boron.proper_object(obj[key])) {
            newobj[prefix+key] = obj[key]
        } else {
            newobj = Boron.extend(newobj, Boron.flatten(obj[key], prefix+key)) // OPT: lotsa GC here
        }
    }
    
    return newobj
}

Boron.unflatten = function(obj) {
    /// convert {'fun.yay': 123} into {fun: {yay: 123}}
    
    return Boron.persistent_merge({}, obj) // OPT: GC
    // return Object.keys(obj||{}).reduce(function(acc, key) {return Boron.set_deep_value(acc, key, obj[key])}, {}) // OPT: GC
}

Boron.proper_object = function(obj) { return typeof obj == 'object' && !Array.isArray(obj) && !!obj} 

Boron.extend = function() {
    /// given ({fun:123, yay:123}, {yay:456, ok:789}) as args, returns a new object {fun:123, yay:456, ok:789}
    
    var newobj = {}
    Array.prototype.slice.call(arguments).forEach(function(arg) {
        for(var prop in arg) {
            newobj[prop] = arg[prop] } })
    return newobj
}


Boron.memoize = function(f) {
    var table = {}
    f = typeof f == 'function' ? f : function() {}
    return function() {
        var args = Array.prototype.slice.call(arguments)
        var key = args.toString()
        return table[key] ? table[key] : (table[key] = f.apply(null, args))
    } 
}

/*
     ____  _____ _____ _____ _____ _____ 
    |    \|  _  |   __|     | __  |  _  |
    |  |  |     |  |  |  |  | __ -|     |
    |____/|__|__|_____|_____|_____|__|__|
    
    dagoba: a tiny in-memory graph database

    ex: 
    V = [ {name: 'alice'}                                         // alice gets auto-_id (prolly 1)
        , {_id: 10, name: 'bob', hobbies: ['asdf', {x:3}]}] 
    E = [ {_out: 1, _in: 10, _label: 'knows'} ]
    g = Dagoba.graph(V, E)
    
    g.addVertex({name: 'charlie', _id: 'charlie'})                // string ids are fine
    g.addVertex({name: 'delta', _id: '30'})                       // actually they're all strings

    g.addEdge({_out: 10, _in: 30, _label: 'parent'})
    g.addEdge({_out: 10, _in: 'charlie', _label: 'knows'})

    g.v(1).out('knows').out().run()                               // returns [charlie, delta]
    
    q = g.v(1).out('knows').out().take(1)
    q.run()                                                       // returns [charlie]
    q.run()                                                       // returns [delta]    (but don't rely on result order!)
    q.run()                                                       // returns []
*/


Dagoba = {}                                                       // the namespace

Dagoba.G = {}                                                     // the prototype

Dagoba.graph = function(V, E) {                                   // the factory
  var graph = Object.create( Dagoba.G )
  graph.vertices = []                                             // fresh copies so they're not shared
  graph.edges = []
  graph.vertexIndex = {}
  if(V && Array.isArray(V)) graph.addVertices(V)                  // arrays only, because you wouldn't
  if(E && Array.isArray(E)) graph.addEdges(E)                     // call this with singular V and E
  return graph
}

Dagoba.G.v = function() {                                         // a query initializer: g.v() -> query
  var query = Dagoba.query(this)
  query.add(['vertex'].concat( [].slice.call(arguments) ))
  return query
}

Dagoba.G.addVertex = function(vertex) {
  if(!vertex._id) 
    vertex._id = this.vertices.length+1
  // TODO: ensure unique _id
  this.vertices.push(vertex) // THINK: the user may retain a pointer to vertex, which they might mutate later >.<
  // can take away user's ability to set _id and lose the index cache hash, because building it causes big rebalancing slowdowns and runs the GC hard. (or does it?) [this was with a million items, indexed by consecutive ints. generally we need settable _id because we need to grab vertices quickly by external key]
  this.vertexIndex[vertex._id] = vertex
  vertex._out = []; vertex._in = []
}

Dagoba.G.addEdge = function(edge) {
  if(!edge._label) return false
  edge._in  = this.findVertexById(edge._in)
  edge._out = this.findVertexById(edge._out)
  if(!(edge._in && edge._out)) return false
  edge._out._out.push(edge)
  edge._in._in.push(edge)
  this.edges.push(edge)
}

Dagoba.G.addVertices = function(vertices) { vertices.forEach(this.addVertex.bind(this)) }
Dagoba.G.addEdges    = function(edges)    { edges   .forEach(this.addEdge  .bind(this)) }

Dagoba.G.findVertexById = function(vertex_id) {
  return this.vertexIndex[vertex_id] }

Dagoba.G.findVerticesByIds = function(ids) {
  return ids.length == 1 ? [].concat( this.findVertexById(ids[0]) || [] )
       : ids.map( this.findVertexById.bind(this) ).filter(Boolean) }

Dagoba.G.findVertices = function(ids) {
  return typeof ids[0] == 'object' ? this.searchVertices(ids[0])
       : ids.length == 0 ? this.vertices.slice()                  // OPT: do we need the slice?
       : this.findVerticesByIds(ids) }

Dagoba.G.searchVertices = function(obj) {
  return this.vertices.filter(
    function(vertex) {
      return Object.keys(obj).reduce(
        function(acc, key) {
          return acc && obj[key] == vertex[key] }, true ) } ) }

Dagoba.G.findEdgeById = function(edge_id) {
  return Dagoba.find(this.edges, function(edge) {return edge._id == edge_id} ) }

Dagoba.G.findOutEdges = function(vertex) { return vertex._out; }
Dagoba.G.findInEdges  = function(vertex) { return vertex._in;  }

Dagoba.G.toString = function() {                                  // kids, don't hand code JSON
  return '{"V":' + JSON.stringify(this.vertices, Dagoba.cleanvertex)
       + ',"E":' + JSON.stringify(this.edges,    Dagoba.cleanedge) 
       + '}' }

Dagoba.fromString = function(str) {                               // another graph constructor
  var obj = JSON.parse(str)
  return Dagoba.graph(obj.V, obj.E) 
}



Dagoba.Q = {}                                                     // prototype

Dagoba.query = function(graph) {                                  // factory (only called by a graph's query initializers)
  var query = Object.create( Dagoba.Q )
  
  query.   graph = graph                                          // the graph itself
  query.   state = []                                             // state for each step
  query. program = []                                             // list of steps to take  
  query.gremlins = []                                             // gremlins for each step
  
  return query
}

Dagoba.Q.run = function() {                                       // the magic lives here
  
  var graph = this.graph                                          // these are closed over in the helpers
  var state = this.state                                          // so we give them a spot in the frame
  var program  = this.program
  var gremlins = this.gremlins

  var max = program.length-1                                      // work backwards
  var pc = max                                                    // program counter
  var done = -1                                                   // behindwhich things have finished
  var results = []                                                // results for this run
  var maybe_gremlin = false                                       // a mythical beast

  if(!program.length) return []                                   // don't bother
  
  
  // driver loop
  while(done < max) {
    maybe_gremlin = try_step(pc, maybe_gremlin)                   // maybe_gremlin is a gremlin or (string | false)
    
    if(maybe_gremlin == 'pull') {
      maybe_gremlin = false
      if(pc-1 > done) {
        pc--
        continue
      } else {
        done = pc
      }
    }
    
    if(maybe_gremlin == 'done') {
      done = pc
      maybe_gremlin = false
    }
    
    pc++
    
    if(pc > max) {                                                // a gremlin is popping out of the pipeline. catch it!
      if(maybe_gremlin)
        results.push(maybe_gremlin)
      maybe_gremlin = false
      pc--
    }
  }

  // TODO: deal with gremlin paths / history and gremlin "collisions"
  
  results = results.map(function(gremlin) {                       // make this a query component (or posthook)
    return gremlin.result ? gremlin.result : gremlin.vertex } )

  results = Dagoba.firehooks('postquery', this, results)[0] 
  
  return results
  
  // NAMED HELPERS
  
  function try_step(pc, maybe_gremlin) {
    var step = program[pc]
    var my_state = (state[pc] = state[pc] || {})
    if(!Dagoba.QFuns[step[0]]) return Dagoba.onError('Unrecognized function call: ' + step[0]) || maybe_gremlin || 'pull'
    return Dagoba.QFuns[step[0]](graph, step.slice(1) || {}, maybe_gremlin, my_state)
  }
    
  function gremlin_boxer(step_index) { return function(gremlin) { return [step_index, gremlin] } }
  
  function stepper(step_index, gremlin) {
    var step = program[step_index]
    if(!Dagoba.QFuns[step[0]]) return Dagoba.onError('Unrecognized function call: ' + step[0]) || {}
    return Dagoba.QFuns[step[0]](graph, step.slice(1) || {}, gremlin || {}, state[step_index] || {})
  }
  
  function eat_gremlins(gremlins, step_index, result) {
    return gremlins.concat( (result.stay || []).map(gremlin_boxer(step_index))   )
                   .concat( (result.go   || []).map(gremlin_boxer(step_index+1)) ) }
  
  function setbang_gremlins(step_index, result) {gremlins = eat_gremlins(gremlins, step_index, result)}
}


Dagoba.Q.add = function(list) {                                  // add a new traversal to the query
  this.program.push(list)
  return this
}

Dagoba.addQFun = function(name, fun) {                            // add a new traversal type
  Dagoba.QFuns[name] = fun
  Dagoba.Q[name] = function() { return this.add([name].concat([].slice.apply(arguments))) } 
  // TODO: accept string fun and allow extra params, for building quick aliases like
  //       Dagoba.addQFun('children', 'out') <-- if all out edges are kids
  //       Dagoba.addQFun('nthGGP', 'inN', 'parent')
  // var methods = ['out', 'in', 'take', 'property', 'outAllN', 'inAllN', 'unique', 'filter', 'outV', 'outE', 'inV', 'inE', 'both', 'bothV', 'bothE']
}


Dagoba.QFuns = {}                                                 // all traversal types

Dagoba.addQFun('vertex', function(graph, args, gremlin, state) {
  if(!state.vertices) state.vertices = graph.findVertices(args)
  if(!state.vertices.length) return 'done'
  var vertex = state.vertices.pop() 
  return Dagoba.make_gremlin(vertex)
})
  
Dagoba.addQFun('out', function(graph, args, gremlin, state) {
  if(!gremlin && (!state.edges || !state.edges.length)) return 'pull'
  if(!state.edges || !state.edges.length) 
    state.edges = graph.findOutEdges(gremlin.vertex).filter(Dagoba.filterThings(args[0]))
  if(!state.edges.length) return 'pull'
  var vertex = state.edges.pop()._in // what?
  var clone = Dagoba.make_gremlin(vertex) // we lose history here: use clone_gremlin(gremlin).goto(vertex) instead
  return clone
})

Dagoba.addQFun('outAllN', function(graph, args, gremlin, state) {
  var filter = args[0]
  var limit = args[1]-1
  
  if(!state.edgeList) { // initialize
    if(!gremlin) return 'pull'
    state.edgeList = []
    state.current = 0
    state.edgeList[0] = graph.findOutEdges(gremlin.vertex).filter(Dagoba.filterThings(filter))
  }
  
  if(!state.edgeList[state.current].length) { // finished this round
    if(state.current >= limit || !state.edgeList[state.current+1]   // totally done, or the next round has no items
                              || !state.edgeList[state.current+1].length) {
      state.edgeList = false
      return 'pull'
    }
    state.current++ // go to next round
    state.edgeList[state.current+1] = [] 
  }
  
  var vertex = state.edgeList[state.current].pop()._in
  
  if(state.current < limit) { // add all our matching edges to the next level
    if(!state.edgeList[state.current+1]) state.edgeList[state.current+1] = []
    state.edgeList[state.current+1] = state.edgeList[state.current+1].concat(
      graph.findOutEdges(vertex).filter(Dagoba.filterThings(filter))
    )
  }
  
  var clone = Dagoba.make_gremlin(vertex) // we lose history here: use clone_gremlin(gremlin).goto(vertex) instead
  return clone
})
  
Dagoba.addQFun('inAllN', function(graph, args, gremlin, state) {
  var filter = args[0]
  var limit = args[1]-1
  
  if(!state.edgeList) {                                           // initialize
    if(!gremlin) return 'pull'
    state.edgeList = []
    state.current = 0
    state.edgeList[0] = graph.findInEdges(gremlin.vertex).filter(Dagoba.filterThings(filter))
  }
  
  if(!state.edgeList[state.current].length) {                     // finished this round
    if(state.current >= limit || !state.edgeList[state.current+1] // totally done, or the next round has no items
                              || !state.edgeList[state.current+1].length) {
      state.edgeList = false
      return 'pull'
    }
    state.current++                                               // go to next round
    state.edgeList[state.current+1] = [] 
  }
  
  var vertex = state.edgeList[state.current].pop()._out
  
  if(state.current < limit) {                                     // add all our matching edges to the next level
    if(!state.edgeList[state.current+1]) state.edgeList[state.current+1] = []
    state.edgeList[state.current+1] = state.edgeList[state.current+1].concat(
      graph.findInEdges(vertex).filter(Dagoba.filterThings(filter))
    )
  }
  
  var clone = Dagoba.make_gremlin(vertex) // we lose history here: use clone_gremlin(gremlin).goto(vertex) instead
  return clone
})
  
Dagoba.addQFun('in', function(graph, args, gremlin, state) {
  if(!gremlin && (!state.edges || !state.edges.length)) return 'pull'
  if(!state.edges || !state.edges.length) 
    state.edges = graph.findInEdges(gremlin.vertex).filter(Dagoba.filterThings(args[0]))
  if(!state.edges.length) return 'pull'
  var vertex = state.edges.pop()._out // what? // also, abstract this...
  var clone = Dagoba.make_gremlin(vertex) // we lose history here: use clone_gremlin(gremlin).goto(vertex) instead
  return clone
})
  
Dagoba.addQFun('property', function(graph, args, gremlin, state) {
  if(!gremlin) return 'pull'
  gremlin.result = gremlin.vertex[args[0]]
  return gremlin
})
  
Dagoba.addQFun('unique', function(graph, args, gremlin, state) {
  if(!gremlin) return 'pull'
  if(state[gremlin.vertex._id]) return 'pull'                     // we've seen this gremlin, so get another instead
  state[gremlin.vertex._id] = true
  return gremlin
})
  
Dagoba.addQFun('filter', function(graph, args, gremlin, state) {
  if(!gremlin) return 'pull'
  if(typeof args[0] != 'function') return Dagoba.onError('Filter arg is not a function: ' + args[0]) || gremlin
  if(!args[0](gremlin.vertex)) return 'pull'                      // gremlin fails filter function 
  // THINK: would we ever want to filter by other parts of the gremlin?
  return gremlin
})
  
Dagoba.addQFun('take', function(graph, args, gremlin, state) {
  state.taken = state.taken ? state.taken : 0
  if(state.taken == args[0]) {
    state.taken = 0
    return 'done'
  }
  if(!gremlin) return 'pull'
  state.taken++ // THINK: mutating state
  return gremlin
})



// hi! 
// - tune gremlins (collisions, history, etc)
// - interface: show query pieces and params,
// - interface: resumable queries
// - generational queries
// - intersections
// - adverbs
// - you are great!



Dagoba.hooks = {}

Dagoba.addhook = function(type, callback) {
  if(!Dagoba.hooks[type]) Dagoba.hooks[type] = []
  Dagoba.hooks[type].push(callback)
}

Dagoba.firehooks = function(type, query) {
  var args = [].slice.call(arguments, 2)
  return ((Dagoba.hooks || {})[type] || []).reduce(function(acc, callback) {return callback.apply(query, acc)}, args)
}

Dagoba.make_gremlin = function(vertex, state) { return {vertex: vertex, state: state} }

Dagoba.filterThings = function(arg) {
  return function(thing) {
    return !arg ? true                                                                           // nothing is true
         : arg+'' === arg ? thing._label == arg                                                  // check the label
         : Array.isArray(arg) ? !!~arg.indexOf(thing._label) : Dagoba.objFilter(thing, arg) } }  // or a list of labels

Dagoba.objFilter = function(thing, obj) {
  for(var key in obj)
    if(thing[key] != obj[key])
      return false; return true }

Dagoba.find = function(arr, fun) {
  for (var i = 0, len = arr.length; i < len; i++)
    if(fun(arr[i], i, arr))
      return arr[i] }

Dagoba.cleanvertex = function(key, value) {return (key == '_in' || key == '_out') ? undefined : value} // for JSON.stringify
Dagoba.cleanedge   = function(key, value) {return key == '_in' ? value._id : key == '_out' ? value._id : value}

Dagoba.uniqueify = function (results) { // OPT: do this in the query via gremlin collision counting
  return [results.filter(function(item, index, array) {return array.indexOf(item) == index})]}

Dagoba.cleanclone = function (results) { // remove all _-prefixed properties
 return [results.map(function(item) {return JSON.parse(JSON.stringify(item, function(key, value) {return key[0]=='_' ? undefined : value}))})]}

// NOTE: add these hooks if you need them. (our vertex payloads are immutable, and we uniqueify prior to taking.)

// Dagoba.addhook('postquery', Dagoba.uniqueify)
// Dagoba.addhook('postquery', Dagoba.cleanclone)

// THINK: the uniquify hook happens after the take component so it smushes results down, possibly returning fewer than you wanted...
  
Dagoba.onError = function(msg) {
  console.log(msg)
  return false 
}
/*
    events: a pub/sub system with wildcard paths
*/


Events = {}
Events.subs = {}

Events.pub = function(path, data) {
    return setImmediate(function() {Events.start_pub(path, data)})              // do it next tick
}

Events.sub = function(path, handler) {
    path = Events.scrub_path(path).join('/')
    if(!Events.subs[path]) Events.subs[path] = []
    Events.subs[path].push(handler)
}

Events.unsub = function(path, handler) {
    path = Events.scrub_path(path).join('/')

    var subs = Events.subs[path]
    if(!subs) return false

    var index = subs.indexOf(handler)
    if(index == -1) return false

    subs.splice(index, 1)
}

Events.start_pub = function(path, data) {
    //// pub to * at each level and then to path itself
    var pathlist = Events.scrub_path(path)
    var realpath = pathlist.join('/')

    Events.try_pub('*', data, realpath)                                         // global catchall

    pathlist.reduce(function(acc, seg) {                                        // channel catchalls
        var newacc = acc + seg + '/'
        Events.try_pub(newacc + '*', data, realpath)
        return newacc
    }, '')

    Events.try_pub(realpath, data, realpath)                                    // actual channel
}

Events.try_pub = function(path, data, realpath) {
    var handlers = Events.subs[path]
    if(!handlers || !handlers.length) return false
    handlers.forEach(function(handler) {handler(data, realpath)})
    // THINK: use setImmediate here?
}


Events.scrub_path = function(path) {
    return path.replace(/^[^\w*-]+/, '')                                        // trim leading slashes etc
        .replace(/[^\w*-]+$/, '')                                               // trim trailing gunk
        .split('/')                                                             // break out the path segments
        .map(function(item) {return item.replace(/[^\w*-]/g, '')})              // scrub each segment
}


// maybe later
// eventlog = []
// Events.sub('*', function(data, path) {
//     eventlog.push([path, data])
// })


FileFile = {}

FileFile.oldFile = null

FileFile.prepBlob = function(str, type) {
    if (typeof str != 'string')
        str = JSON.stringify(str)

    var blob

    if (type == 'file')
        blob = FileFile.dataURItoBlob(str)
    else
        blob = new Blob([str], {type: 'text/plain'})

    if (navigator.appVersion.toString().indexOf('.NET') > 0)            // IE needs to directly save the blob object
        return blob

    if(FileFile.oldFile)                                                // prevents old blobs from causing mem leaks
       window.URL.revokeObjectURL(FileFile.oldFile)

    FileFile.oldFile = window.URL.createObjectURL(blob)

    return FileFile.oldFile
}

FileFile.openPuffFile = function(element) {                
    return FileFile.handleFileOpen(element)
}

FileFile.openTextFile = function(element) {                
    return FileFile.handleFileOpen(element)
}

FileFile.openBinaryFile = function(element) {                
    return FileFile.handleFileOpen(element, 'asDataURI')
}

FileFile.handleFileOpen = function(element, asDataURI) {                
    return new Promise(function(resolve, reject) {
        var reader = new FileReader()

        reader.onload = function(event) {
            // console.log(reader)
            var dataURIContent = event.target.result
            // var blob = FileFile.dataURItoBlob(dataURIContent)
            resolve(dataURIContent)
        }
        
        if(!element.files[0]) // THINK: is false the right response?
            return reject('No file selected')
            
        if(asDataURI)
            reader.readAsDataURL(element.files[0])
        else
            reader.readAsText(element.files[0])
    })
}

FileFile.dataURItoBlob = function(dataURI) {
    // convert base64/URLEncoded data component to raw binary data held in a Blob
    // via http://stackoverflow.com/questions/4998908/convert-data-uri-to-file-then-append-to-formdata
    var byteString
    
    if (dataURI.split(',')[0].indexOf('base64') >= 0)
        byteString = atob(dataURI.split(',')[1])
    else
        byteString = unescape(dataURI.split(',')[1])

    // separate out the mime component
    var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]

    // write the bytes of the string to a typed array
    var ia = new Uint8Array(byteString.length)
    for (var i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i)
    }

    return new Blob([ia], {type:mimeString})
}

/*
    gridbox: a simple system for putting things in places
*/

Gridbox = {}

Gridbox.getGridCoordBox = function(rows, cols, outerwidth, outerheight, verticalPadding) {
    var min = function(a, b) {return Math.min(a, b)}
    var max = function(a, b) {return Math.max(a, b)}
    var gridwidth  = outerwidth  / cols
    var gridheight = outerheight / rows
    var eq = function(a, b) {return a == b}
    var grid = Array.apply(0, Array(rows))
        .map(function() {return Array.apply(0, Array(cols))
            .map(function() {return 0})}) // build 2D array

    return { get: function() {return grid}
        , set_eq: function(new_eq) {eq = new_eq}
        , add: function(width, height, miny, minx, maxy, maxx, pointer) {
            maxy = min(maxy||rows-height, rows-height), maxx = min(maxx||cols-width, cols-width)
            miny = min(miny||0, maxy), minx = min(minx||0, maxx)
            if(maxx<0 || maxy<0) return EB.onError('Block is too big for the grid')

            top: for(var y = miny; y <= maxy; y++) {
                bot: for(var x = minx; x <= maxx;  x++) {
                    for(var dy = 0; dy < height; dy++) {
                        for(var dx = 0; dx < width; dx++) {
                            if(grid[y+dy][x+dx]) continue bot }}
                    break top }}
            if(x == maxx+1 && y == maxy+1) return EB.onError('No room in the grid')
            if(x == null || y == null) return EB.onError('Block too big for the grid')
            for(var dy = 0; dy < height; dy++) {
                for(var dx = 0; dx < width; dx++) {
                    grid[y+dy][x+dx] = pointer || 1 } }
            return {width: width*gridwidth, height: height*gridheight, x: x*gridwidth, y: y*gridheight+(verticalPadding/1.5)} // THINK: generalize verticalPadding 
        }
    }
}

Gridbox.findNeighbor = function(grid, pointer, dir) {
    var boxCoords = Gridbox.findBoxInGrid(grid, pointer)
    if(!boxCoords) return false

    // TODO: need to indicate if dirBox is outside of grid, versus pointer not found

    var dirBox = Gridbox.makeDirBox(boxCoords, dir)
    if(!dirBox) return false

    return Gridbox.firstThingInBox(grid, dirBox[0], dirBox[1])
}

Gridbox.findBoxInGrid = function(grid, target, eq) {
    /// find something in a grid box and return coords
    /// NOTE: this assumes rectilinear shapes
    eq = eq || function(a, b) {return a === b}
    eq = function(a, b) {return a.sig === b.sig} // TODO: encapsulate eq in gridBox // OPT: don't look inside

    top: for(var y = 0, ly = grid.length; y < ly; y++)
        for(var x = 0, lx = grid[y].length; x < lx; x++)
            if(eq(grid[y][x], target)) break top                        // find top and left coords

    if(y == grid.length && x == grid[0].length) return false            // target not in box

    for(var dy = 0, ly = grid.length-y; dy < ly; dy++)
        if(!eq(grid[y+dy][x], target)) break                            // find bottom coord

    for(var dx = 0, lx = grid[y].length-x; dx < lx; dx++)
        if(!eq(grid[y][x+dx], target)) break                            // find right coord

    return [[x, y], [x+dx-1, y+dy-1]]                                   // minus one because deltas always overshoot
}

Gridbox.firstThingInBox = function(grid, topleft, botright) {
    for(var y = Math.max(topleft[1], 0), ly = Math.min(botright[1], grid.length-1); y <= ly; y++)
        for(var x = Math.max(topleft[0], 0), lx = Math.min(botright[0], grid[0].length-1); x <= lx; x++)
            if(grid[y][x]) return grid[y][x]                            // lteq because our boxes are inclusive;
}                                                                       // boundaries are built in.

Gridbox.makeDirBox = function(boxCoords, dir) {
    var top   = boxCoords[0][1]
    var left  = boxCoords[0][0]
    var bot   = boxCoords[1][1]
    var right = boxCoords[1][0]

    if(dir == 'up')    return [[left, top-1],  [right, top-1]]
    if(dir == 'down')  return [[left, bot+1],  [right, bot+1]]
    if(dir == 'left')  return [[left-1, top],  [left-1, bot]]
    if(dir == 'right') return [[right+1, top], [right+1, bot]]
}

/*
    Timing is everything
*/

~function() {
    var setImmediate, handleMessage
    
    ~function() {
        //// postpone until next tick
        // inspired by http://dbaron.org/log/20100309-faster-timeouts
        var later = []
        var messageName = 12345
        var gimme_a_tick = true

        setImmediate = function(fun) {
            later.push(fun)

            if(gimme_a_tick) {
                gimme_a_tick = false
                window.postMessage(messageName, "*")
            }
        
            return false
        }

        handleMessage = function(event) {
            if(event.data != messageName) return false

            event.stopPropagation()
            gimme_a_tick = true

            var now = later
            later = []

            for(var i=0, l=now.length; i < l; i++)
                now[i]()
        }
    }()

    function queuer() {
        //// do something after some other things
        var queue = []

        var nexttime = function(invoker) {
            invoker(function() {
                if(!queue.length) return false
                queue.shift()()
                nexttime(invoker)
            })
        }

        var queuer = function(invoker, fun) {
            queue.push(fun)
            if(queue.length > 1) return false // THINK: possible race condition
            nexttime(invoker) 
        }

        return queuer
    }

    function once() {
        //// do something later, but only once
        var later = []

        var step = function() {
            var now = later
            later = []
            for(var i=0, l=now.length; i < l; i++)
                now[i]()
        }

        var once = function(invoker, fun) {
            if(~later.indexOf(fun)) return false
            later.push(fun)
            if(later.length > 1) return false // THINK: possible race condition
            invoker(step) 
        }

        return once
    }

    if(typeof window != 'undefined') {
        window.addEventListener('message', handleMessage, true)
        window.setImmediate = setImmediate
        
        window.queueImmediate = queuer().bind(null, setImmediate)
        window.onceImmediate  = once().bind(null, setImmediate)
        window.queueRAF = queuer().bind(null, requestAnimationFrame)
        window.onceRAF  = once().bind(null, requestAnimationFrame)
    
        var timefunbind = {}
        window.onceInAwhile = function(fun, time) {
            //// NOTE: don't use the same fun with different times
            if(timefunbind[fun]) return false
            timefunbind[fun] = setTimeout(function() {fun(); timefunbind[fun] = false}, time)
        }
    }
}()

/*
     ______     __   __   ______     ______     __  __     ______     __     ______  
    /\  ___\   /\ \ / /  /\  ___\   /\  == \   /\ \_\ \   /\  == \   /\ \   /\__  _\ 
    \ \  __\   \ \ \'/   \ \  __\   \ \  __<   \ \____ \  \ \  __<   \ \ \  \/_/\ \/ 
     \ \_____\  \ \__|    \ \_____\  \ \_\ \_\  \/\_____\  \ \_____\  \ \_\    \ \_\ 
      \/_____/   \/_/      \/_____/   \/_/ /_/   \/_____/   \/_____/   \/_/     \/_/ 

    The main interface for the EveryBit platform.

    Most calls to the platform should go through here,
    rather than accessing core systems like EB.Data and EB.Crypto directly.

    In addition to the public-facing API some general helper functions
    are established here for use by the deeper layers.

    Copyright 2014-2015 EveryBit. See README for license information.

*/

if(typeof EB === 'undefined') EB = {}                   // we might load config.js first
if(!EB.CONFIG) EB.CONFIG = {}                           // or we might not

EB.Modules = {}                                         // supplementary extensions live here
EB.M = EB.Modules

EB.version = '0.8.0'


////////////// STANDARD API FUNCTIONS //////////////////

// Note that almost all of the EB.* API functions return a promise, with the exception of EB.formatIdentityFile and EB.loginWithIdentityFile. (The fire-and-forget interface housed in this file is also non-promise-based.)


//// THE FIRE AND FORGET INTERFACE FOR RECEIVING MESSAGES

// The fire-and-forget style interface, where we ask for a puff and either
// - receive it directly if it's in the cache, or
// - receive false, but meanwhile a request is sent
// This can be easier than dealing with promises when e.g. showing cat photos:
// start by showing whichever cats you have in the cache at that moment. 
// When more cats arrive a refresh is triggered and those additional cats are shown too.
// If you return a promise then you'd have to wait for 'all available cats' before resolving it,
// but there's no way to know when the last cat has arrived -- halting problem.


EB.FAF = {}

/**
 * Try to get a puff by its sig from the local cache, or ask the network and return false
 * @param {string}  sig
 * @return {(puff|false)}
 */
EB.FAF.getPuffBySig = function(sig) {
    return EB.Data.getPuffOrNot(sig)
}


/**
 * Get a list of the current identity's currently cached puffs, and ask the network for more
 * @return {[puffs]}
 */
EB.FAF.getMyMessages = function() {
    // get current username
    // ask the network for anything new from or for me
    // return things from caches
}




//// RECEIVE MESSAGES


/**
 * Try to get a particular puff by its signature
 * @param {string}  The signature of a puff
 * @return {promise}
 */
EB.getPuffBySig = function(sig) {
    return EB.Data.getPuffBySig(sig)                    // get a promise for the puff from cache or network
}


//// SEND MESSAGES


/**
 * Send a public message
 * @param {string}    A message string
 * @param {string}    Optional, defaults to 'text'
 * @return {promise}
 */
EB.postPublicMessage = function(content, type) {
    type = type || 'text'
    
    var myUsername = EB.getCurrentUsername()
    if(!myUsername)
        return EB.emptyPromise('You must have a current identity to post a public message')
    
    var puff = EB.Puff.simpleBuild(type, content)
    return Promise.resolve(EB.Data.addPuffToSystem(puff))
}


/**
 * Send a private message
 * @param {string}    A message string
 * @param {array}     A list of usernames
 * @param {string}    Optional, defaults to 'text'
 * @return {promise}
 */
EB.postPrivateMessage = function(content, usernames, type) {
    type = type || 'text'

    var myUsername = EB.getCurrentUsername()
    if(!myUsername)
        return EB.emptyPromise('You must have a current identity to post a private message')
    
    usernames = usernames || []
    if(!Array.isArray(usernames))
        usernames = [usernames]
    
    usernames.push(myUsername)
    usernames = EB.uniquify(usernames)
    var prom = EB.Users.usernamesToUserRecordsPromise(usernames)
    
    return prom.then(function(userRecords) {        
        var puff = EB.Puff.simpleBuild(type, content, null, usernames, userRecords)
        return EB.Data.addPuffToSystem(puff)
    })
    
    return prom
}


/**
 * Send an anonymous private message
 * @param {string}    A message string
 * @param {array}     A list of usernames
 * @param {string}    Optional, defaults to 'text'
 * @return {promise}
 */
EB.postAnonymousPrivateMessage = function(content, usernames, type) {
    return EB.Data.sendAnonModePuff(content, usernames, type, 'anon')
}


/**
 * Send a traceless private message
 * @param {string}    A message string
 * @param {array}     A list of usernames
 * @param {string}    Optional, defaults to 'text'
 * @return {promise}
 */
EB.postTracelessPrivateMessage = function(content, usernames, type) {
    return EB.Data.sendAnonModePuff(content, usernames, type, 'doublyanon')
}


//// IDENTITY AND USER MANAGEMENT


/**
 * Create a new identity
 * @param {string}    new username
 * @param {string}    a string passphrase
 * @return {promise}  userRecord for the newly created user
 */
EB.createIdentity = function(username, passphrase) {
    // TODO: validations and error handling (lots of it)
    
    var prependedPassphrase = username + passphrase
        var privateKey = EB.Crypto.passphraseToPrivateKeyWif(prependedPassphrase)
    
    var prom = EB.registerTopLevelUser(username, privateKey, privateKey, privateKey)
    
    prom.then(function(userRecord) {
        var capa = 1 // THINK: does capa always start at 1? where should that knowledge live?
        EB.addAlias(username, username, capa, privateKey, privateKey, privateKey, {passphrase: passphrase})
        EB.switchIdentityTo(username)
    })
    
    // TODO: on switchIdentityTo false change undefined to ''
    
    return prom
}


/**
 * Register a new top-level user
 * @param {string}     new username
 * @param {string}     new private root key
 * @param {string}     new private admin key
 * @param {string}     new private default key
 * @return {promise}   userRecord for the newly created user
 */
EB.registerTopLevelUser = function(username, privateRootKey, privateAdminKey, privateDefaultKey) {
    // OPT: privateToPublic is expensive -- we could reduce the number of calls if the private keys are identical
    var rootKey    = EB.Crypto.privateToPublic(privateRootKey)
    var adminKey   = EB.Crypto.privateToPublic(privateAdminKey)
    var defaultKey = EB.Crypto.privateToPublic(privateDefaultKey)

    var puff = EB.Puff.buildUserRegistration(username, privateAdminKey, username, rootKey, adminKey, defaultKey)
    var prom = EB.Net.updateUserRecord(puff)
    
    return prom
}


/**
 * Register a subuser for the currently active identity
 * @param  {string}    desired new subuser name
 * @param  {string}    public root key for the new subuser
 * @param  {string}    public admin key for the new subuser
 * @param  {string}    public default key for the new subuser
 * @return {promise}   userRecord for the newly created subuser
 */
EB.registerSubuser = function(newUsername, rootKey, adminKey, defaultKey) {
    var signingUsername = EB.getCurrentUsername()
    var prom
    
    EB.useSecureInfo(function(_, _, _, privateAdminKey, _) {
        prom = EB.Users.registerSubuserForUser(signingUsername, privateAdminKey, newUsername, rootKey, adminKey, defaultKey)
    })
    
    return prom
}


/**
 * Attempts to update a private key for the current user
 * If successful it adds the new alias to the current identity.
 * @param {string}     'defaultKey', 'adminKey', or 'rootKey'
 * @param {string}     the new private key
 * @param {string}     secret information to include in the userRecord
 * @return {promise}   the new userRecord
 */
EB.updatePrivateKey = function(keyToModify, newPrivateKey, secrets) {    
    var username = EB.getCurrentUsername()
    var newPublicKey = EB.Crypto.privateToPublic(newPrivateKey)

    if(['defaultKey', 'adminKey', 'rootKey'].indexOf(keyToModify) == -1)
        return EB.emptyPromise('That is not a valid key to modify')

    var payload = {}
    var routes  = []
    var content = 'modifyUserKey'
    var type    = 'updateUserRecord'

    payload.keyToModify = keyToModify
    payload.newKey = newPublicKey
    payload.time = Date.now()

    var prom = new Promise(function(resolve, reject) {
        var puff                                        // we use this var to return publicly accessible data 

        EB.useSecureInfo(function(_, _, privateRootKey, privateAdminKey, privateDefaultKey) {
            var signingUserKey = 'privateRootKey'       // changing admin or root keys requires root privileges
            var privateKey = privateRootKey

            if (keyToModify == 'defaultKey') { 
                signingUserKey = 'privateAdminKey'      // changing the default key only requires admin privileges
                privateKey = privateAdminKey
            }

            if(!privateKey) {
                return reject(EB.makeError("You need the " + signingUserKey + " to change the " + keyToModify + " key."))
            } else {
                puff = EB.Puff.build(username, privateKey, routes, type, content, payload)
            }
        })

        var userRecordPromise = EB.Net.updateUserRecord(puff)

        userRecordPromise.then(function(userRecord) {
            if(keyToModify == 'defaultKey') {
                EB.useSecureInfo(function(_, username, privateRootKey, privateAdminKey, _) {
                    EB.addAlias(username, username, userRecord.capa, privateRootKey, privateAdminKey, newPrivateKey, secrets)
                })
            }

            if(keyToModify == 'adminKey') {
                EB.useSecureInfo(function(_, username, privateRootKey, _, privateDefaultKey) {
                    EB.addAlias(username, username, userRecord.capa, privateRootKey, newPrivateKey, privateDefaultKey, secrets)
                })
            }

            if(keyToModify == 'rootKey') {
                EB.useSecureInfo(function(_, username, _, privateAdminKey, privateDefaultKey) {
                    EB.addAlias(username, username, userRecord.capa, newPrivateKey, privateAdminKey,  privateDefaultKey, secrets)
                })
            }

            return resolve(userRecord)
        })
        .catch(function(err) {
            return reject(EB.makeError(err))
        })
    })

    return prom
}


/**
 * Try to get a user's profile puff
 * @param {string}  The username
 * @return {promise}
 */
EB.getProfilePuff = function(username) {
    var cached_profile = EB.Data.profiles[username]
    
    if(cached_profile)
        return Promise.resolve(cached_profile)

    var prom = EB.Net.getProfilePuff(username)

    prom = prom.then(function(puffs) {
        var puff = puffs[0]
    
        // NOTE: Setting this prevents us from re-trying to collect profiles from users who don't have them.
        //       This is good, because it prevents network noise, but requires a refresh to see new profile info.
        if(!puff)
            puff = {payload:{}} // TODO: get a proper empty puff from somewhere
        
        EB.Data.profiles[EB.Users.justUsername(puff.username || username)] = puff
    
        return puff
    })

    return prom
}


//// LOGIN & ID FILE MANAGEMENT


/**
 * Make an identity the current one
 * @param {string}   main username for the identity
 * @param {string}   the key for the user's identity file
 * @return {promise}
 */
EB.login = function(username, privateKey) {
    // TODO: handle offline case...
    // TODO: encrypted localStorage identity files
    // TODO: cache encrypted puffs in localStorage
    // TODO: grab the user record from EB.loginWithPassphrase
    
    userprom = EB.Users.getUserRecordNoCache(username)
    
    return userprom.then(function(userRecord) {
        if(!userRecord)
            return EB.onError('Could not access user record')
        
        var identitySig = userRecord.identity
        
        if(identitySig) {
            var decryptprom = EB.Users.getIdentityPuff(userRecord, privateKey)
            
            return decryptprom.then(function(letter) {
                if(letter && letter.payload && letter.payload.content)
                    return EB.loginWithIdentityFile(letter.payload.content)
                else
                    return EB.throwError('Invalid password') // THINK: this could happen for other reasons
            }, function(err) {
                return EB.catchError('Could not access identity file')
            })
        }
        
        // no identity puff, so try it the old fashioned way
        // TODO: move this into a helper function
        var publicKey = EB.Crypto.privateToPublic(privateKey)
        
        if( (userRecord.defaultKey != publicKey) 
         && (userRecord.adminKey   != publicKey) 
         && (userRecord.rootKey    != publicKey) )
            return EB.onError('That user record has no identity file, and the public key provided does not match')
    
        var secrets = {} // {passphrase: passphrase} // THINK: maybe move this up a level to loginWithPassphrase
        EB.addAlias(username, username, userRecord.capa, privateKey, privateKey, privateKey, secrets)

        EB.switchIdentityTo(username)
        
        EB.storeIdentityFileInCloud()
        
        return true
    })
}


/**
 * Takes a canonical identity file object, adds it to the wardrobe, and signs you in
 * @param {object} Identity file
 * @return 
 */
EB.loginWithIdentityFile = function(object) {
    var username = object.username
    var aliases  = object.aliases
    var preferences = object.preferences
    
    if(!username || !aliases || !preferences)
        return EB.onError('That is not a valid identity object')
    
    EB.currentIdentityHash = EB.Crypto.createMessageHash(JSON.stringify(object))
    
    EB.addIdentity(username, aliases, preferences)
    
    return EB.switchIdentityTo(username)
}


/**
 * Try to access the system with a username/passphrase combo
 * @param {string}   Identity's primary username
 * @param {string}   Passphrase to unlock the identity file
 * @param {string}   Used internally
 * @return {promise}
 */
EB.loginWithPassphrase = function(username, passphrase, legacy) {
    // First attempt to prepend username to passphrase
    // If that fails then try just using the passphrase
    var pass = legacy ? passphrase : username + passphrase

    var privateKey = EB.Crypto.passphraseToPrivateKeyWif(pass)
    var publicKey = EB.Crypto.privateToPublic(privateKey)

    var userprom = EB.Users.getUserRecordNoCache(username)

    return userprom.then(function(userRecord) {
        if(!userRecord)
            return EB.onError('Could not access user record')
        
        if( (userRecord.defaultKey != publicKey) 
         && (userRecord.adminKey   != publicKey) 
         && (userRecord.rootKey    != publicKey) )
            return (legacy) ? false : EB.loginWithPassphrase(username, passphrase, true)

        return EB.login(username, privateKey)
    })
}


/**
 * Store the current identity's identity file in the cloud
 * @return {promise}
 */
EB.storeIdentityFileInCloud = function() {
    if(!EB.currentIdentityHash) {
        // THINK: user did not log in with identity file... so what should we do here?
    }

    // get identity file
    var content = EB.formatIdentityFile()
    if(!content) return false
    
    // check against latest
    var newIdentityHash = EB.Crypto.createMessageHash(JSON.stringify(content))
    if(EB.currentIdentityHash == newIdentityHash) return false
    EB.currentIdentityHash = newIdentityHash
    
    // package as encrypted puff
    var payload = {}
    var routes  = []
    var type    = 'identity'
        
    var userRecord = EB.getCurrentUserRecord()
    var userRecordsForWhomToEncrypt = [userRecord]

    if(!userRecord) return false

    // THINK: using simpleBuildPuff puts a timestamp in the identity file...
    var puff = EB.Puff.simpleBuild(type, content, payload, routes, userRecordsForWhomToEncrypt)
    
    if(!puff) return false
        
    // if(puff.sig == userRecord.identity) return false // always false, because of the timestamp -- if you remove it, add this back
    
    EB.Net.distributePuff(puff)                         // send it to the server
    
    // update user record
    var payload = {}                                    // NOTE: the double "var"s don't hurt, and help keep us focused
    var routes  = []
    var type    = 'updateUserRecord'
    var content = 'setIdentity'
    var update_puff

    payload.identity = puff.sig

    EB.useSecureInfo(function(_, currentUsername, _, privateAdminKey, _) {
        if(!privateAdminKey)
            return EB.onError('You must have an administrative key to upload your identity file')
        
        update_puff = EB.Puff.build(currentUsername, privateAdminKey, routes, type, content, payload)
    })
    
    if(!update_puff)
        return false
    
    var update_prom = EB.Net.updateUserRecord(update_puff)
        
    return update_prom
}


/**
 * Try to get an identity file and format it correctly
 * @param {string} Identity's primary username
 * @return {(object|false)}
 */
EB.formatIdentityFile = function(username) {
    // THINK: consider passphrase protecting the identity file by default
    // TODO: add authFromIdFile -- need consistency both ways
    
    username = username || EB.getCurrentUsername()
    
    if(!username) return false

    var idFile = {}

    EB.useSecureInfo(function(identities, currentUsername, privateRootKey, privateAdminKey, privateDefaultKey) {
        // this leaks all of the identity information back to the caller
        // if we passphrase protect the file, do it here to prevent that leakage

        var identity = identities[username]

        // assemble idFile manually to keep everything in the right order
        // idFile.comment = "This file contains your private passphrase. The information here can be used to login to websites on the EveryBit platform. Keep this file safe and secure!"

        idFile.username = username
        // idFile.primary  = identity.primary // NOTE: primary is automatically gathered from aliases
        idFile.aliases  = identity.aliases
        idFile.preferences = identity.preferences
        idFile.version  = "1.1"
    })

    return idFile
}

//// END STANDARD API ////





//// SECURE INFORMATION INTERFACE

EB.implementSecureInterface = function(useSecureInfo, addIdentity, addAlias, setPrimaryAlias, setPreference, switchIdentityTo, removeIdentity) {
    // API cheatsheet:
    // useSecureInfo    = function( function(identities, username, privateRootKey, privateAdminKey, privateDefaultKey) )
    // addIdentity      = function(username, aliases, preferences)
    // addAlias         = function(identityUsername, aliasUsername, capa, privateRootKey, privateAdminKey, privateDefaultKey, secrets)
    // setPrimaryAlias  = function(identityUsername, aliasUsername)
    // removeIdentity   = function(username)
    // setPreference    = function(key, value) // for current identity
    // switchIdentityTo = function(username)

    // THINK: consider ensuring all functions are present first, so it's harder to mix and match wardrobe implementations
    
    if(typeof useSecureInfo == 'function') {
        EB.useSecureInfo = function(callback) {
            // NOTE: useSecureInfo returns true if there is a current identity, and false otherwise
            return useSecureInfo( function(identities, username, privateRootKey, privateAdminKey, privateDefaultKey) {
                var clonedIdentities = JSON.parse(JSON.stringify(identities)) // prevent accidental mutation
                callback(clonedIdentities, username, privateRootKey, privateAdminKey, privateDefaultKey)
            })
        }
    }
    
    if(typeof addIdentity == 'function')
        EB.addIdentity = addIdentity
        
    if(typeof addAlias == 'function')
        EB.addAlias = addAlias
        
    if(typeof setPrimaryAlias == 'function')
        EB.setPrimaryAlias = setPrimaryAlias
        
    if(typeof setPreference == 'function')
        EB.setPreference = setPreference
        
    if(typeof switchIdentityTo == 'function')
        EB.switchIdentityTo = function(username) {
            EB.runHandlers('beforeSwitchIdentity', username)
            var output = switchIdentityTo(username)
            EB.runHandlers('afterSwitchIdentity', username)
            return output
        }
        
    if(typeof removeIdentity == 'function')
        EB.removeIdentity = removeIdentity
        
    EB.getCurrentUsername = function() {
        // NOTE: we're using the output var to leak information out of useSecureInfo. be careful with this technique.
        var output
        EB.useSecureInfo(function(identities, username) { output = username })
        return output
    }
    
    EB.getCurrentCapa = function() {
        var output
        EB.useSecureInfo(function(identities, username) { output = ((identities[username]||{}).primary||{}).capa||0 })
        return output
    }
    
    EB.getCurrentVersionedUsername = function() {
        var username = EB.getCurrentUsername()
        if(!username)
            return EB.onError('No current user in wardrobe')
        
        return EB.Users.makeVersioned(username, EB.getCurrentCapa())
    }
    
    EB.getCurrentUserRecord = function() {
        var versionedUsername = EB.getCurrentVersionedUsername()
        if(!versionedUsername)
            return false
        
        // THINK: it's weird to hit the cache directly from here, but if we don't then we always get a promise,
        //        even if we hit the cache, and this should return a proper userRecord, not a promise, 
        //        since after all we have stored the userRecord in our wardrobe, haven't we?
    
        var userRecord = EB.Users.records[versionedUsername]
        if(!userRecord)
            return EB.onError('That user does not exist in our records')
    
        return userRecord
    }

    EB.getAllIdentityUsernames = function() {
        var output
        EB.useSecureInfo(function(identities, username) { output = Object.keys(identities) })
        return output
    }
    
}


//// INITIALIZATION

EB.init = function(options) {
    //// initializes all available modules and the platform subsystems.
    //// options is an object of configuration options that is passed to each module and subsystem.
    
    // BEGIN CONFIG AND OPTIONS //
    
    options = options || {}
    
    setDefault('zone', '')
    setDefault('puffApi', 'https://i.cx/api/puffs/api.php')
    setDefault('userApi', 'https://i.cx/api/users/api.php')
    setDefault('eventsApi', 'https://i.cx/api/puffs/api.php')
    setDefault('enableP2P', false)
    setDefault('pageBatchSize', 10)
    setDefault('initLoadGiveup', 200)
    setDefault('networkTimeout', 20000)         // twenty second timeout
    setDefault('noLocalStorage', false)
    setDefault('netblockSuffix', 'local')
    setDefault('cryptoworkerURL', '')           // point to cryptoworker.js to enable worker thread
    setDefault('ephemeralKeychain', false)      // prevents keychain from being saved to localStorage
    setDefault('initLoadBatchSize', 20)
    setDefault('inMemoryShellLimit', 10000)     // shells are removed to compensate
    setDefault('globalBigBatchLimit', 2000)     // maximum number of shells to receive at once // TODO: align with API
    setDefault('inMemoryMemoryLimit', 300E6)    // ~300MB
    setDefault('anonPrivateAdminKey', '5KdVjQwjhMchrZudFVfeRiiPMdrN6rc4CouNh7KPZmh8iHEiWMx') // for registering anon users
    setDefault('disableSendToServer', false)    // so you can work locally
    setDefault('disableReceivePublic', false)   // no public puffs except profiles
    setDefault('disableCloudIdentity', false)   // don't store encrypted identity in the cloud
    setDefault('supportedContentTypes', false)  // whitelist of context types; false loads all
    setDefault('shellContentThreshold', 1000)   // size of uncompacted content
    setDefault('localStorageShellLimit', 1000)  // maximum number of shells
    setDefault('localStorageMemoryLimit', 3E6)  // ~3MB
    
    function setDefault(key, val) {
        EB.CONFIG[key] = options[key] || EB.CONFIG[key] || val
    }
    
    // END CONFIG AND OPTIONS //
        
    EB.Users.init(options)                              // initialize the user record subsystem
    EB.Data.init(options)                               // initialize the data subsystem
    EB.Net.init(options)                                // initialize the network subsystem
    
    var moduleKeys = Object.keys(EB.M)
    moduleKeys.forEach(function(key) {                  // call all module initializers
        if(EB.M[key].init) 
            EB.M[key].init(options)
    })
    
    popMods()                                           // deflate any machine prefs
    function popMods() {                                // THINK: maybe move this to EB.Persist.init
        var mods = EB.Persist.get('CONFIG')
        if(!mods) return false
    
        EB.CONFIG.mods = mods
        Object.keys(EB.CONFIG.mods).forEach(function(key) { EB.CONFIG[key] = mods[key] })
    }
    
    EB.buildCryptoworker(options)
}


////////////// END STANDARD API //////////////////



////////////// HANDLER HANDLERS //////////////////

EB.handlers = {}

EB.addHandler = function(type, callback) {
  if(!EB.handlers[type]) EB.handlers[type] = []
  EB.handlers[type].push(callback)
}

EB.runHandlers = function(type) {
  var args = [].slice.call(arguments, 1)
  return (EB.handlers[type] || []).reduce(
      function(acc, callback) {
          return callback.apply(null, acc == null ? args : Array.isArray(acc) ? acc : [acc])}, args)
}

EB.makeHandlerHandler = function(type) {
    return function(callback) {return EB.addHandler(type, callback)}
}

// USEFUL HANDLERS:

EB.addErrorHandler           = EB.makeHandlerHandler('error')           // receives all error messages

EB.addNewPuffHandler         = EB.makeHandlerHandler('newPuffs')        // called when new puffs are available

EB.addDHTErrorHandler        = EB.makeHandlerHandler('DHTError')        // receives DHT error messages

EB.addRelationshipHandler    = EB.makeHandlerHandler('relationship')    // manage relationships between puffs

EB.addTimeoutErrorHandler    = EB.makeHandlerHandler('timeoutError')    // receives timeout error messages

EB.addNetworkErrorHandler    = EB.makeHandlerHandler('networkError')    // receives network error messages

EB.addNewPuffReportHandler   = EB.makeHandlerHandler('newPuffReport')   // handles reports on incoming puffs

EB.addIdentityUpdateHandler  = EB.makeHandlerHandler('identityUpdate')  // general GUI update trigger

EB.addNetworkResponseHandler = EB.makeHandlerHandler('networkresponse') // receives all network response

EB.addPayloadModifierHandler = EB.makeHandlerHandler('payloadModifier') // decorate puff payloads 

// EB.addClearPuffCacheHandler = EB.makeHandlerHandler('clearpuffcache')

// beforeSwitchIdentity is called prior to switchIdentity and removeIdentity, while the old identity is active
// afterSwitchIdentity  is called after switchIdentity, once the new identity is active
EB.addBeforeSwitchIdentityHandler = EB.makeHandlerHandler('beforeSwitchIdentity')
EB.addAfterSwitchIdentityHandler  = EB.makeHandlerHandler('afterSwitchIdentity')

////////////// END HANDLER HANDLERS //////////////




//// PUFF HELPERS ////

EB.decryptPuffForReals = function(envelope, yourPublicWif, myVersionedUsername, myPrivateWif) {
    //// interface with EB.Crypto for decrypting a message
    // TODO: this should be in EB.Data, but is in EB for cryptoworker's sake
    if(!envelope.keys) return false
    var keyForMe = envelope.keys[myVersionedUsername]
    var puffkey  = EB.Crypto.decryptPrivateMessage(keyForMe, yourPublicWif, myPrivateWif)
    var letterCipher = envelope.payload.content
    var letterString = EB.Crypto.decryptWithAES(letterCipher, puffkey)
    var betterString = EB.tryDecodeURIComponent(escape(letterString))   // try decoding
    return EB.parseJSON(betterString)                                   // try parsing
}

//// END PUFF HELPERS ////






//// BUILD CRYPTO WORKER ////

EB.buildCryptoworker = function(options) {
    var cryptoworkerURL = options.cryptoworkerURL || EB.CONFIG.cryptoworkerURL // || 'cryptoworker.js'
    
    if(!cryptoworkerURL) return false
    
    EB.cryptoworker = new Worker(cryptoworkerURL)
    EB.cryptoworker.addEventListener("message", EB.workerreceive)
}

EB.workerqueue = []
EB.workerautoid = 0

EB.workerreceive = function(msg) {
    var id = msg.data.id
    if(!id) return false // TODO: add onError here

    var fun = EB.workerqueue[id]
    if(!fun) return false // TODO: add onError here

    fun(msg.data.evaluated)

    delete EB.workerqueue[id] // THINK: this leaves a sparse array, but is probably faster than splicing
}

EB.workersend = function(funstr, args, resolve, reject) {
    EB.workerautoid += 1
    EB.workerqueue[EB.workerautoid] = resolve
    if(!Array.isArray(args))
        args = [args]
    EB.cryptoworker.postMessage({fun: funstr, args: args, id: EB.workerautoid})
}

//// END BUILD CRYPTO WORKER ////




//// ERROR HELPERS

// TODO: build a more general error handling system for GUI integration

EB.onError = function(msg, obj, trigger) {
    //// override this for custom error behavior
    
    var composite = {msg: msg, obj: obj}

    EB.runHandlers('error', composite)
    
    if(trigger)
        EB.runHandlers(trigger, composite)
        
    // for debugging help, run this in the console:
    // EB.addErrorHandler(function(composite) {console.log(composite)})

    return false
}

EB.catchError = function(msg) {
    //// ex: prom.catch( EB.catchError('invalid foo') ).then(function(foo) {...})
    return function(err) {
        EB.onError(msg, err)
        throw err
    }
}

EB.throwError = function(msg, errmsg) {
    //// ex: prom.then(function(foo) {if(!foo) EB.throwError('no foo'); ...})
    var err = errmsg ? Error(errmsg) : ''
    throw EB.makeError(msg, err)
}

EB.makeError = function(msg, err, trigger) {
    //// ex: new Promise(function(resolve, reject) { if(!foo) reject( EB.makeError('no foo') ) ... })
    EB.onError(msg, err, trigger)
    return Error(msg)
}

EB.emptyPromise = function(msg) {
    //// ex: function(foo) { if(!foo) return EB.emptyPromise('no foo'); return getFooPromise(foo) }
    if(msg) EB.onError(msg)
    return Promise.reject(msg)
}

EB.throwNetError = function(msg, errmsg) {
    //// like throw error but triggers the networkError handler
    var trigger = 'networkError'
    var err = errmsg ? Error(errmsg) : ''
    throw EB.makeError(msg, err, trigger)
}

EB.throwDHTError = function(msg, errmsg) {
    //// like throw error but triggers the DHTError handler
    var trigger = 'DHTError'
    var err = errmsg ? Error(errmsg) : ''
    throw EB.makeError(msg, err, trigger)
}


//// Exceptional API wrappers

EB.parseJSON = function(str) {
    //// JSON.parse throws, so we catch it. throw/catch borks the JS VM optimizer, so we box it.
    try {
        return JSON.parse(str)
    } catch(err) {
        return EB.onError('Invalid JSON string', err)
    }
}

EB.stringifyJSON = function(obj) {
    //// JSON.stringify throws on dumb DOM objects, so we catch it. throw/catch borks the JS VM optimizer, so we box it.
    try {
        return JSON.stringify(obj)
    } catch(err) {
        return EB.onError('Invalid object', err)
    }
}

EB.tryDecodeURIComponent = function(str) {
    //// decodeURIComponent throws, so we wrap it. try/catch kills the optimizer, so we isolate it.
    try {
        return decodeURIComponent(str)
    } catch(err) {
        return EB.onError('Invalid URI string', err)
    }
}


//// something different

EB.promisesPending = {}

// Major jujitsu here
EB.promiseMemoize = function(fun, ohboy) {
    if(!ohboy) ohboy = EB.removePromisePending
    
    return function() {
        var key = JSON.stringify([fun.toString(),arguments])
        
        if(EB.promisesPending[key])
            return EB.promisesPending[key]
        
        var prom = fun.apply(fun, arguments)
        prom = prom.then(function(value) {
            ohboy(key, value)
            return value                                        // deliver successes
        }, function(value) {
            ohboy(key, value)
            throw value                                         // propagate failures
        })
        
        EB.promisesPending[key] = prom
        return prom
    }
}

EB.removePromisePending = function(key) {
    delete EB.promisesPending[key]
}


////////////// A few small helpers for building functional pipelines ///////////////

EB.prop = function(p, obj) { // THINK: consider importing all of Rambda.js
    return arguments.length < 2 ? function (obj) { return obj[p]; } : obj[p]
}

EB.uniquify = function(list) {
    return list.filter(EB.unique)
}

EB.unique = function(item, index, array) {return array.indexOf(item) == index}

/*

    Cryptographic management for the EveryBit platform.

    Contains various functions that rely on bitcoin-lib.js for their cryptographic functionality,
    an ECDH implementation, a random number shim for older browsers, and random helper functions.

    Copyright 2014-2015 EveryBit. See README for license information.

*/

EB.Crypto = {};

/**
 * Generate private key
 * @return {string} 
 */
EB.Crypto.generatePrivateKey = function() {
    // OPT: remove this test once Bitcoin.ECKey no longer generates invalid keys (about 1 in 1,000 right now)
    var prikey = new Bitcoin.ECKey().toWif()
    if(EB.Crypto.wifToPriKey(prikey))
        return prikey
    else
        return EB.Crypto.generatePrivateKey()  // THINK: this could generate an eternal error explosion
}


/**
 * Convert public key from private key
 * @param  {string} privateKeyWIF
 * @return {string}
 */
EB.Crypto.privateToPublic = function(privateKeyWIF) {
    // TODO: This should return false if string is empty
    if(!privateKeyWIF)
        return EB.onError('That private key contained no data')
        
    try {
        return EB.Crypto.wifToPriKey(privateKeyWIF).getPub(true).toWif()
    } catch(err) {
        return EB.onError('Invalid private key: could not convert to public key', [privateKeyWIF, err])
    }
}


/**
 * Sign the hash of some data with a private key and return the sig in base 58
 * @param  {object} unsignedPuff
 * @param  {string} privateKeyWIF
 * @return {(boolean|error)}
 */
EB.Crypto.signPuff = function(unsignedPuff, privateKeyWIF) {
    //// sign the hash of some data with a private key and return the sig in base 58

    var prikey = EB.Crypto.wifToPriKey(privateKeyWIF)
    var message = EB.Crypto.puffToSiglessString(unsignedPuff)
    var messageHash = EB.Crypto.createMessageHash(message)
    
    try {
        return Bitcoin.base58.encode(prikey.sign(messageHash))
    } catch(err) {
        return EB.onError('Could not properly encode signature', [prikey, messageHash, err])
    }
}


/**
 * to verify puff sig
 * @param  {object} puff
 * @param  {string} defaultKey
 * @return {boolean}
 */
EB.Crypto.verifyPuffSig = function(puff, defaultKey) {
    var puffString = EB.Crypto.puffToSiglessString(puff);
    return EB.Crypto.verifyMessage(puffString, puff.sig, defaultKey);
}


/**
 * accept a base 58 sig, a message (must be a string) and a base 58 public key. returns true if they match, false otherwise
 * @param  {string} message
 * @param  {string} sig
 * @param  {string} publicKeyWIF
 * @return {boolean}
 */
EB.Crypto.verifyMessage = function(message, sig, publicKeyWIF) {
    //// accept a base 58 sig, a message (must be a string) and a base 58 public key. returns true if they match, false otherwise
  
    try {
        var pubkey = EB.Crypto.wifToPubKey(publicKeyWIF)
        
        var sigBytes = Bitcoin.base58.decode(sig).toJSON()
        sigBytes = sigBytes.data || sigBytes
        
        var messageHash = EB.Crypto.createMessageHash(message)
        
        return pubkey.verify(messageHash, sigBytes)
    } catch(err) {
        return EB.onError('Invalid key or sig: could not verify message', [messageHash, sig, publicKeyWIF, err])
    }
}


/**
 * to create message hash
 * @param  {string} message
 * @return {string}
 */
EB.Crypto.createMessageHash = function(message) {
    return Bitcoin.Crypto.SHA256(message).toString()
}


/**
 * crypt wif to private key
 * @param  {string} privateKeyWIF
 * @return {boolean}
 */
EB.Crypto.wifToPriKey = function(privateKeyWIF) {
    if(!privateKeyWIF)
        return EB.onError('That private key wif contains no data')

    try {
        return new Bitcoin.ECKey(privateKeyWIF, true)
    } catch(err) {
        return EB.onError('Invalid private key: are you sure it is properly WIFfed?', [privateKeyWIF, err])
    }
}

/**
 * crypt wif to public try
 * @param  {string} publicKeyWIF
 * @return {boolean}
 */
EB.Crypto.wifToPubKey = function(publicKeyWIF) {
    if(!publicKeyWIF)
        return EB.onError('That public key wif contains no data')

    try {
        var pubkeyBytes = Bitcoin.base58check.decode(publicKeyWIF).payload.toJSON()
        pubkeyBytes = pubkeyBytes.data || pubkeyBytes
        return new Bitcoin.ECPubKey(pubkeyBytes, true)
    } catch(err) {
        return EB.onError('Invalid public key: are you sure it is properly WIFfed?', [publicKeyWIF, err])
    }
}


/**
 * crypt puff to string without sig
 * @param  {object} puff
 * @return {string}
 */
EB.Crypto.puffToSiglessString = function(puff) {
    return JSON.stringify(puff, function(key, value) {if(key == 'sig') return undefined; return value})
}


/**
 * Convert a passphrase to a private key
 * @param  {string} passphrase
 * @return {string} private key WIF
 */
EB.Crypto.passphraseToPrivateKeyWif = function(passphrase) {
    var hashStr = Bitcoin.Crypto.SHA256(passphrase).toString()
    var hash = Bitcoin.convert.hexToBytes(hashStr)
    return Bitcoin.ECKey(hash).toWif()
}


/**
 * Encrypt a string with AES
 * @param  {string} message
 * @param  {string} key
 * @return {string}
 */
EB.Crypto.encryptWithAES = function(message, key) {
    if(typeof message != 'string')
        return EB.onError('The message to encryptWithAES must be a string')
    if(typeof key != 'string')
        return EB.onError('The key to encryptWithAES must be a string')
        
    var enc = Bitcoin.Crypto.AES.encrypt(message, key)
    return Bitcoin.Crypto.format.OpenSSL.stringify(enc)
}


/**
 * Decrypt a string with AES
 * @param  {string} ciphertext
 * @param  {string} key
 * @return {string}
 */
EB.Crypto.decryptWithAES = function(ciphertext, key) {
    if(!key || !ciphertext) return false

    if(typeof ciphertext != 'string')
        return EB.onError('The ciphertext to decryptWithAES must be a string')
    if(typeof key != 'string')
        return EB.onError('The key to decryptWithAES must be a string')

    var message = Bitcoin.Crypto.format.OpenSSL.parse(ciphertext)
    var words = Bitcoin.Crypto.AES.decrypt(message, key)
    var bytes = Bitcoin.convert.wordsToBytes(words.words) 
    // var uglyRegex = /[\u0002\u0004\u0007\u000e]+$/g
    var uglyRegex = /[\u0000-\u0010]+$/g // TODO: contain AES padding
    return bytes.map(function(x) {return String.fromCharCode(x)}).join('').replace(uglyRegex, '')
}


/**
 * Get the shared secret of two users
 * @param  {string} yourPublicWif
 * @param  {string} myPrivateWif
 * @return {string}
 */
EB.Crypto.getOurSharedSecret = function(yourPublicWif, myPrivateWif) {
    // TODO: unit testing for ECDH maths
    var pubkey = EB.Crypto.wifToPubKey(yourPublicWif)
    var prikey = EB.Crypto.wifToPriKey(myPrivateWif)
    if(!pubkey || !prikey) return false  
    var secret = pubkey.multiply(prikey).toWif()
    var key = Bitcoin.Crypto.SHA256(secret).toString()
    
    return key
}


/**
 * Encrypt a private message
 * @param  {string} plaintext
 * @param  {string} yourPublicWif
 * @param  {string} myPrivateWif
 * @return {string}
 */
EB.Crypto.encryptPrivateMessage = function(plaintext, yourPublicWif, myPrivateWif) {
    var key = EB.Crypto.getOurSharedSecret(yourPublicWif, myPrivateWif)
    if(!key) return false
    var ciphertext = EB.Crypto.encryptWithAES(plaintext, key)
    return ciphertext
}


/**
 * Decrypt a private message
 * @param  {string} plaintext
 * @param  {string} yourPublicWif
 * @param  {string} myPrivateWif
 * @return {string}
 */
EB.Crypto.decryptPrivateMessage = function(ciphertext, yourPublicWif, myPrivateWif) {
    var key = EB.Crypto.getOurSharedSecret(yourPublicWif, myPrivateWif)
    if(!key || !ciphertext) return false
    var plaintext = EB.Crypto.decryptWithAES(ciphertext, key)
    return plaintext // .replace(/\n+$/g, '')
}


/**
 * Get the 'keys' object for a private puff
 * @param  {string} puffkey
 * @param  {string} myPrivateWif
 * @param  {object} userRecords
 * @return {object}
 */
EB.Crypto.createKeyPairs = function(puffkey, myPrivateWif, userRecords) {
    if(!Array.isArray(userRecords))
        return EB.throwError('Invalid userRecords')
    
    return userRecords.reduce(function(acc, userRecord) {
        var versionedUsername = EB.Users.userRecordToVersionedUsername(userRecord)
        acc[versionedUsername] = EB.Crypto.encryptPrivateMessage(puffkey, userRecord.defaultKey, myPrivateWif)
        return acc
    }, {})
}


// EB.Crypto.verifyBlock = function(block, publicKeyBase58) {
//     return EB.Crypto.verifyMessage(block.blockPayload, block.blockSig.replace(/\*/g, ""), publicKeyBase58);
// }

// EB.Crypto.signBlock = function(blockPayload, privateKeyWIF) {
//     return EB.Crypto.signPayload(blockPayload, privateKeyWIF);
// }



//// Randomness enhancements



/**
 * Get a random number between 0 and 1
 * @return {number}
 */
EB.Crypto.random = function() { 
    // just like Math.random, but better
    // via http://stackoverflow.com/questions/13694626/generating-random-numbers-0-to-1-with-crypto-generatevalues

    var list = EB.Crypto.getRandomValues(2, 32)

    // keep all 32 bits of the the first, top 20 of the second for 52 random bits
    var mantissa = (list[0] * Math.pow(2,20)) + (list[1] >> 12)

    // shift all 52 bits to the right of the decimal point
    var result = mantissa * Math.pow(2,-52)
    
    return result
    
    // var log2 = Math.log(max) / Math.LN2
    // var size = Math.ceil(log2) + 1 // NOTE: this is about 8 times higher than necessary
}


/**
 * Get a random integer
 * @param  {number} Maximum integer. Defaults to 2^31 - 1, the largest bitop safe integer.
 * @param  {number} Minimum integer. Defaults to 0.
 * @return {number}
 */
EB.Crypto.getRandomInteger = function(max, min) { 
    // NOTE: min is inclusive, max is exclusive
    // TODO: error if max and min are not proper (non-NaN) numbers
    min = Math.floor(min || 0)
    max = Math.floor(max || 0x7fffffff) // 0x7fffffff == Math.pow(2, 31) - 1, the largest bitop safe int
    var range = max - min
    var randFloat = EB.Crypto.random()
    return Math.floor(randFloat*range + min)
}


/**
 * Get a random item from a list
 * @param  {(array|string)} An array or string from which to choose an element
 * @return {any} 
 */
EB.Crypto.getRandomItem = function(list) {
    // TODO: error if list is not an array or string
    var index = EB.Crypto.getRandomInteger(list.length)
    return list[index]
}


/**
 * Get a new AES key
 * @param  {number} len Length in bytes (defaults to 256 bits)
 * @return {string} AES key
 */
EB.Crypto.getRandomKey = function(len) {
    len = len || 256/8                                      // AES key size is 256 bits
    var bytes = EB.Crypto.getRandomValues(len, 8)
    // var bytes = new Uint8Array(size)
    // crypto.getRandomValues(bytes)
    return Bitcoin.convert.bytesToBase64(bytes)
}


/**
 * A wrapper for crypto.getRandomValues
 * @param  {number} Number of samples 
 * @param  {number} Size of samples in bits (32 or 8, defaults to 8)
 * @return {array}
 */
EB.Crypto.getRandomValues = function(number, size) {
    if(window.crypto && window.crypto.getRandomValues) {
        var bytes
        if(size == 32)
            bytes = new Uint32Array(number)
        else
            bytes = new Uint8Array(number)
    
        return window.crypto.getRandomValues(bytes)
    }

    return EB.Crypto.getRandomValuesShim(number, size)
}


/**
 * A shim for crypto.getRandomValues
 * @param  {number} Number of samples 
 * @param  {number} Size of samples in bits (32 or 8, defaults to 8)
 * @return {array}
 */
EB.Crypto.getRandomValuesShim = function(number, size) {
    // via https://github.com/evanvosberg/crypto-js/issues/7
    // fallback for old browsers that don't support crypto.getRandomValues
    // better than plain Math.random(), worse than crypto.getRandomValues()
    var words = [];

    var r = (function (m_w) {
        var m_w = m_w;
        var m_z = 0x3ade68b1;
        var mask = 0xffffffff;

        return function () {
            m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
            m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
            var result = ((m_z << 0x10) + m_w) & mask;
            result /= 0x100000000;
            result += 0.5;
            return result * (Math.random() > .5 ? 1 : -1);
        }
    });

    for (var i = 0, rcache; i < number; i += 4) {
        var _r = r((rcache || Math.random()) * 0x100000000);

        rcache = _r() * 0x3ade67b7;

        if(size == 32) {
            words.push(Math.abs( (_r() * 0x100000000) | 0 ));
        } else {
            // in case we want bytes instead of 32-bit chunks
            var int32 = (_r() * 0x100000000) | 0;
            words.push(Math.abs(int32 & 0xFF000000) >> 24);
            words.push(Math.abs(int32 & 0x00FF0000) >> 16);
            words.push(Math.abs(int32 & 0x0000FF00) >> 8);
            words.push(Math.abs(int32 & 0x000000FF));
        }
    }

    return words;
}
/*

    Data management for the EveryBit platform.
    
    All puff-related data flows through here:
    caching, persistence, optimizations and network access are managed through this module.

    Copyright 2014-2015 EveryBit. See README for license information.

 */

EB.Data = {}
EB.Data.bonii = {}
EB.Data.shells = []
EB.Data.shellSort = {}
EB.Data.pendingPuffPromises = {}

EB.Data.profiles = {}

EB.Data.init = function(options) {
    // THINK: disabling preloading may affect older EB example code
    // if(!options.disablePublicPuffs)
    //     EB.Data.importShells()                                       // preload relevant shells
    EB.addBeforeSwitchIdentityHandler(EB.Data.removeAllPrivateShells)   // clear private caches on id change
}


///////////////// new graph stuff ////////////////////

EB.Data.addSigAsVertex = function(sig) {
    var matches = EB.Data.graph.v(sig).run()
    
    if(matches.length) return false         // returns false if nothing happens
    
    return EB.Data.graph.addVertex({_id: sig, name: sig, type: 'shell'}) || true
}

EB.Data.addShellAsVertex = function(shell) {
    var matches = EB.Data.graph.v(shell.sig).run()
    
    if(!matches.length)
        return EB.Data.graph.addVertex({ _id: shell.sig, name: shell.sig, shell: shell, type: 'shell' }) || true
    
    var vertex = matches[0]
    if(vertex.shell) return false           // NOTE: returns false if it does nothing
    
    return vertex.shell = shell             // NOTE: mutation & pointer setting
}

EB.Data.addShellUsernameAsVertex = function(shell) {
    //// add shell.username to graph and connect them up
    
    var username = shell.username
    var matches = EB.Data.graph.v(username).run()
    var vertex = matches[0]
    
    if(!vertex)                             // THINK: make usernames unique like USERNAME::<username> or something
        vertex = EB.Data.graph.addVertex({ _id: username, name: username, type: 'username' })
    else
        if(EB.Data.graph.v(shell.sig).out('author').property('name').run()[0] == username)
            return false
        
    // TODO: add easy filtering by vertex type for both 'v' and also outV etc
    EB.Data.graph.addEdge({ _out: shell.sig, _in: shell.username, _label: 'author'})
}

EB.Data.graph = Dagoba.graph()

EB.Data.addToGraph = function(shells) {
    shells.forEach(EB.Data.addShellAsVertex)
    shells.forEach(EB.Data.addShellUsernameAsVertex)
    EB.runHandlers('relationship', shells)
}

// TODO: alias children() as .in('parent') and parents() as .out('parent') and use those instead (halves # of edges)

///////////////// end new graph stuff ////////////////////


//// CONTENT TYPES ////

EB.Data.contentTypes = {}

// TODO: this might get big, need some GC here
EB.Data.puffContentStash = {}

EB.Data.clearPuffContentStash = function() {
    EB.Data.puffContentStash = {}
}


/**
 * to process the content
 * @param  {string} type
 * @param  {string} content
 * @param  {puff} puff
 * @return {string}
 */
EB.Data.processContent = function(type, content, puff) {
    var typeObj = EB.Data.contentTypes[type]
    
    if(!typeObj)
        typeObj = EB.Data.contentTypes['text']

    return typeObj.toHtml(content, puff)
}


/**
 * Get the content of a puff
 * @param  {puff} puff
 * @return {string}
 */
EB.Data.getProcessedPuffContent = function(puff) {
    // THINK: we've already ensured these are proper puffs, so we don't have to check for payload... right?
    if(EB.Data.puffContentStash[puff.sig])
        return EB.Data.puffContentStash[puff.sig]
    
    var content = EB.Data.processContent(puff.payload.type, puff.payload.content, puff)
    EB.Data.puffContentStash[puff.sig] = content
    
    return content
}

/**
 * Add support for types of content to the system
 * @param {string} name
 * @param {string} type
 */
EB.Data.addContentType = function(name, type) {
    // THINK: move this down into EB?
    
    if(!name) 
        return EB.onError('Invalid content type name')
    if(EB.CONFIG.supportedContentTypes && EB.CONFIG.supportedContentTypes.indexOf(name) == -1)
        return EB.onError('Unsupported content type: ' + name)
    if(!type.toHtml) 
        return EB.onError('Invalid content type: object is missing toHtml method', name)
    
    EB.Data.contentTypes[name] = type
}

//// END CONTENT TYPES ////




EB.Data.getAllMyShells = function() {
    var publicShells = EB.Data.getPublicShells()
    var privateShells = EB.Data.getCurrentDecryptedLetters()
    return publicShells.concat(privateShells)
}


/**
 * get all currently known shells
 * @return {Shell[]}
 */
EB.Data.getShells = function() {
    //// Get all currently known shells
    // NOTE: always use this accessor instead of referencing EB.Data.shells directly, as what this function does will change.
    return EB.Data.shells
}

/**
 * get all public shells
 * @returns {Shell[]}
 */
EB.Data.getPublicShells = function() {
    //// Get all public shells
    var shells = EB.Data.getShells()
    return shells.filter(function(shell) {return !shell.keys})
}

/**
 * Get cached shells by sig
 * @param {string} sig
 * @returns {shell[]}
 */
EB.Data.getCachedShellBySig = function(sig) {
    return EB.Data.shellSort[sig]
    // return EB.Data.getShells().filter(function(shell) { return sig === shell.sig })[0]
}

/**
 * adds bonus
 * @param {object} puff
 * @param {string} key
 * @param {string} value
 */
EB.Data.addBonus = function(puff, key, value) {
    //// this simulates a WeakMap
    // THINK: we'll need to provide some GC here
    var id = puff.sig
    
    if(!EB.Data.bonii[id])
        EB.Data.bonii[id] = {}
    
    EB.Data.bonii[id][key] = value
}

/**
 * gets bonus
 * @param puff
 * @param key
 * @returns {object}
 */
EB.Data.getBonus = function(puff, key) {
    //// pull from our FauxWeakMap
    var id = puff.sig
    var puffBonii = EB.Data.bonii[id]
    return puffBonii && puffBonii[key]
}








EB.Data.addStar = function(sig, username, starsig) {
    // TODO: consider moving this to a module
    
    var fauxshell = {sig: sig} // THINK: can we formalize this?
    var starStats = EB.Data.getBonus(fauxshell, 'starStats') || {score: 0, from: {}}
    
    starStats.from[username] = starsig                                  // admittedly strange, but helpful when unstarring
    starStats.score = EB.Data.scoreStars(Object.keys(starStats.from))  // OPT: O(n^2) in stars-per-puff
    
    EB.Data.addBonus(fauxshell, 'starStats', starStats)
}

EB.Data.removeStar = function(sig, username) {
    // TODO: consider moving this to a module
    
    var fauxshell = {sig: sig} // THINK: ye gads is this ugly
    var starStats = EB.Data.getBonus(fauxshell, 'starStats') || {score: 0, from: {}}
    
    delete starStats.from[username]
    
    starStats.score = EB.Data.scoreStars(Object.keys(starStats.from))  // OPT: O(n^2) in stars-per-puff
    
    EB.Data.addBonus(fauxshell, 'starStats', starStats)
}

EB.Data.scoreStars = function(usernames) {
    
    return 0
    
    // TODO: move this into a module
    /*
    var tluScore = 0;
    var suScore = 0;
    var scorePref = Boron.shallow_copy(puffworldprops.view.score);
    for (var k in scorePref) {
        if (scorePref[k]) {
            var s = parseFloat(scorePref[k]);
            if (isNaN(s))
                s = parseFloat(puffworlddefaults.view.score[k]);
            scorePref[k] = s;
        }
    }
    
    usernames.forEach(function(username) {
        if (username.indexOf('.') == -1) {
            tluScore += scorePref.tluValue;
        } else {
            suScore += scorePref.suValue;
        }
    })
    
    var score = tluScore + Math.min(scorePref.maxSuValue, suScore);
    score = score.toFixed(1);
    if (score == parseInt(score)) score = parseInt(score);
    return score
    */
}


/**
 * handle a newly created puff: add to our local cache and fire new content callbacks
 * @param {object} puff
 */
EB.Data.addPuffToSystem = function(puff) {
    if(EB.Data.getCachedShellBySig(puff.sig)) return false
    
    EB.Data.addShellsThenMakeAvailable(puff)

    EB.Net.distributePuff(puff)
    
    return puff
}








/*
    Some new shell handling equipment. Need to integrate this more deeply and clean and test.
*/

EB.Data.addShellsThenMakeAvailable = function(shells) {
    //// adds shells to the system, then returns a report on its progress
    
    // report.delivered: 10
    // report.valid: 8
    // report.new_shells: 7
    // report.new_puffs: 5
    // report.GC: 0
    
    // report.public: 2
    // report.stars: 0
    
    // report.private_promise: {sigs:[], failed: }
    
    // report.public_puff_sigs: []
    
    function not(fun) {return function(x) {return !fun(x)}}
    
    var report = {counts: {}}
    
    shells = Array.isArray(shells) ? shells : [shells]
    report.counts.delivered = shells.length
    
    shells = shells.filter(EB.Spec.isValidShell)
    report.counts.valid = shells.length
    
    report.meta = EB.Data.handleMetaPuffs(shells)
    
    shells = shells.filter(not(EB.Data.isMetaPuff))
    report.counts.nonmeta = shells.length
    
    report.private_promise = EB.Data.handlePrivatePuffs(shells)
    
    shells = shells.filter(not(EB.Puff.isPrivate))
    report.counts.public = shells.length
    
    shells = EB.Data.handleAndFilterExistingShells(shells)
    report.counts.new_public = report.counts.public - shells.length
    
    EB.Data.handleNewPublicShells(shells)
    
    shells = EB.Data.handleAndFilterByGC(shells)
    report.counts.gc = report.counts.new_public - shells.length

    report.public_puff_sigs = shells.map(EB.prop('sig'))
    
    EB.runHandlers('newPuffs', shells)
    EB.runHandlers('newPuffReport', report)
    
    return report
}


EB.Data.handleMetaPuffs = function(shells) {
    // TODO: move this to a module
    var metapuffs = shells.filter(EB.Data.isMetaPuff)
    
    metapuffs.forEach(function(shell) {
        var sig = shell.payload.content
        EB.Data.addStar(sig, shell.username, shell.sig)
    })
    
    return {stars: metapuffs.length}
}

EB.Data.isMetaPuff = function(shell) {
    // TODO: move this to a module
    return shell.payload.type == 'star'    
}


EB.Data.handlePrivatePuffs = function(shells) {
    var privatepuffs = shells.filter(EB.Puff.isPrivate)    
    return EB.Data.ingestEncryptedShells(privatepuffs)          // TODO: this returns our promise report
}


EB.Data.handleAndFilterExistingShells = function(shells) {
    // THINK: this can't answer the question of "did we updated an existing shell with content"?
    return shells.filter(function(shell) {                      // returns all new (and newly full) puffs
        var existing = EB.Data.getCachedShellBySig(shell.sig)

        if(!existing) return true                               // it's new
        if(EB.Puff.isFull(existing)) return false               // it's known
        if(EB.Puff.isEmpty(shell)) return false                 // it's an empty shell

        existing.payload.content = shell.payload.content        // add the missing content
        return true                                             // true because we changed it
    })
}


EB.Data.handleNewPublicShells = function(shells) {
    shells.forEach(function(shell) {
        EB.Data.shells.push(shell)
        EB.Data.shellSort[shell.sig] = shell
    })

    EB.Data.addToGraph(shells)
    EB.Data.rateSomePuffs(shells)
    EB.Data.persistShells()                                     // drop new stuff into localStorage
}


EB.Data.handleAndFilterByGC = function(shells) {
    var compacted = EB.Data.garbageCompactor()                  // OPT: call this earlier
    if(!compacted) return shells
    
    return shells.map(EB.prop('sig'))                            // if GC eats puffs this spits them out
                 .map(EB.Data.getCachedShellBySig)
                 .filter(Boolean)
}


/**
 * to persist shells
 * @param {Shell[]}
 * @returns {(boolean|*)}
 */
EB.Data.persistShells = function(shells) {
    if(EB.CONFIG.noLocalStorage) return false                      // THINK: this is only for debugging and development
    
    // THINK: when we receive shells directly we should compact them too
    if(!shells) 
        shells = function() {return EB.Data.getShellsForLocalStorage()} // thunked for perf
    
    // when you save shells, GC older "uninteresting" shells and just save the latest ones
    // THINK: is this my puff? then save it. otherwise, if the content is >1k strip it down.
    // THINK: we need knowledge of our user records here... how do we get that? 
    // EB.Data.interesting_usernames?
    
    // shells = shells.filter(function(shell) { return !shell.payload.content || (shell.payload.content.length < 1000) })
    
    EB.Persist.save('shells', shells)
}



EB.Data.getConversationPuffs = function(convoId, offset, batchsize) {
    offset = offset || 0
    batchsize = batchsize || EB.CONFIG.pageBatchSize || 10
    
    var prom
    prom = EB.Net.getConversationPuffs(convoId, batchsize, offset)
    prom = prom.then(EB.Data.addShellsThenMakeAvailable)
    return prom
}

EB.Data.getConversationPuffs = EB.promiseMemoize(EB.Data.getConversationPuffs, function(key, report) {
    report.private_promise.then(function() {
        EB.removePromisePending(key)
    })
})


/**
 * to import shells from local and remote sources
 */
EB.Data.importShells = function() {
    //// fetch shells from local and remote sources
    
    // THINK: this should take a set of routes so we can pass them to importRemoteShells
    
    // grab the local shells and add them to the system
    // then grab some remote shells (latest 100) and compare them
    // go back until we fill in the gaps, or hit the threshold (500?)
    
    // when you want to look at shells that don't exist, like when scrolling, grab them as a batch
    
    EB.Data.importLocalShells()
    // EB.Data.getMoreShells()
    EB.Data.importRemoteShells()
    // EB.Data.importAllStars()
}

/**
 * to import local shells
 */
EB.Data.importLocalShells = function() {   // callback) {
    // EB.Data.shells = EB.Persist.get('shells') || []
    var localShells = EB.Persist.get('shells') || []
    
    EB.Data.addShellsThenMakeAvailable(localShells)
}


EB.Data.importAllStars = function() {
    // TODO: consider moving this to a module
    var prom = EB.Net.getStarShells()
    prom.then(EB.Data.addShellsThenMakeAvailable)
}


EB.Data.horridStash = {}

EB.Data.isBadEnvelope = function(sig) {
    return EB.Data.horridStash[sig]
}

EB.Data.addBadEnvelope = function(sig) {
    EB.Data.horridStash[sig] = true
}


EB.Data.currentDecryptedLetters = []
EB.Data.currentDecryptedLetterMap = {}

EB.Data.getCurrentDecryptedLetters = function() {
    //// NOTE: always use this instead of hitting currentDecryptedLetters directly, as this function may change
    return EB.Data.currentDecryptedLetters
}

EB.Data.getDecryptedLetterBySig = function(sig) {
    if(EB.Data.currentDecryptedLetterMap[sig])
        return EB.Data.currentDecryptedLetterMap[sig]
}


EB.Data.addDecryptedLetter = function(letter, envelope) {
    // THINK: how can we avoid doing this 'existing letter' check twice?
    var maybeLetter = EB.Data.getDecryptedLetterBySig(envelope.sig)
    if(maybeLetter) return false
    
    if(letter.payload.type == 'identity') return false             // THINK: where should this live?
    
    EB.Data.currentDecryptedLetters.push(letter)
    
    EB.Data.currentDecryptedLetterMap[envelope.sig] = letter       // letter is a puff too
    EB.Data.currentDecryptedLetterMap[letter.sig] = letter         // stash it both ways
    EB.Data.addBonus(letter, 'envelope', envelope)                 // mark it for later
    
    EB.Data.addToGraph([letter])

    return true
}

EB.Data.removeAllPrivateShells = function() {
    EB.Data.currentDecryptedLetters.forEach(function(shell) {
        EB.Data.removeShellFromCache(shell.sig)
    })
    
    EB.Data.currentDecryptedLetterMap = {}
    EB.Data.currentDecryptedLetters = [] 
    EB.Data.clearPuffContentStash()
}






EB.Data.getMorePrivatePuffs = function(username, offset, batchsize) {
    // THINK: race condition while toggling identities? username isn't used below.
    if(!username) username = EB.getCurrentUsername()
    
    offset = offset || 0
    // offset = offset || EB.CONFIG.initLoadBatchSize || 20
    batchsize = batchsize || EB.CONFIG.pageBatchSize || 10
    
    var prom
    prom = EB.Net.getMyPrivatePuffs(EB.getCurrentUsername(), batchsize, offset) // THINK: why switched param order?
    prom = prom.then(EB.Data.addShellsThenMakeAvailable)
    return prom
}


EB.Data.updatePrivateShells = function(offset) {
    var username = EB.getCurrentUsername()
    var batchsize = 1
    var fullOrShell = 'full' // OPT: just gather the shell (or sig) here when checking latest
    offset = offset || 0     //      actually... we need a list of all sigs we've encountered (not just good ones)
                             //      otherwise bad envelopes (etc) could block prior good content.

    EB.Net.getMyPrivatePuffs(username, batchsize, offset, fullOrShell)
          .then(function(shells) {
              var shell = shells[0]
              if(!shell) return false
              
              var prom = EB.Data.ingestAnEncryptedShell(shell) // manual because we need the decryption promise
              
              prom.then(function(fresh) {
                  if(fresh)
                      EB.Data.updatePrivateShells(1+offset)
              })
          })
}


EB.Data.ingestEncryptedShells = function(shells) {
    var proms = shells.map(EB.Data.ingestAnEncryptedShell)
    
    // NOTE: Promise.all rejects immediately upon any rejection, so we have to do this manually
    
    return new Promise(function(resolve, reject) {
        var remaining = proms.length
        var report = {good: 0, bad: 0, goodsigs: []}
        
        // TODO: add more information about what went wrong to the report
        
        function unhappy_path() {
            report.bad++
            if(!--remaining) resolve(report)
        }
        
        proms.forEach(function(prom) {
            prom.then(function(letter) {
                if(!letter) return unhappy_path()                       // catches old or weird puffs 
                report.good++                                           // TODO: differentiate above cases
                report.goodsigs.push(letter.sig)
                if(!--remaining) resolve(report)
            }, unhappy_path )                                           // catches decryption errors
        })
    })
}


EB.Data.ingestAnEncryptedShell = function(envelope) {
    var prom = EB.Puff.promiseLetter(envelope)

    prom = prom.then(function(letter) {
        if(!letter) return false
        
        var fresh = EB.Data.addDecryptedLetter(letter, envelope)        // add the letter to our system
        if(!fresh) return false
        
        EB.runHandlers('newPuffs', [letter])                            // always receives an array of puffs
        return letter
    })
    
    return prom
    
    // NOTE: this doesn't appear to do much, mostly because extractLetterFromEnvelope is quite effectful.
    //       it calls EB.Data.addDecryptedLetter as part of its processing, which does all the real work.
    
    // THINK: consider adding this back in, though remember that each decryption pushes its own errors...
    // if (letters.length != privateShells.length) {
    //     Events.pub('track/decrypt/some-decrypt-fails',
    //                 {letters: letters.map(function(p){return p.sig}),
    //                  privateShells: privateShells.map(function(p){return p.sig})})
    // }
}




// the slot locker contains information on queries made to fill slots. 
// in particular it holds the offset, which will be -1 when [] is returned.
// it keeps queries from re-requesting the same shells over and over, 
// and provides some concurrency / flow control by allowing a query
// to set it to -1 when it is running and then replace it when done.
EB.Data.slotLocker = {}

// THINK: we're calling this from the 'refresh' button now...


EB.Data.importRemoteShells = function() {
    //// only called during initial application bootup. handles both cold loads and hot loads.
    
    var offset = 0
    var giveup = EB.CONFIG.initLoadGiveup
    var limit  = EB.CONFIG.initLoadBatchSize
    var new_shells = []
    var keep_going = true
    
    var key = '[{"sort":"DESC"},{"tags":[],"types":[],"users":[],"routes":[]}]' // TODO: upgrade this default query
    EB.Data.slotLocker[key] = -1
    
    // TODO: index by username
    // TODO: if duplicate check update times for latest
    // TODO: persist to LS (maybe only sometimes? onunload? probabilistic?)
         
    function getMeSomeShells(puffs) {
        if(puffs) {
            var delta = EB.Data.addShellsThenMakeAvailable(puffs)
            // new_shells = new_shells.concat(my_new_shells)
            // var delta = my_new_shells.length
            
            if(delta != limit)                                          // some shells were already in our cache
                keep_going = false
        }
        
        if(offset > giveup)
            keep_going = false

        if(!keep_going) {
            EB.Data.slotLocker[key] = 1
            // EB.Data.stupidHorribleGlobalThing = true
            // EB.Data.makeShellsAvailable(new_shells)
            return false
        }
        
        var prom = EB.Net.getSomeShells({}, {}, limit, offset)
        prom.then(getMeSomeShells)

        offset += limit
    }
    
    getMeSomeShells()
}



/*
    End shell collection intake equipment
*/


/**
 * Send a private puff using a new anonymous user as the sender and possibly another as reply-to
 * @param {string} Either 'anon' or 'doublyanon'
 * @returns {promise}
 */
EB.Data.sendAnonModePuff = function(content, usernames, type, mode, payload, routes) {
    if(!EB.getCurrentUsername())
        return EB.emptyPromise('You must have a current identity to send messages')
        
    payload = payload || {}
    if(!Array.isArray(usernames))
        usernames = usernames ? [usernames] : []
    
    var privateEnvelopeAlias                                            // escapes the private keys of new anon user
    var prom = Promise.resolve()                                        // a promise we use to string everything along 

    prom = prom.then(function() {                                       // we'd like to be anonymous, so make a new user
        return EB.Users.addAnonymousUser().then(function(userRecord) {
            EB.useSecureInfo(function(identities, currentUsername) {
                var identity = identities[currentUsername]
                var aliases = identity.aliases
                privateEnvelopeAlias = aliases[aliases.length-1]        // our new anon aliases should be the last one
                usernames.push(userRecord.username)                     // add new anon username to the list of recipients
            })
        })
    })

    if(mode == 'doublyanon') {                                          // are we doubly anonymous? make another new user
        prom = prom.then(function() {
            return EB.Users.addAnonymousUser().then(function(userRecord) {
                payload.replyTo = userRecord.username
            })
        })
    }

    prom = prom.then(function() {                                       // once the users are made, send off the puff
        var userprom = EB.Users.usernamesToUserRecordsPromise(usernames)
        
        return userprom.then(function(userRecords) {        
            var puff = EB.Puff.simpleBuild(type, content, payload, routes, userRecords, privateEnvelopeAlias)
            return EB.Data.addPuffToSystem(puff)
        })
    }).catch(function(err) {
        EB.catchError(err)
    })
    
    return prom
}


/**
 * get a puff by its sig
 * @param {string} sig
 * @returns {promise}
 */
EB.Data.getPuffBySig = function(sig) {
    var shell = EB.Data.getCachedShellBySig(sig)                    // check in public cache
    
    if(!shell)
        shell = EB.Data.getDecryptedLetterBySig(sig)                // check in private cache
    
    if(EB.Puff.isFull(shell))
        return Promise.resolve(shell)                               // it has content
    
    if(EB.Data.pendingPuffPromises[sig])                            // establish a foothold
        return EB.Data.pendingPuffPromises[sig]
    
    return EB.Data.getPuffBySigFromElsewhere(sig)                   // gather a promise
}

EB.Data.getPuffOrNot = function(sig) {
    // Supports the fire-and-forget style -- see note in EB.js
   
    var shell = EB.Data.getCachedShellBySig(sig)                    // check in public cache
    
    if(!shell)
        shell = EB.Data.getDecryptedLetterBySig(sig)                // check in private cache

    if(EB.Puff.isFull(shell))
        return shell                                                // it has content
        
    EB.Data.getPuffBySigFromElsewhere(sig)                          // get the puff from the network
        
    return false                                                    // but return false for easy filtering
}


/**
 * get a puff by its sig from elsewhere
 * @param {string} sig
 * @returns {promise}
 */
EB.Data.getPuffBySigFromElsewhere = function(sig) {
    EB.Data.pendingPuffPromises[sig] = EB.Net.getPuffBySig(sig)
    var output = EB.Data.pendingPuffPromises[sig].then(badShellClearCache)

    output.then(EB.Data.addShellsThenMakeAvailable)
          .then(function() {                                        // delay GC to stop runaway network requests
                    setTimeout(function() { delete EB.Data.pendingPuffPromises[sig] }, 10000) })
    
    return output
        
    // locally cached shells that are missing content on the network prevent slotfills from resolving,
    // so we clear it from our cache if we can't find it.
    function badShellClearCache(shells) {
        if(!shells.length) {
            var fauxshell = {sig: sig}
            if(!EB.Data.getBonus(fauxshell, 'envelope')) {
                EB.Data.removeShellFromCache(sig)
                return EB.onError("Content can not be found for shell '" + sig + "'") // THINK: why was this throwError?
                // THINK: unlock EB.Data.pendingPuffPromises[sig]? probably not, but it might re-appear later...
            }
        }
        return shells
    }
}

EB.Data.removeShellFromCache = function(sig) {
    var shell = EB.Data.getCachedShellBySig(sig)                    // remove from EB.Data.shells
    EB.Data.shells.splice( EB.Data.shells.indexOf(shell), 1 )
    
    delete EB.Data.shellSort[sig]                                   // remove from EB.Data.shellSort
    
    delete EB.Data.bonii[sig]                                       // remove shell's bonii
    
    EB.Data.purgeShellFromGraph(sig)                                // remove from graph
    
    EB.Data.removeCachedPuffScore(shell)                            // remove allocator score
}

EB.Data.purgeShellFromGraph = function(sig) {
    // change graph vertex to 'pseudo-shell' type (or 'purged' type?)
    //   and remove the content of the 'shell' property
    // TODO: this is icky make it better
    var vertex = EB.Data.graph.v(sig).run()[0]
    if(vertex) {
        vertex.type = 'purged'
        vertex.shell = undefined
    }
}


/**
 * to get my puff chain
 * @param  {string} username 
 * @return {object}
 */
EB.Data.getMyPuffChain = function(username) {
    // CURRENTLY UNUSED
    // TODO: this should grab my puffs from a file or localStorage or wherever my identity's puffs get stored
    // TODO: that collection should be updated automatically with new puffs created through other devices
    // TODO: the puffchain should also be sorted in chain order, not general collection order
    
    var shells = EB.Data.getShells()
    
    return shells.filter(function(puff) { return puff && puff.username == username }) // TODO: use the graph
    // return EB.M.Forum.getByUser(username) // TODO: test this 
}



///////////////////////////////////////////
//                                       //
//       Garbage Collector Thing         //
//                                       //
///////////////////////////////////////////



EB.Data.runningSizeTally = 0
EB.Data.scoreSort = {}

EB.Data.heuristics = []
EB.Data.addHeuristics = function(fun) {
    EB.Data.heuristics.push(fun)
}

EB.Data.addHeuristics(function(shell) {
    return parseFloat( (EB.Data.getBonus(shell, 'starStats') || {}).score || 0 ) * 100
})

// TODO: add heuristics for: my puffs (which go elsewhere, ultimately), replies to my puffs, my puff's parents, 
//       friend's puffs (whatever that means), puff freshness, last seen, etc


EB.Data.rateMyPuff = function(puff) {
    var scores = EB.Data.heuristics.map(function(h) {return h(puff)})           // apply heuristics
    var total  = scores.reduce(function(acc, score) {return acc+(score||0)}, 0) // get total // TODO: improve algo
    return total
}

EB.Data.rateSomePuffs = function(puffs) {
    puffs.forEach(function(puff) {                                              // rate each puff
        var score = EB.Data.rateMyPuff(puff)
        EB.Data.doStuffWithScore(puff, score)
        EB.Data.doStuffWithPuff (puff)
    })
    // THINK: some heuristics rely on scores of related puffs... possible feedback loop? topological ordering?
    //        a toposort is easy-ish w/ graph db...
}

// TODO: when you switch identities, rescore the puffs


EB.Data.doStuffWithScore = function(puff, score) {
    EB.Data.removeCachedPuffScore(puff)                                         // NOTE: has to come before bonii
    EB.Data.addBonus(puff, 'rating', score)                                     // add rating to bonii
    EB.Data.cachePuffScore(puff, score)    
    // OPT: cache sorted version
    // maybe bins[score.floor].push(puff) or something...
}

EB.Data.doStuffWithPuff = function(puff) {
    var puffsize = JSON.stringify(puff).length
    EB.Data.addBonus(puff, 'size', puffsize)
    EB.Data.runningSizeTally += puffsize || 0                                  // block NaNs
}

EB.Data.cachePuffScore = function(puff, score) {
    var key = EB.Data.convertScoreToKey(score)
    EB.Data.scoreSort[key] = EB.Data.scoreSort[key] || []
    EB.Data.scoreSort[key].push(puff)
}

EB.Data.removeCachedPuffScore = function(puff) {
    if(!puff) return false
    
    var score = EB.Data.getBonus(puff, 'score')
    var key = EB.Data.convertScoreToKey(score)
    var bin = EB.Data.scoreSort[key]
    if(!bin) return false
    if(!bin.length) return false
    
    for(var i = bin.length - 1; i >= 0; i--) {
        if(bin[i].sig == puff.sig) {
            bin.splice(i, 1)
            var puffsize = EB.Data.getBonus(puff, 'size')
            EB.Data.runningSizeTally -= puffsize || 0                          // block NaNs
            return false
        }
    }
}

EB.Data.getCachedPuffs = function(limit, bottom) {
    var seen = 0
    var result = []
    var keys = Object.keys(EB.Data.scoreSort).map(parseFloat).sort()
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i]
        var puffs = EB.Data.scoreSort[key] // OPT: short-circuit on !bottom
        
        puffs.reduce(function(seen, puff) {
            if(seen > limit == !!bottom) result.push(puff)
            return seen+1
        }, 0)
    }
    
    return result
}

EB.Data.convertScoreToKey = function(score) {
    return Math.floor(score / 10) || 0 // TODO: make this smarter
}


EB.Data.getTopPuffs = function(limit) {
    return EB.Data.getCachedPuffs(limit)
}

EB.Data.getNotTopPuffs = function(limit) {
    // grab the puffs below the limit threshold (w/ 300 puffs and limit=100 this returns the 200 worst puffs)
    return EB.Data.getCachedPuffs(limit, 'bottom')
}

// EB.Data.getTopPuffs = function(options) {
//     var numberLimit =  options.number || 0
//     var sizeLimit   =    options.size || 0
//     var compact     = options.compact || false  // whether to allow compaction of returned puffs
//     var reverse     = options.reverse || false  // return bottom puffs instead of top puffs
// }

EB.Data.garbageCompactor = function() {
    // are we over the limits?
    var limit     = EB.CONFIG.inMemoryShellLimit
    var memlimit  = EB.CONFIG.inMemoryMemoryLimit
    var sizelimit = EB.CONFIG.shellContentThreshold
    var didStuff  = false

    if(EB.Data.shells.length > limit) {
        didStuff = true
        EB.Data.shells.slice(limit).map(EB.prop('sig')).forEach(EB.Data.removeShellFromCache)
    }
    
    if(EB.Data.runningSizeTally > memlimit) {
        didStuff = true
        for (var i = EB.Data.shells.length - 1; i >= 0; i--) {
            var shell = EB.Data.shells[i]
            var content_size = (shell.payload.content||"").toString().length // THINK: non-flat content borks this
            if (content_size > sizelimit) {
                delete shell.payload.content // THINK: this is hardcore
                total -= content_size + 13 // NOTE: magic number == '"content":"",'.length
                if(total <= memlimit) break
            }
        }
    }
    
    return didStuff
}


EB.Data.getShellsForLocalStorage = function() {
    var limit     = EB.CONFIG.localStorageShellLimit
    var memlimit  = EB.CONFIG.localStorageMemoryLimit
    var sizelimit = EB.CONFIG.shellContentThreshold
    
    var shells = EB.Data.getTopPuffs(limit)
    var total = shells.reduce(function(size, shell) {
        return size + (EB.Data.getBonus(shell, 'size') || 0)
    }, 0)
    
    if (total <= memlimit) return shells
    
    // compact the puffs
    for (var i = shells.length - 1; i >= 0; i--) {
        var shell = shells[i]
        var content_size = (shell.payload.content||"").toString().length // THINK: non-flat content borks this
        if (content_size > sizelimit) {
            var new_shell = EB.Puff.compactPuff(shell)
            shells[i] = new_shell
            total -= content_size + 13 // NOTE: magic number == '"content":"",'.length
            if(total <= memlimit) break
        }
    }
    
    if (total <= memlimit) return shells
    
    // remove shells until under memlimit
    for (var i = shells.length - 1; i >= 0; i--) {
        var content_size = JSON.stringify(shell).length
        total -= content_size
        if(total <= memlimit) break
    }
    
    shells = shells.slice(0, Math.max(i, 1)) // prevent -1 
    
    return shells
}






// /**
//  * to fill some slots
//  * @param {number} need
//  * @param {number} have
//  * @param {string} query
//  * @param {string} filters
//  * @returns {boolean}
//  */
// EB.Data.fillSomeSlotsPlease = function(need, have, query, filters) {
//     //// we have empty slots on screen. fill them with puffs.
//
//     if(have >= need) return false
//
//     // -- redraw screen on new puffs being ingested (w/o looping)
//     // -- cycle all new puffs through graph stuff
//     // -- call fillSomeSlotsPlease every time we have slots to fill
//     // -- get focused puff immediately
//
//     // - perform GC on in-memory puffs (can remove content also)
//     // - use GC funs for persisting shells
//     // - store size of each shell/puff for GC
//     // - manage empty vertices better (different type?)
//
//     var args = [query, filters]
//     // var args = [query, filters, need]
//     // if(!query.mode) args.push(have) // hack for alternate query modes
//
//     var key = JSON.stringify(args)
//     var my_offset = EB.Data.slotLocker[key] || 0
//
//     if(my_offset < 0)
//         return false // slot is locked, go elsewhere
//
//     EB.Data.slotLocker[key] = -1 // prevent concurrent versions of the same request
//
//     //////
//
//     // var limit = need - have + 3 // 3 for luck
//
//     var limit = need // so... if we only do this once, and we have half the puffs already, we might only grab that half again. this is true even if we send an offset of 'have' to the server, because what we have might map to that slice (or to anything else -- our offsets are totally different than the servers). so we have to grab enough to cover the difference, which means grabbing the same shells multiple times... (but only empty shells, fortunately. but still.)
//
//     // var received_shells = 0
//
//     var prom = EB.Net.getSomeShells(query, filters, limit, query.offset)
//     // prom.then(function(shells) {received_shells = shells.length; return shells})
//     prom.then(EB.Data.addShellsThenMakeAvailable)
//         .then(function(delta) {
//             EB.Data.slotLocker[key] = delta ? 1 : -1})
//             // if the request is fruitful, unlock it (but be careful of offsets here).
//             // also, this locks when we received data but chose not to keep it (either dups or GC),
//             // so we could have an issue with locked queries that would be fruitful w/ different offset / limits...
//
//
//     // TODO: the slotLocker really should keep track of what 'slices' of the server you've seen, so we know not to re-request those over and over. this is... complicated.
//     //       so send query.offset+have to getSomeShells, and store that same offset as part of the slotLocker.
//     //       then you can track how much of some type of stuff is on the server... except that doesn't work for the P2P network.
//
//     return true
//
//     //////
//
//
//     // OLD STUFF SAVE FOR REFERENCE
//
//     // var batchSize = EB.CONFIG.fillSlotsBatchSize
//     // var giveup = EB.CONFIG.fillSlotsGiveup
//     // var new_shells = []
//     //
//     // giveup = giveup + my_offset
//     //
//     // function getMeSomeShells(puffs) {
//     //     if(puffs) {
//     //         var my_new_shells = EB.Data.hereHaveSomeNewShells(puffs)
//     //         new_shells = new_shells.concat(my_new_shells)
//     //         var delta = my_new_shells.length
//     //         // THINK: but do they pass the filter?
//     //         // TODO: can we make available here now that we're locking?
//     //         have += delta || 0
//     //     }
//     //
//     //     if(have >= need || my_offset > giveup || (query.mode && (my_offset - giveup < 0))) {
//     //         EB.Data.makeShellsAvailable(new_shells)
//     //         EB.Data.slotLocker[key] = my_offset-limit
//     //         return false
//     //     }
//     //
//     //     var limit = need - have
//     //     // if(!query.mode) limit += 50 // grab a few extras to help work through bare patches
//     //
//     //     var prom = EB.Net.getSomeShells(query, filters, limit, my_offset)
//     //     prom.then(getMeSomeShells)
//     //
//     //     my_offset += limit
//     // }
//     //
//     // getMeSomeShells()
// }


/*

    Network library for the EveryBit platform.

    Contains a peer.js-based p2p layer, a promise-based XHR implementation, 
    helper functions for accessing various server-based APIs, 
    and helper functions for handling puff distribution and acquisition.

    Copyright 2014-2015 EveryBit. See README for license information.

 */

EB.Net = {}

/**
 * Fire up networks (currently just the peer connections)
 */
EB.Net.init = function() {
    EB.Net.P2P.init()
}

/**
 * Given a signature, return puff with that signature
 * @param  {string} sig signature of a puff
 * @return {object}     puff corresponds to the specified signature
 */
EB.Net.getPuffBySig = function(sig) {
    var url  = EB.CONFIG.puffApi
    var data = {type: 'getPuffBySig', sig: sig}
    
    return EB.Net.EBgetJSON(url, data)
}

EB.Net.getKidSigs = function(sig) {
    var url  = EB.CONFIG.puffApi
    var data = {type: 'getChildrenBySig', sig: sig}
    
    return EB.Net.EBgetJSON(url, data)
}

EB.Net.getKidSigs = Boron.memoize(EB.Net.getKidSigs) // THINK: this assumes we'll get all new things over the P2P network, which won't always be true.



EB.Net.getStarShells = function() {
    var url  = EB.CONFIG.puffApi
    var data = {type: 'getPuffs', contentType: 'star', numb: EB.CONFIG.globalBigBatchLimit}
    
    return EB.Net.EBgetJSON(url, data)
}

EB.Net.getConversationPuffs = function(convoId, batchsize, offset, fullOrShell) {
    convoId  = convoId.replace('&',',')

    var url  = EB.CONFIG.puffApi
    var data = { type: 'getPuffs', contentType: 'encryptedpuff'
               , conversationPartners: convoId
               , numb: batchsize
               , offset: offset
               }
    
    return EB.Net.EBgetJSON(url, data)
}

EB.Net.getMyPrivatePuffs = function(username, batchsize, offset, fullOrShell) {
    if(!username) return EB.emptyPromise()
    batchsize = batchsize || EB.CONFIG.globalBigBatchLimit
    
    var url  = EB.CONFIG.puffApi
    var data = { route: username, username: username, fromAndTo: 1
               , type: 'getPuffs', contentType: 'encryptedpuff'
               , fullOrShell: fullOrShell || 'full'
               , numb: batchsize
               , offset: offset
               }
    
    return EB.Net.EBgetJSON(url, data)
    
/*

    So something like:

    EB.getSomePuffs(query, limit, etc)

    helper.js:
    tryGettingMorePuffs(visibleLimit) {
        // figure out how many we've requested already (EB.currentOffset)
        // figure out how many we actually have (EB.Data.getDecryptedPuffs)
        var delta = visibleLimit - EB.Data.getDecryptedPuffs().length
        EB.currentOffset += delta
        return EB.getSomePuffs(query, EB.currentOffset)
    }


*/ 

    // TODO: chain this in to the table view
    
}


EB.Net.getProfilePuff = function(username) {
    var url  = EB.CONFIG.puffApi
    var data = { username: username
               , fullOrShell: 'full'
               , contentType: 'profile'
               , type: 'getPuffs'
               , sort: 'DESC'
               , numb: 1
               }
    
    return EB.Net.EBgetJSON(url, data)
}

EB.Net.getProfilePuff = EB.promiseMemoize(EB.Net.getProfilePuff)


/**
 * to get some shells
 * @param {string} query
 * @param {string} filters
 * @param {number} limit
 * @param {number} offset
 * @returns {Shell[]}
 */
EB.Net.getSomeShells = function(query, filters, limit, offset) {
    // TODO: switching by query 'mode' will need to be changed when the network api matches our local api (i.e. once we use browser p2p & headless clients to service requests)
    
    var mode = query.mode
    // if(mode == 'ancestors')   return EB.Net.getAncestors  ([query.focus], limit)
    // if(mode == 'descendants') return EB.Net.getDescendants([query.focus], limit)
    // if(mode == 'siblings')    return EB.Net.getSiblings   ([query.focus], limit)

    // "normal" mode (just ask for shells from lists or something)
    var url  = EB.CONFIG.puffApi

    //  if(filters.types)   data.type       = filters.types      // filter by types

    var data = {type: 'getPuffs', contentType: 'plain'}
    // var data = {type: 'getPuffs', contentType: '["image"]'}


    if(limit)  data.numb    = limit                         // defaults to 20 on the server
    if(offset) data.offset  = offset                        // defaults to 0, which is latest
    
    if(query.sort)      data.sort        = query.sort       // ASC or DESC
    if(filters.users)   data.username    = filters.users    // filter by username
    if(filters.routes)  data.route       = filters.routes   // filter by route
    if(filters.tags)    data.tags        = filters.tags     // filter by tags
    if(filters.types)   data.contentType = filters.types    // filter by types
    if(query.ancestors) data.maxParents  = query.ancestors  // defaults to all shells 
                                                            // 0 is roots, 1 is single parent, etc
    // data.flagged = false
    
    // data.focus
    // data.ancestors
    // data.descendants
    
    var filterstring = JSON.stringify(filters.types)
    var profile_request = (filterstring == '["profile"]')
    
    if(EB.CONFIG.disableReceivePublic && !profile_request)
        return EB.emptyPromise()
                 .then(function() {return []})
    
    return EB.Net.EBgetJSON(url, data)                      // always returns a valid array
                 .then(function(x) {return x || []}, function() {return []})
}


/**
 * add puff to the server and broadcast to peers
 * @param  {object} puff the puff to be added to the server
 */
EB.Net.distributePuff = function(puff) {
    //// distribute a puff to the network

    if(EB.CONFIG.disableSendToServer) return false          // so you can work locally

    if(EB.CONFIG.netblockSuffix) {                          // block distribution of local puffs
        var usernames = [puff.username]
        if(puff.keys)
            usernames = usernames.concat(Object.keys(puff.keys))

        usernames = usernames.map(EB.Users.justUsername)
        var suffixes = usernames.map(function(username) {
            var chunks = username.split('.')
            return chunks[chunks.length-1]
        })
        
        if(suffixes.indexOf(EB.CONFIG.netblockSuffix) > -1)
            return false
    }

    EB.Net.sendPuffToServer(puff)                           // add it to the server's pufflist

    EB.Net.P2P.sendPuffToPeers(puff)                        // broadcast it to peers
}

/**
 * add a puff to the server's pufflist
 * @param  {object} puff
 * @return {object}
 */
EB.Net.sendPuffToServer = function(puff) {
    // THINK: this is fire-and-forget, but we should do something smart if the network is offline or it otherwise fails. 
    //        on the other hand, we'll probably want to do this with sockets instead of ajax ultimately...
    //        or manage it entirely with routing, even for server-sent puffs?
    
    var data = { type: 'addPuff'
               , puff: JSON.stringify(puff) }
               
    return EB.Net.EBpost(EB.CONFIG.puffApi, data)
                 .catch(EB.catchError('Could not send puff to server'))
}

/**
 * fetch a particular userRecord
 * @param  {string}  username 
 * @param  {string}  capa 
 * @return {promise} on fulfilled passes the user record as object, otherwise re-throw error
 */
EB.Net.getUserRecord = function(username, capa) {
    var url   = EB.CONFIG.userApi
    
    var versionedUsername = EB.Users.makeVersioned(username, capa)
    username = EB.Users.justUsername(versionedUsername)
    
    if(capa !== 0) // 0 signals that we need to fetch the latest userRecord
        capa = EB.Users.justCapa(versionedUsername)
    
    var data  = { type: 'getUser'
                , username: username
                }

    if(capa)
        data.capa = capa

    return EB.Net.EBgetJSON(url, data)
}


/**
 * modify a user record
 * @param  {puff}   puff a signed puff containing information of modified user record
 * @return {object} promise for new userRecord or error when the update fails
 */
EB.Net.updateUserRecord = function(puff) {
    var data = { type: 'updateUsingPuff'
               , puff: puff
               }

    var prom = EB.Net.EBpost(EB.CONFIG.userApi, data)
    
    return prom.catch(EB.catchError('Sending user record modification puff failed'))
               .then(JSON.parse) // THINK: this throws on invalid JSON
               .then(function(userRecord) {
                   return EB.Users.process(userRecord)
                       || EB.throwError('Invalid user record', JSON.stringify(userRecord))
               })
}



/**
 * EB.Net promise-based XHR layer
 * 
 * We use promises as our default concurrency construct, 
 * because ultimately this platform is composed of a 
 * huge set of interdependent async calls which mostly 
 * each resolve to a single immutable entity 
 * -- aka the promise sweet spot.
 * 
 * @param  {string} url     requested url
 * @param  {object} options 
 * @param  {object} data    
 * @return {object}
 */
EB.Net.xhr = function(url, options, data) {
    //// very simple promise-based XHR implementation
    
    return new Promise(function(resolve, reject) {
        var req = new XMLHttpRequest()
        req.open(options.method || 'GET', url)
        
        Object.keys(options.headers || {}).forEach(function (key) {
            req.setRequestHeader(key, options.headers[key])
        })
        
        var formdata = new FormData()
        Object.keys(data || {}).forEach(function (key) {
            var datum = typeof data[key] == 'object' ? EB.stringifyJSON(data[key]) : data[key]
            formdata.append(key, datum)
        })
        
        if(options && options.type)
            req.responseType = options.type
                
        req.onload = function() {
            if(req.status != 200) // silly safari
                return reject(EB.makeError(req.statusText))
            
            if(req.responseType == 'json' && req.response === null) // NOTE: traps JSONified 'null' responses also: use empty string or [] to indicate an empty result
                return reject(EB.makeError("Invalid JSON in response", req.response))
            
            resolve( (req.responseType != options.type) // manually convert json for old browsers
                  && options.type == 'json' ? EB.parseJSON(req.response) : req.response)
        }

        req.onerror = function(event) {
            reject(EB.makeError("Network Error", event, 'networkError'))
        }
        
        req.ontimeout = function(event) {
            reject(EB.makeError("Timeout Error", event, 'timeoutError'))
        }
        
        req.timeout = EB.CONFIG.networkTimeout

        req.send(formdata)
    })
}

/**
 * request an url, get result in JSON
 * @param  {string} url    
 * @param  {object} params 
 * @return {object}
 */
EB.Net.getJSON = function(url, params) {
    var options = { headers: { 'Accept': 'application/json' }
                  ,  method: 'GET'
                  ,    type: 'json'
                  }

    var params = params || {}
    var enc = function(param) {return !param && param!==0 ? '' : encodeURIComponent(param)}
    var qstring = Object.keys(params).reduce(function(acc, key) {return acc + enc(key) +'='+ enc(params[key]) +'&'}, '?')

    return EB.Net.xhr(url + qstring, options) 
}


/**
 * send a post request
 * @param  {string} url  requested url
 * @param  {object} data 
 * @return {object}
 */
EB.Net.post = function(url, data) {
    var options = { headers: {   
//         'Content-type': 'application/x-www-form-urlencoded' 
//                           , 'Content-length': params.length
//                           ,     'Connection': 'close'  
                             }
                  ,  method: 'POST'
                  }

    return EB.Net.xhr(url, options, data)
}



/**
 * A customized wrapper for the EveryBit server over the base XHR promise wrapper
 * @param  {string} url    
 * @param  {object} params 
 * @return {object}
 */
EB.Net.EBxhr = function(url, options, data) {
    var prom = EB.Net.xhr(url, options, data)
        
    return prom.then(function(response) {
        if(response.FAIL)
            return EB.throwDHTError(response.FAIL)

        if(typeof response == 'string' && response.slice(0,6) == '{"FAIL')
            return EB.throwDHTError((EB.parseJSON(response)||{}).FAIL)

        EB.runHandlers('networkresponse', response)
        
        return response
    })
}

EB.Net.EBpost = function(url, data) {
    //// This is the EveryBit server version of EB.Net.getJSON -- use that function if you're not accessing the EveryBit server
    // THINK: should we parametrize over the dispatch function?
    var options = { headers: {}
                  ,  method: 'POST'
                  }
                  
    return EB.Net.EBxhr(url, options, data)
}

EB.Net.EBgetJSON = function(url, params) {
    //// This is the EveryBit server version of EB.Net.getJSON -- use that function if you're not accessing the EveryBit server
    // THINK: should we parametrize over the dispatch function?
    var options = { headers: { 'Accept': 'application/json' }
                  ,  method: 'GET'
                  ,    type: 'json'
                  }

    var params = params || {}
    var enc = function(param) {return !param && param!==0 ? '' : encodeURIComponent(param)}
    var qstring = Object.keys(params).reduce(function(acc, key) {return acc + enc(key) +'='+ enc(params[key]) +'&'}, '?')

    return EB.Net.EBxhr(url + qstring, options) 
}








/*

    EB.Net Peer-to-Peer layer

    We're currently using peer.js to negotiate the WebRTC connection. There's a lot of work left to be done here.

*/


EB.Net.P2P = {}
EB.Net.P2P.peers = {}

/**
 * initialize the peer-to-peer layer
 */
EB.Net.P2P.init = function() {
    // NOTE: you have to manually enable the P2P layer via config or init options
    // e.g. EB.init({enableP2P: true})
    // or   EB.CONFIG.enableP2P = true
    if(!EB.CONFIG.enableP2P) return false
    
    EB.Net.P2P.Peer = new Peer({ host:  '162.219.162.56'
                               , port:  9000
                               , path:  '/'
                               , debug: 1
                               })
    
    EB.Net.P2P.Peer.on('open', EB.Net.P2P.openPeerConnection)
    EB.Net.P2P.Peer.on('connection', EB.Net.P2P.connection)
}

/**
 * to reload peers
 * @return {object} 
 */
EB.Net.P2P.reloadPeers = function() {
    return EB.Net.P2P.Peer.listAllPeers(EB.Net.P2P.handlePeers)
}

/**
 * open peer connection
 * @param  {string} id 
 * @return {object[]}
 */
EB.Net.P2P.openPeerConnection = function(id) {
    // OPT: do we really need this? 
    // THINK: why not just call EB.Net.P2P.reloadPeers?
    return EB.Net.P2P.Peer.listAllPeers(EB.Net.P2P.handlePeers)
}

/**
 * connection
 * @param connection
 * @returns {*}
 */
EB.Net.P2P.connection = function(connection) {
    EB.Net.P2P.reloadPeers() // OPT: do we really need this? 

    return connection.on('data', function(data) {
        EB.Data.addShellsThenMakeAvailable(data) // TODO: pass a callback in to EB.Net instead of calling this directly
    })
}

/**
 * to handle peers
 * @param  {object} peers 
 * @return {boolean}   
 */
EB.Net.P2P.handlePeers = function(peers) {
    peers.forEach(function(peer) {
        if(EB.Net.P2P.peers[peer]) 
            return false
        EB.Net.P2P.peers[peer] = EB.Net.P2P.Peer.connect(peer)
    })
}

/**
 * to send puff to peers
 * @param  {object} puff
 */
EB.Net.P2P.sendPuffToPeers = function(puff) {
    for(var peer in EB.Net.P2P.peers) {
        EB.Net.P2P.peers[peer].send(puff)
    }
}











// EB.Net.getAncestors = function(start, limit) {
//     getEm(start, [], limit)
//     return EB.emptyPromise()
//
//     function getEm(todo, done, remaining) {
//         if(!todo.length) return false                       // all done
//         if(!remaining) return false                         // all done
//
//         var sig = todo[0]
//
//         if(~done.indexOf(sig)) {
//             return getEm(todo.slice(1), done, remaining)    // we've already done this one
//         }
//
//         // TODO: set a callback in EB.Net instead of calling EB.Data directly
//         var puff = EB.Data.getPuffBySig(sig)                // effectful
//
//         if(puff)
//             return getEm(todo.slice(1).concat(puff.payload.parents), done.concat(sig), remaining)
//
//         // no puff? that's ok. attach a then clause to its pending promise.
//         // TODO: find better method to do this
//         remaining-- // because we're adding a new puff, or at least new content
//         var prom = EB.Data.pendingPuffPromises[sig]
//         prom.then(function(puffs) {
//             getEm(todo.slice(1).concat(((puffs[0]||{}).payload||{}).parents), done.concat(sig), remaining)
//         })
//     }
//
//     //
//     // if(!todo.length)
//     //     return Promise.resolve(results)             // all done
//     // if(results.length >= limit)
//     //     return Promise.resolve(results)             // all done
//     //
//     // var sig = todo[0]
//     // var shell = EB.Data.getCachedShellBySig(sig)   // TODO: set a callback in EB.Net instead of calling this directly
//     //          || results.filter(function(result) {return result.sig == sig})[0]
//     //
//     // // if we already have a puff for sig, then we just need to put its parents on the todo stack
//     // if(shell) {
//     //     todo.shift() // take off the shell we just worked on
//     //     return EB.Net.getAncestors(todo.concat(shell.payload.parents), limit, results)
//     // }
//     //
//     // // otherwise, get a promise for the shell, then add it to results
//     // var prom = EB.Net.getPuffBySig(sig)
//     // return prom.then(function(puffs) {
//     //     return EB.Net.getAncestors(todo, limit, results.concat(puffs))
//     // })
// }

// EB.Net.getDescendants = function(start, limit) {
//     getEm(start, [], limit)
//     return EB.emptyPromise()
//
//     function getEm(todo, done, remaining) {
//         if(!todo.length) return false                       // all done
//         if(!remaining) return false                         // all done
//
//         var sig = todo[0]
//
//         if(~done.indexOf(sig)) {
//             return getEm(todo.slice(1), done, remaining)    // we've already done this one
//         }
//
//         // TODO: set a callback in EB.Net instead of calling EB.Data directly
//         var haveShell = EB.Data.getCachedShellBySig(sig)
//
//         if(!haveShell) {                                    // we don't have the shell yet, so go get it
//             // TODO: use above callback to EB.Data
//             EB.Data.getPuffBySig(sig)                       // effectful
//             remaining--
//         }
//
//         var kidsigprom = EB.Net.getKidSigs(sig)             // get all its children
//         return kidsigprom.then(function(kidsigs) {
//             getEm(todo.slice(1).concat(kidsigs), done.concat(sig), remaining)
//         })
//     }
// }

// EB.Net.getSiblings = function() {
//     // this case is ugly, so we're leaving it until the client api can answer questions for us
//     return EB.emptyPromise()
// }

/*

    Persistence layer for the EveryBit platform.

    It's like a network on your hard drive... which means this could be part of EB.Net.

    Copyright 2014-2015 EveryBit. See README for license information.

 */

EB.Persist = {};
EB.Persist.todo = {}
EB.Persist.todoflag = false

/**
 * to save key/value
 * @param  {string} key
 * @param  {string} value
 */
EB.Persist.save = function(key, value) {
    if(value == null)
        value = false
    EB.Persist.todo[key] = value
    if(!EB.Persist.todoflag) {
        onceInAwhile(function() {
            for(var key in EB.Persist.todo) {
                var realkey = 'PUFF::' + key;                           // prepend PUFF:: so we're good neighbors
                var value = EB.Persist.todo[key];
                if(typeof value == 'function')                          // in case we're passed a thunk
                    value = value();
                var str = JSON.stringify(value);                
                localStorage.setItem(realkey, str);
            }
            EB.Persist.todo = {};
            EB.Persist.todoflag = false;
        }, 100);                                                        // call at most every 100ms
    }
    EB.Persist.todoflag = true
}

/**
 * get the parsed JSON info from the given key
 * @param  {string} key
 * @return {anything}
 */
EB.Persist.get = function(key) {
    // TODO: return empty string instead of false

    var realkey = 'PUFF::' + key;
    var str = localStorage.getItem(realkey);
    if(!str) return false;
    return EB.parseJSON(str);
}

/**
 * to remove the item according to the given key
 * @param  {string} key
 */
EB.Persist.remove = function(key) {
    var realkey = 'PUFF::' + key;
    localStorage.removeItem(realkey);
}

/*

    Puffs are the lifeblood of EveryBit. This file contains relatively pure functions for working with them.

    Copyright 2015 EveryBit. See README for license information.

*/

EB.Puff = {}


//// Building puffs

EB.Puff.createPrivate = function(content, type) {
    var payload = {}
    
    var type   = type || 'file'
    var routes = ['local']

    var userRecord = EB.getCurrentUserRecord()
    var userRecordsForWhomToEncrypt = [userRecord]
    var previous, puff
    
    puff = EB.Puff.simpleBuild(type, content, payload, routes, userRecordsForWhomToEncrypt)
    
    return puff
}


EB.Puff.simpleBuild = function(type, content, payload, routes, userRecordsForWhomToEncrypt, privateEnvelopeAlias) {
    //// build a puff for the 'current user', as determined by the key manager (by default EB.M.Wardrobe)
    var puff 

    payload = EB.runHandlers('payloadModifier', payload)

    EB.useSecureInfo(function(identities, currentUsername, privateRootKey, privateAdminKey, privateDefaultKey) {
        // THINK: should we confirm that our local capa matches the DHT's latest capa for the current user here? it turns the output into a promise...
        var previous = false // TODO: get the sig of this user's latest puff
        var versionedUsername = EB.getCurrentVersionedUsername()
        
        puff = EB.Puff.build(versionedUsername, privateDefaultKey, routes, type, content, payload, previous, userRecordsForWhomToEncrypt, privateEnvelopeAlias)
    })
    
    return puff
}


/**
 * build a new puff object based on the parameters  
 * does not hit the network, hence does no real verification whatsoever
 * @param  {string} username                    user who sign the puff
 * @param  {string} privateKey                  private default key for the user
 * @param  {string} routes                      routes of the puff
 * @param  {string} type                        type of the puff
 * @param  {string} content                     content of the puff
 * @param  {object} payload                     other payload information for the puff
 * @param  {string} previous                    most recently published content by the user
 * @param  {object} userRecordsForWhomToEncrypt
 * @param  {object} privateEnvelopeAlias
 * @return {object}                             the new puff object
 */
EB.Puff.build = function(versionedUsername, privateKey, routes, type, content, payload, previous, userRecordsForWhomToEncrypt, privateEnvelopeAlias) {
    var puff = EB.Puff.packageStructure(versionedUsername, routes, type, content, payload, previous)

    puff.sig = EB.Crypto.signPuff(puff, privateKey)
    
    if(userRecordsForWhomToEncrypt) {
        puff = EB.Puff.encrypt(puff, privateKey, userRecordsForWhomToEncrypt, privateEnvelopeAlias)
    }
    
    return puff
}


EB.Puff.packageStructure = function(versionedUsername, routes, type, content, payload, previous) {
    //// pack all the parameters into an object with puff structure (without signature)
    
    payload = payload || {}                     // TODO: check all of these values more carefully
    payload.content = content
    payload.type = type

    routes = routes || []
    previous = previous || false                // false for DHT requests and beginning of blockchain, else valid sig

    var puff = { username: versionedUsername
               ,   routes: routes
               , previous: previous
               ,  version: '0.4.0'              // version accounts for crypto type and puff shape
               ,  payload: payload              // early versions will be aggressively deprecated and unsupported
               }
    
    return puff
}


/**
 * Build user registration puff
 * @param  {string}  username of existing user
 * @param  {string}  private admin key for existing user
 * @param  {string}  desired new user name
 * @param  {string}  public root key for the new user
 * @param  {string}  public admin key for the new user
 * @param  {string}  public default key for the new user
 * @return {object}  puff to register the user
 */
EB.Puff.buildUserRegistration = function(signingUsername, privateAdminKey, newUsername, rootKey, adminKey, defaultKey) {

    // the DHT update puff payload
    var payload = { requestedUsername: newUsername
                  ,        defaultKey: defaultKey
                  ,          adminKey: adminKey
                  ,           rootKey: rootKey
                  ,              time: Date.now()
                  }

    // build the DHT update puff
    var routing = [] // THINK: DHT?
    var content = 'requestUsername'
    var type    = 'updateUserRecord'

    // NOTE: we're skipping previous, because requestUsername-style puffs don't use it.
    var puff = EB.Puff.build(signingUsername, privateAdminKey, routing, type, content, payload)

    return puff
}





//// Encryption and decryption


EB.Puff.isPrivate = function(shell) {
    return shell.payload.type == 'encryptedpuff'
}


EB.Puff.encrypt = function(letter, myPrivateWif, userRecords, privateEnvelopeAlias) {
    //// stick a letter in an envelope. userRecords must be fully instantiated.
    var puffkey = EB.Crypto.getRandomKey()                                        // get a new random key
    
    var letterCipher = EB.Crypto.encryptWithAES(JSON.stringify(letter), puffkey)  // encrypt the letter
    var versionedUsername = letter.username
    
    if(privateEnvelopeAlias) {
        myPrivateWif = privateEnvelopeAlias.privateDefaultKey
        versionedUsername = EB.Users.makeVersioned(privateEnvelopeAlias.username, privateEnvelopeAlias.capa)
    }
    
    var envelope = EB.Puff.packageStructure(versionedUsername, letter.routes      // envelope is also a puff
                           , 'encryptedpuff', letterCipher, {}, letter.previous)  // it includes the letter
    
    envelope.keys = EB.Crypto.createKeyPairs(puffkey, myPrivateWif, userRecords)  // add decryption keys
    envelope.sig = EB.Crypto.signPuff(envelope, myPrivateWif)                     // sign the envelope
    
    return envelope
}

EB.Puff.promiseLetter = function(envelope) {                            // the envelope is a puff
    if(EB.Data.isBadEnvelope(envelope.sig)) 
        return Promise.reject('Bad envelope')                           // flagged as invalid envelope

    var maybeLetter = EB.Data.getDecryptedLetterBySig(envelope.sig)     // have we already opened it?
    
    if(maybeLetter)
        return Promise.resolve(maybeLetter)                             // resolve to existing letter
    
    var prom = EB.Puff.promiseDecryptedLetter(envelope)                 // do the decryption
    
    return prom.catch(function(err) { return false })
               .then(function(letter) {
                   if(!letter) {
                       EB.Data.addBadEnvelope(envelope.sig)             // decryption failed: flag envelope
                       return EB.throwError('Invalid envelope')         // then bail out
                   }

                   return letter
               })
    
}

EB.Puff.promiseDecryptedLetter = function(envelope) {
    //// pull a letter out of the envelope -- returns a promise!

    if(!envelope || !envelope.keys) 
        return EB.emptyPromise('Envelope does not contain an encrypted letter')
    
    var senderVersionedUsername = envelope.username
    var userProm = EB.Users.getUserRecordPromise(senderVersionedUsername)
    
    var puffprom = userProm
    .catch(EB.catchError('User record acquisition failed'))
    .then(function(senderVersionedUserRecord) {
        var prom // used for leaking secure promise

        EB.useSecureInfo(function(identities, currentUsername) {
            // NOTE: leaks a promise which resolves to unencrypted puff
        
            var identity = identities[currentUsername]
            var aliases  = identity.aliases
            var matchingUsername = ''
                
            top: for(var keykey in envelope.keys) {             // match our aliases against all recipients
                for (var i = 0; i < aliases.length; i++) {
                    var alias = aliases[i]
                    
                    if(alias.username == keykey) {              // only for old, unversioned usernames
                        matchingUsername = alias.username
                        break top
                    }
                    
                    var versionUsername = EB.Users.makeVersioned(alias.username, alias.capa)
                    if(versionUsername == keykey) {
                        matchingUsername = versionUsername
                        break top
                    }
                }
            }

            if(!matchingUsername)
                return EB.throwError('No key found for current user')

            var recipientPrivateKey = alias.privateDefaultKey
            var senderPublicKey = senderVersionedUserRecord.defaultKey
            
            prom = EB.Puff.promiseToDecryptForReals(envelope, senderPublicKey, matchingUsername, recipientPrivateKey)
        })

        return prom
    })
    
    return puffprom
}

EB.Puff.promiseToDecryptForReals = function(envelope, senderPublicKey, recipientUsername, recipientPrivateKey) {
    return new Promise(function(resolve, reject) {
        return EB.cryptoworker
             ? EB.workersend( 'decryptPuffForReals'
                            , [ envelope
                              , senderPublicKey
                              , recipientUsername
                              , recipientPrivateKey ]
                            , resolve, reject )
             : resolve( EB.decryptPuffForReals( envelope
                                              , senderPublicKey
                                              , recipientUsername
                                              , recipientPrivateKey ) )
    })
}


//// Shells and puffs


EB.Puff.isFull = function(shell) {
    // A puff has payload.content -- a shell does not
    return ((shell||{}).payload||{}).content !== undefined
}

EB.Puff.isEmpty = function(shell) {
    return !EB.Puff.isFull(shell)
}

EB.Puff.compactPuff = function(puff) {
    // THINK: instead of rebuilding the puff, use a JSON.stringify reducer that strips out the content
    var new_shell = Boron.extend(puff)
    var new_payload = {}
    for(var prop in puff.payload)
        if(prop != 'content')
            new_payload[prop] = puff.payload[prop] 

    new_shell.payload = new_payload
    return new_shell
}


/*

    Comprehensive (in progress!), canonical set of functions defining and validating a puff.

    All of these are STRICTLY FORMAL validations: they don't depend on the state of the universe.

    Copyright 2014-2015 EveryBit. See README for license information.

 */


EB.Spec = {}


/**
 * Validate the username
 * @param  {string} username
 */
EB.Spec.isValidUsername = function(username) {
    /*
    RULES:
    - Minimum length is 1
    - Maximum length of full username (including subusers and .) is 255 characters
    - Only alphanumeric
    - Only lowercase
    - Cannot begin or end with a .
     */

    EB.Spec.isValidUsername.rulesStatement = 'Usernames can only contain lowercase letters, numbers, and periods. They cannot ' +
        'be longer than 255 characters, or begin or end with a period.'

    if(!username)
        return false

    if(username.length > 255)
        return false

    if(!username.match(/^[a-z0-9.]+$/))
        return false

    if(username.slice(0, 1) == '.')
        return false

    if(username.slice(-1) == '.')
        return false

    return true
}


/**
 * Does everything possible to make a username valid
 * Note: This may have unintended consequences for the user
 */
EB.Spec.sanitizeUsername = function(username) {
    /*
     TRANSFORMATIONS:
     - Remove leading and trailing space
     - Convert to lowercase
     - Remove all illegal characters, including leading and trailing .
     */
    username = username.trim()

    username = username.toLowerCase()

    if(username.slice(0, 1) == '.')
        username = username.slice(1)

    if(username.slice(-1) == '.')
        username = username.slice(0,-1)

    username = username.replace(/[^a-z0-9.]+/g, '')

    return username
}


/**
 * check if it is a valid public key
 * @param {string} publicKey
 * @returns {boolean}
 */
EB.Spec.isValidPublicKey = function(publicKey) {
    // TODO: do "checksum" validation

    if(!isset(publicKey)) {
        return false;
    } else {
        return true;
    }

}

/**
 * check if it is a valid private key
 * @param {string} privateKey
 * @returns {boolean}
 */
EB.Spec.isValidPrivateKey = function(privateKey) {
    // TODO: Validate by testing if can be converted to public key

    if(!isset(privateKey)) {
        return false;
    } else {
        return true;
    }
}

/**
 * Check if this is a valid capa
 * @param capa
 * @returns {boolean}
 */
EB.Spec.isValidCapa = function(capa) {

    /*
     RULES:
     - Must be a natural number (1 or greater)
     */

    EB.Spec.isValidCapa.rulesStatement = 'capa must be a natural number.';


    capa = capa.toString(); // Convert to string
    var n1 = Math.abs(n);
    var n2 = parseInt(n, 10);

    if(n2 < 1)
        return false

    return !isNaN(n1) && n2 === n1 && n1.toString() === n;
}



/**
 * check if a username is valid
 *     a username must be shorter than 256 characters, all lowercase and contains only alphanumeric and . sign
 * @param  {string} username the string to be check
 * @return {boolean}          return true if  the parameter string is a valid username, otherwise throw error
 */
EB.Spec.validateUsername = function(username) {
    if(!username) 
        return EB.onError('Username is required', username)

    if(username.length > 256) 
        return EB.onError('Usernames must be shorter than 256 characters', username)

    if(username != username.toLowerCase()) 
        return EB.onError('Usernames must be lowercase', username)
    
    if(!/^[0-9a-z.]+$/.test(username))
        return EB.onError('Usernames must be alphanumeric', username)
    
    return true
}


/**
 * determine if it is a good shell, checks for the existence of required fields
 * @param {Shell[]}
 * @returns {boolean}
 */
EB.Spec.isValidShell = function(shell) {
    //// this just checks for the existence of required fields
    if(!shell.sig) return false
    if(!shell.routes) return false
    if(!shell.username) return false
    if(typeof shell.payload != 'object') return false
    if(!shell.payload.type) return false
        
    return true
}

/**
 * to verify a puff
 * @param  {object} puff
 * @return {(string|boolean)}
 */
EB.Spec.isGoodPuff = function(puff) {
    // CURRENTLY UNUSED
    // TODO: check previous sig, maybe
    // TODO: check for well-formed-ness
    // TODO: use this to verify incoming puffs
    // TODO: if prom doesn't match, try again with getUserRecordNoCache
    
    // TODO: rewrite this function to give a consistent return value
    
    if (!EB.Data.contentTypes[shell.payload.type]) {
        // TODO: this needs to include 'encryptedpuff' as a valid type
        Events.pub('track/unsupported-content-type', {type: shell.payload.type, sig: shell.sig})
        return false
    }
    
    var prom = EB.Users.getUserRecordPromise(puff.username) // NOTE: versionedUsername
    
    return prom.then(function(user) {
        return EB.Crypto.verifyPuffSig(puff, user.defaultKey)
    })
}

/*

    User management for the EveryBit platform.

    Most functions related to userRecords live here.
    Note that userRecords are entirely public;
    private key identities are handled elsewhere.

    Copyright 2014-2015 EveryBit. See README for license information.

 */

EB.Users = {}

EB.Users.records  = {}                              // maps versioned username to an array of DHT userRecords
EB.Users.promises = {}                              // pending userRecord requests


EB.Users.init = function(options) {
    EB.Users.depersist()                            // pop userRecords out of localStorage
}


EB.Users.process = function(userRecord) {
    //// Processes all incoming userRecords
    
    userRecord = EB.Users.build( userRecord.username, userRecord.defaultKey, userRecord.adminKey
                               , userRecord.rootKey,  userRecord.latest,     userRecord.created
                               , userRecord.updated,  userRecord.profile,    userRecord.identity
                               , userRecord.capa )
    
    if(!userRecord)
        return EB.onError('That is not an acceptable user record', userRecord)
    
    EB.Users.cache(userRecord)
    
    return userRecord
}


EB.Users.getCachedUserRecord = function(username) {
    if(EB.Users.makeVersioned(username) == username)    // username is versioned
        return EB.Users.records[username]
    
    return EB.Users.findFreshest(username)              // username isn't versioned
}


/**
 * Checks the cache, and always returns a promise
 * @param {string} username
 * @param {int} capa is the version of the username keys
 * @returns {object} Promise for a user record
 * Looks first in the cache, then grabs from the network
 */
EB.Users.getUserRecordPromise = function(username, capa) {
    //// This always checks the cache, and always returns a promise
    
    var versionedUsername = EB.Users.makeVersioned(username, capa)
    
    var userRecord = EB.Users.getCachedUserRecord(versionedUsername)
    
    if(userRecord)
        return Promise.resolve(userRecord)
    
    var userPromise = EB.Users.promises[versionedUsername]
    
    if(userPromise)
        return userPromise
    
    return EB.Users.getUserRecordNoCache(versionedUsername)
}


/**
 * Forces a request to the network, ignores cached
 * @param {string} username
 * @param {int} capa is the version of the username keys
 * @returns {object} Promise for a user record
 */
EB.Users.getUserRecordNoCache = function(username, capa) {
    //// This never checks the cache
    
    capa = capa || 0 // 0 signals EB.Net.getUserRecord to get the latest userRecord
    
    var prom = EB.Net.getUserRecord(username, capa) 
    
    prom = prom.then(
                function(userRecord) {
                    var userRecord = EB.Users.process(userRecord)
                    if(!userRecord)  EB.throwError('Invalid user record returned')
                    return userRecord
                }
                , EB.catchError('Unable to access user information from the DHT'))
    
    var versionedUsername = EB.Users.makeVersioned(username, capa)
    EB.Users.promises[versionedUsername] = prom
    
    return prom
}

EB.Users.doesUserExist = function(username) {
    return EB.Net.getUserRecord(username).then(
                function(userRecord) {
                    if(!userRecord || userRecord.FAIL) 
                        throw 'User does not exist'
                    return true
                }
                , EB.catchError('Unable to access user information from the DHT'))
}


//
// USERNAME HELPERS
//

EB.Users.userRecordToVersionedUsername = function(userRecord) {
    return EB.Users.makeVersioned(userRecord.username, userRecord.capa)
}

EB.Users.justUsername = function(versionedUsername) {
    var uc = EB.Users.breakVersionedUsername(versionedUsername)
    return uc.username
}

EB.Users.justCapa = function(versionedUsername) {
    var uc = EB.Users.breakVersionedUsername(versionedUsername)
    return uc.capa
}

EB.Users.makeVersioned = function(username, capa) {
    if(!username || !username.indexOf)
        return ''
    
    if(capa)
        return actuallyVersionThisUsernameOkay(username, capa)
    
    if(username.indexOf(':') > 0)
        return username
    
    return actuallyVersionThisUsernameOkay(username)
    
    function actuallyVersionThisUsernameOkay(username, capa) {
        capa = capa || 1 // NOTE: default capa
        return username + ':' + capa
    }
}

EB.Users.breakVersionedUsername = function(versionedUsername) {
    var list = (versionedUsername||'').split(':')

    return { username: list[0]
           , capa:     list[1] || 1 // NOTE: default capa
           }
}


//
// GENERAL HELPERS
//


EB.Users.build = function(username, defaultKey, adminKey, rootKey, latest, created, updated, profile, identity, capa) {
    //// returns a canonical user object: use this everywhere user objects are needed (DHT, identities, etc)

    latest   = latest   || ""                       // signature of the most recent puff published by the user
    updated  = updated  || ""                       // date of the most recent update to the username
    profile  = profile  || ""                       // profile puff signature
    identity = identity || ""                       // identity puff signature
    capa     = capa     || 1                        // version of the username
    
    // THINK: should we check for valid keys? valid timestamp for updated? what if you want a partially invalid user like anon?
    
    // THINK: split username and capa if it's a versionedUsername?

    if(!EB.Spec.validateUsername(username))
        return false                                // error is logged inside EB.Spec.validateUsername
    
    return {   username: username                   // unversioned username
           ,       capa: capa
           ,    rootKey: rootKey                    // public root key
           ,   adminKey: adminKey                   // public admin key
           , defaultKey: defaultKey                 // public default key
           ,    created: created                    // Date the record was created
           ,     latest: latest
           ,    updated: updated
           ,    profile: profile
           ,   identity: identity
           }
}


EB.Users.usernamesToUserRecordsPromise = function(usernames) {
    //// returns a promise of userRecords. thanks to capa we usually don't need the latest and can use cached versions.
    if(!usernames || !usernames.length)
        return Promise.resolve([])
    
    if(!Array.isArray(usernames))
        usernames = [usernames]
        
    var userRecords = usernames.map(EB.Users.getCachedUserRecord).filter(Boolean)
    
    if (userRecords.length == usernames.length)
        return Promise.resolve(userRecords) // got 'em all!
    
    var prom = Promise.resolve() // a promise we use to string everything along

    var userRecordUsernames = userRecords.map(function (userRecord) {
        return userRecord.username
    })
    
    usernames.forEach(function (username) {
        if (!~userRecordUsernames.indexOf(username)) { // we need this one
            prom = prom.then(function() {
                return EB.Users.getUserRecordNoCache(username).then(function (userRecord) {
                    userRecords.push(userRecord)
                })
            })
        }
    })
    
    return prom.then(function() { return userRecords }) // when it's all done, give back the userRecords
}

EB.Users.cache = function(userRecord) {
    //// This caches with no validation: use EB.Users.process instead
    
    var versionedUsername = EB.Users.userRecordToVersionedUsername(userRecord)
    
    EB.Users.records[versionedUsername] = userRecord
    
    delete EB.Users.promises[versionedUsername]
    
    EB.Persist.save('userRecords', EB.Users.records)
    
    return userRecord
}

EB.Users.depersist = function() {
    //// grab userRecords from local storage. this smashes the current userRecords in memory, so don't call it after init!
    EB.Users.records = EB.Persist.get('userRecords') || {}
}


EB.Users.findFreshest = function(username) {
    username = EB.Users.justUsername(username)
    
    var keys = Object.keys(EB.Users.records)
    var capa = 0
    
    keys.filter(function(versionedUsername) {
        return EB.Users.justUsername(versionedUsername) == username
    }).forEach( function(versionedUsername) {
        var this_capa = +EB.Users.justCapa(versionedUsername)
        if(this_capa > capa)
            capa = this_capa
    })
    
    var versionedUsername = EB.Users.makeVersioned(username, capa)
    return EB.Users.records[versionedUsername]
}


EB.Users.getIdentityPuff = function(userRecord, privateKey) {
    //// userRecord is the user's canonical user record
    //// privateKey is the user's private default key
    
    if(!userRecord || !userRecord.defaultKey || !userRecord.username)
        return EB.emptyPromise('Invalid user record')
    
    if(!userRecord.identity)
        return EB.emptyPromise('User record has no identity')
    
    puffprom = EB.Net.getPuffBySig(userRecord.identity)

    return puffprom.then(function(puffs) {
        var envelope = puffs[0]
        if(!envelope || !envelope.sig)
            return EB.throwError('Invalid identity puff')
        
        var senderPublicKey = userRecord.defaultKey
        var recipientUsername = EB.Users.makeVersioned(userRecord.username, userRecord.capa)
        var recipientPrivateKey = privateKey

        return EB.Puff.promiseToDecryptForReals(envelope, senderPublicKey, recipientUsername, recipientPrivateKey)
    })        
}


/**
 * register a subuser
 * @param  {string} signingUsername username of existed user
 * @param  {string} privateAdminKey private admin key for existed user
 * @param  {string} newUsername     desired new subuser name
 * @param  {string} rootKey         public root key for the new subuser
 * @param  {string} adminKey        public admin key for the new subuser
 * @param  {string} defaultKey      public default key for the new subuser
 * @return {object}                user record for the newly created subuser
 */
EB.Users.registerSubuserForUser = function(signingUsername, privateAdminKey, newUsername, rootKey, adminKey, defaultKey) {
    var puff = EB.Puff.buildUserRegistration(signingUsername, privateAdminKey, newUsername, rootKey, adminKey, defaultKey)
    return EB.Net.updateUserRecord(puff)
}



//// ANONYMOUS USERS


/**
 * Add a new user and attach it to the current identity as an alias
 * This is by the most common use case, since most anon users are created to send/receive messages
 * @param {string} Optional private default key
 * @param {string} Optional private admin key
 * @param {string} Optional private root key
 * @returns {promise} Resolves to the user record or fails
 */
EB.Users.addAnonymousUser = function(privateDefaultKey, privateAdminKey, privateRootKey) {
    var currentUsername = EB.getCurrentUsername()
    return EB.Users.addAnonymousUserToIdentity(currentUsername, privateDefaultKey, privateAdminKey, privateRootKey)
}


/**
 * Add a new user and attach to an identity as an alias
 * @param {string} The username of the identity to which to attach
 * @param {string} Optional private default key
 * @param {string} Optional private admin key
 * @param {string} Optional private root key
 * @returns {promise} Resolves to the user record or fails
 */
EB.Users.addAnonymousUserToIdentity = function(username, privateDefaultKey, privateAdminKey, privateRootKey) {
    var callback = function(userRecord, privateDefaultKey, privateAdminKey, privateRootKey) {
        EB.addAlias(username, userRecord.username, null, privateRootKey, privateAdminKey, privateDefaultKey)
        return userRecord
    }
    
    return EB.Users.addAnonymousUserToDHT(callback, privateDefaultKey, privateAdminKey, privateRootKey)
}


/**
 * Register a new anonymous user
 * @param {string} This callback takes userRecord, privateDefaultKey, privateAdminKey, and privateRootKey as args
 * @param {string} Optional private default key
 * @param {string} Optional private admin key
 * @param {string} Optional private root key
 * @returns {promise} Resolves to the user record or fails
 */
EB.Users.addAnonymousUserToDHT = function(callback, privateDefaultKey, privateAdminKey, privateRootKey) {
    // get username
    var newUsername = 'anon.' + EB.Users.generateRandomUsername(12)
    
    // generate private keys
    privateDefaultKey = privateDefaultKey || EB.Crypto.generatePrivateKey()
    privateAdminKey   = privateAdminKey   || EB.Crypto.generatePrivateKey()
    privateRootKey    = privateRootKey    || EB.Crypto.generatePrivateKey()
    
    // generate public keys
    var defaultKey = EB.Crypto.privateToPublic(privateDefaultKey)
    var adminKey   = EB.Crypto.privateToPublic(privateAdminKey)
    var rootKey    = EB.Crypto.privateToPublic(privateRootKey)
    
    var puff = EB.Puff.buildUserRegistration('anon', EB.CONFIG.anonPrivateAdminKey, newUsername, rootKey, adminKey, defaultKey)
    
    // send DHT update puff
    return EB.Net.updateUserRecord(puff).then(function(userRecord) {
        if(callback)
            return callback(userRecord, privateDefaultKey, privateAdminKey, privateRootKey)
        return userRecord
    })
}


/**
 * Generate a random username
 * @param {number} length of username
 * @return {string}
 */
EB.Users.generateRandomUsername = function(size) {
    size = +size|0||0

    var generatedName = ''
    var alphabet = 'abcdefghijklmnopqrstuvwxyz0123456789'
    for(var i=0; i<size; i++) {
        generatedName += EB.Crypto.getRandomItem(alphabet)
    }
    return generatedName
}



EB.Users.createAnonUserAndMakeCurrent = function() {
    // TODO: convert this to use EB.Users.addAnonymousUserToDHT
    
    var newUsername = 'anon.' + EB.Users.generateRandomUsername(12)
    var passphrase = EB.Crypto.generatePrivateKey().slice(-12)
    var prependedPassphrase = newUsername + passphrase
    var privateKey = EB.Crypto.passphraseToPrivateKeyWif(prependedPassphrase)
    var publicKey = EB.Crypto.privateToPublic(privateKey)

    // Build puff to register this user
    var puff = EB.Puff.buildUserRegistration('anon', EB.CONFIG.anonPrivateAdminKey, newUsername, publicKey, publicKey, publicKey)

    var prom = EB.Net.updateUserRecord(puff)

    // Works?
    return prom.then(function(userRecord) {
        // Switch to this user
        EB.addAlias(userRecord.username, userRecord.username, 1, privateKey, privateKey, privateKey, {passphrase: passphrase})

        EB.switchIdentityTo(userRecord.username)

        return userRecord
    })
}

/* 
     _  _  ____  ____  ____   __    ___  ____  ____ 
    ( \/ )(  __)/ ___)/ ___) / _\  / __)(  __)/ ___)
    / \/ \ ) _) \___ \\___ \/    \( (_ \ ) _) \___ \
    \_)(_/(____)(____/(____/\_/\_/ \___/(____)(____/  
  
  When included this module adds two passive enhancements:
  - all puffs receive a payload.time field containing the current time in milliseconds
  - any puff containing an array of signatures in the payload.parents field will have have those parents lifted in to the graph

*/

EB.M.Messages = {}

EB.M.Messages.init = function() {
    EB.addRelationshipHandler(EB.M.Messages.addFamilialEdges)              // manages parent-child relationships
    EB.addPayloadModifierHandler(EB.M.Messages.addTimestamp)               // add timestamp to all new puffs
}


EB.M.Messages.addTimestamp = function(payload) {
    payload = payload || {}
    payload.time = payload.time || Date.now()
    return payload
}


EB.M.Messages.addFamilialEdges = function(shells) {
    shells.forEach(EB.M.Messages.addFamilialEdgesForShell)
}

EB.M.Messages.addFamilialEdgesForShell = function(child) {
    var addParentEdges = EB.M.Messages.addFamilialEdgesForParent(child);
    (child.payload.parents||[]).forEach(addParentEdges);
}

EB.M.Messages.addFamilialEdgesForParent = function(child) {
    var existingParents = EB.Data.graph.v(child.sig).out('parent').property('shell').run().map(EB.prop('sig'))
    
    return function(parentSig) {
        if(~existingParents.indexOf(parentSig)) return false                       // done?
        EB.Data.addSigAsVertex(parentSig)                                          // idempotent
        EB.Data.graph.addEdge({_label: 'parent', _in: parentSig, _out: child.sig}) // not idempotent
        EB.Data.graph.addEdge({_label: 'child', _out: parentSig,  _in: child.sig})
    }
}





///////////////////////////////////////////////////////////////////////////////////







EB.M.Messages.flagPuff = function (sig) {
    // TODO: move this out of the Message module and rewrite it

    var payload = {};
    var routes = [];
    var type = 'flagPuff';
    var content = sig;
    var puff; // variable for leaking the signed puff out of the secure zone
    
    payload.time = Date.now();

    EB.useSecureInfo(function(identities, currentUsername, privateRootKey, privateAdminKey, privateDefaultKey) {    

        if(!currentUsername) {
            alert("You must first set your username before you can flag content");
            return false;
        }
        /*if(!currentUsername == EB.getPuffBySig(sig).username) {
            alert("You must set your identity to the author of the puff you want to flag");
        }*/
        if(!privateAdminKey) {
            alert("You must first set your private admin key before you can flag content");
            return false;
        }
    
        puff = EB.Puff.build(currentUsername, privateAdminKey, routes, type, content, payload);
    })

    var data = { type: 'flagPuff'
               , puff: puff
               };

    var prom = EB.Net.EBpost(EB.CONFIG.puffApi, data);
    
    prom = prom.then(function(result){
        // var storedShells = EB.Persist.get('shells');
        // var filteredShells = storedShells.filter(function(s){return s.sig != content && s.content != content});
        var flaggedSig = EB.Persist.get('flagged') || [];
        flaggedSig.push(content);

        // EB.Persist.save('shells', filteredShells);
        EB.Persist.save('flagged', flaggedSig);
        // reload?
        // document.location.reload();
        Events.pub('ui/flag', {});
        return result;
    })
    return prom;
}

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

// DETRITUS TO BE DEALT WITH
    
   
// /**
//  * Filter puffs according to criteria
//  * @param  {string} query
//  * @param  {string} filters
//  * @param  {number} limit
//  * @return {array} An array of puffs
//  */
// EB.M.Forum.getPuffList = function(query, filters, limit) {
//     //// returns a list of puffs
//
//     // THINK: the graph can help us here, but only if we're more clever about forming relationships and using those in our filters.
//
//     limit = limit || Infinity
//     var offset = +query.offset||0
//
//     // var shells = EB.M.Forum.getShells(query, filters)
//     var shells = EB.Data.getAllMyShells()
//
//     var filtered_shells = shells.filter(EB.M.Forum.filterByFilters(Boron.extend({}, query, filters)))
//                                 .sort(EB.M.Forum.sortByPayload) // TODO: sort by query
//
//     var sliced_shells = filtered_shells.slice(offset, offset+limit)
//
//     var puffs = sliced_shells.map(EB.Data.getPuffFromShell)
//                              .filter(Boolean)
//
//     var have = sliced_shells.length
//     // var have = puffs.length
//     if(have >= limit)
//         return puffs  // as long as we have enough filtered shells the puffs will eventually fill in empty spots
//
//     EB.Data.fillSomeSlotsPlease(limit, have, query, filters)
//
//     return puffs;
// }
//

// /**
//  * Filter puffs by prop filters
//  * @param  {string} filters
//  * @return {boolean}
//  */
// EB.M.Forum.filterByFilters = function(filters) {
//
//     if(!filters) return function() {return true}
//
//     //// get a filtering function
//     return function(shell) {
//
//         // ROUTES
//         if (filters.routes && filters.routes.length > 0) {
//             var routeMatch = false;
//             for (var i = 0; i < filters.routes.length; i++) {
//                 if (shell.routes.indexOf(filters.routes[i]) > -1) routeMatch = true;
//             }
//             if (!routeMatch) return false;
//         }
//
//         // TAGS
//         if (filters.tags && filters.tags.length > 0) {
//             if (!shell.payload.tags || !shell.payload.tags.length) {
//                 return false;
//             }
//             var tagMatch = false;
//             for (var i = 0; i < filters.tags.length; i++) {
//                 if (shell.payload.tags.indexOf(filters.tags[i]) > -1) tagMatch = true;
//             }
//             if (!tagMatch) return false;
//         }
//
//         // TYPES
//         if (filters.types && filters.types.length > 0) {
//             if (!~filters.types.indexOf(shell.payload.type)) {
//                 // console.log(shell.type)
//                 return false
//             }
//         }
//
//         // USERS
//         if(filters.users && filters.users.length > 0)
//             if(!~filters.users.indexOf(EB.Users.justUsername(shell.username))) return false
//
//
//         if(filters.roots)
//             if((shell.payload.parents||[]).length) return false
//
//         if(filters.ancestors && filters.focus) {
//             var focus = EB.getPuffBySig(filters.focus) // TODO: find better way to do this
//             if(focus.payload && !~focus.payload.parents.indexOf(shell.sig)) return false
//         }
//
//         if(filters.descendants && filters.focus)
//             if(!~shell.payload.parents.indexOf(filters.focus)) return false
//
//         // TODO: deprecate this, as it's handled above:
//         if (filters.type && filters.type.length)
//             if (!~filters.type.indexOf(shell.payload.type)) return false
//
//         return true
//     }
// }


// /**
//  * Helper for sorting by payload.time
//  * @param  {Object} a
//  * @param  {object} b
//  * @return {number} based on desired sorting order
//  */
// EB.M.Forum.sortByPayload = function(a,b) {
//     //// helper for sorting by payload.time
//     if(puffworldprops.view.query.sort == 'DESC')
//         return b.payload.time - a.payload.time;
//     else
//         return a.payload.time - b.payload.time;
// }



// /**
//  * Get the current puff's parents
//  * @param  {Object} puff
//  * @param  {Object} props
//  * @return {number} The number of parents
//  */
// EB.M.Forum.getParentCount = function(puff, props) {
//     if(!puff) return 0
//
//     var sig = puff.sig || puff
//
//     return EB.Data.graph.v(sig).out('parent').run().length
// }


// /**
//  * Get a count of the current puff's children
//  * @param  {Object} puff
//  * @return {number} The number of children
//  */
// EB.M.Forum.getChildCount = function(puff) {
//     if(!puff) return 0
//
//     var sig = puff.sig || puff
//
//     return EB.Data.graph.v(sig).out('child').run().length
// }


// // Adding default metafields to included in a puff
// EB.M.Forum.metaFields = []
// EB.M.Forum.context = {};
// EB.M.Forum.addMetaFields = function(fieldInfo, context, excludeContext) {
//     // NOTE: this isn't used outside of publishEmbed.js, but it might provide a good basis for generic/required metadata
//
//     if (!fieldInfo.name) return console.log('Invalid meta field name.');
//
//     // supported type: text, textarea, pulldown, array
//     if (!fieldInfo.type) return console.log('Invalid meta field type.');
//
//     if (!fieldInfo.validator || typeof fieldInfo.validator != 'function') {
//         fieldInfo.validator = false;
//     }
//
//     context = context || Object.keys(EB.Data.contentTypes);
//     if (typeof context == 'string') {
//         context = [context];
//     } else if (!Array.isArray(context)) {
//         return EB.onError('Invalid context.')
//     }
//
//     excludeContext = excludeContext || [];
//     if (typeof excludeContext == 'string') {
//         excludeContext = [excludeContext];
//     }else if (!Array.isArray(excludeContext)) {
//         return EB.onError('Invalid context.')
//     }
//
//     EB.M.Forum.metaFields.push(fieldInfo);
//     for (var i=0; i<context.length; i++) {
//         if (excludeContext.indexOf(context[i]) != -1)
//             continue;
//         var contextFields = EB.M.Forum.context[context[i]] || [];
//         contextFields.push(fieldInfo.name);
//         EB.M.Forum.context[context[i]] = contextFields;
//     }
// }
//
// EB.M.Forum.addMetaFields(
//     {name: 'reply privacy',
//      type: 'pulldown',
//      enum: ['', 'public', 'private', 'anonymous', 'invisible'],
//      defaultValue: ''});
//
// EB.M.Forum.addMetaFields(
//     {name: 'content license',
//      type: 'pulldown',
//      enum: ['', 'CreativeCommonsAttribution', 'GNUPublicLicense', 'Publicdomain', 'Rights-managed', 'Royalty-free'],
//      defaultValue: ''});
//
// EB.M.Forum.addMetaFields(
//     {name: 'tags',
//      type: 'array',
//      validator: function(v){return /^[a-z0-9]+$/i.test(v)}
//      },
//     false, 'profile');
//
// EB.M.Forum.addMetaFields(
//     {name: 'language',
//      type: 'text',
//      defaultValue: function(){return puffworldprops.view.language}});
//
// EB.M.Forum.addMetaFields(
//     {name: 'name',
//      type: 'text'},
//     'profile');


// /**
//  * Takes a string of content, create a puff and push it into the system
//  * @param {string} type
//  * @param {string} content
//  * @param {array} parents
//  * @param {Object} metadata
//  * @param {string[]} userRecordsForWhomToEncrypt
//  * @param {string[]} privateEnvelopeAlias
//  * @returns {promise}
//  */
// EB.M.Forum.addPost = function(type, content, parents, metadata, userRecordsForWhomToEncrypt, privateEnvelopeAlias) {
//     //// Given a string of content, create a puff and push it into the system
//
//     // ensure parents is an array
//     if(!parents) parents = []
//     if(!Array.isArray(parents)) parents = [parents]
//
//     // ensure parents contains only puff ids
//     if(parents.map(EB.getPuffBySig).filter(function(x) { return x != null }).length != parents.length)
//         return EB.emptyPromise('Those are not good parents')
//
//     // ensure parents are unique
//     parents = EB.uniquify(parents)
//
//     // find the routes using parents
//     var routes = parents.map(function(id) {
//         return EB.getPuffBySig(id).username
//     });
//     if (metadata.routes) {
//         routes = metadata.routes // THINK: this should probably merge with above instead of replacing it...
//         delete metadata['routes']
//     }
//
//     // ensure all routes are unique
//     routes = EB.uniquify(routes)
//
//     var takeUserMakePuff = EB.M.Forum.partiallyApplyPuffMaker(type, content, parents, metadata, routes, userRecordsForWhomToEncrypt, privateEnvelopeAlias)
//
//     // get a user promise
//     var userprom = EB.Users.getUpToDateUserAtAnyCost()
//
//     var prom = userprom.catch(EB.catchError('Failed to add post: could not access or create a valid user'))
//                        .then(takeUserMakePuff)
//                        .catch(EB.catchError('Posting failed'))
//
//     return prom
//
//     // NOTE: any puff that has 'time' and 'parents' fields fulfills the forum interface
//     // TODO: make an official interface fulfillment thing
// }
//
//
// /**
//  * Make a puff... except the parts that require a user
//  * @param {string} type
//  * @param {string} content
//  * @param {array} parents
//  * @param {object} metadata
//  * @param {array} routes
//  * @param {array} userRecordsForWhomToEncrypt
//  * @param {array} privateEnvelopeAlias
//  * @returns {Function}
//  */
// EB.M.Forum.partiallyApplyPuffMaker = function(type, content, parents, metadata, routes, userRecordsForWhomToEncrypt, privateEnvelopeAlias) {
//     //// Make a puff... except the parts that require a user
//
//     // THINK: if you use the same metadata object for multiple puffs your cached version of the older puffs will get messed up
//
//     var payload = metadata || {}                            // metadata becomes the basis of payload
//     payload.parents = payload.parents || parents            // ids of the parent puffs
//     payload.time = metadata.time || Date.now()              // time is always a unix timestamp
//     payload.tags = metadata.tags || []                      // an array of tags // TODO: make these work
//
//     var type  = type || 'text'
//     var routes = routes ? routes : [];
//     routes = routes.concat(EB.CONFIG.zone);
//
//     return function(userRecord) {
//         // userRecord is always an up-to-date record from the DHT, so we can use its 'latest' value here
//
//         var previous = userRecord.latest
//         var puff = EB.Puff.simpleBuild(type, content, payload, routes, userRecordsForWhomToEncrypt, privateEnvelopeAlias)
//
//         return EB.Data.addPuffToSystem(puff) // THINK: this fails silently if the sig exists already
//     }
// }

/* 
                   _____  _____                          .___            ___.           
    ______  __ ___/ ____\/ ____\_  _  _______ _______  __| _/______  ____\_ |__   ____  
    \____ \|  |  \   __\\   __\\ \/ \/ /\__  \\_  __ \/ __ |\_  __ \/  _ \| __ \_/ __ \ 
    |  |_> >  |  /|  |   |  |   \     /  / __ \|  | \/ /_/ | |  | \(  <_> ) \_\ \  ___/ 
    |   __/|____/ |__|   |__|    \/\_/  (____  /__|  \____ | |__|   \____/|___  /\___  >
    |__|                                     \/           \/                  \/     \/ 
  
  An EveryBit module for managing identities and private data locally.
  ==================================================

  The Wardrobe manages identities, aliases, and private data.

  An identity is a username and a list of all known aliases. The identity also lists the last known primary alias, if there is one, and the identity's private preferences. 

  An alias is a username, a 'capa', and a set of private keys. Additional private information (like a passphrase) may be stored in the alias's 'secrets' field.

  Aliases generally correspond either to previous versions of the identity's username (previous primaries), or to anonymous usernames created for one-time encrypted transfer. 

  Username and capa define a unique alias. The capa field references a specific moment in the username's lifecycle, and correlates to the userRecord with the same username and capa whose public keys match the alias's private keys. In other words, capa == version.

  Currently capa counts by consecutive integers. This may change in the future. Any set deriving Eq and Ord will work.

  An identity file can be exported to the local filesystem and imported back in to the system.

  Private data is a black box for 

  Usage examples:
      EB.switchIdentityTo(username)

*/

/*
  THINK:
    - register callback handlers for user record creation and modification
    - EB.M.Wardrobe.init registers those with EB.onUserCreation and EB.onUserModification
    - identity file encryption using a passphrase
*/


EB.M.Wardrobe = {}

~function() { // begin the closure

    var identities = {}
    var aliases = {}
    // {asdf: { username: 'asdf', primary: asdf-12, aliases: [asdf-11, asdf-10], preferences: {} } }

    // an alias: { username: 'asdf', capa: 12, privateRootKey: '123', privateAdminKey: '333', privateDefaultKey: '444', secrets: {} }

    var currentUsername = false


    // TODO: integrate capa with userRecords and puffs everywhere
    // TODO: use capa returned from server on update passphrase
    // TODO: get anon creation working


    EB.M.Wardrobe.init = init
    
    function init() {
        EB.implementSecureInterface(useSecureInfo, addIdentity, addAlias, setPrimaryAlias, setPreference, switchIdentityTo, removeIdentity)
        
        EB.addIdentityUpdateHandler(function() { // THINK: where should this live?
            if(!EB.CONFIG.disableCloudIdentity)
                EB.storeIdentityFileInCloud()
        })
        
        // TODO: find a better way to do this
        var oldConfigValue = EB.CONFIG.disableCloudIdentity
        EB.CONFIG.disableCloudIdentity = true
        
        var storedIdentities = EB.Persist.get('identities') || {}
    
        Object.keys(storedIdentities).forEach(function(username) {
            var identity = storedIdentities[username]
            addIdentity(username, identity.aliases, identity.preferences, true)
        })
        
        EB.CONFIG.disableCloudIdentity = oldConfigValue
        
        var lastUsername = EB.Persist.get('currentUsername')
        
        if (lastUsername)
            EB.switchIdentityTo(lastUsername) // NOTE: call wrapped version to get handlers
    }
    
    
    //// exported via implementSecureInterface

    var useSecureInfo = function(callback) {
        var identity = getCurrentIdentity() || {}
        var primary = identity.primary || {}

        // we have to return all the identities because the user might be trying to list them
        callback(identities, currentUsername, primary.privateRootKey, primary.privateAdminKey, primary.privateDefaultKey)
        
        return true
    }

    var addIdentity = function(username, aliases, preferences, nosave) { // TODO: check if nosave is needed
        // TODO: validation on all available values
        // TODO: check for existing identity
        // TODO: add any unknown aliases
        // THINK: what about aliases that belong to other identities?
        // THINK: ensure primary alias exists?
        // TODO: remove primary (use username+maxcapa instead)

        var identity = { username: username
                       , primary: {}
                       , aliases: []
                       , preferences: preferences || {}
                       }

        identities[username] = identity
        
        if(!Array.isArray(aliases))
            aliases = aliases ? [aliases] : []
        
        aliases.forEach(
            function(alias) {
                addAlias(username, alias.username, alias.capa, alias.privateRootKey, alias.privateAdminKey, alias.privateDefaultKey, alias.secrets)})
        
        // TODO: handle prefs
        
        if(!nosave) // TODO: change processUpdates so it only saves if we're not busy opening all identities? or just let the 100ms throttle handle it...
            processUpdates()
            
        return true
    }

    var addAlias = function(identityUsername, aliasUsername, capa, privateRootKey, privateAdminKey, privateDefaultKey, secrets) {
        // TODO: validation on all available values
        // TODO: check for existing username/capa
        // THINK: hit network for confirmation?
        // THINK: maybe only include viable values?

        var alias = { username: aliasUsername
                    , capa: capa || 1 // NOTE: default capa
                    , privateRootKey: privateRootKey || false
                    , privateAdminKey: privateAdminKey || false
                    , privateDefaultKey: privateDefaultKey || false
                    , secrets: secrets || {}
                    }

        var identity = getIdentity(identityUsername)
        
        if(!identity) {
            addIdentity(identityUsername)                   // creates an empty identity
            identity = getIdentity(identityUsername)
        }
        
        // merge alias
        var old_alias = getOldAlias(identity, alias)
        if(old_alias) {
            alias.secrets = Boron.extend(old_alias.secrets, alias.secrets)
            for(var key in alias) 
                if(alias[key])
                    old_alias[key] = alias[key]
        } else {
            identity.aliases.push(alias)
        }
        
        if(aliasUsername == identityUsername && alias.capa >= (identity.capa||0)) {
            identity.primary = alias                        // set primary for identity (which may have been empty)
        }
        
        aliases[aliasUsername] = identity                   // add this to the alias-identity mapping

        processUpdates()

        return true
    }

    var setPrimaryAlias = function(identityUsername, aliasUsername) {
        var identity = getIdentity(identityUsername)
        
        if(!identity)
            return EB.onError('Primary alias can only be set for known identities')
            
        var alias = getLatestAlias(identity, aliasUsername)
        
        if(!alias)
            return EB.onError('That alias is not associated with that identity')
    
        // all clear!
        
        identity.username = aliasUsername
        identity.primary = alias

        delete identities[identityUsername]
        identities[aliasUsername] = identity
        
        if(identityUsername == currentUsername)
            switchIdentityTo(aliasUsername)
        
        return true
    }
     
    var setPreference = function(key, value) {
        // NOTE: this only works for the current identity
        var identity = getCurrentIdentity()
    
        if(!identity)
            return EB.onError('Preferences can only be set for an active identity')
    
        identity.preferences[key] = value

        processUpdates()
    }
    
    var switchIdentityTo = function(username) {
        if(username) {
            var identity = getIdentity(username)

            if(!identity)
                return EB.onError('No identity found with username "' + username + '"')
        }
        
        currentUsername = username || false

        if(!EB.currentIdentityHash) // THINK: what are the cases?
            EB.currentIdentityHash = EB.Crypto.createMessageHash(JSON.stringify(EB.formatIdentityFile()))
        
        processUpdates()
        
        if(username && identity && identity.primary)
            EB.Users.getUserRecordPromise(username, identity.primary.capa) // fetch our userRecord 

        return true
    }
    
    var removeIdentity = function(username) {
        var identity = getIdentity(username)

        if(!identity)
            return EB.onError('Could not find that identity for removal')

        delete identities[username]

        if(currentUsername == username)
            currentUsername = false

        processUpdates()
    }

    ////
    //// internal helper functions. not exported.
    ////

    function getLatestAlias(identity, aliasUsername) {
        var maxcapa = 0
        var alias = false
        
        for(var i=0, l=identity.aliases.length; i<l; i++) {
            var test = identity.aliases[i]
            if(test.username == aliasUsername && test.capa > maxcapa) {
                alias = test
                maxcapa = test.capa
            }
        }
        
        return alias
    }

    function getOldAlias(identity, alias) {
        for(var i=0, l=identity.aliases.length; i<l; i++) {
            var test = identity.aliases[i]
            if(alias.username == test.username && alias.capa == test.capa)
                return test
        }
    }

    function validatePrivateKeys(username, capa, privateRootKey, privateAdminKey, privateDefaultKey) {
        // CURRENTLY UNUSED
        //// Ensure keys match the userRecord
    
        var prom = EB.Users.getUserRecordPromise(username, capa)
    
        return prom
            .then(function(userRecord) {
                // validate any provided private keys against the userRecord's public keys
                if(   privateRootKey && EB.Crypto.privateToPublic(privateRootKey) != userRecord.rootKey)
                    EB.throwError('That private root key does not match the public root key on record')
                if(  privateAdminKey && EB.Crypto.privateToPublic(privateAdminKey) != userRecord.adminKey)
                    EB.throwError('That private admin key does not match the public admin key on record')
                if(privateDefaultKey && EB.Crypto.privateToPublic(privateDefaultKey) != userRecord.defaultKey)
                    EB.throwError('That private default key does not match the public default key on record')
        
                return userRecord
            }
            , EB.catchError('Could not store private keys due to faulty user record'))
    }

    function processUpdates() {
        if(!EB.CONFIG.ephemeralKeychain)
            EB.Persist.save('identities', identities)

        // THINK: consider zipping identities in localStorage to prevent shoulder-surfing and save space (same for puffs)
        // THINK: consider passphrase protecting identities and private puffs in localStorage
        // TODO: don't persist primary -- regenerate it at load time, so we don't duplicate the alias
        EB.Persist.save('currentUsername', currentUsername)

        EB.runHandlers('identityUpdate')
    }

    function getCurrentIdentity() {
        return getIdentity(currentUsername)
    }

    function getIdentity(username) {
        if(!username) 
            return false

        var identity = identities[username]

        // THINK: we could check the aliases map here in case the username isn't primary

        if(!identity) 
            return false

        return identity
    }

}() // end the closure
EB.Data.addContentType('bbcode', {
    toHtml: function(content) {
        var bbcodeParse = XBBCODE.process({ text: content });
        var parsedText  = bbcodeParse.html.replace(/\n/g, '<br />'); 
        return parsedText;
    }
})

EB.Data.addContentType('file', {
    toHtml: function(content, puff) {
        return puff.payload.filename
    }
})

EB.Data.addContentType('identity', {
    toHtml: function() {
        return ''
    }
})

EB.Data.addContentType('image', {
    toHtml: function(content) {
        if(puffworldprops.view.mode == "tableView")
            return '<img src=' + content + ' />';
        else
            return '<img class="imgInBox" src=' + content + ' />';
    }
})

// TODO: Add support for LaTex
/*EB.Data.addContentType('LaTex', {
    toHtml: function(content) {
        var safe_content = XBBCODE.process({ text: content }) 
        return '<p>' + safe_content.html + '</p>'
    }
}) */

EB.Data.addContentType('markdown', {
    toHtml: function(content) {
        var converter = new Markdown.Converter();
        return '<span>'+converter.makeHtml(content)+'</span>';
    }
})

// Used to display chess boards
EB.Data.addContentType('PGN', {
    toHtml: function(content) {
        return chessBoard(content);
    }
})

EB.Data.addContentType('profile', {
    toHtml: function(content, puff) {
        if(puffworldprops.view.mode == "tableView")
            return '<img src=' + content + ' />';
        else
            return '<img class="imgInBox" src=' + content + ' />';
        /*var keysNotShow = ['content', 'type'];
        for (var key in puff.payload) {
            var value = puff.payload[key];
            if (keysNotShow.indexOf(key)==-1 && value && value.length) {
                toRet += '<div><span class="profileKey">' + key + ': </span><span class="profileValue">' + value + '</span></div>';
            }
        }*/
    }
})

EB.Data.addContentType('text', {
    toHtml: function(content) {
        var safe_content = XBBCODE.process({ text: content })   // not ideal, but it does seem to strip out raw html
        safe_content.html = safe_content.html.replace(/\n/g, '</br>');  // Set line breaks
        return '<span>' + safe_content.html + '</span>'
    }
})

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImJpdGNvaW5qcy1taW4uanMiLCJwZWVyLmpzIiwicHJvbWlzZS5taW4uanMiLCJ4YmJjb2RlLmpzIiwiYm9yb24uanMiLCJkYWdvYmEuanMiLCJldmVudHMuanMiLCJmaWxlZmlsZS5qcyIsImdyaWRib3guanMiLCJ0aW1pbmcuanMiLCJFQi5qcyIsIkVCLkNyeXB0by5qcyIsIkVCLkRhdGEuanMiLCJFQi5OZXQuanMiLCJFQi5QZXJzaXN0LmpzIiwiRUIuUHVmZi5qcyIsIkVCLlNwZWMuanMiLCJFQi5Vc2Vycy5qcyIsIkVCLk0uTWVzc2FnZXMuanMiLCJFQi5NLldhcmRyb2JlLmpzIiwiYmJjb2RlLmpzIiwiZmlsZS5qcyIsImlkZW50aXR5LmpzIiwiaW1hZ2UuanMiLCJsYXRleC5qcyIsIm1hcmtkb3duLmpzIiwicGduLmpzIiwicHJvZmlsZS5qcyIsInRleHQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzM0ZBO0FBQ0E7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN2YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1b0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbGJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJldmVyeWJpdC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGUpO2Vsc2V7dmFyIGY7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz9mPXdpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2Y9Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiYoZj1zZWxmKSxmLkJpdGNvaW49ZSgpfX0oZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiBmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30oezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciB1dGlsPV9kZXJlcV8oXCJ1dGlsL1wiKTt2YXIgcFNsaWNlPUFycmF5LnByb3RvdHlwZS5zbGljZTt2YXIgaGFzT3duPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIGFzc2VydD1tb2R1bGUuZXhwb3J0cz1vazthc3NlcnQuQXNzZXJ0aW9uRXJyb3I9ZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucyl7dGhpcy5uYW1lPVwiQXNzZXJ0aW9uRXJyb3JcIjt0aGlzLmFjdHVhbD1vcHRpb25zLmFjdHVhbDt0aGlzLmV4cGVjdGVkPW9wdGlvbnMuZXhwZWN0ZWQ7dGhpcy5vcGVyYXRvcj1vcHRpb25zLm9wZXJhdG9yO2lmKG9wdGlvbnMubWVzc2FnZSl7dGhpcy5tZXNzYWdlPW9wdGlvbnMubWVzc2FnZTt0aGlzLmdlbmVyYXRlZE1lc3NhZ2U9ZmFsc2V9ZWxzZXt0aGlzLm1lc3NhZ2U9Z2V0TWVzc2FnZSh0aGlzKTt0aGlzLmdlbmVyYXRlZE1lc3NhZ2U9dHJ1ZX12YXIgc3RhY2tTdGFydEZ1bmN0aW9uPW9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9ufHxmYWlsO2lmKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKXtFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLHN0YWNrU3RhcnRGdW5jdGlvbil9ZWxzZXt2YXIgZXJyPW5ldyBFcnJvcjtpZihlcnIuc3RhY2spe3ZhciBvdXQ9ZXJyLnN0YWNrO3ZhciBmbl9uYW1lPXN0YWNrU3RhcnRGdW5jdGlvbi5uYW1lO3ZhciBpZHg9b3V0LmluZGV4T2YoXCJcXG5cIitmbl9uYW1lKTtpZihpZHg+PTApe3ZhciBuZXh0X2xpbmU9b3V0LmluZGV4T2YoXCJcXG5cIixpZHgrMSk7b3V0PW91dC5zdWJzdHJpbmcobmV4dF9saW5lKzEpfXRoaXMuc3RhY2s9b3V0fX19O3V0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLEVycm9yKTtmdW5jdGlvbiByZXBsYWNlcihrZXksdmFsdWUpe2lmKHV0aWwuaXNVbmRlZmluZWQodmFsdWUpKXtyZXR1cm5cIlwiK3ZhbHVlfWlmKHV0aWwuaXNOdW1iZXIodmFsdWUpJiYoaXNOYU4odmFsdWUpfHwhaXNGaW5pdGUodmFsdWUpKSl7cmV0dXJuIHZhbHVlLnRvU3RyaW5nKCl9aWYodXRpbC5pc0Z1bmN0aW9uKHZhbHVlKXx8dXRpbC5pc1JlZ0V4cCh2YWx1ZSkpe3JldHVybiB2YWx1ZS50b1N0cmluZygpfXJldHVybiB2YWx1ZX1mdW5jdGlvbiB0cnVuY2F0ZShzLG4pe2lmKHV0aWwuaXNTdHJpbmcocykpe3JldHVybiBzLmxlbmd0aDxuP3M6cy5zbGljZSgwLG4pfWVsc2V7cmV0dXJuIHN9fWZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZil7cmV0dXJuIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHNlbGYuYWN0dWFsLHJlcGxhY2VyKSwxMjgpK1wiIFwiK3NlbGYub3BlcmF0b3IrXCIgXCIrdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5leHBlY3RlZCxyZXBsYWNlciksMTI4KX1mdW5jdGlvbiBmYWlsKGFjdHVhbCxleHBlY3RlZCxtZXNzYWdlLG9wZXJhdG9yLHN0YWNrU3RhcnRGdW5jdGlvbil7dGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7bWVzc2FnZTptZXNzYWdlLGFjdHVhbDphY3R1YWwsZXhwZWN0ZWQ6ZXhwZWN0ZWQsb3BlcmF0b3I6b3BlcmF0b3Isc3RhY2tTdGFydEZ1bmN0aW9uOnN0YWNrU3RhcnRGdW5jdGlvbn0pfWFzc2VydC5mYWlsPWZhaWw7ZnVuY3Rpb24gb2sodmFsdWUsbWVzc2FnZSl7aWYoIXZhbHVlKWZhaWwodmFsdWUsdHJ1ZSxtZXNzYWdlLFwiPT1cIixhc3NlcnQub2spfWFzc2VydC5vaz1vazthc3NlcnQuZXF1YWw9ZnVuY3Rpb24gZXF1YWwoYWN0dWFsLGV4cGVjdGVkLG1lc3NhZ2Upe2lmKGFjdHVhbCE9ZXhwZWN0ZWQpZmFpbChhY3R1YWwsZXhwZWN0ZWQsbWVzc2FnZSxcIj09XCIsYXNzZXJ0LmVxdWFsKX07YXNzZXJ0Lm5vdEVxdWFsPWZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCxleHBlY3RlZCxtZXNzYWdlKXtpZihhY3R1YWw9PWV4cGVjdGVkKXtmYWlsKGFjdHVhbCxleHBlY3RlZCxtZXNzYWdlLFwiIT1cIixhc3NlcnQubm90RXF1YWwpfX07YXNzZXJ0LmRlZXBFcXVhbD1mdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLGV4cGVjdGVkLG1lc3NhZ2Upe2lmKCFfZGVlcEVxdWFsKGFjdHVhbCxleHBlY3RlZCkpe2ZhaWwoYWN0dWFsLGV4cGVjdGVkLG1lc3NhZ2UsXCJkZWVwRXF1YWxcIixhc3NlcnQuZGVlcEVxdWFsKX19O2Z1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLGV4cGVjdGVkKXtpZihhY3R1YWw9PT1leHBlY3RlZCl7cmV0dXJuIHRydWV9ZWxzZSBpZih1dGlsLmlzQnVmZmVyKGFjdHVhbCkmJnV0aWwuaXNCdWZmZXIoZXhwZWN0ZWQpKXtpZihhY3R1YWwubGVuZ3RoIT1leHBlY3RlZC5sZW5ndGgpcmV0dXJuIGZhbHNlO2Zvcih2YXIgaT0wO2k8YWN0dWFsLmxlbmd0aDtpKyspe2lmKGFjdHVhbFtpXSE9PWV4cGVjdGVkW2ldKXJldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX1lbHNlIGlmKHV0aWwuaXNEYXRlKGFjdHVhbCkmJnV0aWwuaXNEYXRlKGV4cGVjdGVkKSl7cmV0dXJuIGFjdHVhbC5nZXRUaW1lKCk9PT1leHBlY3RlZC5nZXRUaW1lKCl9ZWxzZSBpZih1dGlsLmlzUmVnRXhwKGFjdHVhbCkmJnV0aWwuaXNSZWdFeHAoZXhwZWN0ZWQpKXtyZXR1cm4gYWN0dWFsLnNvdXJjZT09PWV4cGVjdGVkLnNvdXJjZSYmYWN0dWFsLmdsb2JhbD09PWV4cGVjdGVkLmdsb2JhbCYmYWN0dWFsLm11bHRpbGluZT09PWV4cGVjdGVkLm11bHRpbGluZSYmYWN0dWFsLmxhc3RJbmRleD09PWV4cGVjdGVkLmxhc3RJbmRleCYmYWN0dWFsLmlnbm9yZUNhc2U9PT1leHBlY3RlZC5pZ25vcmVDYXNlfWVsc2UgaWYoIXV0aWwuaXNPYmplY3QoYWN0dWFsKSYmIXV0aWwuaXNPYmplY3QoZXhwZWN0ZWQpKXtyZXR1cm4gYWN0dWFsPT1leHBlY3RlZH1lbHNle3JldHVybiBvYmpFcXVpdihhY3R1YWwsZXhwZWN0ZWQpfX1mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3Qpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KT09XCJbb2JqZWN0IEFyZ3VtZW50c11cIn1mdW5jdGlvbiBvYmpFcXVpdihhLGIpe2lmKHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoYSl8fHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoYikpcmV0dXJuIGZhbHNlO2lmKGEucHJvdG90eXBlIT09Yi5wcm90b3R5cGUpcmV0dXJuIGZhbHNlO2lmKGlzQXJndW1lbnRzKGEpKXtpZighaXNBcmd1bWVudHMoYikpe3JldHVybiBmYWxzZX1hPXBTbGljZS5jYWxsKGEpO2I9cFNsaWNlLmNhbGwoYik7cmV0dXJuIF9kZWVwRXF1YWwoYSxiKX10cnl7dmFyIGthPW9iamVjdEtleXMoYSksa2I9b2JqZWN0S2V5cyhiKSxrZXksaX1jYXRjaChlKXtyZXR1cm4gZmFsc2V9aWYoa2EubGVuZ3RoIT1rYi5sZW5ndGgpcmV0dXJuIGZhbHNlO2thLnNvcnQoKTtrYi5zb3J0KCk7Zm9yKGk9a2EubGVuZ3RoLTE7aT49MDtpLS0pe2lmKGthW2ldIT1rYltpXSlyZXR1cm4gZmFsc2V9Zm9yKGk9a2EubGVuZ3RoLTE7aT49MDtpLS0pe2tleT1rYVtpXTtpZighX2RlZXBFcXVhbChhW2tleV0sYltrZXldKSlyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9YXNzZXJ0Lm5vdERlZXBFcXVhbD1mdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLGV4cGVjdGVkLG1lc3NhZ2Upe2lmKF9kZWVwRXF1YWwoYWN0dWFsLGV4cGVjdGVkKSl7ZmFpbChhY3R1YWwsZXhwZWN0ZWQsbWVzc2FnZSxcIm5vdERlZXBFcXVhbFwiLGFzc2VydC5ub3REZWVwRXF1YWwpfX07YXNzZXJ0LnN0cmljdEVxdWFsPWZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCxleHBlY3RlZCxtZXNzYWdlKXtpZihhY3R1YWwhPT1leHBlY3RlZCl7ZmFpbChhY3R1YWwsZXhwZWN0ZWQsbWVzc2FnZSxcIj09PVwiLGFzc2VydC5zdHJpY3RFcXVhbCl9fTthc3NlcnQubm90U3RyaWN0RXF1YWw9ZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLGV4cGVjdGVkLG1lc3NhZ2Upe2lmKGFjdHVhbD09PWV4cGVjdGVkKXtmYWlsKGFjdHVhbCxleHBlY3RlZCxtZXNzYWdlLFwiIT09XCIsYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKX19O2Z1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCxleHBlY3RlZCl7aWYoIWFjdHVhbHx8IWV4cGVjdGVkKXtyZXR1cm4gZmFsc2V9aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKT09XCJbb2JqZWN0IFJlZ0V4cF1cIil7cmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKX1lbHNlIGlmKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKXtyZXR1cm4gdHJ1ZX1lbHNlIGlmKGV4cGVjdGVkLmNhbGwoe30sYWN0dWFsKT09PXRydWUpe3JldHVybiB0cnVlfXJldHVybiBmYWxzZX1mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LGJsb2NrLGV4cGVjdGVkLG1lc3NhZ2Upe3ZhciBhY3R1YWw7aWYodXRpbC5pc1N0cmluZyhleHBlY3RlZCkpe21lc3NhZ2U9ZXhwZWN0ZWQ7ZXhwZWN0ZWQ9bnVsbH10cnl7YmxvY2soKX1jYXRjaChlKXthY3R1YWw9ZX1tZXNzYWdlPShleHBlY3RlZCYmZXhwZWN0ZWQubmFtZT9cIiAoXCIrZXhwZWN0ZWQubmFtZStcIikuXCI6XCIuXCIpKyhtZXNzYWdlP1wiIFwiK21lc3NhZ2U6XCIuXCIpO2lmKHNob3VsZFRocm93JiYhYWN0dWFsKXtmYWlsKGFjdHVhbCxleHBlY3RlZCxcIk1pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uXCIrbWVzc2FnZSl9aWYoIXNob3VsZFRocm93JiZleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsZXhwZWN0ZWQpKXtmYWlsKGFjdHVhbCxleHBlY3RlZCxcIkdvdCB1bndhbnRlZCBleGNlcHRpb25cIittZXNzYWdlKX1pZihzaG91bGRUaHJvdyYmYWN0dWFsJiZleHBlY3RlZCYmIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCxleHBlY3RlZCl8fCFzaG91bGRUaHJvdyYmYWN0dWFsKXt0aHJvdyBhY3R1YWx9fWFzc2VydC50aHJvd3M9ZnVuY3Rpb24oYmxvY2ssZXJyb3IsbWVzc2FnZSl7X3Rocm93cy5hcHBseSh0aGlzLFt0cnVlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpfTthc3NlcnQuZG9lc05vdFRocm93PWZ1bmN0aW9uKGJsb2NrLG1lc3NhZ2Upe190aHJvd3MuYXBwbHkodGhpcyxbZmFsc2VdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSl9O2Fzc2VydC5pZkVycm9yPWZ1bmN0aW9uKGVycil7aWYoZXJyKXt0aHJvdyBlcnJ9fTt2YXIgb2JqZWN0S2V5cz1PYmplY3Qua2V5c3x8ZnVuY3Rpb24ob2JqKXt2YXIga2V5cz1bXTtmb3IodmFyIGtleSBpbiBvYmope2lmKGhhc093bi5jYWxsKG9iaixrZXkpKWtleXMucHVzaChrZXkpfXJldHVybiBrZXlzfX0se1widXRpbC9cIjozfV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24gaXNCdWZmZXIoYXJnKXtyZXR1cm4gYXJnJiZ0eXBlb2YgYXJnPT09XCJvYmplY3RcIiYmdHlwZW9mIGFyZy5jb3B5PT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgYXJnLmZpbGw9PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBhcmcucmVhZFVJbnQ4PT09XCJmdW5jdGlvblwifX0se31dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihwcm9jZXNzLGdsb2JhbCl7dmFyIGZvcm1hdFJlZ0V4cD0vJVtzZGolXS9nO2V4cG9ydHMuZm9ybWF0PWZ1bmN0aW9uKGYpe2lmKCFpc1N0cmluZyhmKSl7dmFyIG9iamVjdHM9W107Zm9yKHZhciBpPTA7aTxhcmd1bWVudHMubGVuZ3RoO2krKyl7b2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSl9cmV0dXJuIG9iamVjdHMuam9pbihcIiBcIil9dmFyIGk9MTt2YXIgYXJncz1hcmd1bWVudHM7dmFyIGxlbj1hcmdzLmxlbmd0aDt2YXIgc3RyPVN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCxmdW5jdGlvbih4KXtpZih4PT09XCIlJVwiKXJldHVyblwiJVwiO2lmKGk+PWxlbilyZXR1cm4geDtzd2l0Y2goeCl7Y2FzZVwiJXNcIjpyZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7Y2FzZVwiJWRcIjpyZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7Y2FzZVwiJWpcIjp0cnl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSl9Y2F0Y2goXyl7cmV0dXJuXCJbQ2lyY3VsYXJdXCJ9ZGVmYXVsdDpyZXR1cm4geH19KTtmb3IodmFyIHg9YXJnc1tpXTtpPGxlbjt4PWFyZ3NbKytpXSl7aWYoaXNOdWxsKHgpfHwhaXNPYmplY3QoeCkpe3N0cis9XCIgXCIreH1lbHNle3N0cis9XCIgXCIraW5zcGVjdCh4KX19cmV0dXJuIHN0cn07ZXhwb3J0cy5kZXByZWNhdGU9ZnVuY3Rpb24oZm4sbXNnKXtpZihpc1VuZGVmaW5lZChnbG9iYWwucHJvY2Vzcykpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbixtc2cpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19aWYocHJvY2Vzcy5ub0RlcHJlY2F0aW9uPT09dHJ1ZSl7cmV0dXJuIGZufXZhciB3YXJuZWQ9ZmFsc2U7ZnVuY3Rpb24gZGVwcmVjYXRlZCgpe2lmKCF3YXJuZWQpe2lmKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbil7dGhyb3cgbmV3IEVycm9yKG1zZyl9ZWxzZSBpZihwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pe2NvbnNvbGUudHJhY2UobXNnKX1lbHNle2NvbnNvbGUuZXJyb3IobXNnKX13YXJuZWQ9dHJ1ZX1yZXR1cm4gZm4uYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBkZXByZWNhdGVkfTt2YXIgZGVidWdzPXt9O3ZhciBkZWJ1Z0Vudmlyb247ZXhwb3J0cy5kZWJ1Z2xvZz1mdW5jdGlvbihzZXQpe2lmKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpZGVidWdFbnZpcm9uPXByb2Nlc3MuZW52Lk5PREVfREVCVUd8fFwiXCI7c2V0PXNldC50b1VwcGVyQ2FzZSgpO2lmKCFkZWJ1Z3Nbc2V0XSl7aWYobmV3IFJlZ0V4cChcIlxcXFxiXCIrc2V0K1wiXFxcXGJcIixcImlcIikudGVzdChkZWJ1Z0Vudmlyb24pKXt2YXIgcGlkPXByb2Nlc3MucGlkO2RlYnVnc1tzZXRdPWZ1bmN0aW9uKCl7dmFyIG1zZz1leHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLGFyZ3VtZW50cyk7Y29uc29sZS5lcnJvcihcIiVzICVkOiAlc1wiLHNldCxwaWQsbXNnKX19ZWxzZXtkZWJ1Z3Nbc2V0XT1mdW5jdGlvbigpe319fXJldHVybiBkZWJ1Z3Nbc2V0XX07ZnVuY3Rpb24gaW5zcGVjdChvYmosb3B0cyl7dmFyIGN0eD17c2VlbjpbXSxzdHlsaXplOnN0eWxpemVOb0NvbG9yfTtpZihhcmd1bWVudHMubGVuZ3RoPj0zKWN0eC5kZXB0aD1hcmd1bWVudHNbMl07aWYoYXJndW1lbnRzLmxlbmd0aD49NCljdHguY29sb3JzPWFyZ3VtZW50c1szXTtpZihpc0Jvb2xlYW4ob3B0cykpe2N0eC5zaG93SGlkZGVuPW9wdHN9ZWxzZSBpZihvcHRzKXtleHBvcnRzLl9leHRlbmQoY3R4LG9wdHMpfWlmKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSljdHguc2hvd0hpZGRlbj1mYWxzZTtpZihpc1VuZGVmaW5lZChjdHguZGVwdGgpKWN0eC5kZXB0aD0yO2lmKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKWN0eC5jb2xvcnM9ZmFsc2U7aWYoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKWN0eC5jdXN0b21JbnNwZWN0PXRydWU7aWYoY3R4LmNvbG9ycyljdHguc3R5bGl6ZT1zdHlsaXplV2l0aENvbG9yO3JldHVybiBmb3JtYXRWYWx1ZShjdHgsb2JqLGN0eC5kZXB0aCl9ZXhwb3J0cy5pbnNwZWN0PWluc3BlY3Q7aW5zcGVjdC5jb2xvcnM9e2JvbGQ6WzEsMjJdLGl0YWxpYzpbMywyM10sdW5kZXJsaW5lOls0LDI0XSxpbnZlcnNlOls3LDI3XSx3aGl0ZTpbMzcsMzldLGdyZXk6WzkwLDM5XSxibGFjazpbMzAsMzldLGJsdWU6WzM0LDM5XSxjeWFuOlszNiwzOV0sZ3JlZW46WzMyLDM5XSxtYWdlbnRhOlszNSwzOV0scmVkOlszMSwzOV0seWVsbG93OlszMywzOV19O2luc3BlY3Quc3R5bGVzPXtzcGVjaWFsOlwiY3lhblwiLG51bWJlcjpcInllbGxvd1wiLFwiYm9vbGVhblwiOlwieWVsbG93XCIsdW5kZWZpbmVkOlwiZ3JleVwiLFwibnVsbFwiOlwiYm9sZFwiLHN0cmluZzpcImdyZWVuXCIsZGF0ZTpcIm1hZ2VudGFcIixyZWdleHA6XCJyZWRcIn07ZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsc3R5bGVUeXBlKXt2YXIgc3R5bGU9aW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtpZihzdHlsZSl7cmV0dXJuXCJcdTAwMWJbXCIraW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdK1wibVwiK3N0citcIlx1MDAxYltcIitpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0rXCJtXCJ9ZWxzZXtyZXR1cm4gc3RyfX1mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsc3R5bGVUeXBlKXtyZXR1cm4gc3RyfWZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KXt2YXIgaGFzaD17fTthcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCxpZHgpe2hhc2hbdmFsXT10cnVlfSk7cmV0dXJuIGhhc2h9ZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LHZhbHVlLHJlY3Vyc2VUaW1lcyl7aWYoY3R4LmN1c3RvbUluc3BlY3QmJnZhbHVlJiZpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpJiZ2YWx1ZS5pbnNwZWN0IT09ZXhwb3J0cy5pbnNwZWN0JiYhKHZhbHVlLmNvbnN0cnVjdG9yJiZ2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGU9PT12YWx1ZSkpe3ZhciByZXQ9dmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsY3R4KTtpZighaXNTdHJpbmcocmV0KSl7cmV0PWZvcm1hdFZhbHVlKGN0eCxyZXQscmVjdXJzZVRpbWVzKX1yZXR1cm4gcmV0fXZhciBwcmltaXRpdmU9Zm9ybWF0UHJpbWl0aXZlKGN0eCx2YWx1ZSk7aWYocHJpbWl0aXZlKXtyZXR1cm4gcHJpbWl0aXZlfXZhciBrZXlzPU9iamVjdC5rZXlzKHZhbHVlKTt2YXIgdmlzaWJsZUtleXM9YXJyYXlUb0hhc2goa2V5cyk7aWYoY3R4LnNob3dIaWRkZW4pe2tleXM9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpfWlmKGlzRXJyb3IodmFsdWUpJiYoa2V5cy5pbmRleE9mKFwibWVzc2FnZVwiKT49MHx8a2V5cy5pbmRleE9mKFwiZGVzY3JpcHRpb25cIik+PTApKXtyZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpfWlmKGtleXMubGVuZ3RoPT09MCl7aWYoaXNGdW5jdGlvbih2YWx1ZSkpe3ZhciBuYW1lPXZhbHVlLm5hbWU/XCI6IFwiK3ZhbHVlLm5hbWU6XCJcIjtyZXR1cm4gY3R4LnN0eWxpemUoXCJbRnVuY3Rpb25cIituYW1lK1wiXVwiLFwic3BlY2lhbFwiKX1pZihpc1JlZ0V4cCh2YWx1ZSkpe3JldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLFwicmVnZXhwXCIpfWlmKGlzRGF0ZSh2YWx1ZSkpe3JldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSxcImRhdGVcIil9aWYoaXNFcnJvcih2YWx1ZSkpe3JldHVybiBmb3JtYXRFcnJvcih2YWx1ZSl9fXZhciBiYXNlPVwiXCIsYXJyYXk9ZmFsc2UsYnJhY2VzPVtcIntcIixcIn1cIl07aWYoaXNBcnJheSh2YWx1ZSkpe2FycmF5PXRydWU7YnJhY2VzPVtcIltcIixcIl1cIl19aWYoaXNGdW5jdGlvbih2YWx1ZSkpe3ZhciBuPXZhbHVlLm5hbWU/XCI6IFwiK3ZhbHVlLm5hbWU6XCJcIjtiYXNlPVwiIFtGdW5jdGlvblwiK24rXCJdXCJ9aWYoaXNSZWdFeHAodmFsdWUpKXtiYXNlPVwiIFwiK1JlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSl9aWYoaXNEYXRlKHZhbHVlKSl7YmFzZT1cIiBcIitEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKX1pZihpc0Vycm9yKHZhbHVlKSl7YmFzZT1cIiBcIitmb3JtYXRFcnJvcih2YWx1ZSl9aWYoa2V5cy5sZW5ndGg9PT0wJiYoIWFycmF5fHx2YWx1ZS5sZW5ndGg9PTApKXtyZXR1cm4gYnJhY2VzWzBdK2Jhc2UrYnJhY2VzWzFdfWlmKHJlY3Vyc2VUaW1lczwwKXtpZihpc1JlZ0V4cCh2YWx1ZSkpe3JldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLFwicmVnZXhwXCIpfWVsc2V7cmV0dXJuIGN0eC5zdHlsaXplKFwiW09iamVjdF1cIixcInNwZWNpYWxcIil9fWN0eC5zZWVuLnB1c2godmFsdWUpO3ZhciBvdXRwdXQ7aWYoYXJyYXkpe291dHB1dD1mb3JtYXRBcnJheShjdHgsdmFsdWUscmVjdXJzZVRpbWVzLHZpc2libGVLZXlzLGtleXMpfWVsc2V7b3V0cHV0PWtleXMubWFwKGZ1bmN0aW9uKGtleSl7cmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCx2YWx1ZSxyZWN1cnNlVGltZXMsdmlzaWJsZUtleXMsa2V5LGFycmF5KX0pfWN0eC5zZWVuLnBvcCgpO3JldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsYmFzZSxicmFjZXMpfWZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsdmFsdWUpe2lmKGlzVW5kZWZpbmVkKHZhbHVlKSlyZXR1cm4gY3R4LnN0eWxpemUoXCJ1bmRlZmluZWRcIixcInVuZGVmaW5lZFwiKTtpZihpc1N0cmluZyh2YWx1ZSkpe3ZhciBzaW1wbGU9XCInXCIrSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZyxcIlwiKS5yZXBsYWNlKC8nL2csXCJcXFxcJ1wiKS5yZXBsYWNlKC9cXFxcXCIvZywnXCInKStcIidcIjtyZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLFwic3RyaW5nXCIpfWlmKGlzTnVtYmVyKHZhbHVlKSlyZXR1cm4gY3R4LnN0eWxpemUoXCJcIit2YWx1ZSxcIm51bWJlclwiKTtpZihpc0Jvb2xlYW4odmFsdWUpKXJldHVybiBjdHguc3R5bGl6ZShcIlwiK3ZhbHVlLFwiYm9vbGVhblwiKTtpZihpc051bGwodmFsdWUpKXJldHVybiBjdHguc3R5bGl6ZShcIm51bGxcIixcIm51bGxcIil9ZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpe3JldHVyblwiW1wiK0Vycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKStcIl1cIn1mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsdmFsdWUscmVjdXJzZVRpbWVzLHZpc2libGVLZXlzLGtleXMpe3ZhciBvdXRwdXQ9W107Zm9yKHZhciBpPTAsbD12YWx1ZS5sZW5ndGg7aTxsOysraSl7aWYoaGFzT3duUHJvcGVydHkodmFsdWUsU3RyaW5nKGkpKSl7b3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LHZhbHVlLHJlY3Vyc2VUaW1lcyx2aXNpYmxlS2V5cyxTdHJpbmcoaSksdHJ1ZSkpfWVsc2V7b3V0cHV0LnB1c2goXCJcIil9fWtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpe2lmKCFrZXkubWF0Y2goL15cXGQrJC8pKXtvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsdmFsdWUscmVjdXJzZVRpbWVzLHZpc2libGVLZXlzLGtleSx0cnVlKSl9fSk7cmV0dXJuIG91dHB1dH1mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsdmFsdWUscmVjdXJzZVRpbWVzLHZpc2libGVLZXlzLGtleSxhcnJheSl7dmFyIG5hbWUsc3RyLGRlc2M7ZGVzYz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLGtleSl8fHt2YWx1ZTp2YWx1ZVtrZXldfTtpZihkZXNjLmdldCl7aWYoZGVzYy5zZXQpe3N0cj1jdHguc3R5bGl6ZShcIltHZXR0ZXIvU2V0dGVyXVwiLFwic3BlY2lhbFwiKX1lbHNle3N0cj1jdHguc3R5bGl6ZShcIltHZXR0ZXJdXCIsXCJzcGVjaWFsXCIpfX1lbHNle2lmKGRlc2Muc2V0KXtzdHI9Y3R4LnN0eWxpemUoXCJbU2V0dGVyXVwiLFwic3BlY2lhbFwiKX19aWYoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLGtleSkpe25hbWU9XCJbXCIra2V5K1wiXVwifWlmKCFzdHIpe2lmKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSk8MCl7aWYoaXNOdWxsKHJlY3Vyc2VUaW1lcykpe3N0cj1mb3JtYXRWYWx1ZShjdHgsZGVzYy52YWx1ZSxudWxsKX1lbHNle3N0cj1mb3JtYXRWYWx1ZShjdHgsZGVzYy52YWx1ZSxyZWN1cnNlVGltZXMtMSl9aWYoc3RyLmluZGV4T2YoXCJcXG5cIik+LTEpe2lmKGFycmF5KXtzdHI9c3RyLnNwbGl0KFwiXFxuXCIpLm1hcChmdW5jdGlvbihsaW5lKXtyZXR1cm5cIiAgXCIrbGluZX0pLmpvaW4oXCJcXG5cIikuc3Vic3RyKDIpfWVsc2V7c3RyPVwiXFxuXCIrc3RyLnNwbGl0KFwiXFxuXCIpLm1hcChmdW5jdGlvbihsaW5lKXtyZXR1cm5cIiAgIFwiK2xpbmV9KS5qb2luKFwiXFxuXCIpfX19ZWxzZXtzdHI9Y3R4LnN0eWxpemUoXCJbQ2lyY3VsYXJdXCIsXCJzcGVjaWFsXCIpfX1pZihpc1VuZGVmaW5lZChuYW1lKSl7aWYoYXJyYXkmJmtleS5tYXRjaCgvXlxcZCskLykpe3JldHVybiBzdHJ9bmFtZT1KU09OLnN0cmluZ2lmeShcIlwiK2tleSk7aWYobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpe25hbWU9bmFtZS5zdWJzdHIoMSxuYW1lLmxlbmd0aC0yKTtuYW1lPWN0eC5zdHlsaXplKG5hbWUsXCJuYW1lXCIpfWVsc2V7bmFtZT1uYW1lLnJlcGxhY2UoLycvZyxcIlxcXFwnXCIpLnJlcGxhY2UoL1xcXFxcIi9nLCdcIicpLnJlcGxhY2UoLyheXCJ8XCIkKS9nLFwiJ1wiKTtuYW1lPWN0eC5zdHlsaXplKG5hbWUsXCJzdHJpbmdcIil9fXJldHVybiBuYW1lK1wiOiBcIitzdHJ9ZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LGJhc2UsYnJhY2VzKXt2YXIgbnVtTGluZXNFc3Q9MDt2YXIgbGVuZ3RoPW91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldixjdXIpe251bUxpbmVzRXN0Kys7aWYoY3VyLmluZGV4T2YoXCJcXG5cIik+PTApbnVtTGluZXNFc3QrKztyZXR1cm4gcHJlditjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csXCJcIikubGVuZ3RoKzF9LDApO2lmKGxlbmd0aD42MCl7cmV0dXJuIGJyYWNlc1swXSsoYmFzZT09PVwiXCI/XCJcIjpiYXNlK1wiXFxuIFwiKStcIiBcIitvdXRwdXQuam9pbihcIixcXG4gIFwiKStcIiBcIiticmFjZXNbMV19cmV0dXJuIGJyYWNlc1swXStiYXNlK1wiIFwiK291dHB1dC5qb2luKFwiLCBcIikrXCIgXCIrYnJhY2VzWzFdfWZ1bmN0aW9uIGlzQXJyYXkoYXIpe3JldHVybiBBcnJheS5pc0FycmF5KGFyKX1leHBvcnRzLmlzQXJyYXk9aXNBcnJheTtmdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKXtyZXR1cm4gdHlwZW9mIGFyZz09PVwiYm9vbGVhblwifWV4cG9ydHMuaXNCb29sZWFuPWlzQm9vbGVhbjtmdW5jdGlvbiBpc051bGwoYXJnKXtyZXR1cm4gYXJnPT09bnVsbH1leHBvcnRzLmlzTnVsbD1pc051bGw7ZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKXtyZXR1cm4gYXJnPT1udWxsfWV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQ9aXNOdWxsT3JVbmRlZmluZWQ7ZnVuY3Rpb24gaXNOdW1iZXIoYXJnKXtyZXR1cm4gdHlwZW9mIGFyZz09PVwibnVtYmVyXCJ9ZXhwb3J0cy5pc051bWJlcj1pc051bWJlcjtmdW5jdGlvbiBpc1N0cmluZyhhcmcpe3JldHVybiB0eXBlb2YgYXJnPT09XCJzdHJpbmdcIn1leHBvcnRzLmlzU3RyaW5nPWlzU3RyaW5nO2Z1bmN0aW9uIGlzU3ltYm9sKGFyZyl7cmV0dXJuIHR5cGVvZiBhcmc9PT1cInN5bWJvbFwifWV4cG9ydHMuaXNTeW1ib2w9aXNTeW1ib2w7ZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKXtyZXR1cm4gYXJnPT09dm9pZCAwfWV4cG9ydHMuaXNVbmRlZmluZWQ9aXNVbmRlZmluZWQ7ZnVuY3Rpb24gaXNSZWdFeHAocmUpe3JldHVybiBpc09iamVjdChyZSkmJm9iamVjdFRvU3RyaW5nKHJlKT09PVwiW29iamVjdCBSZWdFeHBdXCJ9ZXhwb3J0cy5pc1JlZ0V4cD1pc1JlZ0V4cDtmdW5jdGlvbiBpc09iamVjdChhcmcpe3JldHVybiB0eXBlb2YgYXJnPT09XCJvYmplY3RcIiYmYXJnIT09bnVsbH1leHBvcnRzLmlzT2JqZWN0PWlzT2JqZWN0O2Z1bmN0aW9uIGlzRGF0ZShkKXtyZXR1cm4gaXNPYmplY3QoZCkmJm9iamVjdFRvU3RyaW5nKGQpPT09XCJbb2JqZWN0IERhdGVdXCJ9ZXhwb3J0cy5pc0RhdGU9aXNEYXRlO2Z1bmN0aW9uIGlzRXJyb3IoZSl7cmV0dXJuIGlzT2JqZWN0KGUpJiYob2JqZWN0VG9TdHJpbmcoZSk9PT1cIltvYmplY3QgRXJyb3JdXCJ8fGUgaW5zdGFuY2VvZiBFcnJvcil9ZXhwb3J0cy5pc0Vycm9yPWlzRXJyb3I7ZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpe3JldHVybiB0eXBlb2YgYXJnPT09XCJmdW5jdGlvblwifWV4cG9ydHMuaXNGdW5jdGlvbj1pc0Z1bmN0aW9uO2Z1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZyl7cmV0dXJuIGFyZz09PW51bGx8fHR5cGVvZiBhcmc9PT1cImJvb2xlYW5cInx8dHlwZW9mIGFyZz09PVwibnVtYmVyXCJ8fHR5cGVvZiBhcmc9PT1cInN0cmluZ1wifHx0eXBlb2YgYXJnPT09XCJzeW1ib2xcInx8dHlwZW9mIGFyZz09PVwidW5kZWZpbmVkXCJ9ZXhwb3J0cy5pc1ByaW1pdGl2ZT1pc1ByaW1pdGl2ZTtleHBvcnRzLmlzQnVmZmVyPV9kZXJlcV8oXCIuL3N1cHBvcnQvaXNCdWZmZXJcIik7ZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobyl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKX1mdW5jdGlvbiBwYWQobil7cmV0dXJuIG48MTA/XCIwXCIrbi50b1N0cmluZygxMCk6bi50b1N0cmluZygxMCl9dmFyIG1vbnRocz1bXCJKYW5cIixcIkZlYlwiLFwiTWFyXCIsXCJBcHJcIixcIk1heVwiLFwiSnVuXCIsXCJKdWxcIixcIkF1Z1wiLFwiU2VwXCIsXCJPY3RcIixcIk5vdlwiLFwiRGVjXCJdO2Z1bmN0aW9uIHRpbWVzdGFtcCgpe3ZhciBkPW5ldyBEYXRlO3ZhciB0aW1lPVtwYWQoZC5nZXRIb3VycygpKSxwYWQoZC5nZXRNaW51dGVzKCkpLHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oXCI6XCIpO3JldHVybltkLmdldERhdGUoKSxtb250aHNbZC5nZXRNb250aCgpXSx0aW1lXS5qb2luKFwiIFwiKX1leHBvcnRzLmxvZz1mdW5jdGlvbigpe2NvbnNvbGUubG9nKFwiJXMgLSAlc1wiLHRpbWVzdGFtcCgpLGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKSl9O2V4cG9ydHMuaW5oZXJpdHM9X2RlcmVxXyhcImluaGVyaXRzXCIpO2V4cG9ydHMuX2V4dGVuZD1mdW5jdGlvbihvcmlnaW4sYWRkKXtpZighYWRkfHwhaXNPYmplY3QoYWRkKSlyZXR1cm4gb3JpZ2luO3ZhciBrZXlzPU9iamVjdC5rZXlzKGFkZCk7dmFyIGk9a2V5cy5sZW5ndGg7d2hpbGUoaS0tKXtvcmlnaW5ba2V5c1tpXV09YWRkW2tleXNbaV1dfXJldHVybiBvcmlnaW59O2Z1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaixwcm9wKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaixwcm9wKX19KS5jYWxsKHRoaXMsX2RlcmVxXyhcIkZXYUFTSFwiKSx0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6e30pfSx7XCIuL3N1cHBvcnQvaXNCdWZmZXJcIjoyLEZXYUFTSDoxNSxpbmhlcml0czoxNH1dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe30se31dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBiYXNlNjQ9X2RlcmVxXyhcImJhc2U2NC1qc1wiKTt2YXIgaWVlZTc1ND1fZGVyZXFfKFwiaWVlZTc1NFwiKTtleHBvcnRzLkJ1ZmZlcj1CdWZmZXI7ZXhwb3J0cy5TbG93QnVmZmVyPUJ1ZmZlcjtleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTPTUwO0J1ZmZlci5wb29sU2l6ZT04MTkyO0J1ZmZlci5fdXNlVHlwZWRBcnJheXM9ZnVuY3Rpb24oKXt0cnl7dmFyIGJ1Zj1uZXcgQXJyYXlCdWZmZXIoMCk7dmFyIGFycj1uZXcgVWludDhBcnJheShidWYpO2Fyci5mb289ZnVuY3Rpb24oKXtyZXR1cm4gNDJ9O3JldHVybiA0Mj09PWFyci5mb28oKSYmdHlwZW9mIGFyci5zdWJhcnJheT09PVwiZnVuY3Rpb25cIn1jYXRjaChlKXtyZXR1cm4gZmFsc2V9fSgpO2Z1bmN0aW9uIEJ1ZmZlcihzdWJqZWN0LGVuY29kaW5nLG5vWmVybyl7aWYoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlyZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LGVuY29kaW5nLG5vWmVybyk7dmFyIHR5cGU9dHlwZW9mIHN1YmplY3Q7aWYoZW5jb2Rpbmc9PT1cImJhc2U2NFwiJiZ0eXBlPT09XCJzdHJpbmdcIil7c3ViamVjdD1zdHJpbmd0cmltKHN1YmplY3QpO3doaWxlKHN1YmplY3QubGVuZ3RoJTQhPT0wKXtzdWJqZWN0PXN1YmplY3QrXCI9XCJ9fXZhciBsZW5ndGg7aWYodHlwZT09PVwibnVtYmVyXCIpbGVuZ3RoPWNvZXJjZShzdWJqZWN0KTtlbHNlIGlmKHR5cGU9PT1cInN0cmluZ1wiKWxlbmd0aD1CdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LGVuY29kaW5nKTtlbHNlIGlmKHR5cGU9PT1cIm9iamVjdFwiKWxlbmd0aD1jb2VyY2Uoc3ViamVjdC5sZW5ndGgpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsIGFycmF5IG9yIHN0cmluZy5cIik7dmFyIGJ1ZjtpZihCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKXtidWY9QnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpfWVsc2V7YnVmPXRoaXM7YnVmLmxlbmd0aD1sZW5ndGg7YnVmLl9pc0J1ZmZlcj10cnVlfXZhciBpO2lmKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMmJnR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGg9PT1cIm51bWJlclwiKXtidWYuX3NldChzdWJqZWN0KX1lbHNlIGlmKGlzQXJyYXlpc2goc3ViamVjdCkpe2lmKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSl7Zm9yKGk9MDtpPGxlbmd0aDtpKyspYnVmW2ldPXN1YmplY3QucmVhZFVJbnQ4KGkpfWVsc2V7Zm9yKGk9MDtpPGxlbmd0aDtpKyspYnVmW2ldPShzdWJqZWN0W2ldJTI1NisyNTYpJTI1Nn19ZWxzZSBpZih0eXBlPT09XCJzdHJpbmdcIil7YnVmLndyaXRlKHN1YmplY3QsMCxlbmNvZGluZyl9ZWxzZSBpZih0eXBlPT09XCJudW1iZXJcIiYmIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMmJiFub1plcm8pe2ZvcihpPTA7aTxsZW5ndGg7aSsrKXtidWZbaV09MH19cmV0dXJuIGJ1Zn1CdWZmZXIuaXNFbmNvZGluZz1mdW5jdGlvbihlbmNvZGluZyl7c3dpdGNoKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSl7Y2FzZVwiaGV4XCI6Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6Y2FzZVwiYXNjaWlcIjpjYXNlXCJiaW5hcnlcIjpjYXNlXCJiYXNlNjRcIjpjYXNlXCJyYXdcIjpjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdHJ1ZTtkZWZhdWx0OnJldHVybiBmYWxzZX19O0J1ZmZlci5pc0J1ZmZlcj1mdW5jdGlvbihiKXtyZXR1cm4hIShiIT09bnVsbCYmYiE9PXVuZGVmaW5lZCYmYi5faXNCdWZmZXIpfTtCdWZmZXIuYnl0ZUxlbmd0aD1mdW5jdGlvbihzdHIsZW5jb2Rpbmcpe3ZhciByZXQ7c3RyPXN0ci50b1N0cmluZygpO3N3aXRjaChlbmNvZGluZ3x8XCJ1dGY4XCIpe2Nhc2VcImhleFwiOnJldD1zdHIubGVuZ3RoLzI7YnJlYWs7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0PXV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoO2JyZWFrO2Nhc2VcImFzY2lpXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwicmF3XCI6cmV0PXN0ci5sZW5ndGg7YnJlYWs7Y2FzZVwiYmFzZTY0XCI6cmV0PWJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGg7YnJlYWs7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0PXN0ci5sZW5ndGgqMjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVua25vd24gZW5jb2RpbmdcIil9cmV0dXJuIHJldH07QnVmZmVyLmNvbmNhdD1mdW5jdGlvbihsaXN0LHRvdGFsTGVuZ3RoKXthc3NlcnQoaXNBcnJheShsaXN0KSxcIlVzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3RbLCBsZW5ndGhdKVwiKTtpZihsaXN0Lmxlbmd0aD09PTApe3JldHVybiBuZXcgQnVmZmVyKDApfWVsc2UgaWYobGlzdC5sZW5ndGg9PT0xKXtyZXR1cm4gbGlzdFswXX12YXIgaTtpZih0b3RhbExlbmd0aD09PXVuZGVmaW5lZCl7dG90YWxMZW5ndGg9MDtmb3IoaT0wO2k8bGlzdC5sZW5ndGg7aSsrKXt0b3RhbExlbmd0aCs9bGlzdFtpXS5sZW5ndGh9fXZhciBidWY9bmV3IEJ1ZmZlcih0b3RhbExlbmd0aCk7dmFyIHBvcz0wO2ZvcihpPTA7aTxsaXN0Lmxlbmd0aDtpKyspe3ZhciBpdGVtPWxpc3RbaV07aXRlbS5jb3B5KGJ1Zixwb3MpO3Bvcys9aXRlbS5sZW5ndGh9cmV0dXJuIGJ1Zn07QnVmZmVyLmNvbXBhcmU9ZnVuY3Rpb24oYSxiKXthc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGEpJiZCdWZmZXIuaXNCdWZmZXIoYiksXCJBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzXCIpO3ZhciB4PWEubGVuZ3RoO3ZhciB5PWIubGVuZ3RoO2Zvcih2YXIgaT0wLGxlbj1NYXRoLm1pbih4LHkpO2k8bGVuJiZhW2ldPT09YltpXTtpKyspe31pZihpIT09bGVuKXt4PWFbaV07eT1iW2ldfWlmKHg8eSl7cmV0dXJuLTF9aWYoeTx4KXtyZXR1cm4gMX1yZXR1cm4gMH07ZnVuY3Rpb24gaGV4V3JpdGUoYnVmLHN0cmluZyxvZmZzZXQsbGVuZ3RoKXtvZmZzZXQ9TnVtYmVyKG9mZnNldCl8fDA7dmFyIHJlbWFpbmluZz1idWYubGVuZ3RoLW9mZnNldDtpZighbGVuZ3RoKXtsZW5ndGg9cmVtYWluaW5nfWVsc2V7bGVuZ3RoPU51bWJlcihsZW5ndGgpO2lmKGxlbmd0aD5yZW1haW5pbmcpe2xlbmd0aD1yZW1haW5pbmd9fXZhciBzdHJMZW49c3RyaW5nLmxlbmd0aDthc3NlcnQoc3RyTGVuJTI9PT0wLFwiSW52YWxpZCBoZXggc3RyaW5nXCIpO2lmKGxlbmd0aD5zdHJMZW4vMil7bGVuZ3RoPXN0ckxlbi8yfWZvcih2YXIgaT0wO2k8bGVuZ3RoO2krKyl7dmFyIGJ5dGU9cGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpKjIsMiksMTYpO2Fzc2VydCghaXNOYU4oYnl0ZSksXCJJbnZhbGlkIGhleCBzdHJpbmdcIik7YnVmW29mZnNldCtpXT1ieXRlfXJldHVybiBpfWZ1bmN0aW9uIHV0ZjhXcml0ZShidWYsc3RyaW5nLG9mZnNldCxsZW5ndGgpe3ZhciBjaGFyc1dyaXR0ZW49YmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLGJ1ZixvZmZzZXQsbGVuZ3RoKTtyZXR1cm4gY2hhcnNXcml0dGVufWZ1bmN0aW9uIGFzY2lpV3JpdGUoYnVmLHN0cmluZyxvZmZzZXQsbGVuZ3RoKXt2YXIgY2hhcnNXcml0dGVuPWJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksYnVmLG9mZnNldCxsZW5ndGgpO3JldHVybiBjaGFyc1dyaXR0ZW59ZnVuY3Rpb24gYmluYXJ5V3JpdGUoYnVmLHN0cmluZyxvZmZzZXQsbGVuZ3RoKXtyZXR1cm4gYXNjaWlXcml0ZShidWYsc3RyaW5nLG9mZnNldCxsZW5ndGgpfWZ1bmN0aW9uIGJhc2U2NFdyaXRlKGJ1ZixzdHJpbmcsb2Zmc2V0LGxlbmd0aCl7dmFyIGNoYXJzV3JpdHRlbj1ibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSxidWYsb2Zmc2V0LGxlbmd0aCk7cmV0dXJuIGNoYXJzV3JpdHRlbn1mdW5jdGlvbiB1dGYxNmxlV3JpdGUoYnVmLHN0cmluZyxvZmZzZXQsbGVuZ3RoKXt2YXIgY2hhcnNXcml0dGVuPWJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSxidWYsb2Zmc2V0LGxlbmd0aCk7cmV0dXJuIGNoYXJzV3JpdHRlbn1CdWZmZXIucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHN0cmluZyxvZmZzZXQsbGVuZ3RoLGVuY29kaW5nKXtpZihpc0Zpbml0ZShvZmZzZXQpKXtpZighaXNGaW5pdGUobGVuZ3RoKSl7ZW5jb2Rpbmc9bGVuZ3RoO2xlbmd0aD11bmRlZmluZWR9fWVsc2V7dmFyIHN3YXA9ZW5jb2Rpbmc7ZW5jb2Rpbmc9b2Zmc2V0O29mZnNldD1sZW5ndGg7bGVuZ3RoPXN3YXB9b2Zmc2V0PU51bWJlcihvZmZzZXQpfHwwO3ZhciByZW1haW5pbmc9dGhpcy5sZW5ndGgtb2Zmc2V0O2lmKCFsZW5ndGgpe2xlbmd0aD1yZW1haW5pbmd9ZWxzZXtsZW5ndGg9TnVtYmVyKGxlbmd0aCk7aWYobGVuZ3RoPnJlbWFpbmluZyl7bGVuZ3RoPXJlbWFpbmluZ319ZW5jb2Rpbmc9U3RyaW5nKGVuY29kaW5nfHxcInV0ZjhcIikudG9Mb3dlckNhc2UoKTt2YXIgcmV0O3N3aXRjaChlbmNvZGluZyl7Y2FzZVwiaGV4XCI6cmV0PWhleFdyaXRlKHRoaXMsc3RyaW5nLG9mZnNldCxsZW5ndGgpO2JyZWFrO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldD11dGY4V3JpdGUodGhpcyxzdHJpbmcsb2Zmc2V0LGxlbmd0aCk7YnJlYWs7Y2FzZVwiYXNjaWlcIjpyZXQ9YXNjaWlXcml0ZSh0aGlzLHN0cmluZyxvZmZzZXQsbGVuZ3RoKTticmVhaztjYXNlXCJiaW5hcnlcIjpyZXQ9YmluYXJ5V3JpdGUodGhpcyxzdHJpbmcsb2Zmc2V0LGxlbmd0aCk7YnJlYWs7Y2FzZVwiYmFzZTY0XCI6cmV0PWJhc2U2NFdyaXRlKHRoaXMsc3RyaW5nLG9mZnNldCxsZW5ndGgpO2JyZWFrO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldD11dGYxNmxlV3JpdGUodGhpcyxzdHJpbmcsb2Zmc2V0LGxlbmd0aCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVuY29kaW5nXCIpfXJldHVybiByZXR9O0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oZW5jb2Rpbmcsc3RhcnQsZW5kKXt2YXIgc2VsZj10aGlzO2VuY29kaW5nPVN0cmluZyhlbmNvZGluZ3x8XCJ1dGY4XCIpLnRvTG93ZXJDYXNlKCk7c3RhcnQ9TnVtYmVyKHN0YXJ0KXx8MDtlbmQ9ZW5kPT09dW5kZWZpbmVkP3NlbGYubGVuZ3RoOk51bWJlcihlbmQpO2lmKGVuZD09PXN0YXJ0KXJldHVyblwiXCI7dmFyIHJldDtzd2l0Y2goZW5jb2Rpbmcpe2Nhc2VcImhleFwiOnJldD1oZXhTbGljZShzZWxmLHN0YXJ0LGVuZCk7YnJlYWs7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0PXV0ZjhTbGljZShzZWxmLHN0YXJ0LGVuZCk7YnJlYWs7Y2FzZVwiYXNjaWlcIjpyZXQ9YXNjaWlTbGljZShzZWxmLHN0YXJ0LGVuZCk7YnJlYWs7Y2FzZVwiYmluYXJ5XCI6cmV0PWJpbmFyeVNsaWNlKHNlbGYsc3RhcnQsZW5kKTticmVhaztjYXNlXCJiYXNlNjRcIjpyZXQ9YmFzZTY0U2xpY2Uoc2VsZixzdGFydCxlbmQpO2JyZWFrO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldD11dGYxNmxlU2xpY2Uoc2VsZixzdGFydCxlbmQpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBlbmNvZGluZ1wiKX1yZXR1cm4gcmV0fTtCdWZmZXIucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnt0eXBlOlwiQnVmZmVyXCIsZGF0YTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnJ8fHRoaXMsMCl9fTtCdWZmZXIucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihiKXthc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGIpLFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtyZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcyxiKT09PTB9O0J1ZmZlci5wcm90b3R5cGUuY29tcGFyZT1mdW5jdGlvbihiKXthc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGIpLFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtyZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcyxiKX07QnVmZmVyLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKHRhcmdldCx0YXJnZXRfc3RhcnQsc3RhcnQsZW5kKXt2YXIgc291cmNlPXRoaXM7aWYoIXN0YXJ0KXN0YXJ0PTA7aWYoIWVuZCYmZW5kIT09MCllbmQ9dGhpcy5sZW5ndGg7aWYoIXRhcmdldF9zdGFydCl0YXJnZXRfc3RhcnQ9MDtpZihlbmQ9PT1zdGFydClyZXR1cm47aWYodGFyZ2V0Lmxlbmd0aD09PTB8fHNvdXJjZS5sZW5ndGg9PT0wKXJldHVybjthc3NlcnQoZW5kPj1zdGFydCxcInNvdXJjZUVuZCA8IHNvdXJjZVN0YXJ0XCIpO2Fzc2VydCh0YXJnZXRfc3RhcnQ+PTAmJnRhcmdldF9zdGFydDx0YXJnZXQubGVuZ3RoLFwidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kc1wiKTthc3NlcnQoc3RhcnQ+PTAmJnN0YXJ0PHNvdXJjZS5sZW5ndGgsXCJzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzXCIpO2Fzc2VydChlbmQ+PTAmJmVuZDw9c291cmNlLmxlbmd0aCxcInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzXCIpO2lmKGVuZD50aGlzLmxlbmd0aCllbmQ9dGhpcy5sZW5ndGg7aWYodGFyZ2V0Lmxlbmd0aC10YXJnZXRfc3RhcnQ8ZW5kLXN0YXJ0KWVuZD10YXJnZXQubGVuZ3RoLXRhcmdldF9zdGFydCtzdGFydDt2YXIgbGVuPWVuZC1zdGFydDtpZihsZW48MTAwfHwhQnVmZmVyLl91c2VUeXBlZEFycmF5cyl7Zm9yKHZhciBpPTA7aTxsZW47aSsrKXt0YXJnZXRbaSt0YXJnZXRfc3RhcnRdPXRoaXNbaStzdGFydF19fWVsc2V7dGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCxzdGFydCtsZW4pLHRhcmdldF9zdGFydCl9fTtmdW5jdGlvbiBiYXNlNjRTbGljZShidWYsc3RhcnQsZW5kKXtpZihzdGFydD09PTAmJmVuZD09PWJ1Zi5sZW5ndGgpe3JldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpfWVsc2V7cmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCxlbmQpKX19ZnVuY3Rpb24gdXRmOFNsaWNlKGJ1ZixzdGFydCxlbmQpe3ZhciByZXM9XCJcIjt2YXIgdG1wPVwiXCI7ZW5kPU1hdGgubWluKGJ1Zi5sZW5ndGgsZW5kKTtmb3IodmFyIGk9c3RhcnQ7aTxlbmQ7aSsrKXtpZihidWZbaV08PTEyNyl7cmVzKz1kZWNvZGVVdGY4Q2hhcih0bXApK1N0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTt0bXA9XCJcIn1lbHNle3RtcCs9XCIlXCIrYnVmW2ldLnRvU3RyaW5nKDE2KX19cmV0dXJuIHJlcytkZWNvZGVVdGY4Q2hhcih0bXApfWZ1bmN0aW9uIGFzY2lpU2xpY2UoYnVmLHN0YXJ0LGVuZCl7dmFyIHJldD1cIlwiO2VuZD1NYXRoLm1pbihidWYubGVuZ3RoLGVuZCk7Zm9yKHZhciBpPXN0YXJ0O2k8ZW5kO2krKyl7cmV0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSl9cmV0dXJuIHJldH1mdW5jdGlvbiBiaW5hcnlTbGljZShidWYsc3RhcnQsZW5kKXtyZXR1cm4gYXNjaWlTbGljZShidWYsc3RhcnQsZW5kKX1mdW5jdGlvbiBoZXhTbGljZShidWYsc3RhcnQsZW5kKXt2YXIgbGVuPWJ1Zi5sZW5ndGg7aWYoIXN0YXJ0fHxzdGFydDwwKXN0YXJ0PTA7aWYoIWVuZHx8ZW5kPDB8fGVuZD5sZW4pZW5kPWxlbjt2YXIgb3V0PVwiXCI7Zm9yKHZhciBpPXN0YXJ0O2k8ZW5kO2krKyl7b3V0Kz10b0hleChidWZbaV0pfXJldHVybiBvdXR9ZnVuY3Rpb24gdXRmMTZsZVNsaWNlKGJ1ZixzdGFydCxlbmQpe3ZhciBieXRlcz1idWYuc2xpY2Uoc3RhcnQsZW5kKTt2YXIgcmVzPVwiXCI7Zm9yKHZhciBpPTA7aTxieXRlcy5sZW5ndGg7aSs9Mil7cmVzKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldK2J5dGVzW2krMV0qMjU2KX1yZXR1cm4gcmVzfUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24oc3RhcnQsZW5kKXt2YXIgbGVuPXRoaXMubGVuZ3RoO3N0YXJ0PWNsYW1wKHN0YXJ0LGxlbiwwKTtlbmQ9Y2xhbXAoZW5kLGxlbixsZW4pO2lmKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpe3JldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCxlbmQpKX1lbHNle3ZhciBzbGljZUxlbj1lbmQtc3RhcnQ7dmFyIG5ld0J1Zj1uZXcgQnVmZmVyKHNsaWNlTGVuLHVuZGVmaW5lZCx0cnVlKTtmb3IodmFyIGk9MDtpPHNsaWNlTGVuO2krKyl7bmV3QnVmW2ldPXRoaXNbaStzdGFydF19cmV0dXJuIG5ld0J1Zn19O0J1ZmZlci5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKG9mZnNldCl7Y29uc29sZS5sb2coXCIuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC5cIik7cmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldCl9O0J1ZmZlci5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHYsb2Zmc2V0KXtjb25zb2xlLmxvZyhcIi5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLlwiKTtyZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsb2Zmc2V0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDg9ZnVuY3Rpb24ob2Zmc2V0LG5vQXNzZXJ0KXtpZighbm9Bc3NlcnQpe2Fzc2VydChvZmZzZXQhPT11bmRlZmluZWQmJm9mZnNldCE9PW51bGwsXCJtaXNzaW5nIG9mZnNldFwiKTthc3NlcnQob2Zmc2V0PHRoaXMubGVuZ3RoLFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIil9aWYob2Zmc2V0Pj10aGlzLmxlbmd0aClyZXR1cm47cmV0dXJuIHRoaXNbb2Zmc2V0XX07ZnVuY3Rpb24gcmVhZFVJbnQxNihidWYsb2Zmc2V0LGxpdHRsZUVuZGlhbixub0Fzc2VydCl7aWYoIW5vQXNzZXJ0KXthc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbj09PVwiYm9vbGVhblwiLFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblwiKTthc3NlcnQob2Zmc2V0IT09dW5kZWZpbmVkJiZvZmZzZXQhPT1udWxsLFwibWlzc2luZyBvZmZzZXRcIik7YXNzZXJ0KG9mZnNldCsxPGJ1Zi5sZW5ndGgsXCJUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX12YXIgbGVuPWJ1Zi5sZW5ndGg7aWYob2Zmc2V0Pj1sZW4pcmV0dXJuO3ZhciB2YWw7aWYobGl0dGxlRW5kaWFuKXt2YWw9YnVmW29mZnNldF07aWYob2Zmc2V0KzE8bGVuKXZhbHw9YnVmW29mZnNldCsxXTw8OH1lbHNle3ZhbD1idWZbb2Zmc2V0XTw8ODtpZihvZmZzZXQrMTxsZW4pdmFsfD1idWZbb2Zmc2V0KzFdfXJldHVybiB2YWx9QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24ob2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gcmVhZFVJbnQxNih0aGlzLG9mZnNldCx0cnVlLG5vQXNzZXJ0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24ob2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gcmVhZFVJbnQxNih0aGlzLG9mZnNldCxmYWxzZSxub0Fzc2VydCl9O2Z1bmN0aW9uIHJlYWRVSW50MzIoYnVmLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpe2lmKCFub0Fzc2VydCl7YXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW49PT1cImJvb2xlYW5cIixcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cIik7YXNzZXJ0KG9mZnNldCE9PXVuZGVmaW5lZCYmb2Zmc2V0IT09bnVsbCxcIm1pc3Npbmcgb2Zmc2V0XCIpO2Fzc2VydChvZmZzZXQrMzxidWYubGVuZ3RoLFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIil9dmFyIGxlbj1idWYubGVuZ3RoO2lmKG9mZnNldD49bGVuKXJldHVybjt2YXIgdmFsO2lmKGxpdHRsZUVuZGlhbil7aWYob2Zmc2V0KzI8bGVuKXZhbD1idWZbb2Zmc2V0KzJdPDwxNjtpZihvZmZzZXQrMTxsZW4pdmFsfD1idWZbb2Zmc2V0KzFdPDw4O3ZhbHw9YnVmW29mZnNldF07aWYob2Zmc2V0KzM8bGVuKXZhbD12YWwrKGJ1ZltvZmZzZXQrM108PDI0Pj4+MCl9ZWxzZXtpZihvZmZzZXQrMTxsZW4pdmFsPWJ1ZltvZmZzZXQrMV08PDE2O2lmKG9mZnNldCsyPGxlbil2YWx8PWJ1ZltvZmZzZXQrMl08PDg7aWYob2Zmc2V0KzM8bGVuKXZhbHw9YnVmW29mZnNldCszXTt2YWw9dmFsKyhidWZbb2Zmc2V0XTw8MjQ+Pj4wKX1yZXR1cm4gdmFsfUJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFPWZ1bmN0aW9uKG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHJlYWRVSW50MzIodGhpcyxvZmZzZXQsdHJ1ZSxub0Fzc2VydCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uKG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHJlYWRVSW50MzIodGhpcyxvZmZzZXQsZmFsc2Usbm9Bc3NlcnQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4PWZ1bmN0aW9uKG9mZnNldCxub0Fzc2VydCl7aWYoIW5vQXNzZXJ0KXthc3NlcnQob2Zmc2V0IT09dW5kZWZpbmVkJiZvZmZzZXQhPT1udWxsLFwibWlzc2luZyBvZmZzZXRcIik7YXNzZXJ0KG9mZnNldDx0aGlzLmxlbmd0aCxcIlRyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfWlmKG9mZnNldD49dGhpcy5sZW5ndGgpcmV0dXJuO3ZhciBuZWc9dGhpc1tvZmZzZXRdJjEyODtpZihuZWcpcmV0dXJuKDI1NS10aGlzW29mZnNldF0rMSkqLTE7ZWxzZSByZXR1cm4gdGhpc1tvZmZzZXRdfTtmdW5jdGlvbiByZWFkSW50MTYoYnVmLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpe2lmKCFub0Fzc2VydCl7YXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW49PT1cImJvb2xlYW5cIixcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cIik7YXNzZXJ0KG9mZnNldCE9PXVuZGVmaW5lZCYmb2Zmc2V0IT09bnVsbCxcIm1pc3Npbmcgb2Zmc2V0XCIpO2Fzc2VydChvZmZzZXQrMTxidWYubGVuZ3RoLFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIil9dmFyIGxlbj1idWYubGVuZ3RoO2lmKG9mZnNldD49bGVuKXJldHVybjt2YXIgdmFsPXJlYWRVSW50MTYoYnVmLG9mZnNldCxsaXR0bGVFbmRpYW4sdHJ1ZSk7dmFyIG5lZz12YWwmMzI3Njg7aWYobmVnKXJldHVybig2NTUzNS12YWwrMSkqLTE7ZWxzZSByZXR1cm4gdmFsfUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEU9ZnVuY3Rpb24ob2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gcmVhZEludDE2KHRoaXMsb2Zmc2V0LHRydWUsbm9Bc3NlcnQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFPWZ1bmN0aW9uKG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHJlYWRJbnQxNih0aGlzLG9mZnNldCxmYWxzZSxub0Fzc2VydCl9O2Z1bmN0aW9uIHJlYWRJbnQzMihidWYsb2Zmc2V0LGxpdHRsZUVuZGlhbixub0Fzc2VydCl7aWYoIW5vQXNzZXJ0KXthc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbj09PVwiYm9vbGVhblwiLFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblwiKTthc3NlcnQob2Zmc2V0IT09dW5kZWZpbmVkJiZvZmZzZXQhPT1udWxsLFwibWlzc2luZyBvZmZzZXRcIik7YXNzZXJ0KG9mZnNldCszPGJ1Zi5sZW5ndGgsXCJUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX12YXIgbGVuPWJ1Zi5sZW5ndGg7aWYob2Zmc2V0Pj1sZW4pcmV0dXJuO3ZhciB2YWw9cmVhZFVJbnQzMihidWYsb2Zmc2V0LGxpdHRsZUVuZGlhbix0cnVlKTt2YXIgbmVnPXZhbCYyMTQ3NDgzNjQ4O2lmKG5lZylyZXR1cm4oNDI5NDk2NzI5NS12YWwrMSkqLTE7ZWxzZSByZXR1cm4gdmFsfUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEU9ZnVuY3Rpb24ob2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gcmVhZEludDMyKHRoaXMsb2Zmc2V0LHRydWUsbm9Bc3NlcnQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uKG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHJlYWRJbnQzMih0aGlzLG9mZnNldCxmYWxzZSxub0Fzc2VydCl9O2Z1bmN0aW9uIHJlYWRGbG9hdChidWYsb2Zmc2V0LGxpdHRsZUVuZGlhbixub0Fzc2VydCl7aWYoIW5vQXNzZXJ0KXthc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbj09PVwiYm9vbGVhblwiLFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblwiKTthc3NlcnQob2Zmc2V0KzM8YnVmLmxlbmd0aCxcIlRyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfXJldHVybiBpZWVlNzU0LnJlYWQoYnVmLG9mZnNldCxsaXR0bGVFbmRpYW4sMjMsNCl9QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRT1mdW5jdGlvbihvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiByZWFkRmxvYXQodGhpcyxvZmZzZXQsdHJ1ZSxub0Fzc2VydCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkU9ZnVuY3Rpb24ob2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gcmVhZEZsb2F0KHRoaXMsb2Zmc2V0LGZhbHNlLG5vQXNzZXJ0KX07ZnVuY3Rpb24gcmVhZERvdWJsZShidWYsb2Zmc2V0LGxpdHRsZUVuZGlhbixub0Fzc2VydCl7aWYoIW5vQXNzZXJ0KXthc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbj09PVwiYm9vbGVhblwiLFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblwiKTthc3NlcnQob2Zmc2V0Kzc8YnVmLmxlbmd0aCxcIlRyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfXJldHVybiBpZWVlNzU0LnJlYWQoYnVmLG9mZnNldCxsaXR0bGVFbmRpYW4sNTIsOCl9QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEU9ZnVuY3Rpb24ob2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gcmVhZERvdWJsZSh0aGlzLG9mZnNldCx0cnVlLG5vQXNzZXJ0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU9ZnVuY3Rpb24ob2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gcmVhZERvdWJsZSh0aGlzLG9mZnNldCxmYWxzZSxub0Fzc2VydCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OD1mdW5jdGlvbih2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe2lmKCFub0Fzc2VydCl7YXNzZXJ0KHZhbHVlIT09dW5kZWZpbmVkJiZ2YWx1ZSE9PW51bGwsXCJtaXNzaW5nIHZhbHVlXCIpO2Fzc2VydChvZmZzZXQhPT11bmRlZmluZWQmJm9mZnNldCE9PW51bGwsXCJtaXNzaW5nIG9mZnNldFwiKTthc3NlcnQob2Zmc2V0PHRoaXMubGVuZ3RoLFwidHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpO3ZlcmlmdWludCh2YWx1ZSwyNTUpfWlmKG9mZnNldD49dGhpcy5sZW5ndGgpcmV0dXJuO3RoaXNbb2Zmc2V0XT12YWx1ZTtyZXR1cm4gb2Zmc2V0KzF9O2Z1bmN0aW9uIHdyaXRlVUludDE2KGJ1Zix2YWx1ZSxvZmZzZXQsbGl0dGxlRW5kaWFuLG5vQXNzZXJ0KXtpZighbm9Bc3NlcnQpe2Fzc2VydCh2YWx1ZSE9PXVuZGVmaW5lZCYmdmFsdWUhPT1udWxsLFwibWlzc2luZyB2YWx1ZVwiKTthc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbj09PVwiYm9vbGVhblwiLFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblwiKTthc3NlcnQob2Zmc2V0IT09dW5kZWZpbmVkJiZvZmZzZXQhPT1udWxsLFwibWlzc2luZyBvZmZzZXRcIik7YXNzZXJ0KG9mZnNldCsxPGJ1Zi5sZW5ndGgsXCJ0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIik7dmVyaWZ1aW50KHZhbHVlLDY1NTM1KX12YXIgbGVuPWJ1Zi5sZW5ndGg7aWYob2Zmc2V0Pj1sZW4pcmV0dXJuO2Zvcih2YXIgaT0wLGo9TWF0aC5taW4obGVuLW9mZnNldCwyKTtpPGo7aSsrKXtidWZbb2Zmc2V0K2ldPSh2YWx1ZSYyNTU8PDgqKGxpdHRsZUVuZGlhbj9pOjEtaSkpPj4+KGxpdHRsZUVuZGlhbj9pOjEtaSkqOH1yZXR1cm4gb2Zmc2V0KzJ9QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHdyaXRlVUludDE2KHRoaXMsdmFsdWUsb2Zmc2V0LHRydWUsbm9Bc3NlcnQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24odmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gd3JpdGVVSW50MTYodGhpcyx2YWx1ZSxvZmZzZXQsZmFsc2Usbm9Bc3NlcnQpfTtmdW5jdGlvbiB3cml0ZVVJbnQzMihidWYsdmFsdWUsb2Zmc2V0LGxpdHRsZUVuZGlhbixub0Fzc2VydCl7aWYoIW5vQXNzZXJ0KXthc3NlcnQodmFsdWUhPT11bmRlZmluZWQmJnZhbHVlIT09bnVsbCxcIm1pc3NpbmcgdmFsdWVcIik7YXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW49PT1cImJvb2xlYW5cIixcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cIik7YXNzZXJ0KG9mZnNldCE9PXVuZGVmaW5lZCYmb2Zmc2V0IT09bnVsbCxcIm1pc3Npbmcgb2Zmc2V0XCIpO2Fzc2VydChvZmZzZXQrMzxidWYubGVuZ3RoLFwidHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpO3ZlcmlmdWludCh2YWx1ZSw0Mjk0OTY3Mjk1KX12YXIgbGVuPWJ1Zi5sZW5ndGg7aWYob2Zmc2V0Pj1sZW4pcmV0dXJuO2Zvcih2YXIgaT0wLGo9TWF0aC5taW4obGVuLW9mZnNldCw0KTtpPGo7aSsrKXtidWZbb2Zmc2V0K2ldPXZhbHVlPj4+KGxpdHRsZUVuZGlhbj9pOjMtaSkqOCYyNTV9cmV0dXJuIG9mZnNldCs0fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRT1mdW5jdGlvbih2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiB3cml0ZVVJbnQzMih0aGlzLHZhbHVlLG9mZnNldCx0cnVlLG5vQXNzZXJ0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHdyaXRlVUludDMyKHRoaXMsdmFsdWUsb2Zmc2V0LGZhbHNlLG5vQXNzZXJ0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24odmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXtpZighbm9Bc3NlcnQpe2Fzc2VydCh2YWx1ZSE9PXVuZGVmaW5lZCYmdmFsdWUhPT1udWxsLFwibWlzc2luZyB2YWx1ZVwiKTthc3NlcnQob2Zmc2V0IT09dW5kZWZpbmVkJiZvZmZzZXQhPT1udWxsLFwibWlzc2luZyBvZmZzZXRcIik7YXNzZXJ0KG9mZnNldDx0aGlzLmxlbmd0aCxcIlRyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKTt2ZXJpZnNpbnQodmFsdWUsMTI3LC0xMjgpfWlmKG9mZnNldD49dGhpcy5sZW5ndGgpcmV0dXJuO2lmKHZhbHVlPj0wKXRoaXMud3JpdGVVSW50OCh2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpO2Vsc2UgdGhpcy53cml0ZVVJbnQ4KDI1NSt2YWx1ZSsxLG9mZnNldCxub0Fzc2VydCk7cmV0dXJuIG9mZnNldCsxfTtmdW5jdGlvbiB3cml0ZUludDE2KGJ1Zix2YWx1ZSxvZmZzZXQsbGl0dGxlRW5kaWFuLG5vQXNzZXJ0KXtpZighbm9Bc3NlcnQpe2Fzc2VydCh2YWx1ZSE9PXVuZGVmaW5lZCYmdmFsdWUhPT1udWxsLFwibWlzc2luZyB2YWx1ZVwiKTthc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbj09PVwiYm9vbGVhblwiLFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblwiKTthc3NlcnQob2Zmc2V0IT09dW5kZWZpbmVkJiZvZmZzZXQhPT1udWxsLFwibWlzc2luZyBvZmZzZXRcIik7YXNzZXJ0KG9mZnNldCsxPGJ1Zi5sZW5ndGgsXCJUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIik7dmVyaWZzaW50KHZhbHVlLDMyNzY3LC0zMjc2OCl9dmFyIGxlbj1idWYubGVuZ3RoO2lmKG9mZnNldD49bGVuKXJldHVybjtpZih2YWx1ZT49MCl3cml0ZVVJbnQxNihidWYsdmFsdWUsb2Zmc2V0LGxpdHRsZUVuZGlhbixub0Fzc2VydCk7ZWxzZSB3cml0ZVVJbnQxNihidWYsNjU1MzUrdmFsdWUrMSxvZmZzZXQsbGl0dGxlRW5kaWFuLG5vQXNzZXJ0KTtyZXR1cm4gb2Zmc2V0KzJ9QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEU9ZnVuY3Rpb24odmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gd3JpdGVJbnQxNih0aGlzLHZhbHVlLG9mZnNldCx0cnVlLG5vQXNzZXJ0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkU9ZnVuY3Rpb24odmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gd3JpdGVJbnQxNih0aGlzLHZhbHVlLG9mZnNldCxmYWxzZSxub0Fzc2VydCl9O2Z1bmN0aW9uIHdyaXRlSW50MzIoYnVmLHZhbHVlLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpe2lmKCFub0Fzc2VydCl7YXNzZXJ0KHZhbHVlIT09dW5kZWZpbmVkJiZ2YWx1ZSE9PW51bGwsXCJtaXNzaW5nIHZhbHVlXCIpO2Fzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuPT09XCJib29sZWFuXCIsXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXCIpO2Fzc2VydChvZmZzZXQhPT11bmRlZmluZWQmJm9mZnNldCE9PW51bGwsXCJtaXNzaW5nIG9mZnNldFwiKTthc3NlcnQob2Zmc2V0KzM8YnVmLmxlbmd0aCxcIlRyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKTt2ZXJpZnNpbnQodmFsdWUsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCl9dmFyIGxlbj1idWYubGVuZ3RoO2lmKG9mZnNldD49bGVuKXJldHVybjtpZih2YWx1ZT49MCl3cml0ZVVJbnQzMihidWYsdmFsdWUsb2Zmc2V0LGxpdHRsZUVuZGlhbixub0Fzc2VydCk7ZWxzZSB3cml0ZVVJbnQzMihidWYsNDI5NDk2NzI5NSt2YWx1ZSsxLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpO3JldHVybiBvZmZzZXQrNH1CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRT1mdW5jdGlvbih2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiB3cml0ZUludDMyKHRoaXMsdmFsdWUsb2Zmc2V0LHRydWUsbm9Bc3NlcnQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRT1mdW5jdGlvbih2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiB3cml0ZUludDMyKHRoaXMsdmFsdWUsb2Zmc2V0LGZhbHNlLG5vQXNzZXJ0KX07ZnVuY3Rpb24gd3JpdGVGbG9hdChidWYsdmFsdWUsb2Zmc2V0LGxpdHRsZUVuZGlhbixub0Fzc2VydCl7aWYoIW5vQXNzZXJ0KXthc3NlcnQodmFsdWUhPT11bmRlZmluZWQmJnZhbHVlIT09bnVsbCxcIm1pc3NpbmcgdmFsdWVcIik7YXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW49PT1cImJvb2xlYW5cIixcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cIik7YXNzZXJ0KG9mZnNldCE9PXVuZGVmaW5lZCYmb2Zmc2V0IT09bnVsbCxcIm1pc3Npbmcgb2Zmc2V0XCIpO2Fzc2VydChvZmZzZXQrMzxidWYubGVuZ3RoLFwiVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpO3ZlcmlmSUVFRTc1NCh2YWx1ZSwzLjQwMjgyMzQ2NjM4NTI4ODZlMzgsLTMuNDAyODIzNDY2Mzg1Mjg4NmUzOCl9dmFyIGxlbj1idWYubGVuZ3RoO2lmKG9mZnNldD49bGVuKXJldHVybjtpZWVlNzU0LndyaXRlKGJ1Zix2YWx1ZSxvZmZzZXQsbGl0dGxlRW5kaWFuLDIzLDQpO3JldHVybiBvZmZzZXQrNFxufUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFPWZ1bmN0aW9uKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyx2YWx1ZSxvZmZzZXQsdHJ1ZSxub0Fzc2VydCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFPWZ1bmN0aW9uKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyx2YWx1ZSxvZmZzZXQsZmFsc2Usbm9Bc3NlcnQpfTtmdW5jdGlvbiB3cml0ZURvdWJsZShidWYsdmFsdWUsb2Zmc2V0LGxpdHRsZUVuZGlhbixub0Fzc2VydCl7aWYoIW5vQXNzZXJ0KXthc3NlcnQodmFsdWUhPT11bmRlZmluZWQmJnZhbHVlIT09bnVsbCxcIm1pc3NpbmcgdmFsdWVcIik7YXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW49PT1cImJvb2xlYW5cIixcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cIik7YXNzZXJ0KG9mZnNldCE9PXVuZGVmaW5lZCYmb2Zmc2V0IT09bnVsbCxcIm1pc3Npbmcgb2Zmc2V0XCIpO2Fzc2VydChvZmZzZXQrNzxidWYubGVuZ3RoLFwiVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpO3ZlcmlmSUVFRTc1NCh2YWx1ZSwxLjc5NzY5MzEzNDg2MjMxNTdlMzA4LC0xLjc5NzY5MzEzNDg2MjMxNTdlMzA4KX12YXIgbGVuPWJ1Zi5sZW5ndGg7aWYob2Zmc2V0Pj1sZW4pcmV0dXJuO2llZWU3NTQud3JpdGUoYnVmLHZhbHVlLG9mZnNldCxsaXR0bGVFbmRpYW4sNTIsOCk7cmV0dXJuIG9mZnNldCs4fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRT1mdW5jdGlvbih2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiB3cml0ZURvdWJsZSh0aGlzLHZhbHVlLG9mZnNldCx0cnVlLG5vQXNzZXJ0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFPWZ1bmN0aW9uKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsdmFsdWUsb2Zmc2V0LGZhbHNlLG5vQXNzZXJ0KX07QnVmZmVyLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKHZhbHVlLHN0YXJ0LGVuZCl7aWYoIXZhbHVlKXZhbHVlPTA7aWYoIXN0YXJ0KXN0YXJ0PTA7aWYoIWVuZCllbmQ9dGhpcy5sZW5ndGg7YXNzZXJ0KGVuZD49c3RhcnQsXCJlbmQgPCBzdGFydFwiKTtpZihlbmQ9PT1zdGFydClyZXR1cm47aWYodGhpcy5sZW5ndGg9PT0wKXJldHVybjthc3NlcnQoc3RhcnQ+PTAmJnN0YXJ0PHRoaXMubGVuZ3RoLFwic3RhcnQgb3V0IG9mIGJvdW5kc1wiKTthc3NlcnQoZW5kPj0wJiZlbmQ8PXRoaXMubGVuZ3RoLFwiZW5kIG91dCBvZiBib3VuZHNcIik7dmFyIGk7aWYodHlwZW9mIHZhbHVlPT09XCJudW1iZXJcIil7Zm9yKGk9c3RhcnQ7aTxlbmQ7aSsrKXt0aGlzW2ldPXZhbHVlfX1lbHNle3ZhciBieXRlcz11dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKTt2YXIgbGVuPWJ5dGVzLmxlbmd0aDtmb3IoaT1zdGFydDtpPGVuZDtpKyspe3RoaXNbaV09Ynl0ZXNbaSVsZW5dfX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0PWZ1bmN0aW9uKCl7dmFyIG91dD1bXTt2YXIgbGVuPXRoaXMubGVuZ3RoO2Zvcih2YXIgaT0wO2k8bGVuO2krKyl7b3V0W2ldPXRvSGV4KHRoaXNbaV0pO2lmKGk9PT1leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKXtvdXRbaSsxXT1cIi4uLlwiO2JyZWFrfX1yZXR1cm5cIjxCdWZmZXIgXCIrb3V0LmpvaW4oXCIgXCIpK1wiPlwifTtCdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXI9ZnVuY3Rpb24oKXtpZih0eXBlb2YgVWludDhBcnJheSE9PVwidW5kZWZpbmVkXCIpe2lmKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpe3JldHVybiBuZXcgQnVmZmVyKHRoaXMpLmJ1ZmZlcn1lbHNle3ZhciBidWY9bmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpO2Zvcih2YXIgaT0wLGxlbj1idWYubGVuZ3RoO2k8bGVuO2krPTEpe2J1ZltpXT10aGlzW2ldfXJldHVybiBidWYuYnVmZmVyfX1lbHNle3Rocm93IG5ldyBFcnJvcihcIkJ1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpfX07dmFyIEJQPUJ1ZmZlci5wcm90b3R5cGU7QnVmZmVyLl9hdWdtZW50PWZ1bmN0aW9uKGFycil7YXJyLl9pc0J1ZmZlcj10cnVlO2Fyci5fZ2V0PWFyci5nZXQ7YXJyLl9zZXQ9YXJyLnNldDthcnIuZ2V0PUJQLmdldDthcnIuc2V0PUJQLnNldDthcnIud3JpdGU9QlAud3JpdGU7YXJyLnRvU3RyaW5nPUJQLnRvU3RyaW5nO2Fyci50b0xvY2FsZVN0cmluZz1CUC50b1N0cmluZzthcnIudG9KU09OPUJQLnRvSlNPTjthcnIuZXF1YWxzPUJQLmVxdWFsczthcnIuY29tcGFyZT1CUC5jb21wYXJlO2Fyci5jb3B5PUJQLmNvcHk7YXJyLnNsaWNlPUJQLnNsaWNlO2Fyci5yZWFkVUludDg9QlAucmVhZFVJbnQ4O2Fyci5yZWFkVUludDE2TEU9QlAucmVhZFVJbnQxNkxFO2Fyci5yZWFkVUludDE2QkU9QlAucmVhZFVJbnQxNkJFO2Fyci5yZWFkVUludDMyTEU9QlAucmVhZFVJbnQzMkxFO2Fyci5yZWFkVUludDMyQkU9QlAucmVhZFVJbnQzMkJFO2Fyci5yZWFkSW50OD1CUC5yZWFkSW50ODthcnIucmVhZEludDE2TEU9QlAucmVhZEludDE2TEU7YXJyLnJlYWRJbnQxNkJFPUJQLnJlYWRJbnQxNkJFO2Fyci5yZWFkSW50MzJMRT1CUC5yZWFkSW50MzJMRTthcnIucmVhZEludDMyQkU9QlAucmVhZEludDMyQkU7YXJyLnJlYWRGbG9hdExFPUJQLnJlYWRGbG9hdExFO2Fyci5yZWFkRmxvYXRCRT1CUC5yZWFkRmxvYXRCRTthcnIucmVhZERvdWJsZUxFPUJQLnJlYWREb3VibGVMRTthcnIucmVhZERvdWJsZUJFPUJQLnJlYWREb3VibGVCRTthcnIud3JpdGVVSW50OD1CUC53cml0ZVVJbnQ4O2Fyci53cml0ZVVJbnQxNkxFPUJQLndyaXRlVUludDE2TEU7YXJyLndyaXRlVUludDE2QkU9QlAud3JpdGVVSW50MTZCRTthcnIud3JpdGVVSW50MzJMRT1CUC53cml0ZVVJbnQzMkxFO2Fyci53cml0ZVVJbnQzMkJFPUJQLndyaXRlVUludDMyQkU7YXJyLndyaXRlSW50OD1CUC53cml0ZUludDg7YXJyLndyaXRlSW50MTZMRT1CUC53cml0ZUludDE2TEU7YXJyLndyaXRlSW50MTZCRT1CUC53cml0ZUludDE2QkU7YXJyLndyaXRlSW50MzJMRT1CUC53cml0ZUludDMyTEU7YXJyLndyaXRlSW50MzJCRT1CUC53cml0ZUludDMyQkU7YXJyLndyaXRlRmxvYXRMRT1CUC53cml0ZUZsb2F0TEU7YXJyLndyaXRlRmxvYXRCRT1CUC53cml0ZUZsb2F0QkU7YXJyLndyaXRlRG91YmxlTEU9QlAud3JpdGVEb3VibGVMRTthcnIud3JpdGVEb3VibGVCRT1CUC53cml0ZURvdWJsZUJFO2Fyci5maWxsPUJQLmZpbGw7YXJyLmluc3BlY3Q9QlAuaW5zcGVjdDthcnIudG9BcnJheUJ1ZmZlcj1CUC50b0FycmF5QnVmZmVyO3JldHVybiBhcnJ9O2Z1bmN0aW9uIHN0cmluZ3RyaW0oc3RyKXtpZihzdHIudHJpbSlyZXR1cm4gc3RyLnRyaW0oKTtyZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csXCJcIil9ZnVuY3Rpb24gY2xhbXAoaW5kZXgsbGVuLGRlZmF1bHRWYWx1ZSl7aWYodHlwZW9mIGluZGV4IT09XCJudW1iZXJcIilyZXR1cm4gZGVmYXVsdFZhbHVlO2luZGV4PX5+aW5kZXg7aWYoaW5kZXg+PWxlbilyZXR1cm4gbGVuO2lmKGluZGV4Pj0wKXJldHVybiBpbmRleDtpbmRleCs9bGVuO2lmKGluZGV4Pj0wKXJldHVybiBpbmRleDtyZXR1cm4gMH1mdW5jdGlvbiBjb2VyY2UobGVuZ3RoKXtsZW5ndGg9fn5NYXRoLmNlaWwoK2xlbmd0aCk7cmV0dXJuIGxlbmd0aDwwPzA6bGVuZ3RofWZ1bmN0aW9uIGlzQXJyYXkoc3ViamVjdCl7cmV0dXJuKEFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKHN1YmplY3Qpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCk9PT1cIltvYmplY3QgQXJyYXldXCJ9KShzdWJqZWN0KX1mdW5jdGlvbiBpc0FycmF5aXNoKHN1YmplY3Qpe3JldHVybiBpc0FycmF5KHN1YmplY3QpfHxCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCl8fHN1YmplY3QmJnR5cGVvZiBzdWJqZWN0PT09XCJvYmplY3RcIiYmdHlwZW9mIHN1YmplY3QubGVuZ3RoPT09XCJudW1iZXJcIn1mdW5jdGlvbiB0b0hleChuKXtpZihuPDE2KXJldHVyblwiMFwiK24udG9TdHJpbmcoMTYpO3JldHVybiBuLnRvU3RyaW5nKDE2KX1mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpe3ZhciBieXRlQXJyYXk9W107Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoO2krKyl7dmFyIGI9c3RyLmNoYXJDb2RlQXQoaSk7aWYoYjw9MTI3KXtieXRlQXJyYXkucHVzaChiKX1lbHNle3ZhciBzdGFydD1pO2lmKGI+PTU1Mjk2JiZiPD01NzM0MylpKys7dmFyIGg9ZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5zbGljZShzdGFydCxpKzEpKS5zdWJzdHIoMSkuc3BsaXQoXCIlXCIpO2Zvcih2YXIgaj0wO2o8aC5sZW5ndGg7aisrKXtieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLDE2KSl9fX1yZXR1cm4gYnl0ZUFycmF5fWZ1bmN0aW9uIGFzY2lpVG9CeXRlcyhzdHIpe3ZhciBieXRlQXJyYXk9W107Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoO2krKyl7Ynl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkmMjU1KX1yZXR1cm4gYnl0ZUFycmF5fWZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzKHN0cil7dmFyIGMsaGksbG87dmFyIGJ5dGVBcnJheT1bXTtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7aSsrKXtjPXN0ci5jaGFyQ29kZUF0KGkpO2hpPWM+Pjg7bG89YyUyNTY7Ynl0ZUFycmF5LnB1c2gobG8pO2J5dGVBcnJheS5wdXNoKGhpKX1yZXR1cm4gYnl0ZUFycmF5fWZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoc3RyKXtyZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KHN0cil9ZnVuY3Rpb24gYmxpdEJ1ZmZlcihzcmMsZHN0LG9mZnNldCxsZW5ndGgpe2Zvcih2YXIgaT0wO2k8bGVuZ3RoO2krKyl7aWYoaStvZmZzZXQ+PWRzdC5sZW5ndGh8fGk+PXNyYy5sZW5ndGgpYnJlYWs7ZHN0W2krb2Zmc2V0XT1zcmNbaV19cmV0dXJuIGl9ZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIoc3RyKXt0cnl7cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpfWNhdGNoKGVycil7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoNjU1MzMpfX1mdW5jdGlvbiB2ZXJpZnVpbnQodmFsdWUsbWF4KXthc3NlcnQodHlwZW9mIHZhbHVlPT09XCJudW1iZXJcIixcImNhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXJcIik7YXNzZXJ0KHZhbHVlPj0wLFwic3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWVcIik7YXNzZXJ0KHZhbHVlPD1tYXgsXCJ2YWx1ZSBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHZhbHVlIGZvciB0eXBlXCIpO2Fzc2VydChNYXRoLmZsb29yKHZhbHVlKT09PXZhbHVlLFwidmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnRcIil9ZnVuY3Rpb24gdmVyaWZzaW50KHZhbHVlLG1heCxtaW4pe2Fzc2VydCh0eXBlb2YgdmFsdWU9PT1cIm51bWJlclwiLFwiY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlclwiKTthc3NlcnQodmFsdWU8PW1heCxcInZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZVwiKTthc3NlcnQodmFsdWU+PW1pbixcInZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWVcIik7YXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpPT09dmFsdWUsXCJ2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudFwiKX1mdW5jdGlvbiB2ZXJpZklFRUU3NTQodmFsdWUsbWF4LG1pbil7YXNzZXJ0KHR5cGVvZiB2YWx1ZT09PVwibnVtYmVyXCIsXCJjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyXCIpO2Fzc2VydCh2YWx1ZTw9bWF4LFwidmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlXCIpO2Fzc2VydCh2YWx1ZT49bWluLFwidmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZVwiKX1mdW5jdGlvbiBhc3NlcnQodGVzdCxtZXNzYWdlKXtpZighdGVzdCl0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXx8XCJGYWlsZWQgYXNzZXJ0aW9uXCIpfX0se1wiYmFzZTY0LWpzXCI6NixpZWVlNzU0Ojd9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgbG9va3VwPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiOyhmdW5jdGlvbihleHBvcnRzKXtcInVzZSBzdHJpY3RcIjt2YXIgQXJyPXR5cGVvZiBVaW50OEFycmF5IT09XCJ1bmRlZmluZWRcIj9VaW50OEFycmF5OkFycmF5O3ZhciBaRVJPPVwiMFwiLmNoYXJDb2RlQXQoMCk7dmFyIFBMVVM9XCIrXCIuY2hhckNvZGVBdCgwKTt2YXIgU0xBU0g9XCIvXCIuY2hhckNvZGVBdCgwKTt2YXIgTlVNQkVSPVwiMFwiLmNoYXJDb2RlQXQoMCk7dmFyIExPV0VSPVwiYVwiLmNoYXJDb2RlQXQoMCk7dmFyIFVQUEVSPVwiQVwiLmNoYXJDb2RlQXQoMCk7ZnVuY3Rpb24gZGVjb2RlKGVsdCl7dmFyIGNvZGU9ZWx0LmNoYXJDb2RlQXQoMCk7aWYoY29kZT09PVBMVVMpcmV0dXJuIDYyO2lmKGNvZGU9PT1TTEFTSClyZXR1cm4gNjM7aWYoY29kZTxOVU1CRVIpcmV0dXJuLTE7aWYoY29kZTxOVU1CRVIrMTApcmV0dXJuIGNvZGUtTlVNQkVSKzI2KzI2O2lmKGNvZGU8VVBQRVIrMjYpcmV0dXJuIGNvZGUtVVBQRVI7aWYoY29kZTxMT1dFUisyNilyZXR1cm4gY29kZS1MT1dFUisyNn1mdW5jdGlvbiBiNjRUb0J5dGVBcnJheShiNjQpe3ZhciBpLGosbCx0bXAscGxhY2VIb2xkZXJzLGFycjtpZihiNjQubGVuZ3RoJTQ+MCl7dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKX12YXIgbGVuPWI2NC5sZW5ndGg7cGxhY2VIb2xkZXJzPVwiPVwiPT09YjY0LmNoYXJBdChsZW4tMik/MjpcIj1cIj09PWI2NC5jaGFyQXQobGVuLTEpPzE6MDthcnI9bmV3IEFycihiNjQubGVuZ3RoKjMvNC1wbGFjZUhvbGRlcnMpO2w9cGxhY2VIb2xkZXJzPjA/YjY0Lmxlbmd0aC00OmI2NC5sZW5ndGg7dmFyIEw9MDtmdW5jdGlvbiBwdXNoKHYpe2FycltMKytdPXZ9Zm9yKGk9MCxqPTA7aTxsO2krPTQsais9Myl7dG1wPWRlY29kZShiNjQuY2hhckF0KGkpKTw8MTh8ZGVjb2RlKGI2NC5jaGFyQXQoaSsxKSk8PDEyfGRlY29kZShiNjQuY2hhckF0KGkrMikpPDw2fGRlY29kZShiNjQuY2hhckF0KGkrMykpO3B1c2goKHRtcCYxNjcxMTY4MCk+PjE2KTtwdXNoKCh0bXAmNjUyODApPj44KTtwdXNoKHRtcCYyNTUpfWlmKHBsYWNlSG9sZGVycz09PTIpe3RtcD1kZWNvZGUoYjY0LmNoYXJBdChpKSk8PDJ8ZGVjb2RlKGI2NC5jaGFyQXQoaSsxKSk+PjQ7cHVzaCh0bXAmMjU1KX1lbHNlIGlmKHBsYWNlSG9sZGVycz09PTEpe3RtcD1kZWNvZGUoYjY0LmNoYXJBdChpKSk8PDEwfGRlY29kZShiNjQuY2hhckF0KGkrMSkpPDw0fGRlY29kZShiNjQuY2hhckF0KGkrMikpPj4yO3B1c2godG1wPj44JjI1NSk7cHVzaCh0bXAmMjU1KX1yZXR1cm4gYXJyfWZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQodWludDgpe3ZhciBpLGV4dHJhQnl0ZXM9dWludDgubGVuZ3RoJTMsb3V0cHV0PVwiXCIsdGVtcCxsZW5ndGg7ZnVuY3Rpb24gZW5jb2RlKG51bSl7cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKX1mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQobnVtKXtyZXR1cm4gZW5jb2RlKG51bT4+MTgmNjMpK2VuY29kZShudW0+PjEyJjYzKStlbmNvZGUobnVtPj42JjYzKStlbmNvZGUobnVtJjYzKX1mb3IoaT0wLGxlbmd0aD11aW50OC5sZW5ndGgtZXh0cmFCeXRlcztpPGxlbmd0aDtpKz0zKXt0ZW1wPSh1aW50OFtpXTw8MTYpKyh1aW50OFtpKzFdPDw4KSt1aW50OFtpKzJdO291dHB1dCs9dHJpcGxldFRvQmFzZTY0KHRlbXApfXN3aXRjaChleHRyYUJ5dGVzKXtjYXNlIDE6dGVtcD11aW50OFt1aW50OC5sZW5ndGgtMV07b3V0cHV0Kz1lbmNvZGUodGVtcD4+Mik7b3V0cHV0Kz1lbmNvZGUodGVtcDw8NCY2Myk7b3V0cHV0Kz1cIj09XCI7YnJlYWs7Y2FzZSAyOnRlbXA9KHVpbnQ4W3VpbnQ4Lmxlbmd0aC0yXTw8OCkrdWludDhbdWludDgubGVuZ3RoLTFdO291dHB1dCs9ZW5jb2RlKHRlbXA+PjEwKTtvdXRwdXQrPWVuY29kZSh0ZW1wPj40JjYzKTtvdXRwdXQrPWVuY29kZSh0ZW1wPDwyJjYzKTtvdXRwdXQrPVwiPVwiO2JyZWFrfXJldHVybiBvdXRwdXR9bW9kdWxlLmV4cG9ydHMudG9CeXRlQXJyYXk9YjY0VG9CeXRlQXJyYXk7bW9kdWxlLmV4cG9ydHMuZnJvbUJ5dGVBcnJheT11aW50OFRvQmFzZTY0fSkoKX0se31dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe2V4cG9ydHMucmVhZD1mdW5jdGlvbihidWZmZXIsb2Zmc2V0LGlzTEUsbUxlbixuQnl0ZXMpe3ZhciBlLG0sZUxlbj1uQnl0ZXMqOC1tTGVuLTEsZU1heD0oMTw8ZUxlbiktMSxlQmlhcz1lTWF4Pj4xLG5CaXRzPS03LGk9aXNMRT9uQnl0ZXMtMTowLGQ9aXNMRT8tMToxLHM9YnVmZmVyW29mZnNldCtpXTtpKz1kO2U9cyYoMTw8LW5CaXRzKS0xO3M+Pj0tbkJpdHM7bkJpdHMrPWVMZW47Zm9yKDtuQml0cz4wO2U9ZSoyNTYrYnVmZmVyW29mZnNldCtpXSxpKz1kLG5CaXRzLT04KTttPWUmKDE8PC1uQml0cyktMTtlPj49LW5CaXRzO25CaXRzKz1tTGVuO2Zvcig7bkJpdHM+MDttPW0qMjU2K2J1ZmZlcltvZmZzZXQraV0saSs9ZCxuQml0cy09OCk7aWYoZT09PTApe2U9MS1lQmlhc31lbHNlIGlmKGU9PT1lTWF4KXtyZXR1cm4gbT9OYU46KHM/LTE6MSkqSW5maW5pdHl9ZWxzZXttPW0rTWF0aC5wb3coMixtTGVuKTtlPWUtZUJpYXN9cmV0dXJuKHM/LTE6MSkqbSpNYXRoLnBvdygyLGUtbUxlbil9O2V4cG9ydHMud3JpdGU9ZnVuY3Rpb24oYnVmZmVyLHZhbHVlLG9mZnNldCxpc0xFLG1MZW4sbkJ5dGVzKXt2YXIgZSxtLGMsZUxlbj1uQnl0ZXMqOC1tTGVuLTEsZU1heD0oMTw8ZUxlbiktMSxlQmlhcz1lTWF4Pj4xLHJ0PW1MZW49PT0yMz9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjAsaT1pc0xFPzA6bkJ5dGVzLTEsZD1pc0xFPzE6LTEscz12YWx1ZTwwfHx2YWx1ZT09PTAmJjEvdmFsdWU8MD8xOjA7dmFsdWU9TWF0aC5hYnModmFsdWUpO2lmKGlzTmFOKHZhbHVlKXx8dmFsdWU9PT1JbmZpbml0eSl7bT1pc05hTih2YWx1ZSk/MTowO2U9ZU1heH1lbHNle2U9TWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkvTWF0aC5MTjIpO2lmKHZhbHVlKihjPU1hdGgucG93KDIsLWUpKTwxKXtlLS07Yyo9Mn1pZihlK2VCaWFzPj0xKXt2YWx1ZSs9cnQvY31lbHNle3ZhbHVlKz1ydCpNYXRoLnBvdygyLDEtZUJpYXMpfWlmKHZhbHVlKmM+PTIpe2UrKztjLz0yfWlmKGUrZUJpYXM+PWVNYXgpe209MDtlPWVNYXh9ZWxzZSBpZihlK2VCaWFzPj0xKXttPSh2YWx1ZSpjLTEpKk1hdGgucG93KDIsbUxlbik7ZT1lK2VCaWFzfWVsc2V7bT12YWx1ZSpNYXRoLnBvdygyLGVCaWFzLTEpKk1hdGgucG93KDIsbUxlbik7ZT0wfX1mb3IoO21MZW4+PTg7YnVmZmVyW29mZnNldCtpXT1tJjI1NSxpKz1kLG0vPTI1NixtTGVuLT04KTtlPWU8PG1MZW58bTtlTGVuKz1tTGVuO2Zvcig7ZUxlbj4wO2J1ZmZlcltvZmZzZXQraV09ZSYyNTUsaSs9ZCxlLz0yNTYsZUxlbi09OCk7YnVmZmVyW29mZnNldCtpLWRdfD1zKjEyOH19LHt9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgQnVmZmVyPV9kZXJlcV8oXCJidWZmZXJcIikuQnVmZmVyO3ZhciBpbnRTaXplPTQ7dmFyIHplcm9CdWZmZXI9bmV3IEJ1ZmZlcihpbnRTaXplKTt6ZXJvQnVmZmVyLmZpbGwoMCk7dmFyIGNocnN6PTg7ZnVuY3Rpb24gdG9BcnJheShidWYsYmlnRW5kaWFuKXtpZihidWYubGVuZ3RoJWludFNpemUhPT0wKXt2YXIgbGVuPWJ1Zi5sZW5ndGgrKGludFNpemUtYnVmLmxlbmd0aCVpbnRTaXplKTtidWY9QnVmZmVyLmNvbmNhdChbYnVmLHplcm9CdWZmZXJdLGxlbil9dmFyIGFycj1bXTt2YXIgZm49YmlnRW5kaWFuP2J1Zi5yZWFkSW50MzJCRTpidWYucmVhZEludDMyTEU7Zm9yKHZhciBpPTA7aTxidWYubGVuZ3RoO2krPWludFNpemUpe2Fyci5wdXNoKGZuLmNhbGwoYnVmLGkpKX1yZXR1cm4gYXJyfWZ1bmN0aW9uIHRvQnVmZmVyKGFycixzaXplLGJpZ0VuZGlhbil7dmFyIGJ1Zj1uZXcgQnVmZmVyKHNpemUpO3ZhciBmbj1iaWdFbmRpYW4/YnVmLndyaXRlSW50MzJCRTpidWYud3JpdGVJbnQzMkxFO2Zvcih2YXIgaT0wO2k8YXJyLmxlbmd0aDtpKyspe2ZuLmNhbGwoYnVmLGFycltpXSxpKjQsdHJ1ZSl9cmV0dXJuIGJ1Zn1mdW5jdGlvbiBoYXNoKGJ1ZixmbixoYXNoU2l6ZSxiaWdFbmRpYW4pe2lmKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSlidWY9bmV3IEJ1ZmZlcihidWYpO3ZhciBhcnI9Zm4odG9BcnJheShidWYsYmlnRW5kaWFuKSxidWYubGVuZ3RoKmNocnN6KTtyZXR1cm4gdG9CdWZmZXIoYXJyLGhhc2hTaXplLGJpZ0VuZGlhbil9bW9kdWxlLmV4cG9ydHM9e2hhc2g6aGFzaH19LHtidWZmZXI6NX1dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBCdWZmZXI9X2RlcmVxXyhcImJ1ZmZlclwiKS5CdWZmZXI7dmFyIHNoYT1fZGVyZXFfKFwiLi9zaGFcIik7dmFyIHNoYTI1Nj1fZGVyZXFfKFwiLi9zaGEyNTZcIik7dmFyIHJuZz1fZGVyZXFfKFwiLi9ybmdcIik7dmFyIG1kNT1fZGVyZXFfKFwiLi9tZDVcIik7dmFyIGFsZ29yaXRobXM9e3NoYTE6c2hhLHNoYTI1NjpzaGEyNTYsbWQ1Om1kNX07dmFyIGJsb2Nrc2l6ZT02NDt2YXIgemVyb0J1ZmZlcj1uZXcgQnVmZmVyKGJsb2Nrc2l6ZSk7emVyb0J1ZmZlci5maWxsKDApO2Z1bmN0aW9uIGhtYWMoZm4sa2V5LGRhdGEpe2lmKCFCdWZmZXIuaXNCdWZmZXIoa2V5KSlrZXk9bmV3IEJ1ZmZlcihrZXkpO2lmKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpZGF0YT1uZXcgQnVmZmVyKGRhdGEpO2lmKGtleS5sZW5ndGg+YmxvY2tzaXplKXtrZXk9Zm4oa2V5KX1lbHNlIGlmKGtleS5sZW5ndGg8YmxvY2tzaXplKXtrZXk9QnVmZmVyLmNvbmNhdChba2V5LHplcm9CdWZmZXJdLGJsb2Nrc2l6ZSl9dmFyIGlwYWQ9bmV3IEJ1ZmZlcihibG9ja3NpemUpLG9wYWQ9bmV3IEJ1ZmZlcihibG9ja3NpemUpO2Zvcih2YXIgaT0wO2k8YmxvY2tzaXplO2krKyl7aXBhZFtpXT1rZXlbaV1eNTQ7b3BhZFtpXT1rZXlbaV1eOTJ9dmFyIGhhc2g9Zm4oQnVmZmVyLmNvbmNhdChbaXBhZCxkYXRhXSkpO3JldHVybiBmbihCdWZmZXIuY29uY2F0KFtvcGFkLGhhc2hdKSl9ZnVuY3Rpb24gaGFzaChhbGcsa2V5KXthbGc9YWxnfHxcInNoYTFcIjt2YXIgZm49YWxnb3JpdGhtc1thbGddO3ZhciBidWZzPVtdO3ZhciBsZW5ndGg9MDtpZighZm4pZXJyb3IoXCJhbGdvcml0aG06XCIsYWxnLFwiaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7cmV0dXJue3VwZGF0ZTpmdW5jdGlvbihkYXRhKXtpZighQnVmZmVyLmlzQnVmZmVyKGRhdGEpKWRhdGE9bmV3IEJ1ZmZlcihkYXRhKTtidWZzLnB1c2goZGF0YSk7bGVuZ3RoKz1kYXRhLmxlbmd0aDtyZXR1cm4gdGhpc30sZGlnZXN0OmZ1bmN0aW9uKGVuYyl7dmFyIGJ1Zj1CdWZmZXIuY29uY2F0KGJ1ZnMpO3ZhciByPWtleT9obWFjKGZuLGtleSxidWYpOmZuKGJ1Zik7YnVmcz1udWxsO3JldHVybiBlbmM/ci50b1N0cmluZyhlbmMpOnJ9fX1mdW5jdGlvbiBlcnJvcigpe3ZhciBtPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTt0aHJvdyBuZXcgRXJyb3IoW20sXCJ3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0c1wiLFwiaHR0cDovL2dpdGh1Yi5jb20vZG9taW5pY3RhcnIvY3J5cHRvLWJyb3dzZXJpZnlcIl0uam9pbihcIlxcblwiKSl9ZXhwb3J0cy5jcmVhdGVIYXNoPWZ1bmN0aW9uKGFsZyl7cmV0dXJuIGhhc2goYWxnKX07ZXhwb3J0cy5jcmVhdGVIbWFjPWZ1bmN0aW9uKGFsZyxrZXkpe3JldHVybiBoYXNoKGFsZyxrZXkpfTtleHBvcnRzLnJhbmRvbUJ5dGVzPWZ1bmN0aW9uKHNpemUsY2FsbGJhY2spe2lmKGNhbGxiYWNrJiZjYWxsYmFjay5jYWxsKXt0cnl7Y2FsbGJhY2suY2FsbCh0aGlzLHVuZGVmaW5lZCxuZXcgQnVmZmVyKHJuZyhzaXplKSkpfWNhdGNoKGVycil7Y2FsbGJhY2soZXJyKX19ZWxzZXtyZXR1cm4gbmV3IEJ1ZmZlcihybmcoc2l6ZSkpfX07ZnVuY3Rpb24gZWFjaChhLGYpe2Zvcih2YXIgaSBpbiBhKWYoYVtpXSxpKX1lYWNoKFtcImNyZWF0ZUNyZWRlbnRpYWxzXCIsXCJjcmVhdGVDaXBoZXJcIixcImNyZWF0ZUNpcGhlcml2XCIsXCJjcmVhdGVEZWNpcGhlclwiLFwiY3JlYXRlRGVjaXBoZXJpdlwiLFwiY3JlYXRlU2lnblwiLFwiY3JlYXRlVmVyaWZ5XCIsXCJjcmVhdGVEaWZmaWVIZWxsbWFuXCIsXCJwYmtkZjJcIl0sZnVuY3Rpb24obmFtZSl7ZXhwb3J0c1tuYW1lXT1mdW5jdGlvbigpe2Vycm9yKFwic29ycnksXCIsbmFtZSxcImlzIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIil9fSl9LHtcIi4vbWQ1XCI6MTAsXCIuL3JuZ1wiOjExLFwiLi9zaGFcIjoxMixcIi4vc2hhMjU2XCI6MTMsYnVmZmVyOjV9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIGhlbHBlcnM9X2RlcmVxXyhcIi4vaGVscGVyc1wiKTtmdW5jdGlvbiBtZDVfdm1fdGVzdCgpe3JldHVybiBoZXhfbWQ1KFwiYWJjXCIpPT1cIjkwMDE1MDk4M2NkMjRmYjBkNjk2M2Y3ZDI4ZTE3ZjcyXCJ9ZnVuY3Rpb24gY29yZV9tZDUoeCxsZW4pe3hbbGVuPj41XXw9MTI4PDxsZW4lMzI7eFsobGVuKzY0Pj4+OTw8NCkrMTRdPWxlbjt2YXIgYT0xNzMyNTg0MTkzO3ZhciBiPS0yNzE3MzM4Nzk7dmFyIGM9LTE3MzI1ODQxOTQ7dmFyIGQ9MjcxNzMzODc4O2Zvcih2YXIgaT0wO2k8eC5sZW5ndGg7aSs9MTYpe3ZhciBvbGRhPWE7dmFyIG9sZGI9Yjt2YXIgb2xkYz1jO3ZhciBvbGRkPWQ7YT1tZDVfZmYoYSxiLGMsZCx4W2krMF0sNywtNjgwODc2OTM2KTtkPW1kNV9mZihkLGEsYixjLHhbaSsxXSwxMiwtMzg5NTY0NTg2KTtjPW1kNV9mZihjLGQsYSxiLHhbaSsyXSwxNyw2MDYxMDU4MTkpO2I9bWQ1X2ZmKGIsYyxkLGEseFtpKzNdLDIyLC0xMDQ0NTI1MzMwKTthPW1kNV9mZihhLGIsYyxkLHhbaSs0XSw3LC0xNzY0MTg4OTcpO2Q9bWQ1X2ZmKGQsYSxiLGMseFtpKzVdLDEyLDEyMDAwODA0MjYpO2M9bWQ1X2ZmKGMsZCxhLGIseFtpKzZdLDE3LC0xNDczMjMxMzQxKTtiPW1kNV9mZihiLGMsZCxhLHhbaSs3XSwyMiwtNDU3MDU5ODMpO2E9bWQ1X2ZmKGEsYixjLGQseFtpKzhdLDcsMTc3MDAzNTQxNik7ZD1tZDVfZmYoZCxhLGIsYyx4W2krOV0sMTIsLTE5NTg0MTQ0MTcpO2M9bWQ1X2ZmKGMsZCxhLGIseFtpKzEwXSwxNywtNDIwNjMpO2I9bWQ1X2ZmKGIsYyxkLGEseFtpKzExXSwyMiwtMTk5MDQwNDE2Mik7YT1tZDVfZmYoYSxiLGMsZCx4W2krMTJdLDcsMTgwNDYwMzY4Mik7ZD1tZDVfZmYoZCxhLGIsYyx4W2krMTNdLDEyLC00MDM0MTEwMSk7Yz1tZDVfZmYoYyxkLGEsYix4W2krMTRdLDE3LC0xNTAyMDAyMjkwKTtiPW1kNV9mZihiLGMsZCxhLHhbaSsxNV0sMjIsMTIzNjUzNTMyOSk7YT1tZDVfZ2coYSxiLGMsZCx4W2krMV0sNSwtMTY1Nzk2NTEwKTtkPW1kNV9nZyhkLGEsYixjLHhbaSs2XSw5LC0xMDY5NTAxNjMyKTtjPW1kNV9nZyhjLGQsYSxiLHhbaSsxMV0sMTQsNjQzNzE3NzEzKTtiPW1kNV9nZyhiLGMsZCxhLHhbaSswXSwyMCwtMzczODk3MzAyKTthPW1kNV9nZyhhLGIsYyxkLHhbaSs1XSw1LC03MDE1NTg2OTEpO2Q9bWQ1X2dnKGQsYSxiLGMseFtpKzEwXSw5LDM4MDE2MDgzKTtjPW1kNV9nZyhjLGQsYSxiLHhbaSsxNV0sMTQsLTY2MDQ3ODMzNSk7Yj1tZDVfZ2coYixjLGQsYSx4W2krNF0sMjAsLTQwNTUzNzg0OCk7YT1tZDVfZ2coYSxiLGMsZCx4W2krOV0sNSw1Njg0NDY0MzgpO2Q9bWQ1X2dnKGQsYSxiLGMseFtpKzE0XSw5LC0xMDE5ODAzNjkwKTtjPW1kNV9nZyhjLGQsYSxiLHhbaSszXSwxNCwtMTg3MzYzOTYxKTtiPW1kNV9nZyhiLGMsZCxhLHhbaSs4XSwyMCwxMTYzNTMxNTAxKTthPW1kNV9nZyhhLGIsYyxkLHhbaSsxM10sNSwtMTQ0NDY4MTQ2Nyk7ZD1tZDVfZ2coZCxhLGIsYyx4W2krMl0sOSwtNTE0MDM3ODQpO2M9bWQ1X2dnKGMsZCxhLGIseFtpKzddLDE0LDE3MzUzMjg0NzMpO2I9bWQ1X2dnKGIsYyxkLGEseFtpKzEyXSwyMCwtMTkyNjYwNzczNCk7YT1tZDVfaGgoYSxiLGMsZCx4W2krNV0sNCwtMzc4NTU4KTtkPW1kNV9oaChkLGEsYixjLHhbaSs4XSwxMSwtMjAyMjU3NDQ2Myk7Yz1tZDVfaGgoYyxkLGEsYix4W2krMTFdLDE2LDE4MzkwMzA1NjIpO2I9bWQ1X2hoKGIsYyxkLGEseFtpKzE0XSwyMywtMzUzMDk1NTYpO2E9bWQ1X2hoKGEsYixjLGQseFtpKzFdLDQsLTE1MzA5OTIwNjApO2Q9bWQ1X2hoKGQsYSxiLGMseFtpKzRdLDExLDEyNzI4OTMzNTMpO2M9bWQ1X2hoKGMsZCxhLGIseFtpKzddLDE2LC0xNTU0OTc2MzIpO2I9bWQ1X2hoKGIsYyxkLGEseFtpKzEwXSwyMywtMTA5NDczMDY0MCk7YT1tZDVfaGgoYSxiLGMsZCx4W2krMTNdLDQsNjgxMjc5MTc0KTtkPW1kNV9oaChkLGEsYixjLHhbaSswXSwxMSwtMzU4NTM3MjIyKTtjPW1kNV9oaChjLGQsYSxiLHhbaSszXSwxNiwtNzIyNTIxOTc5KTtiPW1kNV9oaChiLGMsZCxhLHhbaSs2XSwyMyw3NjAyOTE4OSk7YT1tZDVfaGgoYSxiLGMsZCx4W2krOV0sNCwtNjQwMzY0NDg3KTtkPW1kNV9oaChkLGEsYixjLHhbaSsxMl0sMTEsLTQyMTgxNTgzNSk7Yz1tZDVfaGgoYyxkLGEsYix4W2krMTVdLDE2LDUzMDc0MjUyMCk7Yj1tZDVfaGgoYixjLGQsYSx4W2krMl0sMjMsLTk5NTMzODY1MSk7YT1tZDVfaWkoYSxiLGMsZCx4W2krMF0sNiwtMTk4NjMwODQ0KTtkPW1kNV9paShkLGEsYixjLHhbaSs3XSwxMCwxMTI2ODkxNDE1KTtjPW1kNV9paShjLGQsYSxiLHhbaSsxNF0sMTUsLTE0MTYzNTQ5MDUpO2I9bWQ1X2lpKGIsYyxkLGEseFtpKzVdLDIxLC01NzQzNDA1NSk7YT1tZDVfaWkoYSxiLGMsZCx4W2krMTJdLDYsMTcwMDQ4NTU3MSk7ZD1tZDVfaWkoZCxhLGIsYyx4W2krM10sMTAsLTE4OTQ5ODY2MDYpO2M9bWQ1X2lpKGMsZCxhLGIseFtpKzEwXSwxNSwtMTA1MTUyMyk7Yj1tZDVfaWkoYixjLGQsYSx4W2krMV0sMjEsLTIwNTQ5MjI3OTkpO2E9bWQ1X2lpKGEsYixjLGQseFtpKzhdLDYsMTg3MzMxMzM1OSk7ZD1tZDVfaWkoZCxhLGIsYyx4W2krMTVdLDEwLC0zMDYxMTc0NCk7Yz1tZDVfaWkoYyxkLGEsYix4W2krNl0sMTUsLTE1NjAxOTgzODApO2I9bWQ1X2lpKGIsYyxkLGEseFtpKzEzXSwyMSwxMzA5MTUxNjQ5KTthPW1kNV9paShhLGIsYyxkLHhbaSs0XSw2LC0xNDU1MjMwNzApO2Q9bWQ1X2lpKGQsYSxiLGMseFtpKzExXSwxMCwtMTEyMDIxMDM3OSk7Yz1tZDVfaWkoYyxkLGEsYix4W2krMl0sMTUsNzE4Nzg3MjU5KTtiPW1kNV9paShiLGMsZCxhLHhbaSs5XSwyMSwtMzQzNDg1NTUxKTthPXNhZmVfYWRkKGEsb2xkYSk7Yj1zYWZlX2FkZChiLG9sZGIpO2M9c2FmZV9hZGQoYyxvbGRjKTtkPXNhZmVfYWRkKGQsb2xkZCl9cmV0dXJuIEFycmF5KGEsYixjLGQpfWZ1bmN0aW9uIG1kNV9jbW4ocSxhLGIseCxzLHQpe3JldHVybiBzYWZlX2FkZChiaXRfcm9sKHNhZmVfYWRkKHNhZmVfYWRkKGEscSksc2FmZV9hZGQoeCx0KSkscyksYil9ZnVuY3Rpb24gbWQ1X2ZmKGEsYixjLGQseCxzLHQpe3JldHVybiBtZDVfY21uKGImY3x+YiZkLGEsYix4LHMsdCl9ZnVuY3Rpb24gbWQ1X2dnKGEsYixjLGQseCxzLHQpe3JldHVybiBtZDVfY21uKGImZHxjJn5kLGEsYix4LHMsdCl9ZnVuY3Rpb24gbWQ1X2hoKGEsYixjLGQseCxzLHQpe3JldHVybiBtZDVfY21uKGJeY15kLGEsYix4LHMsdCl9ZnVuY3Rpb24gbWQ1X2lpKGEsYixjLGQseCxzLHQpe3JldHVybiBtZDVfY21uKGNeKGJ8fmQpLGEsYix4LHMsdCl9ZnVuY3Rpb24gc2FmZV9hZGQoeCx5KXt2YXIgbHN3PSh4JjY1NTM1KSsoeSY2NTUzNSk7dmFyIG1zdz0oeD4+MTYpKyh5Pj4xNikrKGxzdz4+MTYpO3JldHVybiBtc3c8PDE2fGxzdyY2NTUzNX1mdW5jdGlvbiBiaXRfcm9sKG51bSxjbnQpe3JldHVybiBudW08PGNudHxudW0+Pj4zMi1jbnR9bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24gbWQ1KGJ1Zil7cmV0dXJuIGhlbHBlcnMuaGFzaChidWYsY29yZV9tZDUsMTYpfX0se1wiLi9oZWxwZXJzXCI6OH1dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oKXt2YXIgX2dsb2JhbD10aGlzO3ZhciBtYXRoUk5HLHdoYXR3Z1JORzttYXRoUk5HPWZ1bmN0aW9uKHNpemUpe3ZhciBieXRlcz1uZXcgQXJyYXkoc2l6ZSk7dmFyIHI7Zm9yKHZhciBpPTAscjtpPHNpemU7aSsrKXtpZigoaSYzKT09MClyPU1hdGgucmFuZG9tKCkqNDI5NDk2NzI5NjtieXRlc1tpXT1yPj4+KChpJjMpPDwzKSYyNTV9cmV0dXJuIGJ5dGVzfTtpZihfZ2xvYmFsLmNyeXB0byYmY3J5cHRvLmdldFJhbmRvbVZhbHVlcyl7d2hhdHdnUk5HPWZ1bmN0aW9uKHNpemUpe3ZhciBieXRlcz1uZXcgVWludDhBcnJheShzaXplKTtjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtyZXR1cm4gYnl0ZXN9fW1vZHVsZS5leHBvcnRzPXdoYXR3Z1JOR3x8bWF0aFJOR30pKCl9LHt9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIGhlbHBlcnM9X2RlcmVxXyhcIi4vaGVscGVyc1wiKTtmdW5jdGlvbiBjb3JlX3NoYTEoeCxsZW4pe3hbbGVuPj41XXw9MTI4PDwyNC1sZW4lMzI7eFsobGVuKzY0Pj45PDw0KSsxNV09bGVuO3ZhciB3PUFycmF5KDgwKTt2YXIgYT0xNzMyNTg0MTkzO3ZhciBiPS0yNzE3MzM4Nzk7dmFyIGM9LTE3MzI1ODQxOTQ7dmFyIGQ9MjcxNzMzODc4O3ZhciBlPS0xMDA5NTg5Nzc2O2Zvcih2YXIgaT0wO2k8eC5sZW5ndGg7aSs9MTYpe3ZhciBvbGRhPWE7dmFyIG9sZGI9Yjt2YXIgb2xkYz1jO3ZhciBvbGRkPWQ7dmFyIG9sZGU9ZTtmb3IodmFyIGo9MDtqPDgwO2orKyl7aWYoajwxNil3W2pdPXhbaStqXTtlbHNlIHdbal09cm9sKHdbai0zXV53W2otOF1ed1tqLTE0XV53W2otMTZdLDEpO3ZhciB0PXNhZmVfYWRkKHNhZmVfYWRkKHJvbChhLDUpLHNoYTFfZnQoaixiLGMsZCkpLHNhZmVfYWRkKHNhZmVfYWRkKGUsd1tqXSksc2hhMV9rdChqKSkpO2U9ZDtkPWM7Yz1yb2woYiwzMCk7Yj1hO2E9dH1hPXNhZmVfYWRkKGEsb2xkYSk7Yj1zYWZlX2FkZChiLG9sZGIpO2M9c2FmZV9hZGQoYyxvbGRjKTtkPXNhZmVfYWRkKGQsb2xkZCk7ZT1zYWZlX2FkZChlLG9sZGUpfXJldHVybiBBcnJheShhLGIsYyxkLGUpfWZ1bmN0aW9uIHNoYTFfZnQodCxiLGMsZCl7aWYodDwyMClyZXR1cm4gYiZjfH5iJmQ7aWYodDw0MClyZXR1cm4gYl5jXmQ7aWYodDw2MClyZXR1cm4gYiZjfGImZHxjJmQ7cmV0dXJuIGJeY15kfWZ1bmN0aW9uIHNoYTFfa3QodCl7cmV0dXJuIHQ8MjA/MTUxODUwMDI0OTp0PDQwPzE4NTk3NzUzOTM6dDw2MD8tMTg5NDAwNzU4ODotODk5NDk3NTE0fWZ1bmN0aW9uIHNhZmVfYWRkKHgseSl7dmFyIGxzdz0oeCY2NTUzNSkrKHkmNjU1MzUpO3ZhciBtc3c9KHg+PjE2KSsoeT4+MTYpKyhsc3c+PjE2KTtyZXR1cm4gbXN3PDwxNnxsc3cmNjU1MzV9ZnVuY3Rpb24gcm9sKG51bSxjbnQpe3JldHVybiBudW08PGNudHxudW0+Pj4zMi1jbnR9bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24gc2hhMShidWYpe3JldHVybiBoZWxwZXJzLmhhc2goYnVmLGNvcmVfc2hhMSwyMCx0cnVlKX19LHtcIi4vaGVscGVyc1wiOjh9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIGhlbHBlcnM9X2RlcmVxXyhcIi4vaGVscGVyc1wiKTt2YXIgc2FmZV9hZGQ9ZnVuY3Rpb24oeCx5KXt2YXIgbHN3PSh4JjY1NTM1KSsoeSY2NTUzNSk7dmFyIG1zdz0oeD4+MTYpKyh5Pj4xNikrKGxzdz4+MTYpO3JldHVybiBtc3c8PDE2fGxzdyY2NTUzNX07dmFyIFM9ZnVuY3Rpb24oWCxuKXtyZXR1cm4gWD4+Pm58WDw8MzItbn07dmFyIFI9ZnVuY3Rpb24oWCxuKXtyZXR1cm4gWD4+Pm59O3ZhciBDaD1mdW5jdGlvbih4LHkseil7cmV0dXJuIHgmeV5+eCZ6fTt2YXIgTWFqPWZ1bmN0aW9uKHgseSx6KXtyZXR1cm4geCZ5Xngmel55Jnp9O3ZhciBTaWdtYTAyNTY9ZnVuY3Rpb24oeCl7cmV0dXJuIFMoeCwyKV5TKHgsMTMpXlMoeCwyMil9O3ZhciBTaWdtYTEyNTY9ZnVuY3Rpb24oeCl7cmV0dXJuIFMoeCw2KV5TKHgsMTEpXlMoeCwyNSl9O3ZhciBHYW1tYTAyNTY9ZnVuY3Rpb24oeCl7cmV0dXJuIFMoeCw3KV5TKHgsMTgpXlIoeCwzKX07dmFyIEdhbW1hMTI1Nj1mdW5jdGlvbih4KXtyZXR1cm4gUyh4LDE3KV5TKHgsMTkpXlIoeCwxMCl9O3ZhciBjb3JlX3NoYTI1Nj1mdW5jdGlvbihtLGwpe3ZhciBLPW5ldyBBcnJheSgxMTE2MzUyNDA4LDE4OTk0NDc0NDEsMzA0OTMyMzQ3MSwzOTIxMDA5NTczLDk2MTk4NzE2MywxNTA4OTcwOTkzLDI0NTM2MzU3NDgsMjg3MDc2MzIyMSwzNjI0MzgxMDgwLDMxMDU5ODQwMSw2MDcyMjUyNzgsMTQyNjg4MTk4NywxOTI1MDc4Mzg4LDIxNjIwNzgyMDYsMjYxNDg4ODEwMywzMjQ4MjIyNTgwLDM4MzUzOTA0MDEsNDAyMjIyNDc3NCwyNjQzNDcwNzgsNjA0ODA3NjI4LDc3MDI1NTk4MywxMjQ5MTUwMTIyLDE1NTUwODE2OTIsMTk5NjA2NDk4NiwyNTU0MjIwODgyLDI4MjE4MzQzNDksMjk1Mjk5NjgwOCwzMjEwMzEzNjcxLDMzMzY1NzE4OTEsMzU4NDUyODcxMSwxMTM5MjY5OTMsMzM4MjQxODk1LDY2NjMwNzIwNSw3NzM1Mjk5MTIsMTI5NDc1NzM3MiwxMzk2MTgyMjkxLDE2OTUxODM3MDAsMTk4NjY2MTA1MSwyMTc3MDI2MzUwLDI0NTY5NTYwMzcsMjczMDQ4NTkyMSwyODIwMzAyNDExLDMyNTk3MzA4MDAsMzM0NTc2NDc3MSwzNTE2MDY1ODE3LDM2MDAzNTI4MDQsNDA5NDU3MTkwOSwyNzU0MjMzNDQsNDMwMjI3NzM0LDUwNjk0ODYxNiw2NTkwNjA1NTYsODgzOTk3ODc3LDk1ODEzOTU3MSwxMzIyODIyMjE4LDE1MzcwMDIwNjMsMTc0Nzg3Mzc3OSwxOTU1NTYyMjIyLDIwMjQxMDQ4MTUsMjIyNzczMDQ1MiwyMzYxODUyNDI0LDI0Mjg0MzY0NzQsMjc1NjczNDE4NywzMjA0MDMxNDc5LDMzMjkzMjUyOTgpO3ZhciBIQVNIPW5ldyBBcnJheSgxNzc5MDMzNzAzLDMxNDQxMzQyNzcsMTAxMzkwNDI0MiwyNzczNDgwNzYyLDEzNTk4OTMxMTksMjYwMDgyMjkyNCw1Mjg3MzQ2MzUsMTU0MTQ1OTIyNSk7dmFyIFc9bmV3IEFycmF5KDY0KTt2YXIgYSxiLGMsZCxlLGYsZyxoLGksajt2YXIgVDEsVDI7bVtsPj41XXw9MTI4PDwyNC1sJTMyO21bKGwrNjQ+Pjk8PDQpKzE1XT1sO2Zvcih2YXIgaT0wO2k8bS5sZW5ndGg7aSs9MTYpe2E9SEFTSFswXTtiPUhBU0hbMV07Yz1IQVNIWzJdO2Q9SEFTSFszXTtlPUhBU0hbNF07Zj1IQVNIWzVdO2c9SEFTSFs2XTtoPUhBU0hbN107Zm9yKHZhciBqPTA7ajw2NDtqKyspe2lmKGo8MTYpe1dbal09bVtqK2ldfWVsc2V7V1tqXT1zYWZlX2FkZChzYWZlX2FkZChzYWZlX2FkZChHYW1tYTEyNTYoV1tqLTJdKSxXW2otN10pLEdhbW1hMDI1NihXW2otMTVdKSksV1tqLTE2XSl9VDE9c2FmZV9hZGQoc2FmZV9hZGQoc2FmZV9hZGQoc2FmZV9hZGQoaCxTaWdtYTEyNTYoZSkpLENoKGUsZixnKSksS1tqXSksV1tqXSk7VDI9c2FmZV9hZGQoU2lnbWEwMjU2KGEpLE1haihhLGIsYykpO2g9ZztnPWY7Zj1lO2U9c2FmZV9hZGQoZCxUMSk7ZD1jO2M9YjtiPWE7YT1zYWZlX2FkZChUMSxUMil9SEFTSFswXT1zYWZlX2FkZChhLEhBU0hbMF0pO0hBU0hbMV09c2FmZV9hZGQoYixIQVNIWzFdKTtIQVNIWzJdPXNhZmVfYWRkKGMsSEFTSFsyXSk7SEFTSFszXT1zYWZlX2FkZChkLEhBU0hbM10pO0hBU0hbNF09c2FmZV9hZGQoZSxIQVNIWzRdKTtIQVNIWzVdPXNhZmVfYWRkKGYsSEFTSFs1XSk7SEFTSFs2XT1zYWZlX2FkZChnLEhBU0hbNl0pO0hBU0hbN109c2FmZV9hZGQoaCxIQVNIWzddKX1yZXR1cm4gSEFTSH07bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24gc2hhMjU2KGJ1Zil7cmV0dXJuIGhlbHBlcnMuaGFzaChidWYsY29yZV9zaGEyNTYsMzIsdHJ1ZSl9fSx7XCIuL2hlbHBlcnNcIjo4fV0sMTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe2lmKHR5cGVvZiBPYmplY3QuY3JlYXRlPT09XCJmdW5jdGlvblwiKXttb2R1bGUuZXhwb3J0cz1mdW5jdGlvbiBpbmhlcml0cyhjdG9yLHN1cGVyQ3Rvcil7Y3Rvci5zdXBlcl89c3VwZXJDdG9yO2N0b3IucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmN0b3IsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfX0pfX1lbHNle21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uIGluaGVyaXRzKGN0b3Isc3VwZXJDdG9yKXtjdG9yLnN1cGVyXz1zdXBlckN0b3I7dmFyIFRlbXBDdG9yPWZ1bmN0aW9uKCl7fTtUZW1wQ3Rvci5wcm90b3R5cGU9c3VwZXJDdG9yLnByb3RvdHlwZTtjdG9yLnByb3RvdHlwZT1uZXcgVGVtcEN0b3I7Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3I9Y3Rvcn19fSx7fV0sMTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBwcm9jZXNzPW1vZHVsZS5leHBvcnRzPXt9O3Byb2Nlc3MubmV4dFRpY2s9ZnVuY3Rpb24oKXt2YXIgY2FuU2V0SW1tZWRpYXRlPXR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiJiZ3aW5kb3cuc2V0SW1tZWRpYXRlO3ZhciBjYW5Qb3N0PXR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiJiZ3aW5kb3cucG9zdE1lc3NhZ2UmJndpbmRvdy5hZGRFdmVudExpc3RlbmVyO2lmKGNhblNldEltbWVkaWF0ZSl7cmV0dXJuIGZ1bmN0aW9uKGYpe3JldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpfX1pZihjYW5Qb3N0KXt2YXIgcXVldWU9W107d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsZnVuY3Rpb24oZXYpe3ZhciBzb3VyY2U9ZXYuc291cmNlO2lmKChzb3VyY2U9PT13aW5kb3d8fHNvdXJjZT09PW51bGwpJiZldi5kYXRhPT09XCJwcm9jZXNzLXRpY2tcIil7ZXYuc3RvcFByb3BhZ2F0aW9uKCk7aWYocXVldWUubGVuZ3RoPjApe3ZhciBmbj1xdWV1ZS5zaGlmdCgpO2ZuKCl9fX0sdHJ1ZSk7cmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKXtxdWV1ZS5wdXNoKGZuKTt3aW5kb3cucG9zdE1lc3NhZ2UoXCJwcm9jZXNzLXRpY2tcIixcIipcIil9fXJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbil7c2V0VGltZW91dChmbiwwKX19KCk7cHJvY2Vzcy50aXRsZT1cImJyb3dzZXJcIjtwcm9jZXNzLmJyb3dzZXI9dHJ1ZTtwcm9jZXNzLmVudj17fTtwcm9jZXNzLmFyZ3Y9W107ZnVuY3Rpb24gbm9vcCgpe31wcm9jZXNzLm9uPW5vb3A7cHJvY2Vzcy5hZGRMaXN0ZW5lcj1ub29wO3Byb2Nlc3Mub25jZT1ub29wO3Byb2Nlc3Mub2ZmPW5vb3A7cHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcj1ub29wO3Byb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3A7cHJvY2Vzcy5lbWl0PW5vb3A7cHJvY2Vzcy5iaW5kaW5nPWZ1bmN0aW9uKG5hbWUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfTtwcm9jZXNzLmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifTtwcm9jZXNzLmNoZGlyPWZ1bmN0aW9uKGRpcil7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfX0se31dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1fZGVyZXFfKDIpfSx7fV0sMTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPV9kZXJlcV8oMyl9LHtcIi4vc3VwcG9ydC9pc0J1ZmZlclwiOjE2LEZXYUFTSDoxNSxpbmhlcml0czoxNH1dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL2VuYy1iYXNlNjRcIiksX2RlcmVxXyhcIi4vbWQ1XCIpLF9kZXJlcV8oXCIuL2V2cGtkZlwiKSxfZGVyZXFfKFwiLi9jaXBoZXItY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL2VuYy1iYXNlNjRcIixcIi4vbWQ1XCIsXCIuL2V2cGtkZlwiLFwiLi9jaXBoZXItY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBCbG9ja0NpcGhlcj1DX2xpYi5CbG9ja0NpcGhlcjt2YXIgQ19hbGdvPUMuYWxnbzt2YXIgU0JPWD1bXTt2YXIgSU5WX1NCT1g9W107dmFyIFNVQl9NSVhfMD1bXTt2YXIgU1VCX01JWF8xPVtdO3ZhciBTVUJfTUlYXzI9W107dmFyIFNVQl9NSVhfMz1bXTt2YXIgSU5WX1NVQl9NSVhfMD1bXTt2YXIgSU5WX1NVQl9NSVhfMT1bXTt2YXIgSU5WX1NVQl9NSVhfMj1bXTt2YXIgSU5WX1NVQl9NSVhfMz1bXTsoZnVuY3Rpb24oKXt2YXIgZD1bXTtmb3IodmFyIGk9MDtpPDI1NjtpKyspe2lmKGk8MTI4KXtkW2ldPWk8PDF9ZWxzZXtkW2ldPWk8PDFeMjgzfX12YXIgeD0wO3ZhciB4aT0wO2Zvcih2YXIgaT0wO2k8MjU2O2krKyl7dmFyIHN4PXhpXnhpPDwxXnhpPDwyXnhpPDwzXnhpPDw0O3N4PXN4Pj4+OF5zeCYyNTVeOTk7U0JPWFt4XT1zeDtJTlZfU0JPWFtzeF09eDt2YXIgeDI9ZFt4XTt2YXIgeDQ9ZFt4Ml07dmFyIHg4PWRbeDRdO3ZhciB0PWRbc3hdKjI1N15zeCoxNjg0MzAwODtTVUJfTUlYXzBbeF09dDw8MjR8dD4+Pjg7U1VCX01JWF8xW3hdPXQ8PDE2fHQ+Pj4xNjtTVUJfTUlYXzJbeF09dDw8OHx0Pj4+MjQ7U1VCX01JWF8zW3hdPXQ7dmFyIHQ9eDgqMTY4NDMwMDleeDQqNjU1MzdeeDIqMjU3XngqMTY4NDMwMDg7SU5WX1NVQl9NSVhfMFtzeF09dDw8MjR8dD4+Pjg7SU5WX1NVQl9NSVhfMVtzeF09dDw8MTZ8dD4+PjE2O0lOVl9TVUJfTUlYXzJbc3hdPXQ8PDh8dD4+PjI0O0lOVl9TVUJfTUlYXzNbc3hdPXQ7aWYoIXgpe3g9eGk9MX1lbHNle3g9eDJeZFtkW2RbeDheeDJdXV07eGlePWRbZFt4aV1dfX19KSgpO3ZhciBSQ09OPVswLDEsMiw0LDgsMTYsMzIsNjQsMTI4LDI3LDU0XTt2YXIgQUVTPUNfYWxnby5BRVM9QmxvY2tDaXBoZXIuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3ZhciBrZXk9dGhpcy5fa2V5O3ZhciBrZXlXb3Jkcz1rZXkud29yZHM7dmFyIGtleVNpemU9a2V5LnNpZ0J5dGVzLzQ7dmFyIG5Sb3VuZHM9dGhpcy5fblJvdW5kcz1rZXlTaXplKzY7dmFyIGtzUm93cz0oblJvdW5kcysxKSo0O3ZhciBrZXlTY2hlZHVsZT10aGlzLl9rZXlTY2hlZHVsZT1bXTtmb3IodmFyIGtzUm93PTA7a3NSb3c8a3NSb3dzO2tzUm93Kyspe2lmKGtzUm93PGtleVNpemUpe2tleVNjaGVkdWxlW2tzUm93XT1rZXlXb3Jkc1trc1Jvd119ZWxzZXt2YXIgdD1rZXlTY2hlZHVsZVtrc1Jvdy0xXTtpZighKGtzUm93JWtleVNpemUpKXt0PXQ8PDh8dD4+PjI0O3Q9U0JPWFt0Pj4+MjRdPDwyNHxTQk9YW3Q+Pj4xNiYyNTVdPDwxNnxTQk9YW3Q+Pj44JjI1NV08PDh8U0JPWFt0JjI1NV07dF49UkNPTltrc1Jvdy9rZXlTaXplfDBdPDwyNH1lbHNlIGlmKGtleVNpemU+NiYma3NSb3cla2V5U2l6ZT09NCl7dD1TQk9YW3Q+Pj4yNF08PDI0fFNCT1hbdD4+PjE2JjI1NV08PDE2fFNCT1hbdD4+PjgmMjU1XTw8OHxTQk9YW3QmMjU1XX1rZXlTY2hlZHVsZVtrc1Jvd109a2V5U2NoZWR1bGVba3NSb3cta2V5U2l6ZV1edH19dmFyIGludktleVNjaGVkdWxlPXRoaXMuX2ludktleVNjaGVkdWxlPVtdO2Zvcih2YXIgaW52S3NSb3c9MDtpbnZLc1Jvdzxrc1Jvd3M7aW52S3NSb3crKyl7dmFyIGtzUm93PWtzUm93cy1pbnZLc1JvdztpZihpbnZLc1JvdyU0KXt2YXIgdD1rZXlTY2hlZHVsZVtrc1Jvd119ZWxzZXt2YXIgdD1rZXlTY2hlZHVsZVtrc1Jvdy00XX1pZihpbnZLc1Jvdzw0fHxrc1Jvdzw9NCl7aW52S2V5U2NoZWR1bGVbaW52S3NSb3ddPXR9ZWxzZXtpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd109SU5WX1NVQl9NSVhfMFtTQk9YW3Q+Pj4yNF1dXklOVl9TVUJfTUlYXzFbU0JPWFt0Pj4+MTYmMjU1XV1eSU5WX1NVQl9NSVhfMltTQk9YW3Q+Pj44JjI1NV1dXklOVl9TVUJfTUlYXzNbU0JPWFt0JjI1NV1dfX19LGVuY3J5cHRCbG9jazpmdW5jdGlvbihNLG9mZnNldCl7dGhpcy5fZG9DcnlwdEJsb2NrKE0sb2Zmc2V0LHRoaXMuX2tleVNjaGVkdWxlLFNVQl9NSVhfMCxTVUJfTUlYXzEsU1VCX01JWF8yLFNVQl9NSVhfMyxTQk9YKX0sZGVjcnlwdEJsb2NrOmZ1bmN0aW9uKE0sb2Zmc2V0KXt2YXIgdD1NW29mZnNldCsxXTtNW29mZnNldCsxXT1NW29mZnNldCszXTtNW29mZnNldCszXT10O3RoaXMuX2RvQ3J5cHRCbG9jayhNLG9mZnNldCx0aGlzLl9pbnZLZXlTY2hlZHVsZSxJTlZfU1VCX01JWF8wLElOVl9TVUJfTUlYXzEsSU5WX1NVQl9NSVhfMixJTlZfU1VCX01JWF8zLElOVl9TQk9YKTt2YXIgdD1NW29mZnNldCsxXTtNW29mZnNldCsxXT1NW29mZnNldCszXTtNW29mZnNldCszXT10fSxfZG9DcnlwdEJsb2NrOmZ1bmN0aW9uKE0sb2Zmc2V0LGtleVNjaGVkdWxlLFNVQl9NSVhfMCxTVUJfTUlYXzEsU1VCX01JWF8yLFNVQl9NSVhfMyxTQk9YKXt2YXIgblJvdW5kcz10aGlzLl9uUm91bmRzO3ZhciBzMD1NW29mZnNldF1ea2V5U2NoZWR1bGVbMF07dmFyIHMxPU1bb2Zmc2V0KzFdXmtleVNjaGVkdWxlWzFdO3ZhciBzMj1NW29mZnNldCsyXV5rZXlTY2hlZHVsZVsyXTt2YXIgczM9TVtvZmZzZXQrM11ea2V5U2NoZWR1bGVbM107dmFyIGtzUm93PTQ7Zm9yKHZhciByb3VuZD0xO3JvdW5kPG5Sb3VuZHM7cm91bmQrKyl7dmFyIHQwPVNVQl9NSVhfMFtzMD4+PjI0XV5TVUJfTUlYXzFbczE+Pj4xNiYyNTVdXlNVQl9NSVhfMltzMj4+PjgmMjU1XV5TVUJfTUlYXzNbczMmMjU1XV5rZXlTY2hlZHVsZVtrc1JvdysrXTt2YXIgdDE9U1VCX01JWF8wW3MxPj4+MjRdXlNVQl9NSVhfMVtzMj4+PjE2JjI1NV1eU1VCX01JWF8yW3MzPj4+OCYyNTVdXlNVQl9NSVhfM1tzMCYyNTVdXmtleVNjaGVkdWxlW2tzUm93KytdO3ZhciB0Mj1TVUJfTUlYXzBbczI+Pj4yNF1eU1VCX01JWF8xW3MzPj4+MTYmMjU1XV5TVUJfTUlYXzJbczA+Pj44JjI1NV1eU1VCX01JWF8zW3MxJjI1NV1ea2V5U2NoZWR1bGVba3NSb3crK107dmFyIHQzPVNVQl9NSVhfMFtzMz4+PjI0XV5TVUJfTUlYXzFbczA+Pj4xNiYyNTVdXlNVQl9NSVhfMltzMT4+PjgmMjU1XV5TVUJfTUlYXzNbczImMjU1XV5rZXlTY2hlZHVsZVtrc1JvdysrXTtzMD10MDtzMT10MTtzMj10MjtzMz10M312YXIgdDA9KFNCT1hbczA+Pj4yNF08PDI0fFNCT1hbczE+Pj4xNiYyNTVdPDwxNnxTQk9YW3MyPj4+OCYyNTVdPDw4fFNCT1hbczMmMjU1XSlea2V5U2NoZWR1bGVba3NSb3crK107dmFyIHQxPShTQk9YW3MxPj4+MjRdPDwyNHxTQk9YW3MyPj4+MTYmMjU1XTw8MTZ8U0JPWFtzMz4+PjgmMjU1XTw8OHxTQk9YW3MwJjI1NV0pXmtleVNjaGVkdWxlW2tzUm93KytdO3ZhciB0Mj0oU0JPWFtzMj4+PjI0XTw8MjR8U0JPWFtzMz4+PjE2JjI1NV08PDE2fFNCT1hbczA+Pj44JjI1NV08PDh8U0JPWFtzMSYyNTVdKV5rZXlTY2hlZHVsZVtrc1JvdysrXTt2YXIgdDM9KFNCT1hbczM+Pj4yNF08PDI0fFNCT1hbczA+Pj4xNiYyNTVdPDwxNnxTQk9YW3MxPj4+OCYyNTVdPDw4fFNCT1hbczImMjU1XSlea2V5U2NoZWR1bGVba3NSb3crK107TVtvZmZzZXRdPXQwO01bb2Zmc2V0KzFdPXQxO01bb2Zmc2V0KzJdPXQyO01bb2Zmc2V0KzNdPXQzfSxrZXlTaXplOjI1Ni8zMn0pO0MuQUVTPUJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQUVTKX0pKCk7cmV0dXJuIENyeXB0b0pTLkFFU30pfSx7XCIuL2NpcGhlci1jb3JlXCI6MTksXCIuL2NvcmVcIjoyMCxcIi4vZW5jLWJhc2U2NFwiOjIxLFwiLi9ldnBrZGZcIjoyMyxcIi4vbWQ1XCI6Mjl9XSwxOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSl7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXtDcnlwdG9KUy5saWIuQ2lwaGVyfHxmdW5jdGlvbih1bmRlZmluZWQpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgQmFzZT1DX2xpYi5CYXNlO3ZhciBXb3JkQXJyYXk9Q19saWIuV29yZEFycmF5O3ZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtPUNfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG07dmFyIENfZW5jPUMuZW5jO3ZhciBVdGY4PUNfZW5jLlV0Zjg7dmFyIEJhc2U2ND1DX2VuYy5CYXNlNjQ7dmFyIENfYWxnbz1DLmFsZ287dmFyIEV2cEtERj1DX2FsZ28uRXZwS0RGO3ZhciBDaXBoZXI9Q19saWIuQ2lwaGVyPUJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtjZmc6QmFzZS5leHRlbmQoKSxjcmVhdGVFbmNyeXB0b3I6ZnVuY3Rpb24oa2V5LGNmZyl7cmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0VOQ19YRk9STV9NT0RFLGtleSxjZmcpfSxjcmVhdGVEZWNyeXB0b3I6ZnVuY3Rpb24oa2V5LGNmZyl7cmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLGtleSxjZmcpfSxpbml0OmZ1bmN0aW9uKHhmb3JtTW9kZSxrZXksY2ZnKXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQoY2ZnKTt0aGlzLl94Zm9ybU1vZGU9eGZvcm1Nb2RlO3RoaXMuX2tleT1rZXk7dGhpcy5yZXNldCgpfSxyZXNldDpmdW5jdGlvbigpe0J1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTt0aGlzLl9kb1Jlc2V0KCl9LHByb2Nlc3M6ZnVuY3Rpb24oZGF0YVVwZGF0ZSl7dGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO3JldHVybiB0aGlzLl9wcm9jZXNzKCl9LGZpbmFsaXplOmZ1bmN0aW9uKGRhdGFVcGRhdGUpe2lmKGRhdGFVcGRhdGUpe3RoaXMuX2FwcGVuZChkYXRhVXBkYXRlKX12YXIgZmluYWxQcm9jZXNzZWREYXRhPXRoaXMuX2RvRmluYWxpemUoKTtyZXR1cm4gZmluYWxQcm9jZXNzZWREYXRhfSxrZXlTaXplOjEyOC8zMixpdlNpemU6MTI4LzMyLF9FTkNfWEZPUk1fTU9ERToxLF9ERUNfWEZPUk1fTU9ERToyLF9jcmVhdGVIZWxwZXI6ZnVuY3Rpb24oKXtmdW5jdGlvbiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpe2lmKHR5cGVvZiBrZXk9PVwic3RyaW5nXCIpe3JldHVybiBQYXNzd29yZEJhc2VkQ2lwaGVyfWVsc2V7cmV0dXJuIFNlcmlhbGl6YWJsZUNpcGhlcn19cmV0dXJuIGZ1bmN0aW9uKGNpcGhlcil7cmV0dXJue2VuY3J5cHQ6ZnVuY3Rpb24obWVzc2FnZSxrZXksY2ZnKXtyZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5lbmNyeXB0KGNpcGhlcixtZXNzYWdlLGtleSxjZmcpfSxkZWNyeXB0OmZ1bmN0aW9uKGNpcGhlcnRleHQsa2V5LGNmZyl7cmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZGVjcnlwdChjaXBoZXIsY2lwaGVydGV4dCxrZXksY2ZnKX19fX0oKX0pO3ZhciBTdHJlYW1DaXBoZXI9Q19saWIuU3RyZWFtQ2lwaGVyPUNpcGhlci5leHRlbmQoe19kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzPXRoaXMuX3Byb2Nlc3MoISFcImZsdXNoXCIpO3JldHVybiBmaW5hbFByb2Nlc3NlZEJsb2Nrc30sYmxvY2tTaXplOjF9KTt2YXIgQ19tb2RlPUMubW9kZT17fTt2YXIgQmxvY2tDaXBoZXJNb2RlPUNfbGliLkJsb2NrQ2lwaGVyTW9kZT1CYXNlLmV4dGVuZCh7Y3JlYXRlRW5jcnlwdG9yOmZ1bmN0aW9uKGNpcGhlcixpdil7cmV0dXJuIHRoaXMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsaXYpfSxjcmVhdGVEZWNyeXB0b3I6ZnVuY3Rpb24oY2lwaGVyLGl2KXtyZXR1cm4gdGhpcy5EZWNyeXB0b3IuY3JlYXRlKGNpcGhlcixpdil9LGluaXQ6ZnVuY3Rpb24oY2lwaGVyLGl2KXt0aGlzLl9jaXBoZXI9Y2lwaGVyO3RoaXMuX2l2PWl2fX0pO3ZhciBDQkM9Q19tb2RlLkNCQz1mdW5jdGlvbigpe3ZhciBDQkM9QmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO0NCQy5FbmNyeXB0b3I9Q0JDLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHdvcmRzLG9mZnNldCl7dmFyIGNpcGhlcj10aGlzLl9jaXBoZXI7dmFyIGJsb2NrU2l6ZT1jaXBoZXIuYmxvY2tTaXplO3hvckJsb2NrLmNhbGwodGhpcyx3b3JkcyxvZmZzZXQsYmxvY2tTaXplKTtjaXBoZXIuZW5jcnlwdEJsb2NrKHdvcmRzLG9mZnNldCk7dGhpcy5fcHJldkJsb2NrPXdvcmRzLnNsaWNlKG9mZnNldCxvZmZzZXQrYmxvY2tTaXplKX19KTtDQkMuRGVjcnlwdG9yPUNCQy5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih3b3JkcyxvZmZzZXQpe3ZhciBjaXBoZXI9dGhpcy5fY2lwaGVyO3ZhciBibG9ja1NpemU9Y2lwaGVyLmJsb2NrU2l6ZTt2YXIgdGhpc0Jsb2NrPXdvcmRzLnNsaWNlKG9mZnNldCxvZmZzZXQrYmxvY2tTaXplKTtjaXBoZXIuZGVjcnlwdEJsb2NrKHdvcmRzLG9mZnNldCk7eG9yQmxvY2suY2FsbCh0aGlzLHdvcmRzLG9mZnNldCxibG9ja1NpemUpO3RoaXMuX3ByZXZCbG9jaz10aGlzQmxvY2t9fSk7ZnVuY3Rpb24geG9yQmxvY2sod29yZHMsb2Zmc2V0LGJsb2NrU2l6ZSl7dmFyIGl2PXRoaXMuX2l2O2lmKGl2KXt2YXIgYmxvY2s9aXY7dGhpcy5faXY9dW5kZWZpbmVkfWVsc2V7dmFyIGJsb2NrPXRoaXMuX3ByZXZCbG9ja31mb3IodmFyIGk9MDtpPGJsb2NrU2l6ZTtpKyspe3dvcmRzW29mZnNldCtpXV49YmxvY2tbaV19fXJldHVybiBDQkN9KCk7dmFyIENfcGFkPUMucGFkPXt9O3ZhciBQa2NzNz1DX3BhZC5Qa2NzNz17cGFkOmZ1bmN0aW9uKGRhdGEsYmxvY2tTaXplKXt2YXIgYmxvY2tTaXplQnl0ZXM9YmxvY2tTaXplKjQ7dmFyIG5QYWRkaW5nQnl0ZXM9YmxvY2tTaXplQnl0ZXMtZGF0YS5zaWdCeXRlcyVibG9ja1NpemVCeXRlczt2YXIgcGFkZGluZ1dvcmQ9blBhZGRpbmdCeXRlczw8MjR8blBhZGRpbmdCeXRlczw8MTZ8blBhZGRpbmdCeXRlczw8OHxuUGFkZGluZ0J5dGVzO3ZhciBwYWRkaW5nV29yZHM9W107Zm9yKHZhciBpPTA7aTxuUGFkZGluZ0J5dGVzO2krPTQpe3BhZGRpbmdXb3Jkcy5wdXNoKHBhZGRpbmdXb3JkKX12YXIgcGFkZGluZz1Xb3JkQXJyYXkuY3JlYXRlKHBhZGRpbmdXb3JkcyxuUGFkZGluZ0J5dGVzKTtkYXRhLmNvbmNhdChwYWRkaW5nKX0sdW5wYWQ6ZnVuY3Rpb24oZGF0YSl7dmFyIG5QYWRkaW5nQnl0ZXM9ZGF0YS53b3Jkc1tkYXRhLnNpZ0J5dGVzLTE+Pj4yXSYyNTU7ZGF0YS5zaWdCeXRlcy09blBhZGRpbmdCeXRlc319O3ZhciBCbG9ja0NpcGhlcj1DX2xpYi5CbG9ja0NpcGhlcj1DaXBoZXIuZXh0ZW5kKHtjZmc6Q2lwaGVyLmNmZy5leHRlbmQoe21vZGU6Q0JDLHBhZGRpbmc6UGtjczd9KSxyZXNldDpmdW5jdGlvbigpe0NpcGhlci5yZXNldC5jYWxsKHRoaXMpO3ZhciBjZmc9dGhpcy5jZmc7dmFyIGl2PWNmZy5pdjt2YXIgbW9kZT1jZmcubW9kZTtpZih0aGlzLl94Zm9ybU1vZGU9PXRoaXMuX0VOQ19YRk9STV9NT0RFKXt2YXIgbW9kZUNyZWF0b3I9bW9kZS5jcmVhdGVFbmNyeXB0b3J9ZWxzZXt2YXIgbW9kZUNyZWF0b3I9bW9kZS5jcmVhdGVEZWNyeXB0b3I7dGhpcy5fbWluQnVmZmVyU2l6ZT0xfXRoaXMuX21vZGU9bW9kZUNyZWF0b3IuY2FsbChtb2RlLHRoaXMsaXYmJml2LndvcmRzKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHdvcmRzLG9mZnNldCl7dGhpcy5fbW9kZS5wcm9jZXNzQmxvY2sod29yZHMsb2Zmc2V0KX0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgcGFkZGluZz10aGlzLmNmZy5wYWRkaW5nO2lmKHRoaXMuX3hmb3JtTW9kZT09dGhpcy5fRU5DX1hGT1JNX01PREUpe3BhZGRpbmcucGFkKHRoaXMuX2RhdGEsdGhpcy5ibG9ja1NpemUpO3ZhciBmaW5hbFByb2Nlc3NlZEJsb2Nrcz10aGlzLl9wcm9jZXNzKCEhXCJmbHVzaFwiKX1lbHNle3ZhciBmaW5hbFByb2Nlc3NlZEJsb2Nrcz10aGlzLl9wcm9jZXNzKCEhXCJmbHVzaFwiKTtwYWRkaW5nLnVucGFkKGZpbmFsUHJvY2Vzc2VkQmxvY2tzKX1yZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3N9LGJsb2NrU2l6ZToxMjgvMzJ9KTt2YXIgQ2lwaGVyUGFyYW1zPUNfbGliLkNpcGhlclBhcmFtcz1CYXNlLmV4dGVuZCh7aW5pdDpmdW5jdGlvbihjaXBoZXJQYXJhbXMpe3RoaXMubWl4SW4oY2lwaGVyUGFyYW1zKX0sdG9TdHJpbmc6ZnVuY3Rpb24oZm9ybWF0dGVyKXtyZXR1cm4oZm9ybWF0dGVyfHx0aGlzLmZvcm1hdHRlcikuc3RyaW5naWZ5KHRoaXMpfX0pO3ZhciBDX2Zvcm1hdD1DLmZvcm1hdD17fTt2YXIgT3BlblNTTEZvcm1hdHRlcj1DX2Zvcm1hdC5PcGVuU1NMPXtzdHJpbmdpZnk6ZnVuY3Rpb24oY2lwaGVyUGFyYW1zKXt2YXIgY2lwaGVydGV4dD1jaXBoZXJQYXJhbXMuY2lwaGVydGV4dDt2YXIgc2FsdD1jaXBoZXJQYXJhbXMuc2FsdDtpZihzYWx0KXt2YXIgd29yZEFycmF5PVdvcmRBcnJheS5jcmVhdGUoWzEzOTg4OTM2ODQsMTcwMTA3NjgzMV0pLmNvbmNhdChzYWx0KS5jb25jYXQoY2lwaGVydGV4dCl9ZWxzZXt2YXIgd29yZEFycmF5PWNpcGhlcnRleHR9cmV0dXJuIHdvcmRBcnJheS50b1N0cmluZyhCYXNlNjQpfSxwYXJzZTpmdW5jdGlvbihvcGVuU1NMU3RyKXt2YXIgY2lwaGVydGV4dD1CYXNlNjQucGFyc2Uob3BlblNTTFN0cik7dmFyIGNpcGhlcnRleHRXb3Jkcz1jaXBoZXJ0ZXh0LndvcmRzO2lmKGNpcGhlcnRleHRXb3Jkc1swXT09MTM5ODg5MzY4NCYmY2lwaGVydGV4dFdvcmRzWzFdPT0xNzAxMDc2ODMxKXt2YXIgc2FsdD1Xb3JkQXJyYXkuY3JlYXRlKGNpcGhlcnRleHRXb3Jkcy5zbGljZSgyLDQpKTtjaXBoZXJ0ZXh0V29yZHMuc3BsaWNlKDAsNCk7Y2lwaGVydGV4dC5zaWdCeXRlcy09MTZ9cmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoe2NpcGhlcnRleHQ6Y2lwaGVydGV4dCxzYWx0OnNhbHR9KX19O3ZhciBTZXJpYWxpemFibGVDaXBoZXI9Q19saWIuU2VyaWFsaXphYmxlQ2lwaGVyPUJhc2UuZXh0ZW5kKHtjZmc6QmFzZS5leHRlbmQoe2Zvcm1hdDpPcGVuU1NMRm9ybWF0dGVyfSksZW5jcnlwdDpmdW5jdGlvbihjaXBoZXIsbWVzc2FnZSxrZXksY2ZnKXtjZmc9dGhpcy5jZmcuZXh0ZW5kKGNmZyk7dmFyIGVuY3J5cHRvcj1jaXBoZXIuY3JlYXRlRW5jcnlwdG9yKGtleSxjZmcpO3ZhciBjaXBoZXJ0ZXh0PWVuY3J5cHRvci5maW5hbGl6ZShtZXNzYWdlKTt2YXIgY2lwaGVyQ2ZnPWVuY3J5cHRvci5jZmc7cmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoe2NpcGhlcnRleHQ6Y2lwaGVydGV4dCxrZXk6a2V5LGl2OmNpcGhlckNmZy5pdixhbGdvcml0aG06Y2lwaGVyLG1vZGU6Y2lwaGVyQ2ZnLm1vZGUscGFkZGluZzpjaXBoZXJDZmcucGFkZGluZyxibG9ja1NpemU6Y2lwaGVyLmJsb2NrU2l6ZSxmb3JtYXR0ZXI6Y2ZnLmZvcm1hdH0pfSxkZWNyeXB0OmZ1bmN0aW9uKGNpcGhlcixjaXBoZXJ0ZXh0LGtleSxjZmcpe2NmZz10aGlzLmNmZy5leHRlbmQoY2ZnKTtjaXBoZXJ0ZXh0PXRoaXMuX3BhcnNlKGNpcGhlcnRleHQsY2ZnLmZvcm1hdCk7dmFyIHBsYWludGV4dD1jaXBoZXIuY3JlYXRlRGVjcnlwdG9yKGtleSxjZmcpLmZpbmFsaXplKGNpcGhlcnRleHQuY2lwaGVydGV4dCk7cmV0dXJuIHBsYWludGV4dH0sX3BhcnNlOmZ1bmN0aW9uKGNpcGhlcnRleHQsZm9ybWF0KXtpZih0eXBlb2YgY2lwaGVydGV4dD09XCJzdHJpbmdcIil7cmV0dXJuIGZvcm1hdC5wYXJzZShjaXBoZXJ0ZXh0LHRoaXMpfWVsc2V7cmV0dXJuIGNpcGhlcnRleHR9fX0pO3ZhciBDX2tkZj1DLmtkZj17fTt2YXIgT3BlblNTTEtkZj1DX2tkZi5PcGVuU1NMPXtleGVjdXRlOmZ1bmN0aW9uKHBhc3N3b3JkLGtleVNpemUsaXZTaXplLHNhbHQpe2lmKCFzYWx0KXtzYWx0PVdvcmRBcnJheS5yYW5kb20oNjQvOCl9dmFyIGtleT1FdnBLREYuY3JlYXRlKHtrZXlTaXplOmtleVNpemUraXZTaXplfSkuY29tcHV0ZShwYXNzd29yZCxzYWx0KTt2YXIgaXY9V29yZEFycmF5LmNyZWF0ZShrZXkud29yZHMuc2xpY2Uoa2V5U2l6ZSksaXZTaXplKjQpO2tleS5zaWdCeXRlcz1rZXlTaXplKjQ7cmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoe2tleTprZXksaXY6aXYsc2FsdDpzYWx0fSl9fTt2YXIgUGFzc3dvcmRCYXNlZENpcGhlcj1DX2xpYi5QYXNzd29yZEJhc2VkQ2lwaGVyPVNlcmlhbGl6YWJsZUNpcGhlci5leHRlbmQoe2NmZzpTZXJpYWxpemFibGVDaXBoZXIuY2ZnLmV4dGVuZCh7a2RmOk9wZW5TU0xLZGZ9KSxlbmNyeXB0OmZ1bmN0aW9uKGNpcGhlcixtZXNzYWdlLHBhc3N3b3JkLGNmZyl7Y2ZnPXRoaXMuY2ZnLmV4dGVuZChjZmcpO3ZhciBkZXJpdmVkUGFyYW1zPWNmZy5rZGYuZXhlY3V0ZShwYXNzd29yZCxjaXBoZXIua2V5U2l6ZSxjaXBoZXIuaXZTaXplKTtjZmcuaXY9ZGVyaXZlZFBhcmFtcy5pdjt2YXIgY2lwaGVydGV4dD1TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdC5jYWxsKHRoaXMsY2lwaGVyLG1lc3NhZ2UsZGVyaXZlZFBhcmFtcy5rZXksY2ZnKTtcbmNpcGhlcnRleHQubWl4SW4oZGVyaXZlZFBhcmFtcyk7cmV0dXJuIGNpcGhlcnRleHR9LGRlY3J5cHQ6ZnVuY3Rpb24oY2lwaGVyLGNpcGhlcnRleHQscGFzc3dvcmQsY2ZnKXtjZmc9dGhpcy5jZmcuZXh0ZW5kKGNmZyk7Y2lwaGVydGV4dD10aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LGNmZy5mb3JtYXQpO3ZhciBkZXJpdmVkUGFyYW1zPWNmZy5rZGYuZXhlY3V0ZShwYXNzd29yZCxjaXBoZXIua2V5U2l6ZSxjaXBoZXIuaXZTaXplLGNpcGhlcnRleHQuc2FsdCk7Y2ZnLml2PWRlcml2ZWRQYXJhbXMuaXY7dmFyIHBsYWludGV4dD1TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdC5jYWxsKHRoaXMsY2lwaGVyLGNpcGhlcnRleHQsZGVyaXZlZFBhcmFtcy5rZXksY2ZnKTtyZXR1cm4gcGxhaW50ZXh0fX0pfSgpfSl9LHtcIi4vY29yZVwiOjIwfV0sMjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3Rvcnkpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZmFjdG9yeSl9ZWxzZXtyb290LkNyeXB0b0pTPWZhY3RvcnkoKX19KSh0aGlzLGZ1bmN0aW9uKCl7dmFyIENyeXB0b0pTPUNyeXB0b0pTfHxmdW5jdGlvbihNYXRoLHVuZGVmaW5lZCl7dmFyIEM9e307dmFyIENfbGliPUMubGliPXt9O3ZhciBCYXNlPUNfbGliLkJhc2U9ZnVuY3Rpb24oKXtmdW5jdGlvbiBGKCl7fXJldHVybntleHRlbmQ6ZnVuY3Rpb24ob3ZlcnJpZGVzKXtGLnByb3RvdHlwZT10aGlzO3ZhciBzdWJ0eXBlPW5ldyBGO2lmKG92ZXJyaWRlcyl7c3VidHlwZS5taXhJbihvdmVycmlkZXMpfWlmKCFzdWJ0eXBlLmhhc093blByb3BlcnR5KFwiaW5pdFwiKSl7c3VidHlwZS5pbml0PWZ1bmN0aW9uKCl7c3VidHlwZS4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fXN1YnR5cGUuaW5pdC5wcm90b3R5cGU9c3VidHlwZTtzdWJ0eXBlLiRzdXBlcj10aGlzO3JldHVybiBzdWJ0eXBlfSxjcmVhdGU6ZnVuY3Rpb24oKXt2YXIgaW5zdGFuY2U9dGhpcy5leHRlbmQoKTtpbnN0YW5jZS5pbml0LmFwcGx5KGluc3RhbmNlLGFyZ3VtZW50cyk7cmV0dXJuIGluc3RhbmNlfSxpbml0OmZ1bmN0aW9uKCl7fSxtaXhJbjpmdW5jdGlvbihwcm9wZXJ0aWVzKXtmb3IodmFyIHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0aWVzKXtpZihwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpe3RoaXNbcHJvcGVydHlOYW1lXT1wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV19fWlmKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXCJ0b1N0cmluZ1wiKSl7dGhpcy50b1N0cmluZz1wcm9wZXJ0aWVzLnRvU3RyaW5nfX0sY2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbml0LnByb3RvdHlwZS5leHRlbmQodGhpcyl9fX0oKTt2YXIgV29yZEFycmF5PUNfbGliLldvcmRBcnJheT1CYXNlLmV4dGVuZCh7aW5pdDpmdW5jdGlvbih3b3JkcyxzaWdCeXRlcyl7d29yZHM9dGhpcy53b3Jkcz13b3Jkc3x8W107aWYoc2lnQnl0ZXMhPXVuZGVmaW5lZCl7dGhpcy5zaWdCeXRlcz1zaWdCeXRlc31lbHNle3RoaXMuc2lnQnl0ZXM9d29yZHMubGVuZ3RoKjR9fSx0b1N0cmluZzpmdW5jdGlvbihlbmNvZGVyKXtyZXR1cm4oZW5jb2Rlcnx8SGV4KS5zdHJpbmdpZnkodGhpcyl9LGNvbmNhdDpmdW5jdGlvbih3b3JkQXJyYXkpe3ZhciB0aGlzV29yZHM9dGhpcy53b3Jkczt2YXIgdGhhdFdvcmRzPXdvcmRBcnJheS53b3Jkczt2YXIgdGhpc1NpZ0J5dGVzPXRoaXMuc2lnQnl0ZXM7dmFyIHRoYXRTaWdCeXRlcz13b3JkQXJyYXkuc2lnQnl0ZXM7dGhpcy5jbGFtcCgpO2lmKHRoaXNTaWdCeXRlcyU0KXtmb3IodmFyIGk9MDtpPHRoYXRTaWdCeXRlcztpKyspe3ZhciB0aGF0Qnl0ZT10aGF0V29yZHNbaT4+PjJdPj4+MjQtaSU0KjgmMjU1O3RoaXNXb3Jkc1t0aGlzU2lnQnl0ZXMraT4+PjJdfD10aGF0Qnl0ZTw8MjQtKHRoaXNTaWdCeXRlcytpKSU0Kjh9fWVsc2UgaWYodGhhdFdvcmRzLmxlbmd0aD4yNTYpe2Zvcih2YXIgaT0wO2k8dGhhdFNpZ0J5dGVzO2krPTQpe3RoaXNXb3Jkc1t0aGlzU2lnQnl0ZXMraT4+PjJdPXRoYXRXb3Jkc1tpPj4+Ml19fWVsc2V7dGhpc1dvcmRzLnB1c2guYXBwbHkodGhpc1dvcmRzLHRoYXRXb3Jkcyl9dGhpcy5zaWdCeXRlcys9dGhhdFNpZ0J5dGVzO3JldHVybiB0aGlzfSxjbGFtcDpmdW5jdGlvbigpe3ZhciB3b3Jkcz10aGlzLndvcmRzO3ZhciBzaWdCeXRlcz10aGlzLnNpZ0J5dGVzO3dvcmRzW3NpZ0J5dGVzPj4+Ml0mPTQyOTQ5NjcyOTU8PDMyLXNpZ0J5dGVzJTQqODt3b3Jkcy5sZW5ndGg9TWF0aC5jZWlsKHNpZ0J5dGVzLzQpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciBjbG9uZT1CYXNlLmNsb25lLmNhbGwodGhpcyk7Y2xvbmUud29yZHM9dGhpcy53b3Jkcy5zbGljZSgwKTtyZXR1cm4gY2xvbmV9LHJhbmRvbTpmdW5jdGlvbihuQnl0ZXMpe3ZhciB3b3Jkcz1bXTtmb3IodmFyIGk9MDtpPG5CeXRlcztpKz00KXt3b3Jkcy5wdXNoKE1hdGgucmFuZG9tKCkqNDI5NDk2NzI5NnwwKX1yZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLG5CeXRlcyl9fSk7dmFyIENfZW5jPUMuZW5jPXt9O3ZhciBIZXg9Q19lbmMuSGV4PXtzdHJpbmdpZnk6ZnVuY3Rpb24od29yZEFycmF5KXt2YXIgd29yZHM9d29yZEFycmF5LndvcmRzO3ZhciBzaWdCeXRlcz13b3JkQXJyYXkuc2lnQnl0ZXM7dmFyIGhleENoYXJzPVtdO2Zvcih2YXIgaT0wO2k8c2lnQnl0ZXM7aSsrKXt2YXIgYml0ZT13b3Jkc1tpPj4+Ml0+Pj4yNC1pJTQqOCYyNTU7aGV4Q2hhcnMucHVzaCgoYml0ZT4+PjQpLnRvU3RyaW5nKDE2KSk7aGV4Q2hhcnMucHVzaCgoYml0ZSYxNSkudG9TdHJpbmcoMTYpKX1yZXR1cm4gaGV4Q2hhcnMuam9pbihcIlwiKX0scGFyc2U6ZnVuY3Rpb24oaGV4U3RyKXt2YXIgaGV4U3RyTGVuZ3RoPWhleFN0ci5sZW5ndGg7dmFyIHdvcmRzPVtdO2Zvcih2YXIgaT0wO2k8aGV4U3RyTGVuZ3RoO2krPTIpe3dvcmRzW2k+Pj4zXXw9cGFyc2VJbnQoaGV4U3RyLnN1YnN0cihpLDIpLDE2KTw8MjQtaSU4KjR9cmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcyxoZXhTdHJMZW5ndGgvMil9fTt2YXIgTGF0aW4xPUNfZW5jLkxhdGluMT17c3RyaW5naWZ5OmZ1bmN0aW9uKHdvcmRBcnJheSl7dmFyIHdvcmRzPXdvcmRBcnJheS53b3Jkczt2YXIgc2lnQnl0ZXM9d29yZEFycmF5LnNpZ0J5dGVzO3ZhciBsYXRpbjFDaGFycz1bXTtmb3IodmFyIGk9MDtpPHNpZ0J5dGVzO2krKyl7dmFyIGJpdGU9d29yZHNbaT4+PjJdPj4+MjQtaSU0KjgmMjU1O2xhdGluMUNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiaXRlKSl9cmV0dXJuIGxhdGluMUNoYXJzLmpvaW4oXCJcIil9LHBhcnNlOmZ1bmN0aW9uKGxhdGluMVN0cil7dmFyIGxhdGluMVN0ckxlbmd0aD1sYXRpbjFTdHIubGVuZ3RoO3ZhciB3b3Jkcz1bXTtmb3IodmFyIGk9MDtpPGxhdGluMVN0ckxlbmd0aDtpKyspe3dvcmRzW2k+Pj4yXXw9KGxhdGluMVN0ci5jaGFyQ29kZUF0KGkpJjI1NSk8PDI0LWklNCo4fXJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsbGF0aW4xU3RyTGVuZ3RoKX19O3ZhciBVdGY4PUNfZW5jLlV0Zjg9e3N0cmluZ2lmeTpmdW5jdGlvbih3b3JkQXJyYXkpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShMYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSkpKX1jYXRjaChlKXt0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgVVRGLTggZGF0YVwiKX19LHBhcnNlOmZ1bmN0aW9uKHV0ZjhTdHIpe3JldHVybiBMYXRpbjEucGFyc2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHV0ZjhTdHIpKSl9fTt2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobT1DX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtPUJhc2UuZXh0ZW5kKHtyZXNldDpmdW5jdGlvbigpe3RoaXMuX2RhdGE9bmV3IFdvcmRBcnJheS5pbml0O3RoaXMuX25EYXRhQnl0ZXM9MH0sX2FwcGVuZDpmdW5jdGlvbihkYXRhKXtpZih0eXBlb2YgZGF0YT09XCJzdHJpbmdcIil7ZGF0YT1VdGY4LnBhcnNlKGRhdGEpfXRoaXMuX2RhdGEuY29uY2F0KGRhdGEpO3RoaXMuX25EYXRhQnl0ZXMrPWRhdGEuc2lnQnl0ZXN9LF9wcm9jZXNzOmZ1bmN0aW9uKGRvRmx1c2gpe3ZhciBkYXRhPXRoaXMuX2RhdGE7dmFyIGRhdGFXb3Jkcz1kYXRhLndvcmRzO3ZhciBkYXRhU2lnQnl0ZXM9ZGF0YS5zaWdCeXRlczt2YXIgYmxvY2tTaXplPXRoaXMuYmxvY2tTaXplO3ZhciBibG9ja1NpemVCeXRlcz1ibG9ja1NpemUqNDt2YXIgbkJsb2Nrc1JlYWR5PWRhdGFTaWdCeXRlcy9ibG9ja1NpemVCeXRlcztpZihkb0ZsdXNoKXtuQmxvY2tzUmVhZHk9TWF0aC5jZWlsKG5CbG9ja3NSZWFkeSl9ZWxzZXtuQmxvY2tzUmVhZHk9TWF0aC5tYXgoKG5CbG9ja3NSZWFkeXwwKS10aGlzLl9taW5CdWZmZXJTaXplLDApfXZhciBuV29yZHNSZWFkeT1uQmxvY2tzUmVhZHkqYmxvY2tTaXplO3ZhciBuQnl0ZXNSZWFkeT1NYXRoLm1pbihuV29yZHNSZWFkeSo0LGRhdGFTaWdCeXRlcyk7aWYobldvcmRzUmVhZHkpe2Zvcih2YXIgb2Zmc2V0PTA7b2Zmc2V0PG5Xb3Jkc1JlYWR5O29mZnNldCs9YmxvY2tTaXplKXt0aGlzLl9kb1Byb2Nlc3NCbG9jayhkYXRhV29yZHMsb2Zmc2V0KX12YXIgcHJvY2Vzc2VkV29yZHM9ZGF0YVdvcmRzLnNwbGljZSgwLG5Xb3Jkc1JlYWR5KTtkYXRhLnNpZ0J5dGVzLT1uQnl0ZXNSZWFkeX1yZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHByb2Nlc3NlZFdvcmRzLG5CeXRlc1JlYWR5KX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgY2xvbmU9QmFzZS5jbG9uZS5jYWxsKHRoaXMpO2Nsb25lLl9kYXRhPXRoaXMuX2RhdGEuY2xvbmUoKTtyZXR1cm4gY2xvbmV9LF9taW5CdWZmZXJTaXplOjB9KTt2YXIgSGFzaGVyPUNfbGliLkhhc2hlcj1CdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7Y2ZnOkJhc2UuZXh0ZW5kKCksaW5pdDpmdW5jdGlvbihjZmcpe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZChjZmcpO3RoaXMucmVzZXQoKX0scmVzZXQ6ZnVuY3Rpb24oKXtCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7dGhpcy5fZG9SZXNldCgpfSx1cGRhdGU6ZnVuY3Rpb24obWVzc2FnZVVwZGF0ZSl7dGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO3RoaXMuX3Byb2Nlc3MoKTtyZXR1cm4gdGhpc30sZmluYWxpemU6ZnVuY3Rpb24obWVzc2FnZVVwZGF0ZSl7aWYobWVzc2FnZVVwZGF0ZSl7dGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpfXZhciBoYXNoPXRoaXMuX2RvRmluYWxpemUoKTtyZXR1cm4gaGFzaH0sYmxvY2tTaXplOjUxMi8zMixfY3JlYXRlSGVscGVyOmZ1bmN0aW9uKGhhc2hlcil7cmV0dXJuIGZ1bmN0aW9uKG1lc3NhZ2UsY2ZnKXtyZXR1cm4gbmV3IGhhc2hlci5pbml0KGNmZykuZmluYWxpemUobWVzc2FnZSl9fSxfY3JlYXRlSG1hY0hlbHBlcjpmdW5jdGlvbihoYXNoZXIpe3JldHVybiBmdW5jdGlvbihtZXNzYWdlLGtleSl7cmV0dXJuIG5ldyBDX2FsZ28uSE1BQy5pbml0KGhhc2hlcixrZXkpLmZpbmFsaXplKG1lc3NhZ2UpfX19KTt2YXIgQ19hbGdvPUMuYWxnbz17fTtyZXR1cm4gQ30oTWF0aCk7cmV0dXJuIENyeXB0b0pTfSl9LHt9XSwyMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSl7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIFdvcmRBcnJheT1DX2xpYi5Xb3JkQXJyYXk7dmFyIENfZW5jPUMuZW5jO3ZhciBCYXNlNjQ9Q19lbmMuQmFzZTY0PXtzdHJpbmdpZnk6ZnVuY3Rpb24od29yZEFycmF5KXt2YXIgd29yZHM9d29yZEFycmF5LndvcmRzO3ZhciBzaWdCeXRlcz13b3JkQXJyYXkuc2lnQnl0ZXM7dmFyIG1hcD10aGlzLl9tYXA7d29yZEFycmF5LmNsYW1wKCk7dmFyIGJhc2U2NENoYXJzPVtdO2Zvcih2YXIgaT0wO2k8c2lnQnl0ZXM7aSs9Myl7dmFyIGJ5dGUxPXdvcmRzW2k+Pj4yXT4+PjI0LWklNCo4JjI1NTt2YXIgYnl0ZTI9d29yZHNbaSsxPj4+Ml0+Pj4yNC0oaSsxKSU0KjgmMjU1O3ZhciBieXRlMz13b3Jkc1tpKzI+Pj4yXT4+PjI0LShpKzIpJTQqOCYyNTU7dmFyIHRyaXBsZXQ9Ynl0ZTE8PDE2fGJ5dGUyPDw4fGJ5dGUzO2Zvcih2YXIgaj0wO2o8NCYmaStqKi43NTxzaWdCeXRlcztqKyspe2Jhc2U2NENoYXJzLnB1c2gobWFwLmNoYXJBdCh0cmlwbGV0Pj4+NiooMy1qKSY2MykpfX12YXIgcGFkZGluZ0NoYXI9bWFwLmNoYXJBdCg2NCk7aWYocGFkZGluZ0NoYXIpe3doaWxlKGJhc2U2NENoYXJzLmxlbmd0aCU0KXtiYXNlNjRDaGFycy5wdXNoKHBhZGRpbmdDaGFyKX19cmV0dXJuIGJhc2U2NENoYXJzLmpvaW4oXCJcIil9LHBhcnNlOmZ1bmN0aW9uKGJhc2U2NFN0cil7dmFyIGJhc2U2NFN0ckxlbmd0aD1iYXNlNjRTdHIubGVuZ3RoO3ZhciBtYXA9dGhpcy5fbWFwO3ZhciBwYWRkaW5nQ2hhcj1tYXAuY2hhckF0KDY0KTtpZihwYWRkaW5nQ2hhcil7dmFyIHBhZGRpbmdJbmRleD1iYXNlNjRTdHIuaW5kZXhPZihwYWRkaW5nQ2hhcik7aWYocGFkZGluZ0luZGV4IT0tMSl7YmFzZTY0U3RyTGVuZ3RoPXBhZGRpbmdJbmRleH19dmFyIHdvcmRzPVtdO3ZhciBuQnl0ZXM9MDtmb3IodmFyIGk9MDtpPGJhc2U2NFN0ckxlbmd0aDtpKyspe2lmKGklNCl7dmFyIGJpdHMxPW1hcC5pbmRleE9mKGJhc2U2NFN0ci5jaGFyQXQoaS0xKSk8PGklNCoyO3ZhciBiaXRzMj1tYXAuaW5kZXhPZihiYXNlNjRTdHIuY2hhckF0KGkpKT4+PjYtaSU0KjI7d29yZHNbbkJ5dGVzPj4+Ml18PShiaXRzMXxiaXRzMik8PDI0LW5CeXRlcyU0Kjg7bkJ5dGVzKyt9fXJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLG5CeXRlcyl9LF9tYXA6XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwifX0pKCk7cmV0dXJuIENyeXB0b0pTLmVuYy5CYXNlNjR9KX0se1wiLi9jb3JlXCI6MjB9XSwyMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSl7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIFdvcmRBcnJheT1DX2xpYi5Xb3JkQXJyYXk7dmFyIENfZW5jPUMuZW5jO3ZhciBVdGYxNkJFPUNfZW5jLlV0ZjE2PUNfZW5jLlV0ZjE2QkU9e3N0cmluZ2lmeTpmdW5jdGlvbih3b3JkQXJyYXkpe3ZhciB3b3Jkcz13b3JkQXJyYXkud29yZHM7dmFyIHNpZ0J5dGVzPXdvcmRBcnJheS5zaWdCeXRlczt2YXIgdXRmMTZDaGFycz1bXTtmb3IodmFyIGk9MDtpPHNpZ0J5dGVzO2krPTIpe3ZhciBjb2RlUG9pbnQ9d29yZHNbaT4+PjJdPj4+MTYtaSU0KjgmNjU1MzU7dXRmMTZDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KSl9cmV0dXJuIHV0ZjE2Q2hhcnMuam9pbihcIlwiKX0scGFyc2U6ZnVuY3Rpb24odXRmMTZTdHIpe3ZhciB1dGYxNlN0ckxlbmd0aD11dGYxNlN0ci5sZW5ndGg7dmFyIHdvcmRzPVtdO2Zvcih2YXIgaT0wO2k8dXRmMTZTdHJMZW5ndGg7aSsrKXt3b3Jkc1tpPj4+MV18PXV0ZjE2U3RyLmNoYXJDb2RlQXQoaSk8PDE2LWklMioxNn1yZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3Jkcyx1dGYxNlN0ckxlbmd0aCoyKX19O0NfZW5jLlV0ZjE2TEU9e3N0cmluZ2lmeTpmdW5jdGlvbih3b3JkQXJyYXkpe3ZhciB3b3Jkcz13b3JkQXJyYXkud29yZHM7dmFyIHNpZ0J5dGVzPXdvcmRBcnJheS5zaWdCeXRlczt2YXIgdXRmMTZDaGFycz1bXTtmb3IodmFyIGk9MDtpPHNpZ0J5dGVzO2krPTIpe3ZhciBjb2RlUG9pbnQ9c3dhcEVuZGlhbih3b3Jkc1tpPj4+Ml0+Pj4xNi1pJTQqOCY2NTUzNSk7dXRmMTZDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KSl9cmV0dXJuIHV0ZjE2Q2hhcnMuam9pbihcIlwiKX0scGFyc2U6ZnVuY3Rpb24odXRmMTZTdHIpe3ZhciB1dGYxNlN0ckxlbmd0aD11dGYxNlN0ci5sZW5ndGg7dmFyIHdvcmRzPVtdO2Zvcih2YXIgaT0wO2k8dXRmMTZTdHJMZW5ndGg7aSsrKXt3b3Jkc1tpPj4+MV18PXN3YXBFbmRpYW4odXRmMTZTdHIuY2hhckNvZGVBdChpKTw8MTYtaSUyKjE2KX1yZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3Jkcyx1dGYxNlN0ckxlbmd0aCoyKX19O2Z1bmN0aW9uIHN3YXBFbmRpYW4od29yZCl7cmV0dXJuIHdvcmQ8PDgmNDI3ODI1NTM2MHx3b3JkPj4+OCYxNjcxMTkzNX19KSgpO3JldHVybiBDcnlwdG9KUy5lbmMuVXRmMTZ9KX0se1wiLi9jb3JlXCI6MjB9XSwyMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9zaGExXCIpLF9kZXJlcV8oXCIuL2htYWNcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9zaGExXCIsXCIuL2htYWNcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbigpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgQmFzZT1DX2xpYi5CYXNlO3ZhciBXb3JkQXJyYXk9Q19saWIuV29yZEFycmF5O3ZhciBDX2FsZ289Qy5hbGdvO3ZhciBNRDU9Q19hbGdvLk1ENTt2YXIgRXZwS0RGPUNfYWxnby5FdnBLREY9QmFzZS5leHRlbmQoe2NmZzpCYXNlLmV4dGVuZCh7a2V5U2l6ZToxMjgvMzIsaGFzaGVyOk1ENSxpdGVyYXRpb25zOjF9KSxpbml0OmZ1bmN0aW9uKGNmZyl7dGhpcy5jZmc9dGhpcy5jZmcuZXh0ZW5kKGNmZyl9LGNvbXB1dGU6ZnVuY3Rpb24ocGFzc3dvcmQsc2FsdCl7dmFyIGNmZz10aGlzLmNmZzt2YXIgaGFzaGVyPWNmZy5oYXNoZXIuY3JlYXRlKCk7dmFyIGRlcml2ZWRLZXk9V29yZEFycmF5LmNyZWF0ZSgpO3ZhciBkZXJpdmVkS2V5V29yZHM9ZGVyaXZlZEtleS53b3Jkczt2YXIga2V5U2l6ZT1jZmcua2V5U2l6ZTt2YXIgaXRlcmF0aW9ucz1jZmcuaXRlcmF0aW9uczt3aGlsZShkZXJpdmVkS2V5V29yZHMubGVuZ3RoPGtleVNpemUpe2lmKGJsb2NrKXtoYXNoZXIudXBkYXRlKGJsb2NrKX12YXIgYmxvY2s9aGFzaGVyLnVwZGF0ZShwYXNzd29yZCkuZmluYWxpemUoc2FsdCk7aGFzaGVyLnJlc2V0KCk7Zm9yKHZhciBpPTE7aTxpdGVyYXRpb25zO2krKyl7YmxvY2s9aGFzaGVyLmZpbmFsaXplKGJsb2NrKTtoYXNoZXIucmVzZXQoKX1kZXJpdmVkS2V5LmNvbmNhdChibG9jayl9ZGVyaXZlZEtleS5zaWdCeXRlcz1rZXlTaXplKjQ7cmV0dXJuIGRlcml2ZWRLZXl9fSk7Qy5FdnBLREY9ZnVuY3Rpb24ocGFzc3dvcmQsc2FsdCxjZmcpe3JldHVybiBFdnBLREYuY3JlYXRlKGNmZykuY29tcHV0ZShwYXNzd29yZCxzYWx0KX19KSgpO3JldHVybiBDcnlwdG9KUy5FdnBLREZ9KX0se1wiLi9jb3JlXCI6MjAsXCIuL2htYWNcIjoyNixcIi4vc2hhMVwiOjQ1fV0sMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vY2lwaGVyLWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9jaXBoZXItY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKHVuZGVmaW5lZCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBDaXBoZXJQYXJhbXM9Q19saWIuQ2lwaGVyUGFyYW1zO3ZhciBDX2VuYz1DLmVuYzt2YXIgSGV4PUNfZW5jLkhleDt2YXIgQ19mb3JtYXQ9Qy5mb3JtYXQ7dmFyIEhleEZvcm1hdHRlcj1DX2Zvcm1hdC5IZXg9e3N0cmluZ2lmeTpmdW5jdGlvbihjaXBoZXJQYXJhbXMpe3JldHVybiBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dC50b1N0cmluZyhIZXgpfSxwYXJzZTpmdW5jdGlvbihpbnB1dCl7dmFyIGNpcGhlcnRleHQ9SGV4LnBhcnNlKGlucHV0KTtyZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7Y2lwaGVydGV4dDpjaXBoZXJ0ZXh0fSl9fX0pKCk7cmV0dXJuIENyeXB0b0pTLmZvcm1hdC5IZXh9KX0se1wiLi9jaXBoZXItY29yZVwiOjE5LFwiLi9jb3JlXCI6MjB9XSwyNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9zaGEyNTZcIiksX2RlcmVxXyhcIi4vaG1hY1wiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL3NoYTI1NlwiLFwiLi9obWFjXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXtyZXR1cm4gQ3J5cHRvSlMuSG1hY1NIQTI1Nn0pfSx7XCIuL2NvcmVcIjoyMCxcIi4vaG1hY1wiOjI2LFwiLi9zaGEyNTZcIjo0N31dLDI2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5KXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbigpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgQmFzZT1DX2xpYi5CYXNlO3ZhciBDX2VuYz1DLmVuYzt2YXIgVXRmOD1DX2VuYy5VdGY4O3ZhciBDX2FsZ289Qy5hbGdvO3ZhciBITUFDPUNfYWxnby5ITUFDPUJhc2UuZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKGhhc2hlcixrZXkpe2hhc2hlcj10aGlzLl9oYXNoZXI9bmV3IGhhc2hlci5pbml0O2lmKHR5cGVvZiBrZXk9PVwic3RyaW5nXCIpe2tleT1VdGY4LnBhcnNlKGtleSl9dmFyIGhhc2hlckJsb2NrU2l6ZT1oYXNoZXIuYmxvY2tTaXplO3ZhciBoYXNoZXJCbG9ja1NpemVCeXRlcz1oYXNoZXJCbG9ja1NpemUqNDtpZihrZXkuc2lnQnl0ZXM+aGFzaGVyQmxvY2tTaXplQnl0ZXMpe2tleT1oYXNoZXIuZmluYWxpemUoa2V5KX1rZXkuY2xhbXAoKTt2YXIgb0tleT10aGlzLl9vS2V5PWtleS5jbG9uZSgpO3ZhciBpS2V5PXRoaXMuX2lLZXk9a2V5LmNsb25lKCk7dmFyIG9LZXlXb3Jkcz1vS2V5LndvcmRzO3ZhciBpS2V5V29yZHM9aUtleS53b3Jkcztmb3IodmFyIGk9MDtpPGhhc2hlckJsb2NrU2l6ZTtpKyspe29LZXlXb3Jkc1tpXV49MTU0OTU1NjgyODtpS2V5V29yZHNbaV1ePTkwOTUyMjQ4Nn1vS2V5LnNpZ0J5dGVzPWlLZXkuc2lnQnl0ZXM9aGFzaGVyQmxvY2tTaXplQnl0ZXM7dGhpcy5yZXNldCgpfSxyZXNldDpmdW5jdGlvbigpe3ZhciBoYXNoZXI9dGhpcy5faGFzaGVyO2hhc2hlci5yZXNldCgpO2hhc2hlci51cGRhdGUodGhpcy5faUtleSl9LHVwZGF0ZTpmdW5jdGlvbihtZXNzYWdlVXBkYXRlKXt0aGlzLl9oYXNoZXIudXBkYXRlKG1lc3NhZ2VVcGRhdGUpO3JldHVybiB0aGlzfSxmaW5hbGl6ZTpmdW5jdGlvbihtZXNzYWdlVXBkYXRlKXt2YXIgaGFzaGVyPXRoaXMuX2hhc2hlcjt2YXIgaW5uZXJIYXNoPWhhc2hlci5maW5hbGl6ZShtZXNzYWdlVXBkYXRlKTtoYXNoZXIucmVzZXQoKTt2YXIgaG1hYz1oYXNoZXIuZmluYWxpemUodGhpcy5fb0tleS5jbG9uZSgpLmNvbmNhdChpbm5lckhhc2gpKTtyZXR1cm4gaG1hY319KX0pKCl9KX0se1wiLi9jb3JlXCI6MjB9XSwyNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi94NjQtY29yZVwiKSxfZGVyZXFfKFwiLi9saWItdHlwZWRhcnJheXNcIiksX2RlcmVxXyhcIi4vZW5jLXV0ZjE2XCIpLF9kZXJlcV8oXCIuL2VuYy1iYXNlNjRcIiksX2RlcmVxXyhcIi4vbWQ1XCIpLF9kZXJlcV8oXCIuL3NoYTFcIiksX2RlcmVxXyhcIi4vc2hhMjU2XCIpLF9kZXJlcV8oXCIuL3NoYTIyNFwiKSxfZGVyZXFfKFwiLi9zaGE1MTJcIiksX2RlcmVxXyhcIi4vc2hhMzg0XCIpLF9kZXJlcV8oXCIuL3NoYTNcIiksX2RlcmVxXyhcIi4vcmlwZW1kMTYwXCIpLF9kZXJlcV8oXCIuL2htYWNcIiksX2RlcmVxXyhcIi4vcGJrZGYyXCIpLF9kZXJlcV8oXCIuL2V2cGtkZlwiKSxfZGVyZXFfKFwiLi9jaXBoZXItY29yZVwiKSxfZGVyZXFfKFwiLi9tb2RlLWNmYlwiKSxfZGVyZXFfKFwiLi9tb2RlLWN0clwiKSxfZGVyZXFfKFwiLi9tb2RlLWN0ci1nbGFkbWFuXCIpLF9kZXJlcV8oXCIuL21vZGUtb2ZiXCIpLF9kZXJlcV8oXCIuL21vZGUtZWNiXCIpLF9kZXJlcV8oXCIuL3BhZC1hbnNpeDkyM1wiKSxfZGVyZXFfKFwiLi9wYWQtaXNvMTAxMjZcIiksX2RlcmVxXyhcIi4vcGFkLWlzbzk3OTcxXCIpLF9kZXJlcV8oXCIuL3BhZC16ZXJvcGFkZGluZ1wiKSxfZGVyZXFfKFwiLi9wYWQtbm9wYWRkaW5nXCIpLF9kZXJlcV8oXCIuL2Zvcm1hdC1oZXhcIiksX2RlcmVxXyhcIi4vYWVzXCIpLF9kZXJlcV8oXCIuL3RyaXBsZWRlc1wiKSxfZGVyZXFfKFwiLi9yYzRcIiksX2RlcmVxXyhcIi4vcmFiYml0XCIpLF9kZXJlcV8oXCIuL3JhYmJpdC1sZWdhY3lcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi94NjQtY29yZVwiLFwiLi9saWItdHlwZWRhcnJheXNcIixcIi4vZW5jLXV0ZjE2XCIsXCIuL2VuYy1iYXNlNjRcIixcIi4vbWQ1XCIsXCIuL3NoYTFcIixcIi4vc2hhMjU2XCIsXCIuL3NoYTIyNFwiLFwiLi9zaGE1MTJcIixcIi4vc2hhMzg0XCIsXCIuL3NoYTNcIixcIi4vcmlwZW1kMTYwXCIsXCIuL2htYWNcIixcIi4vcGJrZGYyXCIsXCIuL2V2cGtkZlwiLFwiLi9jaXBoZXItY29yZVwiLFwiLi9tb2RlLWNmYlwiLFwiLi9tb2RlLWN0clwiLFwiLi9tb2RlLWN0ci1nbGFkbWFuXCIsXCIuL21vZGUtb2ZiXCIsXCIuL21vZGUtZWNiXCIsXCIuL3BhZC1hbnNpeDkyM1wiLFwiLi9wYWQtaXNvMTAxMjZcIixcIi4vcGFkLWlzbzk3OTcxXCIsXCIuL3BhZC16ZXJvcGFkZGluZ1wiLFwiLi9wYWQtbm9wYWRkaW5nXCIsXCIuL2Zvcm1hdC1oZXhcIixcIi4vYWVzXCIsXCIuL3RyaXBsZWRlc1wiLFwiLi9yYzRcIixcIi4vcmFiYml0XCIsXCIuL3JhYmJpdC1sZWdhY3lcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpe3JldHVybiBDcnlwdG9KU30pfSx7XCIuL2Flc1wiOjE4LFwiLi9jaXBoZXItY29yZVwiOjE5LFwiLi9jb3JlXCI6MjAsXCIuL2VuYy1iYXNlNjRcIjoyMSxcIi4vZW5jLXV0ZjE2XCI6MjIsXCIuL2V2cGtkZlwiOjIzLFwiLi9mb3JtYXQtaGV4XCI6MjQsXCIuL2htYWNcIjoyNixcIi4vbGliLXR5cGVkYXJyYXlzXCI6MjgsXCIuL21kNVwiOjI5LFwiLi9tb2RlLWNmYlwiOjMwLFwiLi9tb2RlLWN0clwiOjMyLFwiLi9tb2RlLWN0ci1nbGFkbWFuXCI6MzEsXCIuL21vZGUtZWNiXCI6MzMsXCIuL21vZGUtb2ZiXCI6MzQsXCIuL3BhZC1hbnNpeDkyM1wiOjM1LFwiLi9wYWQtaXNvMTAxMjZcIjozNixcIi4vcGFkLWlzbzk3OTcxXCI6MzcsXCIuL3BhZC1ub3BhZGRpbmdcIjozOCxcIi4vcGFkLXplcm9wYWRkaW5nXCI6MzksXCIuL3Bia2RmMlwiOjQwLFwiLi9yYWJiaXRcIjo0MixcIi4vcmFiYml0LWxlZ2FjeVwiOjQxLFwiLi9yYzRcIjo0MyxcIi4vcmlwZW1kMTYwXCI6NDQsXCIuL3NoYTFcIjo0NSxcIi4vc2hhMjI0XCI6NDYsXCIuL3NoYTI1NlwiOjQ3LFwiLi9zaGEzXCI6NDgsXCIuL3NoYTM4NFwiOjQ5LFwiLi9zaGE1MTJcIjo1MCxcIi4vdHJpcGxlZGVzXCI6NTEsXCIuL3g2NC1jb3JlXCI6NTJ9XSwyODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSl7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oKXtpZih0eXBlb2YgQXJyYXlCdWZmZXIhPVwiZnVuY3Rpb25cIil7cmV0dXJufXZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgV29yZEFycmF5PUNfbGliLldvcmRBcnJheTt2YXIgc3VwZXJJbml0PVdvcmRBcnJheS5pbml0O3ZhciBzdWJJbml0PVdvcmRBcnJheS5pbml0PWZ1bmN0aW9uKHR5cGVkQXJyYXkpe2lmKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil7dHlwZWRBcnJheT1uZXcgVWludDhBcnJheSh0eXBlZEFycmF5KX1pZih0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50OEFycmF5fHx0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXl8fHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQxNkFycmF5fHx0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXl8fHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5fHx0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXl8fHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXl8fHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpe3R5cGVkQXJyYXk9bmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheS5idWZmZXIsdHlwZWRBcnJheS5ieXRlT2Zmc2V0LHR5cGVkQXJyYXkuYnl0ZUxlbmd0aCl9aWYodHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpe3ZhciB0eXBlZEFycmF5Qnl0ZUxlbmd0aD10eXBlZEFycmF5LmJ5dGVMZW5ndGg7dmFyIHdvcmRzPVtdO2Zvcih2YXIgaT0wO2k8dHlwZWRBcnJheUJ5dGVMZW5ndGg7aSsrKXt3b3Jkc1tpPj4+Ml18PXR5cGVkQXJyYXlbaV08PDI0LWklNCo4fXN1cGVySW5pdC5jYWxsKHRoaXMsd29yZHMsdHlwZWRBcnJheUJ5dGVMZW5ndGgpfWVsc2V7c3VwZXJJbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX19O3N1YkluaXQucHJvdG90eXBlPVdvcmRBcnJheX0pKCk7cmV0dXJuIENyeXB0b0pTLmxpYi5Xb3JkQXJyYXl9KX0se1wiLi9jb3JlXCI6MjB9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSl7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oTWF0aCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBXb3JkQXJyYXk9Q19saWIuV29yZEFycmF5O3ZhciBIYXNoZXI9Q19saWIuSGFzaGVyO3ZhciBDX2FsZ289Qy5hbGdvO3ZhciBUPVtdOyhmdW5jdGlvbigpe2Zvcih2YXIgaT0wO2k8NjQ7aSsrKXtUW2ldPU1hdGguYWJzKE1hdGguc2luKGkrMSkpKjQyOTQ5NjcyOTZ8MH19KSgpO3ZhciBNRDU9Q19hbGdvLk1ENT1IYXNoZXIuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IFdvcmRBcnJheS5pbml0KFsxNzMyNTg0MTkzLDQwMjMyMzM0MTcsMjU2MjM4MzEwMiwyNzE3MzM4NzhdKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKE0sb2Zmc2V0KXtmb3IodmFyIGk9MDtpPDE2O2krKyl7dmFyIG9mZnNldF9pPW9mZnNldCtpO3ZhciBNX29mZnNldF9pPU1bb2Zmc2V0X2ldO01bb2Zmc2V0X2ldPShNX29mZnNldF9pPDw4fE1fb2Zmc2V0X2k+Pj4yNCkmMTY3MTE5MzV8KE1fb2Zmc2V0X2k8PDI0fE1fb2Zmc2V0X2k+Pj44KSY0Mjc4MjU1MzYwfXZhciBIPXRoaXMuX2hhc2gud29yZHM7dmFyIE1fb2Zmc2V0XzA9TVtvZmZzZXQrMF07dmFyIE1fb2Zmc2V0XzE9TVtvZmZzZXQrMV07dmFyIE1fb2Zmc2V0XzI9TVtvZmZzZXQrMl07dmFyIE1fb2Zmc2V0XzM9TVtvZmZzZXQrM107dmFyIE1fb2Zmc2V0XzQ9TVtvZmZzZXQrNF07dmFyIE1fb2Zmc2V0XzU9TVtvZmZzZXQrNV07dmFyIE1fb2Zmc2V0XzY9TVtvZmZzZXQrNl07dmFyIE1fb2Zmc2V0Xzc9TVtvZmZzZXQrN107dmFyIE1fb2Zmc2V0Xzg9TVtvZmZzZXQrOF07dmFyIE1fb2Zmc2V0Xzk9TVtvZmZzZXQrOV07dmFyIE1fb2Zmc2V0XzEwPU1bb2Zmc2V0KzEwXTt2YXIgTV9vZmZzZXRfMTE9TVtvZmZzZXQrMTFdO3ZhciBNX29mZnNldF8xMj1NW29mZnNldCsxMl07dmFyIE1fb2Zmc2V0XzEzPU1bb2Zmc2V0KzEzXTt2YXIgTV9vZmZzZXRfMTQ9TVtvZmZzZXQrMTRdO3ZhciBNX29mZnNldF8xNT1NW29mZnNldCsxNV07dmFyIGE9SFswXTt2YXIgYj1IWzFdO3ZhciBjPUhbMl07dmFyIGQ9SFszXTthPUZGKGEsYixjLGQsTV9vZmZzZXRfMCw3LFRbMF0pO2Q9RkYoZCxhLGIsYyxNX29mZnNldF8xLDEyLFRbMV0pO2M9RkYoYyxkLGEsYixNX29mZnNldF8yLDE3LFRbMl0pO2I9RkYoYixjLGQsYSxNX29mZnNldF8zLDIyLFRbM10pO2E9RkYoYSxiLGMsZCxNX29mZnNldF80LDcsVFs0XSk7ZD1GRihkLGEsYixjLE1fb2Zmc2V0XzUsMTIsVFs1XSk7Yz1GRihjLGQsYSxiLE1fb2Zmc2V0XzYsMTcsVFs2XSk7Yj1GRihiLGMsZCxhLE1fb2Zmc2V0XzcsMjIsVFs3XSk7YT1GRihhLGIsYyxkLE1fb2Zmc2V0XzgsNyxUWzhdKTtkPUZGKGQsYSxiLGMsTV9vZmZzZXRfOSwxMixUWzldKTtjPUZGKGMsZCxhLGIsTV9vZmZzZXRfMTAsMTcsVFsxMF0pO2I9RkYoYixjLGQsYSxNX29mZnNldF8xMSwyMixUWzExXSk7YT1GRihhLGIsYyxkLE1fb2Zmc2V0XzEyLDcsVFsxMl0pO2Q9RkYoZCxhLGIsYyxNX29mZnNldF8xMywxMixUWzEzXSk7Yz1GRihjLGQsYSxiLE1fb2Zmc2V0XzE0LDE3LFRbMTRdKTtiPUZGKGIsYyxkLGEsTV9vZmZzZXRfMTUsMjIsVFsxNV0pO2E9R0coYSxiLGMsZCxNX29mZnNldF8xLDUsVFsxNl0pO2Q9R0coZCxhLGIsYyxNX29mZnNldF82LDksVFsxN10pO2M9R0coYyxkLGEsYixNX29mZnNldF8xMSwxNCxUWzE4XSk7Yj1HRyhiLGMsZCxhLE1fb2Zmc2V0XzAsMjAsVFsxOV0pO2E9R0coYSxiLGMsZCxNX29mZnNldF81LDUsVFsyMF0pO2Q9R0coZCxhLGIsYyxNX29mZnNldF8xMCw5LFRbMjFdKTtjPUdHKGMsZCxhLGIsTV9vZmZzZXRfMTUsMTQsVFsyMl0pO2I9R0coYixjLGQsYSxNX29mZnNldF80LDIwLFRbMjNdKTthPUdHKGEsYixjLGQsTV9vZmZzZXRfOSw1LFRbMjRdKTtkPUdHKGQsYSxiLGMsTV9vZmZzZXRfMTQsOSxUWzI1XSk7Yz1HRyhjLGQsYSxiLE1fb2Zmc2V0XzMsMTQsVFsyNl0pO2I9R0coYixjLGQsYSxNX29mZnNldF84LDIwLFRbMjddKTthPUdHKGEsYixjLGQsTV9vZmZzZXRfMTMsNSxUWzI4XSk7ZD1HRyhkLGEsYixjLE1fb2Zmc2V0XzIsOSxUWzI5XSk7Yz1HRyhjLGQsYSxiLE1fb2Zmc2V0XzcsMTQsVFszMF0pO2I9R0coYixjLGQsYSxNX29mZnNldF8xMiwyMCxUWzMxXSk7YT1ISChhLGIsYyxkLE1fb2Zmc2V0XzUsNCxUWzMyXSk7ZD1ISChkLGEsYixjLE1fb2Zmc2V0XzgsMTEsVFszM10pO2M9SEgoYyxkLGEsYixNX29mZnNldF8xMSwxNixUWzM0XSk7Yj1ISChiLGMsZCxhLE1fb2Zmc2V0XzE0LDIzLFRbMzVdKTthPUhIKGEsYixjLGQsTV9vZmZzZXRfMSw0LFRbMzZdKTtkPUhIKGQsYSxiLGMsTV9vZmZzZXRfNCwxMSxUWzM3XSk7Yz1ISChjLGQsYSxiLE1fb2Zmc2V0XzcsMTYsVFszOF0pO2I9SEgoYixjLGQsYSxNX29mZnNldF8xMCwyMyxUWzM5XSk7YT1ISChhLGIsYyxkLE1fb2Zmc2V0XzEzLDQsVFs0MF0pO2Q9SEgoZCxhLGIsYyxNX29mZnNldF8wLDExLFRbNDFdKTtjPUhIKGMsZCxhLGIsTV9vZmZzZXRfMywxNixUWzQyXSk7Yj1ISChiLGMsZCxhLE1fb2Zmc2V0XzYsMjMsVFs0M10pO2E9SEgoYSxiLGMsZCxNX29mZnNldF85LDQsVFs0NF0pO2Q9SEgoZCxhLGIsYyxNX29mZnNldF8xMiwxMSxUWzQ1XSk7Yz1ISChjLGQsYSxiLE1fb2Zmc2V0XzE1LDE2LFRbNDZdKTtiPUhIKGIsYyxkLGEsTV9vZmZzZXRfMiwyMyxUWzQ3XSk7YT1JSShhLGIsYyxkLE1fb2Zmc2V0XzAsNixUWzQ4XSk7ZD1JSShkLGEsYixjLE1fb2Zmc2V0XzcsMTAsVFs0OV0pO2M9SUkoYyxkLGEsYixNX29mZnNldF8xNCwxNSxUWzUwXSk7Yj1JSShiLGMsZCxhLE1fb2Zmc2V0XzUsMjEsVFs1MV0pO2E9SUkoYSxiLGMsZCxNX29mZnNldF8xMiw2LFRbNTJdKTtkPUlJKGQsYSxiLGMsTV9vZmZzZXRfMywxMCxUWzUzXSk7Yz1JSShjLGQsYSxiLE1fb2Zmc2V0XzEwLDE1LFRbNTRdKTtiPUlJKGIsYyxkLGEsTV9vZmZzZXRfMSwyMSxUWzU1XSk7YT1JSShhLGIsYyxkLE1fb2Zmc2V0XzgsNixUWzU2XSk7ZD1JSShkLGEsYixjLE1fb2Zmc2V0XzE1LDEwLFRbNTddKTtjPUlJKGMsZCxhLGIsTV9vZmZzZXRfNiwxNSxUWzU4XSk7Yj1JSShiLGMsZCxhLE1fb2Zmc2V0XzEzLDIxLFRbNTldKTthPUlJKGEsYixjLGQsTV9vZmZzZXRfNCw2LFRbNjBdKTtkPUlJKGQsYSxiLGMsTV9vZmZzZXRfMTEsMTAsVFs2MV0pO2M9SUkoYyxkLGEsYixNX29mZnNldF8yLDE1LFRbNjJdKTtiPUlJKGIsYyxkLGEsTV9vZmZzZXRfOSwyMSxUWzYzXSk7SFswXT1IWzBdK2F8MDtIWzFdPUhbMV0rYnwwO0hbMl09SFsyXStjfDA7SFszXT1IWzNdK2R8MH0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgZGF0YT10aGlzLl9kYXRhO3ZhciBkYXRhV29yZHM9ZGF0YS53b3Jkczt2YXIgbkJpdHNUb3RhbD10aGlzLl9uRGF0YUJ5dGVzKjg7dmFyIG5CaXRzTGVmdD1kYXRhLnNpZ0J5dGVzKjg7ZGF0YVdvcmRzW25CaXRzTGVmdD4+PjVdfD0xMjg8PDI0LW5CaXRzTGVmdCUzMjt2YXIgbkJpdHNUb3RhbEg9TWF0aC5mbG9vcihuQml0c1RvdGFsLzQyOTQ5NjcyOTYpO3ZhciBuQml0c1RvdGFsTD1uQml0c1RvdGFsO2RhdGFXb3Jkc1sobkJpdHNMZWZ0KzY0Pj4+OTw8NCkrMTVdPShuQml0c1RvdGFsSDw8OHxuQml0c1RvdGFsSD4+PjI0KSYxNjcxMTkzNXwobkJpdHNUb3RhbEg8PDI0fG5CaXRzVG90YWxIPj4+OCkmNDI3ODI1NTM2MDtkYXRhV29yZHNbKG5CaXRzTGVmdCs2ND4+Pjk8PDQpKzE0XT0obkJpdHNUb3RhbEw8PDh8bkJpdHNUb3RhbEw+Pj4yNCkmMTY3MTE5MzV8KG5CaXRzVG90YWxMPDwyNHxuQml0c1RvdGFsTD4+PjgpJjQyNzgyNTUzNjA7ZGF0YS5zaWdCeXRlcz0oZGF0YVdvcmRzLmxlbmd0aCsxKSo0O3RoaXMuX3Byb2Nlc3MoKTt2YXIgaGFzaD10aGlzLl9oYXNoO3ZhciBIPWhhc2gud29yZHM7Zm9yKHZhciBpPTA7aTw0O2krKyl7dmFyIEhfaT1IW2ldO0hbaV09KEhfaTw8OHxIX2k+Pj4yNCkmMTY3MTE5MzV8KEhfaTw8MjR8SF9pPj4+OCkmNDI3ODI1NTM2MH1yZXR1cm4gaGFzaH0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgY2xvbmU9SGFzaGVyLmNsb25lLmNhbGwodGhpcyk7Y2xvbmUuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpO3JldHVybiBjbG9uZX19KTtmdW5jdGlvbiBGRihhLGIsYyxkLHgscyx0KXt2YXIgbj1hKyhiJmN8fmImZCkreCt0O3JldHVybihuPDxzfG4+Pj4zMi1zKStifWZ1bmN0aW9uIEdHKGEsYixjLGQseCxzLHQpe3ZhciBuPWErKGImZHxjJn5kKSt4K3Q7cmV0dXJuKG48PHN8bj4+PjMyLXMpK2J9ZnVuY3Rpb24gSEgoYSxiLGMsZCx4LHMsdCl7dmFyIG49YSsoYl5jXmQpK3grdDtyZXR1cm4objw8c3xuPj4+MzItcykrYn1mdW5jdGlvbiBJSShhLGIsYyxkLHgscyx0KXt2YXIgbj1hKyhjXihifH5kKSkreCt0O3JldHVybihuPDxzfG4+Pj4zMi1zKStifUMuTUQ1PUhhc2hlci5fY3JlYXRlSGVscGVyKE1ENSk7Qy5IbWFjTUQ1PUhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihNRDUpfSkoTWF0aCk7cmV0dXJuIENyeXB0b0pTLk1ENX0pfSx7XCIuL2NvcmVcIjoyMH1dLDMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL2NpcGhlci1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vY2lwaGVyLWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpe0NyeXB0b0pTLm1vZGUuQ0ZCPWZ1bmN0aW9uKCl7dmFyIENGQj1DcnlwdG9KUy5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO0NGQi5FbmNyeXB0b3I9Q0ZCLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHdvcmRzLG9mZnNldCl7dmFyIGNpcGhlcj10aGlzLl9jaXBoZXI7dmFyIGJsb2NrU2l6ZT1jaXBoZXIuYmxvY2tTaXplO2dlbmVyYXRlS2V5c3RyZWFtQW5kRW5jcnlwdC5jYWxsKHRoaXMsd29yZHMsb2Zmc2V0LGJsb2NrU2l6ZSxjaXBoZXIpO3RoaXMuX3ByZXZCbG9jaz13b3Jkcy5zbGljZShvZmZzZXQsb2Zmc2V0K2Jsb2NrU2l6ZSl9fSk7Q0ZCLkRlY3J5cHRvcj1DRkIuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24od29yZHMsb2Zmc2V0KXt2YXIgY2lwaGVyPXRoaXMuX2NpcGhlcjt2YXIgYmxvY2tTaXplPWNpcGhlci5ibG9ja1NpemU7dmFyIHRoaXNCbG9jaz13b3Jkcy5zbGljZShvZmZzZXQsb2Zmc2V0K2Jsb2NrU2l6ZSk7Z2VuZXJhdGVLZXlzdHJlYW1BbmRFbmNyeXB0LmNhbGwodGhpcyx3b3JkcyxvZmZzZXQsYmxvY2tTaXplLGNpcGhlcik7dGhpcy5fcHJldkJsb2NrPXRoaXNCbG9ja319KTtmdW5jdGlvbiBnZW5lcmF0ZUtleXN0cmVhbUFuZEVuY3J5cHQod29yZHMsb2Zmc2V0LGJsb2NrU2l6ZSxjaXBoZXIpe3ZhciBpdj10aGlzLl9pdjtpZihpdil7dmFyIGtleXN0cmVhbT1pdi5zbGljZSgwKTt0aGlzLl9pdj11bmRlZmluZWR9ZWxzZXt2YXIga2V5c3RyZWFtPXRoaXMuX3ByZXZCbG9ja31jaXBoZXIuZW5jcnlwdEJsb2NrKGtleXN0cmVhbSwwKTtmb3IodmFyIGk9MDtpPGJsb2NrU2l6ZTtpKyspe3dvcmRzW29mZnNldCtpXV49a2V5c3RyZWFtW2ldfX1yZXR1cm4gQ0ZCfSgpO3JldHVybiBDcnlwdG9KUy5tb2RlLkNGQn0pfSx7XCIuL2NpcGhlci1jb3JlXCI6MTksXCIuL2NvcmVcIjoyMH1dLDMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL2NpcGhlci1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vY2lwaGVyLWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpe0NyeXB0b0pTLm1vZGUuQ1RSR2xhZG1hbj1mdW5jdGlvbigpe3ZhciBDVFJHbGFkbWFuPUNyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7ZnVuY3Rpb24gaW5jV29yZCh3b3JkKXtpZigod29yZD4+MjQmMjU1KT09PTI1NSl7dmFyIGIxPXdvcmQ+PjE2JjI1NTt2YXIgYjI9d29yZD4+OCYyNTU7dmFyIGIzPXdvcmQmMjU1O2lmKGIxPT09MjU1KXtiMT0wO2lmKGIyPT09MjU1KXtiMj0wO2lmKGIzPT09MjU1KXtiMz0wfWVsc2V7KytiM319ZWxzZXsrK2IyfX1lbHNleysrYjF9d29yZD0wO3dvcmQrPWIxPDwxNjt3b3JkKz1iMjw8ODt3b3JkKz1iM31lbHNle3dvcmQrPTE8PDI0fXJldHVybiB3b3JkfWZ1bmN0aW9uIGluY0NvdW50ZXIoY291bnRlcil7aWYoKGNvdW50ZXJbMF09aW5jV29yZChjb3VudGVyWzBdKSk9PT0wKXtjb3VudGVyWzFdPWluY1dvcmQoY291bnRlclsxXSl9cmV0dXJuIGNvdW50ZXJ9dmFyIEVuY3J5cHRvcj1DVFJHbGFkbWFuLkVuY3J5cHRvcj1DVFJHbGFkbWFuLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHdvcmRzLG9mZnNldCl7dmFyIGNpcGhlcj10aGlzLl9jaXBoZXI7dmFyIGJsb2NrU2l6ZT1jaXBoZXIuYmxvY2tTaXplO3ZhciBpdj10aGlzLl9pdjt2YXIgY291bnRlcj10aGlzLl9jb3VudGVyO2lmKGl2KXtjb3VudGVyPXRoaXMuX2NvdW50ZXI9aXYuc2xpY2UoMCk7dGhpcy5faXY9dW5kZWZpbmVkfWluY0NvdW50ZXIoY291bnRlcik7dmFyIGtleXN0cmVhbT1jb3VudGVyLnNsaWNlKDApO2NpcGhlci5lbmNyeXB0QmxvY2soa2V5c3RyZWFtLDApO2Zvcih2YXIgaT0wO2k8YmxvY2tTaXplO2krKyl7d29yZHNbb2Zmc2V0K2ldXj1rZXlzdHJlYW1baV19fX0pO0NUUkdsYWRtYW4uRGVjcnlwdG9yPUVuY3J5cHRvcjtyZXR1cm4gQ1RSR2xhZG1hbn0oKTtyZXR1cm4gQ3J5cHRvSlMubW9kZS5DVFJHbGFkbWFufSl9LHtcIi4vY2lwaGVyLWNvcmVcIjoxOSxcIi4vY29yZVwiOjIwfV0sMzI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vY2lwaGVyLWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9jaXBoZXItY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7Q3J5cHRvSlMubW9kZS5DVFI9ZnVuY3Rpb24oKXt2YXIgQ1RSPUNyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7dmFyIEVuY3J5cHRvcj1DVFIuRW5jcnlwdG9yPUNUUi5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih3b3JkcyxvZmZzZXQpe3ZhciBjaXBoZXI9dGhpcy5fY2lwaGVyO3ZhciBibG9ja1NpemU9Y2lwaGVyLmJsb2NrU2l6ZTt2YXIgaXY9dGhpcy5faXY7dmFyIGNvdW50ZXI9dGhpcy5fY291bnRlcjtpZihpdil7Y291bnRlcj10aGlzLl9jb3VudGVyPWl2LnNsaWNlKDApO3RoaXMuX2l2PXVuZGVmaW5lZH12YXIga2V5c3RyZWFtPWNvdW50ZXIuc2xpY2UoMCk7Y2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sMCk7Y291bnRlcltibG9ja1NpemUtMV09Y291bnRlcltibG9ja1NpemUtMV0rMXwwO2Zvcih2YXIgaT0wO2k8YmxvY2tTaXplO2krKyl7d29yZHNbb2Zmc2V0K2ldXj1rZXlzdHJlYW1baV19fX0pO0NUUi5EZWNyeXB0b3I9RW5jcnlwdG9yO3JldHVybiBDVFJ9KCk7cmV0dXJuIENyeXB0b0pTLm1vZGUuQ1RSfSl9LHtcIi4vY2lwaGVyLWNvcmVcIjoxOSxcIi4vY29yZVwiOjIwfV0sMzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vY2lwaGVyLWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9jaXBoZXItY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7Q3J5cHRvSlMubW9kZS5FQ0I9ZnVuY3Rpb24oKXt2YXIgRUNCPUNyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7RUNCLkVuY3J5cHRvcj1FQ0IuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24od29yZHMsb2Zmc2V0KXt0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHdvcmRzLG9mZnNldCl9fSk7RUNCLkRlY3J5cHRvcj1FQ0IuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24od29yZHMsb2Zmc2V0KXt0aGlzLl9jaXBoZXIuZGVjcnlwdEJsb2NrKHdvcmRzLG9mZnNldCl9fSk7cmV0dXJuIEVDQn0oKTtyZXR1cm4gQ3J5cHRvSlMubW9kZS5FQ0J9KX0se1wiLi9jaXBoZXItY29yZVwiOjE5LFwiLi9jb3JlXCI6MjB9XSwzNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9jaXBoZXItY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL2NpcGhlci1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXtDcnlwdG9KUy5tb2RlLk9GQj1mdW5jdGlvbigpe3ZhciBPRkI9Q3J5cHRvSlMubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTt2YXIgRW5jcnlwdG9yPU9GQi5FbmNyeXB0b3I9T0ZCLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHdvcmRzLG9mZnNldCl7dmFyIGNpcGhlcj10aGlzLl9jaXBoZXI7dmFyIGJsb2NrU2l6ZT1jaXBoZXIuYmxvY2tTaXplO3ZhciBpdj10aGlzLl9pdjt2YXIga2V5c3RyZWFtPXRoaXMuX2tleXN0cmVhbTtpZihpdil7a2V5c3RyZWFtPXRoaXMuX2tleXN0cmVhbT1pdi5zbGljZSgwKTt0aGlzLl9pdj11bmRlZmluZWR9Y2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sMCk7Zm9yKHZhciBpPTA7aTxibG9ja1NpemU7aSsrKXt3b3Jkc1tvZmZzZXQraV1ePWtleXN0cmVhbVtpXX19fSk7T0ZCLkRlY3J5cHRvcj1FbmNyeXB0b3I7cmV0dXJuIE9GQn0oKTtyZXR1cm4gQ3J5cHRvSlMubW9kZS5PRkJ9KX0se1wiLi9jaXBoZXItY29yZVwiOjE5LFwiLi9jb3JlXCI6MjB9XSwzNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9jaXBoZXItY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL2NpcGhlci1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXtDcnlwdG9KUy5wYWQuQW5zaVg5MjM9e3BhZDpmdW5jdGlvbihkYXRhLGJsb2NrU2l6ZSl7dmFyIGRhdGFTaWdCeXRlcz1kYXRhLnNpZ0J5dGVzO3ZhciBibG9ja1NpemVCeXRlcz1ibG9ja1NpemUqNDt2YXIgblBhZGRpbmdCeXRlcz1ibG9ja1NpemVCeXRlcy1kYXRhU2lnQnl0ZXMlYmxvY2tTaXplQnl0ZXM7dmFyIGxhc3RCeXRlUG9zPWRhdGFTaWdCeXRlcytuUGFkZGluZ0J5dGVzLTE7ZGF0YS5jbGFtcCgpO2RhdGEud29yZHNbbGFzdEJ5dGVQb3M+Pj4yXXw9blBhZGRpbmdCeXRlczw8MjQtbGFzdEJ5dGVQb3MlNCo4O2RhdGEuc2lnQnl0ZXMrPW5QYWRkaW5nQnl0ZXN9LHVucGFkOmZ1bmN0aW9uKGRhdGEpe3ZhciBuUGFkZGluZ0J5dGVzPWRhdGEud29yZHNbZGF0YS5zaWdCeXRlcy0xPj4+Ml0mMjU1O2RhdGEuc2lnQnl0ZXMtPW5QYWRkaW5nQnl0ZXN9fTtyZXR1cm4gQ3J5cHRvSlMucGFkLkFuc2l4OTIzfSl9LHtcIi4vY2lwaGVyLWNvcmVcIjoxOSxcIi4vY29yZVwiOjIwfV0sMzY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vY2lwaGVyLWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9jaXBoZXItY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7Q3J5cHRvSlMucGFkLklzbzEwMTI2PXtwYWQ6ZnVuY3Rpb24oZGF0YSxibG9ja1NpemUpe3ZhciBibG9ja1NpemVCeXRlcz1ibG9ja1NpemUqNDt2YXIgblBhZGRpbmdCeXRlcz1ibG9ja1NpemVCeXRlcy1kYXRhLnNpZ0J5dGVzJWJsb2NrU2l6ZUJ5dGVzO2RhdGEuY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKG5QYWRkaW5nQnl0ZXMtMSkpLmNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbblBhZGRpbmdCeXRlczw8MjRdLDEpKX0sdW5wYWQ6ZnVuY3Rpb24oZGF0YSl7dmFyIG5QYWRkaW5nQnl0ZXM9ZGF0YS53b3Jkc1tkYXRhLnNpZ0J5dGVzLTE+Pj4yXSYyNTU7ZGF0YS5zaWdCeXRlcy09blBhZGRpbmdCeXRlc319O3JldHVybiBDcnlwdG9KUy5wYWQuSXNvMTAxMjZ9KX0se1wiLi9jaXBoZXItY29yZVwiOjE5LFwiLi9jb3JlXCI6MjB9XSwzNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9jaXBoZXItY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL2NpcGhlci1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXtDcnlwdG9KUy5wYWQuSXNvOTc5NzE9e3BhZDpmdW5jdGlvbihkYXRhLGJsb2NrU2l6ZSl7ZGF0YS5jb25jYXQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzIxNDc0ODM2NDhdLDEpKTtDcnlwdG9KUy5wYWQuWmVyb1BhZGRpbmcucGFkKGRhdGEsYmxvY2tTaXplKX0sdW5wYWQ6ZnVuY3Rpb24oZGF0YSl7Q3J5cHRvSlMucGFkLlplcm9QYWRkaW5nLnVucGFkKGRhdGEpO2RhdGEuc2lnQnl0ZXMtLX19O3JldHVybiBDcnlwdG9KUy5wYWQuSXNvOTc5NzF9KX0se1wiLi9jaXBoZXItY29yZVwiOjE5LFwiLi9jb3JlXCI6MjB9XSwzODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9jaXBoZXItY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL2NpcGhlci1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXtDcnlwdG9KUy5wYWQuTm9QYWRkaW5nPXtwYWQ6ZnVuY3Rpb24oKXt9LHVucGFkOmZ1bmN0aW9uKCl7fX07cmV0dXJuIENyeXB0b0pTLnBhZC5Ob1BhZGRpbmd9KX0se1wiLi9jaXBoZXItY29yZVwiOjE5LFwiLi9jb3JlXCI6MjB9XSwzOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9jaXBoZXItY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL2NpcGhlci1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXtDcnlwdG9KUy5wYWQuWmVyb1BhZGRpbmc9e3BhZDpmdW5jdGlvbihkYXRhLGJsb2NrU2l6ZSl7dmFyIGJsb2NrU2l6ZUJ5dGVzPWJsb2NrU2l6ZSo0O2RhdGEuY2xhbXAoKTtkYXRhLnNpZ0J5dGVzKz1ibG9ja1NpemVCeXRlcy0oZGF0YS5zaWdCeXRlcyVibG9ja1NpemVCeXRlc3x8YmxvY2tTaXplQnl0ZXMpfSx1bnBhZDpmdW5jdGlvbihkYXRhKXt2YXIgZGF0YVdvcmRzPWRhdGEud29yZHM7dmFyIGk9ZGF0YS5zaWdCeXRlcy0xO3doaWxlKCEoZGF0YVdvcmRzW2k+Pj4yXT4+PjI0LWklNCo4JjI1NSkpe2ktLX1kYXRhLnNpZ0J5dGVzPWkrMX19O3JldHVybiBDcnlwdG9KUy5wYWQuWmVyb1BhZGRpbmd9KX0se1wiLi9jaXBoZXItY29yZVwiOjE5LFwiLi9jb3JlXCI6MjB9XSw0MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9zaGExXCIpLF9kZXJlcV8oXCIuL2htYWNcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9zaGExXCIsXCIuL2htYWNcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbigpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgQmFzZT1DX2xpYi5CYXNlO3ZhciBXb3JkQXJyYXk9Q19saWIuV29yZEFycmF5O3ZhciBDX2FsZ289Qy5hbGdvO3ZhciBTSEExPUNfYWxnby5TSEExO3ZhciBITUFDPUNfYWxnby5ITUFDO3ZhciBQQktERjI9Q19hbGdvLlBCS0RGMj1CYXNlLmV4dGVuZCh7Y2ZnOkJhc2UuZXh0ZW5kKHtrZXlTaXplOjEyOC8zMixoYXNoZXI6U0hBMSxpdGVyYXRpb25zOjF9KSxpbml0OmZ1bmN0aW9uKGNmZyl7dGhpcy5jZmc9dGhpcy5jZmcuZXh0ZW5kKGNmZyl9LGNvbXB1dGU6ZnVuY3Rpb24ocGFzc3dvcmQsc2FsdCl7dmFyIGNmZz10aGlzLmNmZzt2YXIgaG1hYz1ITUFDLmNyZWF0ZShjZmcuaGFzaGVyLHBhc3N3b3JkKTt2YXIgZGVyaXZlZEtleT1Xb3JkQXJyYXkuY3JlYXRlKCk7dmFyIGJsb2NrSW5kZXg9V29yZEFycmF5LmNyZWF0ZShbMV0pO3ZhciBkZXJpdmVkS2V5V29yZHM9ZGVyaXZlZEtleS53b3Jkczt2YXIgYmxvY2tJbmRleFdvcmRzPWJsb2NrSW5kZXgud29yZHM7dmFyIGtleVNpemU9Y2ZnLmtleVNpemU7dmFyIGl0ZXJhdGlvbnM9Y2ZnLml0ZXJhdGlvbnM7d2hpbGUoZGVyaXZlZEtleVdvcmRzLmxlbmd0aDxrZXlTaXplKXt2YXIgYmxvY2s9aG1hYy51cGRhdGUoc2FsdCkuZmluYWxpemUoYmxvY2tJbmRleCk7aG1hYy5yZXNldCgpO3ZhciBibG9ja1dvcmRzPWJsb2NrLndvcmRzO3ZhciBibG9ja1dvcmRzTGVuZ3RoPWJsb2NrV29yZHMubGVuZ3RoO3ZhciBpbnRlcm1lZGlhdGU9YmxvY2s7Zm9yKHZhciBpPTE7aTxpdGVyYXRpb25zO2krKyl7aW50ZXJtZWRpYXRlPWhtYWMuZmluYWxpemUoaW50ZXJtZWRpYXRlKTtobWFjLnJlc2V0KCk7dmFyIGludGVybWVkaWF0ZVdvcmRzPWludGVybWVkaWF0ZS53b3Jkcztmb3IodmFyIGo9MDtqPGJsb2NrV29yZHNMZW5ndGg7aisrKXtibG9ja1dvcmRzW2pdXj1pbnRlcm1lZGlhdGVXb3Jkc1tqXX19ZGVyaXZlZEtleS5jb25jYXQoYmxvY2spO2Jsb2NrSW5kZXhXb3Jkc1swXSsrfWRlcml2ZWRLZXkuc2lnQnl0ZXM9a2V5U2l6ZSo0O3JldHVybiBkZXJpdmVkS2V5fX0pO0MuUEJLREYyPWZ1bmN0aW9uKHBhc3N3b3JkLHNhbHQsY2ZnKXtyZXR1cm4gUEJLREYyLmNyZWF0ZShjZmcpLmNvbXB1dGUocGFzc3dvcmQsc2FsdCl9fSkoKTtyZXR1cm4gQ3J5cHRvSlMuUEJLREYyfSl9LHtcIi4vY29yZVwiOjIwLFwiLi9obWFjXCI6MjYsXCIuL3NoYTFcIjo0NX1dLDQxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL2VuYy1iYXNlNjRcIiksX2RlcmVxXyhcIi4vbWQ1XCIpLF9kZXJlcV8oXCIuL2V2cGtkZlwiKSxfZGVyZXFfKFwiLi9jaXBoZXItY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL2VuYy1iYXNlNjRcIixcIi4vbWQ1XCIsXCIuL2V2cGtkZlwiLFwiLi9jaXBoZXItY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBTdHJlYW1DaXBoZXI9Q19saWIuU3RyZWFtQ2lwaGVyO3ZhciBDX2FsZ289Qy5hbGdvO3ZhciBTPVtdO3ZhciBDXz1bXTt2YXIgRz1bXTt2YXIgUmFiYml0TGVnYWN5PUNfYWxnby5SYWJiaXRMZWdhY3k9U3RyZWFtQ2lwaGVyLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt2YXIgSz10aGlzLl9rZXkud29yZHM7dmFyIGl2PXRoaXMuY2ZnLml2O3ZhciBYPXRoaXMuX1g9W0tbMF0sS1szXTw8MTZ8S1syXT4+PjE2LEtbMV0sS1swXTw8MTZ8S1szXT4+PjE2LEtbMl0sS1sxXTw8MTZ8S1swXT4+PjE2LEtbM10sS1syXTw8MTZ8S1sxXT4+PjE2XTt2YXIgQz10aGlzLl9DPVtLWzJdPDwxNnxLWzJdPj4+MTYsS1swXSY0Mjk0OTAxNzYwfEtbMV0mNjU1MzUsS1szXTw8MTZ8S1szXT4+PjE2LEtbMV0mNDI5NDkwMTc2MHxLWzJdJjY1NTM1LEtbMF08PDE2fEtbMF0+Pj4xNixLWzJdJjQyOTQ5MDE3NjB8S1szXSY2NTUzNSxLWzFdPDwxNnxLWzFdPj4+MTYsS1szXSY0Mjk0OTAxNzYwfEtbMF0mNjU1MzVdO3RoaXMuX2I9MDtmb3IodmFyIGk9MDtpPDQ7aSsrKXtuZXh0U3RhdGUuY2FsbCh0aGlzKX1mb3IodmFyIGk9MDtpPDg7aSsrKXtDW2ldXj1YW2krNCY3XX1pZihpdil7dmFyIElWPWl2LndvcmRzO3ZhciBJVl8wPUlWWzBdO3ZhciBJVl8xPUlWWzFdO3ZhciBpMD0oSVZfMDw8OHxJVl8wPj4+MjQpJjE2NzExOTM1fChJVl8wPDwyNHxJVl8wPj4+OCkmNDI3ODI1NTM2MDt2YXIgaTI9KElWXzE8PDh8SVZfMT4+PjI0KSYxNjcxMTkzNXwoSVZfMTw8MjR8SVZfMT4+PjgpJjQyNzgyNTUzNjA7dmFyIGkxPWkwPj4+MTZ8aTImNDI5NDkwMTc2MDt2YXIgaTM9aTI8PDE2fGkwJjY1NTM1O0NbMF1ePWkwO0NbMV1ePWkxO0NbMl1ePWkyO0NbM11ePWkzO0NbNF1ePWkwO0NbNV1ePWkxO0NbNl1ePWkyO0NbN11ePWkzO2Zvcih2YXIgaT0wO2k8NDtpKyspe25leHRTdGF0ZS5jYWxsKHRoaXMpfX19LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihNLG9mZnNldCl7dmFyIFg9dGhpcy5fWDtuZXh0U3RhdGUuY2FsbCh0aGlzKTtTWzBdPVhbMF1eWFs1XT4+PjE2XlhbM108PDE2O1NbMV09WFsyXV5YWzddPj4+MTZeWFs1XTw8MTY7U1syXT1YWzRdXlhbMV0+Pj4xNl5YWzddPDwxNjtTWzNdPVhbNl1eWFszXT4+PjE2XlhbMV08PDE2O2Zvcih2YXIgaT0wO2k8NDtpKyspe1NbaV09KFNbaV08PDh8U1tpXT4+PjI0KSYxNjcxMTkzNXwoU1tpXTw8MjR8U1tpXT4+PjgpJjQyNzgyNTUzNjA7TVtvZmZzZXQraV1ePVNbaV19fSxibG9ja1NpemU6MTI4LzMyLGl2U2l6ZTo2NC8zMn0pO1xuZnVuY3Rpb24gbmV4dFN0YXRlKCl7dmFyIFg9dGhpcy5fWDt2YXIgQz10aGlzLl9DO2Zvcih2YXIgaT0wO2k8ODtpKyspe0NfW2ldPUNbaV19Q1swXT1DWzBdKzEyOTUzMDc1OTcrdGhpcy5fYnwwO0NbMV09Q1sxXSszNTQ1MDUyMzcxKyhDWzBdPj4+MDxDX1swXT4+PjA/MTowKXwwO0NbMl09Q1syXSs4ODYyNjMwOTIrKENbMV0+Pj4wPENfWzFdPj4+MD8xOjApfDA7Q1szXT1DWzNdKzEyOTUzMDc1OTcrKENbMl0+Pj4wPENfWzJdPj4+MD8xOjApfDA7Q1s0XT1DWzRdKzM1NDUwNTIzNzErKENbM10+Pj4wPENfWzNdPj4+MD8xOjApfDA7Q1s1XT1DWzVdKzg4NjI2MzA5MisoQ1s0XT4+PjA8Q19bNF0+Pj4wPzE6MCl8MDtDWzZdPUNbNl0rMTI5NTMwNzU5NysoQ1s1XT4+PjA8Q19bNV0+Pj4wPzE6MCl8MDtDWzddPUNbN10rMzU0NTA1MjM3MSsoQ1s2XT4+PjA8Q19bNl0+Pj4wPzE6MCl8MDt0aGlzLl9iPUNbN10+Pj4wPENfWzddPj4+MD8xOjA7Zm9yKHZhciBpPTA7aTw4O2krKyl7dmFyIGd4PVhbaV0rQ1tpXTt2YXIgZ2E9Z3gmNjU1MzU7dmFyIGdiPWd4Pj4+MTY7dmFyIGdoPSgoZ2EqZ2E+Pj4xNykrZ2EqZ2I+Pj4xNSkrZ2IqZ2I7dmFyIGdsPSgoZ3gmNDI5NDkwMTc2MCkqZ3h8MCkrKChneCY2NTUzNSkqZ3h8MCk7R1tpXT1naF5nbH1YWzBdPUdbMF0rKEdbN108PDE2fEdbN10+Pj4xNikrKEdbNl08PDE2fEdbNl0+Pj4xNil8MDtYWzFdPUdbMV0rKEdbMF08PDh8R1swXT4+PjI0KStHWzddfDA7WFsyXT1HWzJdKyhHWzFdPDwxNnxHWzFdPj4+MTYpKyhHWzBdPDwxNnxHWzBdPj4+MTYpfDA7WFszXT1HWzNdKyhHWzJdPDw4fEdbMl0+Pj4yNCkrR1sxXXwwO1hbNF09R1s0XSsoR1szXTw8MTZ8R1szXT4+PjE2KSsoR1syXTw8MTZ8R1syXT4+PjE2KXwwO1hbNV09R1s1XSsoR1s0XTw8OHxHWzRdPj4+MjQpK0dbM118MDtYWzZdPUdbNl0rKEdbNV08PDE2fEdbNV0+Pj4xNikrKEdbNF08PDE2fEdbNF0+Pj4xNil8MDtYWzddPUdbN10rKEdbNl08PDh8R1s2XT4+PjI0KStHWzVdfDB9Qy5SYWJiaXRMZWdhY3k9U3RyZWFtQ2lwaGVyLl9jcmVhdGVIZWxwZXIoUmFiYml0TGVnYWN5KX0pKCk7cmV0dXJuIENyeXB0b0pTLlJhYmJpdExlZ2FjeX0pfSx7XCIuL2NpcGhlci1jb3JlXCI6MTksXCIuL2NvcmVcIjoyMCxcIi4vZW5jLWJhc2U2NFwiOjIxLFwiLi9ldnBrZGZcIjoyMyxcIi4vbWQ1XCI6Mjl9XSw0MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9lbmMtYmFzZTY0XCIpLF9kZXJlcV8oXCIuL21kNVwiKSxfZGVyZXFfKFwiLi9ldnBrZGZcIiksX2RlcmVxXyhcIi4vY2lwaGVyLWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9lbmMtYmFzZTY0XCIsXCIuL21kNVwiLFwiLi9ldnBrZGZcIixcIi4vY2lwaGVyLWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbigpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgU3RyZWFtQ2lwaGVyPUNfbGliLlN0cmVhbUNpcGhlcjt2YXIgQ19hbGdvPUMuYWxnbzt2YXIgUz1bXTt2YXIgQ189W107dmFyIEc9W107dmFyIFJhYmJpdD1DX2FsZ28uUmFiYml0PVN0cmVhbUNpcGhlci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dmFyIEs9dGhpcy5fa2V5LndvcmRzO3ZhciBpdj10aGlzLmNmZy5pdjtmb3IodmFyIGk9MDtpPDQ7aSsrKXtLW2ldPShLW2ldPDw4fEtbaV0+Pj4yNCkmMTY3MTE5MzV8KEtbaV08PDI0fEtbaV0+Pj44KSY0Mjc4MjU1MzYwfXZhciBYPXRoaXMuX1g9W0tbMF0sS1szXTw8MTZ8S1syXT4+PjE2LEtbMV0sS1swXTw8MTZ8S1szXT4+PjE2LEtbMl0sS1sxXTw8MTZ8S1swXT4+PjE2LEtbM10sS1syXTw8MTZ8S1sxXT4+PjE2XTt2YXIgQz10aGlzLl9DPVtLWzJdPDwxNnxLWzJdPj4+MTYsS1swXSY0Mjk0OTAxNzYwfEtbMV0mNjU1MzUsS1szXTw8MTZ8S1szXT4+PjE2LEtbMV0mNDI5NDkwMTc2MHxLWzJdJjY1NTM1LEtbMF08PDE2fEtbMF0+Pj4xNixLWzJdJjQyOTQ5MDE3NjB8S1szXSY2NTUzNSxLWzFdPDwxNnxLWzFdPj4+MTYsS1szXSY0Mjk0OTAxNzYwfEtbMF0mNjU1MzVdO3RoaXMuX2I9MDtmb3IodmFyIGk9MDtpPDQ7aSsrKXtuZXh0U3RhdGUuY2FsbCh0aGlzKX1mb3IodmFyIGk9MDtpPDg7aSsrKXtDW2ldXj1YW2krNCY3XX1pZihpdil7dmFyIElWPWl2LndvcmRzO3ZhciBJVl8wPUlWWzBdO3ZhciBJVl8xPUlWWzFdO3ZhciBpMD0oSVZfMDw8OHxJVl8wPj4+MjQpJjE2NzExOTM1fChJVl8wPDwyNHxJVl8wPj4+OCkmNDI3ODI1NTM2MDt2YXIgaTI9KElWXzE8PDh8SVZfMT4+PjI0KSYxNjcxMTkzNXwoSVZfMTw8MjR8SVZfMT4+PjgpJjQyNzgyNTUzNjA7dmFyIGkxPWkwPj4+MTZ8aTImNDI5NDkwMTc2MDt2YXIgaTM9aTI8PDE2fGkwJjY1NTM1O0NbMF1ePWkwO0NbMV1ePWkxO0NbMl1ePWkyO0NbM11ePWkzO0NbNF1ePWkwO0NbNV1ePWkxO0NbNl1ePWkyO0NbN11ePWkzO2Zvcih2YXIgaT0wO2k8NDtpKyspe25leHRTdGF0ZS5jYWxsKHRoaXMpfX19LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihNLG9mZnNldCl7dmFyIFg9dGhpcy5fWDtuZXh0U3RhdGUuY2FsbCh0aGlzKTtTWzBdPVhbMF1eWFs1XT4+PjE2XlhbM108PDE2O1NbMV09WFsyXV5YWzddPj4+MTZeWFs1XTw8MTY7U1syXT1YWzRdXlhbMV0+Pj4xNl5YWzddPDwxNjtTWzNdPVhbNl1eWFszXT4+PjE2XlhbMV08PDE2O2Zvcih2YXIgaT0wO2k8NDtpKyspe1NbaV09KFNbaV08PDh8U1tpXT4+PjI0KSYxNjcxMTkzNXwoU1tpXTw8MjR8U1tpXT4+PjgpJjQyNzgyNTUzNjA7TVtvZmZzZXQraV1ePVNbaV19fSxibG9ja1NpemU6MTI4LzMyLGl2U2l6ZTo2NC8zMn0pO2Z1bmN0aW9uIG5leHRTdGF0ZSgpe3ZhciBYPXRoaXMuX1g7dmFyIEM9dGhpcy5fQztmb3IodmFyIGk9MDtpPDg7aSsrKXtDX1tpXT1DW2ldfUNbMF09Q1swXSsxMjk1MzA3NTk3K3RoaXMuX2J8MDtDWzFdPUNbMV0rMzU0NTA1MjM3MSsoQ1swXT4+PjA8Q19bMF0+Pj4wPzE6MCl8MDtDWzJdPUNbMl0rODg2MjYzMDkyKyhDWzFdPj4+MDxDX1sxXT4+PjA/MTowKXwwO0NbM109Q1szXSsxMjk1MzA3NTk3KyhDWzJdPj4+MDxDX1syXT4+PjA/MTowKXwwO0NbNF09Q1s0XSszNTQ1MDUyMzcxKyhDWzNdPj4+MDxDX1szXT4+PjA/MTowKXwwO0NbNV09Q1s1XSs4ODYyNjMwOTIrKENbNF0+Pj4wPENfWzRdPj4+MD8xOjApfDA7Q1s2XT1DWzZdKzEyOTUzMDc1OTcrKENbNV0+Pj4wPENfWzVdPj4+MD8xOjApfDA7Q1s3XT1DWzddKzM1NDUwNTIzNzErKENbNl0+Pj4wPENfWzZdPj4+MD8xOjApfDA7dGhpcy5fYj1DWzddPj4+MDxDX1s3XT4+PjA/MTowO2Zvcih2YXIgaT0wO2k8ODtpKyspe3ZhciBneD1YW2ldK0NbaV07dmFyIGdhPWd4JjY1NTM1O3ZhciBnYj1neD4+PjE2O3ZhciBnaD0oKGdhKmdhPj4+MTcpK2dhKmdiPj4+MTUpK2diKmdiO3ZhciBnbD0oKGd4JjQyOTQ5MDE3NjApKmd4fDApKygoZ3gmNjU1MzUpKmd4fDApO0dbaV09Z2heZ2x9WFswXT1HWzBdKyhHWzddPDwxNnxHWzddPj4+MTYpKyhHWzZdPDwxNnxHWzZdPj4+MTYpfDA7WFsxXT1HWzFdKyhHWzBdPDw4fEdbMF0+Pj4yNCkrR1s3XXwwO1hbMl09R1syXSsoR1sxXTw8MTZ8R1sxXT4+PjE2KSsoR1swXTw8MTZ8R1swXT4+PjE2KXwwO1hbM109R1szXSsoR1syXTw8OHxHWzJdPj4+MjQpK0dbMV18MDtYWzRdPUdbNF0rKEdbM108PDE2fEdbM10+Pj4xNikrKEdbMl08PDE2fEdbMl0+Pj4xNil8MDtYWzVdPUdbNV0rKEdbNF08PDh8R1s0XT4+PjI0KStHWzNdfDA7WFs2XT1HWzZdKyhHWzVdPDwxNnxHWzVdPj4+MTYpKyhHWzRdPDwxNnxHWzRdPj4+MTYpfDA7WFs3XT1HWzddKyhHWzZdPDw4fEdbNl0+Pj4yNCkrR1s1XXwwfUMuUmFiYml0PVN0cmVhbUNpcGhlci5fY3JlYXRlSGVscGVyKFJhYmJpdCl9KSgpO3JldHVybiBDcnlwdG9KUy5SYWJiaXR9KX0se1wiLi9jaXBoZXItY29yZVwiOjE5LFwiLi9jb3JlXCI6MjAsXCIuL2VuYy1iYXNlNjRcIjoyMSxcIi4vZXZwa2RmXCI6MjMsXCIuL21kNVwiOjI5fV0sNDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vZW5jLWJhc2U2NFwiKSxfZGVyZXFfKFwiLi9tZDVcIiksX2RlcmVxXyhcIi4vZXZwa2RmXCIpLF9kZXJlcV8oXCIuL2NpcGhlci1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vZW5jLWJhc2U2NFwiLFwiLi9tZDVcIixcIi4vZXZwa2RmXCIsXCIuL2NpcGhlci1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIFN0cmVhbUNpcGhlcj1DX2xpYi5TdHJlYW1DaXBoZXI7dmFyIENfYWxnbz1DLmFsZ287dmFyIFJDND1DX2FsZ28uUkM0PVN0cmVhbUNpcGhlci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dmFyIGtleT10aGlzLl9rZXk7dmFyIGtleVdvcmRzPWtleS53b3Jkczt2YXIga2V5U2lnQnl0ZXM9a2V5LnNpZ0J5dGVzO3ZhciBTPXRoaXMuX1M9W107Zm9yKHZhciBpPTA7aTwyNTY7aSsrKXtTW2ldPWl9Zm9yKHZhciBpPTAsaj0wO2k8MjU2O2krKyl7dmFyIGtleUJ5dGVJbmRleD1pJWtleVNpZ0J5dGVzO3ZhciBrZXlCeXRlPWtleVdvcmRzW2tleUJ5dGVJbmRleD4+PjJdPj4+MjQta2V5Qnl0ZUluZGV4JTQqOCYyNTU7aj0oaitTW2ldK2tleUJ5dGUpJTI1Njt2YXIgdD1TW2ldO1NbaV09U1tqXTtTW2pdPXR9dGhpcy5faT10aGlzLl9qPTB9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihNLG9mZnNldCl7TVtvZmZzZXRdXj1nZW5lcmF0ZUtleXN0cmVhbVdvcmQuY2FsbCh0aGlzKX0sa2V5U2l6ZToyNTYvMzIsaXZTaXplOjB9KTtmdW5jdGlvbiBnZW5lcmF0ZUtleXN0cmVhbVdvcmQoKXt2YXIgUz10aGlzLl9TO3ZhciBpPXRoaXMuX2k7dmFyIGo9dGhpcy5fajt2YXIga2V5c3RyZWFtV29yZD0wO2Zvcih2YXIgbj0wO248NDtuKyspe2k9KGkrMSklMjU2O2o9KGorU1tpXSklMjU2O3ZhciB0PVNbaV07U1tpXT1TW2pdO1Nbal09dDtrZXlzdHJlYW1Xb3JkfD1TWyhTW2ldK1Nbal0pJTI1Nl08PDI0LW4qOH10aGlzLl9pPWk7dGhpcy5faj1qO3JldHVybiBrZXlzdHJlYW1Xb3JkfUMuUkM0PVN0cmVhbUNpcGhlci5fY3JlYXRlSGVscGVyKFJDNCk7dmFyIFJDNERyb3A9Q19hbGdvLlJDNERyb3A9UkM0LmV4dGVuZCh7Y2ZnOlJDNC5jZmcuZXh0ZW5kKHtkcm9wOjE5Mn0pLF9kb1Jlc2V0OmZ1bmN0aW9uKCl7UkM0Ll9kb1Jlc2V0LmNhbGwodGhpcyk7Zm9yKHZhciBpPXRoaXMuY2ZnLmRyb3A7aT4wO2ktLSl7Z2VuZXJhdGVLZXlzdHJlYW1Xb3JkLmNhbGwodGhpcyl9fX0pO0MuUkM0RHJvcD1TdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSQzREcm9wKX0pKCk7cmV0dXJuIENyeXB0b0pTLlJDNH0pfSx7XCIuL2NpcGhlci1jb3JlXCI6MTksXCIuL2NvcmVcIjoyMCxcIi4vZW5jLWJhc2U2NFwiOjIxLFwiLi9ldnBrZGZcIjoyMyxcIi4vbWQ1XCI6Mjl9XSw0NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSl7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oTWF0aCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBXb3JkQXJyYXk9Q19saWIuV29yZEFycmF5O3ZhciBIYXNoZXI9Q19saWIuSGFzaGVyO3ZhciBDX2FsZ289Qy5hbGdvO3ZhciBfemw9V29yZEFycmF5LmNyZWF0ZShbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSw3LDQsMTMsMSwxMCw2LDE1LDMsMTIsMCw5LDUsMiwxNCwxMSw4LDMsMTAsMTQsNCw5LDE1LDgsMSwyLDcsMCw2LDEzLDExLDUsMTIsMSw5LDExLDEwLDAsOCwxMiw0LDEzLDMsNywxNSwxNCw1LDYsMiw0LDAsNSw5LDcsMTIsMiwxMCwxNCwxLDMsOCwxMSw2LDE1LDEzXSk7dmFyIF96cj1Xb3JkQXJyYXkuY3JlYXRlKFs1LDE0LDcsMCw5LDIsMTEsNCwxMyw2LDE1LDgsMSwxMCwzLDEyLDYsMTEsMyw3LDAsMTMsNSwxMCwxNCwxNSw4LDEyLDQsOSwxLDIsMTUsNSwxLDMsNywxNCw2LDksMTEsOCwxMiwyLDEwLDAsNCwxMyw4LDYsNCwxLDMsMTEsMTUsMCw1LDEyLDIsMTMsOSw3LDEwLDE0LDEyLDE1LDEwLDQsMSw1LDgsNyw2LDIsMTMsMTQsMCwzLDksMTFdKTt2YXIgX3NsPVdvcmRBcnJheS5jcmVhdGUoWzExLDE0LDE1LDEyLDUsOCw3LDksMTEsMTMsMTQsMTUsNiw3LDksOCw3LDYsOCwxMywxMSw5LDcsMTUsNywxMiwxNSw5LDExLDcsMTMsMTIsMTEsMTMsNiw3LDE0LDksMTMsMTUsMTQsOCwxMyw2LDUsMTIsNyw1LDExLDEyLDE0LDE1LDE0LDE1LDksOCw5LDE0LDUsNiw4LDYsNSwxMiw5LDE1LDUsMTEsNiw4LDEzLDEyLDUsMTIsMTMsMTQsMTEsOCw1LDZdKTt2YXIgX3NyPVdvcmRBcnJheS5jcmVhdGUoWzgsOSw5LDExLDEzLDE1LDE1LDUsNyw3LDgsMTEsMTQsMTQsMTIsNiw5LDEzLDE1LDcsMTIsOCw5LDExLDcsNywxMiw3LDYsMTUsMTMsMTEsOSw3LDE1LDExLDgsNiw2LDE0LDEyLDEzLDUsMTQsMTMsMTMsNyw1LDE1LDUsOCwxMSwxNCwxNCw2LDE0LDYsOSwxMiw5LDEyLDUsMTUsOCw4LDUsMTIsOSwxMiw1LDE0LDYsOCwxMyw2LDUsMTUsMTMsMTEsMTFdKTt2YXIgX2hsPVdvcmRBcnJheS5jcmVhdGUoWzAsMTUxODUwMDI0OSwxODU5Nzc1MzkzLDI0MDA5NTk3MDgsMjg0MDg1MzgzOF0pO3ZhciBfaHI9V29yZEFycmF5LmNyZWF0ZShbMTM1MjgyOTkyNiwxNTQ4NjAzNjg0LDE4MzYwNzI2OTEsMjA1Mzk5NDIxNywwXSk7dmFyIFJJUEVNRDE2MD1DX2FsZ28uUklQRU1EMTYwPUhhc2hlci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1Xb3JkQXJyYXkuY3JlYXRlKFsxNzMyNTg0MTkzLDQwMjMyMzM0MTcsMjU2MjM4MzEwMiwyNzE3MzM4NzgsMzI4NTM3NzUyMF0pfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24oTSxvZmZzZXQpe2Zvcih2YXIgaT0wO2k8MTY7aSsrKXt2YXIgb2Zmc2V0X2k9b2Zmc2V0K2k7dmFyIE1fb2Zmc2V0X2k9TVtvZmZzZXRfaV07TVtvZmZzZXRfaV09KE1fb2Zmc2V0X2k8PDh8TV9vZmZzZXRfaT4+PjI0KSYxNjcxMTkzNXwoTV9vZmZzZXRfaTw8MjR8TV9vZmZzZXRfaT4+PjgpJjQyNzgyNTUzNjB9dmFyIEg9dGhpcy5faGFzaC53b3Jkczt2YXIgaGw9X2hsLndvcmRzO3ZhciBocj1faHIud29yZHM7dmFyIHpsPV96bC53b3Jkczt2YXIgenI9X3pyLndvcmRzO3ZhciBzbD1fc2wud29yZHM7dmFyIHNyPV9zci53b3Jkczt2YXIgYWwsYmwsY2wsZGwsZWw7dmFyIGFyLGJyLGNyLGRyLGVyO2FyPWFsPUhbMF07YnI9Ymw9SFsxXTtjcj1jbD1IWzJdO2RyPWRsPUhbM107ZXI9ZWw9SFs0XTt2YXIgdDtmb3IodmFyIGk9MDtpPDgwO2krPTEpe3Q9YWwrTVtvZmZzZXQremxbaV1dfDA7aWYoaTwxNil7dCs9ZjEoYmwsY2wsZGwpK2hsWzBdfWVsc2UgaWYoaTwzMil7dCs9ZjIoYmwsY2wsZGwpK2hsWzFdfWVsc2UgaWYoaTw0OCl7dCs9ZjMoYmwsY2wsZGwpK2hsWzJdfWVsc2UgaWYoaTw2NCl7dCs9ZjQoYmwsY2wsZGwpK2hsWzNdfWVsc2V7dCs9ZjUoYmwsY2wsZGwpK2hsWzRdfXQ9dHwwO3Q9cm90bCh0LHNsW2ldKTt0PXQrZWx8MDthbD1lbDtlbD1kbDtkbD1yb3RsKGNsLDEwKTtjbD1ibDtibD10O3Q9YXIrTVtvZmZzZXQrenJbaV1dfDA7aWYoaTwxNil7dCs9ZjUoYnIsY3IsZHIpK2hyWzBdfWVsc2UgaWYoaTwzMil7dCs9ZjQoYnIsY3IsZHIpK2hyWzFdfWVsc2UgaWYoaTw0OCl7dCs9ZjMoYnIsY3IsZHIpK2hyWzJdfWVsc2UgaWYoaTw2NCl7dCs9ZjIoYnIsY3IsZHIpK2hyWzNdfWVsc2V7dCs9ZjEoYnIsY3IsZHIpK2hyWzRdfXQ9dHwwO3Q9cm90bCh0LHNyW2ldKTt0PXQrZXJ8MDthcj1lcjtlcj1kcjtkcj1yb3RsKGNyLDEwKTtjcj1icjticj10fXQ9SFsxXStjbCtkcnwwO0hbMV09SFsyXStkbCtlcnwwO0hbMl09SFszXStlbCthcnwwO0hbM109SFs0XSthbCticnwwO0hbNF09SFswXStibCtjcnwwO0hbMF09dH0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgZGF0YT10aGlzLl9kYXRhO3ZhciBkYXRhV29yZHM9ZGF0YS53b3Jkczt2YXIgbkJpdHNUb3RhbD10aGlzLl9uRGF0YUJ5dGVzKjg7dmFyIG5CaXRzTGVmdD1kYXRhLnNpZ0J5dGVzKjg7ZGF0YVdvcmRzW25CaXRzTGVmdD4+PjVdfD0xMjg8PDI0LW5CaXRzTGVmdCUzMjtkYXRhV29yZHNbKG5CaXRzTGVmdCs2ND4+Pjk8PDQpKzE0XT0obkJpdHNUb3RhbDw8OHxuQml0c1RvdGFsPj4+MjQpJjE2NzExOTM1fChuQml0c1RvdGFsPDwyNHxuQml0c1RvdGFsPj4+OCkmNDI3ODI1NTM2MDtkYXRhLnNpZ0J5dGVzPShkYXRhV29yZHMubGVuZ3RoKzEpKjQ7dGhpcy5fcHJvY2VzcygpO3ZhciBoYXNoPXRoaXMuX2hhc2g7dmFyIEg9aGFzaC53b3Jkcztmb3IodmFyIGk9MDtpPDU7aSsrKXt2YXIgSF9pPUhbaV07SFtpXT0oSF9pPDw4fEhfaT4+PjI0KSYxNjcxMTkzNXwoSF9pPDwyNHxIX2k+Pj44KSY0Mjc4MjU1MzYwfXJldHVybiBoYXNofSxjbG9uZTpmdW5jdGlvbigpe3ZhciBjbG9uZT1IYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtjbG9uZS5faGFzaD10aGlzLl9oYXNoLmNsb25lKCk7cmV0dXJuIGNsb25lfX0pO2Z1bmN0aW9uIGYxKHgseSx6KXtyZXR1cm4geF55Xnp9ZnVuY3Rpb24gZjIoeCx5LHope3JldHVybiB4Jnl8fngmen1mdW5jdGlvbiBmMyh4LHkseil7cmV0dXJuKHh8fnkpXnp9ZnVuY3Rpb24gZjQoeCx5LHope3JldHVybiB4Jnp8eSZ+en1mdW5jdGlvbiBmNSh4LHkseil7cmV0dXJuIHheKHl8fnopfWZ1bmN0aW9uIHJvdGwoeCxuKXtyZXR1cm4geDw8bnx4Pj4+MzItbn1DLlJJUEVNRDE2MD1IYXNoZXIuX2NyZWF0ZUhlbHBlcihSSVBFTUQxNjApO0MuSG1hY1JJUEVNRDE2MD1IYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoUklQRU1EMTYwKX0pKE1hdGgpO3JldHVybiBDcnlwdG9KUy5SSVBFTUQxNjB9KX0se1wiLi9jb3JlXCI6MjB9XSw0NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSl7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIFdvcmRBcnJheT1DX2xpYi5Xb3JkQXJyYXk7dmFyIEhhc2hlcj1DX2xpYi5IYXNoZXI7dmFyIENfYWxnbz1DLmFsZ287dmFyIFc9W107dmFyIFNIQTE9Q19hbGdvLlNIQTE9SGFzaGVyLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyBXb3JkQXJyYXkuaW5pdChbMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4LDMyODUzNzc1MjBdKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKE0sb2Zmc2V0KXt2YXIgSD10aGlzLl9oYXNoLndvcmRzO3ZhciBhPUhbMF07dmFyIGI9SFsxXTt2YXIgYz1IWzJdO3ZhciBkPUhbM107dmFyIGU9SFs0XTtmb3IodmFyIGk9MDtpPDgwO2krKyl7aWYoaTwxNil7V1tpXT1NW29mZnNldCtpXXwwfWVsc2V7dmFyIG49V1tpLTNdXldbaS04XV5XW2ktMTRdXldbaS0xNl07V1tpXT1uPDwxfG4+Pj4zMX12YXIgdD0oYTw8NXxhPj4+MjcpK2UrV1tpXTtpZihpPDIwKXt0Kz0oYiZjfH5iJmQpKzE1MTg1MDAyNDl9ZWxzZSBpZihpPDQwKXt0Kz0oYl5jXmQpKzE4NTk3NzUzOTN9ZWxzZSBpZihpPDYwKXt0Kz0oYiZjfGImZHxjJmQpLTE4OTQwMDc1ODh9ZWxzZXt0Kz0oYl5jXmQpLTg5OTQ5NzUxNH1lPWQ7ZD1jO2M9Yjw8MzB8Yj4+PjI7Yj1hO2E9dH1IWzBdPUhbMF0rYXwwO0hbMV09SFsxXStifDA7SFsyXT1IWzJdK2N8MDtIWzNdPUhbM10rZHwwO0hbNF09SFs0XStlfDB9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGRhdGE9dGhpcy5fZGF0YTt2YXIgZGF0YVdvcmRzPWRhdGEud29yZHM7dmFyIG5CaXRzVG90YWw9dGhpcy5fbkRhdGFCeXRlcyo4O3ZhciBuQml0c0xlZnQ9ZGF0YS5zaWdCeXRlcyo4O2RhdGFXb3Jkc1tuQml0c0xlZnQ+Pj41XXw9MTI4PDwyNC1uQml0c0xlZnQlMzI7ZGF0YVdvcmRzWyhuQml0c0xlZnQrNjQ+Pj45PDw0KSsxNF09TWF0aC5mbG9vcihuQml0c1RvdGFsLzQyOTQ5NjcyOTYpO2RhdGFXb3Jkc1sobkJpdHNMZWZ0KzY0Pj4+OTw8NCkrMTVdPW5CaXRzVG90YWw7ZGF0YS5zaWdCeXRlcz1kYXRhV29yZHMubGVuZ3RoKjQ7dGhpcy5fcHJvY2VzcygpO3JldHVybiB0aGlzLl9oYXNofSxjbG9uZTpmdW5jdGlvbigpe3ZhciBjbG9uZT1IYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtjbG9uZS5faGFzaD10aGlzLl9oYXNoLmNsb25lKCk7cmV0dXJuIGNsb25lfX0pO0MuU0hBMT1IYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEExKTtDLkhtYWNTSEExPUhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEExKX0pKCk7cmV0dXJuIENyeXB0b0pTLlNIQTF9KX0se1wiLi9jb3JlXCI6MjB9XSw0NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9zaGEyNTZcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9zaGEyNTZcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbigpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgV29yZEFycmF5PUNfbGliLldvcmRBcnJheTt2YXIgQ19hbGdvPUMuYWxnbzt2YXIgU0hBMjU2PUNfYWxnby5TSEEyNTY7dmFyIFNIQTIyND1DX2FsZ28uU0hBMjI0PVNIQTI1Ni5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgV29yZEFycmF5LmluaXQoWzMyMzgzNzEwMzIsOTE0MTUwNjYzLDgxMjcwMjk5OSw0MTQ0OTEyNjk3LDQyOTA3NzU4NTcsMTc1MDYwMzAyNSwxNjk0MDc2ODM5LDMyMDQwNzU0MjhdKX0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgaGFzaD1TSEEyNTYuX2RvRmluYWxpemUuY2FsbCh0aGlzKTtoYXNoLnNpZ0J5dGVzLT00O3JldHVybiBoYXNofX0pO0MuU0hBMjI0PVNIQTI1Ni5fY3JlYXRlSGVscGVyKFNIQTIyNCk7Qy5IbWFjU0hBMjI0PVNIQTI1Ni5fY3JlYXRlSG1hY0hlbHBlcihTSEEyMjQpfSkoKTtyZXR1cm4gQ3J5cHRvSlMuU0hBMjI0fSl9LHtcIi4vY29yZVwiOjIwLFwiLi9zaGEyNTZcIjo0N31dLDQ3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5KXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbihNYXRoKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIFdvcmRBcnJheT1DX2xpYi5Xb3JkQXJyYXk7dmFyIEhhc2hlcj1DX2xpYi5IYXNoZXI7dmFyIENfYWxnbz1DLmFsZ287dmFyIEg9W107dmFyIEs9W107KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gaXNQcmltZShuKXt2YXIgc3FydE49TWF0aC5zcXJ0KG4pO2Zvcih2YXIgZmFjdG9yPTI7ZmFjdG9yPD1zcXJ0TjtmYWN0b3IrKyl7aWYoIShuJWZhY3Rvcikpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9ZnVuY3Rpb24gZ2V0RnJhY3Rpb25hbEJpdHMobil7cmV0dXJuKG4tKG58MCkpKjQyOTQ5NjcyOTZ8MH12YXIgbj0yO3ZhciBuUHJpbWU9MDt3aGlsZShuUHJpbWU8NjQpe2lmKGlzUHJpbWUobikpe2lmKG5QcmltZTw4KXtIW25QcmltZV09Z2V0RnJhY3Rpb25hbEJpdHMoTWF0aC5wb3cobiwxLzIpKX1LW25QcmltZV09Z2V0RnJhY3Rpb25hbEJpdHMoTWF0aC5wb3cobiwxLzMpKTtuUHJpbWUrK31uKyt9fSkoKTt2YXIgVz1bXTt2YXIgU0hBMjU2PUNfYWxnby5TSEEyNTY9SGFzaGVyLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyBXb3JkQXJyYXkuaW5pdChILnNsaWNlKDApKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKE0sb2Zmc2V0KXt2YXIgSD10aGlzLl9oYXNoLndvcmRzO3ZhciBhPUhbMF07dmFyIGI9SFsxXTt2YXIgYz1IWzJdO3ZhciBkPUhbM107dmFyIGU9SFs0XTt2YXIgZj1IWzVdO3ZhciBnPUhbNl07dmFyIGg9SFs3XTtmb3IodmFyIGk9MDtpPDY0O2krKyl7aWYoaTwxNil7V1tpXT1NW29mZnNldCtpXXwwfWVsc2V7dmFyIGdhbW1hMHg9V1tpLTE1XTt2YXIgZ2FtbWEwPShnYW1tYTB4PDwyNXxnYW1tYTB4Pj4+NyleKGdhbW1hMHg8PDE0fGdhbW1hMHg+Pj4xOCleZ2FtbWEweD4+PjM7dmFyIGdhbW1hMXg9V1tpLTJdO3ZhciBnYW1tYTE9KGdhbW1hMXg8PDE1fGdhbW1hMXg+Pj4xNyleKGdhbW1hMXg8PDEzfGdhbW1hMXg+Pj4xOSleZ2FtbWExeD4+PjEwO1dbaV09Z2FtbWEwK1dbaS03XStnYW1tYTErV1tpLTE2XX12YXIgY2g9ZSZmXn5lJmc7dmFyIG1haj1hJmJeYSZjXmImYzt2YXIgc2lnbWEwPShhPDwzMHxhPj4+MileKGE8PDE5fGE+Pj4xMyleKGE8PDEwfGE+Pj4yMik7dmFyIHNpZ21hMT0oZTw8MjZ8ZT4+PjYpXihlPDwyMXxlPj4+MTEpXihlPDw3fGU+Pj4yNSk7dmFyIHQxPWgrc2lnbWExK2NoK0tbaV0rV1tpXTt2YXIgdDI9c2lnbWEwK21hajtoPWc7Zz1mO2Y9ZTtlPWQrdDF8MDtkPWM7Yz1iO2I9YTthPXQxK3QyfDB9SFswXT1IWzBdK2F8MDtIWzFdPUhbMV0rYnwwO0hbMl09SFsyXStjfDA7SFszXT1IWzNdK2R8MDtIWzRdPUhbNF0rZXwwO0hbNV09SFs1XStmfDA7SFs2XT1IWzZdK2d8MDtIWzddPUhbN10raHwwfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciBkYXRhPXRoaXMuX2RhdGE7dmFyIGRhdGFXb3Jkcz1kYXRhLndvcmRzO3ZhciBuQml0c1RvdGFsPXRoaXMuX25EYXRhQnl0ZXMqODt2YXIgbkJpdHNMZWZ0PWRhdGEuc2lnQnl0ZXMqODtkYXRhV29yZHNbbkJpdHNMZWZ0Pj4+NV18PTEyODw8MjQtbkJpdHNMZWZ0JTMyO2RhdGFXb3Jkc1sobkJpdHNMZWZ0KzY0Pj4+OTw8NCkrMTRdPU1hdGguZmxvb3IobkJpdHNUb3RhbC80Mjk0OTY3Mjk2KTtkYXRhV29yZHNbKG5CaXRzTGVmdCs2ND4+Pjk8PDQpKzE1XT1uQml0c1RvdGFsO2RhdGEuc2lnQnl0ZXM9ZGF0YVdvcmRzLmxlbmd0aCo0O3RoaXMuX3Byb2Nlc3MoKTtyZXR1cm4gdGhpcy5faGFzaH0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgY2xvbmU9SGFzaGVyLmNsb25lLmNhbGwodGhpcyk7Y2xvbmUuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpO3JldHVybiBjbG9uZX19KTtDLlNIQTI1Nj1IYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEEyNTYpO0MuSG1hY1NIQTI1Nj1IYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMjU2KX0pKE1hdGgpO3JldHVybiBDcnlwdG9KUy5TSEEyNTZ9KX0se1wiLi9jb3JlXCI6MjB9XSw0ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi94NjQtY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL3g2NC1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oTWF0aCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBXb3JkQXJyYXk9Q19saWIuV29yZEFycmF5O3ZhciBIYXNoZXI9Q19saWIuSGFzaGVyO3ZhciBDX3g2ND1DLng2NDt2YXIgWDY0V29yZD1DX3g2NC5Xb3JkO3ZhciBDX2FsZ289Qy5hbGdvO3ZhciBSSE9fT0ZGU0VUUz1bXTt2YXIgUElfSU5ERVhFUz1bXTt2YXIgUk9VTkRfQ09OU1RBTlRTPVtdOyhmdW5jdGlvbigpe3ZhciB4PTEseT0wO2Zvcih2YXIgdD0wO3Q8MjQ7dCsrKXtSSE9fT0ZGU0VUU1t4KzUqeV09KHQrMSkqKHQrMikvMiU2NDt2YXIgbmV3WD15JTU7dmFyIG5ld1k9KDIqeCszKnkpJTU7eD1uZXdYO3k9bmV3WX1mb3IodmFyIHg9MDt4PDU7eCsrKXtmb3IodmFyIHk9MDt5PDU7eSsrKXtQSV9JTkRFWEVTW3grNSp5XT15KygyKngrMyp5KSU1KjV9fXZhciBMRlNSPTE7Zm9yKHZhciBpPTA7aTwyNDtpKyspe3ZhciByb3VuZENvbnN0YW50TXN3PTA7dmFyIHJvdW5kQ29uc3RhbnRMc3c9MDtmb3IodmFyIGo9MDtqPDc7aisrKXtpZihMRlNSJjEpe3ZhciBiaXRQb3NpdGlvbj0oMTw8aiktMTtpZihiaXRQb3NpdGlvbjwzMil7cm91bmRDb25zdGFudExzd149MTw8Yml0UG9zaXRpb259ZWxzZXtyb3VuZENvbnN0YW50TXN3Xj0xPDxiaXRQb3NpdGlvbi0zMn19aWYoTEZTUiYxMjgpe0xGU1I9TEZTUjw8MV4xMTN9ZWxzZXtMRlNSPDw9MX19Uk9VTkRfQ09OU1RBTlRTW2ldPVg2NFdvcmQuY3JlYXRlKHJvdW5kQ29uc3RhbnRNc3cscm91bmRDb25zdGFudExzdyl9fSkoKTt2YXIgVD1bXTsoZnVuY3Rpb24oKXtmb3IodmFyIGk9MDtpPDI1O2krKyl7VFtpXT1YNjRXb3JkLmNyZWF0ZSgpfX0pKCk7dmFyIFNIQTM9Q19hbGdvLlNIQTM9SGFzaGVyLmV4dGVuZCh7Y2ZnOkhhc2hlci5jZmcuZXh0ZW5kKHtvdXRwdXRMZW5ndGg6NTEyfSksX2RvUmVzZXQ6ZnVuY3Rpb24oKXt2YXIgc3RhdGU9dGhpcy5fc3RhdGU9W107Zm9yKHZhciBpPTA7aTwyNTtpKyspe3N0YXRlW2ldPW5ldyBYNjRXb3JkLmluaXR9dGhpcy5ibG9ja1NpemU9KDE2MDAtMip0aGlzLmNmZy5vdXRwdXRMZW5ndGgpLzMyfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24oTSxvZmZzZXQpe3ZhciBzdGF0ZT10aGlzLl9zdGF0ZTt2YXIgbkJsb2NrU2l6ZUxhbmVzPXRoaXMuYmxvY2tTaXplLzI7Zm9yKHZhciBpPTA7aTxuQmxvY2tTaXplTGFuZXM7aSsrKXt2YXIgTTJpPU1bb2Zmc2V0KzIqaV07dmFyIE0yaTE9TVtvZmZzZXQrMippKzFdO00yaT0oTTJpPDw4fE0yaT4+PjI0KSYxNjcxMTkzNXwoTTJpPDwyNHxNMmk+Pj44KSY0Mjc4MjU1MzYwO00yaTE9KE0yaTE8PDh8TTJpMT4+PjI0KSYxNjcxMTkzNXwoTTJpMTw8MjR8TTJpMT4+PjgpJjQyNzgyNTUzNjA7dmFyIGxhbmU9c3RhdGVbaV07bGFuZS5oaWdoXj1NMmkxO2xhbmUubG93Xj1NMml9Zm9yKHZhciByb3VuZD0wO3JvdW5kPDI0O3JvdW5kKyspe2Zvcih2YXIgeD0wO3g8NTt4Kyspe3ZhciB0TXN3PTAsdExzdz0wO2Zvcih2YXIgeT0wO3k8NTt5Kyspe3ZhciBsYW5lPXN0YXRlW3grNSp5XTt0TXN3Xj1sYW5lLmhpZ2g7dExzd149bGFuZS5sb3d9dmFyIFR4PVRbeF07VHguaGlnaD10TXN3O1R4Lmxvdz10THN3fWZvcih2YXIgeD0wO3g8NTt4Kyspe3ZhciBUeDQ9VFsoeCs0KSU1XTt2YXIgVHgxPVRbKHgrMSklNV07dmFyIFR4MU1zdz1UeDEuaGlnaDt2YXIgVHgxTHN3PVR4MS5sb3c7dmFyIHRNc3c9VHg0LmhpZ2heKFR4MU1zdzw8MXxUeDFMc3c+Pj4zMSk7dmFyIHRMc3c9VHg0Lmxvd14oVHgxTHN3PDwxfFR4MU1zdz4+PjMxKTtmb3IodmFyIHk9MDt5PDU7eSsrKXt2YXIgbGFuZT1zdGF0ZVt4KzUqeV07bGFuZS5oaWdoXj10TXN3O2xhbmUubG93Xj10THN3fX1mb3IodmFyIGxhbmVJbmRleD0xO2xhbmVJbmRleDwyNTtsYW5lSW5kZXgrKyl7dmFyIGxhbmU9c3RhdGVbbGFuZUluZGV4XTt2YXIgbGFuZU1zdz1sYW5lLmhpZ2g7dmFyIGxhbmVMc3c9bGFuZS5sb3c7dmFyIHJob09mZnNldD1SSE9fT0ZGU0VUU1tsYW5lSW5kZXhdO2lmKHJob09mZnNldDwzMil7dmFyIHRNc3c9bGFuZU1zdzw8cmhvT2Zmc2V0fGxhbmVMc3c+Pj4zMi1yaG9PZmZzZXQ7dmFyIHRMc3c9bGFuZUxzdzw8cmhvT2Zmc2V0fGxhbmVNc3c+Pj4zMi1yaG9PZmZzZXR9ZWxzZXt2YXIgdE1zdz1sYW5lTHN3PDxyaG9PZmZzZXQtMzJ8bGFuZU1zdz4+PjY0LXJob09mZnNldDt2YXIgdExzdz1sYW5lTXN3PDxyaG9PZmZzZXQtMzJ8bGFuZUxzdz4+PjY0LXJob09mZnNldH12YXIgVFBpTGFuZT1UW1BJX0lOREVYRVNbbGFuZUluZGV4XV07VFBpTGFuZS5oaWdoPXRNc3c7VFBpTGFuZS5sb3c9dExzd312YXIgVDA9VFswXTt2YXIgc3RhdGUwPXN0YXRlWzBdO1QwLmhpZ2g9c3RhdGUwLmhpZ2g7VDAubG93PXN0YXRlMC5sb3c7Zm9yKHZhciB4PTA7eDw1O3grKyl7Zm9yKHZhciB5PTA7eTw1O3krKyl7dmFyIGxhbmVJbmRleD14KzUqeTt2YXIgbGFuZT1zdGF0ZVtsYW5lSW5kZXhdO3ZhciBUTGFuZT1UW2xhbmVJbmRleF07dmFyIFR4MUxhbmU9VFsoeCsxKSU1KzUqeV07dmFyIFR4MkxhbmU9VFsoeCsyKSU1KzUqeV07bGFuZS5oaWdoPVRMYW5lLmhpZ2heflR4MUxhbmUuaGlnaCZUeDJMYW5lLmhpZ2g7bGFuZS5sb3c9VExhbmUubG93Xn5UeDFMYW5lLmxvdyZUeDJMYW5lLmxvd319dmFyIGxhbmU9c3RhdGVbMF07dmFyIHJvdW5kQ29uc3RhbnQ9Uk9VTkRfQ09OU1RBTlRTW3JvdW5kXTtsYW5lLmhpZ2hePXJvdW5kQ29uc3RhbnQuaGlnaDtsYW5lLmxvd149cm91bmRDb25zdGFudC5sb3d9fSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciBkYXRhPXRoaXMuX2RhdGE7dmFyIGRhdGFXb3Jkcz1kYXRhLndvcmRzO3ZhciBuQml0c1RvdGFsPXRoaXMuX25EYXRhQnl0ZXMqODt2YXIgbkJpdHNMZWZ0PWRhdGEuc2lnQnl0ZXMqODt2YXIgYmxvY2tTaXplQml0cz10aGlzLmJsb2NrU2l6ZSozMjtkYXRhV29yZHNbbkJpdHNMZWZ0Pj4+NV18PTE8PDI0LW5CaXRzTGVmdCUzMjtkYXRhV29yZHNbKE1hdGguY2VpbCgobkJpdHNMZWZ0KzEpL2Jsb2NrU2l6ZUJpdHMpKmJsb2NrU2l6ZUJpdHM+Pj41KS0xXXw9MTI4O2RhdGEuc2lnQnl0ZXM9ZGF0YVdvcmRzLmxlbmd0aCo0O3RoaXMuX3Byb2Nlc3MoKTt2YXIgc3RhdGU9dGhpcy5fc3RhdGU7dmFyIG91dHB1dExlbmd0aEJ5dGVzPXRoaXMuY2ZnLm91dHB1dExlbmd0aC84O3ZhciBvdXRwdXRMZW5ndGhMYW5lcz1vdXRwdXRMZW5ndGhCeXRlcy84O3ZhciBoYXNoV29yZHM9W107Zm9yKHZhciBpPTA7aTxvdXRwdXRMZW5ndGhMYW5lcztpKyspe3ZhciBsYW5lPXN0YXRlW2ldO3ZhciBsYW5lTXN3PWxhbmUuaGlnaDt2YXIgbGFuZUxzdz1sYW5lLmxvdztsYW5lTXN3PShsYW5lTXN3PDw4fGxhbmVNc3c+Pj4yNCkmMTY3MTE5MzV8KGxhbmVNc3c8PDI0fGxhbmVNc3c+Pj44KSY0Mjc4MjU1MzYwO2xhbmVMc3c9KGxhbmVMc3c8PDh8bGFuZUxzdz4+PjI0KSYxNjcxMTkzNXwobGFuZUxzdzw8MjR8bGFuZUxzdz4+PjgpJjQyNzgyNTUzNjA7aGFzaFdvcmRzLnB1c2gobGFuZUxzdyk7aGFzaFdvcmRzLnB1c2gobGFuZU1zdyl9cmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdChoYXNoV29yZHMsb3V0cHV0TGVuZ3RoQnl0ZXMpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciBjbG9uZT1IYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTt2YXIgc3RhdGU9Y2xvbmUuX3N0YXRlPXRoaXMuX3N0YXRlLnNsaWNlKDApO2Zvcih2YXIgaT0wO2k8MjU7aSsrKXtzdGF0ZVtpXT1zdGF0ZVtpXS5jbG9uZSgpfXJldHVybiBjbG9uZX19KTtDLlNIQTM9SGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMyk7Qy5IbWFjU0hBMz1IYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMyl9KShNYXRoKTtyZXR1cm4gQ3J5cHRvSlMuU0hBM30pfSx7XCIuL2NvcmVcIjoyMCxcIi4veDY0LWNvcmVcIjo1Mn1dLDQ5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL3g2NC1jb3JlXCIpLF9kZXJlcV8oXCIuL3NoYTUxMlwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL3g2NC1jb3JlXCIsXCIuL3NoYTUxMlwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfeDY0PUMueDY0O3ZhciBYNjRXb3JkPUNfeDY0LldvcmQ7dmFyIFg2NFdvcmRBcnJheT1DX3g2NC5Xb3JkQXJyYXk7dmFyIENfYWxnbz1DLmFsZ287dmFyIFNIQTUxMj1DX2FsZ28uU0hBNTEyO3ZhciBTSEEzODQ9Q19hbGdvLlNIQTM4ND1TSEE1MTIuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IFg2NFdvcmRBcnJheS5pbml0KFtuZXcgWDY0V29yZC5pbml0KDM0MTgwNzAzNjUsMzIzODM3MTAzMiksbmV3IFg2NFdvcmQuaW5pdCgxNjU0MjcwMjUwLDkxNDE1MDY2MyksbmV3IFg2NFdvcmQuaW5pdCgyNDM4NTI5MzcwLDgxMjcwMjk5OSksbmV3IFg2NFdvcmQuaW5pdCgzNTU0NjIzNjAsNDE0NDkxMjY5NyksbmV3IFg2NFdvcmQuaW5pdCgxNzMxNDA1NDE1LDQyOTA3NzU4NTcpLG5ldyBYNjRXb3JkLmluaXQoMjM5NDE4MDIzMSwxNzUwNjAzMDI1KSxuZXcgWDY0V29yZC5pbml0KDM2NzUwMDg1MjUsMTY5NDA3NjgzOSksbmV3IFg2NFdvcmQuaW5pdCgxMjAzMDYyODEzLDMyMDQwNzU0MjgpXSl9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGhhc2g9U0hBNTEyLl9kb0ZpbmFsaXplLmNhbGwodGhpcyk7aGFzaC5zaWdCeXRlcy09MTY7cmV0dXJuIGhhc2h9fSk7Qy5TSEEzODQ9U0hBNTEyLl9jcmVhdGVIZWxwZXIoU0hBMzg0KTtDLkhtYWNTSEEzODQ9U0hBNTEyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTM4NCl9KSgpO3JldHVybiBDcnlwdG9KUy5TSEEzODR9KX0se1wiLi9jb3JlXCI6MjAsXCIuL3NoYTUxMlwiOjUwLFwiLi94NjQtY29yZVwiOjUyfV0sNTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4veDY0LWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi94NjQtY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBIYXNoZXI9Q19saWIuSGFzaGVyO3ZhciBDX3g2ND1DLng2NDt2YXIgWDY0V29yZD1DX3g2NC5Xb3JkO3ZhciBYNjRXb3JkQXJyYXk9Q194NjQuV29yZEFycmF5O3ZhciBDX2FsZ289Qy5hbGdvO2Z1bmN0aW9uIFg2NFdvcmRfY3JlYXRlKCl7cmV0dXJuIFg2NFdvcmQuY3JlYXRlLmFwcGx5KFg2NFdvcmQsYXJndW1lbnRzKX12YXIgSz1bWDY0V29yZF9jcmVhdGUoMTExNjM1MjQwOCwzNjA5NzY3NDU4KSxYNjRXb3JkX2NyZWF0ZSgxODk5NDQ3NDQxLDYwMjg5MTcyNSksWDY0V29yZF9jcmVhdGUoMzA0OTMyMzQ3MSwzOTY0NDg0Mzk5KSxYNjRXb3JkX2NyZWF0ZSgzOTIxMDA5NTczLDIxNzMyOTU1NDgpLFg2NFdvcmRfY3JlYXRlKDk2MTk4NzE2Myw0MDgxNjI4NDcyKSxYNjRXb3JkX2NyZWF0ZSgxNTA4OTcwOTkzLDMwNTM4MzQyNjUpLFg2NFdvcmRfY3JlYXRlKDI0NTM2MzU3NDgsMjkzNzY3MTU3OSksWDY0V29yZF9jcmVhdGUoMjg3MDc2MzIyMSwzNjY0NjA5NTYwKSxYNjRXb3JkX2NyZWF0ZSgzNjI0MzgxMDgwLDI3MzQ4ODMzOTQpLFg2NFdvcmRfY3JlYXRlKDMxMDU5ODQwMSwxMTY0OTk2NTQyKSxYNjRXb3JkX2NyZWF0ZSg2MDcyMjUyNzgsMTMyMzYxMDc2NCksWDY0V29yZF9jcmVhdGUoMTQyNjg4MTk4NywzNTkwMzA0OTk0KSxYNjRXb3JkX2NyZWF0ZSgxOTI1MDc4Mzg4LDQwNjgxODIzODMpLFg2NFdvcmRfY3JlYXRlKDIxNjIwNzgyMDYsOTkxMzM2MTEzKSxYNjRXb3JkX2NyZWF0ZSgyNjE0ODg4MTAzLDYzMzgwMzMxNyksWDY0V29yZF9jcmVhdGUoMzI0ODIyMjU4MCwzNDc5Nzc0ODY4KSxYNjRXb3JkX2NyZWF0ZSgzODM1MzkwNDAxLDI2NjY2MTM0NTgpLFg2NFdvcmRfY3JlYXRlKDQwMjIyMjQ3NzQsOTQ0NzExMTM5KSxYNjRXb3JkX2NyZWF0ZSgyNjQzNDcwNzgsMjM0MTI2Mjc3MyksWDY0V29yZF9jcmVhdGUoNjA0ODA3NjI4LDIwMDc4MDA5MzMpLFg2NFdvcmRfY3JlYXRlKDc3MDI1NTk4MywxNDk1OTkwOTAxKSxYNjRXb3JkX2NyZWF0ZSgxMjQ5MTUwMTIyLDE4NTY0MzEyMzUpLFg2NFdvcmRfY3JlYXRlKDE1NTUwODE2OTIsMzE3NTIxODEzMiksWDY0V29yZF9jcmVhdGUoMTk5NjA2NDk4NiwyMTk4OTUwODM3KSxYNjRXb3JkX2NyZWF0ZSgyNTU0MjIwODgyLDM5OTk3MTkzMzkpLFg2NFdvcmRfY3JlYXRlKDI4MjE4MzQzNDksNzY2Nzg0MDE2KSxYNjRXb3JkX2NyZWF0ZSgyOTUyOTk2ODA4LDI1NjY1OTQ4NzkpLFg2NFdvcmRfY3JlYXRlKDMyMTAzMTM2NzEsMzIwMzMzNzk1NiksWDY0V29yZF9jcmVhdGUoMzMzNjU3MTg5MSwxMDM0NDU3MDI2KSxYNjRXb3JkX2NyZWF0ZSgzNTg0NTI4NzExLDI0NjY5NDg5MDEpLFg2NFdvcmRfY3JlYXRlKDExMzkyNjk5MywzNzU4MzI2MzgzKSxYNjRXb3JkX2NyZWF0ZSgzMzgyNDE4OTUsMTY4NzE3OTM2KSxYNjRXb3JkX2NyZWF0ZSg2NjYzMDcyMDUsMTE4ODE3OTk2NCksWDY0V29yZF9jcmVhdGUoNzczNTI5OTEyLDE1NDYwNDU3MzQpLFg2NFdvcmRfY3JlYXRlKDEyOTQ3NTczNzIsMTUyMjgwNTQ4NSksWDY0V29yZF9jcmVhdGUoMTM5NjE4MjI5MSwyNjQzODMzODIzKSxYNjRXb3JkX2NyZWF0ZSgxNjk1MTgzNzAwLDIzNDM1MjczOTApLFg2NFdvcmRfY3JlYXRlKDE5ODY2NjEwNTEsMTAxNDQ3NzQ4MCksWDY0V29yZF9jcmVhdGUoMjE3NzAyNjM1MCwxMjA2NzU5MTQyKSxYNjRXb3JkX2NyZWF0ZSgyNDU2OTU2MDM3LDM0NDA3NzYyNyksWDY0V29yZF9jcmVhdGUoMjczMDQ4NTkyMSwxMjkwODYzNDYwKSxYNjRXb3JkX2NyZWF0ZSgyODIwMzAyNDExLDMxNTg0NTQyNzMpLFg2NFdvcmRfY3JlYXRlKDMyNTk3MzA4MDAsMzUwNTk1MjY1NyksWDY0V29yZF9jcmVhdGUoMzM0NTc2NDc3MSwxMDYyMTcwMDgpLFg2NFdvcmRfY3JlYXRlKDM1MTYwNjU4MTcsMzYwNjAwODM0NCksWDY0V29yZF9jcmVhdGUoMzYwMDM1MjgwNCwxNDMyNzI1Nzc2KSxYNjRXb3JkX2NyZWF0ZSg0MDk0NTcxOTA5LDE0NjcwMzE1OTQpLFg2NFdvcmRfY3JlYXRlKDI3NTQyMzM0NCw4NTExNjk3MjApLFg2NFdvcmRfY3JlYXRlKDQzMDIyNzczNCwzMTAwODIzNzUyKSxYNjRXb3JkX2NyZWF0ZSg1MDY5NDg2MTYsMTM2MzI1ODE5NSksWDY0V29yZF9jcmVhdGUoNjU5MDYwNTU2LDM3NTA2ODU1OTMpLFg2NFdvcmRfY3JlYXRlKDg4Mzk5Nzg3NywzNzg1MDUwMjgwKSxYNjRXb3JkX2NyZWF0ZSg5NTgxMzk1NzEsMzMxODMwNzQyNyksWDY0V29yZF9jcmVhdGUoMTMyMjgyMjIxOCwzODEyNzIzNDAzKSxYNjRXb3JkX2NyZWF0ZSgxNTM3MDAyMDYzLDIwMDMwMzQ5OTUpLFg2NFdvcmRfY3JlYXRlKDE3NDc4NzM3NzksMzYwMjAzNjg5OSksWDY0V29yZF9jcmVhdGUoMTk1NTU2MjIyMiwxNTc1OTkwMDEyKSxYNjRXb3JkX2NyZWF0ZSgyMDI0MTA0ODE1LDExMjU1OTI5MjgpLFg2NFdvcmRfY3JlYXRlKDIyMjc3MzA0NTIsMjcxNjkwNDMwNiksWDY0V29yZF9jcmVhdGUoMjM2MTg1MjQyNCw0NDI3NzYwNDQpLFg2NFdvcmRfY3JlYXRlKDI0Mjg0MzY0NzQsNTkzNjk4MzQ0KSxYNjRXb3JkX2NyZWF0ZSgyNzU2NzM0MTg3LDM3MzMxMTAyNDkpLFg2NFdvcmRfY3JlYXRlKDMyMDQwMzE0NzksMjk5OTM1MTU3MyksWDY0V29yZF9jcmVhdGUoMzMyOTMyNTI5OCwzODE1OTIwNDI3KSxYNjRXb3JkX2NyZWF0ZSgzMzkxNTY5NjE0LDM5MjgzODM5MDApLFg2NFdvcmRfY3JlYXRlKDM1MTUyNjcyNzEsNTY2MjgwNzExKSxYNjRXb3JkX2NyZWF0ZSgzOTQwMTg3NjA2LDM0NTQwNjk1MzQpLFg2NFdvcmRfY3JlYXRlKDQxMTg2MzAyNzEsNDAwMDIzOTk5MiksWDY0V29yZF9jcmVhdGUoMTE2NDE4NDc0LDE5MTQxMzg1NTQpLFg2NFdvcmRfY3JlYXRlKDE3NDI5MjQyMSwyNzMxMDU1MjcwKSxYNjRXb3JkX2NyZWF0ZSgyODkzODAzNTYsMzIwMzk5MzAwNiksWDY0V29yZF9jcmVhdGUoNDYwMzkzMjY5LDMyMDYyMDMxNSksWDY0V29yZF9jcmVhdGUoNjg1NDcxNzMzLDU4NzQ5NjgzNiksWDY0V29yZF9jcmVhdGUoODUyMTQyOTcxLDEwODY3OTI4NTEpLFg2NFdvcmRfY3JlYXRlKDEwMTcwMzYyOTgsMzY1NTQzMTAwKSxYNjRXb3JkX2NyZWF0ZSgxMTI2MDAwNTgwLDI2MTgyOTc2NzYpLFg2NFdvcmRfY3JlYXRlKDEyODgwMzM0NzAsMzQwOTg1NTE1OCksWDY0V29yZF9jcmVhdGUoMTUwMTUwNTk0OCw0MjM0NTA5ODY2KSxYNjRXb3JkX2NyZWF0ZSgxNjA3MTY3OTE1LDk4NzE2NzQ2OCksWDY0V29yZF9jcmVhdGUoMTgxNjQwMjMxNiwxMjQ2MTg5NTkxKV07dmFyIFc9W107KGZ1bmN0aW9uKCl7Zm9yKHZhciBpPTA7aTw4MDtpKyspe1dbaV09WDY0V29yZF9jcmVhdGUoKX19KSgpO3ZhciBTSEE1MTI9Q19hbGdvLlNIQTUxMj1IYXNoZXIuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IFg2NFdvcmRBcnJheS5pbml0KFtuZXcgWDY0V29yZC5pbml0KDE3NzkwMzM3MDMsNDA4OTIzNTcyMCksbmV3IFg2NFdvcmQuaW5pdCgzMTQ0MTM0Mjc3LDIyMjc4NzM1OTUpLG5ldyBYNjRXb3JkLmluaXQoMTAxMzkwNDI0Miw0MjcxMTc1NzIzKSxuZXcgWDY0V29yZC5pbml0KDI3NzM0ODA3NjIsMTU5NTc1MDEyOSksbmV3IFg2NFdvcmQuaW5pdCgxMzU5ODkzMTE5LDI5MTc1NjUxMzcpLG5ldyBYNjRXb3JkLmluaXQoMjYwMDgyMjkyNCw3MjU1MTExOTkpLG5ldyBYNjRXb3JkLmluaXQoNTI4NzM0NjM1LDQyMTUzODk1NDcpLG5ldyBYNjRXb3JkLmluaXQoMTU0MTQ1OTIyNSwzMjcwMzMyMDkpXSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihNLG9mZnNldCl7dmFyIEg9dGhpcy5faGFzaC53b3Jkczt2YXIgSDA9SFswXTt2YXIgSDE9SFsxXTt2YXIgSDI9SFsyXTt2YXIgSDM9SFszXTt2YXIgSDQ9SFs0XTt2YXIgSDU9SFs1XTt2YXIgSDY9SFs2XTt2YXIgSDc9SFs3XTt2YXIgSDBoPUgwLmhpZ2g7dmFyIEgwbD1IMC5sb3c7dmFyIEgxaD1IMS5oaWdoO3ZhciBIMWw9SDEubG93O3ZhciBIMmg9SDIuaGlnaDt2YXIgSDJsPUgyLmxvdzt2YXIgSDNoPUgzLmhpZ2g7dmFyIEgzbD1IMy5sb3c7dmFyIEg0aD1INC5oaWdoO3ZhciBINGw9SDQubG93O3ZhciBINWg9SDUuaGlnaDt2YXIgSDVsPUg1Lmxvdzt2YXIgSDZoPUg2LmhpZ2g7dmFyIEg2bD1INi5sb3c7dmFyIEg3aD1INy5oaWdoO3ZhciBIN2w9SDcubG93O3ZhciBhaD1IMGg7dmFyIGFsPUgwbDt2YXIgYmg9SDFoO3ZhciBibD1IMWw7dmFyIGNoPUgyaDt2YXIgY2w9SDJsO3ZhciBkaD1IM2g7dmFyIGRsPUgzbDt2YXIgZWg9SDRoO3ZhciBlbD1INGw7dmFyIGZoPUg1aDt2YXIgZmw9SDVsO3ZhciBnaD1INmg7dmFyIGdsPUg2bDt2YXIgaGg9SDdoO3ZhciBobD1IN2w7Zm9yKHZhciBpPTA7aTw4MDtpKyspe3ZhciBXaT1XW2ldO2lmKGk8MTYpe3ZhciBXaWg9V2kuaGlnaD1NW29mZnNldCtpKjJdfDA7dmFyIFdpbD1XaS5sb3c9TVtvZmZzZXQraSoyKzFdfDB9ZWxzZXt2YXIgZ2FtbWEweD1XW2ktMTVdO3ZhciBnYW1tYTB4aD1nYW1tYTB4LmhpZ2g7dmFyIGdhbW1hMHhsPWdhbW1hMHgubG93O3ZhciBnYW1tYTBoPShnYW1tYTB4aD4+PjF8Z2FtbWEweGw8PDMxKV4oZ2FtbWEweGg+Pj44fGdhbW1hMHhsPDwyNCleZ2FtbWEweGg+Pj43O3ZhciBnYW1tYTBsPShnYW1tYTB4bD4+PjF8Z2FtbWEweGg8PDMxKV4oZ2FtbWEweGw+Pj44fGdhbW1hMHhoPDwyNCleKGdhbW1hMHhsPj4+N3xnYW1tYTB4aDw8MjUpO3ZhciBnYW1tYTF4PVdbaS0yXTt2YXIgZ2FtbWExeGg9Z2FtbWExeC5oaWdoO3ZhciBnYW1tYTF4bD1nYW1tYTF4Lmxvdzt2YXIgZ2FtbWExaD0oZ2FtbWExeGg+Pj4xOXxnYW1tYTF4bDw8MTMpXihnYW1tYTF4aDw8M3xnYW1tYTF4bD4+PjI5KV5nYW1tYTF4aD4+PjY7dmFyIGdhbW1hMWw9KGdhbW1hMXhsPj4+MTl8Z2FtbWExeGg8PDEzKV4oZ2FtbWExeGw8PDN8Z2FtbWExeGg+Pj4yOSleKGdhbW1hMXhsPj4+NnxnYW1tYTF4aDw8MjYpO3ZhciBXaTc9V1tpLTddO3ZhciBXaTdoPVdpNy5oaWdoO3ZhciBXaTdsPVdpNy5sb3c7dmFyIFdpMTY9V1tpLTE2XTt2YXIgV2kxNmg9V2kxNi5oaWdoO3ZhciBXaTE2bD1XaTE2Lmxvdzt2YXIgV2lsPWdhbW1hMGwrV2k3bDt2YXIgV2loPWdhbW1hMGgrV2k3aCsoV2lsPj4+MDxnYW1tYTBsPj4+MD8xOjApO3ZhciBXaWw9V2lsK2dhbW1hMWw7dmFyIFdpaD1XaWgrZ2FtbWExaCsoV2lsPj4+MDxnYW1tYTFsPj4+MD8xOjApO3ZhciBXaWw9V2lsK1dpMTZsO3ZhciBXaWg9V2loK1dpMTZoKyhXaWw+Pj4wPFdpMTZsPj4+MD8xOjApO1dpLmhpZ2g9V2loO1dpLmxvdz1XaWx9dmFyIGNoaD1laCZmaF5+ZWgmZ2g7dmFyIGNobD1lbCZmbF5+ZWwmZ2w7dmFyIG1hamg9YWgmYmheYWgmY2heYmgmY2g7dmFyIG1hamw9YWwmYmxeYWwmY2xeYmwmY2w7dmFyIHNpZ21hMGg9KGFoPj4+Mjh8YWw8PDQpXihhaDw8MzB8YWw+Pj4yKV4oYWg8PDI1fGFsPj4+Nyk7dmFyIHNpZ21hMGw9KGFsPj4+Mjh8YWg8PDQpXihhbDw8MzB8YWg+Pj4yKV4oYWw8PDI1fGFoPj4+Nyk7dmFyIHNpZ21hMWg9KGVoPj4+MTR8ZWw8PDE4KV4oZWg+Pj4xOHxlbDw8MTQpXihlaDw8MjN8ZWw+Pj45KTt2YXIgc2lnbWExbD0oZWw+Pj4xNHxlaDw8MTgpXihlbD4+PjE4fGVoPDwxNCleKGVsPDwyM3xlaD4+PjkpO3ZhciBLaT1LW2ldO3ZhciBLaWg9S2kuaGlnaDt2YXIgS2lsPUtpLmxvdzt2YXIgdDFsPWhsK3NpZ21hMWw7dmFyIHQxaD1oaCtzaWdtYTFoKyh0MWw+Pj4wPGhsPj4+MD8xOjApO3ZhciB0MWw9dDFsK2NobDt2YXIgdDFoPXQxaCtjaGgrKHQxbD4+PjA8Y2hsPj4+MD8xOjApO3ZhciB0MWw9dDFsK0tpbDt2YXIgdDFoPXQxaCtLaWgrKHQxbD4+PjA8S2lsPj4+MD8xOjApO3ZhciB0MWw9dDFsK1dpbDt2YXIgdDFoPXQxaCtXaWgrKHQxbD4+PjA8V2lsPj4+MD8xOjApO3ZhciB0Mmw9c2lnbWEwbCttYWpsO3ZhciB0Mmg9c2lnbWEwaCttYWpoKyh0Mmw+Pj4wPHNpZ21hMGw+Pj4wPzE6MCk7aGg9Z2g7aGw9Z2w7Z2g9Zmg7Z2w9Zmw7Zmg9ZWg7Zmw9ZWw7ZWw9ZGwrdDFsfDA7ZWg9ZGgrdDFoKyhlbD4+PjA8ZGw+Pj4wPzE6MCl8MDtkaD1jaDtkbD1jbDtjaD1iaDtjbD1ibDtiaD1haDtibD1hbDthbD10MWwrdDJsfDA7YWg9dDFoK3QyaCsoYWw+Pj4wPHQxbD4+PjA/MTowKXwwfUgwbD1IMC5sb3c9SDBsK2FsO0gwLmhpZ2g9SDBoK2FoKyhIMGw+Pj4wPGFsPj4+MD8xOjApO0gxbD1IMS5sb3c9SDFsK2JsO0gxLmhpZ2g9SDFoK2JoKyhIMWw+Pj4wPGJsPj4+MD8xOjApO0gybD1IMi5sb3c9SDJsK2NsO0gyLmhpZ2g9SDJoK2NoKyhIMmw+Pj4wPGNsPj4+MD8xOjApO0gzbD1IMy5sb3c9SDNsK2RsO0gzLmhpZ2g9SDNoK2RoKyhIM2w+Pj4wPGRsPj4+MD8xOjApO0g0bD1INC5sb3c9SDRsK2VsO0g0LmhpZ2g9SDRoK2VoKyhINGw+Pj4wPGVsPj4+MD8xOjApO0g1bD1INS5sb3c9SDVsK2ZsO0g1LmhpZ2g9SDVoK2ZoKyhINWw+Pj4wPGZsPj4+MD8xOjApO0g2bD1INi5sb3c9SDZsK2dsO0g2LmhpZ2g9SDZoK2doKyhINmw+Pj4wPGdsPj4+MD8xOjApO0g3bD1INy5sb3c9SDdsK2hsO0g3LmhpZ2g9SDdoK2hoKyhIN2w+Pj4wPGhsPj4+MD8xOjApfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciBkYXRhPXRoaXMuX2RhdGE7dmFyIGRhdGFXb3Jkcz1kYXRhLndvcmRzO3ZhciBuQml0c1RvdGFsPXRoaXMuX25EYXRhQnl0ZXMqODt2YXIgbkJpdHNMZWZ0PWRhdGEuc2lnQnl0ZXMqODtkYXRhV29yZHNbbkJpdHNMZWZ0Pj4+NV18PTEyODw8MjQtbkJpdHNMZWZ0JTMyO2RhdGFXb3Jkc1sobkJpdHNMZWZ0KzEyOD4+PjEwPDw1KSszMF09TWF0aC5mbG9vcihuQml0c1RvdGFsLzQyOTQ5NjcyOTYpO2RhdGFXb3Jkc1sobkJpdHNMZWZ0KzEyOD4+PjEwPDw1KSszMV09bkJpdHNUb3RhbDtkYXRhLnNpZ0J5dGVzPWRhdGFXb3Jkcy5sZW5ndGgqNDt0aGlzLl9wcm9jZXNzKCk7dmFyIGhhc2g9dGhpcy5faGFzaC50b1gzMigpO3JldHVybiBoYXNofSxjbG9uZTpmdW5jdGlvbigpe3ZhciBjbG9uZT1IYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtjbG9uZS5faGFzaD10aGlzLl9oYXNoLmNsb25lKCk7cmV0dXJuIGNsb25lfSxibG9ja1NpemU6MTAyNC8zMn0pO0MuU0hBNTEyPUhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTUxMik7Qy5IbWFjU0hBNTEyPUhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEE1MTIpfSkoKTtyZXR1cm4gQ3J5cHRvSlMuU0hBNTEyfSl9LHtcIi4vY29yZVwiOjIwLFwiLi94NjQtY29yZVwiOjUyfV0sNTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vZW5jLWJhc2U2NFwiKSxfZGVyZXFfKFwiLi9tZDVcIiksX2RlcmVxXyhcIi4vZXZwa2RmXCIpLF9kZXJlcV8oXCIuL2NpcGhlci1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vZW5jLWJhc2U2NFwiLFwiLi9tZDVcIixcIi4vZXZwa2RmXCIsXCIuL2NpcGhlci1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIFdvcmRBcnJheT1DX2xpYi5Xb3JkQXJyYXk7dmFyIEJsb2NrQ2lwaGVyPUNfbGliLkJsb2NrQ2lwaGVyO3ZhciBDX2FsZ289Qy5hbGdvO3ZhciBQQzE9WzU3LDQ5LDQxLDMzLDI1LDE3LDksMSw1OCw1MCw0MiwzNCwyNiwxOCwxMCwyLDU5LDUxLDQzLDM1LDI3LDE5LDExLDMsNjAsNTIsNDQsMzYsNjMsNTUsNDcsMzksMzEsMjMsMTUsNyw2Miw1NCw0NiwzOCwzMCwyMiwxNCw2LDYxLDUzLDQ1LDM3LDI5LDIxLDEzLDUsMjgsMjAsMTIsNF07dmFyIFBDMj1bMTQsMTcsMTEsMjQsMSw1LDMsMjgsMTUsNiwyMSwxMCwyMywxOSwxMiw0LDI2LDgsMTYsNywyNywyMCwxMywyLDQxLDUyLDMxLDM3LDQ3LDU1LDMwLDQwLDUxLDQ1LDMzLDQ4LDQ0LDQ5LDM5LDU2LDM0LDUzLDQ2LDQyLDUwLDM2LDI5LDMyXTt2YXIgQklUX1NISUZUUz1bMSwyLDQsNiw4LDEwLDEyLDE0LDE1LDE3LDE5LDIxLDIzLDI1LDI3LDI4XTt2YXIgU0JPWF9QPVt7MDo4NDIxODg4LDI2ODQzNTQ1NjozMjc2OCw1MzY4NzA5MTI6ODQyMTM3OCw4MDUzMDYzNjg6MiwxMDczNzQxODI0OjUxMiwxMzQyMTc3MjgwOjg0MjE4OTAsMTYxMDYxMjczNjo4Mzg5MTIyLDE4NzkwNDgxOTI6ODM4ODYwOCwyMTQ3NDgzNjQ4OjUxNCwyNDE1OTE5MTA0OjgzODkxMjAsMjY4NDM1NDU2MDozMzI4MCwyOTUyNzkwMDE2Ojg0MjEzNzYsMzIyMTIyNTQ3MjozMjc3MCwzNDg5NjYwOTI4OjgzODg2MTAsMzc1ODA5NjM4NDowLDQwMjY1MzE4NDA6MzMyODIsMTM0MjE3NzI4OjAsNDAyNjUzMTg0Ojg0MjE4OTAsNjcxMDg4NjQwOjMzMjgyLDkzOTUyNDA5NjozMjc2OCwxMjA3OTU5NTUyOjg0MjE4ODgsMTQ3NjM5NTAwODo1MTIsMTc0NDgzMDQ2NDo4NDIxMzc4LDIwMTMyNjU5MjA6MiwyMjgxNzAxMzc2OjgzODkxMjAsMjU1MDEzNjgzMjozMzI4MCwyODE4NTcyMjg4Ojg0MjEzNzYsMzA4NzAwNzc0NDo4Mzg5MTIyLDMzNTU0NDMyMDA6ODM4ODYxMCwzNjIzODc4NjU2OjMyNzcwLDM4OTIzMTQxMTI6NTE0LDQxNjA3NDk1Njg6ODM4ODYwOCwxOjMyNzY4LDI2ODQzNTQ1NzoyLDUzNjg3MDkxMzo4NDIxODg4LDgwNTMwNjM2OTo4Mzg4NjA4LDEwNzM3NDE4MjU6ODQyMTM3OCwxMzQyMTc3MjgxOjMzMjgwLDE2MTA2MTI3Mzc6NTEyLDE4NzkwNDgxOTM6ODM4OTEyMiwyMTQ3NDgzNjQ5Ojg0MjE4OTAsMjQxNTkxOTEwNTo4NDIxMzc2LDI2ODQzNTQ1NjE6ODM4ODYxMCwyOTUyNzkwMDE3OjMzMjgyLDMyMjEyMjU0NzM6NTE0LDM0ODk2NjA5Mjk6ODM4OTEyMCwzNzU4MDk2Mzg1OjMyNzcwLDQwMjY1MzE4NDE6MCwxMzQyMTc3Mjk6ODQyMTg5MCw0MDI2NTMxODU6ODQyMTM3Niw2NzEwODg2NDE6ODM4ODYwOCw5Mzk1MjQwOTc6NTEyLDEyMDc5NTk1NTM6MzI3NjgsMTQ3NjM5NTAwOTo4Mzg4NjEwLDE3NDQ4MzA0NjU6MiwyMDEzMjY1OTIxOjMzMjgyLDIyODE3MDEzNzc6MzI3NzAsMjU1MDEzNjgzMzo4Mzg5MTIyLDI4MTg1NzIyODk6NTE0LDMwODcwMDc3NDU6ODQyMTg4OCwzMzU1NDQzMjAxOjgzODkxMjAsMzYyMzg3ODY1NzowLDM4OTIzMTQxMTM6MzMyODAsNDE2MDc0OTU2OTo4NDIxMzc4fSx7MDoxMDc0MjgyNTEyLDE2Nzc3MjE2OjE2Mzg0LDMzNTU0NDMyOjUyNDI4OCw1MDMzMTY0ODoxMDc0MjY2MTI4LDY3MTA4ODY0OjEwNzM3NDE4NDAsODM4ODYwODA6MTA3NDI4MjQ5NiwxMDA2NjMyOTY6MTA3Mzc1ODIwOCwxMTc0NDA1MTI6MTYsMTM0MjE3NzI4OjU0MDY3MiwxNTA5OTQ5NDQ6MTA3Mzc1ODIyNCwxNjc3NzIxNjA6MTA3Mzc0MTgyNCwxODQ1NDkzNzY6NTQwNjg4LDIwMTMyNjU5Mjo1MjQzMDQsMjE4MTAzODA4OjAsMjM0ODgxMDI0OjE2NDAwLDI1MTY1ODI0MDoxMDc0MjY2MTEyLDgzODg2MDg6MTA3Mzc1ODIwOCwyNTE2NTgyNDo1NDA2ODgsNDE5NDMwNDA6MTYsNTg3MjAyNTY6MTA3Mzc1ODIyNCw3NTQ5NzQ3MjoxMDc0MjgyNTEyLDkyMjc0Njg4OjEwNzM3NDE4MjQsMTA5MDUxOTA0OjUyNDI4OCwxMjU4MjkxMjA6MTA3NDI2NjEyOCwxNDI2MDYzMzY6NTI0MzA0LDE1OTM4MzU1MjowLDE3NjE2MDc2ODoxNjM4NCwxOTI5Mzc5ODQ6MTA3NDI2NjExMiwyMDk3MTUyMDA6MTA3Mzc0MTg0MCwyMjY0OTI0MTY6NTQwNjcyLDI0MzI2OTYzMjoxMDc0MjgyNDk2LDI2MDA0Njg0ODoxNjQwMCwyNjg0MzU0NTY6MCwyODUyMTI2NzI6MTA3NDI2NjEyOCwzMDE5ODk4ODg6MTA3Mzc1ODIyNCwzMTg3NjcxMDQ6MTA3NDI4MjQ5NiwzMzU1NDQzMjA6MTA3NDI2NjExMiwzNTIzMjE1MzY6MTYsMzY5MDk4NzUyOjU0MDY4OCwzODU4NzU5Njg6MTYzODQsNDAyNjUzMTg0OjE2NDAwLDQxOTQzMDQwMDo1MjQyODgsNDM2MjA3NjE2OjUyNDMwNCw0NTI5ODQ4MzI6MTA3Mzc0MTg0MCw0Njk3NjIwNDg6NTQwNjcyLDQ4NjUzOTI2NDoxMDczNzU4MjA4LDUwMzMxNjQ4MDoxMDczNzQxODI0LDUyMDA5MzY5NjoxMDc0MjgyNTEyLDI3NjgyNDA2NDo1NDA2ODgsMjkzNjAxMjgwOjUyNDI4OCwzMTAzNzg0OTY6MTA3NDI2NjExMiwzMjcxNTU3MTI6MTYzODQsMzQzOTMyOTI4OjEwNzM3NTgyMDgsMzYwNzEwMTQ0OjEwNzQyODI1MTIsMzc3NDg3MzYwOjE2LDM5NDI2NDU3NjoxMDczNzQxODI0LDQxMTA0MTc5MjoxMDc0MjgyNDk2LDQyNzgxOTAwODoxMDczNzQxODQwLDQ0NDU5NjIyNDoxMDczNzU4MjI0LDQ2MTM3MzQ0MDo1MjQzMDQsNDc4MTUwNjU2OjAsNDk0OTI3ODcyOjE2NDAwLDUxMTcwNTA4ODoxMDc0MjY2MTI4LDUyODQ4MjMwNDo1NDA2NzJ9LHswOjI2MCwxMDQ4NTc2OjAsMjA5NzE1Mjo2NzEwOTEyMCwzMTQ1NzI4OjY1Nzk2LDQxOTQzMDQ6NjU1NDAsNTI0Mjg4MDo2NzEwODg2OCw2MjkxNDU2OjY3MTc0NjYwLDczNDAwMzI6NjcxNzQ0MDAsODM4ODYwODo2NzEwODg2NCw5NDM3MTg0OjY3MTc0NjU2LDEwNDg1NzYwOjY1NzkyLDExNTM0MzM2OjY3MTc0NDA0LDEyNTgyOTEyOjY3MTA5MTI0LDEzNjMxNDg4OjY1NTM2LDE0NjgwMDY0OjQsMTU3Mjg2NDA6MjU2LDUyNDI4ODo2NzE3NDY1NiwxNTcyODY0OjY3MTc0NDA0LDI2MjE0NDA6MCwzNjcwMDE2OjY3MTA5MTIwLDQ3MTg1OTI6NjcxMDg4NjgsNTc2NzE2ODo2NTUzNiw2ODE1NzQ0OjY1NTQwLDc4NjQzMjA6MjYwLDg5MTI4OTY6NCw5OTYxNDcyOjI1NiwxMTAxMDA0ODo2NzE3NDQwMCwxMjA1ODYyNDo2NTc5NiwxMzEwNzIwMDo2NTc5MiwxNDE1NTc3Njo2NzEwOTEyNCwxNTIwNDM1Mjo2NzE3NDY2MCwxNjI1MjkyODo2NzEwODg2NCwxNjc3NzIxNjo2NzE3NDY1NiwxNzgyNTc5Mjo2NTU0MCwxODg3NDM2ODo2NTUzNiwxOTkyMjk0NDo2NzEwOTEyMCwyMDk3MTUyMDoyNTYsMjIwMjAwOTY6NjcxNzQ2NjAsMjMwNjg2NzI6NjcxMDg4NjgsMjQxMTcyNDg6MCwyNTE2NTgyNDo2NzEwOTEyNCwyNjIxNDQwMDo2NzEwODg2NCwyNzI2Mjk3Njo0LDI4MzExNTUyOjY1NzkyLDI5MzYwMTI4OjY3MTc0NDAwLDMwNDA4NzA0OjI2MCwzMTQ1NzI4MDo2NTc5NiwzMjUwNTg1Njo2NzE3NDQwNCwxNzMwMTUwNDo2NzEwODg2NCwxODM1MDA4MDoyNjAsMTkzOTg2NTY6NjcxNzQ2NTYsMjA0NDcyMzI6MCwyMTQ5NTgwODo2NTU0MCwyMjU0NDM4NDo2NzEwOTEyMCwyMzU5Mjk2MDoyNTYsMjQ2NDE1MzY6NjcxNzQ0MDQsMjU2OTAxMTI6NjU1MzYsMjY3Mzg2ODg6NjcxNzQ2NjAsMjc3ODcyNjQ6NjU3OTYsMjg4MzU4NDA6NjcxMDg4NjgsMjk4ODQ0MTY6NjcxMDkxMjQsMzA5MzI5OTI6NjcxNzQ0MDAsMzE5ODE1Njg6NCwzMzAzMDE0NDo2NTc5Mn0sezA6MjE1MTY4MjA0OCw2NTUzNjoyMTQ3NDg3ODA4LDEzMTA3Mjo0MTk4NDY0LDE5NjYwODoyMTUxNjc3OTUyLDI2MjE0NDowLDMyNzY4MDo0MTk4NDAwLDM5MzIxNjoyMTQ3NDgzNzEyLDQ1ODc1Mjo0MTk0MzY4LDUyNDI4ODoyMTQ3NDgzNjQ4LDU4OTgyNDo0MTk0MzA0LDY1NTM2MDo2NCw3MjA4OTY6MjE0NzQ4Nzc0NCw3ODY0MzI6MjE1MTY3ODAxNiw4NTE5Njg6NDE2MCw5MTc1MDQ6NDA5Niw5ODMwNDA6MjE1MTY4MjExMiwzMjc2ODoyMTQ3NDg3ODA4LDk4MzA0OjY0LDE2Mzg0MDoyMTUxNjc4MDE2LDIyOTM3NjoyMTQ3NDg3NzQ0LDI5NDkxMjo0MTk4NDAwLDM2MDQ0ODoyMTUxNjgyMTEyLDQyNTk4NDowLDQ5MTUyMDoyMTUxNjc3OTUyLDU1NzA1Njo0MDk2LDYyMjU5MjoyMTUxNjgyMDQ4LDY4ODEyODo0MTk0MzA0LDc1MzY2NDo0MTYwLDgxOTIwMDoyMTQ3NDgzNjQ4LDg4NDczNjo0MTk0MzY4LDk1MDI3Mjo0MTk4NDY0LDEwMTU4MDg6MjE0NzQ4MzcxMiwxMDQ4NTc2OjQxOTQzNjgsMTExNDExMjo0MTk4NDAwLDExNzk2NDg6MjE0NzQ4MzcxMiwxMjQ1MTg0OjAsMTMxMDcyMDo0MTYwLDEzNzYyNTY6MjE1MTY3ODAxNiwxNDQxNzkyOjIxNTE2ODIwNDgsMTUwNzMyODoyMTQ3NDg3ODA4LDE1NzI4NjQ6MjE1MTY4MjExMiwxNjM4NDAwOjIxNDc0ODM2NDgsMTcwMzkzNjoyMTUxNjc3OTUyLDE3Njk0NzI6NDE5ODQ2NCwxODM1MDA4OjIxNDc0ODc3NDQsMTkwMDU0NDo0MTk0MzA0LDE5NjYwODA6NjQsMjAzMTYxNjo0MDk2LDEwODEzNDQ6MjE1MTY3Nzk1MiwxMTQ2ODgwOjIxNTE2ODIxMTIsMTIxMjQxNjowLDEyNzc5NTI6NDE5ODQwMCwxMzQzNDg4OjQxOTQzNjgsMTQwOTAyNDoyMTQ3NDgzNjQ4LDE0NzQ1NjA6MjE0NzQ4NzgwOCwxNTQwMDk2OjY0LDE2MDU2MzI6MjE0NzQ4MzcxMiwxNjcxMTY4OjQwOTYsMTczNjcwNDoyMTQ3NDg3NzQ0LDE4MDIyNDA6MjE1MTY3ODAxNiwxODY3Nzc2OjQxNjAsMTkzMzMxMjoyMTUxNjgyMDQ4LDE5OTg4NDg6NDE5NDMwNCwyMDY0Mzg0OjQxOTg0NjR9LHswOjEyOCw0MDk2OjE3MDM5MzYwLDgxOTI6MjYyMTQ0LDEyMjg4OjUzNjg3MDkxMiwxNjM4NDo1MzcxMzMxODQsMjA0ODA6MTY3NzczNDQsMjQ1NzY6NTUzNjQ4MjU2LDI4NjcyOjI2MjI3MiwzMjc2ODoxNjc3NzIxNiwzNjg2NDo1MzcxMzMwNTYsNDA5NjA6NTM2ODcxMDQwLDQ1MDU2OjU1MzkxMDQwMCw0OTE1Mjo1NTM5MTAyNzIsNTMyNDg6MCw1NzM0NDoxNzAzOTQ4OCw2MTQ0MDo1NTM2NDgxMjgsMjA0ODoxNzAzOTQ4OCw2MTQ0OjU1MzY0ODI1NiwxMDI0MDoxMjgsMTQzMzY6MTcwMzkzNjAsMTg0MzI6MjYyMTQ0LDIyNTI4OjUzNzEzMzE4NCwyNjYyNDo1NTM5MTAyNzIsMzA3MjA6NTM2ODcwOTEyLDM0ODE2OjUzNzEzMzA1NiwzODkxMjowLDQzMDA4OjU1MzkxMDQwMCw0NzEwNDoxNjc3NzM0NCw1MTIwMDo1MzY4NzEwNDAsNTUyOTY6NTUzNjQ4MTI4LDU5MzkyOjE2Nzc3MjE2LDYzNDg4OjI2MjI3Miw2NTUzNjoyNjIxNDQsNjk2MzI6MTI4LDczNzI4OjUzNjg3MDkxMiw3NzgyNDo1NTM2NDgyNTYsODE5MjA6MTY3NzczNDQsODYwMTY6NTUzOTEwMjcyLDkwMTEyOjUzNzEzMzE4NCw5NDIwODoxNjc3NzIxNiw5ODMwNDo1NTM5MTA0MDAsMTAyNDAwOjU1MzY0ODEyOCwxMDY0OTY6MTcwMzkzNjAsMTEwNTkyOjUzNzEzMzA1NiwxMTQ2ODg6MjYyMjcyLDExODc4NDo1MzY4NzEwNDAsMTIyODgwOjAsMTI2OTc2OjE3MDM5NDg4LDY3NTg0OjU1MzY0ODI1Niw3MTY4MDoxNjc3NzIxNiw3NTc3NjoxNzAzOTM2MCw3OTg3Mjo1MzcxMzMxODQsODM5Njg6NTM2ODcwOTEyLDg4MDY0OjE3MDM5NDg4LDkyMTYwOjEyOCw5NjI1Njo1NTM5MTAyNzIsMTAwMzUyOjI2MjI3MiwxMDQ0NDg6NTUzOTEwNDAwLDEwODU0NDowLDExMjY0MDo1NTM2NDgxMjgsMTE2NzM2OjE2Nzc3MzQ0LDEyMDgzMjoyNjIxNDQsMTI0OTI4OjUzNzEzMzA1NiwxMjkwMjQ6NTM2ODcxMDQwfSx7MDoyNjg0MzU0NjQsMjU2OjgxOTIsNTEyOjI3MDUzMjYwOCw3Njg6MjcwNTQwODA4LDEwMjQ6MjY4NDQzNjQ4LDEyODA6MjA5NzE1MiwxNTM2OjIwOTcxNjAsMTc5MjoyNjg0MzU0NTYsMjA0ODowLDIzMDQ6MjY4NDQzNjU2LDI1NjA6MjEwNTM0NCwyODE2OjgsMzA3MjoyNzA1MzI2MTYsMzMyODoyMTA1MzUyLDM1ODQ6ODIwMCwzODQwOjI3MDU0MDgwMCwxMjg6MjcwNTMyNjA4LDM4NDoyNzA1NDA4MDgsNjQwOjgsODk2OjIwOTcxNTIsMTE1MjoyMTA1MzUyLDE0MDg6MjY4NDM1NDY0LDE2NjQ6MjY4NDQzNjQ4LDE5MjA6ODIwMCwyMTc2OjIwOTcxNjAsMjQzMjo4MTkyLDI2ODg6MjY4NDQzNjU2LDI5NDQ6MjcwNTMyNjE2LDMyMDA6MCwzNDU2OjI3MDU0MDgwMCwzNzEyOjIxMDUzNDQsMzk2ODoyNjg0MzU0NTYsNDA5NjoyNjg0NDM2NDgsNDM1MjoyNzA1MzI2MTYsNDYwODoyNzA1NDA4MDgsNDg2NDo4MjAwLDUxMjA6MjA5NzE1Miw1Mzc2OjI2ODQzNTQ1Niw1NjMyOjI2ODQzNTQ2NCw1ODg4OjIxMDUzNDQsNjE0NDoyMTA1MzUyLDY0MDA6MCw2NjU2OjgsNjkxMjoyNzA1MzI2MDgsNzE2ODo4MTkyLDc0MjQ6MjY4NDQzNjU2LDc2ODA6MjcwNTQwODAwLDc5MzY6MjA5NzE2MCw0MjI0OjgsNDQ4MDoyMTA1MzQ0LDQ3MzY6MjA5NzE1Miw0OTkyOjI2ODQzNTQ2NCw1MjQ4OjI2ODQ0MzY0OCw1NTA0OjgyMDAsNTc2MDoyNzA1NDA4MDgsNjAxNjoyNzA1MzI2MDgsNjI3MjoyNzA1NDA4MDAsNjUyODoyNzA1MzI2MTYsNjc4NDo4MTkyLDcwNDA6MjEwNTM1Miw3Mjk2OjIwOTcxNjAsNzU1MjowLDc4MDg6MjY4NDM1NDU2LDgwNjQ6MjY4NDQzNjU2fSx7MDoxMDQ4NTc2LDE2OjMzNTU1NDU3LDMyOjEwMjQsNDg6MTA0OTYwMSw2NDozNDYwNDAzMyw4MDowLDk2OjEsMTEyOjM0NjAzMDA5LDEyODozMzU1NTQ1NiwxNDQ6MTA0ODU3NywxNjA6MzM1NTQ0MzMsMTc2OjM0NjA0MDMyLDE5MjozNDYwMzAwOCwyMDg6MTAyNSwyMjQ6MTA0OTYwMCwyNDA6MzM1NTQ0MzIsODozNDYwMzAwOSwyNDowLDQwOjMzNTU1NDU3LDU2OjM0NjA0MDMyLDcyOjEwNDg1NzYsODg6MzM1NTQ0MzMsMTA0OjMzNTU0NDMyLDEyMDoxMDI1LDEzNjoxMDQ5NjAxLDE1MjozMzU1NTQ1NiwxNjg6MzQ2MDMwMDgsMTg0OjEwNDg1NzcsMjAwOjEwMjQsMjE2OjM0NjA0MDMzLDIzMjoxLDI0ODoxMDQ5NjAwLDI1NjozMzU1NDQzMiwyNzI6MTA0ODU3NiwyODg6MzM1NTU0NTcsMzA0OjM0NjAzMDA5LDMyMDoxMDQ4NTc3LDMzNjozMzU1NTQ1NiwzNTI6MzQ2MDQwMzIsMzY4OjEwNDk2MDEsMzg0OjEwMjUsNDAwOjM0NjA0MDMzLDQxNjoxMDQ5NjAwLDQzMjoxLDQ0ODowLDQ2NDozNDYwMzAwOCw0ODA6MzM1NTQ0MzMsNDk2OjEwMjQsMjY0OjEwNDk2MDAsMjgwOjMzNTU1NDU3LDI5NjozNDYwMzAwOSwzMTI6MSwzMjg6MzM1NTQ0MzIsMzQ0OjEwNDg1NzYsMzYwOjEwMjUsMzc2OjM0NjA0MDMyLDM5MjozMzU1NDQzMyw0MDg6MzQ2MDMwMDgsNDI0OjAsNDQwOjM0NjA0MDMzLDQ1NjoxMDQ5NjAxLDQ3MjoxMDI0LDQ4ODozMzU1NTQ1Niw1MDQ6MTA0ODU3N30sezA6MTM0MjE5ODA4LDE6MTMxMDcyLDI6MTM0MjE3NzI4LDM6MzIsNDoxMzExMDQsNToxMzQzNTA4ODAsNjoxMzQzNTA4NDgsNzoyMDQ4LDg6MTM0MzQ4ODAwLDk6MTM0MjE5Nzc2LDEwOjEzMzEyMCwxMToxMzQzNDg4MzIsMTI6MjA4MCwxMzowLDE0OjEzNDIxNzc2MCwxNToxMzMxNTIsMjE0NzQ4MzY0ODoyMDQ4LDIxNDc0ODM2NDk6MTM0MzUwODgwLDIxNDc0ODM2NTA6MTM0MjE5ODA4LDIxNDc0ODM2NTE6MTM0MjE3NzI4LDIxNDc0ODM2NTI6MTM0MzQ4ODAwLDIxNDc0ODM2NTM6MTMzMTIwLDIxNDc0ODM2NTQ6MTMzMTUyLDIxNDc0ODM2NTU6MzIsMjE0NzQ4MzY1NjoxMzQyMTc3NjAsMjE0NzQ4MzY1NzoyMDgwLDIxNDc0ODM2NTg6MTMxMTA0LDIxNDc0ODM2NTk6MTM0MzUwODQ4LDIxNDc0ODM2NjA6MCwyMTQ3NDgzNjYxOjEzNDM0ODgzMiwyMTQ3NDgzNjYyOjEzNDIxOTc3NiwyMTQ3NDgzNjYzOjEzMTA3MiwxNjoxMzMxNTIsMTc6MTM0MzUwODQ4LDE4OjMyLDE5OjIwNDgsMjA6MTM0MjE5Nzc2LDIxOjEzNDIxNzc2MCwyMjoxMzQzNDg4MzIsMjM6MTMxMDcyLDI0OjAsMjU6MTMxMTA0LDI2OjEzNDM0ODgwMCwyNzoxMzQyMTk4MDgsMjg6MTM0MzUwODgwLDI5OjEzMzEyMCwzMDoyMDgwLDMxOjEzNDIxNzcyOCwyMTQ3NDgzNjY0OjEzMTA3MiwyMTQ3NDgzNjY1OjIwNDgsMjE0NzQ4MzY2NjoxMzQzNDg4MzIsMjE0NzQ4MzY2NzoxMzMxNTIsMjE0NzQ4MzY2ODozMiwyMTQ3NDgzNjY5OjEzNDM0ODgwMCwyMTQ3NDgzNjcwOjEzNDIxNzcyOCwyMTQ3NDgzNjcxOjEzNDIxOTgwOCwyMTQ3NDgzNjcyOjEzNDM1MDg4MCwyMTQ3NDgzNjczOjEzNDIxNzc2MCwyMTQ3NDgzNjc0OjEzNDIxOTc3NiwyMTQ3NDgzNjc1OjAsMjE0NzQ4MzY3NjoxMzMxMjAsMjE0NzQ4MzY3NzoyMDgwLDIxNDc0ODM2Nzg6MTMxMTA0LDIxNDc0ODM2Nzk6MTM0MzUwODQ4fV07XG52YXIgU0JPWF9NQVNLPVs0MTYwNzQ5NTY5LDUyODQ4MjMwNCwzMzAzMDE0NCwyMDY0Mzg0LDEyOTAyNCw4MDY0LDUwNCwyMTQ3NDgzNjc5XTt2YXIgREVTPUNfYWxnby5ERVM9QmxvY2tDaXBoZXIuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3ZhciBrZXk9dGhpcy5fa2V5O3ZhciBrZXlXb3Jkcz1rZXkud29yZHM7dmFyIGtleUJpdHM9W107Zm9yKHZhciBpPTA7aTw1NjtpKyspe3ZhciBrZXlCaXRQb3M9UEMxW2ldLTE7a2V5Qml0c1tpXT1rZXlXb3Jkc1trZXlCaXRQb3M+Pj41XT4+PjMxLWtleUJpdFBvcyUzMiYxfXZhciBzdWJLZXlzPXRoaXMuX3N1YktleXM9W107Zm9yKHZhciBuU3ViS2V5PTA7blN1YktleTwxNjtuU3ViS2V5Kyspe3ZhciBzdWJLZXk9c3ViS2V5c1tuU3ViS2V5XT1bXTt2YXIgYml0U2hpZnQ9QklUX1NISUZUU1tuU3ViS2V5XTtmb3IodmFyIGk9MDtpPDI0O2krKyl7c3ViS2V5W2kvNnwwXXw9a2V5Qml0c1soUEMyW2ldLTErYml0U2hpZnQpJTI4XTw8MzEtaSU2O3N1YktleVs0KyhpLzZ8MCldfD1rZXlCaXRzWzI4KyhQQzJbaSsyNF0tMStiaXRTaGlmdCklMjhdPDwzMS1pJTZ9c3ViS2V5WzBdPXN1YktleVswXTw8MXxzdWJLZXlbMF0+Pj4zMTtmb3IodmFyIGk9MTtpPDc7aSsrKXtzdWJLZXlbaV09c3ViS2V5W2ldPj4+KGktMSkqNCszfXN1YktleVs3XT1zdWJLZXlbN108PDV8c3ViS2V5WzddPj4+Mjd9dmFyIGludlN1YktleXM9dGhpcy5faW52U3ViS2V5cz1bXTtmb3IodmFyIGk9MDtpPDE2O2krKyl7aW52U3ViS2V5c1tpXT1zdWJLZXlzWzE1LWldfX0sZW5jcnlwdEJsb2NrOmZ1bmN0aW9uKE0sb2Zmc2V0KXt0aGlzLl9kb0NyeXB0QmxvY2soTSxvZmZzZXQsdGhpcy5fc3ViS2V5cyl9LGRlY3J5cHRCbG9jazpmdW5jdGlvbihNLG9mZnNldCl7dGhpcy5fZG9DcnlwdEJsb2NrKE0sb2Zmc2V0LHRoaXMuX2ludlN1YktleXMpfSxfZG9DcnlwdEJsb2NrOmZ1bmN0aW9uKE0sb2Zmc2V0LHN1YktleXMpe3RoaXMuX2xCbG9jaz1NW29mZnNldF07dGhpcy5fckJsb2NrPU1bb2Zmc2V0KzFdO2V4Y2hhbmdlTFIuY2FsbCh0aGlzLDQsMjUyNjQ1MTM1KTtleGNoYW5nZUxSLmNhbGwodGhpcywxNiw2NTUzNSk7ZXhjaGFuZ2VSTC5jYWxsKHRoaXMsMiw4NTg5OTM0NTkpO2V4Y2hhbmdlUkwuY2FsbCh0aGlzLDgsMTY3MTE5MzUpO2V4Y2hhbmdlTFIuY2FsbCh0aGlzLDEsMTQzMTY1NTc2NSk7Zm9yKHZhciByb3VuZD0wO3JvdW5kPDE2O3JvdW5kKyspe3ZhciBzdWJLZXk9c3ViS2V5c1tyb3VuZF07dmFyIGxCbG9jaz10aGlzLl9sQmxvY2s7dmFyIHJCbG9jaz10aGlzLl9yQmxvY2s7dmFyIGY9MDtmb3IodmFyIGk9MDtpPDg7aSsrKXtmfD1TQk9YX1BbaV1bKChyQmxvY2tec3ViS2V5W2ldKSZTQk9YX01BU0tbaV0pPj4+MF19dGhpcy5fbEJsb2NrPXJCbG9jazt0aGlzLl9yQmxvY2s9bEJsb2NrXmZ9dmFyIHQ9dGhpcy5fbEJsb2NrO3RoaXMuX2xCbG9jaz10aGlzLl9yQmxvY2s7dGhpcy5fckJsb2NrPXQ7ZXhjaGFuZ2VMUi5jYWxsKHRoaXMsMSwxNDMxNjU1NzY1KTtleGNoYW5nZVJMLmNhbGwodGhpcyw4LDE2NzExOTM1KTtleGNoYW5nZVJMLmNhbGwodGhpcywyLDg1ODk5MzQ1OSk7ZXhjaGFuZ2VMUi5jYWxsKHRoaXMsMTYsNjU1MzUpO2V4Y2hhbmdlTFIuY2FsbCh0aGlzLDQsMjUyNjQ1MTM1KTtNW29mZnNldF09dGhpcy5fbEJsb2NrO01bb2Zmc2V0KzFdPXRoaXMuX3JCbG9ja30sa2V5U2l6ZTo2NC8zMixpdlNpemU6NjQvMzIsYmxvY2tTaXplOjY0LzMyfSk7ZnVuY3Rpb24gZXhjaGFuZ2VMUihvZmZzZXQsbWFzayl7dmFyIHQ9KHRoaXMuX2xCbG9jaz4+Pm9mZnNldF50aGlzLl9yQmxvY2spJm1hc2s7dGhpcy5fckJsb2NrXj10O3RoaXMuX2xCbG9ja149dDw8b2Zmc2V0fWZ1bmN0aW9uIGV4Y2hhbmdlUkwob2Zmc2V0LG1hc2spe3ZhciB0PSh0aGlzLl9yQmxvY2s+Pj5vZmZzZXRedGhpcy5fbEJsb2NrKSZtYXNrO3RoaXMuX2xCbG9ja149dDt0aGlzLl9yQmxvY2tePXQ8PG9mZnNldH1DLkRFUz1CbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKERFUyk7dmFyIFRyaXBsZURFUz1DX2FsZ28uVHJpcGxlREVTPUJsb2NrQ2lwaGVyLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt2YXIga2V5PXRoaXMuX2tleTt2YXIga2V5V29yZHM9a2V5LndvcmRzO3RoaXMuX2RlczE9REVTLmNyZWF0ZUVuY3J5cHRvcihXb3JkQXJyYXkuY3JlYXRlKGtleVdvcmRzLnNsaWNlKDAsMikpKTt0aGlzLl9kZXMyPURFUy5jcmVhdGVFbmNyeXB0b3IoV29yZEFycmF5LmNyZWF0ZShrZXlXb3Jkcy5zbGljZSgyLDQpKSk7dGhpcy5fZGVzMz1ERVMuY3JlYXRlRW5jcnlwdG9yKFdvcmRBcnJheS5jcmVhdGUoa2V5V29yZHMuc2xpY2UoNCw2KSkpfSxlbmNyeXB0QmxvY2s6ZnVuY3Rpb24oTSxvZmZzZXQpe3RoaXMuX2RlczEuZW5jcnlwdEJsb2NrKE0sb2Zmc2V0KTt0aGlzLl9kZXMyLmRlY3J5cHRCbG9jayhNLG9mZnNldCk7dGhpcy5fZGVzMy5lbmNyeXB0QmxvY2soTSxvZmZzZXQpfSxkZWNyeXB0QmxvY2s6ZnVuY3Rpb24oTSxvZmZzZXQpe3RoaXMuX2RlczMuZGVjcnlwdEJsb2NrKE0sb2Zmc2V0KTt0aGlzLl9kZXMyLmVuY3J5cHRCbG9jayhNLG9mZnNldCk7dGhpcy5fZGVzMS5kZWNyeXB0QmxvY2soTSxvZmZzZXQpfSxrZXlTaXplOjE5Mi8zMixpdlNpemU6NjQvMzIsYmxvY2tTaXplOjY0LzMyfSk7Qy5UcmlwbGVERVM9QmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihUcmlwbGVERVMpfSkoKTtyZXR1cm4gQ3J5cHRvSlMuVHJpcGxlREVTfSl9LHtcIi4vY2lwaGVyLWNvcmVcIjoxOSxcIi4vY29yZVwiOjIwLFwiLi9lbmMtYmFzZTY0XCI6MjEsXCIuL2V2cGtkZlwiOjIzLFwiLi9tZDVcIjoyOX1dLDUyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5KXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbih1bmRlZmluZWQpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgQmFzZT1DX2xpYi5CYXNlO3ZhciBYMzJXb3JkQXJyYXk9Q19saWIuV29yZEFycmF5O3ZhciBDX3g2ND1DLng2ND17fTt2YXIgWDY0V29yZD1DX3g2NC5Xb3JkPUJhc2UuZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKGhpZ2gsbG93KXt0aGlzLmhpZ2g9aGlnaDt0aGlzLmxvdz1sb3d9fSk7dmFyIFg2NFdvcmRBcnJheT1DX3g2NC5Xb3JkQXJyYXk9QmFzZS5leHRlbmQoe2luaXQ6ZnVuY3Rpb24od29yZHMsc2lnQnl0ZXMpe3dvcmRzPXRoaXMud29yZHM9d29yZHN8fFtdO2lmKHNpZ0J5dGVzIT11bmRlZmluZWQpe3RoaXMuc2lnQnl0ZXM9c2lnQnl0ZXN9ZWxzZXt0aGlzLnNpZ0J5dGVzPXdvcmRzLmxlbmd0aCo4fX0sdG9YMzI6ZnVuY3Rpb24oKXt2YXIgeDY0V29yZHM9dGhpcy53b3Jkczt2YXIgeDY0V29yZHNMZW5ndGg9eDY0V29yZHMubGVuZ3RoO3ZhciB4MzJXb3Jkcz1bXTtmb3IodmFyIGk9MDtpPHg2NFdvcmRzTGVuZ3RoO2krKyl7dmFyIHg2NFdvcmQ9eDY0V29yZHNbaV07eDMyV29yZHMucHVzaCh4NjRXb3JkLmhpZ2gpO3gzMldvcmRzLnB1c2goeDY0V29yZC5sb3cpfXJldHVybiBYMzJXb3JkQXJyYXkuY3JlYXRlKHgzMldvcmRzLHRoaXMuc2lnQnl0ZXMpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciBjbG9uZT1CYXNlLmNsb25lLmNhbGwodGhpcyk7dmFyIHdvcmRzPWNsb25lLndvcmRzPXRoaXMud29yZHMuc2xpY2UoMCk7dmFyIHdvcmRzTGVuZ3RoPXdvcmRzLmxlbmd0aDtmb3IodmFyIGk9MDtpPHdvcmRzTGVuZ3RoO2krKyl7d29yZHNbaV09d29yZHNbaV0uY2xvbmUoKX1yZXR1cm4gY2xvbmV9fSl9KSgpO3JldHVybiBDcnlwdG9KU30pfSx7XCIuL2NvcmVcIjoyMH1dLDUzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocHJvY2Vzcyl7IWZ1bmN0aW9uKGdsb2JhbHMpe1widXNlIHN0cmljdFwiO2lmKHR5cGVvZiBkZWZpbmUhPT1cInVuZGVmaW5lZFwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZnVuY3Rpb24oKXtyZXR1cm4gc2VjdXJlUmFuZG9tfSl9ZWxzZSBpZih0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIiYmbW9kdWxlLmV4cG9ydHMpe21vZHVsZS5leHBvcnRzPXNlY3VyZVJhbmRvbX1lbHNle2dsb2JhbHMuc2VjdXJlUmFuZG9tPXNlY3VyZVJhbmRvbX1mdW5jdGlvbiBzZWN1cmVSYW5kb20oY291bnQsb3B0aW9ucyl7b3B0aW9ucz1vcHRpb25zfHx7fTtpZih0eXBlb2YgcHJvY2VzcyE9XCJ1bmRlZmluZWRcIiYmdHlwZW9mIHByb2Nlc3MucGlkPT1cIm51bWJlclwiKXtyZXR1cm4gbm9kZVJhbmRvbShjb3VudCxvcHRpb25zKX1lbHNle2lmKCF3aW5kb3cuY3J5cHRvKXRocm93IG5ldyBFcnJvcihcIllvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHdpbmRvdy5jcnlwdG8uXCIpO3JldHVybiBicm93c2VyUmFuZG9tKGNvdW50LG9wdGlvbnMpfX1mdW5jdGlvbiBub2RlUmFuZG9tKGNvdW50LG9wdGlvbnMpe3ZhciBjcnlwdG89X2RlcmVxXyhcImNyeXB0b1wiKTt2YXIgYnVmPWNyeXB0by5yYW5kb21CeXRlcyhjb3VudCk7aWYob3B0aW9ucy5hcnJheSl2YXIgcmV0PVtdO2Vsc2UgdmFyIHJldD1uZXcgVWludDhBcnJheShjb3VudCk7Zm9yKHZhciBpPTA7aTxjb3VudDsrK2kpe3JldFtpXT1idWYucmVhZFVJbnQ4KGkpfXJldHVybiByZXR9ZnVuY3Rpb24gYnJvd3NlclJhbmRvbShjb3VudCxvcHRpb25zKXt2YXIgbmF0aXZlQXJyPW5ldyBVaW50OEFycmF5KGNvdW50KTt3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuYXRpdmVBcnIpO2lmKG9wdGlvbnMuYXJyYXkpe3ZhciByZXQ9W107Zm9yKHZhciBpPTA7aTxuYXRpdmVBcnIubGVuZ3RoOysraSl7cmV0W2ldPW5hdGl2ZUFycltpXX19ZWxzZXtyZXQ9bmF0aXZlQXJyfXJldHVybiByZXR9fSh0aGlzKX0pLmNhbGwodGhpcyxfZGVyZXFfKFwiRldhQVNIXCIpKX0se0ZXYUFTSDoxNSxjcnlwdG86NH1dLDU0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgYmFzZTU4PV9kZXJlcV8oXCIuL2Jhc2U1OFwiKTt2YXIgYmFzZTU4Y2hlY2s9X2RlcmVxXyhcIi4vYmFzZTU4Y2hlY2tcIik7dmFyIGNvbnZlcnQ9X2RlcmVxXyhcIi4vY29udmVydFwiKTt2YXIgZXJyb3I9X2RlcmVxXyhcIi4vdXRpbFwiKS5lcnJvcjt2YXIgbWFpbm5ldD1fZGVyZXFfKFwiLi9uZXR3b3JrXCIpLm1haW5uZXQuYWRkcmVzc1ZlcnNpb247ZnVuY3Rpb24gQWRkcmVzcyhieXRlcyx2ZXJzaW9uKXtpZighKHRoaXMgaW5zdGFuY2VvZiBBZGRyZXNzKSl7cmV0dXJuIG5ldyBBZGRyZXNzKGJ5dGVzLHZlcnNpb24pfWlmKGJ5dGVzIGluc3RhbmNlb2YgQWRkcmVzcyl7dGhpcy5oYXNoPWJ5dGVzLmhhc2g7dGhpcy52ZXJzaW9uPWJ5dGVzLnZlcnNpb259ZWxzZSBpZih0eXBlb2YgYnl0ZXM9PT1cInN0cmluZ1wiKXtpZihieXRlcy5sZW5ndGg8PTM1KXt2YXIgZGVjb2RlPWJhc2U1OGNoZWNrLmRlY29kZShieXRlcyk7dGhpcy5oYXNoPWRlY29kZS5wYXlsb2FkO3RoaXMudmVyc2lvbj1kZWNvZGUudmVyc2lvbn1lbHNlIGlmKGJ5dGVzLmxlbmd0aDw9NDApe3RoaXMuaGFzaD1jb252ZXJ0LmhleFRvQnl0ZXMoYnl0ZXMpO3RoaXMudmVyc2lvbj12ZXJzaW9ufHxtYWlubmV0fWVsc2V7ZXJyb3IoXCJpbnZhbGlkIG9yIHVucmVjb2duaXplZCBpbnB1dFwiKX19ZWxzZXt0aGlzLmhhc2g9Ynl0ZXM7dGhpcy52ZXJzaW9uPXZlcnNpb258fG1haW5uZXR9fUFkZHJlc3MucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIGJhc2U1OGNoZWNrLmVuY29kZSh0aGlzLmhhc2guc2xpY2UoMCksdGhpcy52ZXJzaW9uKX07QWRkcmVzcy5nZXRWZXJzaW9uPWZ1bmN0aW9uKGFkZHJlc3Mpe3JldHVybiBiYXNlNTguZGVjb2RlKGFkZHJlc3MpWzBdfTtBZGRyZXNzLnZhbGlkYXRlPWZ1bmN0aW9uKGFkZHJlc3Mpe3RyeXtiYXNlNThjaGVjay5kZWNvZGUoYWRkcmVzcyk7cmV0dXJuIHRydWV9Y2F0Y2goZSl7cmV0dXJuIGZhbHNlfX07bW9kdWxlLmV4cG9ydHM9QWRkcmVzc30se1wiLi9iYXNlNThcIjo1NSxcIi4vYmFzZTU4Y2hlY2tcIjo1NixcIi4vY29udmVydFwiOjU3LFwiLi9uZXR3b3JrXCI6NjYsXCIuL3V0aWxcIjo3MH1dLDU1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oQnVmZmVyKXt2YXIgQmlnSW50ZWdlcj1fZGVyZXFfKFwiLi9qc2JuL2pzYm5cIik7dmFyIGFscGhhYmV0PVwiMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5elwiO3ZhciBiYXNlPUJpZ0ludGVnZXIudmFsdWVPZig1OCk7dmFyIGFscGhhYmV0TWFwPXt9O2Zvcih2YXIgaT0wO2k8YWxwaGFiZXQubGVuZ3RoOysraSl7dmFyIGNocj1hbHBoYWJldFtpXTthbHBoYWJldE1hcFtjaHJdPUJpZ0ludGVnZXIudmFsdWVPZihpKX1mdW5jdGlvbiBlbmNvZGUoYnVmZmVyKXt2YXIgYmk9QmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQoYnVmZmVyKTt2YXIgY2hhcnM9W107d2hpbGUoYmkuY29tcGFyZVRvKGJhc2UpPj0wKXt2YXIgbW9kPWJpLm1vZChiYXNlKTtiaT1iaS5zdWJ0cmFjdChtb2QpLmRpdmlkZShiYXNlKTtjaGFycy5wdXNoKGFscGhhYmV0W21vZC5pbnRWYWx1ZSgpXSl9Y2hhcnMucHVzaChhbHBoYWJldFtiaS5pbnRWYWx1ZSgpXSk7Zm9yKHZhciBpPTA7aTxidWZmZXIubGVuZ3RoO2krKyl7aWYoYnVmZmVyW2ldIT09MClicmVhaztjaGFycy5wdXNoKGFscGhhYmV0WzBdKX1yZXR1cm4gY2hhcnMucmV2ZXJzZSgpLmpvaW4oXCJcIil9ZnVuY3Rpb24gZGVjb2RlKHN0cil7dmFyIG51bT1CaWdJbnRlZ2VyLnZhbHVlT2YoMCk7dmFyIGxlYWRpbmdfemVybz0wO3ZhciBzZWVuX290aGVyPWZhbHNlO2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe3ZhciBjaHI9c3RyW2ldO3ZhciBiaT1hbHBoYWJldE1hcFtjaHJdO2lmKGJpPT09dW5kZWZpbmVkKXt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJhc2U1OCBzdHJpbmc6IFwiK3N0cil9bnVtPW51bS5tdWx0aXBseShiYXNlKS5hZGQoYmkpO2lmKGNocj09PVwiMVwiJiYhc2Vlbl9vdGhlcil7KytsZWFkaW5nX3plcm99ZWxzZXtzZWVuX290aGVyPXRydWV9fXZhciBieXRlcz1udW0udG9CeXRlQXJyYXlVbnNpZ25lZCgpO3doaWxlKGxlYWRpbmdfemVyby0tPjApe2J5dGVzLnVuc2hpZnQoMCl9cmV0dXJuIG5ldyBCdWZmZXIoYnl0ZXMpfW1vZHVsZS5leHBvcnRzPXtlbmNvZGU6ZW5jb2RlLGRlY29kZTpkZWNvZGV9fSkuY2FsbCh0aGlzLF9kZXJlcV8oXCJidWZmZXJcIikuQnVmZmVyKX0se1wiLi9qc2JuL2pzYm5cIjo2MyxidWZmZXI6NX1dLDU2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oQnVmZmVyKXt2YXIgYXNzZXJ0PV9kZXJlcV8oXCJhc3NlcnRcIik7dmFyIGJhc2U1OD1fZGVyZXFfKFwiLi9iYXNlNThcIik7dmFyIGNyeXB0bz1fZGVyZXFfKFwiY3J5cHRvXCIpO2Z1bmN0aW9uIHNoYTI1NihidWYpe3ZhciBoYXNoPWNyeXB0by5jcmVhdGVIYXNoKFwic2hhMjU2XCIpO2hhc2gudXBkYXRlKGJ1Zik7cmV0dXJuIGhhc2guZGlnZXN0KCl9ZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlcix2ZXJzaW9uKXt2ZXJzaW9uPXZlcnNpb258fDA7dmFyIHZlcnNpb249bmV3IEJ1ZmZlcihbdmVyc2lvbl0pO3ZhciBwYXlsb2FkPW5ldyBCdWZmZXIoYnVmZmVyKTt2YXIgbWVzc2FnZT1CdWZmZXIuY29uY2F0KFt2ZXJzaW9uLHBheWxvYWRdKTt2YXIgY2hlY2tzdW09c2hhMjU2KHNoYTI1NihtZXNzYWdlKSkuc2xpY2UoMCw0KTtyZXR1cm4gYmFzZTU4LmVuY29kZShCdWZmZXIuY29uY2F0KFttZXNzYWdlLGNoZWNrc3VtXSkpfWZ1bmN0aW9uIGRlY29kZShzdHJpbmcpe3ZhciBidWZmZXI9YmFzZTU4LmRlY29kZShzdHJpbmcpO3ZhciBtZXNzYWdlPWJ1ZmZlci5zbGljZSgwLC00KTt2YXIgY2hlY2tzdW09YnVmZmVyLnNsaWNlKC00KTt2YXIgbmV3Q2hlY2tzdW09c2hhMjU2KHNoYTI1NihtZXNzYWdlKSkuc2xpY2UoMCw0KTthc3NlcnQuZGVlcEVxdWFsKG5ld0NoZWNrc3VtLGNoZWNrc3VtKTt2YXIgdmVyc2lvbj1tZXNzYWdlLnJlYWRVSW50OCgwKTt2YXIgcGF5bG9hZD1tZXNzYWdlLnNsaWNlKDEpO3JldHVybnt2ZXJzaW9uOnZlcnNpb24scGF5bG9hZDpwYXlsb2FkLGNoZWNrc3VtOmNoZWNrc3VtfX1tb2R1bGUuZXhwb3J0cz17ZW5jb2RlOmVuY29kZSxkZWNvZGU6ZGVjb2RlfX0pLmNhbGwodGhpcyxfZGVyZXFfKFwiYnVmZmVyXCIpLkJ1ZmZlcil9LHtcIi4vYmFzZTU4XCI6NTUsYXNzZXJ0OjEsYnVmZmVyOjUsY3J5cHRvOjl9XSw1NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKEJ1ZmZlcil7dmFyIENyeXB0bz1fZGVyZXFfKFwiY3J5cHRvLWpzXCIpO3ZhciBXb3JkQXJyYXk9Q3J5cHRvLmxpYi5Xb3JkQXJyYXk7dmFyIGJhc2U2NG1hcD1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtmdW5jdGlvbiBscGFkKHN0cixwYWRTdHJpbmcsbGVuZ3RoKXt3aGlsZShzdHIubGVuZ3RoPGxlbmd0aClzdHI9cGFkU3RyaW5nK3N0cjtyZXR1cm4gc3RyfWZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpe2lmKEJ1ZmZlci5pc0J1ZmZlcihieXRlcykpe3JldHVybiBieXRlcy50b1N0cmluZyhcImhleFwiKX1yZXR1cm4gYnl0ZXMubWFwKGZ1bmN0aW9uKHgpe3JldHVybiBscGFkKHgudG9TdHJpbmcoMTYpLFwiMFwiLDIpfSkuam9pbihcIlwiKX1mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCl7cmV0dXJuIGhleC5tYXRjaCgvLi4vZykubWFwKGZ1bmN0aW9uKHgpe3JldHVybiBwYXJzZUludCh4LDE2KX0pfWZ1bmN0aW9uIGJ5dGVzVG9CYXNlNjQoYnl0ZXMpe3ZhciBiYXNlNjQ9W107Zm9yKHZhciBpPTA7aTxieXRlcy5sZW5ndGg7aSs9Myl7dmFyIHRyaXBsZXQ9Ynl0ZXNbaV08PDE2fGJ5dGVzW2krMV08PDh8Ynl0ZXNbaSsyXTtmb3IodmFyIGo9MDtqPDQ7aisrKXtpZihpKjgraio2PD1ieXRlcy5sZW5ndGgqOCl7YmFzZTY0LnB1c2goYmFzZTY0bWFwLmNoYXJBdCh0cmlwbGV0Pj4+NiooMy1qKSY2MykpfWVsc2V7YmFzZTY0LnB1c2goXCI9XCIpfX19cmV0dXJuIGJhc2U2NC5qb2luKFwiXCIpfWZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoYmFzZTY0KXtiYXNlNjQ9YmFzZTY0LnJlcGxhY2UoL1teQS1aMC05K1xcL10vZ2ksXCJcIik7dmFyIGJ5dGVzPVtdO3ZhciBpbW9kND0wO2Zvcih2YXIgaT0wO2k8YmFzZTY0Lmxlbmd0aDtpbW9kND0rK2klNCl7aWYoIWltb2Q0KWNvbnRpbnVlO2J5dGVzLnB1c2goKGJhc2U2NG1hcC5pbmRleE9mKGJhc2U2NC5jaGFyQXQoaS0xKSkmTWF0aC5wb3coMiwtMippbW9kNCs4KS0xKTw8aW1vZDQqMnxiYXNlNjRtYXAuaW5kZXhPZihiYXNlNjQuY2hhckF0KGkpKT4+PjYtaW1vZDQqMil9cmV0dXJuIGJ5dGVzfWZ1bmN0aW9uIGNvZXJjZVRvQnl0ZXMoaW5wdXQpe2lmKHR5cGVvZiBpbnB1dCE9XCJzdHJpbmdcIilyZXR1cm4gaW5wdXQ7cmV0dXJuIGhleFRvQnl0ZXMoaW5wdXQpfWZ1bmN0aW9uIGJpblRvQnl0ZXMoYmluKXtyZXR1cm4gYmluLm1hdGNoKC8uLi4uLi4uLi9nKS5tYXAoZnVuY3Rpb24oeCl7cmV0dXJuIHBhcnNlSW50KHgsMil9KX1mdW5jdGlvbiBieXRlc1RvQmluKGJ5dGVzKXtyZXR1cm4gYnl0ZXMubWFwKGZ1bmN0aW9uKHgpe3JldHVybiBscGFkKHgudG9TdHJpbmcoMiksXCIwXCIsOCl9KS5qb2luKFwiXCIpfWZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpe3JldHVybiBieXRlcy5tYXAoZnVuY3Rpb24oeCl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoeCl9KS5qb2luKFwiXCIpfWZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyaW5nKXtyZXR1cm4gc3RyaW5nLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbih4KXtyZXR1cm4geC5jaGFyQ29kZUF0KDApfSl9ZnVuY3Rpb24gbnVtVG9CeXRlcyhudW0sYnl0ZXMpe2lmKGJ5dGVzPT09dW5kZWZpbmVkKWJ5dGVzPTg7aWYoYnl0ZXM9PT0wKXJldHVybltdO3JldHVybltudW0lMjU2XS5jb25jYXQobnVtVG9CeXRlcyhNYXRoLmZsb29yKG51bS8yNTYpLGJ5dGVzLTEpKX1mdW5jdGlvbiBieXRlc1RvTnVtKGJ5dGVzKXtpZihieXRlcy5sZW5ndGg9PT0wKXJldHVybiAwO3JldHVybiBieXRlc1swXSsyNTYqYnl0ZXNUb051bShieXRlcy5zbGljZSgxKSl9ZnVuY3Rpb24gbnVtVG9WYXJJbnQobnVtKXtpZihudW08MjUzKXJldHVybltudW1dO2lmKG51bTw2NTUzNilyZXR1cm5bMjUzXS5jb25jYXQobnVtVG9CeXRlcyhudW0sMikpO2lmKG51bTw0Mjk0OTY3Mjk2KXJldHVyblsyNTRdLmNvbmNhdChudW1Ub0J5dGVzKG51bSw0KSk7cmV0dXJuWzI1NV0uY29uY2F0KG51bVRvQnl0ZXMobnVtLDgpKX1mdW5jdGlvbiB2YXJJbnRUb051bShieXRlcyl7dmFyIHByZWZpeD1ieXRlc1swXTt2YXIgdmlCeXRlcz1wcmVmaXg8MjUzP2J5dGVzLnNsaWNlKDAsMSk6cHJlZml4PT09MjUzP2J5dGVzLnNsaWNlKDEsMyk6cHJlZml4PT09MjU0P2J5dGVzLnNsaWNlKDEsNSk6Ynl0ZXMuc2xpY2UoMSw5KTtyZXR1cm57Ynl0ZXM6cHJlZml4PDI1Mz92aUJ5dGVzOmJ5dGVzLnNsaWNlKDAsdmlCeXRlcy5sZW5ndGgrMSksbnVtYmVyOmJ5dGVzVG9OdW0odmlCeXRlcyl9fWZ1bmN0aW9uIGJ5dGVzVG9Xb3JkcyhieXRlcyl7dmFyIHdvcmRzPVtdO2Zvcih2YXIgaT0wLGI9MDtpPGJ5dGVzLmxlbmd0aDtpKyssYis9OCl7d29yZHNbYj4+PjVdfD1ieXRlc1tpXTw8MjQtYiUzMn1yZXR1cm4gd29yZHN9ZnVuY3Rpb24gd29yZHNUb0J5dGVzKHdvcmRzKXt2YXIgYnl0ZXM9W107Zm9yKHZhciBiPTA7Yjx3b3Jkcy5sZW5ndGgqMzI7Yis9OCl7Ynl0ZXMucHVzaCh3b3Jkc1tiPj4+NV0+Pj4yNC1iJTMyJjI1NSl9cmV0dXJuIGJ5dGVzfWZ1bmN0aW9uIGJ5dGVzVG9Xb3JkQXJyYXkoYnl0ZXMpe3JldHVybiBuZXcgV29yZEFycmF5LmluaXQoYnl0ZXNUb1dvcmRzKGJ5dGVzKSxieXRlcy5sZW5ndGgpfWZ1bmN0aW9uIHdvcmRBcnJheVRvQnl0ZXMod29yZEFycmF5KXtyZXR1cm4gd29yZHNUb0J5dGVzKHdvcmRBcnJheS53b3Jkcyl9ZnVuY3Rpb24gcmV2ZXJzZUVuZGlhbihoZXgpe3JldHVybiBieXRlc1RvSGV4KGhleFRvQnl0ZXMoaGV4KS5yZXZlcnNlKCkpfW1vZHVsZS5leHBvcnRzPXtscGFkOmxwYWQsYnl0ZXNUb0hleDpieXRlc1RvSGV4LGhleFRvQnl0ZXM6aGV4VG9CeXRlcyxieXRlc1RvQmFzZTY0OmJ5dGVzVG9CYXNlNjQsYmFzZTY0VG9CeXRlczpiYXNlNjRUb0J5dGVzLGNvZXJjZVRvQnl0ZXM6Y29lcmNlVG9CeXRlcyxiaW5Ub0J5dGVzOmJpblRvQnl0ZXMsYnl0ZXNUb0JpbjpieXRlc1RvQmluLGJ5dGVzVG9TdHJpbmc6Ynl0ZXNUb1N0cmluZyxzdHJpbmdUb0J5dGVzOnN0cmluZ1RvQnl0ZXMsbnVtVG9CeXRlczpudW1Ub0J5dGVzLGJ5dGVzVG9OdW06Ynl0ZXNUb051bSxudW1Ub1ZhckludDpudW1Ub1ZhckludCx2YXJJbnRUb051bTp2YXJJbnRUb051bSxieXRlc1RvV29yZHM6Ynl0ZXNUb1dvcmRzLHdvcmRzVG9CeXRlczp3b3Jkc1RvQnl0ZXMsYnl0ZXNUb1dvcmRBcnJheTpieXRlc1RvV29yZEFycmF5LHdvcmRBcnJheVRvQnl0ZXM6d29yZEFycmF5VG9CeXRlcyxyZXZlcnNlRW5kaWFuOnJldmVyc2VFbmRpYW59fSkuY2FsbCh0aGlzLF9kZXJlcV8oXCJidWZmZXJcIikuQnVmZmVyKX0se2J1ZmZlcjo1LFwiY3J5cHRvLWpzXCI6Mjd9XSw1ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIHNlYz1fZGVyZXFfKFwiLi9qc2JuL3NlY1wiKTt2YXIgcm5nPV9kZXJlcV8oXCJzZWN1cmUtcmFuZG9tXCIpO3ZhciBCaWdJbnRlZ2VyPV9kZXJlcV8oXCIuL2pzYm4vanNiblwiKTt2YXIgY29udmVydD1fZGVyZXFfKFwiLi9jb252ZXJ0XCIpO3ZhciBIbWFjU0hBMjU2PV9kZXJlcV8oXCJjcnlwdG8tanMvaG1hYy1zaGEyNTZcIik7dmFyIEVDUG9pbnRGcD1fZGVyZXFfKFwiLi9qc2JuL2VjXCIpLkVDUG9pbnRGcDt2YXIgZWNwYXJhbXM9c2VjKFwic2VjcDI1NmsxXCIpO3ZhciBQX09WRVJfRk9VUj1udWxsO2Z1bmN0aW9uIGltcGxTaGFtaXJzVHJpY2soUCxrLFEsbCl7dmFyIG09TWF0aC5tYXgoay5iaXRMZW5ndGgoKSxsLmJpdExlbmd0aCgpKTt2YXIgWj1QLmFkZDJEKFEpO3ZhciBSPVAuY3VydmUuZ2V0SW5maW5pdHkoKTtmb3IodmFyIGk9bS0xO2k+PTA7LS1pKXtSPVIudHdpY2UyRCgpO1Iuej1CaWdJbnRlZ2VyLk9ORTtpZihrLnRlc3RCaXQoaSkpe2lmKGwudGVzdEJpdChpKSl7Uj1SLmFkZDJEKFopfWVsc2V7Uj1SLmFkZDJEKFApfX1lbHNle2lmKGwudGVzdEJpdChpKSl7Uj1SLmFkZDJEKFEpfX19cmV0dXJuIFJ9ZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY0dlbmVyYXRlSyhoYXNoLGtleSl7dmFyIHZBcnI9W107dmFyIGtBcnI9W107Zm9yKHZhciBpPTA7aTwzMjtpKyspdkFyci5wdXNoKDEpO2Zvcih2YXIgaT0wO2k8MzI7aSsrKWtBcnIucHVzaCgwKTt2YXIgdj1jb252ZXJ0LmJ5dGVzVG9Xb3JkQXJyYXkodkFycik7dmFyIGs9Y29udmVydC5ieXRlc1RvV29yZEFycmF5KGtBcnIpO2s9SG1hY1NIQTI1Nihjb252ZXJ0LmJ5dGVzVG9Xb3JkQXJyYXkodkFyci5jb25jYXQoWzBdKS5jb25jYXQoa2V5KS5jb25jYXQoaGFzaCkpLGspO3Y9SG1hY1NIQTI1Nih2LGspO3ZBcnI9Y29udmVydC53b3JkQXJyYXlUb0J5dGVzKHYpO2s9SG1hY1NIQTI1Nihjb252ZXJ0LmJ5dGVzVG9Xb3JkQXJyYXkodkFyci5jb25jYXQoWzFdKS5jb25jYXQoa2V5KS5jb25jYXQoaGFzaCkpLGspO3Y9SG1hY1NIQTI1Nih2LGspO3Y9SG1hY1NIQTI1Nih2LGspO3ZBcnI9Y29udmVydC53b3JkQXJyYXlUb0J5dGVzKHYpO3JldHVybiBCaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZCh2QXJyKX12YXIgRUNEU0E9e2dldEJpZ1JhbmRvbTpmdW5jdGlvbihsaW1pdCl7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGxpbWl0LmJpdExlbmd0aCgpLHJuZykubW9kKGxpbWl0LnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKSkuYWRkKEJpZ0ludGVnZXIuT05FKX0sc2lnbjpmdW5jdGlvbihoYXNoLHByaXYpe3ZhciBkPXByaXY7dmFyIG49ZWNwYXJhbXMuZ2V0TigpO3ZhciBlPUJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKGhhc2gpO3ZhciBrPWRldGVybWluaXN0aWNHZW5lcmF0ZUsoaGFzaCxwcml2LnRvQnl0ZUFycmF5VW5zaWduZWQoKSk7dmFyIEc9ZWNwYXJhbXMuZ2V0RygpO3ZhciBRPUcubXVsdGlwbHkoayk7dmFyIHI9US5nZXRYKCkudG9CaWdJbnRlZ2VyKCkubW9kKG4pO3ZhciBzPWsubW9kSW52ZXJzZShuKS5tdWx0aXBseShlLmFkZChkLm11bHRpcGx5KHIpKSkubW9kKG4pO3JldHVybiBFQ0RTQS5zZXJpYWxpemVTaWcocixzKX0sdmVyaWZ5OmZ1bmN0aW9uKGhhc2gsc2lnLHB1YmtleSl7dmFyIHIscztpZihBcnJheS5pc0FycmF5KHNpZykpe3ZhciBvYmo9RUNEU0EucGFyc2VTaWcoc2lnKTtyPW9iai5yO3M9b2JqLnN9ZWxzZSBpZihcIm9iamVjdFwiPT09dHlwZW9mIHNpZyYmc2lnLnImJnNpZy5zKXtyPXNpZy5yO3M9c2lnLnN9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBzaWduYXR1cmVcIil9dmFyIFE7aWYocHVia2V5IGluc3RhbmNlb2YgRUNQb2ludEZwKXtRPXB1YmtleX1lbHNlIGlmKEFycmF5LmlzQXJyYXkocHVia2V5KSl7UT1FQ1BvaW50RnAuZGVjb2RlRnJvbShlY3BhcmFtcy5nZXRDdXJ2ZSgpLHB1YmtleSl9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZvcm1hdCBmb3IgcHVia2V5IHZhbHVlLCBtdXN0IGJlIGJ5dGUgYXJyYXkgb3IgRUNQb2ludEZwXCIpfXZhciBlPUJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKGhhc2gpO3JldHVybiBFQ0RTQS52ZXJpZnlSYXcoZSxyLHMsUSl9LHZlcmlmeVJhdzpmdW5jdGlvbihlLHIscyxRKXt2YXIgbj1lY3BhcmFtcy5nZXROKCk7dmFyIEc9ZWNwYXJhbXMuZ2V0RygpO2lmKHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKTwwfHxyLmNvbXBhcmVUbyhuKT49MCl7cmV0dXJuIGZhbHNlfWlmKHMuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKTwwfHxzLmNvbXBhcmVUbyhuKT49MCl7cmV0dXJuIGZhbHNlfXZhciBjPXMubW9kSW52ZXJzZShuKTt2YXIgdTE9ZS5tdWx0aXBseShjKS5tb2Qobik7dmFyIHUyPXIubXVsdGlwbHkoYykubW9kKG4pO3ZhciBwb2ludD1HLm11bHRpcGx5KHUxKS5hZGQoUS5tdWx0aXBseSh1MikpO3ZhciB2PXBvaW50LmdldFgoKS50b0JpZ0ludGVnZXIoKS5tb2Qobik7cmV0dXJuIHYuZXF1YWxzKHIpfSxzZXJpYWxpemVTaWc6ZnVuY3Rpb24ocixzKXt2YXIgckJhPXIudG9CeXRlQXJyYXlTaWduZWQoKTt2YXIgc0JhPXMudG9CeXRlQXJyYXlTaWduZWQoKTt2YXIgc2VxdWVuY2U9W107c2VxdWVuY2UucHVzaCgyKTtzZXF1ZW5jZS5wdXNoKHJCYS5sZW5ndGgpO3NlcXVlbmNlPXNlcXVlbmNlLmNvbmNhdChyQmEpO3NlcXVlbmNlLnB1c2goMik7c2VxdWVuY2UucHVzaChzQmEubGVuZ3RoKTtzZXF1ZW5jZT1zZXF1ZW5jZS5jb25jYXQoc0JhKTtzZXF1ZW5jZS51bnNoaWZ0KHNlcXVlbmNlLmxlbmd0aCk7c2VxdWVuY2UudW5zaGlmdCg0OCk7cmV0dXJuIHNlcXVlbmNlfSxwYXJzZVNpZzpmdW5jdGlvbihzaWcpe3ZhciBjdXJzb3I7aWYoc2lnWzBdIT00OCl7dGhyb3cgbmV3IEVycm9yKFwiU2lnbmF0dXJlIG5vdCBhIHZhbGlkIERFUlNlcXVlbmNlXCIpfWN1cnNvcj0yO2lmKHNpZ1tjdXJzb3JdIT0yKXt0aHJvdyBuZXcgRXJyb3IoXCJGaXJzdCBlbGVtZW50IGluIHNpZ25hdHVyZSBtdXN0IGJlIGEgREVSSW50ZWdlclwiKX12YXIgckJhPXNpZy5zbGljZShjdXJzb3IrMixjdXJzb3IrMitzaWdbY3Vyc29yKzFdKTtjdXJzb3IrPTIrc2lnW2N1cnNvcisxXTtpZihzaWdbY3Vyc29yXSE9Mil7dGhyb3cgbmV3IEVycm9yKFwiU2Vjb25kIGVsZW1lbnQgaW4gc2lnbmF0dXJlIG11c3QgYmUgYSBERVJJbnRlZ2VyXCIpfXZhciBzQmE9c2lnLnNsaWNlKGN1cnNvcisyLGN1cnNvcisyK3NpZ1tjdXJzb3IrMV0pO2N1cnNvcis9MitzaWdbY3Vyc29yKzFdO3ZhciByPUJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKHJCYSk7dmFyIHM9QmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQoc0JhKTtyZXR1cm57cjpyLHM6c319LHBhcnNlU2lnQ29tcGFjdDpmdW5jdGlvbihzaWcpe2lmKHNpZy5sZW5ndGghPT02NSl7dGhyb3cgbmV3IEVycm9yKFwiU2lnbmF0dXJlIGhhcyB0aGUgd3JvbmcgbGVuZ3RoXCIpfXZhciBpPXNpZ1swXS0yNztpZihpPDB8fGk+Nyl7dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduYXR1cmUgdHlwZVwiKX12YXIgbj1lY3BhcmFtcy5nZXROKCk7dmFyIHI9QmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQoc2lnLnNsaWNlKDEsMzMpKS5tb2Qobik7dmFyIHM9QmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQoc2lnLnNsaWNlKDMzLDY1KSkubW9kKG4pO3JldHVybntyOnIsczpzLGk6aX19LHJlY292ZXJQdWJLZXk6ZnVuY3Rpb24ocixzLGhhc2gsaSl7aT1pJjM7dmFyIGlzWUV2ZW49aSYxO3ZhciBpc1NlY29uZEtleT1pPj4xO3ZhciBuPWVjcGFyYW1zLmdldE4oKTt2YXIgRz1lY3BhcmFtcy5nZXRHKCk7dmFyIGN1cnZlPWVjcGFyYW1zLmdldEN1cnZlKCk7dmFyIHA9Y3VydmUuZ2V0USgpO3ZhciBhPWN1cnZlLmdldEEoKS50b0JpZ0ludGVnZXIoKTt2YXIgYj1jdXJ2ZS5nZXRCKCkudG9CaWdJbnRlZ2VyKCk7aWYoIVBfT1ZFUl9GT1VSKXtQX09WRVJfRk9VUj1wLmFkZChCaWdJbnRlZ2VyLk9ORSkuZGl2aWRlKEJpZ0ludGVnZXIudmFsdWVPZig0KSl9dmFyIHg9aXNTZWNvbmRLZXk/ci5hZGQobik6cjt2YXIgYWxwaGE9eC5tdWx0aXBseSh4KS5tdWx0aXBseSh4KS5hZGQoYS5tdWx0aXBseSh4KSkuYWRkKGIpLm1vZChwKTt2YXIgYmV0YT1hbHBoYS5tb2RQb3coUF9PVkVSX0ZPVVIscCk7dmFyIHk9KGJldGEuaXNFdmVuKCk/IWlzWUV2ZW46aXNZRXZlbik/YmV0YTpwLnN1YnRyYWN0KGJldGEpO3ZhciBSPW5ldyBFQ1BvaW50RnAoY3VydmUsY3VydmUuZnJvbUJpZ0ludGVnZXIoeCksY3VydmUuZnJvbUJpZ0ludGVnZXIoeSkpO1IudmFsaWRhdGUoKTt2YXIgZT1CaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZChoYXNoKTt2YXIgZU5lZz1CaWdJbnRlZ2VyLlpFUk8uc3VidHJhY3QoZSkubW9kKG4pO3ZhciBySW52PXIubW9kSW52ZXJzZShuKTt2YXIgUT1pbXBsU2hhbWlyc1RyaWNrKFIscyxHLGVOZWcpLm11bHRpcGx5KHJJbnYpO1EudmFsaWRhdGUoKTtpZighRUNEU0EudmVyaWZ5UmF3KGUscixzLFEpKXt0aHJvdyBuZXcgRXJyb3IoXCJQdWJrZXkgcmVjb3ZlcnkgdW5zdWNjZXNzZnVsXCIpfXJldHVybiBRfSxjYWxjUHViS2V5UmVjb3ZlcnlQYXJhbTpmdW5jdGlvbihvcmlnUHViS2V5LHIscyxoYXNoKXtmb3IodmFyIGk9MDtpPDQ7aSsrKXt2YXIgcHViS2V5PUVDRFNBLnJlY292ZXJQdWJLZXkocixzLGhhc2gsaSk7aWYocHViS2V5LmVxdWFscyhvcmlnUHViS2V5KSl7cmV0dXJuIGl9fXRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHZhbGlkIHJlY292ZXJ5IGZhY3RvclwiKX19O21vZHVsZS5leHBvcnRzPUVDRFNBfSx7XCIuL2NvbnZlcnRcIjo1NyxcIi4vanNibi9lY1wiOjYyLFwiLi9qc2JuL2pzYm5cIjo2MyxcIi4vanNibi9zZWNcIjo2NCxcImNyeXB0by1qcy9obWFjLXNoYTI1NlwiOjI1LFwic2VjdXJlLXJhbmRvbVwiOjUzfV0sNTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBBZGRyZXNzPV9kZXJlcV8oXCIuL2FkZHJlc3NcIik7dmFyIGFzc2VydD1fZGVyZXFfKFwiYXNzZXJ0XCIpO3ZhciBjb252ZXJ0PV9kZXJlcV8oXCIuL2NvbnZlcnRcIik7dmFyIGJhc2U1OGNoZWNrPV9kZXJlcV8oXCIuL2Jhc2U1OGNoZWNrXCIpO3ZhciBCaWdJbnRlZ2VyPV9kZXJlcV8oXCIuL2pzYm4vanNiblwiKTt2YXIgZWNkc2E9X2RlcmVxXyhcIi4vZWNkc2FcIik7dmFyIEVDUG9pbnRGcD1fZGVyZXFfKFwiLi9qc2JuL2VjXCIpLkVDUG9pbnRGcDt2YXIgc2VjPV9kZXJlcV8oXCIuL2pzYm4vc2VjXCIpO3ZhciBOZXR3b3JrPV9kZXJlcV8oXCIuL25ldHdvcmtcIik7dmFyIHV0aWw9X2RlcmVxXyhcIi4vdXRpbFwiKTt2YXIgZWNwYXJhbXM9c2VjKFwic2VjcDI1NmsxXCIpO3ZhciBFQ0tleT1mdW5jdGlvbihpbnB1dCxjb21wcmVzc2VkKXtpZighKHRoaXMgaW5zdGFuY2VvZiBFQ0tleSkpe3JldHVybiBuZXcgRUNLZXkoaW5wdXQsY29tcHJlc3NlZCl9aWYoIWlucHV0KXt2YXIgbj1lY3BhcmFtcy5nZXROKCk7dGhpcy5wcml2PWVjZHNhLmdldEJpZ1JhbmRvbShuKTt0aGlzLmNvbXByZXNzZWQ9Y29tcHJlc3NlZHx8ZmFsc2V9ZWxzZSB0aGlzLmltcG9ydChpbnB1dCxjb21wcmVzc2VkKX07RUNLZXkucHJvdG90eXBlLmltcG9ydD1mdW5jdGlvbihpbnB1dCxjb21wcmVzc2VkKXtmdW5jdGlvbiBoYXMobGksdil7cmV0dXJuIGxpLmluZGV4T2Yodik+PTB9ZnVuY3Rpb24gZnJvbUJpbih4KXtyZXR1cm4gQmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQoeCl9dGhpcy5wcml2PWlucHV0IGluc3RhbmNlb2YgRUNLZXk/aW5wdXQucHJpdjppbnB1dCBpbnN0YW5jZW9mIEJpZ0ludGVnZXI/aW5wdXQubW9kKGVjcGFyYW1zLmdldE4oKSk6QXJyYXkuaXNBcnJheShpbnB1dCk/ZnJvbUJpbihpbnB1dC5zbGljZSgwLDMyKSk6dHlwZW9mIGlucHV0IT1cInN0cmluZ1wiP251bGw6aW5wdXQubGVuZ3RoPT00ND9mcm9tQmluKGNvbnZlcnQuYmFzZTY0VG9CeXRlcyhpbnB1dCkpOmlucHV0Lmxlbmd0aD09NTEmJmlucHV0WzBdPT1cIjVcIj9mcm9tQmluKGJhc2U1OGNoZWNrLmRlY29kZShpbnB1dCkucGF5bG9hZCk6aW5wdXQubGVuZ3RoPT01MSYmaW5wdXRbMF09PVwiOVwiP2Zyb21CaW4oYmFzZTU4Y2hlY2suZGVjb2RlKGlucHV0KS5wYXlsb2FkKTppbnB1dC5sZW5ndGg9PTUyJiZoYXMoXCJMS1wiLGlucHV0WzBdKT9mcm9tQmluKGJhc2U1OGNoZWNrLmRlY29kZShpbnB1dCkucGF5bG9hZC5zbGljZSgwLDMyKSk6aW5wdXQubGVuZ3RoPT01MiYmaW5wdXRbMF09PVwiY1wiP2Zyb21CaW4oYmFzZTU4Y2hlY2suZGVjb2RlKGlucHV0KS5wYXlsb2FkLnNsaWNlKDAsMzIpKTpoYXMoWzY0LDY1XSxpbnB1dC5sZW5ndGgpP2Zyb21CaW4oY29udmVydC5oZXhUb0J5dGVzKGlucHV0LnNsaWNlKDAsNjQpKSk6bnVsbDthc3NlcnQodGhpcy5wcml2IT09bnVsbCk7dGhpcy5jb21wcmVzc2VkPWNvbXByZXNzZWQhPT11bmRlZmluZWQ/Y29tcHJlc3NlZDppbnB1dCBpbnN0YW5jZW9mIEVDS2V5P2lucHV0LmNvbXByZXNzZWQ6aW5wdXQgaW5zdGFuY2VvZiBCaWdJbnRlZ2VyP2ZhbHNlOkFycmF5LmlzQXJyYXkoaW5wdXQpP2ZhbHNlOnR5cGVvZiBpbnB1dCE9XCJzdHJpbmdcIj9udWxsOmlucHV0Lmxlbmd0aD09NDQ/ZmFsc2U6aW5wdXQubGVuZ3RoPT01MSYmaW5wdXRbMF09PVwiNVwiP2ZhbHNlOmlucHV0Lmxlbmd0aD09NTEmJmlucHV0WzBdPT1cIjlcIj9mYWxzZTppbnB1dC5sZW5ndGg9PTUyJiZoYXMoXCJMS1wiLGlucHV0WzBdKT90cnVlOmlucHV0Lmxlbmd0aD09NTImJmlucHV0WzBdPT1cImNcIj90cnVlOmlucHV0Lmxlbmd0aD09NjQ/ZmFsc2U6aW5wdXQubGVuZ3RoPT02NT90cnVlOm51bGw7YXNzZXJ0KHRoaXMuY29tcHJlc3NlZCE9PW51bGwpfTtFQ0tleS5wcm90b3R5cGUuZ2V0UHViPWZ1bmN0aW9uKGNvbXByZXNzZWQpe2lmKGNvbXByZXNzZWQ9PT11bmRlZmluZWQpY29tcHJlc3NlZD10aGlzLmNvbXByZXNzZWQ7cmV0dXJuIEVDUHViS2V5KGVjcGFyYW1zLmdldEcoKS5tdWx0aXBseSh0aGlzLnByaXYpLGNvbXByZXNzZWQpfTtFQ0tleS5wcm90b3R5cGUudG9CaW49ZnVuY3Rpb24oKXtyZXR1cm4gY29udmVydC5ieXRlc1RvU3RyaW5nKHRoaXMudG9CeXRlcygpKX07RUNLZXkudmVyc2lvbl9ieXRlcz17MDoxMjgsMTExOjIzOX07RUNLZXkucHJvdG90eXBlLnRvV2lmPWZ1bmN0aW9uKHZlcnNpb24pe3ZlcnNpb249dmVyc2lvbnx8TmV0d29yay5tYWlubmV0LmFkZHJlc3NWZXJzaW9uO3JldHVybiBiYXNlNThjaGVjay5lbmNvZGUodGhpcy50b0J5dGVzKCksRUNLZXkudmVyc2lvbl9ieXRlc1t2ZXJzaW9uXSl9O0VDS2V5LnByb3RvdHlwZS50b0hleD1mdW5jdGlvbigpe3JldHVybiBjb252ZXJ0LmJ5dGVzVG9IZXgodGhpcy50b0J5dGVzKCkpfTtFQ0tleS5wcm90b3R5cGUudG9CeXRlcz1mdW5jdGlvbigpe3ZhciBieXRlcz10aGlzLnByaXYudG9CeXRlQXJyYXlVbnNpZ25lZCgpO2lmKHRoaXMuY29tcHJlc3NlZClieXRlcy5wdXNoKDEpO3JldHVybiBieXRlc307RUNLZXkucHJvdG90eXBlLnRvQmFzZTY0PWZ1bmN0aW9uKCl7cmV0dXJuIGNvbnZlcnQuYnl0ZXNUb0Jhc2U2NCh0aGlzLnRvQnl0ZXMoKSl9O0VDS2V5LnByb3RvdHlwZS50b1N0cmluZz1FQ0tleS5wcm90b3R5cGUudG9IZXg7RUNLZXkucHJvdG90eXBlLmdldEFkZHJlc3M9ZnVuY3Rpb24odmVyc2lvbil7cmV0dXJuIHRoaXMuZ2V0UHViKCkuZ2V0QWRkcmVzcyh2ZXJzaW9uKX07RUNLZXkucHJvdG90eXBlLmFkZD1mdW5jdGlvbihrZXkpe3JldHVybiBFQ0tleSh0aGlzLnByaXYuYWRkKEVDS2V5KGtleSkucHJpdiksdGhpcy5jb21wcmVzc2VkKX07RUNLZXkucHJvdG90eXBlLm11bHRpcGx5PWZ1bmN0aW9uKGtleSl7cmV0dXJuIEVDS2V5KHRoaXMucHJpdi5tdWx0aXBseShFQ0tleShrZXkpLnByaXYpLHRoaXMuY29tcHJlc3NlZCl9O0VDS2V5LnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKGhhc2gpe3JldHVybiBlY2RzYS5zaWduKGhhc2gsdGhpcy5wcml2KX07RUNLZXkucHJvdG90eXBlLnZlcmlmeT1mdW5jdGlvbihoYXNoLHNpZyl7cmV0dXJuIHRoaXMuZ2V0UHViKCkudmVyaWZ5KGhhc2gsc2lnKX07dmFyIEVDUHViS2V5PWZ1bmN0aW9uKGlucHV0LGNvbXByZXNzZWQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIEVDUHViS2V5KSl7cmV0dXJuIG5ldyBFQ1B1YktleShpbnB1dCxjb21wcmVzc2VkKX10aGlzLmltcG9ydChpbnB1dCxjb21wcmVzc2VkKX07RUNQdWJLZXkucHJvdG90eXBlLmltcG9ydD1mdW5jdGlvbihpbnB1dCxjb21wcmVzc2VkKXt2YXIgZGVjb2RlPWZ1bmN0aW9uKHgpe3JldHVybiBFQ1BvaW50RnAuZGVjb2RlRnJvbShlY3BhcmFtcy5nZXRDdXJ2ZSgpLHgpfTt0aGlzLnB1Yj1pbnB1dCBpbnN0YW5jZW9mIEVDUG9pbnRGcD9pbnB1dDppbnB1dCBpbnN0YW5jZW9mIEVDS2V5P2VjcGFyYW1zLmdldEcoKS5tdWx0aXBseShpbnB1dC5wcml2KTppbnB1dCBpbnN0YW5jZW9mIEVDUHViS2V5P2lucHV0LnB1Yjp0eXBlb2YgaW5wdXQ9PVwic3RyaW5nXCI/ZGVjb2RlKGNvbnZlcnQuaGV4VG9CeXRlcyhpbnB1dCkpOkFycmF5LmlzQXJyYXkoaW5wdXQpP2RlY29kZShpbnB1dCk6bnVsbDthc3NlcnQodGhpcy5wdWIhPT1udWxsKTt0aGlzLmNvbXByZXNzZWQ9Y29tcHJlc3NlZD9jb21wcmVzc2VkOmlucHV0IGluc3RhbmNlb2YgRUNQb2ludEZwP2lucHV0LmNvbXByZXNzZWQ6aW5wdXQgaW5zdGFuY2VvZiBFQ1B1YktleT9pbnB1dC5jb21wcmVzc2VkOnRoaXMucHViWzBdPDR9O0VDUHViS2V5LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oa2V5KXtyZXR1cm4gRUNQdWJLZXkodGhpcy5wdWIuYWRkKEVDUHViS2V5KGtleSkucHViKSx0aGlzLmNvbXByZXNzZWQpfTtFQ1B1YktleS5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24oa2V5KXtyZXR1cm4gRUNQdWJLZXkodGhpcy5wdWIubXVsdGlwbHkoRUNLZXkoa2V5KS5wcml2KSx0aGlzLmNvbXByZXNzZWQpfTtFQ1B1YktleS5wcm90b3R5cGUudG9CeXRlcz1mdW5jdGlvbihjb21wcmVzc2VkKXtpZihjb21wcmVzc2VkPT09dW5kZWZpbmVkKWNvbXByZXNzZWQ9dGhpcy5jb21wcmVzc2VkO3JldHVybiB0aGlzLnB1Yi5nZXRFbmNvZGVkKGNvbXByZXNzZWQpfTtFQ1B1YktleS5wcm90b3R5cGUudG9IZXg9ZnVuY3Rpb24oY29tcHJlc3NlZCl7cmV0dXJuIGNvbnZlcnQuYnl0ZXNUb0hleCh0aGlzLnRvQnl0ZXMoY29tcHJlc3NlZCkpfTtFQ1B1YktleS5wcm90b3R5cGUudG9CaW49ZnVuY3Rpb24oY29tcHJlc3NlZCl7cmV0dXJuIGNvbnZlcnQuYnl0ZXNUb1N0cmluZyh0aGlzLnRvQnl0ZXMoY29tcHJlc3NlZCkpfTtFQ1B1YktleS5wcm90b3R5cGUudG9XaWY9ZnVuY3Rpb24odmVyc2lvbil7dmVyc2lvbj12ZXJzaW9ufHxOZXR3b3JrLm1haW5uZXQuYWRkcmVzc1ZlcnNpb247cmV0dXJuIGJhc2U1OGNoZWNrLmVuY29kZSh0aGlzLnRvQnl0ZXMoKSx2ZXJzaW9uKX07RUNQdWJLZXkucHJvdG90eXBlLnRvU3RyaW5nPUVDUHViS2V5LnByb3RvdHlwZS50b0hleDtFQ1B1YktleS5wcm90b3R5cGUuZ2V0QWRkcmVzcz1mdW5jdGlvbih2ZXJzaW9uKXt2ZXJzaW9uPXZlcnNpb258fE5ldHdvcmsubWFpbm5ldC5hZGRyZXNzVmVyc2lvbjtyZXR1cm4gbmV3IEFkZHJlc3ModXRpbC5zaGEyNTZyaXBlMTYwKHRoaXMudG9CeXRlcygpKSx2ZXJzaW9uKX07RUNQdWJLZXkucHJvdG90eXBlLnZlcmlmeT1mdW5jdGlvbihoYXNoLHNpZyl7cmV0dXJuIGVjZHNhLnZlcmlmeShoYXNoLHNpZyx0aGlzLnRvQnl0ZXMoKSl9O21vZHVsZS5leHBvcnRzPXtFQ0tleTpFQ0tleSxFQ1B1YktleTpFQ1B1YktleX19LHtcIi4vYWRkcmVzc1wiOjU0LFwiLi9iYXNlNThjaGVja1wiOjU2LFwiLi9jb252ZXJ0XCI6NTcsXCIuL2VjZHNhXCI6NTgsXCIuL2pzYm4vZWNcIjo2MixcIi4vanNibi9qc2JuXCI6NjMsXCIuL2pzYm4vc2VjXCI6NjQsXCIuL25ldHdvcmtcIjo2NixcIi4vdXRpbFwiOjcwLGFzc2VydDoxfV0sNjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihCdWZmZXIpe3ZhciBjb252ZXJ0PV9kZXJlcV8oXCIuL2NvbnZlcnQuanNcIik7dmFyIGJhc2U1OD1fZGVyZXFfKFwiLi9iYXNlNTguanNcIik7dmFyIGFzc2VydD1fZGVyZXFfKFwiYXNzZXJ0XCIpO3ZhciBmb3JtYXQ9X2RlcmVxXyhcInV0aWxcIikuZm9ybWF0O3ZhciB1dGlsPV9kZXJlcV8oXCIuL3V0aWwuanNcIik7dmFyIENyeXB0bz1fZGVyZXFfKFwiY3J5cHRvLWpzXCIpO3ZhciBIbWFjU0hBNTEyPUNyeXB0by5IbWFjU0hBNTEyO3ZhciBITUFDPUNyeXB0by5hbGdvLkhNQUM7dmFyIEVDS2V5PV9kZXJlcV8oXCIuL2Vja2V5LmpzXCIpLkVDS2V5O3ZhciBFQ1B1YktleT1fZGVyZXFfKFwiLi9lY2tleS5qc1wiKS5FQ1B1YktleTt2YXIgQWRkcmVzcz1fZGVyZXFfKFwiLi9hZGRyZXNzLmpzXCIpO3ZhciBOZXR3b3JrPV9kZXJlcV8oXCIuL25ldHdvcmtcIik7dmFyIGNyeXB0bz1fZGVyZXFfKFwiY3J5cHRvXCIpO2Z1bmN0aW9uIHNoYTI1NihidWYpe3ZhciBoYXNoPWNyeXB0by5jcmVhdGVIYXNoKFwic2hhMjU2XCIpO2hhc2gudXBkYXRlKGJ1Zik7cmV0dXJuIGhhc2guZGlnZXN0KCl9ZnVuY3Rpb24gSERXYWxsZXQoc2VlZCxuZXR3b3JrKXtpZihzZWVkPT09dW5kZWZpbmVkKXJldHVybjt2YXIgc2VlZFdvcmRzPWNvbnZlcnQuYnl0ZXNUb1dvcmRBcnJheShzZWVkKTt2YXIgST1jb252ZXJ0LndvcmRBcnJheVRvQnl0ZXMoSG1hY1NIQTUxMihzZWVkV29yZHMsXCJCaXRjb2luIHNlZWRcIikpO3RoaXMuY2hhaW5jb2RlPUkuc2xpY2UoMzIpO3RoaXMubmV0d29yaz1uZXR3b3JrfHxcIm1haW5uZXRcIjtpZighTmV0d29yay5oYXNPd25Qcm9wZXJ0eSh0aGlzLm5ldHdvcmspKXt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5ldHdvcms6IFwiK3RoaXMubmV0d29yayl9dGhpcy5wcml2PW5ldyBFQ0tleShJLnNsaWNlKDAsMzIpLmNvbmNhdChbMV0pLHRydWUpO3RoaXMucHViPXRoaXMucHJpdi5nZXRQdWIoKTt0aGlzLmluZGV4PTA7dGhpcy5kZXB0aD0wfUhEV2FsbGV0LkhJR0hFU1RfQklUPTIxNDc0ODM2NDg7SERXYWxsZXQuTEVOR1RIPTc4O2Z1bmN0aW9uIGFycmF5RXF1YWwoYSxiKXtyZXR1cm4hKGE8Ynx8YT5iKX1IRFdhbGxldC5mcm9tU2VlZEhleD1mdW5jdGlvbihoZXgsbmV0d29yayl7cmV0dXJuIG5ldyBIRFdhbGxldChjb252ZXJ0LmhleFRvQnl0ZXMoaGV4KSxuZXR3b3JrKX07SERXYWxsZXQuZnJvbVNlZWRTdHJpbmc9ZnVuY3Rpb24oc3RyaW5nLG5ldHdvcmspe3JldHVybiBuZXcgSERXYWxsZXQoY29udmVydC5zdHJpbmdUb0J5dGVzKHN0cmluZyksbmV0d29yayl9O0hEV2FsbGV0LmZyb21CYXNlNTg9ZnVuY3Rpb24oc3RyaW5nKXt2YXIgYnVmZmVyPWJhc2U1OC5kZWNvZGUoc3RyaW5nKTt2YXIgcGF5bG9hZD1idWZmZXIuc2xpY2UoMCwtNCk7dmFyIGNoZWNrc3VtPWJ1ZmZlci5zbGljZSgtNCk7dmFyIG5ld0NoZWNrc3VtPXNoYTI1NihzaGEyNTYocGF5bG9hZCkpLnNsaWNlKDAsNCk7YXNzZXJ0LmRlZXBFcXVhbChuZXdDaGVja3N1bSxjaGVja3N1bSk7YXNzZXJ0LmVxdWFsKHBheWxvYWQubGVuZ3RoLEhEV2FsbGV0LkxFTkdUSCk7cmV0dXJuIEhEV2FsbGV0LmZyb21CeXRlcyhwYXlsb2FkKX07SERXYWxsZXQuZnJvbUhleD1mdW5jdGlvbihpbnB1dCl7cmV0dXJuIEhEV2FsbGV0LmZyb21CeXRlcyhjb252ZXJ0LmhleFRvQnl0ZXMoaW5wdXQpKX07SERXYWxsZXQuZnJvbUJ5dGVzPWZ1bmN0aW9uKGlucHV0KXtpZihpbnB1dC5sZW5ndGghPUhEV2FsbGV0LkxFTkdUSCl7dGhyb3cgbmV3IEVycm9yKGZvcm1hdChcIkludmFsaWQgaW5wdXQgbGVuZ3RoLCAlcy4gRXhwZWN0ZWQgJXMuXCIsaW5wdXQubGVuZ3RoLEhEV2FsbGV0LkxFTkdUSCkpfWlmKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpe2lucHV0PUFycmF5LnByb3RvdHlwZS5tYXAuYmluZChpbnB1dCxmdW5jdGlvbih4KXtyZXR1cm4geH0pKCl9dmFyIGhkPW5ldyBIRFdhbGxldDt2YXIgdmVyc2lvbkJ5dGVzPWlucHV0LnNsaWNlKDAsNCk7dmFyIHZlcnNpb25Xb3JkPWNvbnZlcnQuYnl0ZXNUb1dvcmRzKHZlcnNpb25CeXRlcylbMF07dmFyIHR5cGU7Zm9yKHZhciBuYW1lIGluIE5ldHdvcmspe3ZhciBuZXR3b3JrPU5ldHdvcmtbbmFtZV07Zm9yKHZhciB0IGluIG5ldHdvcmsuaGRWZXJzaW9ucyl7aWYodmVyc2lvbldvcmQhPW5ldHdvcmsuaGRWZXJzaW9uc1t0XSljb250aW51ZTt0eXBlPXQ7aGQubmV0d29yaz1uYW1lfX1pZighaGQubmV0d29yayl7dGhyb3cgbmV3IEVycm9yKGZvcm1hdChcIkNvdWxkIG5vdCBmaW5kIHZlcnNpb24gJXNcIixjb252ZXJ0LmJ5dGVzVG9IZXgodmVyc2lvbkJ5dGVzKSkpfWhkLmRlcHRoPWlucHV0WzRdO2hkLnBhcmVudEZpbmdlcnByaW50PWlucHV0LnNsaWNlKDUsOSk7YXNzZXJ0KGhkLmRlcHRoPT09MD09YXJyYXlFcXVhbChoZC5wYXJlbnRGaW5nZXJwcmludCxbMCwwLDAsMF0pKTtoZC5pbmRleD1jb252ZXJ0LmJ5dGVzVG9OdW0oaW5wdXQuc2xpY2UoOSwxMykucmV2ZXJzZSgpKTthc3NlcnQoaGQuZGVwdGg+MHx8aGQuaW5kZXg9PT0wKTtoZC5jaGFpbmNvZGU9aW5wdXQuc2xpY2UoMTMsNDUpO2lmKHR5cGU9PVwicHJpdlwiKXtoZC5wcml2PW5ldyBFQ0tleShpbnB1dC5zbGljZSg0Niw3OCkuY29uY2F0KFsxXSksdHJ1ZSk7aGQucHViPWhkLnByaXYuZ2V0UHViKCl9ZWxzZXtoZC5wdWI9bmV3IEVDUHViS2V5KGlucHV0LnNsaWNlKDQ1LDc4KSx0cnVlKX1yZXR1cm4gaGR9O0hEV2FsbGV0LnByb3RvdHlwZS5nZXRJZGVudGlmaWVyPWZ1bmN0aW9uKCl7cmV0dXJuIHV0aWwuc2hhMjU2cmlwZTE2MCh0aGlzLnB1Yi50b0J5dGVzKCkpfTtIRFdhbGxldC5wcm90b3R5cGUuZ2V0RmluZ2VycHJpbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRJZGVudGlmaWVyKCkuc2xpY2UoMCw0KX07SERXYWxsZXQucHJvdG90eXBlLmdldEFkZHJlc3M9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEFkZHJlc3ModXRpbC5zaGEyNTZyaXBlMTYwKHRoaXMucHViLnRvQnl0ZXMoKSksdGhpcy5nZXRLZXlWZXJzaW9uKCkpfTtIRFdhbGxldC5wcm90b3R5cGUudG9CeXRlcz1mdW5jdGlvbihwcml2KXt2YXIgYnVmZmVyPVtdO3ZhciB2ZXJzaW9uPU5ldHdvcmtbdGhpcy5uZXR3b3JrXS5oZFZlcnNpb25zW3ByaXY/XCJwcml2XCI6XCJwdWJcIl07dmFyIHZCeXRlcz1jb252ZXJ0LndvcmRzVG9CeXRlcyhbdmVyc2lvbl0pO2J1ZmZlcj1idWZmZXIuY29uY2F0KHZCeXRlcyk7YXNzZXJ0LmVxdWFsKGJ1ZmZlci5sZW5ndGgsNCk7YnVmZmVyLnB1c2godGhpcy5kZXB0aCk7YXNzZXJ0LmVxdWFsKGJ1ZmZlci5sZW5ndGgsNCsxKTtidWZmZXI9YnVmZmVyLmNvbmNhdCh0aGlzLmRlcHRoP3RoaXMucGFyZW50RmluZ2VycHJpbnQ6WzAsMCwwLDBdKTthc3NlcnQuZXF1YWwoYnVmZmVyLmxlbmd0aCw0KzErNCk7YnVmZmVyPWJ1ZmZlci5jb25jYXQoY29udmVydC5udW1Ub0J5dGVzKHRoaXMuaW5kZXgsNCkucmV2ZXJzZSgpKTthc3NlcnQuZXF1YWwoYnVmZmVyLmxlbmd0aCw0KzErNCs0KTtidWZmZXI9YnVmZmVyLmNvbmNhdCh0aGlzLmNoYWluY29kZSk7YXNzZXJ0LmVxdWFsKGJ1ZmZlci5sZW5ndGgsNCsxKzQrNCszMik7aWYocHJpdil7YXNzZXJ0KHRoaXMucHJpdixcIkNhbm5vdCBzZXJpYWxpemUgdG8gcHJpdmF0ZSB3aXRob3V0IHByaXZhdGUga2V5XCIpO2J1ZmZlci5wdXNoKDApO2J1ZmZlcj1idWZmZXIuY29uY2F0KHRoaXMucHJpdi50b0J5dGVzKCkuc2xpY2UoMCwzMikpfWVsc2V7YnVmZmVyPWJ1ZmZlci5jb25jYXQodGhpcy5wdWIudG9CeXRlcyh0cnVlKSl9cmV0dXJuIGJ1ZmZlcn07SERXYWxsZXQucHJvdG90eXBlLnRvSGV4PWZ1bmN0aW9uKHByaXYpe3ZhciBieXRlcz10aGlzLnRvQnl0ZXMocHJpdik7cmV0dXJuIGNvbnZlcnQuYnl0ZXNUb0hleChieXRlcyl9O0hEV2FsbGV0LnByb3RvdHlwZS50b0Jhc2U1OD1mdW5jdGlvbihwcml2KXt2YXIgYnVmZmVyPW5ldyBCdWZmZXIodGhpcy50b0J5dGVzKHByaXYpKTt2YXIgY2hlY2tzdW09c2hhMjU2KHNoYTI1NihidWZmZXIpKS5zbGljZSgwLDQpO3JldHVybiBiYXNlNTguZW5jb2RlKEJ1ZmZlci5jb25jYXQoW2J1ZmZlcixjaGVja3N1bV0pKX07SERXYWxsZXQucHJvdG90eXBlLmRlcml2ZT1mdW5jdGlvbihpKXt2YXIgSSxpQnl0ZXM9Y29udmVydC5udW1Ub0J5dGVzKGksNCkucmV2ZXJzZSgpLGNQYXI9dGhpcy5jaGFpbmNvZGUsdXNlUHJpdj1pPj1IRFdhbGxldC5ISUdIRVNUX0JJVCxTSEE1MTI9Q3J5cHRvLmFsZ28uU0hBNTEyO2lmKHVzZVByaXYpe2Fzc2VydCh0aGlzLnByaXYsXCJQcml2YXRlIGRlcml2ZSBvbiBwdWJsaWMga2V5XCIpO3ZhciBrUGFyPXRoaXMucHJpdi50b0J5dGVzKCkuc2xpY2UoMCwzMik7ST1IbWFjRnJvbUJ5dGVzVG9CeXRlcyhTSEE1MTIsWzBdLmNvbmNhdChrUGFyLGlCeXRlcyksY1Bhcil9ZWxzZXt2YXIgS1Bhcj10aGlzLnB1Yi50b0J5dGVzKHRydWUpO0k9SG1hY0Zyb21CeXRlc1RvQnl0ZXMoU0hBNTEyLEtQYXIuY29uY2F0KGlCeXRlcyksY1Bhcil9dmFyIElMPUkuc2xpY2UoMCwzMiksSVI9SS5zbGljZSgzMik7dmFyIGhkPW5ldyBIRFdhbGxldDtoZC5uZXR3b3JrPXRoaXMubmV0d29yaztpZih0aGlzLnByaXYpe2hkLnByaXY9dGhpcy5wcml2LmFkZChuZXcgRUNLZXkoSUwuY29uY2F0KFsxXSkpKTtoZC5wcml2LmNvbXByZXNzZWQ9dHJ1ZTtoZC5wcml2LnZlcnNpb249dGhpcy5nZXRLZXlWZXJzaW9uKCk7aGQucHViPWhkLnByaXYuZ2V0UHViKCl9ZWxzZXtoZC5wdWI9dGhpcy5wdWIuYWRkKG5ldyBFQ0tleShJTC5jb25jYXQoWzFdKSx0cnVlKS5nZXRQdWIoKSl9aGQuY2hhaW5jb2RlPUlSO2hkLnBhcmVudEZpbmdlcnByaW50PXRoaXMuZ2V0RmluZ2VycHJpbnQoKTtoZC5kZXB0aD10aGlzLmRlcHRoKzE7aGQuaW5kZXg9aTtoZC5wdWIuY29tcHJlc3NlZD10cnVlO3JldHVybiBoZH07SERXYWxsZXQucHJvdG90eXBlLmRlcml2ZVByaXZhdGU9ZnVuY3Rpb24oaW5kZXgpe3JldHVybiB0aGlzLmRlcml2ZShpbmRleCtIRFdhbGxldC5ISUdIRVNUX0JJVCl9O0hEV2FsbGV0LnByb3RvdHlwZS5nZXRLZXlWZXJzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuIE5ldHdvcmtbdGhpcy5uZXR3b3JrXS5hZGRyZXNzVmVyc2lvbn07SERXYWxsZXQucHJvdG90eXBlLnRvU3RyaW5nPUhEV2FsbGV0LnByb3RvdHlwZS50b0Jhc2U1ODtmdW5jdGlvbiBIbWFjRnJvbUJ5dGVzVG9CeXRlcyhoYXNoZXIsbWVzc2FnZSxrZXkpe3ZhciBobWFjPUhNQUMuY3JlYXRlKGhhc2hlcixjb252ZXJ0LmJ5dGVzVG9Xb3JkQXJyYXkoa2V5KSk7aG1hYy51cGRhdGUoY29udmVydC5ieXRlc1RvV29yZEFycmF5KG1lc3NhZ2UpKTtyZXR1cm4gY29udmVydC53b3JkQXJyYXlUb0J5dGVzKGhtYWMuZmluYWxpemUoKSl9bW9kdWxlLmV4cG9ydHM9SERXYWxsZXR9KS5jYWxsKHRoaXMsX2RlcmVxXyhcImJ1ZmZlclwiKS5CdWZmZXIpfSx7XCIuL2FkZHJlc3MuanNcIjo1NCxcIi4vYmFzZTU4LmpzXCI6NTUsXCIuL2NvbnZlcnQuanNcIjo1NyxcIi4vZWNrZXkuanNcIjo1OSxcIi4vbmV0d29ya1wiOjY2LFwiLi91dGlsLmpzXCI6NzAsYXNzZXJ0OjEsYnVmZmVyOjUsY3J5cHRvOjksXCJjcnlwdG8tanNcIjoyNyx1dGlsOjE3fV0sNjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBLZXk9X2RlcmVxXyhcIi4vZWNrZXlcIik7dmFyIFQ9X2RlcmVxXyhcIi4vdHJhbnNhY3Rpb25cIik7bW9kdWxlLmV4cG9ydHM9e0FkZHJlc3M6X2RlcmVxXyhcIi4vYWRkcmVzc1wiKSxLZXk6S2V5LkVDS2V5LEVDS2V5OktleS5FQ0tleSxFQ1B1YktleTpLZXkuRUNQdWJLZXksTWVzc2FnZTpfZGVyZXFfKFwiLi9tZXNzYWdlXCIpLEJpZ0ludGVnZXI6X2RlcmVxXyhcIi4vanNibi9qc2JuXCIpLENyeXB0bzpfZGVyZXFfKFwiY3J5cHRvLWpzXCIpLFNjcmlwdDpfZGVyZXFfKFwiLi9zY3JpcHRcIiksT3Bjb2RlOl9kZXJlcV8oXCIuL29wY29kZVwiKSxUcmFuc2FjdGlvbjpULlRyYW5zYWN0aW9uLFV0aWw6X2RlcmVxXyhcIi4vdXRpbFwiKSxUcmFuc2FjdGlvbkluOlQuVHJhbnNhY3Rpb25JbixUcmFuc2FjdGlvbk91dDpULlRyYW5zYWN0aW9uT3V0LEVDUG9pbnRGcDpfZGVyZXFfKFwiLi9qc2JuL2VjXCIpLkVDUG9pbnRGcCxXYWxsZXQ6X2RlcmVxXyhcIi4vd2FsbGV0XCIpLG5ldHdvcms6X2RlcmVxXyhcIi4vbmV0d29ya1wiKSxlY2RzYTpfZGVyZXFfKFwiLi9lY2RzYVwiKSxIRFdhbGxldDpfZGVyZXFfKFwiLi9oZHdhbGxldC5qc1wiKSxiYXNlNTg6X2RlcmVxXyhcIi4vYmFzZTU4XCIpLGJhc2U1OGNoZWNrOl9kZXJlcV8oXCIuL2Jhc2U1OGNoZWNrXCIpLGNvbnZlcnQ6X2RlcmVxXyhcIi4vY29udmVydFwiKX19LHtcIi4vYWRkcmVzc1wiOjU0LFwiLi9iYXNlNThcIjo1NSxcIi4vYmFzZTU4Y2hlY2tcIjo1NixcIi4vY29udmVydFwiOjU3LFwiLi9lY2RzYVwiOjU4LFwiLi9lY2tleVwiOjU5LFwiLi9oZHdhbGxldC5qc1wiOjYwLFwiLi9qc2JuL2VjXCI6NjIsXCIuL2pzYm4vanNiblwiOjYzLFwiLi9tZXNzYWdlXCI6NjUsXCIuL25ldHdvcmtcIjo2NixcIi4vb3Bjb2RlXCI6NjcsXCIuL3NjcmlwdFwiOjY4LFwiLi90cmFuc2FjdGlvblwiOjY5LFwiLi91dGlsXCI6NzAsXCIuL3dhbGxldFwiOjcxLFwiY3J5cHRvLWpzXCI6Mjd9XSw2MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIEJpZ0ludGVnZXI9X2RlcmVxXyhcIi4vanNiblwiKSxzZWM9X2RlcmVxXyhcIi4vc2VjXCIpO2Z1bmN0aW9uIEVDRmllbGRFbGVtZW50RnAocSx4KXt0aGlzLng9eDt0aGlzLnE9cX1mdW5jdGlvbiBmZUZwRXF1YWxzKG90aGVyKXtpZihvdGhlcj09dGhpcylyZXR1cm4gdHJ1ZTtyZXR1cm4gdGhpcy5xLmVxdWFscyhvdGhlci5xKSYmdGhpcy54LmVxdWFscyhvdGhlci54KX1mdW5jdGlvbiBmZUZwVG9CaWdJbnRlZ2VyKCl7cmV0dXJuIHRoaXMueH1mdW5jdGlvbiBmZUZwTmVnYXRlKCl7cmV0dXJuIG5ldyBFQ0ZpZWxkRWxlbWVudEZwKHRoaXMucSx0aGlzLngubmVnYXRlKCkubW9kKHRoaXMucSkpfWZ1bmN0aW9uIGZlRnBBZGQoYil7cmV0dXJuIG5ldyBFQ0ZpZWxkRWxlbWVudEZwKHRoaXMucSx0aGlzLnguYWRkKGIudG9CaWdJbnRlZ2VyKCkpLm1vZCh0aGlzLnEpKX1mdW5jdGlvbiBmZUZwU3VidHJhY3QoYil7cmV0dXJuIG5ldyBFQ0ZpZWxkRWxlbWVudEZwKHRoaXMucSx0aGlzLnguc3VidHJhY3QoYi50b0JpZ0ludGVnZXIoKSkubW9kKHRoaXMucSkpfWZ1bmN0aW9uIGZlRnBNdWx0aXBseShiKXtyZXR1cm4gbmV3IEVDRmllbGRFbGVtZW50RnAodGhpcy5xLHRoaXMueC5tdWx0aXBseShiLnRvQmlnSW50ZWdlcigpKS5tb2QodGhpcy5xKSl9ZnVuY3Rpb24gZmVGcFNxdWFyZSgpe3JldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcCh0aGlzLnEsdGhpcy54LnNxdWFyZSgpLm1vZCh0aGlzLnEpKX1mdW5jdGlvbiBmZUZwRGl2aWRlKGIpe3JldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcCh0aGlzLnEsdGhpcy54Lm11bHRpcGx5KGIudG9CaWdJbnRlZ2VyKCkubW9kSW52ZXJzZSh0aGlzLnEpKS5tb2QodGhpcy5xKSl9RUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUuZXF1YWxzPWZlRnBFcXVhbHM7RUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUudG9CaWdJbnRlZ2VyPWZlRnBUb0JpZ0ludGVnZXI7RUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUubmVnYXRlPWZlRnBOZWdhdGU7RUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUuYWRkPWZlRnBBZGQ7RUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUuc3VidHJhY3Q9ZmVGcFN1YnRyYWN0O0VDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLm11bHRpcGx5PWZlRnBNdWx0aXBseTtFQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5zcXVhcmU9ZmVGcFNxdWFyZTtFQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5kaXZpZGU9ZmVGcERpdmlkZTtmdW5jdGlvbiBFQ1BvaW50RnAoY3VydmUseCx5LHope3RoaXMuY3VydmU9Y3VydmU7dGhpcy54PXg7dGhpcy55PXk7aWYoej09bnVsbCl7dGhpcy56PUJpZ0ludGVnZXIuT05FfWVsc2V7dGhpcy56PXp9dGhpcy56aW52PW51bGx9ZnVuY3Rpb24gcG9pbnRGcEdldFgoKXtpZih0aGlzLnppbnY9PW51bGwpe3RoaXMuemludj10aGlzLnoubW9kSW52ZXJzZSh0aGlzLmN1cnZlLnEpfXJldHVybiB0aGlzLmN1cnZlLmZyb21CaWdJbnRlZ2VyKHRoaXMueC50b0JpZ0ludGVnZXIoKS5tdWx0aXBseSh0aGlzLnppbnYpLm1vZCh0aGlzLmN1cnZlLnEpKX1mdW5jdGlvbiBwb2ludEZwR2V0WSgpe2lmKHRoaXMuemludj09bnVsbCl7dGhpcy56aW52PXRoaXMuei5tb2RJbnZlcnNlKHRoaXMuY3VydmUucSl9cmV0dXJuIHRoaXMuY3VydmUuZnJvbUJpZ0ludGVnZXIodGhpcy55LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KHRoaXMuemludikubW9kKHRoaXMuY3VydmUucSkpfWZ1bmN0aW9uIHBvaW50RnBFcXVhbHMob3RoZXIpe2lmKG90aGVyPT10aGlzKXJldHVybiB0cnVlO2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVybiBvdGhlci5pc0luZmluaXR5KCk7aWYob3RoZXIuaXNJbmZpbml0eSgpKXJldHVybiB0aGlzLmlzSW5maW5pdHkoKTt2YXIgdSx2O3U9b3RoZXIueS50b0JpZ0ludGVnZXIoKS5tdWx0aXBseSh0aGlzLnopLnN1YnRyYWN0KHRoaXMueS50b0JpZ0ludGVnZXIoKS5tdWx0aXBseShvdGhlci56KSkubW9kKHRoaXMuY3VydmUucSk7aWYoIXUuZXF1YWxzKEJpZ0ludGVnZXIuWkVSTykpcmV0dXJuIGZhbHNlO3Y9b3RoZXIueC50b0JpZ0ludGVnZXIoKS5tdWx0aXBseSh0aGlzLnopLnN1YnRyYWN0KHRoaXMueC50b0JpZ0ludGVnZXIoKS5tdWx0aXBseShvdGhlci56KSkubW9kKHRoaXMuY3VydmUucSk7cmV0dXJuIHYuZXF1YWxzKEJpZ0ludGVnZXIuWkVSTyl9ZnVuY3Rpb24gcG9pbnRGcElzSW5maW5pdHkoKXtpZih0aGlzLng9PW51bGwmJnRoaXMueT09bnVsbClyZXR1cm4gdHJ1ZTtyZXR1cm4gdGhpcy56LmVxdWFscyhCaWdJbnRlZ2VyLlpFUk8pJiYhdGhpcy55LnRvQmlnSW50ZWdlcigpLmVxdWFscyhCaWdJbnRlZ2VyLlpFUk8pfWZ1bmN0aW9uIHBvaW50RnBOZWdhdGUoKXtyZXR1cm4gbmV3IEVDUG9pbnRGcCh0aGlzLmN1cnZlLHRoaXMueCx0aGlzLnkubmVnYXRlKCksdGhpcy56KX1mdW5jdGlvbiBwb2ludEZwQWRkKGIpe2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVybiBiO2lmKGIuaXNJbmZpbml0eSgpKXJldHVybiB0aGlzO3ZhciB1PWIueS50b0JpZ0ludGVnZXIoKS5tdWx0aXBseSh0aGlzLnopLnN1YnRyYWN0KHRoaXMueS50b0JpZ0ludGVnZXIoKS5tdWx0aXBseShiLnopKS5tb2QodGhpcy5jdXJ2ZS5xKTt2YXIgdj1iLngudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkodGhpcy56KS5zdWJ0cmFjdCh0aGlzLngudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkoYi56KSkubW9kKHRoaXMuY3VydmUucSk7aWYoQmlnSW50ZWdlci5aRVJPLmVxdWFscyh2KSl7aWYoQmlnSW50ZWdlci5aRVJPLmVxdWFscyh1KSl7cmV0dXJuIHRoaXMudHdpY2UoKX1yZXR1cm4gdGhpcy5jdXJ2ZS5nZXRJbmZpbml0eSgpfXZhciBUSFJFRT1uZXcgQmlnSW50ZWdlcihcIjNcIik7dmFyIHgxPXRoaXMueC50b0JpZ0ludGVnZXIoKTt2YXIgeTE9dGhpcy55LnRvQmlnSW50ZWdlcigpO3ZhciB4Mj1iLngudG9CaWdJbnRlZ2VyKCk7dmFyIHkyPWIueS50b0JpZ0ludGVnZXIoKTt2YXIgdjI9di5zcXVhcmUoKTt2YXIgdjM9djIubXVsdGlwbHkodik7dmFyIHgxdjI9eDEubXVsdGlwbHkodjIpO3ZhciB6dTI9dS5zcXVhcmUoKS5tdWx0aXBseSh0aGlzLnopO3ZhciB4Mz16dTIuc3VidHJhY3QoeDF2Mi5zaGlmdExlZnQoMSkpLm11bHRpcGx5KGIueikuc3VidHJhY3QodjMpLm11bHRpcGx5KHYpLm1vZCh0aGlzLmN1cnZlLnEpO3ZhciB5Mz14MXYyLm11bHRpcGx5KFRIUkVFKS5tdWx0aXBseSh1KS5zdWJ0cmFjdCh5MS5tdWx0aXBseSh2MykpLnN1YnRyYWN0KHp1Mi5tdWx0aXBseSh1KSkubXVsdGlwbHkoYi56KS5hZGQodS5tdWx0aXBseSh2MykpLm1vZCh0aGlzLmN1cnZlLnEpO3ZhciB6Mz12My5tdWx0aXBseSh0aGlzLnopLm11bHRpcGx5KGIueikubW9kKHRoaXMuY3VydmUucSk7cmV0dXJuIG5ldyBFQ1BvaW50RnAodGhpcy5jdXJ2ZSx0aGlzLmN1cnZlLmZyb21CaWdJbnRlZ2VyKHgzKSx0aGlzLmN1cnZlLmZyb21CaWdJbnRlZ2VyKHkzKSx6Myl9ZnVuY3Rpb24gcG9pbnRGcFR3aWNlKCl7aWYodGhpcy5pc0luZmluaXR5KCkpcmV0dXJuIHRoaXM7aWYodGhpcy55LnRvQmlnSW50ZWdlcigpLnNpZ251bSgpPT0wKXJldHVybiB0aGlzLmN1cnZlLmdldEluZmluaXR5KCk7dmFyIFRIUkVFPW5ldyBCaWdJbnRlZ2VyKFwiM1wiKTt2YXIgeDE9dGhpcy54LnRvQmlnSW50ZWdlcigpO3ZhciB5MT10aGlzLnkudG9CaWdJbnRlZ2VyKCk7dmFyIHkxejE9eTEubXVsdGlwbHkodGhpcy56KTt2YXIgeTFzcXoxPXkxejEubXVsdGlwbHkoeTEpLm1vZCh0aGlzLmN1cnZlLnEpO3ZhciBhPXRoaXMuY3VydmUuYS50b0JpZ0ludGVnZXIoKTtcbnZhciB3PXgxLnNxdWFyZSgpLm11bHRpcGx5KFRIUkVFKTtpZighQmlnSW50ZWdlci5aRVJPLmVxdWFscyhhKSl7dz13LmFkZCh0aGlzLnouc3F1YXJlKCkubXVsdGlwbHkoYSkpfXc9dy5tb2QodGhpcy5jdXJ2ZS5xKTt2YXIgeDM9dy5zcXVhcmUoKS5zdWJ0cmFjdCh4MS5zaGlmdExlZnQoMykubXVsdGlwbHkoeTFzcXoxKSkuc2hpZnRMZWZ0KDEpLm11bHRpcGx5KHkxejEpLm1vZCh0aGlzLmN1cnZlLnEpO3ZhciB5Mz13Lm11bHRpcGx5KFRIUkVFKS5tdWx0aXBseSh4MSkuc3VidHJhY3QoeTFzcXoxLnNoaWZ0TGVmdCgxKSkuc2hpZnRMZWZ0KDIpLm11bHRpcGx5KHkxc3F6MSkuc3VidHJhY3Qody5zcXVhcmUoKS5tdWx0aXBseSh3KSkubW9kKHRoaXMuY3VydmUucSk7dmFyIHozPXkxejEuc3F1YXJlKCkubXVsdGlwbHkoeTF6MSkuc2hpZnRMZWZ0KDMpLm1vZCh0aGlzLmN1cnZlLnEpO3JldHVybiBuZXcgRUNQb2ludEZwKHRoaXMuY3VydmUsdGhpcy5jdXJ2ZS5mcm9tQmlnSW50ZWdlcih4MyksdGhpcy5jdXJ2ZS5mcm9tQmlnSW50ZWdlcih5MyksejMpfWZ1bmN0aW9uIHBvaW50RnBNdWx0aXBseShrKXtpZih0aGlzLmlzSW5maW5pdHkoKSlyZXR1cm4gdGhpcztpZihrLnNpZ251bSgpPT0wKXJldHVybiB0aGlzLmN1cnZlLmdldEluZmluaXR5KCk7dmFyIGU9azt2YXIgaD1lLm11bHRpcGx5KG5ldyBCaWdJbnRlZ2VyKFwiM1wiKSk7dmFyIG5lZz10aGlzLm5lZ2F0ZSgpO3ZhciBSPXRoaXM7dmFyIGk7Zm9yKGk9aC5iaXRMZW5ndGgoKS0yO2k+MDstLWkpe1I9Ui50d2ljZSgpO3ZhciBoQml0PWgudGVzdEJpdChpKTt2YXIgZUJpdD1lLnRlc3RCaXQoaSk7aWYoaEJpdCE9ZUJpdCl7Uj1SLmFkZChoQml0P3RoaXM6bmVnKX19cmV0dXJuIFJ9ZnVuY3Rpb24gcG9pbnRGcE11bHRpcGx5VHdvKGoseCxrKXt2YXIgaTtpZihqLmJpdExlbmd0aCgpPmsuYml0TGVuZ3RoKCkpaT1qLmJpdExlbmd0aCgpLTE7ZWxzZSBpPWsuYml0TGVuZ3RoKCktMTt2YXIgUj10aGlzLmN1cnZlLmdldEluZmluaXR5KCk7dmFyIGJvdGg9dGhpcy5hZGQoeCk7d2hpbGUoaT49MCl7Uj1SLnR3aWNlKCk7aWYoai50ZXN0Qml0KGkpKXtpZihrLnRlc3RCaXQoaSkpe1I9Ui5hZGQoYm90aCl9ZWxzZXtSPVIuYWRkKHRoaXMpfX1lbHNle2lmKGsudGVzdEJpdChpKSl7Uj1SLmFkZCh4KX19LS1pfXJldHVybiBSfUVDUG9pbnRGcC5wcm90b3R5cGUuZ2V0WD1wb2ludEZwR2V0WDtFQ1BvaW50RnAucHJvdG90eXBlLmdldFk9cG9pbnRGcEdldFk7RUNQb2ludEZwLnByb3RvdHlwZS5lcXVhbHM9cG9pbnRGcEVxdWFscztFQ1BvaW50RnAucHJvdG90eXBlLmlzSW5maW5pdHk9cG9pbnRGcElzSW5maW5pdHk7RUNQb2ludEZwLnByb3RvdHlwZS5uZWdhdGU9cG9pbnRGcE5lZ2F0ZTtFQ1BvaW50RnAucHJvdG90eXBlLmFkZD1wb2ludEZwQWRkO0VDUG9pbnRGcC5wcm90b3R5cGUudHdpY2U9cG9pbnRGcFR3aWNlO0VDUG9pbnRGcC5wcm90b3R5cGUubXVsdGlwbHk9cG9pbnRGcE11bHRpcGx5O0VDUG9pbnRGcC5wcm90b3R5cGUubXVsdGlwbHlUd289cG9pbnRGcE11bHRpcGx5VHdvO2Z1bmN0aW9uIEVDQ3VydmVGcChxLGEsYil7dGhpcy5xPXE7dGhpcy5hPXRoaXMuZnJvbUJpZ0ludGVnZXIoYSk7dGhpcy5iPXRoaXMuZnJvbUJpZ0ludGVnZXIoYik7dGhpcy5pbmZpbml0eT1uZXcgRUNQb2ludEZwKHRoaXMsbnVsbCxudWxsKX1mdW5jdGlvbiBjdXJ2ZUZwR2V0USgpe3JldHVybiB0aGlzLnF9ZnVuY3Rpb24gY3VydmVGcEdldEEoKXtyZXR1cm4gdGhpcy5hfWZ1bmN0aW9uIGN1cnZlRnBHZXRCKCl7cmV0dXJuIHRoaXMuYn1mdW5jdGlvbiBjdXJ2ZUZwRXF1YWxzKG90aGVyKXtpZihvdGhlcj09dGhpcylyZXR1cm4gdHJ1ZTtyZXR1cm4gdGhpcy5xLmVxdWFscyhvdGhlci5xKSYmdGhpcy5hLmVxdWFscyhvdGhlci5hKSYmdGhpcy5iLmVxdWFscyhvdGhlci5iKX1mdW5jdGlvbiBjdXJ2ZUZwR2V0SW5maW5pdHkoKXtyZXR1cm4gdGhpcy5pbmZpbml0eX1mdW5jdGlvbiBjdXJ2ZUZwRnJvbUJpZ0ludGVnZXIoeCl7cmV0dXJuIG5ldyBFQ0ZpZWxkRWxlbWVudEZwKHRoaXMucSx4KX1mdW5jdGlvbiBjdXJ2ZUZwRGVjb2RlUG9pbnRIZXgocyl7c3dpdGNoKHBhcnNlSW50KHMuc3Vic3RyKDAsMiksMTYpKXtjYXNlIDA6cmV0dXJuIHRoaXMuaW5maW5pdHk7Y2FzZSAyOmNhc2UgMzpyZXR1cm4gbnVsbDtjYXNlIDQ6Y2FzZSA2OmNhc2UgNzp2YXIgbGVuPShzLmxlbmd0aC0yKS8yO3ZhciB4SGV4PXMuc3Vic3RyKDIsbGVuKTt2YXIgeUhleD1zLnN1YnN0cihsZW4rMixsZW4pO3JldHVybiBuZXcgRUNQb2ludEZwKHRoaXMsdGhpcy5mcm9tQmlnSW50ZWdlcihuZXcgQmlnSW50ZWdlcih4SGV4LDE2KSksdGhpcy5mcm9tQmlnSW50ZWdlcihuZXcgQmlnSW50ZWdlcih5SGV4LDE2KSkpO2RlZmF1bHQ6cmV0dXJuIG51bGx9fUVDQ3VydmVGcC5wcm90b3R5cGUuZ2V0UT1jdXJ2ZUZwR2V0UTtFQ0N1cnZlRnAucHJvdG90eXBlLmdldEE9Y3VydmVGcEdldEE7RUNDdXJ2ZUZwLnByb3RvdHlwZS5nZXRCPWN1cnZlRnBHZXRCO0VDQ3VydmVGcC5wcm90b3R5cGUuZXF1YWxzPWN1cnZlRnBFcXVhbHM7RUNDdXJ2ZUZwLnByb3RvdHlwZS5nZXRJbmZpbml0eT1jdXJ2ZUZwR2V0SW5maW5pdHk7RUNDdXJ2ZUZwLnByb3RvdHlwZS5mcm9tQmlnSW50ZWdlcj1jdXJ2ZUZwRnJvbUJpZ0ludGVnZXI7RUNDdXJ2ZUZwLnByb3RvdHlwZS5kZWNvZGVQb2ludEhleD1jdXJ2ZUZwRGVjb2RlUG9pbnRIZXg7ZnVuY3Rpb24gaW50ZWdlclRvQnl0ZXMoaSxsZW4pe3ZhciBieXRlcz1pLnRvQnl0ZUFycmF5VW5zaWduZWQoKTtpZihsZW48Ynl0ZXMubGVuZ3RoKXtieXRlcz1ieXRlcy5zbGljZShieXRlcy5sZW5ndGgtbGVuKX1lbHNlIHdoaWxlKGxlbj5ieXRlcy5sZW5ndGgpe2J5dGVzLnVuc2hpZnQoMCl9cmV0dXJuIGJ5dGVzfUVDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLmdldEJ5dGVMZW5ndGg9ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5mbG9vcigodGhpcy50b0JpZ0ludGVnZXIoKS5iaXRMZW5ndGgoKSs3KS84KX07RUNQb2ludEZwLnByb3RvdHlwZS5nZXRFbmNvZGVkPWZ1bmN0aW9uKGNvbXByZXNzZWQpe3ZhciB4PXRoaXMuZ2V0WCgpLnRvQmlnSW50ZWdlcigpO3ZhciB5PXRoaXMuZ2V0WSgpLnRvQmlnSW50ZWdlcigpO3ZhciBlbmM9aW50ZWdlclRvQnl0ZXMoeCwzMik7aWYoY29tcHJlc3NlZCl7aWYoeS5pc0V2ZW4oKSl7ZW5jLnVuc2hpZnQoMil9ZWxzZXtlbmMudW5zaGlmdCgzKX19ZWxzZXtlbmMudW5zaGlmdCg0KTtlbmM9ZW5jLmNvbmNhdChpbnRlZ2VyVG9CeXRlcyh5LDMyKSl9cmV0dXJuIGVuY307RUNQb2ludEZwLmRlY29kZUZyb209ZnVuY3Rpb24oZWNwYXJhbXMsZW5jKXt2YXIgdHlwZT1lbmNbMF07dmFyIGRhdGFMZW49ZW5jLmxlbmd0aC0xO2lmKHR5cGU9PTQpe3ZhciB4QmE9ZW5jLnNsaWNlKDEsMStkYXRhTGVuLzIpLHlCYT1lbmMuc2xpY2UoMStkYXRhTGVuLzIsMStkYXRhTGVuKSx4PUJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKHhCYSkseT1CaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZCh5QmEpfWVsc2V7dmFyIHhCYT1lbmMuc2xpY2UoMSkseD1CaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZCh4QmEpLHA9ZWNwYXJhbXMuZ2V0USgpLHhDdWJlZFBsdXM3PXgubXVsdGlwbHkoeCkubXVsdGlwbHkoeCkuYWRkKG5ldyBCaWdJbnRlZ2VyKFwiN1wiKSkubW9kKHApLHBQbHVzMU92ZXI0PXAuYWRkKG5ldyBCaWdJbnRlZ2VyKFwiMVwiKSkuZGl2aWRlKG5ldyBCaWdJbnRlZ2VyKFwiNFwiKSkseT14Q3ViZWRQbHVzNy5tb2RQb3cocFBsdXMxT3ZlcjQscCk7aWYoeS5tb2QobmV3IEJpZ0ludGVnZXIoXCIyXCIpKS50b1N0cmluZygpIT1cIlwiK3R5cGUlMil7eT1wLnN1YnRyYWN0KHkpfX1yZXR1cm4gbmV3IEVDUG9pbnRGcChlY3BhcmFtcyxlY3BhcmFtcy5mcm9tQmlnSW50ZWdlcih4KSxlY3BhcmFtcy5mcm9tQmlnSW50ZWdlcih5KSl9O0VDUG9pbnRGcC5wcm90b3R5cGUuYWRkMkQ9ZnVuY3Rpb24oYil7aWYodGhpcy5pc0luZmluaXR5KCkpcmV0dXJuIGI7aWYoYi5pc0luZmluaXR5KCkpcmV0dXJuIHRoaXM7aWYodGhpcy54LmVxdWFscyhiLngpKXtpZih0aGlzLnkuZXF1YWxzKGIueSkpe3JldHVybiB0aGlzLnR3aWNlKCl9cmV0dXJuIHRoaXMuY3VydmUuZ2V0SW5maW5pdHkoKX12YXIgeF94PWIueC5zdWJ0cmFjdCh0aGlzLngpO3ZhciB5X3k9Yi55LnN1YnRyYWN0KHRoaXMueSk7dmFyIGdhbW1hPXlfeS5kaXZpZGUoeF94KTt2YXIgeDM9Z2FtbWEuc3F1YXJlKCkuc3VidHJhY3QodGhpcy54KS5zdWJ0cmFjdChiLngpO3ZhciB5Mz1nYW1tYS5tdWx0aXBseSh0aGlzLnguc3VidHJhY3QoeDMpKS5zdWJ0cmFjdCh0aGlzLnkpO3JldHVybiBuZXcgRUNQb2ludEZwKHRoaXMuY3VydmUseDMseTMpfTtFQ1BvaW50RnAucHJvdG90eXBlLnR3aWNlMkQ9ZnVuY3Rpb24oKXtpZih0aGlzLmlzSW5maW5pdHkoKSlyZXR1cm4gdGhpcztpZih0aGlzLnkudG9CaWdJbnRlZ2VyKCkuc2lnbnVtKCk9PTApe3JldHVybiB0aGlzLmN1cnZlLmdldEluZmluaXR5KCl9dmFyIFRXTz10aGlzLmN1cnZlLmZyb21CaWdJbnRlZ2VyKEJpZ0ludGVnZXIudmFsdWVPZigyKSk7dmFyIFRIUkVFPXRoaXMuY3VydmUuZnJvbUJpZ0ludGVnZXIoQmlnSW50ZWdlci52YWx1ZU9mKDMpKTt2YXIgZ2FtbWE9dGhpcy54LnNxdWFyZSgpLm11bHRpcGx5KFRIUkVFKS5hZGQodGhpcy5jdXJ2ZS5hKS5kaXZpZGUodGhpcy55Lm11bHRpcGx5KFRXTykpO3ZhciB4Mz1nYW1tYS5zcXVhcmUoKS5zdWJ0cmFjdCh0aGlzLngubXVsdGlwbHkoVFdPKSk7dmFyIHkzPWdhbW1hLm11bHRpcGx5KHRoaXMueC5zdWJ0cmFjdCh4MykpLnN1YnRyYWN0KHRoaXMueSk7cmV0dXJuIG5ldyBFQ1BvaW50RnAodGhpcy5jdXJ2ZSx4Myx5Myl9O0VDUG9pbnRGcC5wcm90b3R5cGUubXVsdGlwbHkyRD1mdW5jdGlvbihrKXtpZih0aGlzLmlzSW5maW5pdHkoKSlyZXR1cm4gdGhpcztpZihrLnNpZ251bSgpPT0wKXJldHVybiB0aGlzLmN1cnZlLmdldEluZmluaXR5KCk7dmFyIGU9azt2YXIgaD1lLm11bHRpcGx5KG5ldyBCaWdJbnRlZ2VyKFwiM1wiKSk7dmFyIG5lZz10aGlzLm5lZ2F0ZSgpO3ZhciBSPXRoaXM7dmFyIGk7Zm9yKGk9aC5iaXRMZW5ndGgoKS0yO2k+MDstLWkpe1I9Ui50d2ljZSgpO3ZhciBoQml0PWgudGVzdEJpdChpKTt2YXIgZUJpdD1lLnRlc3RCaXQoaSk7aWYoaEJpdCE9ZUJpdCl7Uj1SLmFkZDJEKGhCaXQ/dGhpczpuZWcpfX1yZXR1cm4gUn07RUNQb2ludEZwLnByb3RvdHlwZS5pc09uQ3VydmU9ZnVuY3Rpb24oKXt2YXIgeD10aGlzLmdldFgoKS50b0JpZ0ludGVnZXIoKTt2YXIgeT10aGlzLmdldFkoKS50b0JpZ0ludGVnZXIoKTt2YXIgYT10aGlzLmN1cnZlLmdldEEoKS50b0JpZ0ludGVnZXIoKTt2YXIgYj10aGlzLmN1cnZlLmdldEIoKS50b0JpZ0ludGVnZXIoKTt2YXIgbj10aGlzLmN1cnZlLmdldFEoKTt2YXIgbGhzPXkubXVsdGlwbHkoeSkubW9kKG4pO3ZhciByaHM9eC5tdWx0aXBseSh4KS5tdWx0aXBseSh4KS5hZGQoYS5tdWx0aXBseSh4KSkuYWRkKGIpLm1vZChuKTtyZXR1cm4gbGhzLmVxdWFscyhyaHMpfTtFQ1BvaW50RnAucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCIoXCIrdGhpcy5nZXRYKCkudG9CaWdJbnRlZ2VyKCkudG9TdHJpbmcoKStcIixcIit0aGlzLmdldFkoKS50b0JpZ0ludGVnZXIoKS50b1N0cmluZygpK1wiKVwifTtFQ1BvaW50RnAucHJvdG90eXBlLnZhbGlkYXRlPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy5jdXJ2ZS5nZXRRKCk7aWYodGhpcy5pc0luZmluaXR5KCkpe3Rocm93IG5ldyBFcnJvcihcIlBvaW50IGlzIGF0IGluZmluaXR5LlwiKX12YXIgeD10aGlzLmdldFgoKS50b0JpZ0ludGVnZXIoKTt2YXIgeT10aGlzLmdldFkoKS50b0JpZ0ludGVnZXIoKTtpZih4LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSk8MHx8eC5jb21wYXJlVG8obi5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkpPjApe3Rocm93IG5ldyBFcnJvcihcInggY29vcmRpbmF0ZSBvdXQgb2YgYm91bmRzXCIpfWlmKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKTwwfHx5LmNvbXBhcmVUbyhuLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKSk+MCl7dGhyb3cgbmV3IEVycm9yKFwieSBjb29yZGluYXRlIG91dCBvZiBib3VuZHNcIil9aWYoIXRoaXMuaXNPbkN1cnZlKCkpe3Rocm93IG5ldyBFcnJvcihcIlBvaW50IGlzIG5vdCBvbiB0aGUgY3VydmUuXCIpfWlmKHRoaXMubXVsdGlwbHkobikuaXNJbmZpbml0eSgpKXt0aHJvdyBuZXcgRXJyb3IoXCJQb2ludCBpcyBub3QgYSBzY2FsYXIgbXVsdGlwbGUgb2YgRy5cIil9cmV0dXJuIHRydWV9O21vZHVsZS5leHBvcnRzPUVDQ3VydmVGcDttb2R1bGUuZXhwb3J0cy5FQ1BvaW50RnA9RUNQb2ludEZwfSx7XCIuL2pzYm5cIjo2MyxcIi4vc2VjXCI6NjR9XSw2MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKEJ1ZmZlcil7dmFyIGRiaXRzO3ZhciBjYW5hcnk9MHhkZWFkYmVlZmNhZmU7dmFyIGpfbG09KGNhbmFyeSYxNjc3NzIxNSk9PTE1NzE1MDcwO2Z1bmN0aW9uIEJpZ0ludGVnZXIoYSxiLGMpe2lmKCEodGhpcyBpbnN0YW5jZW9mIEJpZ0ludGVnZXIpKXtyZXR1cm4gbmV3IEJpZ0ludGVnZXIoYSxiLGMpfWlmKGEhPW51bGwpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhKXRoaXMuZnJvbU51bWJlcihhLGIsYyk7ZWxzZSBpZihiPT1udWxsJiZcInN0cmluZ1wiIT10eXBlb2YgYSl0aGlzLmZyb21TdHJpbmcoYSwyNTYpO2Vsc2UgdGhpcy5mcm9tU3RyaW5nKGEsYil9fXZhciBwcm90bz1CaWdJbnRlZ2VyLnByb3RvdHlwZTtmdW5jdGlvbiBuYmkoKXtyZXR1cm4gbmV3IEJpZ0ludGVnZXIobnVsbCl9ZnVuY3Rpb24gYW0xKGkseCx3LGosYyxuKXt3aGlsZSgtLW4+PTApe3ZhciB2PXgqdGhpc1tpKytdK3dbal0rYztjPU1hdGguZmxvb3Iodi82NzEwODg2NCk7d1tqKytdPXYmNjcxMDg4NjN9cmV0dXJuIGN9ZnVuY3Rpb24gYW0yKGkseCx3LGosYyxuKXt2YXIgeGw9eCYzMjc2Nyx4aD14Pj4xNTt3aGlsZSgtLW4+PTApe3ZhciBsPXRoaXNbaV0mMzI3Njc7dmFyIGg9dGhpc1tpKytdPj4xNTt2YXIgbT14aCpsK2gqeGw7bD14bCpsKygobSYzMjc2Nyk8PDE1KSt3W2pdKyhjJjEwNzM3NDE4MjMpO2M9KGw+Pj4zMCkrKG0+Pj4xNSkreGgqaCsoYz4+PjMwKTt3W2orK109bCYxMDczNzQxODIzfXJldHVybiBjfWZ1bmN0aW9uIGFtMyhpLHgsdyxqLGMsbil7dmFyIHhsPXgmMTYzODMseGg9eD4+MTQ7d2hpbGUoLS1uPj0wKXt2YXIgbD10aGlzW2ldJjE2MzgzO3ZhciBoPXRoaXNbaSsrXT4+MTQ7dmFyIG09eGgqbCtoKnhsO2w9eGwqbCsoKG0mMTYzODMpPDwxNCkrd1tqXStjO2M9KGw+PjI4KSsobT4+MTQpK3hoKmg7d1tqKytdPWwmMjY4NDM1NDU1fXJldHVybiBjfUJpZ0ludGVnZXIucHJvdG90eXBlLmFtPWFtMTtkYml0cz0yNjtCaWdJbnRlZ2VyLnByb3RvdHlwZS5EQj1kYml0cztCaWdJbnRlZ2VyLnByb3RvdHlwZS5ETT0oMTw8ZGJpdHMpLTE7dmFyIERWPUJpZ0ludGVnZXIucHJvdG90eXBlLkRWPTE8PGRiaXRzO3ZhciBCSV9GUD01MjtCaWdJbnRlZ2VyLnByb3RvdHlwZS5GVj1NYXRoLnBvdygyLEJJX0ZQKTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5GMT1CSV9GUC1kYml0cztCaWdJbnRlZ2VyLnByb3RvdHlwZS5GMj0yKmRiaXRzLUJJX0ZQO3ZhciBCSV9STT1cIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO3ZhciBCSV9SQz1uZXcgQXJyYXk7dmFyIHJyLHZ2O3JyPVwiMFwiLmNoYXJDb2RlQXQoMCk7Zm9yKHZ2PTA7dnY8PTk7Kyt2dilCSV9SQ1tycisrXT12djtycj1cImFcIi5jaGFyQ29kZUF0KDApO2Zvcih2dj0xMDt2djwzNjsrK3Z2KUJJX1JDW3JyKytdPXZ2O3JyPVwiQVwiLmNoYXJDb2RlQXQoMCk7Zm9yKHZ2PTEwO3Z2PDM2OysrdnYpQklfUkNbcnIrK109dnY7ZnVuY3Rpb24gaW50MmNoYXIobil7cmV0dXJuIEJJX1JNLmNoYXJBdChuKX1mdW5jdGlvbiBpbnRBdChzLGkpe3ZhciBjPUJJX1JDW3MuY2hhckNvZGVBdChpKV07cmV0dXJuIGM9PW51bGw/LTE6Y31mdW5jdGlvbiBibnBDb3B5VG8ocil7Zm9yKHZhciBpPXRoaXMudC0xO2k+PTA7LS1pKXJbaV09dGhpc1tpXTtyLnQ9dGhpcy50O3Iucz10aGlzLnN9ZnVuY3Rpb24gYm5wRnJvbUludCh4KXt0aGlzLnQ9MTt0aGlzLnM9eDwwPy0xOjA7aWYoeD4wKXRoaXNbMF09eDtlbHNlIGlmKHg8LTEpdGhpc1swXT14K0RWO2Vsc2UgdGhpcy50PTB9ZnVuY3Rpb24gbmJ2KGkpe3ZhciByPW5iaSgpO3IuZnJvbUludChpKTtyZXR1cm4gcn1mdW5jdGlvbiBibnBGcm9tU3RyaW5nKHMsYil7dmFyIHNlbGY9dGhpczt2YXIgaztpZihiPT0xNilrPTQ7ZWxzZSBpZihiPT04KWs9MztlbHNlIGlmKGI9PTI1NilrPTg7ZWxzZSBpZihiPT0yKWs9MTtlbHNlIGlmKGI9PTMyKWs9NTtlbHNlIGlmKGI9PTQpaz0yO2Vsc2V7c2VsZi5mcm9tUmFkaXgocyxiKTtyZXR1cm59c2VsZi50PTA7c2VsZi5zPTA7dmFyIGk9cy5sZW5ndGgsbWk9ZmFsc2Usc2g9MDt3aGlsZSgtLWk+PTApe3ZhciB4PWs9PTg/c1tpXSYyNTU6aW50QXQocyxpKTtpZih4PDApe2lmKHMuY2hhckF0KGkpPT1cIi1cIiltaT10cnVlO2NvbnRpbnVlfW1pPWZhbHNlO2lmKHNoPT0wKXNlbGZbc2VsZi50KytdPXg7ZWxzZSBpZihzaCtrPnNlbGYuREIpe3NlbGZbc2VsZi50LTFdfD0oeCYoMTw8c2VsZi5EQi1zaCktMSk8PHNoO3NlbGZbc2VsZi50KytdPXg+PnNlbGYuREItc2h9ZWxzZSBzZWxmW3NlbGYudC0xXXw9eDw8c2g7c2grPWs7aWYoc2g+PXNlbGYuREIpc2gtPXNlbGYuREJ9aWYoaz09OCYmKHNbMF0mMTI4KSE9MCl7c2VsZi5zPS0xO2lmKHNoPjApc2VsZltzZWxmLnQtMV18PSgxPDxzZWxmLkRCLXNoKS0xPDxzaH1zZWxmLmNsYW1wKCk7aWYobWkpQmlnSW50ZWdlci5aRVJPLnN1YlRvKHNlbGYsc2VsZil9ZnVuY3Rpb24gYm5wQ2xhbXAoKXt2YXIgYz10aGlzLnMmdGhpcy5ETTt3aGlsZSh0aGlzLnQ+MCYmdGhpc1t0aGlzLnQtMV09PWMpLS10aGlzLnR9ZnVuY3Rpb24gYm5Ub1N0cmluZyhiKXt2YXIgc2VsZj10aGlzO2lmKHNlbGYuczwwKXJldHVyblwiLVwiK3NlbGYubmVnYXRlKCkudG9TdHJpbmcoYik7dmFyIGs7aWYoYj09MTYpaz00O2Vsc2UgaWYoYj09OClrPTM7ZWxzZSBpZihiPT0yKWs9MTtlbHNlIGlmKGI9PTMyKWs9NTtlbHNlIGlmKGI9PTQpaz0yO2Vsc2UgcmV0dXJuIHNlbGYudG9SYWRpeChiKTt2YXIga209KDE8PGspLTEsZCxtPWZhbHNlLHI9XCJcIixpPXNlbGYudDt2YXIgcD1zZWxmLkRCLWkqc2VsZi5EQiVrO2lmKGktLT4wKXtpZihwPHNlbGYuREImJihkPXNlbGZbaV0+PnApPjApe209dHJ1ZTtyPWludDJjaGFyKGQpfXdoaWxlKGk+PTApe2lmKHA8ayl7ZD0oc2VsZltpXSYoMTw8cCktMSk8PGstcDtkfD1zZWxmWy0taV0+PihwKz1zZWxmLkRCLWspfWVsc2V7ZD1zZWxmW2ldPj4ocC09aykma207aWYocDw9MCl7cCs9c2VsZi5EQjstLWl9fWlmKGQ+MCltPXRydWU7aWYobSlyKz1pbnQyY2hhcihkKX19cmV0dXJuIG0/cjpcIjBcIn1mdW5jdGlvbiBibk5lZ2F0ZSgpe3ZhciByPW5iaSgpO0JpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLHIpO3JldHVybiByfWZ1bmN0aW9uIGJuQWJzKCl7cmV0dXJuIHRoaXMuczwwP3RoaXMubmVnYXRlKCk6dGhpc31mdW5jdGlvbiBibkNvbXBhcmVUbyhhKXt2YXIgcj10aGlzLnMtYS5zO2lmKHIhPTApcmV0dXJuIHI7dmFyIGk9dGhpcy50O3I9aS1hLnQ7aWYociE9MClyZXR1cm4gdGhpcy5zPDA/LXI6cjt3aGlsZSgtLWk+PTApaWYoKHI9dGhpc1tpXS1hW2ldKSE9MClyZXR1cm4gcjtyZXR1cm4gMH1mdW5jdGlvbiBuYml0cyh4KXt2YXIgcj0xLHQ7aWYoKHQ9eD4+PjE2KSE9MCl7eD10O3IrPTE2fWlmKCh0PXg+PjgpIT0wKXt4PXQ7cis9OH1pZigodD14Pj40KSE9MCl7eD10O3IrPTR9aWYoKHQ9eD4+MikhPTApe3g9dDtyKz0yfWlmKCh0PXg+PjEpIT0wKXt4PXQ7cis9MX1yZXR1cm4gcn1mdW5jdGlvbiBibkJpdExlbmd0aCgpe2lmKHRoaXMudDw9MClyZXR1cm4gMDtyZXR1cm4gdGhpcy5EQioodGhpcy50LTEpK25iaXRzKHRoaXNbdGhpcy50LTFdXnRoaXMucyZ0aGlzLkRNKX1mdW5jdGlvbiBibnBETFNoaWZ0VG8obixyKXt2YXIgaTtmb3IoaT10aGlzLnQtMTtpPj0wOy0taSlyW2krbl09dGhpc1tpXTtmb3IoaT1uLTE7aT49MDstLWkpcltpXT0wO3IudD10aGlzLnQrbjtyLnM9dGhpcy5zfWZ1bmN0aW9uIGJucERSU2hpZnRUbyhuLHIpe2Zvcih2YXIgaT1uO2k8dGhpcy50OysraSlyW2ktbl09dGhpc1tpXTtyLnQ9TWF0aC5tYXgodGhpcy50LW4sMCk7ci5zPXRoaXMuc31mdW5jdGlvbiBibnBMU2hpZnRUbyhuLHIpe3ZhciBzZWxmPXRoaXM7dmFyIGJzPW4lc2VsZi5EQjt2YXIgY2JzPXNlbGYuREItYnM7dmFyIGJtPSgxPDxjYnMpLTE7dmFyIGRzPU1hdGguZmxvb3Iobi9zZWxmLkRCKSxjPXNlbGYuczw8YnMmc2VsZi5ETSxpO2ZvcihpPXNlbGYudC0xO2k+PTA7LS1pKXtyW2krZHMrMV09c2VsZltpXT4+Y2JzfGM7Yz0oc2VsZltpXSZibSk8PGJzfWZvcihpPWRzLTE7aT49MDstLWkpcltpXT0wO3JbZHNdPWM7ci50PXNlbGYudCtkcysxO3Iucz1zZWxmLnM7ci5jbGFtcCgpfWZ1bmN0aW9uIGJucFJTaGlmdFRvKG4scil7dmFyIHNlbGY9dGhpcztyLnM9c2VsZi5zO3ZhciBkcz1NYXRoLmZsb29yKG4vc2VsZi5EQik7aWYoZHM+PXNlbGYudCl7ci50PTA7cmV0dXJufXZhciBicz1uJXNlbGYuREI7dmFyIGNicz1zZWxmLkRCLWJzO3ZhciBibT0oMTw8YnMpLTE7clswXT1zZWxmW2RzXT4+YnM7Zm9yKHZhciBpPWRzKzE7aTxzZWxmLnQ7KytpKXtyW2ktZHMtMV18PShzZWxmW2ldJmJtKTw8Y2JzO3JbaS1kc109c2VsZltpXT4+YnN9aWYoYnM+MClyW3NlbGYudC1kcy0xXXw9KHNlbGYucyZibSk8PGNicztyLnQ9c2VsZi50LWRzO3IuY2xhbXAoKX1mdW5jdGlvbiBibnBTdWJUbyhhLHIpe3ZhciBzZWxmPXRoaXM7dmFyIGk9MCxjPTAsbT1NYXRoLm1pbihhLnQsc2VsZi50KTt3aGlsZShpPG0pe2MrPXNlbGZbaV0tYVtpXTtyW2krK109YyZzZWxmLkRNO2M+Pj1zZWxmLkRCfWlmKGEudDxzZWxmLnQpe2MtPWEuczt3aGlsZShpPHNlbGYudCl7Yys9c2VsZltpXTtyW2krK109YyZzZWxmLkRNO2M+Pj1zZWxmLkRCfWMrPXNlbGYuc31lbHNle2MrPXNlbGYuczt3aGlsZShpPGEudCl7Yy09YVtpXTtyW2krK109YyZzZWxmLkRNO2M+Pj1zZWxmLkRCfWMtPWEuc31yLnM9YzwwPy0xOjA7aWYoYzwtMSlyW2krK109c2VsZi5EVitjO2Vsc2UgaWYoYz4wKXJbaSsrXT1jO3IudD1pO3IuY2xhbXAoKX1mdW5jdGlvbiBibnBNdWx0aXBseVRvKGEscil7dmFyIHg9dGhpcy5hYnMoKSx5PWEuYWJzKCk7dmFyIGk9eC50O3IudD1pK3kudDt3aGlsZSgtLWk+PTApcltpXT0wO2ZvcihpPTA7aTx5LnQ7KytpKXJbaSt4LnRdPXguYW0oMCx5W2ldLHIsaSwwLHgudCk7ci5zPTA7ci5jbGFtcCgpO2lmKHRoaXMucyE9YS5zKUJpZ0ludGVnZXIuWkVSTy5zdWJUbyhyLHIpfWZ1bmN0aW9uIGJucFNxdWFyZVRvKHIpe3ZhciB4PXRoaXMuYWJzKCk7dmFyIGk9ci50PTIqeC50O3doaWxlKC0taT49MClyW2ldPTA7Zm9yKGk9MDtpPHgudC0xOysraSl7dmFyIGM9eC5hbShpLHhbaV0sciwyKmksMCwxKTtpZigocltpK3gudF0rPXguYW0oaSsxLDIqeFtpXSxyLDIqaSsxLGMseC50LWktMSkpPj14LkRWKXtyW2kreC50XS09eC5EVjtyW2kreC50KzFdPTF9fWlmKHIudD4wKXJbci50LTFdKz14LmFtKGkseFtpXSxyLDIqaSwwLDEpO3Iucz0wO3IuY2xhbXAoKX1mdW5jdGlvbiBibnBEaXZSZW1UbyhtLHEscil7dmFyIHNlbGY9dGhpczt2YXIgcG09bS5hYnMoKTtpZihwbS50PD0wKXJldHVybjt2YXIgcHQ9c2VsZi5hYnMoKTtpZihwdC50PHBtLnQpe2lmKHEhPW51bGwpcS5mcm9tSW50KDApO2lmKHIhPW51bGwpc2VsZi5jb3B5VG8ocik7cmV0dXJufWlmKHI9PW51bGwpcj1uYmkoKTt2YXIgeT1uYmkoKSx0cz1zZWxmLnMsbXM9bS5zO3ZhciBuc2g9c2VsZi5EQi1uYml0cyhwbVtwbS50LTFdKTtpZihuc2g+MCl7cG0ubFNoaWZ0VG8obnNoLHkpO3B0LmxTaGlmdFRvKG5zaCxyKX1lbHNle3BtLmNvcHlUbyh5KTtwdC5jb3B5VG8ocil9dmFyIHlzPXkudDt2YXIgeTA9eVt5cy0xXTtpZih5MD09MClyZXR1cm47dmFyIHl0PXkwKigxPDxzZWxmLkYxKSsoeXM+MT95W3lzLTJdPj5zZWxmLkYyOjApO3ZhciBkMT1zZWxmLkZWL3l0LGQyPSgxPDxzZWxmLkYxKS95dCxlPTE8PHNlbGYuRjI7dmFyIGk9ci50LGo9aS15cyx0PXE9PW51bGw/bmJpKCk6cTt5LmRsU2hpZnRUbyhqLHQpO2lmKHIuY29tcGFyZVRvKHQpPj0wKXtyW3IudCsrXT0xO3Iuc3ViVG8odCxyKX1CaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oeXMsdCk7dC5zdWJUbyh5LHkpO3doaWxlKHkudDx5cyl5W3kudCsrXT0wO3doaWxlKC0taj49MCl7dmFyIHFkPXJbLS1pXT09eTA/c2VsZi5ETTpNYXRoLmZsb29yKHJbaV0qZDErKHJbaS0xXStlKSpkMik7aWYoKHJbaV0rPXkuYW0oMCxxZCxyLGosMCx5cykpPHFkKXt5LmRsU2hpZnRUbyhqLHQpO3Iuc3ViVG8odCxyKTt3aGlsZShyW2ldPC0tcWQpci5zdWJUbyh0LHIpfX1pZihxIT1udWxsKXtyLmRyU2hpZnRUbyh5cyxxKTtpZih0cyE9bXMpQmlnSW50ZWdlci5aRVJPLnN1YlRvKHEscSl9ci50PXlzO3IuY2xhbXAoKTtpZihuc2g+MClyLnJTaGlmdFRvKG5zaCxyKTtpZih0czwwKUJpZ0ludGVnZXIuWkVSTy5zdWJUbyhyLHIpfWZ1bmN0aW9uIGJuTW9kKGEpe3ZhciByPW5iaSgpO3RoaXMuYWJzKCkuZGl2UmVtVG8oYSxudWxsLHIpO2lmKHRoaXMuczwwJiZyLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pPjApYS5zdWJUbyhyLHIpO3JldHVybiByfWZ1bmN0aW9uIENsYXNzaWMobSl7dGhpcy5tPW19ZnVuY3Rpb24gY0NvbnZlcnQoeCl7aWYoeC5zPDB8fHguY29tcGFyZVRvKHRoaXMubSk+PTApcmV0dXJuIHgubW9kKHRoaXMubSk7ZWxzZSByZXR1cm4geH1mdW5jdGlvbiBjUmV2ZXJ0KHgpe3JldHVybiB4fWZ1bmN0aW9uIGNSZWR1Y2UoeCl7eC5kaXZSZW1Ubyh0aGlzLm0sbnVsbCx4KX1mdW5jdGlvbiBjTXVsVG8oeCx5LHIpe3gubXVsdGlwbHlUbyh5LHIpO3RoaXMucmVkdWNlKHIpfWZ1bmN0aW9uIGNTcXJUbyh4LHIpe3guc3F1YXJlVG8ocik7dGhpcy5yZWR1Y2Uocil9Q2xhc3NpYy5wcm90b3R5cGUuY29udmVydD1jQ29udmVydDtDbGFzc2ljLnByb3RvdHlwZS5yZXZlcnQ9Y1JldmVydDtDbGFzc2ljLnByb3RvdHlwZS5yZWR1Y2U9Y1JlZHVjZTtDbGFzc2ljLnByb3RvdHlwZS5tdWxUbz1jTXVsVG87Q2xhc3NpYy5wcm90b3R5cGUuc3FyVG89Y1NxclRvO2Z1bmN0aW9uIGJucEludkRpZ2l0KCl7aWYodGhpcy50PDEpcmV0dXJuIDA7dmFyIHg9dGhpc1swXTtpZigoeCYxKT09MClyZXR1cm4gMDt2YXIgeT14JjM7eT15KigyLSh4JjE1KSp5KSYxNTt5PXkqKDItKHgmMjU1KSp5KSYyNTU7eT15KigyLSgoeCY2NTUzNSkqeSY2NTUzNSkpJjY1NTM1O3k9eSooMi14KnkldGhpcy5EVikldGhpcy5EVjtyZXR1cm4geT4wP3RoaXMuRFYteToteX1mdW5jdGlvbiBNb250Z29tZXJ5KG0pe3RoaXMubT1tO3RoaXMubXA9bS5pbnZEaWdpdCgpO3RoaXMubXBsPXRoaXMubXAmMzI3Njc7dGhpcy5tcGg9dGhpcy5tcD4+MTU7dGhpcy51bT0oMTw8bS5EQi0xNSktMTt0aGlzLm10Mj0yKm0udH1mdW5jdGlvbiBtb250Q29udmVydCh4KXt2YXIgcj1uYmkoKTt4LmFicygpLmRsU2hpZnRUbyh0aGlzLm0udCxyKTtyLmRpdlJlbVRvKHRoaXMubSxudWxsLHIpO2lmKHguczwwJiZyLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pPjApdGhpcy5tLnN1YlRvKHIscik7cmV0dXJuIHJ9ZnVuY3Rpb24gbW9udFJldmVydCh4KXt2YXIgcj1uYmkoKTt4LmNvcHlUbyhyKTt0aGlzLnJlZHVjZShyKTtyZXR1cm4gcn1mdW5jdGlvbiBtb250UmVkdWNlKHgpe3doaWxlKHgudDw9dGhpcy5tdDIpeFt4LnQrK109MDtmb3IodmFyIGk9MDtpPHRoaXMubS50OysraSl7dmFyIGo9eFtpXSYzMjc2Nzt2YXIgdTA9aip0aGlzLm1wbCsoKGoqdGhpcy5tcGgrKHhbaV0+PjE1KSp0aGlzLm1wbCZ0aGlzLnVtKTw8MTUpJnguRE07aj1pK3RoaXMubS50O3hbal0rPXRoaXMubS5hbSgwLHUwLHgsaSwwLHRoaXMubS50KTt3aGlsZSh4W2pdPj14LkRWKXt4W2pdLT14LkRWO3hbKytqXSsrfX14LmNsYW1wKCk7eC5kclNoaWZ0VG8odGhpcy5tLnQseCk7aWYoeC5jb21wYXJlVG8odGhpcy5tKT49MCl4LnN1YlRvKHRoaXMubSx4KX1mdW5jdGlvbiBtb250U3FyVG8oeCxyKXt4LnNxdWFyZVRvKHIpO3RoaXMucmVkdWNlKHIpfWZ1bmN0aW9uIG1vbnRNdWxUbyh4LHkscil7eC5tdWx0aXBseVRvKHkscik7dGhpcy5yZWR1Y2Uocil9TW9udGdvbWVyeS5wcm90b3R5cGUuY29udmVydD1tb250Q29udmVydDtNb250Z29tZXJ5LnByb3RvdHlwZS5yZXZlcnQ9bW9udFJldmVydDtNb250Z29tZXJ5LnByb3RvdHlwZS5yZWR1Y2U9bW9udFJlZHVjZTtNb250Z29tZXJ5LnByb3RvdHlwZS5tdWxUbz1tb250TXVsVG87TW9udGdvbWVyeS5wcm90b3R5cGUuc3FyVG89bW9udFNxclRvO2Z1bmN0aW9uIGJucElzRXZlbigpe3JldHVybih0aGlzLnQ+MD90aGlzWzBdJjE6dGhpcy5zKT09MH1mdW5jdGlvbiBibnBFeHAoZSx6KXtpZihlPjQyOTQ5NjcyOTV8fGU8MSlyZXR1cm4gQmlnSW50ZWdlci5PTkU7dmFyIHI9bmJpKCkscjI9bmJpKCksZz16LmNvbnZlcnQodGhpcyksaT1uYml0cyhlKS0xO2cuY29weVRvKHIpO3doaWxlKC0taT49MCl7ei5zcXJUbyhyLHIyKTtpZigoZSYxPDxpKT4wKXoubXVsVG8ocjIsZyxyKTtlbHNle3ZhciB0PXI7cj1yMjtyMj10fX1yZXR1cm4gei5yZXZlcnQocil9ZnVuY3Rpb24gYm5Nb2RQb3dJbnQoZSxtKXt2YXIgejtpZihlPDI1Nnx8bS5pc0V2ZW4oKSl6PW5ldyBDbGFzc2ljKG0pO2Vsc2Ugej1uZXcgTW9udGdvbWVyeShtKTtyZXR1cm4gdGhpcy5leHAoZSx6KX1wcm90by5jb3B5VG89Ym5wQ29weVRvO3Byb3RvLmZyb21JbnQ9Ym5wRnJvbUludDtwcm90by5mcm9tU3RyaW5nPWJucEZyb21TdHJpbmc7cHJvdG8uY2xhbXA9Ym5wQ2xhbXA7cHJvdG8uZGxTaGlmdFRvPWJucERMU2hpZnRUbztwcm90by5kclNoaWZ0VG89Ym5wRFJTaGlmdFRvO3Byb3RvLmxTaGlmdFRvPWJucExTaGlmdFRvO3Byb3RvLnJTaGlmdFRvPWJucFJTaGlmdFRvO3Byb3RvLnN1YlRvPWJucFN1YlRvO3Byb3RvLm11bHRpcGx5VG89Ym5wTXVsdGlwbHlUbztwcm90by5zcXVhcmVUbz1ibnBTcXVhcmVUbztwcm90by5kaXZSZW1Ubz1ibnBEaXZSZW1Ubztwcm90by5pbnZEaWdpdD1ibnBJbnZEaWdpdDtwcm90by5pc0V2ZW49Ym5wSXNFdmVuO3Byb3RvLmV4cD1ibnBFeHA7cHJvdG8udG9TdHJpbmc9Ym5Ub1N0cmluZztwcm90by5uZWdhdGU9Ym5OZWdhdGU7cHJvdG8uYWJzPWJuQWJzO3Byb3RvLmNvbXBhcmVUbz1ibkNvbXBhcmVUbztwcm90by5iaXRMZW5ndGg9Ym5CaXRMZW5ndGg7cHJvdG8ubW9kPWJuTW9kO3Byb3RvLm1vZFBvd0ludD1ibk1vZFBvd0ludDtmdW5jdGlvbiBuYmkoKXtyZXR1cm4gbmV3IEJpZ0ludGVnZXIobnVsbCl9ZnVuY3Rpb24gYm5DbG9uZSgpe3ZhciByPW5iaSgpO3RoaXMuY29weVRvKHIpO3JldHVybiByfWZ1bmN0aW9uIGJuSW50VmFsdWUoKXtpZih0aGlzLnM8MCl7aWYodGhpcy50PT0xKXJldHVybiB0aGlzWzBdLXRoaXMuRFY7ZWxzZSBpZih0aGlzLnQ9PTApcmV0dXJuLTF9ZWxzZSBpZih0aGlzLnQ9PTEpcmV0dXJuIHRoaXNbMF07ZWxzZSBpZih0aGlzLnQ9PTApcmV0dXJuIDA7cmV0dXJuKHRoaXNbMV0mKDE8PDMyLXRoaXMuREIpLTEpPDx0aGlzLkRCfHRoaXNbMF19ZnVuY3Rpb24gYm5CeXRlVmFsdWUoKXtyZXR1cm4gdGhpcy50PT0wP3RoaXMuczp0aGlzWzBdPDwyND4+MjR9ZnVuY3Rpb24gYm5TaG9ydFZhbHVlKCl7cmV0dXJuIHRoaXMudD09MD90aGlzLnM6dGhpc1swXTw8MTY+PjE2fWZ1bmN0aW9uIGJucENodW5rU2l6ZShyKXtyZXR1cm4gTWF0aC5mbG9vcihNYXRoLkxOMip0aGlzLkRCL01hdGgubG9nKHIpKX1mdW5jdGlvbiBiblNpZ051bSgpe2lmKHRoaXMuczwwKXJldHVybi0xO2Vsc2UgaWYodGhpcy50PD0wfHx0aGlzLnQ9PTEmJnRoaXNbMF08PTApcmV0dXJuIDA7ZWxzZSByZXR1cm4gMX1mdW5jdGlvbiBibnBUb1JhZGl4KGIpe2lmKGI9PW51bGwpYj0xMDtpZih0aGlzLnNpZ251bSgpPT0wfHxiPDJ8fGI+MzYpcmV0dXJuXCIwXCI7dmFyIGNzPXRoaXMuY2h1bmtTaXplKGIpO3ZhciBhPU1hdGgucG93KGIsY3MpO3ZhciBkPW5idihhKSx5PW5iaSgpLHo9bmJpKCkscj1cIlwiO3RoaXMuZGl2UmVtVG8oZCx5LHopO3doaWxlKHkuc2lnbnVtKCk+MCl7cj0oYSt6LmludFZhbHVlKCkpLnRvU3RyaW5nKGIpLnN1YnN0cigxKStyO3kuZGl2UmVtVG8oZCx5LHopfXJldHVybiB6LmludFZhbHVlKCkudG9TdHJpbmcoYikrcn1mdW5jdGlvbiBibnBGcm9tUmFkaXgocyxiKXt2YXIgc2VsZj10aGlzO3NlbGYuZnJvbUludCgwKTtpZihiPT1udWxsKWI9MTA7dmFyIGNzPXNlbGYuY2h1bmtTaXplKGIpO3ZhciBkPU1hdGgucG93KGIsY3MpLG1pPWZhbHNlLGo9MCx3PTA7Zm9yKHZhciBpPTA7aTxzLmxlbmd0aDsrK2kpe3ZhciB4PWludEF0KHMsaSk7aWYoeDwwKXtpZihzLmNoYXJBdChpKT09XCItXCImJnNlbGYuc2lnbnVtKCk9PTApbWk9dHJ1ZTtjb250aW51ZX13PWIqdyt4O2lmKCsraj49Y3Mpe3NlbGYuZE11bHRpcGx5KGQpO3NlbGYuZEFkZE9mZnNldCh3LDApO2o9MDt3PTB9fWlmKGo+MCl7c2VsZi5kTXVsdGlwbHkoTWF0aC5wb3coYixqKSk7c2VsZi5kQWRkT2Zmc2V0KHcsMCl9aWYobWkpQmlnSW50ZWdlci5aRVJPLnN1YlRvKHNlbGYsc2VsZil9ZnVuY3Rpb24gYm5wRnJvbU51bWJlcihhLGIsYyl7dmFyIHNlbGY9dGhpcztpZihcIm51bWJlclwiPT10eXBlb2YgYil7aWYoYTwyKXNlbGYuZnJvbUludCgxKTtlbHNle3NlbGYuZnJvbU51bWJlcihhLGMpO2lmKCFzZWxmLnRlc3RCaXQoYS0xKSlzZWxmLmJpdHdpc2VUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYS0xKSxvcF9vcixzZWxmKTtpZihzZWxmLmlzRXZlbigpKXNlbGYuZEFkZE9mZnNldCgxLDApO3doaWxlKCFzZWxmLmlzUHJvYmFibGVQcmltZShiKSl7c2VsZi5kQWRkT2Zmc2V0KDIsMCk7aWYoc2VsZi5iaXRMZW5ndGgoKT5hKXNlbGYuc3ViVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEtMSksc2VsZil9fX1lbHNle3ZhciB0PWEmNzt2YXIgbGVuZ3RoPShhPj4zKSsxO3ZhciB4PWIobGVuZ3RoLHthcnJheTp0cnVlfSk7aWYodD4wKXhbMF0mPSgxPDx0KS0xO2Vsc2UgeFswXT0wO3NlbGYuZnJvbVN0cmluZyh4LDI1Nil9fWZ1bmN0aW9uIGJuVG9CeXRlQXJyYXkoKXt2YXIgc2VsZj10aGlzO3ZhciBpPXNlbGYudCxyPW5ldyBBcnJheTtyWzBdPXNlbGYuczt2YXIgcD1zZWxmLkRCLWkqc2VsZi5EQiU4LGQsaz0wO2lmKGktLT4wKXtpZihwPHNlbGYuREImJihkPXNlbGZbaV0+PnApIT0oc2VsZi5zJnNlbGYuRE0pPj5wKXJbaysrXT1kfHNlbGYuczw8c2VsZi5EQi1wO3doaWxlKGk+PTApe2lmKHA8OCl7ZD0oc2VsZltpXSYoMTw8cCktMSk8PDgtcDtkfD1zZWxmWy0taV0+PihwKz1zZWxmLkRCLTgpfWVsc2V7ZD1zZWxmW2ldPj4ocC09OCkmMjU1O2lmKHA8PTApe3ArPXNlbGYuREI7LS1pfX1pZigoZCYxMjgpIT0wKWR8PS0yNTY7aWYoaz09PTAmJihzZWxmLnMmMTI4KSE9KGQmMTI4KSkrK2s7aWYoaz4wfHxkIT1zZWxmLnMpcltrKytdPWR9fXJldHVybiByfWZ1bmN0aW9uIGJuRXF1YWxzKGEpe3JldHVybiB0aGlzLmNvbXBhcmVUbyhhKT09MH1mdW5jdGlvbiBibk1pbihhKXtyZXR1cm4gdGhpcy5jb21wYXJlVG8oYSk8MD90aGlzOmF9ZnVuY3Rpb24gYm5NYXgoYSl7cmV0dXJuIHRoaXMuY29tcGFyZVRvKGEpPjA/dGhpczphfWZ1bmN0aW9uIGJucEJpdHdpc2VUbyhhLG9wLHIpe3ZhciBzZWxmPXRoaXM7dmFyIGksZixtPU1hdGgubWluKGEudCxzZWxmLnQpO2ZvcihpPTA7aTxtOysraSlyW2ldPW9wKHNlbGZbaV0sYVtpXSk7aWYoYS50PHNlbGYudCl7Zj1hLnMmc2VsZi5ETTtmb3IoaT1tO2k8c2VsZi50OysraSlyW2ldPW9wKHNlbGZbaV0sZik7ci50PXNlbGYudH1lbHNle2Y9c2VsZi5zJnNlbGYuRE07Zm9yKGk9bTtpPGEudDsrK2kpcltpXT1vcChmLGFbaV0pO3IudD1hLnR9ci5zPW9wKHNlbGYucyxhLnMpO3IuY2xhbXAoKX1mdW5jdGlvbiBvcF9hbmQoeCx5KXtyZXR1cm4geCZ5fWZ1bmN0aW9uIGJuQW5kKGEpe3ZhciByPW5iaSgpO3RoaXMuYml0d2lzZVRvKGEsb3BfYW5kLHIpO3JldHVybiByfWZ1bmN0aW9uIG9wX29yKHgseSl7cmV0dXJuIHh8eX1mdW5jdGlvbiBibk9yKGEpe3ZhciByPW5iaSgpO3RoaXMuYml0d2lzZVRvKGEsb3Bfb3Iscik7cmV0dXJuIHJ9ZnVuY3Rpb24gb3BfeG9yKHgseSl7cmV0dXJuIHheeX1mdW5jdGlvbiBiblhvcihhKXt2YXIgcj1uYmkoKTt0aGlzLmJpdHdpc2VUbyhhLG9wX3hvcixyKTtyZXR1cm4gcn1mdW5jdGlvbiBvcF9hbmRub3QoeCx5KXtyZXR1cm4geCZ+eX1mdW5jdGlvbiBibkFuZE5vdChhKXt2YXIgcj1uYmkoKTt0aGlzLmJpdHdpc2VUbyhhLG9wX2FuZG5vdCxyKTtyZXR1cm4gcn1mdW5jdGlvbiBibk5vdCgpe3ZhciByPW5iaSgpO2Zvcih2YXIgaT0wO2k8dGhpcy50OysraSlyW2ldPXRoaXMuRE0mfnRoaXNbaV07ci50PXRoaXMudDtyLnM9fnRoaXMucztyZXR1cm4gcn1mdW5jdGlvbiBiblNoaWZ0TGVmdChuKXt2YXIgcj1uYmkoKTtpZihuPDApdGhpcy5yU2hpZnRUbygtbixyKTtlbHNlIHRoaXMubFNoaWZ0VG8obixyKTtyZXR1cm4gcn1mdW5jdGlvbiBiblNoaWZ0UmlnaHQobil7dmFyIHI9bmJpKCk7aWYobjwwKXRoaXMubFNoaWZ0VG8oLW4scik7ZWxzZSB0aGlzLnJTaGlmdFRvKG4scik7cmV0dXJuIHJ9ZnVuY3Rpb24gbGJpdCh4KXtpZih4PT0wKXJldHVybi0xO3ZhciByPTA7aWYoKHgmNjU1MzUpPT0wKXt4Pj49MTY7cis9MTZ9aWYoKHgmMjU1KT09MCl7eD4+PTg7cis9OH1pZigoeCYxNSk9PTApe3g+Pj00O3IrPTR9aWYoKHgmMyk9PTApe3g+Pj0yO3IrPTJ9aWYoKHgmMSk9PTApKytyO3JldHVybiByfWZ1bmN0aW9uIGJuR2V0TG93ZXN0U2V0Qml0KCl7Zm9yKHZhciBpPTA7aTx0aGlzLnQ7KytpKWlmKHRoaXNbaV0hPTApcmV0dXJuIGkqdGhpcy5EQitsYml0KHRoaXNbaV0pO2lmKHRoaXMuczwwKXJldHVybiB0aGlzLnQqdGhpcy5EQjtyZXR1cm4tMX1mdW5jdGlvbiBjYml0KHgpe3ZhciByPTA7d2hpbGUoeCE9MCl7eCY9eC0xOysrcn1yZXR1cm4gcn1mdW5jdGlvbiBibkJpdENvdW50KCl7dmFyIHI9MCx4PXRoaXMucyZ0aGlzLkRNO2Zvcih2YXIgaT0wO2k8dGhpcy50OysraSlyKz1jYml0KHRoaXNbaV1eeCk7cmV0dXJuIHJ9ZnVuY3Rpb24gYm5UZXN0Qml0KG4pe3ZhciBqPU1hdGguZmxvb3Iobi90aGlzLkRCKTtpZihqPj10aGlzLnQpcmV0dXJuIHRoaXMucyE9MDtyZXR1cm4odGhpc1tqXSYxPDxuJXRoaXMuREIpIT0wfWZ1bmN0aW9uIGJucENoYW5nZUJpdChuLG9wKXt2YXIgcj1CaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQobik7dGhpcy5iaXR3aXNlVG8ocixvcCxyKTtyZXR1cm4gcn1mdW5jdGlvbiBiblNldEJpdChuKXtyZXR1cm4gdGhpcy5jaGFuZ2VCaXQobixvcF9vcil9ZnVuY3Rpb24gYm5DbGVhckJpdChuKXtyZXR1cm4gdGhpcy5jaGFuZ2VCaXQobixvcF9hbmRub3QpfWZ1bmN0aW9uIGJuRmxpcEJpdChuKXtyZXR1cm4gdGhpcy5jaGFuZ2VCaXQobixvcF94b3IpfWZ1bmN0aW9uIGJucEFkZFRvKGEscil7dmFyIHNlbGY9dGhpczt2YXIgaT0wLGM9MCxtPU1hdGgubWluKGEudCxzZWxmLnQpO3doaWxlKGk8bSl7Yys9c2VsZltpXSthW2ldO3JbaSsrXT1jJnNlbGYuRE07Yz4+PXNlbGYuREJ9aWYoYS50PHNlbGYudCl7Yys9YS5zO3doaWxlKGk8c2VsZi50KXtjKz1zZWxmW2ldO3JbaSsrXT1jJnNlbGYuRE07Yz4+PXNlbGYuREJ9Yys9c2VsZi5zfWVsc2V7Yys9c2VsZi5zO3doaWxlKGk8YS50KXtjKz1hW2ldO3JbaSsrXT1jJnNlbGYuRE07Yz4+PXNlbGYuREJ9Yys9YS5zfXIucz1jPDA/LTE6MDtpZihjPjApcltpKytdPWM7ZWxzZSBpZihjPC0xKXJbaSsrXT1zZWxmLkRWK2M7ci50PWk7ci5jbGFtcCgpfWZ1bmN0aW9uIGJuQWRkKGEpe3ZhciByPW5iaSgpO3RoaXMuYWRkVG8oYSxyKTtyZXR1cm4gcn1mdW5jdGlvbiBiblN1YnRyYWN0KGEpe3ZhciByPW5iaSgpO3RoaXMuc3ViVG8oYSxyKTtyZXR1cm4gcn1mdW5jdGlvbiBibk11bHRpcGx5KGEpe3ZhciByPW5iaSgpO3RoaXMubXVsdGlwbHlUbyhhLHIpO3JldHVybiByfWZ1bmN0aW9uIGJuU3F1YXJlKCl7dmFyIHI9bmJpKCk7dGhpcy5zcXVhcmVUbyhyKTtyZXR1cm4gcn1mdW5jdGlvbiBibkRpdmlkZShhKXt2YXIgcj1uYmkoKTt0aGlzLmRpdlJlbVRvKGEscixudWxsKTtyZXR1cm4gcn1mdW5jdGlvbiBiblJlbWFpbmRlcihhKXt2YXIgcj1uYmkoKTt0aGlzLmRpdlJlbVRvKGEsbnVsbCxyKTtyZXR1cm4gcn1mdW5jdGlvbiBibkRpdmlkZUFuZFJlbWFpbmRlcihhKXt2YXIgcT1uYmkoKSxyPW5iaSgpO3RoaXMuZGl2UmVtVG8oYSxxLHIpO3JldHVybiBuZXcgQXJyYXkocSxyKX1mdW5jdGlvbiBibnBETXVsdGlwbHkobil7dGhpc1t0aGlzLnRdPXRoaXMuYW0oMCxuLTEsdGhpcywwLDAsdGhpcy50KTsrK3RoaXMudDt0aGlzLmNsYW1wKCl9ZnVuY3Rpb24gYm5wREFkZE9mZnNldChuLHcpe2lmKG49PTApcmV0dXJuO3doaWxlKHRoaXMudDw9dyl0aGlzW3RoaXMudCsrXT0wO3RoaXNbd10rPW47d2hpbGUodGhpc1t3XT49dGhpcy5EVil7dGhpc1t3XS09dGhpcy5EVjtpZigrK3c+PXRoaXMudCl0aGlzW3RoaXMudCsrXT0wOysrdGhpc1t3XX19ZnVuY3Rpb24gTnVsbEV4cCgpe31mdW5jdGlvbiBuTm9wKHgpe3JldHVybiB4fWZ1bmN0aW9uIG5NdWxUbyh4LHkscil7eC5tdWx0aXBseVRvKHkscil9ZnVuY3Rpb24gblNxclRvKHgscil7eC5zcXVhcmVUbyhyKX1OdWxsRXhwLnByb3RvdHlwZS5jb252ZXJ0PW5Ob3A7TnVsbEV4cC5wcm90b3R5cGUucmV2ZXJ0PW5Ob3A7TnVsbEV4cC5wcm90b3R5cGUubXVsVG89bk11bFRvO051bGxFeHAucHJvdG90eXBlLnNxclRvPW5TcXJUbztmdW5jdGlvbiBiblBvdyhlKXtyZXR1cm4gdGhpcy5leHAoZSxuZXcgTnVsbEV4cCl9ZnVuY3Rpb24gYm5wTXVsdGlwbHlMb3dlclRvKGEsbixyKXt2YXIgaT1NYXRoLm1pbih0aGlzLnQrYS50LG4pO3Iucz0wO3IudD1pO3doaWxlKGk+MClyWy0taV09MDt2YXIgajtmb3Ioaj1yLnQtdGhpcy50O2k8ajsrK2kpcltpK3RoaXMudF09dGhpcy5hbSgwLGFbaV0scixpLDAsdGhpcy50KTtmb3Ioaj1NYXRoLm1pbihhLnQsbik7aTxqOysraSl0aGlzLmFtKDAsYVtpXSxyLGksMCxuLWkpO3IuY2xhbXAoKX1mdW5jdGlvbiBibnBNdWx0aXBseVVwcGVyVG8oYSxuLHIpey0tbjt2YXIgaT1yLnQ9dGhpcy50K2EudC1uO3Iucz0wO3doaWxlKC0taT49MClyW2ldPTA7Zm9yKGk9TWF0aC5tYXgobi10aGlzLnQsMCk7aTxhLnQ7KytpKXJbdGhpcy50K2ktbl09dGhpcy5hbShuLWksYVtpXSxyLDAsMCx0aGlzLnQraS1uKTtyLmNsYW1wKCk7ci5kclNoaWZ0VG8oMSxyKX1mdW5jdGlvbiBCYXJyZXR0KG0pe3RoaXMucjI9bmJpKCk7dGhpcy5xMz1uYmkoKTtCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oMiptLnQsdGhpcy5yMik7dGhpcy5tdT10aGlzLnIyLmRpdmlkZShtKTt0aGlzLm09bX1mdW5jdGlvbiBiYXJyZXR0Q29udmVydCh4KXtpZih4LnM8MHx8eC50PjIqdGhpcy5tLnQpcmV0dXJuIHgubW9kKHRoaXMubSk7ZWxzZSBpZih4LmNvbXBhcmVUbyh0aGlzLm0pPDApcmV0dXJuIHg7ZWxzZXt2YXIgcj1uYmkoKTt4LmNvcHlUbyhyKTt0aGlzLnJlZHVjZShyKTtyZXR1cm4gcn19ZnVuY3Rpb24gYmFycmV0dFJldmVydCh4KXtyZXR1cm4geH1mdW5jdGlvbiBiYXJyZXR0UmVkdWNlKHgpe3ZhciBzZWxmPXRoaXM7eC5kclNoaWZ0VG8oc2VsZi5tLnQtMSxzZWxmLnIyKTtpZih4LnQ+c2VsZi5tLnQrMSl7eC50PXNlbGYubS50KzE7eC5jbGFtcCgpfXNlbGYubXUubXVsdGlwbHlVcHBlclRvKHNlbGYucjIsc2VsZi5tLnQrMSxzZWxmLnEzKTtzZWxmLm0ubXVsdGlwbHlMb3dlclRvKHNlbGYucTMsc2VsZi5tLnQrMSxzZWxmLnIyKTt3aGlsZSh4LmNvbXBhcmVUbyhzZWxmLnIyKTwwKXguZEFkZE9mZnNldCgxLHNlbGYubS50KzEpO3guc3ViVG8oc2VsZi5yMix4KTt3aGlsZSh4LmNvbXBhcmVUbyhzZWxmLm0pPj0wKXguc3ViVG8oc2VsZi5tLHgpfWZ1bmN0aW9uIGJhcnJldHRTcXJUbyh4LHIpe3guc3F1YXJlVG8ocik7dGhpcy5yZWR1Y2Uocil9ZnVuY3Rpb24gYmFycmV0dE11bFRvKHgseSxyKXt4Lm11bHRpcGx5VG8oeSxyKTt0aGlzLnJlZHVjZShyKX1CYXJyZXR0LnByb3RvdHlwZS5jb252ZXJ0PWJhcnJldHRDb252ZXJ0O0JhcnJldHQucHJvdG90eXBlLnJldmVydD1iYXJyZXR0UmV2ZXJ0O0JhcnJldHQucHJvdG90eXBlLnJlZHVjZT1iYXJyZXR0UmVkdWNlO0JhcnJldHQucHJvdG90eXBlLm11bFRvPWJhcnJldHRNdWxUbztCYXJyZXR0LnByb3RvdHlwZS5zcXJUbz1iYXJyZXR0U3FyVG87ZnVuY3Rpb24gYm5Nb2RQb3coZSxtKXt2YXIgaT1lLmJpdExlbmd0aCgpLGsscj1uYnYoMSksejtpZihpPD0wKXJldHVybiByO2Vsc2UgaWYoaTwxOClrPTE7ZWxzZSBpZihpPDQ4KWs9MztlbHNlIGlmKGk8MTQ0KWs9NDtlbHNlIGlmKGk8NzY4KWs9NTtlbHNlIGs9NjtpZihpPDgpej1uZXcgQ2xhc3NpYyhtKTtlbHNlIGlmKG0uaXNFdmVuKCkpej1uZXcgQmFycmV0dChtKTtlbHNlIHo9bmV3IE1vbnRnb21lcnkobSk7dmFyIGc9bmV3IEFycmF5LG49MyxrMT1rLTEsa209KDE8PGspLTE7Z1sxXT16LmNvbnZlcnQodGhpcyk7aWYoaz4xKXt2YXIgZzI9bmJpKCk7ei5zcXJUbyhnWzFdLGcyKTt3aGlsZShuPD1rbSl7Z1tuXT1uYmkoKTt6Lm11bFRvKGcyLGdbbi0yXSxnW25dKTtuKz0yfX12YXIgaj1lLnQtMSx3LGlzMT10cnVlLHIyPW5iaSgpLHQ7aT1uYml0cyhlW2pdKS0xO3doaWxlKGo+PTApe2lmKGk+PWsxKXc9ZVtqXT4+aS1rMSZrbTtlbHNle3c9KGVbal0mKDE8PGkrMSktMSk8PGsxLWk7aWYoaj4wKXd8PWVbai0xXT4+dGhpcy5EQitpLWsxfW49azt3aGlsZSgodyYxKT09MCl7dz4+PTE7LS1ufWlmKChpLT1uKTwwKXtpKz10aGlzLkRCOy0tan1pZihpczEpe2dbd10uY29weVRvKHIpO2lzMT1mYWxzZX1lbHNle3doaWxlKG4+MSl7ei5zcXJUbyhyLHIyKTt6LnNxclRvKHIyLHIpO24tPTJ9aWYobj4wKXouc3FyVG8ocixyMik7ZWxzZXt0PXI7cj1yMjtyMj10fXoubXVsVG8ocjIsZ1t3XSxyKX13aGlsZShqPj0wJiYoZVtqXSYxPDxpKT09MCl7ei5zcXJUbyhyLHIyKTt0PXI7cj1yMjtyMj10O2lmKC0taTwwKXtpPXRoaXMuREItMTstLWp9fX1yZXR1cm4gei5yZXZlcnQocil9ZnVuY3Rpb24gYm5HQ0QoYSl7dmFyIHg9dGhpcy5zPDA/dGhpcy5uZWdhdGUoKTp0aGlzLmNsb25lKCk7dmFyIHk9YS5zPDA/YS5uZWdhdGUoKTphLmNsb25lKCk7aWYoeC5jb21wYXJlVG8oeSk8MCl7dmFyIHQ9eDt4PXk7eT10fXZhciBpPXguZ2V0TG93ZXN0U2V0Qml0KCksZz15LmdldExvd2VzdFNldEJpdCgpO2lmKGc8MClyZXR1cm4geDtpZihpPGcpZz1pO2lmKGc+MCl7eC5yU2hpZnRUbyhnLHgpO3kuclNoaWZ0VG8oZyx5KX13aGlsZSh4LnNpZ251bSgpPjApe2lmKChpPXguZ2V0TG93ZXN0U2V0Qml0KCkpPjApeC5yU2hpZnRUbyhpLHgpO2lmKChpPXkuZ2V0TG93ZXN0U2V0Qml0KCkpPjApeS5yU2hpZnRUbyhpLHkpO2lmKHguY29tcGFyZVRvKHkpPj0wKXt4LnN1YlRvKHkseCk7eC5yU2hpZnRUbygxLHgpfWVsc2V7eS5zdWJUbyh4LHkpO3kuclNoaWZ0VG8oMSx5KX19aWYoZz4wKXkubFNoaWZ0VG8oZyx5KTtyZXR1cm4geX1mdW5jdGlvbiBibnBNb2RJbnQobil7aWYobjw9MClyZXR1cm4gMDt2YXIgZD10aGlzLkRWJW4scj10aGlzLnM8MD9uLTE6MDtpZih0aGlzLnQ+MClpZihkPT0wKXI9dGhpc1swXSVuO2Vsc2UgZm9yKHZhciBpPXRoaXMudC0xO2k+PTA7LS1pKXI9KGQqcit0aGlzW2ldKSVuO3JldHVybiByfWZ1bmN0aW9uIGJuTW9kSW52ZXJzZShtKXt2YXIgYWM9bS5pc0V2ZW4oKTtpZih0aGlzLmlzRXZlbigpJiZhY3x8bS5zaWdudW0oKT09MClyZXR1cm4gQmlnSW50ZWdlci5aRVJPO3ZhciB1PW0uY2xvbmUoKSx2PXRoaXMuY2xvbmUoKTt2YXIgYT1uYnYoMSksYj1uYnYoMCksYz1uYnYoMCksZD1uYnYoMSk7d2hpbGUodS5zaWdudW0oKSE9MCl7d2hpbGUodS5pc0V2ZW4oKSl7dS5yU2hpZnRUbygxLHUpO2lmKGFjKXtpZighYS5pc0V2ZW4oKXx8IWIuaXNFdmVuKCkpe2EuYWRkVG8odGhpcyxhKTtiLnN1YlRvKG0sYil9YS5yU2hpZnRUbygxLGEpfWVsc2UgaWYoIWIuaXNFdmVuKCkpYi5zdWJUbyhtLGIpO2IuclNoaWZ0VG8oMSxiKX13aGlsZSh2LmlzRXZlbigpKXt2LnJTaGlmdFRvKDEsdik7aWYoYWMpe2lmKCFjLmlzRXZlbigpfHwhZC5pc0V2ZW4oKSl7Yy5hZGRUbyh0aGlzLGMpO2Quc3ViVG8obSxkKX1jLnJTaGlmdFRvKDEsYyl9ZWxzZSBpZighZC5pc0V2ZW4oKSlkLnN1YlRvKG0sZCk7ZC5yU2hpZnRUbygxLGQpfWlmKHUuY29tcGFyZVRvKHYpPj0wKXt1LnN1YlRvKHYsdSk7aWYoYWMpYS5zdWJUbyhjLGEpO2Iuc3ViVG8oZCxiKX1lbHNle3Yuc3ViVG8odSx2KTtpZihhYyljLnN1YlRvKGEsYyk7ZC5zdWJUbyhiLGQpfX1pZih2LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkhPTApcmV0dXJuIEJpZ0ludGVnZXIuWkVSTztpZihkLmNvbXBhcmVUbyhtKT49MClyZXR1cm4gZC5zdWJ0cmFjdChtKTtpZihkLnNpZ251bSgpPDApZC5hZGRUbyhtLGQpO2Vsc2UgcmV0dXJuIGQ7aWYoZC5zaWdudW0oKTwwKXJldHVybiBkLmFkZChtKTtlbHNlIHJldHVybiBkfXByb3RvLmNodW5rU2l6ZT1ibnBDaHVua1NpemU7cHJvdG8udG9SYWRpeD1ibnBUb1JhZGl4O3Byb3RvLmZyb21SYWRpeD1ibnBGcm9tUmFkaXg7cHJvdG8uZnJvbU51bWJlcj1ibnBGcm9tTnVtYmVyO3Byb3RvLmJpdHdpc2VUbz1ibnBCaXR3aXNlVG87cHJvdG8uY2hhbmdlQml0PWJucENoYW5nZUJpdDtwcm90by5hZGRUbz1ibnBBZGRUbztwcm90by5kTXVsdGlwbHk9Ym5wRE11bHRpcGx5O3Byb3RvLmRBZGRPZmZzZXQ9Ym5wREFkZE9mZnNldDtwcm90by5tdWx0aXBseUxvd2VyVG89Ym5wTXVsdGlwbHlMb3dlclRvO3Byb3RvLm11bHRpcGx5VXBwZXJUbz1ibnBNdWx0aXBseVVwcGVyVG87cHJvdG8ubW9kSW50PWJucE1vZEludDtwcm90by5jbG9uZT1ibkNsb25lO3Byb3RvLmludFZhbHVlPWJuSW50VmFsdWU7cHJvdG8uYnl0ZVZhbHVlPWJuQnl0ZVZhbHVlO3Byb3RvLnNob3J0VmFsdWU9Ym5TaG9ydFZhbHVlO3Byb3RvLnNpZ251bT1iblNpZ051bTtwcm90by50b0J5dGVBcnJheT1iblRvQnl0ZUFycmF5O3Byb3RvLmVxdWFscz1ibkVxdWFscztwcm90by5taW49Ym5NaW47cHJvdG8ubWF4PWJuTWF4O3Byb3RvLmFuZD1ibkFuZDtwcm90by5vcj1ibk9yO3Byb3RvLnhvcj1iblhvcjtwcm90by5hbmROb3Q9Ym5BbmROb3Q7cHJvdG8ubm90PWJuTm90O3Byb3RvLnNoaWZ0TGVmdD1iblNoaWZ0TGVmdDtwcm90by5zaGlmdFJpZ2h0PWJuU2hpZnRSaWdodDtwcm90by5nZXRMb3dlc3RTZXRCaXQ9Ym5HZXRMb3dlc3RTZXRCaXQ7cHJvdG8uYml0Q291bnQ9Ym5CaXRDb3VudDtwcm90by50ZXN0Qml0PWJuVGVzdEJpdDtwcm90by5zZXRCaXQ9Ym5TZXRCaXQ7cHJvdG8uY2xlYXJCaXQ9Ym5DbGVhckJpdDtwcm90by5mbGlwQml0PWJuRmxpcEJpdDtwcm90by5hZGQ9Ym5BZGQ7cHJvdG8uc3VidHJhY3Q9Ym5TdWJ0cmFjdDtwcm90by5tdWx0aXBseT1ibk11bHRpcGx5O3Byb3RvLmRpdmlkZT1ibkRpdmlkZTtwcm90by5yZW1haW5kZXI9Ym5SZW1haW5kZXI7cHJvdG8uZGl2aWRlQW5kUmVtYWluZGVyPWJuRGl2aWRlQW5kUmVtYWluZGVyO3Byb3RvLm1vZFBvdz1ibk1vZFBvdztwcm90by5tb2RJbnZlcnNlPWJuTW9kSW52ZXJzZTtwcm90by5wb3c9Ym5Qb3c7cHJvdG8uZ2NkPWJuR0NEO3Byb3RvLnNxdWFyZT1iblNxdWFyZTtCaWdJbnRlZ2VyLlpFUk89bmJ2KDApO0JpZ0ludGVnZXIuT05FPW5idigxKTtCaWdJbnRlZ2VyLnZhbHVlT2Y9bmJ2O0JpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkPWZ1bmN0aW9uKGJhKXtpZihCdWZmZXIuaXNCdWZmZXIoYmEpKXtiYT1BcnJheS5wcm90b3R5cGUubWFwLmJpbmQoYmEsZnVuY3Rpb24oeCl7cmV0dXJuIHh9KSgpfWlmKCFiYS5sZW5ndGgpe3JldHVybiBuZXcgQmlnSW50ZWdlci52YWx1ZU9mKDApfWVsc2UgaWYoYmFbMF0mMTI4KXtyZXR1cm4gbmV3IEJpZ0ludGVnZXIoWzBdLmNvbmNhdChiYSkpfWVsc2V7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGJhKX19O0JpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVNpZ25lZD1mdW5jdGlvbihiYSl7aWYoYmFbMF0mMTI4KXtiYVswXSY9MTI3O3JldHVybiBCaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZChiYSkubmVnYXRlKCl9ZWxzZXtyZXR1cm4gQmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQoYmEpfX07QmlnSW50ZWdlci5wcm90b3R5cGUudG9CeXRlQXJyYXlVbnNpZ25lZD1mdW5jdGlvbigpe3ZhciBiYT10aGlzLmFicygpLnRvQnl0ZUFycmF5KCk7aWYoIWJhLmxlbmd0aCl7cmV0dXJuIGJhfWlmKGJhWzBdPT09MCl7YmE9YmEuc2xpY2UoMSl9Zm9yKHZhciBpPTA7aTxiYS5sZW5ndGg7KytpKXtiYVtpXT1iYVtpXTwwP2JhW2ldKzI1NjpiYVtpXX1yZXR1cm4gYmF9O0JpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5U2lnbmVkPWZ1bmN0aW9uKCl7dmFyIHZhbD10aGlzLnRvQnl0ZUFycmF5VW5zaWduZWQoKTt2YXIgbmVnPXRoaXMuczwwO2lmKHZhbFswXSYxMjgpe3ZhbC51bnNoaWZ0KG5lZz8xMjg6MCl9ZWxzZSBpZihuZWcpe3ZhbFswXXw9MTI4fXJldHVybiB2YWx9O21vZHVsZS5leHBvcnRzPUJpZ0ludGVnZXJ9KS5jYWxsKHRoaXMsX2RlcmVxXyhcImJ1ZmZlclwiKS5CdWZmZXIpfSx7YnVmZmVyOjV9XSw2NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIEVDQ3VydmVGcD1fZGVyZXFfKFwiLi9lY1wiKTt2YXIgQmlnSW50ZWdlcj1fZGVyZXFfKFwiLi9qc2JuXCIpO2Z1bmN0aW9uIFg5RUNQYXJhbWV0ZXJzKGN1cnZlLGcsbixoKXt0aGlzLmN1cnZlPWN1cnZlO3RoaXMuZz1nO3RoaXMubj1uO3RoaXMuaD1ofWZ1bmN0aW9uIHg5Z2V0Q3VydmUoKXtyZXR1cm4gdGhpcy5jdXJ2ZX1mdW5jdGlvbiB4OWdldEcoKXtyZXR1cm4gdGhpcy5nfWZ1bmN0aW9uIHg5Z2V0Tigpe3JldHVybiB0aGlzLm59ZnVuY3Rpb24geDlnZXRIKCl7cmV0dXJuIHRoaXMuaH1YOUVDUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0Q3VydmU9eDlnZXRDdXJ2ZTtYOUVDUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0Rz14OWdldEc7WDlFQ1BhcmFtZXRlcnMucHJvdG90eXBlLmdldE49eDlnZXROO1g5RUNQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRIPXg5Z2V0SDtmdW5jdGlvbiBmcm9tSGV4KHMpe3JldHVybiBuZXcgQmlnSW50ZWdlcihzLDE2KX1mdW5jdGlvbiBzZWNwMTI4cjEoKXt2YXIgcD1mcm9tSGV4KFwiRkZGRkZGRkRGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZcIik7dmFyIGE9ZnJvbUhleChcIkZGRkZGRkZERkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZDXCIpO3ZhciBiPWZyb21IZXgoXCJFODc1NzlDMTEwNzlGNDNERDgyNDk5M0MyQ0VFNUVEM1wiKTt2YXIgbj1mcm9tSGV4KFwiRkZGRkZGRkUwMDAwMDAwMDc1QTMwRDFCOTAzOEExMTVcIik7dmFyIGg9QmlnSW50ZWdlci5PTkU7dmFyIGN1cnZlPW5ldyBFQ0N1cnZlRnAocCxhLGIpO3ZhciBHPWN1cnZlLmRlY29kZVBvaW50SGV4KFwiMDRcIitcIjE2MUZGNzUyOEI4OTlCMkQwQzI4NjA3Q0E1MkM1Qjg2XCIrXCJDRjVBQzgzOTVCQUZFQjEzQzAyREEyOTJEREVEN0E4M1wiKTtyZXR1cm4gbmV3IFg5RUNQYXJhbWV0ZXJzKGN1cnZlLEcsbixoKX1mdW5jdGlvbiBzZWNwMTYwazEoKXt2YXIgcD1mcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkVGRkZGQUM3M1wiKTt2YXIgYT1CaWdJbnRlZ2VyLlpFUk87dmFyIGI9ZnJvbUhleChcIjdcIik7dmFyIG49ZnJvbUhleChcIjAxMDAwMDAwMDAwMDAwMDAwMDAwMDFCOEZBMTZERkFCOUFDQTE2QjZCM1wiKTt2YXIgaD1CaWdJbnRlZ2VyLk9ORTt2YXIgY3VydmU9bmV3IEVDQ3VydmVGcChwLGEsYik7dmFyIEc9Y3VydmUuZGVjb2RlUG9pbnRIZXgoXCIwNFwiK1wiM0I0QzM4MkNFMzdBQTE5MkE0MDE5RTc2MzAzNkY0RjVERDREN0VCQlwiK1wiOTM4Q0Y5MzUzMThGRENFRDZCQzI4Mjg2NTMxNzMzQzNGMDNDNEZFRVwiKTtyZXR1cm4gbmV3IFg5RUNQYXJhbWV0ZXJzKGN1cnZlLEcsbixoKX1mdW5jdGlvbiBzZWNwMTYwcjEoKXt2YXIgcD1mcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY3RkZGRkZGRlwiKTt2YXIgYT1mcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY3RkZGRkZGQ1wiKTt2YXIgYj1mcm9tSGV4KFwiMUM5N0JFRkM1NEJEN0E4QjY1QUNGODlGODFENEQ0QURDNTY1RkE0NVwiKTt2YXIgbj1mcm9tSGV4KFwiMDEwMDAwMDAwMDAwMDAwMDAwMDAwMUY0QzhGOTI3QUVEM0NBNzUyMjU3XCIpO3ZhciBoPUJpZ0ludGVnZXIuT05FO3ZhciBjdXJ2ZT1uZXcgRUNDdXJ2ZUZwKHAsYSxiKTt2YXIgRz1jdXJ2ZS5kZWNvZGVQb2ludEhleChcIjA0XCIrXCI0QTk2QjU2ODhFRjU3MzI4NDY2NDY5ODk2OEMzOEJCOTEzQ0JGQzgyXCIrXCIyM0E2Mjg1NTMxNjg5NDdENTlEQ0M5MTIwNDIzNTEzNzdBQzVGQjMyXCIpO3JldHVybiBuZXcgWDlFQ1BhcmFtZXRlcnMoY3VydmUsRyxuLGgpfWZ1bmN0aW9uIHNlY3AxOTJrMSgpe3ZhciBwPWZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZFRkZGRkVFMzdcIik7dmFyIGE9QmlnSW50ZWdlci5aRVJPO3ZhciBiPWZyb21IZXgoXCIzXCIpO3ZhciBuPWZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkUyNkYyRkMxNzBGNjk0NjZBNzRERUZEOERcIik7dmFyIGg9QmlnSW50ZWdlci5PTkU7dmFyIGN1cnZlPW5ldyBFQ0N1cnZlRnAocCxhLGIpO3ZhciBHPWN1cnZlLmRlY29kZVBvaW50SGV4KFwiMDRcIitcIkRCNEZGMTBFQzA1N0U5QUUyNkIwN0QwMjgwQjdGNDM0MURBNUQxQjFFQUUwNkM3RFwiK1wiOUIyRjJGNkQ5QzU2MjhBNzg0NDE2M0QwMTVCRTg2MzQ0MDgyQUE4OEQ5NUUyRjlEXCIpO3JldHVybiBuZXcgWDlFQ1BhcmFtZXRlcnMoY3VydmUsRyxuLGgpfWZ1bmN0aW9uIHNlY3AxOTJyMSgpe3ZhciBwPWZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRUZGRkZGRkZGRkZGRkZGRkZcIik7dmFyIGE9ZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZFRkZGRkZGRkZGRkZGRkZGQ1wiKTt2YXIgYj1mcm9tSGV4KFwiNjQyMTA1MTlFNTlDODBFNzBGQTdFOUFCNzIyNDMwNDlGRUI4REVFQ0MxNDZCOUIxXCIpO3ZhciBuPWZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY5OURFRjgzNjE0NkJDOUIxQjREMjI4MzFcIik7dmFyIGg9QmlnSW50ZWdlci5PTkU7dmFyIGN1cnZlPW5ldyBFQ0N1cnZlRnAocCxhLGIpO3ZhciBHPWN1cnZlLmRlY29kZVBvaW50SGV4KFwiMDRcIitcIjE4OERBODBFQjAzMDkwRjY3Q0JGMjBFQjQzQTE4ODAwRjRGRjBBRkQ4MkZGMTAxMlwiK1wiMDcxOTJCOTVGRkM4REE3ODYzMTAxMUVENkIyNENERDU3M0Y5NzdBMTFFNzk0ODExXCIpO3JldHVybiBuZXcgWDlFQ1BhcmFtZXRlcnMoY3VydmUsRyxuLGgpfWZ1bmN0aW9uIHNlY3AyMjRyMSgpe3ZhciBwPWZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMVwiKTt2YXIgYT1mcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkVGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkVcIik7dmFyIGI9ZnJvbUhleChcIkI0MDUwQTg1MEMwNEIzQUJGNTQxMzI1NjUwNDRCMEI3RDdCRkQ4QkEyNzBCMzk0MzIzNTVGRkI0XCIpO3ZhciBuPWZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGMTZBMkUwQjhGMDNFMTNERDI5NDU1QzVDMkEzRFwiKTt2YXIgaD1CaWdJbnRlZ2VyLk9ORTt2YXIgY3VydmU9bmV3IEVDQ3VydmVGcChwLGEsYik7dmFyIEc9Y3VydmUuZGVjb2RlUG9pbnRIZXgoXCIwNFwiK1wiQjcwRTBDQkQ2QkI0QkY3RjMyMTM5MEI5NEEwM0MxRDM1NkMyMTEyMjM0MzI4MEQ2MTE1QzFEMjFcIitcIkJEMzc2Mzg4QjVGNzIzRkI0QzIyREZFNkNENDM3NUEwNUEwNzQ3NjQ0NEQ1ODE5OTg1MDA3RTM0XCIpO3JldHVybiBuZXcgWDlFQ1BhcmFtZXRlcnMoY3VydmUsRyxuLGgpfWZ1bmN0aW9uIHNlY3AyNTZrMSgpe3ZhciBwPWZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRUZGRkZGQzJGXCIpO3ZhciBhPUJpZ0ludGVnZXIuWkVSTzt2YXIgYj1mcm9tSGV4KFwiN1wiKTt2YXIgbj1mcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkVCQUFFRENFNkFGNDhBMDNCQkZEMjVFOENEMDM2NDE0MVwiKTt2YXIgaD1CaWdJbnRlZ2VyLk9ORTt2YXIgY3VydmU9bmV3IEVDQ3VydmVGcChwLGEsYik7dmFyIEc9Y3VydmUuZGVjb2RlUG9pbnRIZXgoXCIwNFwiK1wiNzlCRTY2N0VGOURDQkJBQzU1QTA2Mjk1Q0U4NzBCMDcwMjlCRkNEQjJEQ0UyOEQ5NTlGMjgxNUIxNkY4MTc5OFwiK1wiNDgzQURBNzcyNkEzQzQ2NTVEQTRGQkZDMEUxMTA4QThGRDE3QjQ0OEE2ODU1NDE5OUM0N0QwOEZGQjEwRDRCOFwiKTtyZXR1cm4gbmV3IFg5RUNQYXJhbWV0ZXJzKGN1cnZlLEcsbixoKX1mdW5jdGlvbiBzZWNwMjU2cjEoKXt2YXIgcD1mcm9tSGV4KFwiRkZGRkZGRkYwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRlwiKTt2YXIgYT1mcm9tSGV4KFwiRkZGRkZGRkYwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGQ1wiKTt2YXIgYj1mcm9tSGV4KFwiNUFDNjM1RDhBQTNBOTNFN0IzRUJCRDU1NzY5ODg2QkM2NTFEMDZCMENDNTNCMEY2M0JDRTNDM0UyN0QyNjA0QlwiKTt2YXIgbj1mcm9tSGV4KFwiRkZGRkZGRkYwMDAwMDAwMEZGRkZGRkZGRkZGRkZGRkZCQ0U2RkFBREE3MTc5RTg0RjNCOUNBQzJGQzYzMjU1MVwiKTt2YXIgaD1CaWdJbnRlZ2VyLk9ORTt2YXIgY3VydmU9bmV3IEVDQ3VydmVGcChwLGEsYik7dmFyIEc9Y3VydmUuZGVjb2RlUG9pbnRIZXgoXCIwNFwiK1wiNkIxN0QxRjJFMTJDNDI0N0Y4QkNFNkU1NjNBNDQwRjI3NzAzN0Q4MTJERUIzM0EwRjRBMTM5NDVEODk4QzI5NlwiK1wiNEZFMzQyRTJGRTFBN0Y5QjhFRTdFQjRBN0MwRjlFMTYyQkNFMzM1NzZCMzE1RUNFQ0JCNjQwNjgzN0JGNTFGNVwiKTtyZXR1cm4gbmV3IFg5RUNQYXJhbWV0ZXJzKGN1cnZlLEcsbixoKX1mdW5jdGlvbiBnZXRTRUNDdXJ2ZUJ5TmFtZShuYW1lKXtpZihuYW1lPT1cInNlY3AxMjhyMVwiKXJldHVybiBzZWNwMTI4cjEoKTtpZihuYW1lPT1cInNlY3AxNjBrMVwiKXJldHVybiBzZWNwMTYwazEoKTtpZihuYW1lPT1cInNlY3AxNjByMVwiKXJldHVybiBzZWNwMTYwcjEoKTtpZihuYW1lPT1cInNlY3AxOTJrMVwiKXJldHVybiBzZWNwMTkyazEoKTtpZihuYW1lPT1cInNlY3AxOTJyMVwiKXJldHVybiBzZWNwMTkycjEoKTtpZihuYW1lPT1cInNlY3AyMjRyMVwiKXJldHVybiBzZWNwMjI0cjEoKTtpZihuYW1lPT1cInNlY3AyNTZrMVwiKXJldHVybiBzZWNwMjU2azEoKTtpZihuYW1lPT1cInNlY3AyNTZyMVwiKXJldHVybiBzZWNwMjU2cjEoKTtyZXR1cm4gbnVsbH1tb2R1bGUuZXhwb3J0cz1nZXRTRUNDdXJ2ZUJ5TmFtZX0se1wiLi9lY1wiOjYyLFwiLi9qc2JuXCI6NjN9XSw2NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIEFkZHJlc3M9X2RlcmVxXyhcIi4vYWRkcmVzc1wiKTt2YXIgY29udmVydD1fZGVyZXFfKFwiLi9jb252ZXJ0XCIpO3ZhciBlY2RzYT1fZGVyZXFfKFwiLi9lY2RzYVwiKTt2YXIgRUNQdWJLZXk9X2RlcmVxXyhcIi4vZWNrZXlcIikuRUNQdWJLZXk7dmFyIFNIQTI1Nj1fZGVyZXFfKFwiY3J5cHRvLWpzL3NoYTI1NlwiKTt2YXIgbWFnaWNCeXRlcz1jb252ZXJ0LnN0cmluZ1RvQnl0ZXMoXCJCaXRjb2luIFNpZ25lZCBNZXNzYWdlOlxcblwiKTtmdW5jdGlvbiBtYWdpY0hhc2gobWVzc2FnZSl7dmFyIG1lc3NhZ2VCeXRlcz1jb252ZXJ0LnN0cmluZ1RvQnl0ZXMobWVzc2FnZSk7dmFyIGJ1ZmZlcj1bXS5jb25jYXQoY29udmVydC5udW1Ub1ZhckludChtYWdpY0J5dGVzLmxlbmd0aCksbWFnaWNCeXRlcyxjb252ZXJ0Lm51bVRvVmFySW50KG1lc3NhZ2VCeXRlcy5sZW5ndGgpLG1lc3NhZ2VCeXRlcyk7XG5yZXR1cm4gY29udmVydC53b3JkQXJyYXlUb0J5dGVzKFNIQTI1NihTSEEyNTYoY29udmVydC5ieXRlc1RvV29yZEFycmF5KGJ1ZmZlcikpKSl9ZnVuY3Rpb24gc2lnbihrZXksbWVzc2FnZSl7dmFyIGhhc2g9bWFnaWNIYXNoKG1lc3NhZ2UpO3ZhciBzaWc9a2V5LnNpZ24oaGFzaCk7dmFyIG9iaj1lY2RzYS5wYXJzZVNpZyhzaWcpO3ZhciBpPWVjZHNhLmNhbGNQdWJLZXlSZWNvdmVyeVBhcmFtKGtleS5nZXRQdWIoKS5wdWIsb2JqLnIsb2JqLnMsaGFzaCk7aSs9Mjc7aWYoa2V5LmNvbXByZXNzZWQpe2krPTR9dmFyIHJCYT1vYmouci50b0J5dGVBcnJheVVuc2lnbmVkKCk7dmFyIHNCYT1vYmoucy50b0J5dGVBcnJheVVuc2lnbmVkKCk7d2hpbGUockJhLmxlbmd0aDwzMilyQmEudW5zaGlmdCgwKTt3aGlsZShzQmEubGVuZ3RoPDMyKXNCYS51bnNoaWZ0KDApO3NpZz1baV0uY29uY2F0KHJCYSxzQmEpO3JldHVybiBzaWd9ZnVuY3Rpb24gdmVyaWZ5KGFkZHJlc3Msc2lnLG1lc3NhZ2Upe3NpZz1lY2RzYS5wYXJzZVNpZ0NvbXBhY3Qoc2lnKTt2YXIgcHViS2V5PW5ldyBFQ1B1YktleShlY2RzYS5yZWNvdmVyUHViS2V5KHNpZy5yLHNpZy5zLG1hZ2ljSGFzaChtZXNzYWdlKSxzaWcuaSkpO3ZhciBpc0NvbXByZXNzZWQ9ISEoc2lnLmkmNCk7cHViS2V5LmNvbXByZXNzZWQ9aXNDb21wcmVzc2VkO2FkZHJlc3M9bmV3IEFkZHJlc3MoYWRkcmVzcyk7cmV0dXJuIHB1YktleS5nZXRBZGRyZXNzKGFkZHJlc3MudmVyc2lvbikudG9TdHJpbmcoKT09PWFkZHJlc3MudG9TdHJpbmcoKX1tb2R1bGUuZXhwb3J0cz17bWFnaWNIYXNoOm1hZ2ljSGFzaCxzaWduOnNpZ24sdmVyaWZ5OnZlcmlmeX19LHtcIi4vYWRkcmVzc1wiOjU0LFwiLi9jb252ZXJ0XCI6NTcsXCIuL2VjZHNhXCI6NTgsXCIuL2Vja2V5XCI6NTksXCJjcnlwdG8tanMvc2hhMjU2XCI6NDd9XSw2NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9e21haW5uZXQ6e2FkZHJlc3NWZXJzaW9uOjAscDJzaFZlcnNpb246NSxoZFZlcnNpb25zOntwdWI6NzYwNjczNTgscHJpdjo3NjA2NjI3Nn19LHRlc3RuZXQ6e2FkZHJlc3NWZXJzaW9uOjExMSxwMnNoVmVyc2lvbjoxOTYsaGRWZXJzaW9uczp7cHViOjcwNjE3MDM5LHByaXY6NzA2MTU5NTZ9fX19LHt9XSw2NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIE9wY29kZT17bWFwOntPUF8wOjAsT1BfRkFMU0U6MCxPUF9QVVNIREFUQTE6NzYsT1BfUFVTSERBVEEyOjc3LE9QX1BVU0hEQVRBNDo3OCxPUF8xTkVHQVRFOjc5LE9QX1JFU0VSVkVEOjgwLE9QXzE6ODEsT1BfVFJVRTo4MSxPUF8yOjgyLE9QXzM6ODMsT1BfNDo4NCxPUF81Ojg1LE9QXzY6ODYsT1BfNzo4NyxPUF84Ojg4LE9QXzk6ODksT1BfMTA6OTAsT1BfMTE6OTEsT1BfMTI6OTIsT1BfMTM6OTMsT1BfMTQ6OTQsT1BfMTU6OTUsT1BfMTY6OTYsT1BfTk9QOjk3LE9QX1ZFUjo5OCxPUF9JRjo5OSxPUF9OT1RJRjoxMDAsT1BfVkVSSUY6MTAxLE9QX1ZFUk5PVElGOjEwMixPUF9FTFNFOjEwMyxPUF9FTkRJRjoxMDQsT1BfVkVSSUZZOjEwNSxPUF9SRVRVUk46MTA2LE9QX1RPQUxUU1RBQ0s6MTA3LE9QX0ZST01BTFRTVEFDSzoxMDgsT1BfMkRST1A6MTA5LE9QXzJEVVA6MTEwLE9QXzNEVVA6MTExLE9QXzJPVkVSOjExMixPUF8yUk9UOjExMyxPUF8yU1dBUDoxMTQsT1BfSUZEVVA6MTE1LE9QX0RFUFRIOjExNixPUF9EUk9QOjExNyxPUF9EVVA6MTE4LE9QX05JUDoxMTksT1BfT1ZFUjoxMjAsT1BfUElDSzoxMjEsT1BfUk9MTDoxMjIsT1BfUk9UOjEyMyxPUF9TV0FQOjEyNCxPUF9UVUNLOjEyNSxPUF9DQVQ6MTI2LE9QX1NVQlNUUjoxMjcsT1BfTEVGVDoxMjgsT1BfUklHSFQ6MTI5LE9QX1NJWkU6MTMwLE9QX0lOVkVSVDoxMzEsT1BfQU5EOjEzMixPUF9PUjoxMzMsT1BfWE9SOjEzNCxPUF9FUVVBTDoxMzUsT1BfRVFVQUxWRVJJRlk6MTM2LE9QX1JFU0VSVkVEMToxMzcsT1BfUkVTRVJWRUQyOjEzOCxPUF8xQUREOjEzOSxPUF8xU1VCOjE0MCxPUF8yTVVMOjE0MSxPUF8yRElWOjE0MixPUF9ORUdBVEU6MTQzLE9QX0FCUzoxNDQsT1BfTk9UOjE0NSxPUF8wTk9URVFVQUw6MTQ2LE9QX0FERDoxNDcsT1BfU1VCOjE0OCxPUF9NVUw6MTQ5LE9QX0RJVjoxNTAsT1BfTU9EOjE1MSxPUF9MU0hJRlQ6MTUyLE9QX1JTSElGVDoxNTMsT1BfQk9PTEFORDoxNTQsT1BfQk9PTE9SOjE1NSxPUF9OVU1FUVVBTDoxNTYsT1BfTlVNRVFVQUxWRVJJRlk6MTU3LE9QX05VTU5PVEVRVUFMOjE1OCxPUF9MRVNTVEhBTjoxNTksT1BfR1JFQVRFUlRIQU46MTYwLE9QX0xFU1NUSEFOT1JFUVVBTDoxNjEsT1BfR1JFQVRFUlRIQU5PUkVRVUFMOjE2MixPUF9NSU46MTYzLE9QX01BWDoxNjQsT1BfV0lUSElOOjE2NSxPUF9SSVBFTUQxNjA6MTY2LE9QX1NIQTE6MTY3LE9QX1NIQTI1NjoxNjgsT1BfSEFTSDE2MDoxNjksT1BfSEFTSDI1NjoxNzAsT1BfQ09ERVNFUEFSQVRPUjoxNzEsT1BfQ0hFQ0tTSUc6MTcyLE9QX0NIRUNLU0lHVkVSSUZZOjE3MyxPUF9DSEVDS01VTFRJU0lHOjE3NCxPUF9DSEVDS01VTFRJU0lHVkVSSUZZOjE3NSxPUF9OT1AxOjE3NixPUF9OT1AyOjE3NyxPUF9OT1AzOjE3OCxPUF9OT1A0OjE3OSxPUF9OT1A1OjE4MCxPUF9OT1A2OjE4MSxPUF9OT1A3OjE4MixPUF9OT1A4OjE4MyxPUF9OT1A5OjE4NCxPUF9OT1AxMDoxODUsT1BfUFVCS0VZSEFTSDoyNTMsT1BfUFVCS0VZOjI1NCxPUF9JTlZBTElET1BDT0RFOjI1NX0scmV2ZXJzZU1hcDpbXX07Zm9yKHZhciBpIGluIE9wY29kZS5tYXApe09wY29kZS5yZXZlcnNlTWFwW09wY29kZS5tYXBbaV1dPWl9bW9kdWxlLmV4cG9ydHM9T3Bjb2RlfSx7fV0sNjg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihCdWZmZXIpe3ZhciBPcGNvZGU9X2RlcmVxXyhcIi4vb3Bjb2RlXCIpO3ZhciB1dGlsPV9kZXJlcV8oXCIuL3V0aWxcIik7dmFyIGNvbnZlcnQ9X2RlcmVxXyhcIi4vY29udmVydFwiKTt2YXIgQWRkcmVzcz1fZGVyZXFfKFwiLi9hZGRyZXNzXCIpO3ZhciBuZXR3b3JrPV9kZXJlcV8oXCIuL25ldHdvcmtcIik7dmFyIFNjcmlwdD1mdW5jdGlvbihkYXRhKXt0aGlzLmJ1ZmZlcj1kYXRhfHxbXTtpZighQXJyYXkuaXNBcnJheSh0aGlzLmJ1ZmZlcikpe3Rocm93IG5ldyBFcnJvcihcImV4cGVjdCBTY3JpcHQgdG8gYmUgaW5pdGlhbGl6ZWQgd2l0aCBBcnJheSwgYnV0IGdvdCBcIitkYXRhKX10aGlzLnBhcnNlKCl9O1NjcmlwdC5mcm9tSGV4PWZ1bmN0aW9uKGRhdGEpe3JldHVybiBuZXcgU2NyaXB0KGNvbnZlcnQuaGV4VG9CeXRlcyhkYXRhKSl9O1NjcmlwdC5mcm9tUHViS2V5PWZ1bmN0aW9uKHN0cil7dmFyIHNjcmlwdD1uZXcgU2NyaXB0O3ZhciBzPXN0ci5zcGxpdChcIiBcIik7Zm9yKHZhciBpIGluIHMpe2lmKE9wY29kZS5tYXAuaGFzT3duUHJvcGVydHkoc1tpXSkpe3NjcmlwdC53cml0ZU9wKE9wY29kZS5tYXBbc1tpXV0pfWVsc2V7c2NyaXB0LndyaXRlQnl0ZXMoY29udmVydC5oZXhUb0J5dGVzKHNbaV0pKX19cmV0dXJuIHNjcmlwdH07U2NyaXB0LmZyb21TY3JpcHRTaWc9ZnVuY3Rpb24oc3RyKXt2YXIgc2NyaXB0PW5ldyBTY3JpcHQ7dmFyIHM9c3RyLnNwbGl0KFwiIFwiKTtmb3IodmFyIGkgaW4gcyl7aWYoT3Bjb2RlLm1hcC5oYXNPd25Qcm9wZXJ0eShzW2ldKSl7c2NyaXB0LndyaXRlT3AoT3Bjb2RlLm1hcFtzW2ldXSl9ZWxzZXtzY3JpcHQud3JpdGVCeXRlcyhjb252ZXJ0LmhleFRvQnl0ZXMoc1tpXSkpfX1yZXR1cm4gc2NyaXB0fTtTY3JpcHQucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKCl7dmFyIHNlbGY9dGhpczt0aGlzLmNodW5rcz1bXTt2YXIgaT0wO2Z1bmN0aW9uIHJlYWRDaHVuayhuKXtzZWxmLmNodW5rcy5wdXNoKHNlbGYuYnVmZmVyLnNsaWNlKGksaStuKSk7aSs9bn13aGlsZShpPHRoaXMuYnVmZmVyLmxlbmd0aCl7dmFyIG9wY29kZT10aGlzLmJ1ZmZlcltpKytdO2lmKG9wY29kZT49MjQwKXtvcGNvZGU9b3Bjb2RlPDw4fHRoaXMuYnVmZmVyW2krK119dmFyIGxlbjtpZihvcGNvZGU+MCYmb3Bjb2RlPE9wY29kZS5tYXAuT1BfUFVTSERBVEExKXtyZWFkQ2h1bmsob3Bjb2RlKX1lbHNlIGlmKG9wY29kZT09T3Bjb2RlLm1hcC5PUF9QVVNIREFUQTEpe2xlbj10aGlzLmJ1ZmZlcltpKytdO3JlYWRDaHVuayhsZW4pfWVsc2UgaWYob3Bjb2RlPT1PcGNvZGUubWFwLk9QX1BVU0hEQVRBMil7bGVuPXRoaXMuYnVmZmVyW2krK108PDh8dGhpcy5idWZmZXJbaSsrXTtyZWFkQ2h1bmsobGVuKX1lbHNlIGlmKG9wY29kZT09T3Bjb2RlLm1hcC5PUF9QVVNIREFUQTQpe2xlbj10aGlzLmJ1ZmZlcltpKytdPDwyNHx0aGlzLmJ1ZmZlcltpKytdPDwxNnx0aGlzLmJ1ZmZlcltpKytdPDw4fHRoaXMuYnVmZmVyW2krK107cmVhZENodW5rKGxlbil9ZWxzZXt0aGlzLmNodW5rcy5wdXNoKG9wY29kZSl9fX07U2NyaXB0LnByb3RvdHlwZS5nZXRPdXRUeXBlPWZ1bmN0aW9uKCl7aWYodGhpcy5jaHVua3NbdGhpcy5jaHVua3MubGVuZ3RoLTFdPT1PcGNvZGUubWFwLk9QX0VRVUFMJiZ0aGlzLmNodW5rc1swXT09T3Bjb2RlLm1hcC5PUF9IQVNIMTYwJiZ0aGlzLmNodW5rcy5sZW5ndGg9PTMpe3JldHVyblwiUDJTSFwifWVsc2UgaWYodGhpcy5jaHVua3MubGVuZ3RoPT01JiZ0aGlzLmNodW5rc1swXT09T3Bjb2RlLm1hcC5PUF9EVVAmJnRoaXMuY2h1bmtzWzFdPT1PcGNvZGUubWFwLk9QX0hBU0gxNjAmJnRoaXMuY2h1bmtzWzNdPT1PcGNvZGUubWFwLk9QX0VRVUFMVkVSSUZZJiZ0aGlzLmNodW5rc1s0XT09T3Bjb2RlLm1hcC5PUF9DSEVDS1NJRyl7cmV0dXJuXCJQdWJrZXlcIn1lbHNle3JldHVyblwiU3RyYW5nZVwifX07U2NyaXB0LnByb3RvdHlwZS50b1NjcmlwdEhhc2g9ZnVuY3Rpb24oKXt2YXIgb3V0VHlwZT10aGlzLmdldE91dFR5cGUoKTtpZihvdXRUeXBlPT1cIlB1YmtleVwiKXtyZXR1cm4gdGhpcy5jaHVua3NbMl19aWYob3V0VHlwZT09XCJQMlNIXCIpe3JldHVybiB1dGlsLnNoYTI1NnJpcGUxNjAodGhpcy5idWZmZXIpfXJldHVybiB1dGlsLnNoYTI1NnJpcGUxNjAodGhpcy5idWZmZXIpfTtTY3JpcHQucHJvdG90eXBlLmdldFRvQWRkcmVzcz1mdW5jdGlvbigpe3ZhciBvdXRUeXBlPXRoaXMuZ2V0T3V0VHlwZSgpO2lmKG91dFR5cGU9PVwiUHVia2V5XCIpe3JldHVybiBuZXcgQWRkcmVzcyh0aGlzLmNodW5rc1syXSl9aWYob3V0VHlwZT09XCJQMlNIXCIpe3JldHVybiBuZXcgQWRkcmVzcyh0aGlzLmNodW5rc1sxXSw1KX1yZXR1cm4gbmV3IEFkZHJlc3ModGhpcy5jaHVua3NbMV0sNSl9O1NjcmlwdC5wcm90b3R5cGUuZ2V0RnJvbUFkZHJlc3M9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEFkZHJlc3ModGhpcy5zaW1wbGVJbkhhc2goKSl9O1NjcmlwdC5wcm90b3R5cGUuZ2V0SW5UeXBlPWZ1bmN0aW9uKCl7aWYodGhpcy5jaHVua3MubGVuZ3RoPT0xJiZBcnJheS5pc0FycmF5KHRoaXMuY2h1bmtzWzBdKSl7cmV0dXJuXCJQdWJrZXlcIn1lbHNlIGlmKHRoaXMuY2h1bmtzLmxlbmd0aD09MiYmQXJyYXkuaXNBcnJheSh0aGlzLmNodW5rc1swXSkmJkFycmF5LmlzQXJyYXkodGhpcy5jaHVua3NbMV0pKXtyZXR1cm5cIkFkZHJlc3NcIn1lbHNlIGlmKHRoaXMuY2h1bmtzWzBdPT1PcGNvZGUubWFwLk9QXzAmJnRoaXMuY2h1bmtzLnNsaWNlKDEpLnJlZHVjZShmdW5jdGlvbih0LGNodW5rLGkpe3JldHVybiB0JiZBcnJheS5pc0FycmF5KGNodW5rKSYmKGNodW5rWzBdPT00OHx8aT09dGhpcy5jaHVua3MubGVuZ3RoLTEpfSx0cnVlKSl7cmV0dXJuXCJNdWx0aXNpZ1wifWVsc2V7cmV0dXJuXCJTdHJhbmdlXCJ9fTtTY3JpcHQucHJvdG90eXBlLnNpbXBsZUluUHViS2V5PWZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuZ2V0SW5UeXBlKCkpe2Nhc2VcIkFkZHJlc3NcIjpyZXR1cm4gdGhpcy5jaHVua3NbMV07Y2FzZVwiUHVia2V5XCI6dGhyb3cgbmV3IEVycm9yKFwiU2NyaXB0IGRvZXMgbm90IGNvbnRhaW4gcHVia2V5XCIpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiRW5jb3VudGVyZWQgbm9uLXN0YW5kYXJkIHNjcmlwdFNpZ1wiKX19O1NjcmlwdC5wcm90b3R5cGUuc2ltcGxlSW5IYXNoPWZ1bmN0aW9uKCl7cmV0dXJuIHV0aWwuc2hhMjU2cmlwZTE2MCh0aGlzLnNpbXBsZUluUHViS2V5KCkpfTtTY3JpcHQucHJvdG90eXBlLnNpbXBsZUluUHViS2V5SGFzaD1TY3JpcHQucHJvdG90eXBlLnNpbXBsZUluSGFzaDtTY3JpcHQucHJvdG90eXBlLndyaXRlT3A9ZnVuY3Rpb24ob3Bjb2RlKXt0aGlzLmJ1ZmZlci5wdXNoKG9wY29kZSk7dGhpcy5jaHVua3MucHVzaChvcGNvZGUpfTtTY3JpcHQucHJvdG90eXBlLndyaXRlQnl0ZXM9ZnVuY3Rpb24oZGF0YSl7aWYoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKXtkYXRhPUFycmF5LnByb3RvdHlwZS5tYXAuYmluZChkYXRhLGZ1bmN0aW9uKHgpe3JldHVybiB4fSkoKX1pZihkYXRhLmxlbmd0aDxPcGNvZGUubWFwLk9QX1BVU0hEQVRBMSl7dGhpcy5idWZmZXIucHVzaChkYXRhLmxlbmd0aCl9ZWxzZSBpZihkYXRhLmxlbmd0aDw9MjU1KXt0aGlzLmJ1ZmZlci5wdXNoKE9wY29kZS5tYXAuT1BfUFVTSERBVEExKTt0aGlzLmJ1ZmZlci5wdXNoKGRhdGEubGVuZ3RoKX1lbHNlIGlmKGRhdGEubGVuZ3RoPD02NTUzNSl7dGhpcy5idWZmZXIucHVzaChPcGNvZGUubWFwLk9QX1BVU0hEQVRBMik7dGhpcy5idWZmZXIucHVzaChkYXRhLmxlbmd0aCYyNTUpO3RoaXMuYnVmZmVyLnB1c2goZGF0YS5sZW5ndGg+Pj44JjI1NSl9ZWxzZXt0aGlzLmJ1ZmZlci5wdXNoKE9wY29kZS5tYXAuT1BfUFVTSERBVEE0KTt0aGlzLmJ1ZmZlci5wdXNoKGRhdGEubGVuZ3RoJjI1NSk7dGhpcy5idWZmZXIucHVzaChkYXRhLmxlbmd0aD4+PjgmMjU1KTt0aGlzLmJ1ZmZlci5wdXNoKGRhdGEubGVuZ3RoPj4+MTYmMjU1KTt0aGlzLmJ1ZmZlci5wdXNoKGRhdGEubGVuZ3RoPj4+MjQmMjU1KX10aGlzLmJ1ZmZlcj10aGlzLmJ1ZmZlci5jb25jYXQoZGF0YSk7dGhpcy5jaHVua3MucHVzaChkYXRhKX07U2NyaXB0LmNyZWF0ZU91dHB1dFNjcmlwdD1mdW5jdGlvbihhZGRyZXNzKXt2YXIgc2NyaXB0PW5ldyBTY3JpcHQ7YWRkcmVzcz1uZXcgQWRkcmVzcyhhZGRyZXNzKTtpZihhZGRyZXNzLnZlcnNpb249PW5ldHdvcmsubWFpbm5ldC5wMnNoVmVyc2lvbnx8YWRkcmVzcy52ZXJzaW9uPT1uZXR3b3JrLnRlc3RuZXQucDJzaFZlcnNpb24pe3NjcmlwdC53cml0ZU9wKE9wY29kZS5tYXAuT1BfSEFTSDE2MCk7c2NyaXB0LndyaXRlQnl0ZXMoYWRkcmVzcy5oYXNoKTtzY3JpcHQud3JpdGVPcChPcGNvZGUubWFwLk9QX0VRVUFMKX1lbHNle3NjcmlwdC53cml0ZU9wKE9wY29kZS5tYXAuT1BfRFVQKTtzY3JpcHQud3JpdGVPcChPcGNvZGUubWFwLk9QX0hBU0gxNjApO3NjcmlwdC53cml0ZUJ5dGVzKGFkZHJlc3MuaGFzaCk7c2NyaXB0LndyaXRlT3AoT3Bjb2RlLm1hcC5PUF9FUVVBTFZFUklGWSk7c2NyaXB0LndyaXRlT3AoT3Bjb2RlLm1hcC5PUF9DSEVDS1NJRyl9cmV0dXJuIHNjcmlwdH07U2NyaXB0LnByb3RvdHlwZS5leHRyYWN0UHVia2V5cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNodW5rcy5maWx0ZXIoZnVuY3Rpb24oY2h1bmspe3JldHVybiBjaHVua1swXT09NCYmY2h1bmsubGVuZ3RoPT02NXx8Y2h1bmtbMF08NCYmY2h1bmsubGVuZ3RoPT0zM30pfTtTY3JpcHQuY3JlYXRlTXVsdGlTaWdPdXRwdXRTY3JpcHQ9ZnVuY3Rpb24obSxwdWJrZXlzKXt2YXIgc2NyaXB0PW5ldyBTY3JpcHQ7cHVia2V5cz1wdWJrZXlzLnNvcnQoKTtzY3JpcHQud3JpdGVPcChPcGNvZGUubWFwLk9QXzErbS0xKTtmb3IodmFyIGk9MDtpPHB1YmtleXMubGVuZ3RoOysraSl7c2NyaXB0LndyaXRlQnl0ZXMocHVia2V5c1tpXSl9c2NyaXB0LndyaXRlT3AoT3Bjb2RlLm1hcC5PUF8xK3B1YmtleXMubGVuZ3RoLTEpO3NjcmlwdC53cml0ZU9wKE9wY29kZS5tYXAuT1BfQ0hFQ0tNVUxUSVNJRyk7cmV0dXJuIHNjcmlwdH07U2NyaXB0LmNyZWF0ZUlucHV0U2NyaXB0PWZ1bmN0aW9uKHNpZ25hdHVyZSxwdWJLZXkpe3ZhciBzY3JpcHQ9bmV3IFNjcmlwdDtzY3JpcHQud3JpdGVCeXRlcyhzaWduYXR1cmUpO3NjcmlwdC53cml0ZUJ5dGVzKHB1YktleSk7cmV0dXJuIHNjcmlwdH07U2NyaXB0LmNyZWF0ZU11bHRpU2lnSW5wdXRTY3JpcHQ9ZnVuY3Rpb24oc2lnbmF0dXJlcyxzY3JpcHQpe3NjcmlwdD1uZXcgU2NyaXB0KHNjcmlwdCk7dmFyIGs9c2NyaXB0LmNodW5rc1swXVswXTtpZihzaWduYXR1cmVzLmxlbmd0aDxrKXJldHVybiBmYWxzZTt2YXIgaW5TY3JpcHQ9bmV3IFNjcmlwdDtpblNjcmlwdC53cml0ZU9wKE9wY29kZS5tYXAuT1BfMCk7c2lnbmF0dXJlcy5tYXAoZnVuY3Rpb24oc2lnKXtpblNjcmlwdC53cml0ZUJ5dGVzKHNpZyl9KTtpblNjcmlwdC53cml0ZUJ5dGVzKHNjcmlwdC5idWZmZXIpO3JldHVybiBpblNjcmlwdH07U2NyaXB0LnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgU2NyaXB0KHRoaXMuYnVmZmVyKX07bW9kdWxlLmV4cG9ydHM9U2NyaXB0fSkuY2FsbCh0aGlzLF9kZXJlcV8oXCJidWZmZXJcIikuQnVmZmVyKX0se1wiLi9hZGRyZXNzXCI6NTQsXCIuL2NvbnZlcnRcIjo1NyxcIi4vbmV0d29ya1wiOjY2LFwiLi9vcGNvZGVcIjo2NyxcIi4vdXRpbFwiOjcwLGJ1ZmZlcjo1fV0sNjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBCaWdJbnRlZ2VyPV9kZXJlcV8oXCIuL2pzYm4vanNiblwiKTt2YXIgU2NyaXB0PV9kZXJlcV8oXCIuL3NjcmlwdFwiKTt2YXIgdXRpbD1fZGVyZXFfKFwiLi91dGlsXCIpO3ZhciBjb252ZXJ0PV9kZXJlcV8oXCIuL2NvbnZlcnRcIik7dmFyIEVDS2V5PV9kZXJlcV8oXCIuL2Vja2V5XCIpLkVDS2V5O3ZhciBFQ0RTQT1fZGVyZXFfKFwiLi9lY2RzYVwiKTt2YXIgQWRkcmVzcz1fZGVyZXFfKFwiLi9hZGRyZXNzXCIpO3ZhciBTSEEyNTY9X2RlcmVxXyhcImNyeXB0by1qcy9zaGEyNTZcIik7dmFyIFRyYW5zYWN0aW9uPWZ1bmN0aW9uKGRvYyl7aWYoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pKXtyZXR1cm4gbmV3IFRyYW5zYWN0aW9uKGRvYyl9dGhpcy52ZXJzaW9uPTE7dGhpcy5sb2NrdGltZT0wO3RoaXMuaW5zPVtdO3RoaXMub3V0cz1bXTt0aGlzLmRlZmF1bHRTZXF1ZW5jZT1bMjU1LDI1NSwyNTUsMjU1XTtpZihkb2Mpe2lmKHR5cGVvZiBkb2M9PVwic3RyaW5nXCJ8fEFycmF5LmlzQXJyYXkoZG9jKSl7ZG9jPVRyYW5zYWN0aW9uLmRlc2VyaWFsaXplKGRvYyl9aWYoZG9jLmhhc2gpdGhpcy5oYXNoPWRvYy5oYXNoO2lmKGRvYy52ZXJzaW9uKXRoaXMudmVyc2lvbj1kb2MudmVyc2lvbjtpZihkb2MubG9ja3RpbWUpdGhpcy5sb2NrdGltZT1kb2MubG9ja3RpbWU7aWYoZG9jLmlucyYmZG9jLmlucy5sZW5ndGgpe2RvYy5pbnMuZm9yRWFjaChmdW5jdGlvbihpbnB1dCl7dGhpcy5hZGRJbnB1dChuZXcgVHJhbnNhY3Rpb25JbihpbnB1dCkpfSx0aGlzKX1pZihkb2Mub3V0cyYmZG9jLm91dHMubGVuZ3RoKXtkb2Mub3V0cy5mb3JFYWNoKGZ1bmN0aW9uKG91dHB1dCl7dGhpcy5hZGRPdXRwdXQobmV3IFRyYW5zYWN0aW9uT3V0KG91dHB1dCkpfSx0aGlzKX10aGlzLmhhc2g9dGhpcy5oYXNofHx0aGlzLmdldEhhc2goKX19O1RyYW5zYWN0aW9uLnByb3RvdHlwZS5hZGRJbnB1dD1mdW5jdGlvbih0eCxvdXRJbmRleCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBUcmFuc2FjdGlvbkluKXt0aGlzLmlucy5wdXNoKGFyZ3VtZW50c1swXSl9ZWxzZSBpZihhcmd1bWVudHNbMF0ubGVuZ3RoPjY1KXt2YXIgYXJncz1hcmd1bWVudHNbMF0uc3BsaXQoXCI6XCIpO3JldHVybiB0aGlzLmFkZElucHV0KGFyZ3NbMF0sYXJnc1sxXSl9ZWxzZXt2YXIgaGFzaD10eXBlb2YgdHg9PT1cInN0cmluZ1wiP3R4OnR4Lmhhc2g7aGFzaD1BcnJheS5pc0FycmF5KGhhc2gpP2NvbnZlcnQuYnl0ZXNUb0hleChoYXNoKTpoYXNoO3RoaXMuaW5zLnB1c2gobmV3IFRyYW5zYWN0aW9uSW4oe291dHBvaW50OntoYXNoOmhhc2gsaW5kZXg6b3V0SW5kZXh9LHNjcmlwdDpuZXcgU2NyaXB0LHNlcXVlbmNlOnRoaXMuZGVmYXVsdFNlcXVlbmNlfSkpfX07VHJhbnNhY3Rpb24ucHJvdG90eXBlLmFkZE91dHB1dD1mdW5jdGlvbihhZGRyZXNzLHZhbHVlKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFRyYW5zYWN0aW9uT3V0KXt0aGlzLm91dHMucHVzaChhcmd1bWVudHNbMF0pO3JldHVybn1pZihhcmd1bWVudHNbMF0uaW5kZXhPZihcIjpcIik+PTApe3ZhciBhcmdzPWFyZ3VtZW50c1swXS5zcGxpdChcIjpcIik7YWRkcmVzcz1hcmdzWzBdO3ZhbHVlPXBhcnNlSW50KGFyZ3NbMV0pfXRoaXMub3V0cy5wdXNoKG5ldyBUcmFuc2FjdGlvbk91dCh7dmFsdWU6dmFsdWUsc2NyaXB0OlNjcmlwdC5jcmVhdGVPdXRwdXRTY3JpcHQoYWRkcmVzcyl9KSl9O1RyYW5zYWN0aW9uLnByb3RvdHlwZS5zZXJpYWxpemU9ZnVuY3Rpb24oKXt2YXIgYnVmZmVyPVtdO2J1ZmZlcj1idWZmZXIuY29uY2F0KGNvbnZlcnQubnVtVG9CeXRlcyhwYXJzZUludCh0aGlzLnZlcnNpb24pLDQpKTtidWZmZXI9YnVmZmVyLmNvbmNhdChjb252ZXJ0Lm51bVRvVmFySW50KHRoaXMuaW5zLmxlbmd0aCkpO3RoaXMuaW5zLmZvckVhY2goZnVuY3Rpb24odHhpbil7YnVmZmVyPWJ1ZmZlci5jb25jYXQoY29udmVydC5oZXhUb0J5dGVzKHR4aW4ub3V0cG9pbnQuaGFzaCkucmV2ZXJzZSgpKTtidWZmZXI9YnVmZmVyLmNvbmNhdChjb252ZXJ0Lm51bVRvQnl0ZXMocGFyc2VJbnQodHhpbi5vdXRwb2ludC5pbmRleCksNCkpO3ZhciBzY3JpcHRCeXRlcz10eGluLnNjcmlwdC5idWZmZXI7YnVmZmVyPWJ1ZmZlci5jb25jYXQoY29udmVydC5udW1Ub1ZhckludChzY3JpcHRCeXRlcy5sZW5ndGgpKTtidWZmZXI9YnVmZmVyLmNvbmNhdChzY3JpcHRCeXRlcyk7YnVmZmVyPWJ1ZmZlci5jb25jYXQodHhpbi5zZXF1ZW5jZSl9KTtidWZmZXI9YnVmZmVyLmNvbmNhdChjb252ZXJ0Lm51bVRvVmFySW50KHRoaXMub3V0cy5sZW5ndGgpKTt0aGlzLm91dHMuZm9yRWFjaChmdW5jdGlvbih0eG91dCl7YnVmZmVyPWJ1ZmZlci5jb25jYXQoY29udmVydC5udW1Ub0J5dGVzKHR4b3V0LnZhbHVlLDgpKTt2YXIgc2NyaXB0Qnl0ZXM9dHhvdXQuc2NyaXB0LmJ1ZmZlcjtidWZmZXI9YnVmZmVyLmNvbmNhdChjb252ZXJ0Lm51bVRvVmFySW50KHNjcmlwdEJ5dGVzLmxlbmd0aCkpO2J1ZmZlcj1idWZmZXIuY29uY2F0KHNjcmlwdEJ5dGVzKX0pO2J1ZmZlcj1idWZmZXIuY29uY2F0KGNvbnZlcnQubnVtVG9CeXRlcyhwYXJzZUludCh0aGlzLmxvY2t0aW1lKSw0KSk7cmV0dXJuIGJ1ZmZlcn07VHJhbnNhY3Rpb24ucHJvdG90eXBlLnNlcmlhbGl6ZUhleD1mdW5jdGlvbigpe3JldHVybiBjb252ZXJ0LmJ5dGVzVG9IZXgodGhpcy5zZXJpYWxpemUoKSl9O3ZhciBTSUdIQVNIX0FMTD0xO3ZhciBTSUdIQVNIX05PTkU9Mjt2YXIgU0lHSEFTSF9TSU5HTEU9Mzt2YXIgU0lHSEFTSF9BTllPTkVDQU5QQVk9ODA7VHJhbnNhY3Rpb24ucHJvdG90eXBlLmhhc2hUcmFuc2FjdGlvbkZvclNpZ25hdHVyZT1mdW5jdGlvbihjb25uZWN0ZWRTY3JpcHQsaW5JbmRleCxoYXNoVHlwZSl7dmFyIHR4VG1wPXRoaXMuY2xvbmUoKTt0eFRtcC5pbnMuZm9yRWFjaChmdW5jdGlvbih0eGluKXt0eGluLnNjcmlwdD1uZXcgU2NyaXB0fSk7dHhUbXAuaW5zW2luSW5kZXhdLnNjcmlwdD1jb25uZWN0ZWRTY3JpcHQ7aWYoKGhhc2hUeXBlJjMxKT09U0lHSEFTSF9OT05FKXt0eFRtcC5vdXRzPVtdO3R4VG1wLmlucy5mb3JFYWNoKGZ1bmN0aW9uKHR4aW4saSl7aWYoaSE9aW5JbmRleCl7dHhUbXAuaW5zW2ldLnNlcXVlbmNlPTB9fSl9ZWxzZSBpZigoaGFzaFR5cGUmMzEpPT1TSUdIQVNIX1NJTkdMRSl7fWlmKGhhc2hUeXBlJlNJR0hBU0hfQU5ZT05FQ0FOUEFZKXt0eFRtcC5pbnM9W3R4VG1wLmluc1tpbkluZGV4XV19dmFyIGJ1ZmZlcj10eFRtcC5zZXJpYWxpemUoKTtidWZmZXI9YnVmZmVyLmNvbmNhdChjb252ZXJ0Lm51bVRvQnl0ZXMocGFyc2VJbnQoaGFzaFR5cGUpLDQpKTtidWZmZXI9Y29udmVydC5ieXRlc1RvV29yZEFycmF5KGJ1ZmZlcik7cmV0dXJuIGNvbnZlcnQud29yZEFycmF5VG9CeXRlcyhTSEEyNTYoU0hBMjU2KGJ1ZmZlcikpKX07VHJhbnNhY3Rpb24ucHJvdG90eXBlLmdldEhhc2g9ZnVuY3Rpb24oKXt2YXIgYnVmZmVyPWNvbnZlcnQuYnl0ZXNUb1dvcmRBcnJheSh0aGlzLnNlcmlhbGl6ZSgpKTtyZXR1cm4gY29udmVydC53b3JkQXJyYXlUb0J5dGVzKFNIQTI1NihTSEEyNTYoYnVmZmVyKSkpLnJldmVyc2UoKX07VHJhbnNhY3Rpb24ucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIG5ld1R4PW5ldyBUcmFuc2FjdGlvbjtuZXdUeC52ZXJzaW9uPXRoaXMudmVyc2lvbjtuZXdUeC5sb2NrdGltZT10aGlzLmxvY2t0aW1lO3RoaXMuaW5zLmZvckVhY2goZnVuY3Rpb24odHhpbil7bmV3VHguYWRkSW5wdXQodHhpbi5jbG9uZSgpKX0pO3RoaXMub3V0cy5mb3JFYWNoKGZ1bmN0aW9uKHR4b3V0KXtuZXdUeC5hZGRPdXRwdXQodHhvdXQuY2xvbmUoKSl9KTtyZXR1cm4gbmV3VHh9O1RyYW5zYWN0aW9uLmRlc2VyaWFsaXplPWZ1bmN0aW9uKGJ1ZmZlcil7aWYodHlwZW9mIGJ1ZmZlcj09XCJzdHJpbmdcIil7YnVmZmVyPWNvbnZlcnQuaGV4VG9CeXRlcyhidWZmZXIpfXZhciBwb3M9MDt2YXIgcmVhZEFzSW50PWZ1bmN0aW9uKGJ5dGVzKXtpZihieXRlcz09PTApcmV0dXJuIDA7cG9zKys7cmV0dXJuIGJ1ZmZlcltwb3MtMV0rcmVhZEFzSW50KGJ5dGVzLTEpKjI1Nn07dmFyIHJlYWRWYXJJbnQ9ZnVuY3Rpb24oKXt2YXIgYnl0ZXM9YnVmZmVyLnNsaWNlKHBvcyxwb3MrOSk7dmFyIHJlc3VsdD1jb252ZXJ0LnZhckludFRvTnVtKGJ5dGVzKTtwb3MrPXJlc3VsdC5ieXRlcy5sZW5ndGg7cmV0dXJuIHJlc3VsdC5udW1iZXJ9O3ZhciByZWFkQnl0ZXM9ZnVuY3Rpb24oYnl0ZXMpe3Bvcys9Ynl0ZXM7cmV0dXJuIGJ1ZmZlci5zbGljZShwb3MtYnl0ZXMscG9zKX07dmFyIHJlYWRWYXJTdHJpbmc9ZnVuY3Rpb24oKXt2YXIgc2l6ZT1yZWFkVmFySW50KCk7cmV0dXJuIHJlYWRCeXRlcyhzaXplKX07dmFyIG9iaj17aW5zOltdLG91dHM6W119O29iai52ZXJzaW9uPXJlYWRBc0ludCg0KTt2YXIgaW5zPXJlYWRWYXJJbnQoKTt2YXIgaTtmb3IoaT0wO2k8aW5zO2krKyl7b2JqLmlucy5wdXNoKHtvdXRwb2ludDp7aGFzaDpjb252ZXJ0LmJ5dGVzVG9IZXgocmVhZEJ5dGVzKDMyKS5yZXZlcnNlKCkpLGluZGV4OnJlYWRBc0ludCg0KX0sc2NyaXB0Om5ldyBTY3JpcHQocmVhZFZhclN0cmluZygpKSxzZXF1ZW5jZTpyZWFkQnl0ZXMoNCl9KX12YXIgb3V0cz1yZWFkVmFySW50KCk7Zm9yKGk9MDtpPG91dHM7aSsrKXtvYmoub3V0cy5wdXNoKHt2YWx1ZTpjb252ZXJ0LmJ5dGVzVG9OdW0ocmVhZEJ5dGVzKDgpKSxzY3JpcHQ6bmV3IFNjcmlwdChyZWFkVmFyU3RyaW5nKCkpfSl9b2JqLmxvY2t0aW1lPXJlYWRBc0ludCg0KTtyZXR1cm4gbmV3IFRyYW5zYWN0aW9uKG9iail9O1RyYW5zYWN0aW9uLnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKGluZGV4LGtleSx0eXBlKXt0eXBlPXR5cGV8fFNJR0hBU0hfQUxMO2tleT1uZXcgRUNLZXkoa2V5KTt2YXIgcHViPWtleS5nZXRQdWIoKS50b0J5dGVzKCksaGFzaDE2MD11dGlsLnNoYTI1NnJpcGUxNjAocHViKSxzY3JpcHQ9U2NyaXB0LmNyZWF0ZU91dHB1dFNjcmlwdChuZXcgQWRkcmVzcyhoYXNoMTYwKSksaGFzaD10aGlzLmhhc2hUcmFuc2FjdGlvbkZvclNpZ25hdHVyZShzY3JpcHQsaW5kZXgsdHlwZSksc2lnPWtleS5zaWduKGhhc2gpLmNvbmNhdChbdHlwZV0pO3RoaXMuaW5zW2luZGV4XS5zY3JpcHQ9U2NyaXB0LmNyZWF0ZUlucHV0U2NyaXB0KHNpZyxwdWIpfTtUcmFuc2FjdGlvbi5wcm90b3R5cGUuc2lnbldpdGhLZXlzPWZ1bmN0aW9uKGtleXMsb3V0cHV0cyx0eXBlKXt0eXBlPXR5cGV8fFNJR0hBU0hfQUxMO3ZhciBhZGRyZGF0YT1rZXlzLm1hcChmdW5jdGlvbihrZXkpe2tleT1uZXcgRUNLZXkoa2V5KTtyZXR1cm57a2V5OmtleSxhZGRyZXNzOmtleS5nZXRBZGRyZXNzKCkudG9TdHJpbmcoKX19KTt2YXIgaG1hcD17fTtvdXRwdXRzLmZvckVhY2goZnVuY3Rpb24obyl7aG1hcFtvLm91dHB1dF09b30pO2Zvcih2YXIgaT0wO2k8dGhpcy5pbnMubGVuZ3RoO2krKyl7dmFyIG91dHBvaW50PXRoaXMuaW5zW2ldLm91dHBvaW50Lmhhc2grXCI6XCIrdGhpcy5pbnNbaV0ub3V0cG9pbnQuaW5kZXg7dmFyIGhpc3RJdGVtPWhtYXBbb3V0cG9pbnRdO2lmKCFoaXN0SXRlbSljb250aW51ZTt2YXIgdGhpc0lucHV0QWRkcmRhdGE9YWRkcmRhdGEuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBhLmFkZHJlc3M9PWhpc3RJdGVtLmFkZHJlc3N9KTtpZih0aGlzSW5wdXRBZGRyZGF0YS5sZW5ndGg9PT0wKWNvbnRpbnVlO3RoaXMuc2lnbihpLHRoaXNJbnB1dEFkZHJkYXRhWzBdLmtleSl9fTtUcmFuc2FjdGlvbi5wcm90b3R5cGUucDJzaHNpZ249ZnVuY3Rpb24oaW5kZXgsc2NyaXB0LGtleSx0eXBlKXtzY3JpcHQ9bmV3IFNjcmlwdChzY3JpcHQpO2tleT1uZXcgRUNLZXkoa2V5KTt0eXBlPXR5cGV8fFNJR0hBU0hfQUxMO3ZhciBoYXNoPXRoaXMuaGFzaFRyYW5zYWN0aW9uRm9yU2lnbmF0dXJlKHNjcmlwdCxpbmRleCx0eXBlKSxzaWc9a2V5LnNpZ24oaGFzaCkuY29uY2F0KFt0eXBlXSk7cmV0dXJuIHNpZ307VHJhbnNhY3Rpb24ucHJvdG90eXBlLm11bHRpc2lnbj1UcmFuc2FjdGlvbi5wcm90b3R5cGUucDJzaHNpZ247VHJhbnNhY3Rpb24ucHJvdG90eXBlLmFwcGx5TXVsdGlzaWdzPWZ1bmN0aW9uKGluZGV4LHNjcmlwdCxzaWdzKXt0aGlzLmluc1tpbmRleF0uc2NyaXB0PVNjcmlwdC5jcmVhdGVNdWx0aVNpZ0lucHV0U2NyaXB0KHNpZ3Msc2NyaXB0KX07VHJhbnNhY3Rpb24ucHJvdG90eXBlLnZhbGlkYXRlU2lnPWZ1bmN0aW9uKGluZGV4LHNjcmlwdCxzaWcscHViKXtzY3JpcHQ9bmV3IFNjcmlwdChzY3JpcHQpO3ZhciBoYXNoPXRoaXMuaGFzaFRyYW5zYWN0aW9uRm9yU2lnbmF0dXJlKHNjcmlwdCxpbmRleCwxKTtyZXR1cm4gRUNEU0EudmVyaWZ5KGhhc2gsY29udmVydC5jb2VyY2VUb0J5dGVzKHNpZyksY29udmVydC5jb2VyY2VUb0J5dGVzKHB1YikpfTtUcmFuc2FjdGlvbi5mZWVQZXJLYj0yZTQ7VHJhbnNhY3Rpb24ucHJvdG90eXBlLmVzdGltYXRlRmVlPWZ1bmN0aW9uKGZlZVBlcktiKXt2YXIgdW5jb21wcmVzc2VkSW5TaXplPTE4MDt2YXIgb3V0U2l6ZT0zNDt2YXIgZml4ZWRQYWRkaW5nPTM0O2lmKGZlZVBlcktiPT11bmRlZmluZWQpZmVlUGVyS2I9VHJhbnNhY3Rpb24uZmVlUGVyS2I7dmFyIHNpemU9dGhpcy5pbnMubGVuZ3RoKnVuY29tcHJlc3NlZEluU2l6ZSt0aGlzLm91dHMubGVuZ3RoKm91dFNpemUrZml4ZWRQYWRkaW5nO3JldHVybiBmZWVQZXJLYipNYXRoLmNlaWwoc2l6ZS8xZTMpfTt2YXIgVHJhbnNhY3Rpb25Jbj1mdW5jdGlvbihkYXRhKXtpZih0eXBlb2YgZGF0YT09XCJzdHJpbmdcIil7dGhpcy5vdXRwb2ludD17aGFzaDpkYXRhLnNwbGl0KFwiOlwiKVswXSxpbmRleDpkYXRhLnNwbGl0KFwiOlwiKVsxXX19ZWxzZSBpZihkYXRhLm91dHBvaW50KXt0aGlzLm91dHBvaW50PWRhdGEub3V0cG9pbnR9ZWxzZXt0aGlzLm91dHBvaW50PXtoYXNoOmRhdGEuaGFzaCxpbmRleDpkYXRhLmluZGV4fX1pZihkYXRhLnNjcmlwdFNpZyl7dGhpcy5zY3JpcHQ9U2NyaXB0LmZyb21TY3JpcHRTaWcoZGF0YS5zY3JpcHRTaWcpfWVsc2UgaWYoZGF0YS5zY3JpcHQpe3RoaXMuc2NyaXB0PWRhdGEuc2NyaXB0fWVsc2V7dGhpcy5zY3JpcHQ9bmV3IFNjcmlwdChkYXRhLnNjcmlwdCl9dGhpcy5zZXF1ZW5jZT1kYXRhLnNlcXVlbmNlfHx0aGlzLmRlZmF1bHRTZXF1ZW5jZX07VHJhbnNhY3Rpb25Jbi5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW4oe291dHBvaW50OntoYXNoOnRoaXMub3V0cG9pbnQuaGFzaCxpbmRleDp0aGlzLm91dHBvaW50LmluZGV4fSxzY3JpcHQ6dGhpcy5zY3JpcHQuY2xvbmUoKSxzZXF1ZW5jZTp0aGlzLnNlcXVlbmNlfSl9O3ZhciBUcmFuc2FjdGlvbk91dD1mdW5jdGlvbihkYXRhKXt0aGlzLnNjcmlwdD1kYXRhLnNjcmlwdCBpbnN0YW5jZW9mIFNjcmlwdD9kYXRhLnNjcmlwdC5jbG9uZSgpOkFycmF5LmlzQXJyYXkoZGF0YS5zY3JpcHQpP25ldyBTY3JpcHQoZGF0YS5zY3JpcHQpOnR5cGVvZiBkYXRhLnNjcmlwdD09XCJzdHJpbmdcIj9uZXcgU2NyaXB0KGNvbnZlcnQuaGV4VG9CeXRlcyhkYXRhLnNjcmlwdCkpOmRhdGEuc2NyaXB0UHViS2V5P1NjcmlwdC5mcm9tU2NyaXB0U2lnKGRhdGEuc2NyaXB0UHViS2V5KTpkYXRhLmFkZHJlc3M/U2NyaXB0LmNyZWF0ZU91dHB1dFNjcmlwdChkYXRhLmFkZHJlc3MpOm5ldyBTY3JpcHQ7aWYodGhpcy5zY3JpcHQuYnVmZmVyLmxlbmd0aD4wKXRoaXMuYWRkcmVzcz10aGlzLnNjcmlwdC5nZXRUb0FkZHJlc3MoKTt0aGlzLnZhbHVlPUFycmF5LmlzQXJyYXkoZGF0YS52YWx1ZSk/Y29udmVydC5ieXRlc1RvTnVtKGRhdGEudmFsdWUpOlwic3RyaW5nXCI9PXR5cGVvZiBkYXRhLnZhbHVlP3BhcnNlSW50KGRhdGEudmFsdWUpOmRhdGEudmFsdWUgaW5zdGFuY2VvZiBCaWdJbnRlZ2VyP3BhcnNlSW50KGRhdGEudmFsdWUudG9TdHJpbmcoKSk6ZGF0YS52YWx1ZX07VHJhbnNhY3Rpb25PdXQucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIG5ld1R4b3V0PW5ldyBUcmFuc2FjdGlvbk91dCh7c2NyaXB0OnRoaXMuc2NyaXB0LmNsb25lKCksdmFsdWU6dGhpcy52YWx1ZX0pO3JldHVybiBuZXdUeG91dH07VHJhbnNhY3Rpb25PdXQucHJvdG90eXBlLnNjcmlwdFB1YktleT1mdW5jdGlvbigpe3JldHVybiBjb252ZXJ0LmJ5dGVzVG9IZXgodGhpcy5zY3JpcHQuYnVmZmVyKX07bW9kdWxlLmV4cG9ydHM9e1RyYW5zYWN0aW9uOlRyYW5zYWN0aW9uLFRyYW5zYWN0aW9uSW46VHJhbnNhY3Rpb25JbixUcmFuc2FjdGlvbk91dDpUcmFuc2FjdGlvbk91dH19LHtcIi4vYWRkcmVzc1wiOjU0LFwiLi9jb252ZXJ0XCI6NTcsXCIuL2VjZHNhXCI6NTgsXCIuL2Vja2V5XCI6NTksXCIuL2pzYm4vanNiblwiOjYzLFwiLi9zY3JpcHRcIjo2OCxcIi4vdXRpbFwiOjcwLFwiY3J5cHRvLWpzL3NoYTI1NlwiOjQ3fV0sNzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBjb252ZXJ0PV9kZXJlcV8oXCIuL2NvbnZlcnQuanNcIik7dmFyIENyeXB0bz1fZGVyZXFfKFwiY3J5cHRvLWpzXCIpO3ZhciBSSVBFTUQxNjA9Q3J5cHRvLlJJUEVNRDE2MDt2YXIgU0hBMjU2PUNyeXB0by5TSEEyNTY7ZXhwb3J0cy5zaGEyNTZyaXBlMTYwPWZ1bmN0aW9uKGRhdGEpe3ZhciB3b3JkQXJyYXk9UklQRU1EMTYwKFNIQTI1Nihjb252ZXJ0LmJ5dGVzVG9Xb3JkQXJyYXkoZGF0YSkpKTtyZXR1cm4gY29udmVydC53b3JkQXJyYXlUb0J5dGVzKHdvcmRBcnJheSl9O2V4cG9ydHMuZXJyb3I9ZnVuY3Rpb24obXNnKXt0aHJvdyBuZXcgRXJyb3IobXNnKX19LHtcIi4vY29udmVydC5qc1wiOjU3LFwiY3J5cHRvLWpzXCI6Mjd9XSw3MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHByb2Nlc3Mpe3ZhciBjb252ZXJ0PV9kZXJlcV8oXCIuL2NvbnZlcnRcIik7dmFyIFRyYW5zYWN0aW9uPV9kZXJlcV8oXCIuL3RyYW5zYWN0aW9uXCIpLlRyYW5zYWN0aW9uO3ZhciBIRE5vZGU9X2RlcmVxXyhcIi4vaGR3YWxsZXQuanNcIik7dmFyIHJuZz1fZGVyZXFfKFwic2VjdXJlLXJhbmRvbVwiKTtmdW5jdGlvbiBXYWxsZXQoc2VlZCxvcHRpb25zKXtpZighKHRoaXMgaW5zdGFuY2VvZiBXYWxsZXQpKXtyZXR1cm4gbmV3IFdhbGxldChzZWVkLG9wdGlvbnMpfXZhciBvcHRpb25zPW9wdGlvbnN8fHt9O3ZhciBuZXR3b3JrPW9wdGlvbnMubmV0d29ya3x8XCJtYWlubmV0XCI7dmFyIG1hc3RlcmtleT1udWxsO3ZhciBtZT10aGlzO3ZhciBhY2NvdW50WmVybz1udWxsO3ZhciBpbnRlcm5hbEFjY291bnQ9bnVsbDt2YXIgZXh0ZXJuYWxBY2NvdW50PW51bGw7dGhpcy5hZGRyZXNzZXM9W107dGhpcy5jaGFuZ2VBZGRyZXNzZXM9W107dGhpcy5vdXRwdXRzPXt9O3RoaXMubmV3TWFzdGVyS2V5PWZ1bmN0aW9uKHNlZWQsbmV0d29yayl7aWYoIXNlZWQpc2VlZD1ybmcoMzIse2FycmF5OnRydWV9KTttYXN0ZXJrZXk9bmV3IEhETm9kZShzZWVkLG5ldHdvcmspO2FjY291bnRaZXJvPW1hc3RlcmtleS5kZXJpdmVQcml2YXRlKDApO2V4dGVybmFsQWNjb3VudD1hY2NvdW50WmVyby5kZXJpdmUoMCk7aW50ZXJuYWxBY2NvdW50PWFjY291bnRaZXJvLmRlcml2ZSgxKTttZS5hZGRyZXNzZXM9W107bWUuY2hhbmdlQWRkcmVzc2VzPVtdO21lLm91dHB1dHM9e319O3RoaXMubmV3TWFzdGVyS2V5KHNlZWQsbmV0d29yayk7dGhpcy5nZW5lcmF0ZUFkZHJlc3M9ZnVuY3Rpb24oKXt2YXIga2V5PWV4dGVybmFsQWNjb3VudC5kZXJpdmUodGhpcy5hZGRyZXNzZXMubGVuZ3RoKTt0aGlzLmFkZHJlc3Nlcy5wdXNoKGtleS5nZXRBZGRyZXNzKCkudG9TdHJpbmcoKSk7cmV0dXJuIHRoaXMuYWRkcmVzc2VzW3RoaXMuYWRkcmVzc2VzLmxlbmd0aC0xXX07dGhpcy5nZW5lcmF0ZUNoYW5nZUFkZHJlc3M9ZnVuY3Rpb24oKXt2YXIga2V5PWludGVybmFsQWNjb3VudC5kZXJpdmUodGhpcy5jaGFuZ2VBZGRyZXNzZXMubGVuZ3RoKTt0aGlzLmNoYW5nZUFkZHJlc3Nlcy5wdXNoKGtleS5nZXRBZGRyZXNzKCkudG9TdHJpbmcoKSk7cmV0dXJuIHRoaXMuY2hhbmdlQWRkcmVzc2VzW3RoaXMuY2hhbmdlQWRkcmVzc2VzLmxlbmd0aC0xXX07dGhpcy5nZXRCYWxhbmNlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0VW5zcGVudE91dHB1dHMoKS5yZWR1Y2UoZnVuY3Rpb24obWVtbyxvdXRwdXQpe3JldHVybiBtZW1vK291dHB1dC52YWx1ZX0sMCl9O3RoaXMuZ2V0VW5zcGVudE91dHB1dHM9ZnVuY3Rpb24oKXt2YXIgdXR4bz1bXTtmb3IodmFyIGtleSBpbiB0aGlzLm91dHB1dHMpe3ZhciBvdXRwdXQ9dGhpcy5vdXRwdXRzW2tleV07aWYoIW91dHB1dC5zcGVuZCl1dHhvLnB1c2gob3V0cHV0VG9VbnNwZW50T3V0cHV0KG91dHB1dCkpfXJldHVybiB1dHhvfTt0aGlzLnNldFVuc3BlbnRPdXRwdXRzPWZ1bmN0aW9uKHV0eG8pe3ZhciBvdXRwdXRzPXt9O3V0eG8uZm9yRWFjaChmdW5jdGlvbih1byl7dmFsaWRhdGVVbnNwZW50T3V0cHV0KHVvKTt2YXIgbz11bnNwZW50T3V0cHV0VG9PdXRwdXQodW8pO291dHB1dHNbby5yZWNlaXZlXT1vfSk7dGhpcy5vdXRwdXRzPW91dHB1dHN9O3RoaXMuc2V0VW5zcGVudE91dHB1dHNBc3luYz1mdW5jdGlvbih1dHhvLGNhbGxiYWNrKXt2YXIgZXJyb3I9bnVsbDt0cnl7dGhpcy5zZXRVbnNwZW50T3V0cHV0cyh1dHhvKX1jYXRjaChlcnIpe2Vycm9yPWVycn1maW5hbGx5e3Byb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKXtjYWxsYmFjayhlcnJvcil9KX19O2Z1bmN0aW9uIG91dHB1dFRvVW5zcGVudE91dHB1dChvdXRwdXQpe3ZhciBoYXNoQW5kSW5kZXg9b3V0cHV0LnJlY2VpdmUuc3BsaXQoXCI6XCIpO3JldHVybntoYXNoOmhhc2hBbmRJbmRleFswXSxoYXNoTGl0dGxlRW5kaWFuOmNvbnZlcnQucmV2ZXJzZUVuZGlhbihoYXNoQW5kSW5kZXhbMF0pLG91dHB1dEluZGV4OnBhcnNlSW50KGhhc2hBbmRJbmRleFsxXSksYWRkcmVzczpvdXRwdXQuYWRkcmVzcyx2YWx1ZTpvdXRwdXQudmFsdWV9fWZ1bmN0aW9uIHVuc3BlbnRPdXRwdXRUb091dHB1dChvKXt2YXIgaGFzaD1vLmhhc2h8fGNvbnZlcnQucmV2ZXJzZUVuZGlhbihvLmhhc2hMaXR0bGVFbmRpYW4pO3ZhciBrZXk9aGFzaCtcIjpcIitvLm91dHB1dEluZGV4O3JldHVybntyZWNlaXZlOmtleSxhZGRyZXNzOm8uYWRkcmVzcyx2YWx1ZTpvLnZhbHVlfX1mdW5jdGlvbiB2YWxpZGF0ZVVuc3BlbnRPdXRwdXQodW8pe3ZhciBtaXNzaW5nRmllbGQ7aWYoaXNOdWxsT3JVbmRlZmluZWQodW8uaGFzaCkmJmlzTnVsbE9yVW5kZWZpbmVkKHVvLmhhc2hMaXR0bGVFbmRpYW4pKXttaXNzaW5nRmllbGQ9XCJoYXNoKG9yIGhhc2hMaXR0bGVFbmRpYW4pXCJ9dmFyIHJlcXVpcmVkS2V5cz1bXCJvdXRwdXRJbmRleFwiLFwiYWRkcmVzc1wiLFwidmFsdWVcIl07cmVxdWlyZWRLZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KXtpZihpc051bGxPclVuZGVmaW5lZCh1b1trZXldKSl7bWlzc2luZ0ZpZWxkPWtleX19KTtpZihtaXNzaW5nRmllbGQpe3ZhciBtZXNzYWdlPVtcIkludmFsaWQgdW5zcGVudCBvdXRwdXQ6IGtleVwiLG1pc3NpbmdGaWVsZCxcImlzIG1pc3NpbmcuXCIsXCJBIHZhbGlkIHVuc3BlbnQgb3V0cHV0IG11c3QgY29udGFpblwiXTttZXNzYWdlLnB1c2gocmVxdWlyZWRLZXlzLmpvaW4oXCIsIFwiKSk7bWVzc2FnZS5wdXNoKFwiYW5kIGhhc2gob3IgaGFzaExpdHRsZUVuZGlhbilcIik7dGhyb3cgbmV3IEVycm9yKG1lc3NhZ2Uuam9pbihcIiBcIikpfX1mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSl7cmV0dXJuIHZhbHVlPT11bmRlZmluZWR9dGhpcy5wcm9jZXNzVHg9ZnVuY3Rpb24odHgpe3ZhciB0eGhhc2g9Y29udmVydC5ieXRlc1RvSGV4KHR4LmdldEhhc2goKSk7dHgub3V0cy5mb3JFYWNoKGZ1bmN0aW9uKHR4T3V0LGkpe3ZhciBhZGRyZXNzPXR4T3V0LmFkZHJlc3MudG9TdHJpbmcoKTtpZihpc015QWRkcmVzcyhhZGRyZXNzKSl7dmFyIG91dHB1dD10eGhhc2grXCI6XCIraTttZS5vdXRwdXRzW291dHB1dF09e3JlY2VpdmU6b3V0cHV0LHZhbHVlOnR4T3V0LnZhbHVlLGFkZHJlc3M6YWRkcmVzc319fSk7dHguaW5zLmZvckVhY2goZnVuY3Rpb24odHhJbixpKXt2YXIgb3A9dHhJbi5vdXRwb2ludDt2YXIgbz1tZS5vdXRwdXRzW29wLmhhc2grXCI6XCIrb3AuaW5kZXhdO2lmKG8pe28uc3BlbmQ9dHhoYXNoK1wiOlwiK2l9fSl9O3RoaXMuY3JlYXRlVHg9ZnVuY3Rpb24odG8sdmFsdWUsZml4ZWRGZWUpe2NoZWNrRHVzdCh2YWx1ZSk7dmFyIHR4PW5ldyBUcmFuc2FjdGlvbjt0eC5hZGRPdXRwdXQodG8sdmFsdWUpO3ZhciB1dHhvPWdldENhbmRpZGF0ZU91dHB1dHModmFsdWUpO3ZhciB0b3RhbEluVmFsdWU9MDtmb3IodmFyIGk9MDtpPHV0eG8ubGVuZ3RoO2krKyl7dmFyIG91dHB1dD11dHhvW2ldO3R4LmFkZElucHV0KG91dHB1dC5yZWNlaXZlKTt0b3RhbEluVmFsdWUrPW91dHB1dC52YWx1ZTtpZih0b3RhbEluVmFsdWU8dmFsdWUpY29udGludWU7dmFyIGZlZT1maXhlZEZlZT09dW5kZWZpbmVkP2VzdGltYXRlRmVlUGFkQ2hhbmdlT3V0cHV0KHR4KTpmaXhlZEZlZTtpZih0b3RhbEluVmFsdWU8dmFsdWUrZmVlKWNvbnRpbnVlO3ZhciBjaGFuZ2U9dG90YWxJblZhbHVlLXZhbHVlLWZlZTtpZihjaGFuZ2U+MCYmIWlzRHVzdChjaGFuZ2UpKXt0eC5hZGRPdXRwdXQoZ2V0Q2hhbmdlQWRkcmVzcygpLGNoYW5nZSl9YnJlYWt9Y2hlY2tJbnN1ZmZpY2llbnRGdW5kKHRvdGFsSW5WYWx1ZSx2YWx1ZSxmZWUpO3RoaXMuc2lnbih0eCk7cmV0dXJuIHR4fTt0aGlzLmNyZWF0ZVR4QXN5bmM9ZnVuY3Rpb24odG8sdmFsdWUsZml4ZWRGZWUsY2FsbGJhY2spe2lmKGZpeGVkRmVlIGluc3RhbmNlb2YgRnVuY3Rpb24pe2NhbGxiYWNrPWZpeGVkRmVlO2ZpeGVkRmVlPXVuZGVmaW5lZH12YXIgdHg9bnVsbDt2YXIgZXJyb3I9bnVsbDt0cnl7dHg9dGhpcy5jcmVhdGVUeCh0byx2YWx1ZSxmaXhlZEZlZSl9Y2F0Y2goZXJyKXtlcnJvcj1lcnJ9ZmluYWxseXtwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCl7Y2FsbGJhY2soZXJyb3IsdHgpfSl9fTt0aGlzLmR1c3RUaHJlc2hvbGQ9NTQzMDtmdW5jdGlvbiBpc0R1c3QoYW1vdW50KXtyZXR1cm4gYW1vdW50PD1tZS5kdXN0VGhyZXNob2xkfWZ1bmN0aW9uIGNoZWNrRHVzdCh2YWx1ZSl7aWYoaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpfHxpc0R1c3QodmFsdWUpKXt0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBtdXN0IGJlIGFib3ZlIGR1c3QgdGhyZXNob2xkXCIpfX1mdW5jdGlvbiBnZXRDYW5kaWRhdGVPdXRwdXRzKHZhbHVlKXt2YXIgdW5zcGVudD1bXTtmb3IodmFyIGtleSBpbiBtZS5vdXRwdXRzKXt2YXIgb3V0cHV0PW1lLm91dHB1dHNba2V5XTtpZighb3V0cHV0LnNwZW5kKXVuc3BlbnQucHVzaChvdXRwdXQpfXZhciBzb3J0QnlWYWx1ZURlc2M9dW5zcGVudC5zb3J0KGZ1bmN0aW9uKG8xLG8yKXtyZXR1cm4gbzIudmFsdWUtbzEudmFsdWV9KTtyZXR1cm4gc29ydEJ5VmFsdWVEZXNjfWZ1bmN0aW9uIGVzdGltYXRlRmVlUGFkQ2hhbmdlT3V0cHV0KHR4KXt2YXIgdG1wVHg9dHguY2xvbmUoKTt0bXBUeC5hZGRPdXRwdXQoZ2V0Q2hhbmdlQWRkcmVzcygpLDApO3JldHVybiB0bXBUeC5lc3RpbWF0ZUZlZSgpfWZ1bmN0aW9uIGdldENoYW5nZUFkZHJlc3MoKXtpZihtZS5jaGFuZ2VBZGRyZXNzZXMubGVuZ3RoPT09MCltZS5nZW5lcmF0ZUNoYW5nZUFkZHJlc3MoKTtyZXR1cm4gbWUuY2hhbmdlQWRkcmVzc2VzW21lLmNoYW5nZUFkZHJlc3Nlcy5sZW5ndGgtMV19ZnVuY3Rpb24gY2hlY2tJbnN1ZmZpY2llbnRGdW5kKHRvdGFsSW5WYWx1ZSx2YWx1ZSxmZWUpe2lmKHRvdGFsSW5WYWx1ZTx2YWx1ZStmZWUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCBlbm91Z2ggbW9uZXkgdG8gc2VuZCBmdW5kcyBpbmNsdWRpbmcgdHJhbnNhY3Rpb24gZmVlLiBIYXZlOiBcIit0b3RhbEluVmFsdWUrXCIsIG5lZWRlZDogXCIrKHZhbHVlK2ZlZSkpfX10aGlzLnNpZ249ZnVuY3Rpb24odHgpe3R4Lmlucy5mb3JFYWNoKGZ1bmN0aW9uKGlucCxpKXt2YXIgb3V0cHV0PW1lLm91dHB1dHNbaW5wLm91dHBvaW50Lmhhc2grXCI6XCIraW5wLm91dHBvaW50LmluZGV4XTtpZihvdXRwdXQpe3R4LnNpZ24oaSxtZS5nZXRQcml2YXRlS2V5Rm9yQWRkcmVzcyhvdXRwdXQuYWRkcmVzcykpfX0pO3JldHVybiB0eH07dGhpcy5nZXRNYXN0ZXJLZXk9ZnVuY3Rpb24oKXtyZXR1cm4gbWFzdGVya2V5fTt0aGlzLmdldEFjY291bnRaZXJvPWZ1bmN0aW9uKCl7cmV0dXJuIGFjY291bnRaZXJvfTt0aGlzLmdldEludGVybmFsQWNjb3VudD1mdW5jdGlvbigpe3JldHVybiBpbnRlcm5hbEFjY291bnR9O3RoaXMuZ2V0RXh0ZXJuYWxBY2NvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIGV4dGVybmFsQWNjb3VudH07dGhpcy5nZXRQcml2YXRlS2V5PWZ1bmN0aW9uKGluZGV4KXtyZXR1cm4gZXh0ZXJuYWxBY2NvdW50LmRlcml2ZShpbmRleCkucHJpdn07dGhpcy5nZXRJbnRlcm5hbFByaXZhdGVLZXk9ZnVuY3Rpb24oaW5kZXgpe3JldHVybiBpbnRlcm5hbEFjY291bnQuZGVyaXZlKGluZGV4KS5wcml2fTt0aGlzLmdldFByaXZhdGVLZXlGb3JBZGRyZXNzPWZ1bmN0aW9uKGFkZHJlc3Mpe3ZhciBpbmRleDtpZigoaW5kZXg9dGhpcy5hZGRyZXNzZXMuaW5kZXhPZihhZGRyZXNzKSk+LTEpe3JldHVybiB0aGlzLmdldFByaXZhdGVLZXkoaW5kZXgpfWVsc2UgaWYoKGluZGV4PXRoaXMuY2hhbmdlQWRkcmVzc2VzLmluZGV4T2YoYWRkcmVzcykpPi0xKXtyZXR1cm4gdGhpcy5nZXRJbnRlcm5hbFByaXZhdGVLZXkoaW5kZXgpfWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBhZGRyZXNzLiBNYWtlIHN1cmUgdGhlIGFkZHJlc3MgaXMgZnJvbSB0aGUga2V5Y2hhaW4gYW5kIGhhcyBiZWVuIGdlbmVyYXRlZC5cIil9fTtmdW5jdGlvbiBpc1JlY2VpdmVBZGRyZXNzKGFkZHJlc3Mpe3JldHVybiBtZS5hZGRyZXNzZXMuaW5kZXhPZihhZGRyZXNzKT4tMX1mdW5jdGlvbiBpc0NoYW5nZUFkZHJlc3MoYWRkcmVzcyl7cmV0dXJuIG1lLmNoYW5nZUFkZHJlc3Nlcy5pbmRleE9mKGFkZHJlc3MpPi0xfWZ1bmN0aW9uIGlzTXlBZGRyZXNzKGFkZHJlc3Mpe3JldHVybiBpc1JlY2VpdmVBZGRyZXNzKGFkZHJlc3MpfHxpc0NoYW5nZUFkZHJlc3MoYWRkcmVzcyl9fW1vZHVsZS5leHBvcnRzPVdhbGxldH0pLmNhbGwodGhpcyxfZGVyZXFfKFwiRldhQVNIXCIpKX0se1wiLi9jb252ZXJ0XCI6NTcsXCIuL2hkd2FsbGV0LmpzXCI6NjAsXCIuL3RyYW5zYWN0aW9uXCI6NjksRldhQVNIOjE1LFwic2VjdXJlLXJhbmRvbVwiOjUzfV19LHt9LFs2MV0pKDYxKX0pOyIsIi8qISBwZWVyanMgYnVpbGQ6MC4zLjEzLCBkZXZlbG9wbWVudC4gQ29weXJpZ2h0KGMpIDIwMTMgTWljaGVsbGUgQnUgPG1pY2hlbGxlQG1pY2hlbGxlYnUuY29tPiAqLyhmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24gfHxcblx0d2luZG93Lm1velJUQ1Nlc3Npb25EZXNjcmlwdGlvbjtcbm1vZHVsZS5leHBvcnRzLlJUQ1BlZXJDb25uZWN0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8XG5cdHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbiB8fCB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb247XG5tb2R1bGUuZXhwb3J0cy5SVENJY2VDYW5kaWRhdGUgPSB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIHx8XG5cdHdpbmRvdy5tb3pSVENJY2VDYW5kaWRhdGU7XG5cbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XG52YXIgTmVnb3RpYXRvciA9IHJlcXVpcmUoJy4vbmVnb3RpYXRvcicpO1xudmFyIFJlbGlhYmxlID0gcmVxdWlyZSgncmVsaWFibGUnKTtcblxuLyoqXG4gKiBXcmFwcyBhIERhdGFDaGFubmVsIGJldHdlZW4gdHdvIFBlZXJzLlxuICovXG5mdW5jdGlvbiBEYXRhQ29ubmVjdGlvbihwZWVyLCBwcm92aWRlciwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGF0YUNvbm5lY3Rpb24pKSByZXR1cm4gbmV3IERhdGFDb25uZWN0aW9uKHBlZXIsIHByb3ZpZGVyLCBvcHRpb25zKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgIHNlcmlhbGl6YXRpb246ICdiaW5hcnknLFxuICAgIHJlbGlhYmxlOiBmYWxzZVxuICB9LCBvcHRpb25zKTtcblxuICAvLyBDb25uZWN0aW9uIGlzIG5vdCBvcGVuIHlldC5cbiAgdGhpcy5vcGVuID0gZmFsc2U7XG4gIHRoaXMudHlwZSA9ICdkYXRhJztcbiAgdGhpcy5wZWVyID0gcGVlcjtcbiAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuXG4gIHRoaXMuaWQgPSB0aGlzLm9wdGlvbnMuY29ubmVjdGlvbklkIHx8IERhdGFDb25uZWN0aW9uLl9pZFByZWZpeCArIHV0aWwucmFuZG9tVG9rZW4oKTtcblxuICB0aGlzLmxhYmVsID0gdGhpcy5vcHRpb25zLmxhYmVsIHx8IHRoaXMuaWQ7XG4gIHRoaXMubWV0YWRhdGEgPSB0aGlzLm9wdGlvbnMubWV0YWRhdGE7XG4gIHRoaXMuc2VyaWFsaXphdGlvbiA9IHRoaXMub3B0aW9ucy5zZXJpYWxpemF0aW9uO1xuICB0aGlzLnJlbGlhYmxlID0gdGhpcy5vcHRpb25zLnJlbGlhYmxlO1xuXG4gIC8vIERhdGEgY2hhbm5lbCBidWZmZXJpbmcuXG4gIHRoaXMuX2J1ZmZlciA9IFtdO1xuICB0aGlzLl9idWZmZXJpbmcgPSBmYWxzZTtcbiAgdGhpcy5idWZmZXJTaXplID0gMDtcblxuICAvLyBGb3Igc3RvcmluZyBsYXJnZSBkYXRhLlxuICB0aGlzLl9jaHVua2VkRGF0YSA9IHt9O1xuXG4gIGlmICh0aGlzLm9wdGlvbnMuX3BheWxvYWQpIHtcbiAgICB0aGlzLl9wZWVyQnJvd3NlciA9IHRoaXMub3B0aW9ucy5fcGF5bG9hZC5icm93c2VyO1xuICB9XG5cbiAgTmVnb3RpYXRvci5zdGFydENvbm5lY3Rpb24oXG4gICAgdGhpcyxcbiAgICB0aGlzLm9wdGlvbnMuX3BheWxvYWQgfHwge1xuICAgICAgb3JpZ2luYXRvcjogdHJ1ZVxuICAgIH1cbiAgKTtcbn1cblxudXRpbC5pbmhlcml0cyhEYXRhQ29ubmVjdGlvbiwgRXZlbnRFbWl0dGVyKTtcblxuRGF0YUNvbm5lY3Rpb24uX2lkUHJlZml4ID0gJ2RjXyc7XG5cbi8qKiBDYWxsZWQgYnkgdGhlIE5lZ290aWF0b3Igd2hlbiB0aGUgRGF0YUNoYW5uZWwgaXMgcmVhZHkuICovXG5EYXRhQ29ubmVjdGlvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGRjKSB7XG4gIHRoaXMuX2RjID0gdGhpcy5kYXRhQ2hhbm5lbCA9IGRjO1xuICB0aGlzLl9jb25maWd1cmVEYXRhQ2hhbm5lbCgpO1xufVxuXG5EYXRhQ29ubmVjdGlvbi5wcm90b3R5cGUuX2NvbmZpZ3VyZURhdGFDaGFubmVsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHV0aWwuc3VwcG9ydHMuc2N0cCkge1xuICAgIHRoaXMuX2RjLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICB9XG4gIHRoaXMuX2RjLm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHV0aWwubG9nKCdEYXRhIGNoYW5uZWwgY29ubmVjdGlvbiBzdWNjZXNzJyk7XG4gICAgc2VsZi5vcGVuID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ29wZW4nKTtcbiAgfVxuXG4gIC8vIFVzZSB0aGUgUmVsaWFibGUgc2hpbSBmb3Igbm9uIEZpcmVmb3ggYnJvd3NlcnNcbiAgaWYgKCF1dGlsLnN1cHBvcnRzLnNjdHAgJiYgdGhpcy5yZWxpYWJsZSkge1xuICAgIHRoaXMuX3JlbGlhYmxlID0gbmV3IFJlbGlhYmxlKHRoaXMuX2RjLCB1dGlsLmRlYnVnKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9yZWxpYWJsZSkge1xuICAgIHRoaXMuX3JlbGlhYmxlLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuICAgICAgc2VsZi5lbWl0KCdkYXRhJywgbXNnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2RjLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHNlbGYuX2hhbmRsZURhdGFNZXNzYWdlKGUpO1xuICAgIH07XG4gIH1cbiAgdGhpcy5fZGMub25jbG9zZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICB1dGlsLmxvZygnRGF0YUNoYW5uZWwgY2xvc2VkIGZvcjonLCBzZWxmLnBlZXIpO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfTtcbn1cblxuLy8gSGFuZGxlcyBhIERhdGFDaGFubmVsIG1lc3NhZ2UuXG5EYXRhQ29ubmVjdGlvbi5wcm90b3R5cGUuX2hhbmRsZURhdGFNZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBkYXRhID0gZS5kYXRhO1xuICB2YXIgZGF0YXR5cGUgPSBkYXRhLmNvbnN0cnVjdG9yO1xuICBpZiAodGhpcy5zZXJpYWxpemF0aW9uID09PSAnYmluYXJ5JyB8fCB0aGlzLnNlcmlhbGl6YXRpb24gPT09ICdiaW5hcnktdXRmOCcpIHtcbiAgICBpZiAoZGF0YXR5cGUgPT09IEJsb2IpIHtcbiAgICAgIC8vIERhdGF0eXBlIHNob3VsZCBuZXZlciBiZSBibG9iXG4gICAgICB1dGlsLmJsb2JUb0FycmF5QnVmZmVyKGRhdGEsIGZ1bmN0aW9uKGFiKSB7XG4gICAgICAgIGRhdGEgPSB1dGlsLnVucGFjayhhYik7XG4gICAgICAgIHNlbGYuZW1pdCgnZGF0YScsIGRhdGEpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChkYXRhdHlwZSA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgIGRhdGEgPSB1dGlsLnVucGFjayhkYXRhKTtcbiAgICB9IGVsc2UgaWYgKGRhdGF0eXBlID09PSBTdHJpbmcpIHtcbiAgICAgIC8vIFN0cmluZyBmYWxsYmFjayBmb3IgYmluYXJ5IGRhdGEgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBiaW5hcnkgeWV0XG4gICAgICB2YXIgYWIgPSB1dGlsLmJpbmFyeVN0cmluZ1RvQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICBkYXRhID0gdXRpbC51bnBhY2soYWIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLnNlcmlhbGl6YXRpb24gPT09ICdqc29uJykge1xuICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UndmUgY2h1bmtlZC0taWYgc28sIHBpZWNlIHRoaW5ncyBiYWNrIHRvZ2V0aGVyLlxuICAvLyBXZSdyZSBndWFyYW50ZWVkIHRoYXQgdGhpcyBpc24ndCAwLlxuICBpZiAoZGF0YS5fX3BlZXJEYXRhKSB7XG4gICAgdmFyIGlkID0gZGF0YS5fX3BlZXJEYXRhO1xuICAgIHZhciBjaHVua0luZm8gPSB0aGlzLl9jaHVua2VkRGF0YVtpZF0gfHwge2RhdGE6IFtdLCBjb3VudDogMCwgdG90YWw6IGRhdGEudG90YWx9O1xuXG4gICAgY2h1bmtJbmZvLmRhdGFbZGF0YS5uXSA9IGRhdGEuZGF0YTtcbiAgICBjaHVua0luZm8uY291bnQgKz0gMTtcblxuICAgIGlmIChjaHVua0luZm8udG90YWwgPT09IGNodW5rSW5mby5jb3VudCkge1xuICAgICAgLy8gQ2xlYW4gdXAgYmVmb3JlIG1ha2luZyB0aGUgcmVjdXJzaXZlIGNhbGwgdG8gYF9oYW5kbGVEYXRhTWVzc2FnZWAuXG4gICAgICBkZWxldGUgdGhpcy5fY2h1bmtlZERhdGFbaWRdO1xuXG4gICAgICAvLyBXZSd2ZSByZWNlaXZlZCBhbGwgdGhlIGNodW5rcy0tdGltZSB0byBjb25zdHJ1Y3QgdGhlIGNvbXBsZXRlIGRhdGEuXG4gICAgICBkYXRhID0gbmV3IEJsb2IoY2h1bmtJbmZvLmRhdGEpO1xuICAgICAgdGhpcy5faGFuZGxlRGF0YU1lc3NhZ2Uoe2RhdGE6IGRhdGF9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9jaHVua2VkRGF0YVtpZF0gPSBjaHVua0luZm87XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG59XG5cbi8qKlxuICogRXhwb3NlZCBmdW5jdGlvbmFsaXR5IGZvciB1c2Vycy5cbiAqL1xuXG4vKiogQWxsb3dzIHVzZXIgdG8gY2xvc2UgY29ubmVjdGlvbi4gKi9cbkRhdGFDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMub3Blbikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLm9wZW4gPSBmYWxzZTtcbiAgTmVnb3RpYXRvci5jbGVhbnVwKHRoaXMpO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbi8qKiBBbGxvd3MgdXNlciB0byBzZW5kIGRhdGEuICovXG5EYXRhQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEsIGNodW5rZWQpIHtcbiAgaWYgKCF0aGlzLm9wZW4pIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDb25uZWN0aW9uIGlzIG5vdCBvcGVuLiBZb3Ugc2hvdWxkIGxpc3RlbiBmb3IgdGhlIGBvcGVuYCBldmVudCBiZWZvcmUgc2VuZGluZyBtZXNzYWdlcy4nKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0aGlzLl9yZWxpYWJsZSkge1xuICAgIC8vIE5vdGU6IHJlbGlhYmxlIHNoaW0gc2VuZGluZyB3aWxsIG1ha2UgaXQgc28gdGhhdCB5b3UgY2Fubm90IGN1c3RvbWl6ZVxuICAgIC8vIHNlcmlhbGl6YXRpb24uXG4gICAgdGhpcy5fcmVsaWFibGUuc2VuZChkYXRhKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5zZXJpYWxpemF0aW9uID09PSAnanNvbicpIHtcbiAgICB0aGlzLl9idWZmZXJlZFNlbmQoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICB9IGVsc2UgaWYgKHRoaXMuc2VyaWFsaXphdGlvbiA9PT0gJ2JpbmFyeScgfHwgdGhpcy5zZXJpYWxpemF0aW9uID09PSAnYmluYXJ5LXV0ZjgnKSB7XG4gICAgdmFyIGJsb2IgPSB1dGlsLnBhY2soZGF0YSk7XG5cbiAgICAvLyBGb3IgQ2hyb21lLUZpcmVmb3ggaW50ZXJvcGVyYWJpbGl0eSwgd2UgbmVlZCB0byBtYWtlIEZpcmVmb3ggXCJjaHVua1wiXG4gICAgLy8gdGhlIGRhdGEgaXQgc2VuZHMgb3V0LlxuICAgIHZhciBuZWVkc0NodW5raW5nID0gdXRpbC5jaHVua2VkQnJvd3NlcnNbdGhpcy5fcGVlckJyb3dzZXJdIHx8IHV0aWwuY2h1bmtlZEJyb3dzZXJzW3V0aWwuYnJvd3Nlcl07XG4gICAgaWYgKG5lZWRzQ2h1bmtpbmcgJiYgIWNodW5rZWQgJiYgYmxvYi5zaXplID4gdXRpbC5jaHVua2VkTVRVKSB7XG4gICAgICB0aGlzLl9zZW5kQ2h1bmtzKGJsb2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERhdGFDaGFubmVsIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHN0cmluZ3MuXG4gICAgaWYgKCF1dGlsLnN1cHBvcnRzLnNjdHApIHtcbiAgICAgIHV0aWwuYmxvYlRvQmluYXJ5U3RyaW5nKGJsb2IsIGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBzZWxmLl9idWZmZXJlZFNlbmQoc3RyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWwuc3VwcG9ydHMuYmluYXJ5QmxvYikge1xuICAgICAgLy8gV2Ugb25seSBkbyB0aGlzIGlmIHdlIHJlYWxseSBuZWVkIHRvIChlLmcuIGJsb2JzIGFyZSBub3Qgc3VwcG9ydGVkKSxcbiAgICAgIC8vIGJlY2F1c2UgdGhpcyBjb252ZXJzaW9uIGlzIGNvc3RseS5cbiAgICAgIHV0aWwuYmxvYlRvQXJyYXlCdWZmZXIoYmxvYiwgZnVuY3Rpb24oYWIpIHtcbiAgICAgICAgc2VsZi5fYnVmZmVyZWRTZW5kKGFiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9idWZmZXJlZFNlbmQoYmxvYik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2J1ZmZlcmVkU2VuZChkYXRhKTtcbiAgfVxufVxuXG5EYXRhQ29ubmVjdGlvbi5wcm90b3R5cGUuX2J1ZmZlcmVkU2VuZCA9IGZ1bmN0aW9uKG1zZykge1xuICBpZiAodGhpcy5fYnVmZmVyaW5nIHx8ICF0aGlzLl90cnlTZW5kKG1zZykpIHtcbiAgICB0aGlzLl9idWZmZXIucHVzaChtc2cpO1xuICAgIHRoaXMuYnVmZmVyU2l6ZSA9IHRoaXMuX2J1ZmZlci5sZW5ndGg7XG4gIH1cbn1cblxuLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBzZW5kIHN1Y2NlZWRzLlxuRGF0YUNvbm5lY3Rpb24ucHJvdG90eXBlLl90cnlTZW5kID0gZnVuY3Rpb24obXNnKSB7XG4gIHRyeSB7XG4gICAgdGhpcy5fZGMuc2VuZChtc2cpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5fYnVmZmVyaW5nID0gdHJ1ZTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVHJ5IGFnYWluLlxuICAgICAgc2VsZi5fYnVmZmVyaW5nID0gZmFsc2U7XG4gICAgICBzZWxmLl90cnlCdWZmZXIoKTtcbiAgICB9LCAxMDApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gVHJ5IHRvIHNlbmQgdGhlIGZpcnN0IG1lc3NhZ2UgaW4gdGhlIGJ1ZmZlci5cbkRhdGFDb25uZWN0aW9uLnByb3RvdHlwZS5fdHJ5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9idWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1zZyA9IHRoaXMuX2J1ZmZlclswXTtcblxuICBpZiAodGhpcy5fdHJ5U2VuZChtc2cpKSB7XG4gICAgdGhpcy5fYnVmZmVyLnNoaWZ0KCk7XG4gICAgdGhpcy5idWZmZXJTaXplID0gdGhpcy5fYnVmZmVyLmxlbmd0aDtcbiAgICB0aGlzLl90cnlCdWZmZXIoKTtcbiAgfVxufVxuXG5EYXRhQ29ubmVjdGlvbi5wcm90b3R5cGUuX3NlbmRDaHVua3MgPSBmdW5jdGlvbihibG9iKSB7XG4gIHZhciBibG9icyA9IHV0aWwuY2h1bmsoYmxvYik7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGJsb2JzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDEpIHtcbiAgICB2YXIgYmxvYiA9IGJsb2JzW2ldO1xuICAgIHRoaXMuc2VuZChibG9iLCB0cnVlKTtcbiAgfVxufVxuXG5EYXRhQ29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgdmFyIHBheWxvYWQgPSBtZXNzYWdlLnBheWxvYWQ7XG5cbiAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICBjYXNlICdBTlNXRVInOlxuICAgICAgdGhpcy5fcGVlckJyb3dzZXIgPSBwYXlsb2FkLmJyb3dzZXI7XG5cbiAgICAgIC8vIEZvcndhcmQgdG8gbmVnb3RpYXRvclxuICAgICAgTmVnb3RpYXRvci5oYW5kbGVTRFAobWVzc2FnZS50eXBlLCB0aGlzLCBwYXlsb2FkLnNkcCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdDQU5ESURBVEUnOlxuICAgICAgTmVnb3RpYXRvci5oYW5kbGVDYW5kaWRhdGUodGhpcywgcGF5bG9hZC5jYW5kaWRhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHV0aWwud2FybignVW5yZWNvZ25pemVkIG1lc3NhZ2UgdHlwZTonLCBtZXNzYWdlLnR5cGUsICdmcm9tIHBlZXI6JywgdGhpcy5wZWVyKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YUNvbm5lY3Rpb247XG5cbn0se1wiLi9uZWdvdGlhdG9yXCI6NSxcIi4vdXRpbFwiOjgsXCJldmVudGVtaXR0ZXIzXCI6OSxcInJlbGlhYmxlXCI6MTJ9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgaWYodHlwZW9mIHdpbmRvdyA9PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xud2luZG93LlNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG53aW5kb3cuTWVkaWFDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9tZWRpYWNvbm5lY3Rpb24nKTtcbndpbmRvdy5EYXRhQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vZGF0YWNvbm5lY3Rpb24nKTtcbndpbmRvdy5QZWVyID0gcmVxdWlyZSgnLi9wZWVyJyk7XG53aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL2FkYXB0ZXInKS5SVENQZWVyQ29ubmVjdGlvbjtcbndpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24gPSByZXF1aXJlKCcuL2FkYXB0ZXInKS5SVENTZXNzaW9uRGVzY3JpcHRpb247XG53aW5kb3cuUlRDSWNlQ2FuZGlkYXRlID0gcmVxdWlyZSgnLi9hZGFwdGVyJykuUlRDSWNlQ2FuZGlkYXRlO1xud2luZG93Lk5lZ290aWF0b3IgPSByZXF1aXJlKCcuL25lZ290aWF0b3InKTtcbndpbmRvdy51dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG53aW5kb3cuQmluYXJ5UGFjayA9IHJlcXVpcmUoJ2pzLWJpbmFyeXBhY2snKTtcblxufSx7XCIuL2FkYXB0ZXJcIjoxLFwiLi9kYXRhY29ubmVjdGlvblwiOjIsXCIuL21lZGlhY29ubmVjdGlvblwiOjQsXCIuL25lZ290aWF0b3JcIjo1LFwiLi9wZWVyXCI6NixcIi4vc29ja2V0XCI6NyxcIi4vdXRpbFwiOjgsXCJqcy1iaW5hcnlwYWNrXCI6MTB9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpO1xudmFyIE5lZ290aWF0b3IgPSByZXF1aXJlKCcuL25lZ290aWF0b3InKTtcblxuLyoqXG4gKiBXcmFwcyB0aGUgc3RyZWFtaW5nIGludGVyZmFjZSBiZXR3ZWVuIHR3byBQZWVycy5cbiAqL1xuZnVuY3Rpb24gTWVkaWFDb25uZWN0aW9uKHBlZXIsIHByb3ZpZGVyLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNZWRpYUNvbm5lY3Rpb24pKSByZXR1cm4gbmV3IE1lZGlhQ29ubmVjdGlvbihwZWVyLCBwcm92aWRlciwgb3B0aW9ucyk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBvcHRpb25zKTtcblxuICB0aGlzLm9wZW4gPSBmYWxzZTtcbiAgdGhpcy50eXBlID0gJ21lZGlhJztcbiAgdGhpcy5wZWVyID0gcGVlcjtcbiAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICB0aGlzLm1ldGFkYXRhID0gdGhpcy5vcHRpb25zLm1ldGFkYXRhO1xuICB0aGlzLmxvY2FsU3RyZWFtID0gdGhpcy5vcHRpb25zLl9zdHJlYW07XG5cbiAgdGhpcy5pZCA9IHRoaXMub3B0aW9ucy5jb25uZWN0aW9uSWQgfHwgTWVkaWFDb25uZWN0aW9uLl9pZFByZWZpeCArIHV0aWwucmFuZG9tVG9rZW4oKTtcbiAgaWYgKHRoaXMubG9jYWxTdHJlYW0pIHtcbiAgICBOZWdvdGlhdG9yLnN0YXJ0Q29ubmVjdGlvbihcbiAgICAgIHRoaXMsXG4gICAgICB7X3N0cmVhbTogdGhpcy5sb2NhbFN0cmVhbSwgb3JpZ2luYXRvcjogdHJ1ZX1cbiAgICApO1xuICB9XG59O1xuXG51dGlsLmluaGVyaXRzKE1lZGlhQ29ubmVjdGlvbiwgRXZlbnRFbWl0dGVyKTtcblxuTWVkaWFDb25uZWN0aW9uLl9pZFByZWZpeCA9ICdtY18nO1xuXG5NZWRpYUNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uKHJlbW90ZVN0cmVhbSkge1xuICB1dGlsLmxvZygnUmVjZWl2aW5nIHN0cmVhbScsIHJlbW90ZVN0cmVhbSk7XG5cbiAgdGhpcy5yZW1vdGVTdHJlYW0gPSByZW1vdGVTdHJlYW07XG4gIHRoaXMuZW1pdCgnc3RyZWFtJywgcmVtb3RlU3RyZWFtKTsgLy8gU2hvdWxkIHdlIGNhbGwgdGhpcyBgb3BlbmA/XG5cbn07XG5cbk1lZGlhQ29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgdmFyIHBheWxvYWQgPSBtZXNzYWdlLnBheWxvYWQ7XG5cbiAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICBjYXNlICdBTlNXRVInOlxuICAgICAgLy8gRm9yd2FyZCB0byBuZWdvdGlhdG9yXG4gICAgICBOZWdvdGlhdG9yLmhhbmRsZVNEUChtZXNzYWdlLnR5cGUsIHRoaXMsIHBheWxvYWQuc2RwKTtcbiAgICAgIHRoaXMub3BlbiA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdDQU5ESURBVEUnOlxuICAgICAgTmVnb3RpYXRvci5oYW5kbGVDYW5kaWRhdGUodGhpcywgcGF5bG9hZC5jYW5kaWRhdGUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHV0aWwud2FybignVW5yZWNvZ25pemVkIG1lc3NhZ2UgdHlwZTonLCBtZXNzYWdlLnR5cGUsICdmcm9tIHBlZXI6JywgdGhpcy5wZWVyKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbk1lZGlhQ29ubmVjdGlvbi5wcm90b3R5cGUuYW5zd2VyID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIGlmICh0aGlzLmxvY2FsU3RyZWFtKSB7XG4gICAgdXRpbC53YXJuKCdMb2NhbCBzdHJlYW0gYWxyZWFkeSBleGlzdHMgb24gdGhpcyBNZWRpYUNvbm5lY3Rpb24uIEFyZSB5b3UgYW5zd2VyaW5nIGEgY2FsbCB0d2ljZT8nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLm9wdGlvbnMuX3BheWxvYWQuX3N0cmVhbSA9IHN0cmVhbTtcblxuICB0aGlzLmxvY2FsU3RyZWFtID0gc3RyZWFtO1xuICBOZWdvdGlhdG9yLnN0YXJ0Q29ubmVjdGlvbihcbiAgICB0aGlzLFxuICAgIHRoaXMub3B0aW9ucy5fcGF5bG9hZFxuICApXG4gIC8vIFJldHJpZXZlIGxvc3QgbWVzc2FnZXMgc3RvcmVkIGJlY2F1c2UgUGVlckNvbm5lY3Rpb24gbm90IHNldCB1cC5cbiAgdmFyIG1lc3NhZ2VzID0gdGhpcy5wcm92aWRlci5fZ2V0TWVzc2FnZXModGhpcy5pZCk7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IG1lc3NhZ2VzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDEpIHtcbiAgICB0aGlzLmhhbmRsZU1lc3NhZ2UobWVzc2FnZXNbaV0pO1xuICB9XG4gIHRoaXMub3BlbiA9IHRydWU7XG59O1xuXG4vKipcbiAqIEV4cG9zZWQgZnVuY3Rpb25hbGl0eSBmb3IgdXNlcnMuXG4gKi9cblxuLyoqIEFsbG93cyB1c2VyIHRvIGNsb3NlIGNvbm5lY3Rpb24uICovXG5NZWRpYUNvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5vcGVuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMub3BlbiA9IGZhbHNlO1xuICBOZWdvdGlhdG9yLmNsZWFudXAodGhpcyk7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZWRpYUNvbm5lY3Rpb247XG5cbn0se1wiLi9uZWdvdGlhdG9yXCI6NSxcIi4vdXRpbFwiOjgsXCJldmVudGVtaXR0ZXIzXCI6OX1dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBSVENQZWVyQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vYWRhcHRlcicpLlJUQ1BlZXJDb25uZWN0aW9uO1xudmFyIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IHJlcXVpcmUoJy4vYWRhcHRlcicpLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbjtcbnZhciBSVENJY2VDYW5kaWRhdGUgPSByZXF1aXJlKCcuL2FkYXB0ZXInKS5SVENJY2VDYW5kaWRhdGU7XG5cbi8qKlxuICogTWFuYWdlcyBhbGwgbmVnb3RpYXRpb25zIGJldHdlZW4gUGVlcnMuXG4gKi9cbnZhciBOZWdvdGlhdG9yID0ge1xuICBwY3M6IHtcbiAgICBkYXRhOiB7fSxcbiAgICBtZWRpYToge31cbiAgfSwgLy8gdHlwZSA9PiB7cGVlcklkOiB7cGNfaWQ6IHBjfX0uXG4gIC8vcHJvdmlkZXJzOiB7fSwgLy8gcHJvdmlkZXIncyBpZCA9PiBwcm92aWRlcnMgKHRoZXJlIG1heSBiZSBtdWx0aXBsZSBwcm92aWRlcnMvY2xpZW50LlxuICBxdWV1ZTogW10gLy8gY29ubmVjdGlvbnMgdGhhdCBhcmUgZGVsYXllZCBkdWUgdG8gYSBQQyBiZWluZyBpbiB1c2UuXG59XG5cbk5lZ290aWF0b3IuX2lkUHJlZml4ID0gJ3BjXyc7XG5cbi8qKiBSZXR1cm5zIGEgUGVlckNvbm5lY3Rpb24gb2JqZWN0IHNldCB1cCBjb3JyZWN0bHkgKGZvciBkYXRhLCBtZWRpYSkuICovXG5OZWdvdGlhdG9yLnN0YXJ0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHBjID0gTmVnb3RpYXRvci5fZ2V0UGVlckNvbm5lY3Rpb24oY29ubmVjdGlvbiwgb3B0aW9ucyk7XG5cbiAgaWYgKGNvbm5lY3Rpb24udHlwZSA9PT0gJ21lZGlhJyAmJiBvcHRpb25zLl9zdHJlYW0pIHtcbiAgICAvLyBBZGQgdGhlIHN0cmVhbS5cbiAgICBwYy5hZGRTdHJlYW0ob3B0aW9ucy5fc3RyZWFtKTtcbiAgfVxuXG4gIC8vIFNldCB0aGUgY29ubmVjdGlvbidzIFBDLlxuICBjb25uZWN0aW9uLnBjID0gY29ubmVjdGlvbi5wZWVyQ29ubmVjdGlvbiA9IHBjO1xuICAvLyBXaGF0IGRvIHdlIG5lZWQgdG8gZG8gbm93P1xuICBpZiAob3B0aW9ucy5vcmlnaW5hdG9yKSB7XG4gICAgaWYgKGNvbm5lY3Rpb24udHlwZSA9PT0gJ2RhdGEnKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIGRhdGFjaGFubmVsLlxuICAgICAgdmFyIGNvbmZpZyA9IHt9O1xuICAgICAgLy8gRHJvcHBpbmcgcmVsaWFibGU6ZmFsc2Ugc3VwcG9ydCwgc2luY2UgaXQgc2VlbXMgdG8gYmUgY3Jhc2hpbmdcbiAgICAgIC8vIENocm9tZS5cbiAgICAgIC8qaWYgKHV0aWwuc3VwcG9ydHMuc2N0cCAmJiAhb3B0aW9ucy5yZWxpYWJsZSkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGNhbm9uaWNhbCByZWxpYWJsZSBzdXBwb3J0Li4uXG4gICAgICAgIGNvbmZpZyA9IHttYXhSZXRyYW5zbWl0czogMH07XG4gICAgICB9Ki9cbiAgICAgIC8vIEZhbGxiYWNrIHRvIGVuc3VyZSBvbGRlciBicm93c2VycyBkb24ndCBjcmFzaC5cbiAgICAgIGlmICghdXRpbC5zdXBwb3J0cy5zY3RwKSB7XG4gICAgICAgIGNvbmZpZyA9IHtyZWxpYWJsZTogb3B0aW9ucy5yZWxpYWJsZX07XG4gICAgICB9XG4gICAgICB2YXIgZGMgPSBwYy5jcmVhdGVEYXRhQ2hhbm5lbChjb25uZWN0aW9uLmxhYmVsLCBjb25maWcpO1xuICAgICAgY29ubmVjdGlvbi5pbml0aWFsaXplKGRjKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuc3VwcG9ydHMub25uZWdvdGlhdGlvbm5lZWRlZCkge1xuICAgICAgTmVnb3RpYXRvci5fbWFrZU9mZmVyKGNvbm5lY3Rpb24pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBOZWdvdGlhdG9yLmhhbmRsZVNEUCgnT0ZGRVInLCBjb25uZWN0aW9uLCBvcHRpb25zLnNkcCk7XG4gIH1cbn1cblxuTmVnb3RpYXRvci5fZ2V0UGVlckNvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25uZWN0aW9uLCBvcHRpb25zKSB7XG4gIGlmICghTmVnb3RpYXRvci5wY3NbY29ubmVjdGlvbi50eXBlXSkge1xuICAgIHV0aWwuZXJyb3IoY29ubmVjdGlvbi50eXBlICsgJyBpcyBub3QgYSB2YWxpZCBjb25uZWN0aW9uIHR5cGUuIE1heWJlIHlvdSBvdmVycm9kZSB0aGUgYHR5cGVgIHByb3BlcnR5IHNvbWV3aGVyZS4nKTtcbiAgfVxuXG4gIGlmICghTmVnb3RpYXRvci5wY3NbY29ubmVjdGlvbi50eXBlXVtjb25uZWN0aW9uLnBlZXJdKSB7XG4gICAgTmVnb3RpYXRvci5wY3NbY29ubmVjdGlvbi50eXBlXVtjb25uZWN0aW9uLnBlZXJdID0ge307XG4gIH1cbiAgdmFyIHBlZXJDb25uZWN0aW9ucyA9IE5lZ290aWF0b3IucGNzW2Nvbm5lY3Rpb24udHlwZV1bY29ubmVjdGlvbi5wZWVyXTtcblxuICB2YXIgcGM7XG4gIC8vIE5vdCBtdWx0aXBsZXhpbmcgd2hpbGUgRkYgYW5kIENocm9tZSBoYXZlIG5vdC1ncmVhdCBzdXBwb3J0IGZvciBpdC5cbiAgLyppZiAob3B0aW9ucy5tdWx0aXBsZXgpIHtcbiAgICBpZHMgPSBPYmplY3Qua2V5cyhwZWVyQ29ubmVjdGlvbnMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGlkcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAxKSB7XG4gICAgICBwYyA9IHBlZXJDb25uZWN0aW9uc1tpZHNbaV1dO1xuICAgICAgaWYgKHBjLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJykge1xuICAgICAgICBicmVhazsgLy8gV2UgY2FuIGdvIGFoZWFkIGFuZCB1c2UgdGhpcyBQQy5cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSAqL1xuICBpZiAob3B0aW9ucy5wYykgeyAvLyBTaW1wbGVzdCBjYXNlOiBQQyBpZCBhbHJlYWR5IHByb3ZpZGVkIGZvciB1cy5cbiAgICBwYyA9IE5lZ290aWF0b3IucGNzW2Nvbm5lY3Rpb24udHlwZV1bY29ubmVjdGlvbi5wZWVyXVtvcHRpb25zLnBjXTtcbiAgfVxuXG4gIGlmICghcGMgfHwgcGMuc2lnbmFsaW5nU3RhdGUgIT09ICdzdGFibGUnKSB7XG4gICAgcGMgPSBOZWdvdGlhdG9yLl9zdGFydFBlZXJDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICB9XG4gIHJldHVybiBwYztcbn1cblxuLypcbk5lZ290aWF0b3IuX2FkZFByb3ZpZGVyID0gZnVuY3Rpb24ocHJvdmlkZXIpIHtcbiAgaWYgKCghcHJvdmlkZXIuaWQgJiYgIXByb3ZpZGVyLmRpc2Nvbm5lY3RlZCkgfHwgIXByb3ZpZGVyLnNvY2tldC5vcGVuKSB7XG4gICAgLy8gV2FpdCBmb3IgcHJvdmlkZXIgdG8gb2J0YWluIGFuIElELlxuICAgIHByb3ZpZGVyLm9uKCdvcGVuJywgZnVuY3Rpb24oaWQpIHtcbiAgICAgIE5lZ290aWF0b3IuX2FkZFByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBOZWdvdGlhdG9yLnByb3ZpZGVyc1twcm92aWRlci5pZF0gPSBwcm92aWRlcjtcbiAgfVxufSovXG5cblxuLyoqIFN0YXJ0IGEgUEMuICovXG5OZWdvdGlhdG9yLl9zdGFydFBlZXJDb25uZWN0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICB1dGlsLmxvZygnQ3JlYXRpbmcgUlRDUGVlckNvbm5lY3Rpb24uJyk7XG5cbiAgdmFyIGlkID0gTmVnb3RpYXRvci5faWRQcmVmaXggKyB1dGlsLnJhbmRvbVRva2VuKCk7XG4gIHZhciBvcHRpb25hbCA9IHt9O1xuXG4gIGlmIChjb25uZWN0aW9uLnR5cGUgPT09ICdkYXRhJyAmJiAhdXRpbC5zdXBwb3J0cy5zY3RwKSB7XG4gICAgb3B0aW9uYWwgPSB7b3B0aW9uYWw6IFt7UnRwRGF0YUNoYW5uZWxzOiB0cnVlfV19O1xuICB9IGVsc2UgaWYgKGNvbm5lY3Rpb24udHlwZSA9PT0gJ21lZGlhJykge1xuICAgIC8vIEludGVyb3AgcmVxIGZvciBjaHJvbWUuXG4gICAgb3B0aW9uYWwgPSB7b3B0aW9uYWw6IFt7RHRsc1NydHBLZXlBZ3JlZW1lbnQ6IHRydWV9XX07XG4gIH1cblxuICB2YXIgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oY29ubmVjdGlvbi5wcm92aWRlci5vcHRpb25zLmNvbmZpZywgb3B0aW9uYWwpO1xuICBOZWdvdGlhdG9yLnBjc1tjb25uZWN0aW9uLnR5cGVdW2Nvbm5lY3Rpb24ucGVlcl1baWRdID0gcGM7XG5cbiAgTmVnb3RpYXRvci5fc2V0dXBMaXN0ZW5lcnMoY29ubmVjdGlvbiwgcGMsIGlkKTtcblxuICByZXR1cm4gcGM7XG59XG5cbi8qKiBTZXQgdXAgdmFyaW91cyBXZWJSVEMgbGlzdGVuZXJzLiAqL1xuTmVnb3RpYXRvci5fc2V0dXBMaXN0ZW5lcnMgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBwYywgcGNfaWQpIHtcbiAgdmFyIHBlZXJJZCA9IGNvbm5lY3Rpb24ucGVlcjtcbiAgdmFyIGNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb24uaWQ7XG4gIHZhciBwcm92aWRlciA9IGNvbm5lY3Rpb24ucHJvdmlkZXI7XG5cbiAgLy8gSUNFIENBTkRJREFURVMuXG4gIHV0aWwubG9nKCdMaXN0ZW5pbmcgZm9yIElDRSBjYW5kaWRhdGVzLicpO1xuICBwYy5vbmljZWNhbmRpZGF0ZSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIGlmIChldnQuY2FuZGlkYXRlKSB7XG4gICAgICB1dGlsLmxvZygnUmVjZWl2ZWQgSUNFIGNhbmRpZGF0ZXMgZm9yOicsIGNvbm5lY3Rpb24ucGVlcik7XG4gICAgICBwcm92aWRlci5zb2NrZXQuc2VuZCh7XG4gICAgICAgIHR5cGU6ICdDQU5ESURBVEUnLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgY2FuZGlkYXRlOiBldnQuY2FuZGlkYXRlLFxuICAgICAgICAgIHR5cGU6IGNvbm5lY3Rpb24udHlwZSxcbiAgICAgICAgICBjb25uZWN0aW9uSWQ6IGNvbm5lY3Rpb24uaWRcbiAgICAgICAgfSxcbiAgICAgICAgZHN0OiBwZWVySWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBwYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAocGMuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOlxuICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgdXRpbC5sb2coJ2ljZUNvbm5lY3Rpb25TdGF0ZSBpcyBkaXNjb25uZWN0ZWQsIGNsb3NpbmcgY29ubmVjdGlvbnMgdG8gJyArIHBlZXJJZCk7XG4gICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICBwYy5vbmljZWNhbmRpZGF0ZSA9IHV0aWwubm9vcDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIC8vIEZhbGxiYWNrIGZvciBvbGRlciBDaHJvbWUgaW1wbHMuXG4gIHBjLm9uaWNlY2hhbmdlID0gcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2U7XG5cbiAgLy8gT05ORUdPVElBVElPTk5FRURFRCAoQ2hyb21lKVxuICB1dGlsLmxvZygnTGlzdGVuaW5nIGZvciBgbmVnb3RpYXRpb25uZWVkZWRgJyk7XG4gIHBjLm9ubmVnb3RpYXRpb25uZWVkZWQgPSBmdW5jdGlvbigpIHtcbiAgICB1dGlsLmxvZygnYG5lZ290aWF0aW9ubmVlZGVkYCB0cmlnZ2VyZWQnKTtcbiAgICBpZiAocGMuc2lnbmFsaW5nU3RhdGUgPT0gJ3N0YWJsZScpIHtcbiAgICAgIE5lZ290aWF0b3IuX21ha2VPZmZlcihjb25uZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC5sb2coJ29ubmVnb3RpYXRpb25uZWVkZWQgdHJpZ2dlcmVkIHdoZW4gbm90IHN0YWJsZS4gSXMgYW5vdGhlciBjb25uZWN0aW9uIGJlaW5nIGVzdGFibGlzaGVkPycpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEQVRBQ09OTkVDVElPTi5cbiAgdXRpbC5sb2coJ0xpc3RlbmluZyBmb3IgZGF0YSBjaGFubmVsJyk7XG4gIC8vIEZpcmVkIGJldHdlZW4gb2ZmZXIgYW5kIGFuc3dlciwgc28gb3B0aW9ucyBzaG91bGQgYWxyZWFkeSBiZSBzYXZlZFxuICAvLyBpbiB0aGUgb3B0aW9ucyBoYXNoLlxuICBwYy5vbmRhdGFjaGFubmVsID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgdXRpbC5sb2coJ1JlY2VpdmVkIGRhdGEgY2hhbm5lbCcpO1xuICAgIHZhciBkYyA9IGV2dC5jaGFubmVsO1xuICAgIHZhciBjb25uZWN0aW9uID0gcHJvdmlkZXIuZ2V0Q29ubmVjdGlvbihwZWVySWQsIGNvbm5lY3Rpb25JZCk7XG4gICAgY29ubmVjdGlvbi5pbml0aWFsaXplKGRjKTtcbiAgfTtcblxuICAvLyBNRURJQUNPTk5FQ1RJT04uXG4gIHV0aWwubG9nKCdMaXN0ZW5pbmcgZm9yIHJlbW90ZSBzdHJlYW0nKTtcbiAgcGMub25hZGRzdHJlYW0gPSBmdW5jdGlvbihldnQpIHtcbiAgICB1dGlsLmxvZygnUmVjZWl2ZWQgcmVtb3RlIHN0cmVhbScpO1xuICAgIHZhciBzdHJlYW0gPSBldnQuc3RyZWFtO1xuICAgIHZhciBjb25uZWN0aW9uID0gcHJvdmlkZXIuZ2V0Q29ubmVjdGlvbihwZWVySWQsIGNvbm5lY3Rpb25JZCk7XG4gICAgLy8gMTAvMTAvMjAxNDogbG9va3MgbGlrZSBpbiBDaHJvbWUgMzgsIG9uYWRkc3RyZWFtIGlzIHRyaWdnZXJlZCBhZnRlclxuICAgIC8vIHNldHRpbmcgdGhlIHJlbW90ZSBkZXNjcmlwdGlvbi4gT3VyIGNvbm5lY3Rpb24gb2JqZWN0IGluIHRoZXNlIGNhc2VzXG4gICAgLy8gaXMgYWN0dWFsbHkgYSBEQVRBIGNvbm5lY3Rpb24sIHNvIGFkZFN0cmVhbSBmYWlscy5cbiAgICAvLyBUT0RPOiBUaGlzIGlzIGhvcGVmdWxseSBqdXN0IGEgdGVtcG9yYXJ5IGZpeC4gV2Ugc2hvdWxkIHRyeSB0b1xuICAgIC8vIHVuZGVyc3RhbmQgd2h5IHRoaXMgaXMgaGFwcGVuaW5nLlxuICAgIGlmIChjb25uZWN0aW9uLnR5cGUgPT09ICdtZWRpYScpIHtcbiAgICAgIGNvbm5lY3Rpb24uYWRkU3RyZWFtKHN0cmVhbSk7XG4gICAgfVxuICB9O1xufVxuXG5OZWdvdGlhdG9yLmNsZWFudXAgPSBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gIHV0aWwubG9nKCdDbGVhbmluZyB1cCBQZWVyQ29ubmVjdGlvbiB0byAnICsgY29ubmVjdGlvbi5wZWVyKTtcblxuICB2YXIgcGMgPSBjb25uZWN0aW9uLnBjO1xuXG4gIGlmICghIXBjICYmIChwYy5yZWFkeVN0YXRlICE9PSAnY2xvc2VkJyB8fCBwYy5zaWduYWxpbmdTdGF0ZSAhPT0gJ2Nsb3NlZCcpKSB7XG4gICAgcGMuY2xvc2UoKTtcbiAgICBjb25uZWN0aW9uLnBjID0gbnVsbDtcbiAgfVxufVxuXG5OZWdvdGlhdG9yLl9tYWtlT2ZmZXIgPSBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gIHZhciBwYyA9IGNvbm5lY3Rpb24ucGM7XG4gIHBjLmNyZWF0ZU9mZmVyKGZ1bmN0aW9uKG9mZmVyKSB7XG4gICAgdXRpbC5sb2coJ0NyZWF0ZWQgb2ZmZXIuJyk7XG5cbiAgICBpZiAoIXV0aWwuc3VwcG9ydHMuc2N0cCAmJiBjb25uZWN0aW9uLnR5cGUgPT09ICdkYXRhJyAmJiBjb25uZWN0aW9uLnJlbGlhYmxlKSB7XG4gICAgICBvZmZlci5zZHAgPSBSZWxpYWJsZS5oaWdoZXJCYW5kd2lkdGhTRFAob2ZmZXIuc2RwKTtcbiAgICB9XG5cbiAgICBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyLCBmdW5jdGlvbigpIHtcbiAgICAgIHV0aWwubG9nKCdTZXQgbG9jYWxEZXNjcmlwdGlvbjogb2ZmZXInLCAnZm9yOicsIGNvbm5lY3Rpb24ucGVlcik7XG4gICAgICBjb25uZWN0aW9uLnByb3ZpZGVyLnNvY2tldC5zZW5kKHtcbiAgICAgICAgdHlwZTogJ09GRkVSJyxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIHNkcDogb2ZmZXIsXG4gICAgICAgICAgdHlwZTogY29ubmVjdGlvbi50eXBlLFxuICAgICAgICAgIGxhYmVsOiBjb25uZWN0aW9uLmxhYmVsLFxuICAgICAgICAgIGNvbm5lY3Rpb25JZDogY29ubmVjdGlvbi5pZCxcbiAgICAgICAgICByZWxpYWJsZTogY29ubmVjdGlvbi5yZWxpYWJsZSxcbiAgICAgICAgICBzZXJpYWxpemF0aW9uOiBjb25uZWN0aW9uLnNlcmlhbGl6YXRpb24sXG4gICAgICAgICAgbWV0YWRhdGE6IGNvbm5lY3Rpb24ubWV0YWRhdGEsXG4gICAgICAgICAgYnJvd3NlcjogdXRpbC5icm93c2VyXG4gICAgICAgIH0sXG4gICAgICAgIGRzdDogY29ubmVjdGlvbi5wZWVyXG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGNvbm5lY3Rpb24ucHJvdmlkZXIuZW1pdEVycm9yKCd3ZWJydGMnLCBlcnIpO1xuICAgICAgdXRpbC5sb2coJ0ZhaWxlZCB0byBzZXRMb2NhbERlc2NyaXB0aW9uLCAnLCBlcnIpO1xuICAgIH0pO1xuICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICBjb25uZWN0aW9uLnByb3ZpZGVyLmVtaXRFcnJvcignd2VicnRjJywgZXJyKTtcbiAgICB1dGlsLmxvZygnRmFpbGVkIHRvIGNyZWF0ZU9mZmVyLCAnLCBlcnIpO1xuICB9LCBjb25uZWN0aW9uLm9wdGlvbnMuY29uc3RyYWludHMpO1xufVxuXG5OZWdvdGlhdG9yLl9tYWtlQW5zd2VyID0gZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICB2YXIgcGMgPSBjb25uZWN0aW9uLnBjO1xuXG4gIHBjLmNyZWF0ZUFuc3dlcihmdW5jdGlvbihhbnN3ZXIpIHtcbiAgICB1dGlsLmxvZygnQ3JlYXRlZCBhbnN3ZXIuJyk7XG5cbiAgICBpZiAoIXV0aWwuc3VwcG9ydHMuc2N0cCAmJiBjb25uZWN0aW9uLnR5cGUgPT09ICdkYXRhJyAmJiBjb25uZWN0aW9uLnJlbGlhYmxlKSB7XG4gICAgICBhbnN3ZXIuc2RwID0gUmVsaWFibGUuaGlnaGVyQmFuZHdpZHRoU0RQKGFuc3dlci5zZHApO1xuICAgIH1cblxuICAgIHBjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyLCBmdW5jdGlvbigpIHtcbiAgICAgIHV0aWwubG9nKCdTZXQgbG9jYWxEZXNjcmlwdGlvbjogYW5zd2VyJywgJ2ZvcjonLCBjb25uZWN0aW9uLnBlZXIpO1xuICAgICAgY29ubmVjdGlvbi5wcm92aWRlci5zb2NrZXQuc2VuZCh7XG4gICAgICAgIHR5cGU6ICdBTlNXRVInLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgc2RwOiBhbnN3ZXIsXG4gICAgICAgICAgdHlwZTogY29ubmVjdGlvbi50eXBlLFxuICAgICAgICAgIGNvbm5lY3Rpb25JZDogY29ubmVjdGlvbi5pZCxcbiAgICAgICAgICBicm93c2VyOiB1dGlsLmJyb3dzZXJcbiAgICAgICAgfSxcbiAgICAgICAgZHN0OiBjb25uZWN0aW9uLnBlZXJcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgY29ubmVjdGlvbi5wcm92aWRlci5lbWl0RXJyb3IoJ3dlYnJ0YycsIGVycik7XG4gICAgICB1dGlsLmxvZygnRmFpbGVkIHRvIHNldExvY2FsRGVzY3JpcHRpb24sICcsIGVycik7XG4gICAgfSk7XG4gIH0sIGZ1bmN0aW9uKGVycikge1xuICAgIGNvbm5lY3Rpb24ucHJvdmlkZXIuZW1pdEVycm9yKCd3ZWJydGMnLCBlcnIpO1xuICAgIHV0aWwubG9nKCdGYWlsZWQgdG8gY3JlYXRlIGFuc3dlciwgJywgZXJyKTtcbiAgfSk7XG59XG5cbi8qKiBIYW5kbGUgYW4gU0RQLiAqL1xuTmVnb3RpYXRvci5oYW5kbGVTRFAgPSBmdW5jdGlvbih0eXBlLCBjb25uZWN0aW9uLCBzZHApIHtcbiAgc2RwID0gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbihzZHApO1xuICB2YXIgcGMgPSBjb25uZWN0aW9uLnBjO1xuXG4gIHV0aWwubG9nKCdTZXR0aW5nIHJlbW90ZSBkZXNjcmlwdGlvbicsIHNkcCk7XG4gIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkcCwgZnVuY3Rpb24oKSB7XG4gICAgdXRpbC5sb2coJ1NldCByZW1vdGVEZXNjcmlwdGlvbjonLCB0eXBlLCAnZm9yOicsIGNvbm5lY3Rpb24ucGVlcik7XG5cbiAgICBpZiAodHlwZSA9PT0gJ09GRkVSJykge1xuICAgICAgTmVnb3RpYXRvci5fbWFrZUFuc3dlcihjb25uZWN0aW9uKTtcbiAgICB9XG4gIH0sIGZ1bmN0aW9uKGVycikge1xuICAgIGNvbm5lY3Rpb24ucHJvdmlkZXIuZW1pdEVycm9yKCd3ZWJydGMnLCBlcnIpO1xuICAgIHV0aWwubG9nKCdGYWlsZWQgdG8gc2V0UmVtb3RlRGVzY3JpcHRpb24sICcsIGVycik7XG4gIH0pO1xufVxuXG4vKiogSGFuZGxlIGEgY2FuZGlkYXRlLiAqL1xuTmVnb3RpYXRvci5oYW5kbGVDYW5kaWRhdGUgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBpY2UpIHtcbiAgdmFyIGNhbmRpZGF0ZSA9IGljZS5jYW5kaWRhdGU7XG4gIHZhciBzZHBNTGluZUluZGV4ID0gaWNlLnNkcE1MaW5lSW5kZXg7XG4gIGNvbm5lY3Rpb24ucGMuYWRkSWNlQ2FuZGlkYXRlKG5ldyBSVENJY2VDYW5kaWRhdGUoe1xuICAgIHNkcE1MaW5lSW5kZXg6IHNkcE1MaW5lSW5kZXgsXG4gICAgY2FuZGlkYXRlOiBjYW5kaWRhdGVcbiAgfSkpO1xuICB1dGlsLmxvZygnQWRkZWQgSUNFIGNhbmRpZGF0ZSBmb3I6JywgY29ubmVjdGlvbi5wZWVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOZWdvdGlhdG9yO1xuXG59LHtcIi4vYWRhcHRlclwiOjEsXCIuL3V0aWxcIjo4fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKTtcbnZhciBTb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xudmFyIE1lZGlhQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vbWVkaWFjb25uZWN0aW9uJyk7XG52YXIgRGF0YUNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL2RhdGFjb25uZWN0aW9uJyk7XG5cbi8qKlxuICogQSBwZWVyIHdobyBjYW4gaW5pdGlhdGUgY29ubmVjdGlvbnMgd2l0aCBvdGhlciBwZWVycy5cbiAqL1xuZnVuY3Rpb24gUGVlcihpZCwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGVlcikpIHJldHVybiBuZXcgUGVlcihpZCwgb3B0aW9ucyk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIC8vIERlYWwgd2l0aCBvdmVybG9hZGluZ1xuICBpZiAoaWQgJiYgaWQuY29uc3RydWN0b3IgPT0gT2JqZWN0KSB7XG4gICAgb3B0aW9ucyA9IGlkO1xuICAgIGlkID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKGlkKSB7XG4gICAgLy8gRW5zdXJlIGlkIGlzIGEgc3RyaW5nXG4gICAgaWQgPSBpZC50b1N0cmluZygpO1xuICB9XG4gIC8vXG5cbiAgLy8gQ29uZmlndXJpemUgb3B0aW9uc1xuICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgIGRlYnVnOiAwLCAvLyAxOiBFcnJvcnMsIDI6IFdhcm5pbmdzLCAzOiBBbGwgbG9nc1xuICAgIGhvc3Q6IHV0aWwuQ0xPVURfSE9TVCxcbiAgICBwb3J0OiB1dGlsLkNMT1VEX1BPUlQsXG4gICAga2V5OiAncGVlcmpzJyxcbiAgICBwYXRoOiAnLycsXG4gICAgdG9rZW46IHV0aWwucmFuZG9tVG9rZW4oKSxcbiAgICBjb25maWc6IHV0aWwuZGVmYXVsdENvbmZpZ1xuICB9LCBvcHRpb25zKTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgLy8gRGV0ZWN0IHJlbGF0aXZlIFVSTCBob3N0LlxuICBpZiAob3B0aW9ucy5ob3N0ID09PSAnLycpIHtcbiAgICBvcHRpb25zLmhvc3QgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG4gIH1cbiAgLy8gU2V0IHBhdGggY29ycmVjdGx5LlxuICBpZiAob3B0aW9ucy5wYXRoWzBdICE9PSAnLycpIHtcbiAgICBvcHRpb25zLnBhdGggPSAnLycgKyBvcHRpb25zLnBhdGg7XG4gIH1cbiAgaWYgKG9wdGlvbnMucGF0aFtvcHRpb25zLnBhdGgubGVuZ3RoIC0gMV0gIT09ICcvJykge1xuICAgIG9wdGlvbnMucGF0aCArPSAnLyc7XG4gIH1cblxuICAvLyBTZXQgd2hldGhlciB3ZSB1c2UgU1NMIHRvIHNhbWUgYXMgY3VycmVudCBob3N0XG4gIGlmIChvcHRpb25zLnNlY3VyZSA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuaG9zdCAhPT0gdXRpbC5DTE9VRF9IT1NUKSB7XG4gICAgb3B0aW9ucy5zZWN1cmUgPSB1dGlsLmlzU2VjdXJlKCk7XG4gIH1cbiAgLy8gU2V0IGEgY3VzdG9tIGxvZyBmdW5jdGlvbiBpZiBwcmVzZW50XG4gIGlmIChvcHRpb25zLmxvZ0Z1bmN0aW9uKSB7XG4gICAgdXRpbC5zZXRMb2dGdW5jdGlvbihvcHRpb25zLmxvZ0Z1bmN0aW9uKTtcbiAgfVxuICB1dGlsLnNldExvZ0xldmVsKG9wdGlvbnMuZGVidWcpO1xuICAvL1xuXG4gIC8vIFNhbml0eSBjaGVja3NcbiAgLy8gRW5zdXJlIFdlYlJUQyBzdXBwb3J0ZWRcbiAgaWYgKCF1dGlsLnN1cHBvcnRzLmF1ZGlvVmlkZW8gJiYgIXV0aWwuc3VwcG9ydHMuZGF0YSApIHtcbiAgICB0aGlzLl9kZWxheWVkQWJvcnQoJ2Jyb3dzZXItaW5jb21wYXRpYmxlJywgJ1RoZSBjdXJyZW50IGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJSVEMnKTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gRW5zdXJlIGFscGhhbnVtZXJpYyBpZFxuICBpZiAoIXV0aWwudmFsaWRhdGVJZChpZCkpIHtcbiAgICB0aGlzLl9kZWxheWVkQWJvcnQoJ2ludmFsaWQtaWQnLCAnSUQgXCInICsgaWQgKyAnXCIgaXMgaW52YWxpZCcpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBFbnN1cmUgdmFsaWQga2V5XG4gIGlmICghdXRpbC52YWxpZGF0ZUtleShvcHRpb25zLmtleSkpIHtcbiAgICB0aGlzLl9kZWxheWVkQWJvcnQoJ2ludmFsaWQta2V5JywgJ0FQSSBLRVkgXCInICsgb3B0aW9ucy5rZXkgKyAnXCIgaXMgaW52YWxpZCcpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBFbnN1cmUgbm90IHVzaW5nIHVuc2VjdXJlIGNsb3VkIHNlcnZlciBvbiBTU0wgcGFnZVxuICBpZiAob3B0aW9ucy5zZWN1cmUgJiYgb3B0aW9ucy5ob3N0ID09PSAnMC5wZWVyanMuY29tJykge1xuICAgIHRoaXMuX2RlbGF5ZWRBYm9ydCgnc3NsLXVuYXZhaWxhYmxlJyxcbiAgICAgICdUaGUgY2xvdWQgc2VydmVyIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IEhUVFBTLiBQbGVhc2UgcnVuIHlvdXIgb3duIFBlZXJTZXJ2ZXIgdG8gdXNlIEhUVFBTLicpO1xuICAgIHJldHVybjtcbiAgfVxuICAvL1xuXG4gIC8vIFN0YXRlcy5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gQ29ubmVjdGlvbnMgaGF2ZSBiZWVuIGtpbGxlZFxuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IGZhbHNlOyAvLyBDb25uZWN0aW9uIHRvIFBlZXJTZXJ2ZXIga2lsbGVkIGJ1dCBQMlAgY29ubmVjdGlvbnMgc3RpbGwgYWN0aXZlXG4gIHRoaXMub3BlbiA9IGZhbHNlOyAvLyBTb2NrZXRzIGFuZCBzdWNoIGFyZSBub3QgeWV0IG9wZW4uXG4gIC8vXG5cbiAgLy8gUmVmZXJlbmNlc1xuICB0aGlzLmNvbm5lY3Rpb25zID0ge307IC8vIERhdGFDb25uZWN0aW9ucyBmb3IgdGhpcyBwZWVyLlxuICB0aGlzLl9sb3N0TWVzc2FnZXMgPSB7fTsgLy8gc3JjID0+IFtsaXN0IG9mIG1lc3NhZ2VzXVxuICAvL1xuXG4gIC8vIFN0YXJ0IHRoZSBzZXJ2ZXIgY29ubmVjdGlvblxuICB0aGlzLl9pbml0aWFsaXplU2VydmVyQ29ubmVjdGlvbigpO1xuICBpZiAoaWQpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplKGlkKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9yZXRyaWV2ZUlkKCk7XG4gIH1cbiAgLy9cbn1cblxudXRpbC5pbmhlcml0cyhQZWVyLCBFdmVudEVtaXR0ZXIpO1xuXG4vLyBJbml0aWFsaXplIHRoZSAnc29ja2V0JyAod2hpY2ggaXMgYWN0dWFsbHkgYSBtaXggb2YgWEhSIHN0cmVhbWluZyBhbmRcbi8vIHdlYnNvY2tldHMuKVxuUGVlci5wcm90b3R5cGUuX2luaXRpYWxpemVTZXJ2ZXJDb25uZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMub3B0aW9ucy5zZWN1cmUsIHRoaXMub3B0aW9ucy5ob3N0LCB0aGlzLm9wdGlvbnMucG9ydCwgdGhpcy5vcHRpb25zLnBhdGgsIHRoaXMub3B0aW9ucy5rZXkpO1xuICB0aGlzLnNvY2tldC5vbignbWVzc2FnZScsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBzZWxmLl9oYW5kbGVNZXNzYWdlKGRhdGEpO1xuICB9KTtcbiAgdGhpcy5zb2NrZXQub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBzZWxmLl9hYm9ydCgnc29ja2V0LWVycm9yJywgZXJyb3IpO1xuICB9KTtcbiAgdGhpcy5zb2NrZXQub24oJ2Rpc2Nvbm5lY3RlZCcsIGZ1bmN0aW9uKCkge1xuICAgIC8vIElmIHdlIGhhdmVuJ3QgZXhwbGljaXRseSBkaXNjb25uZWN0ZWQsIGVtaXQgZXJyb3IgYW5kIGRpc2Nvbm5lY3QuXG4gICAgaWYgKCFzZWxmLmRpc2Nvbm5lY3RlZCkge1xuICAgICAgc2VsZi5lbWl0RXJyb3IoJ25ldHdvcmsnLCAnTG9zdCBjb25uZWN0aW9uIHRvIHNlcnZlci4nKTtcbiAgICAgIHNlbGYuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfSk7XG4gIHRoaXMuc29ja2V0Lm9uKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgIC8vIElmIHdlIGhhdmVuJ3QgZXhwbGljaXRseSBkaXNjb25uZWN0ZWQsIGVtaXQgZXJyb3IuXG4gICAgaWYgKCFzZWxmLmRpc2Nvbm5lY3RlZCkge1xuICAgICAgc2VsZi5fYWJvcnQoJ3NvY2tldC1jbG9zZWQnLCAnVW5kZXJseWluZyBzb2NrZXQgaXMgYWxyZWFkeSBjbG9zZWQuJyk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKiBHZXQgYSB1bmlxdWUgSUQgZnJvbSB0aGUgc2VydmVyIHZpYSBYSFIuICovXG5QZWVyLnByb3RvdHlwZS5fcmV0cmlldmVJZCA9IGZ1bmN0aW9uKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgdmFyIHByb3RvY29sID0gdGhpcy5vcHRpb25zLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLyc7XG4gIHZhciB1cmwgPSBwcm90b2NvbCArIHRoaXMub3B0aW9ucy5ob3N0ICsgJzonICsgdGhpcy5vcHRpb25zLnBvcnQgK1xuICAgIHRoaXMub3B0aW9ucy5wYXRoICsgdGhpcy5vcHRpb25zLmtleSArICcvaWQnO1xuICB2YXIgcXVlcnlTdHJpbmcgPSAnP3RzPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSArICcnICsgTWF0aC5yYW5kb20oKTtcbiAgdXJsICs9IHF1ZXJ5U3RyaW5nO1xuXG4gIC8vIElmIHRoZXJlJ3Mgbm8gSUQgd2UgbmVlZCB0byB3YWl0IGZvciBvbmUgYmVmb3JlIHRyeWluZyB0byBpbml0IHNvY2tldC5cbiAgaHR0cC5vcGVuKCdnZXQnLCB1cmwsIHRydWUpO1xuICBodHRwLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgdXRpbC5lcnJvcignRXJyb3IgcmV0cmlldmluZyBJRCcsIGUpO1xuICAgIHZhciBwYXRoRXJyb3IgPSAnJztcbiAgICBpZiAoc2VsZi5vcHRpb25zLnBhdGggPT09ICcvJyAmJiBzZWxmLm9wdGlvbnMuaG9zdCAhPT0gdXRpbC5DTE9VRF9IT1NUKSB7XG4gICAgICBwYXRoRXJyb3IgPSAnIElmIHlvdSBwYXNzZWQgaW4gYSBgcGF0aGAgdG8geW91ciBzZWxmLWhvc3RlZCBQZWVyU2VydmVyLCAnICtcbiAgICAgICAgJ3lvdVxcJ2xsIGFsc28gbmVlZCB0byBwYXNzIGluIHRoYXQgc2FtZSBwYXRoIHdoZW4gY3JlYXRpbmcgYSBuZXcgJyArXG4gICAgICAgICdQZWVyLic7XG4gICAgfVxuICAgIHNlbGYuX2Fib3J0KCdzZXJ2ZXItZXJyb3InLCAnQ291bGQgbm90IGdldCBhbiBJRCBmcm9tIHRoZSBzZXJ2ZXIuJyArIHBhdGhFcnJvcik7XG4gIH07XG4gIGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGh0dHAucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaHR0cC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgaHR0cC5vbmVycm9yKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuX2luaXRpYWxpemUoaHR0cC5yZXNwb25zZVRleHQpO1xuICB9O1xuICBodHRwLnNlbmQobnVsbCk7XG59O1xuXG4vKiogSW5pdGlhbGl6ZSBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgc2VydmVyLiAqL1xuUGVlci5wcm90b3R5cGUuX2luaXRpYWxpemUgPSBmdW5jdGlvbihpZCkge1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuc29ja2V0LnN0YXJ0KHRoaXMuaWQsIHRoaXMub3B0aW9ucy50b2tlbik7XG59O1xuXG4vKiogSGFuZGxlcyBtZXNzYWdlcyBmcm9tIHRoZSBzZXJ2ZXIuICovXG5QZWVyLnByb3RvdHlwZS5faGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgdmFyIHR5cGUgPSBtZXNzYWdlLnR5cGU7XG4gIHZhciBwYXlsb2FkID0gbWVzc2FnZS5wYXlsb2FkO1xuICB2YXIgcGVlciA9IG1lc3NhZ2Uuc3JjO1xuICB2YXIgY29ubmVjdGlvbjtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdPUEVOJzogLy8gVGhlIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciBpcyBvcGVuLlxuICAgICAgdGhpcy5lbWl0KCdvcGVuJywgdGhpcy5pZCk7XG4gICAgICB0aGlzLm9wZW4gPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnRVJST1InOiAvLyBTZXJ2ZXIgZXJyb3IuXG4gICAgICB0aGlzLl9hYm9ydCgnc2VydmVyLWVycm9yJywgcGF5bG9hZC5tc2cpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnSUQtVEFLRU4nOiAvLyBUaGUgc2VsZWN0ZWQgSUQgaXMgdGFrZW4uXG4gICAgICB0aGlzLl9hYm9ydCgndW5hdmFpbGFibGUtaWQnLCAnSUQgYCcgKyB0aGlzLmlkICsgJ2AgaXMgdGFrZW4nKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0lOVkFMSUQtS0VZJzogLy8gVGhlIGdpdmVuIEFQSSBrZXkgY2Fubm90IGJlIGZvdW5kLlxuICAgICAgdGhpcy5fYWJvcnQoJ2ludmFsaWQta2V5JywgJ0FQSSBLRVkgXCInICsgdGhpcy5vcHRpb25zLmtleSArICdcIiBpcyBpbnZhbGlkJyk7XG4gICAgICBicmVhaztcblxuICAgIC8vXG4gICAgY2FzZSAnTEVBVkUnOiAvLyBBbm90aGVyIHBlZXIgaGFzIGNsb3NlZCBpdHMgY29ubmVjdGlvbiB0byB0aGlzIHBlZXIuXG4gICAgICB1dGlsLmxvZygnUmVjZWl2ZWQgbGVhdmUgbWVzc2FnZSBmcm9tJywgcGVlcik7XG4gICAgICB0aGlzLl9jbGVhbnVwUGVlcihwZWVyKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnRVhQSVJFJzogLy8gVGhlIG9mZmVyIHNlbnQgdG8gYSBwZWVyIGhhcyBleHBpcmVkIHdpdGhvdXQgcmVzcG9uc2UuXG4gICAgICB0aGlzLmVtaXRFcnJvcigncGVlci11bmF2YWlsYWJsZScsICdDb3VsZCBub3QgY29ubmVjdCB0byBwZWVyICcgKyBwZWVyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ09GRkVSJzogLy8gd2Ugc2hvdWxkIGNvbnNpZGVyIHN3aXRjaGluZyB0aGlzIHRvIENBTEwvQ09OTkVDVCwgYnV0IHRoaXMgaXMgdGhlIGxlYXN0IGJyZWFraW5nIG9wdGlvbi5cbiAgICAgIHZhciBjb25uZWN0aW9uSWQgPSBwYXlsb2FkLmNvbm5lY3Rpb25JZDtcbiAgICAgIGNvbm5lY3Rpb24gPSB0aGlzLmdldENvbm5lY3Rpb24ocGVlciwgY29ubmVjdGlvbklkKTtcblxuICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgdXRpbC53YXJuKCdPZmZlciByZWNlaXZlZCBmb3IgZXhpc3RpbmcgQ29ubmVjdGlvbiBJRDonLCBjb25uZWN0aW9uSWQpO1xuICAgICAgICAvL2Nvbm5lY3Rpb24uaGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb25uZWN0aW9uLlxuICAgICAgICBpZiAocGF5bG9hZC50eXBlID09PSAnbWVkaWEnKSB7XG4gICAgICAgICAgY29ubmVjdGlvbiA9IG5ldyBNZWRpYUNvbm5lY3Rpb24ocGVlciwgdGhpcywge1xuICAgICAgICAgICAgY29ubmVjdGlvbklkOiBjb25uZWN0aW9uSWQsXG4gICAgICAgICAgICBfcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBwYXlsb2FkLm1ldGFkYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5fYWRkQ29ubmVjdGlvbihwZWVyLCBjb25uZWN0aW9uKTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2NhbGwnLCBjb25uZWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkLnR5cGUgPT09ICdkYXRhJykge1xuICAgICAgICAgIGNvbm5lY3Rpb24gPSBuZXcgRGF0YUNvbm5lY3Rpb24ocGVlciwgdGhpcywge1xuICAgICAgICAgICAgY29ubmVjdGlvbklkOiBjb25uZWN0aW9uSWQsXG4gICAgICAgICAgICBfcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBwYXlsb2FkLm1ldGFkYXRhLFxuICAgICAgICAgICAgbGFiZWw6IHBheWxvYWQubGFiZWwsXG4gICAgICAgICAgICBzZXJpYWxpemF0aW9uOiBwYXlsb2FkLnNlcmlhbGl6YXRpb24sXG4gICAgICAgICAgICByZWxpYWJsZTogcGF5bG9hZC5yZWxpYWJsZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX2FkZENvbm5lY3Rpb24ocGVlciwgY29ubmVjdGlvbik7XG4gICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0aW9uJywgY29ubmVjdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXRpbC53YXJuKCdSZWNlaXZlZCBtYWxmb3JtZWQgY29ubmVjdGlvbiB0eXBlOicsIHBheWxvYWQudHlwZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgbWVzc2FnZXMuXG4gICAgICAgIHZhciBtZXNzYWdlcyA9IHRoaXMuX2dldE1lc3NhZ2VzKGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG1lc3NhZ2VzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDEpIHtcbiAgICAgICAgICBjb25uZWN0aW9uLmhhbmRsZU1lc3NhZ2UobWVzc2FnZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKCFwYXlsb2FkKSB7XG4gICAgICAgIHV0aWwud2FybignWW91IHJlY2VpdmVkIGEgbWFsZm9ybWVkIG1lc3NhZ2UgZnJvbSAnICsgcGVlciArICcgb2YgdHlwZSAnICsgdHlwZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkID0gcGF5bG9hZC5jb25uZWN0aW9uSWQ7XG4gICAgICBjb25uZWN0aW9uID0gdGhpcy5nZXRDb25uZWN0aW9uKHBlZXIsIGlkKTtcblxuICAgICAgaWYgKGNvbm5lY3Rpb24gJiYgY29ubmVjdGlvbi5wYykge1xuICAgICAgICAvLyBQYXNzIGl0IG9uLlxuICAgICAgICBjb25uZWN0aW9uLmhhbmRsZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICB9IGVsc2UgaWYgKGlkKSB7XG4gICAgICAgIC8vIFN0b3JlIGZvciBwb3NzaWJsZSBsYXRlciB1c2VcbiAgICAgICAgdGhpcy5fc3RvcmVNZXNzYWdlKGlkLCBtZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwud2FybignWW91IHJlY2VpdmVkIGFuIHVucmVjb2duaXplZCBtZXNzYWdlOicsIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKiBTdG9yZXMgbWVzc2FnZXMgd2l0aG91dCBhIHNldCB1cCBjb25uZWN0aW9uLCB0byBiZSBjbGFpbWVkIGxhdGVyLiAqL1xuUGVlci5wcm90b3R5cGUuX3N0b3JlTWVzc2FnZSA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25JZCwgbWVzc2FnZSkge1xuICBpZiAoIXRoaXMuX2xvc3RNZXNzYWdlc1tjb25uZWN0aW9uSWRdKSB7XG4gICAgdGhpcy5fbG9zdE1lc3NhZ2VzW2Nvbm5lY3Rpb25JZF0gPSBbXTtcbiAgfVxuICB0aGlzLl9sb3N0TWVzc2FnZXNbY29ubmVjdGlvbklkXS5wdXNoKG1lc3NhZ2UpO1xufTtcblxuLyoqIFJldHJpZXZlIG1lc3NhZ2VzIGZyb20gbG9zdCBtZXNzYWdlIHN0b3JlICovXG5QZWVyLnByb3RvdHlwZS5fZ2V0TWVzc2FnZXMgPSBmdW5jdGlvbihjb25uZWN0aW9uSWQpIHtcbiAgdmFyIG1lc3NhZ2VzID0gdGhpcy5fbG9zdE1lc3NhZ2VzW2Nvbm5lY3Rpb25JZF07XG4gIGlmIChtZXNzYWdlcykge1xuICAgIGRlbGV0ZSB0aGlzLl9sb3N0TWVzc2FnZXNbY29ubmVjdGlvbklkXTtcbiAgICByZXR1cm4gbWVzc2FnZXM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBEYXRhQ29ubmVjdGlvbiB0byB0aGUgc3BlY2lmaWVkIHBlZXIuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBhXG4gKiBjb21wbGV0ZSBsaXN0IG9mIG9wdGlvbnMuXG4gKi9cblBlZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihwZWVyLCBvcHRpb25zKSB7XG4gIGlmICh0aGlzLmRpc2Nvbm5lY3RlZCkge1xuICAgIHV0aWwud2FybignWW91IGNhbm5vdCBjb25uZWN0IHRvIGEgbmV3IFBlZXIgYmVjYXVzZSB5b3UgY2FsbGVkICcgK1xuICAgICAgJy5kaXNjb25uZWN0KCkgb24gdGhpcyBQZWVyIGFuZCBlbmRlZCB5b3VyIGNvbm5lY3Rpb24gd2l0aCB0aGUgJyArXG4gICAgICAnc2VydmVyLiBZb3UgY2FuIGNyZWF0ZSBhIG5ldyBQZWVyIHRvIHJlY29ubmVjdCwgb3IgY2FsbCByZWNvbm5lY3QgJyArXG4gICAgICAnb24gdGhpcyBwZWVyIGlmIHlvdSBiZWxpZXZlIGl0cyBJRCB0byBzdGlsbCBiZSBhdmFpbGFibGUuJyk7XG4gICAgdGhpcy5lbWl0RXJyb3IoJ2Rpc2Nvbm5lY3RlZCcsICdDYW5ub3QgY29ubmVjdCB0byBuZXcgUGVlciBhZnRlciBkaXNjb25uZWN0aW5nIGZyb20gc2VydmVyLicpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY29ubmVjdGlvbiA9IG5ldyBEYXRhQ29ubmVjdGlvbihwZWVyLCB0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5fYWRkQ29ubmVjdGlvbihwZWVyLCBjb25uZWN0aW9uKTtcbiAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBNZWRpYUNvbm5lY3Rpb24gdG8gdGhlIHNwZWNpZmllZCBwZWVyLiBTZWUgZG9jdW1lbnRhdGlvbiBmb3IgYVxuICogY29tcGxldGUgbGlzdCBvZiBvcHRpb25zLlxuICovXG5QZWVyLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24ocGVlciwgc3RyZWFtLCBvcHRpb25zKSB7XG4gIGlmICh0aGlzLmRpc2Nvbm5lY3RlZCkge1xuICAgIHV0aWwud2FybignWW91IGNhbm5vdCBjb25uZWN0IHRvIGEgbmV3IFBlZXIgYmVjYXVzZSB5b3UgY2FsbGVkICcgK1xuICAgICAgJy5kaXNjb25uZWN0KCkgb24gdGhpcyBQZWVyIGFuZCBlbmRlZCB5b3VyIGNvbm5lY3Rpb24gd2l0aCB0aGUgJyArXG4gICAgICAnc2VydmVyLiBZb3UgY2FuIGNyZWF0ZSBhIG5ldyBQZWVyIHRvIHJlY29ubmVjdC4nKTtcbiAgICB0aGlzLmVtaXRFcnJvcignZGlzY29ubmVjdGVkJywgJ0Nhbm5vdCBjb25uZWN0IHRvIG5ldyBQZWVyIGFmdGVyIGRpc2Nvbm5lY3RpbmcgZnJvbSBzZXJ2ZXIuJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghc3RyZWFtKSB7XG4gICAgdXRpbC5lcnJvcignVG8gY2FsbCBhIHBlZXIsIHlvdSBtdXN0IHByb3ZpZGUgYSBzdHJlYW0gZnJvbSB5b3VyIGJyb3dzZXJcXCdzIGBnZXRVc2VyTWVkaWFgLicpO1xuICAgIHJldHVybjtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5fc3RyZWFtID0gc3RyZWFtO1xuICB2YXIgY2FsbCA9IG5ldyBNZWRpYUNvbm5lY3Rpb24ocGVlciwgdGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuX2FkZENvbm5lY3Rpb24ocGVlciwgY2FsbCk7XG4gIHJldHVybiBjYWxsO1xufTtcblxuLyoqIEFkZCBhIGRhdGEvbWVkaWEgY29ubmVjdGlvbiB0byB0aGlzIHBlZXIuICovXG5QZWVyLnByb3RvdHlwZS5fYWRkQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKHBlZXIsIGNvbm5lY3Rpb24pIHtcbiAgaWYgKCF0aGlzLmNvbm5lY3Rpb25zW3BlZXJdKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uc1twZWVyXSA9IFtdO1xuICB9XG4gIHRoaXMuY29ubmVjdGlvbnNbcGVlcl0ucHVzaChjb25uZWN0aW9uKTtcbn07XG5cbi8qKiBSZXRyaWV2ZSBhIGRhdGEvbWVkaWEgY29ubmVjdGlvbiBmb3IgdGhpcyBwZWVyLiAqL1xuUGVlci5wcm90b3R5cGUuZ2V0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKHBlZXIsIGlkKSB7XG4gIHZhciBjb25uZWN0aW9ucyA9IHRoaXMuY29ubmVjdGlvbnNbcGVlcl07XG4gIGlmICghY29ubmVjdGlvbnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb25uZWN0aW9ucy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgaWYgKGNvbm5lY3Rpb25zW2ldLmlkID09PSBpZCkge1xuICAgICAgcmV0dXJuIGNvbm5lY3Rpb25zW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cblBlZXIucHJvdG90eXBlLl9kZWxheWVkQWJvcnQgPSBmdW5jdGlvbih0eXBlLCBtZXNzYWdlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdXRpbC5zZXRaZXJvVGltZW91dChmdW5jdGlvbigpe1xuICAgIHNlbGYuX2Fib3J0KHR5cGUsIG1lc3NhZ2UpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIFBlZXIgYW5kIGVtaXRzIGFuIGVycm9yIG1lc3NhZ2UuXG4gKiBUaGUgUGVlciBpcyBub3QgZGVzdHJveWVkIGlmIGl0J3MgaW4gYSBkaXNjb25uZWN0ZWQgc3RhdGUsIGluIHdoaWNoIGNhc2VcbiAqIGl0IHJldGFpbnMgaXRzIGRpc2Nvbm5lY3RlZCBzdGF0ZSBhbmQgaXRzIGV4aXN0aW5nIGNvbm5lY3Rpb25zLlxuICovXG5QZWVyLnByb3RvdHlwZS5fYWJvcnQgPSBmdW5jdGlvbih0eXBlLCBtZXNzYWdlKSB7XG4gIHV0aWwuZXJyb3IoJ0Fib3J0aW5nIScpO1xuICBpZiAoIXRoaXMuX2xhc3RTZXJ2ZXJJZCkge1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICB9XG4gIHRoaXMuZW1pdEVycm9yKHR5cGUsIG1lc3NhZ2UpO1xufTtcblxuLyoqIEVtaXRzIGEgdHlwZWQgZXJyb3IgbWVzc2FnZS4gKi9cblBlZXIucHJvdG90eXBlLmVtaXRFcnJvciA9IGZ1bmN0aW9uKHR5cGUsIGVycikge1xuICB1dGlsLmVycm9yKCdFcnJvcjonLCBlcnIpO1xuICBpZiAodHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIHtcbiAgICBlcnIgPSBuZXcgRXJyb3IoZXJyKTtcbiAgfVxuICBlcnIudHlwZSA9IHR5cGU7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgUGVlcjogY2xvc2VzIGFsbCBhY3RpdmUgY29ubmVjdGlvbnMgYXMgd2VsbCBhcyB0aGUgY29ubmVjdGlvblxuICogIHRvIHRoZSBzZXJ2ZXIuXG4gKiBXYXJuaW5nOiBUaGUgcGVlciBjYW4gbm8gbG9uZ2VyIGNyZWF0ZSBvciBhY2NlcHQgY29ubmVjdGlvbnMgYWZ0ZXIgYmVpbmdcbiAqICBkZXN0cm95ZWQuXG4gKi9cblBlZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmRlc3Ryb3llZCkge1xuICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cbn07XG5cblxuLyoqIERpc2Nvbm5lY3RzIGV2ZXJ5IGNvbm5lY3Rpb24gb24gdGhpcyBwZWVyLiAqL1xuUGVlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY29ubmVjdGlvbnMpIHtcbiAgICB2YXIgcGVlcnMgPSBPYmplY3Qua2V5cyh0aGlzLmNvbm5lY3Rpb25zKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwZWVycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB0aGlzLl9jbGVhbnVwUGVlcihwZWVyc1tpXSk7XG4gICAgfVxuICB9XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG5cbi8qKiBDbG9zZXMgYWxsIGNvbm5lY3Rpb25zIHRvIHRoaXMgcGVlci4gKi9cblBlZXIucHJvdG90eXBlLl9jbGVhbnVwUGVlciA9IGZ1bmN0aW9uKHBlZXIpIHtcbiAgdmFyIGNvbm5lY3Rpb25zID0gdGhpcy5jb25uZWN0aW9uc1twZWVyXTtcbiAgZm9yICh2YXIgaiA9IDAsIGpqID0gY29ubmVjdGlvbnMubGVuZ3RoOyBqIDwgamo7IGogKz0gMSkge1xuICAgIGNvbm5lY3Rpb25zW2pdLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRGlzY29ubmVjdHMgdGhlIFBlZXIncyBjb25uZWN0aW9uIHRvIHRoZSBQZWVyU2VydmVyLiBEb2VzIG5vdCBjbG9zZSBhbnlcbiAqICBhY3RpdmUgY29ubmVjdGlvbnMuXG4gKiBXYXJuaW5nOiBUaGUgcGVlciBjYW4gbm8gbG9uZ2VyIGNyZWF0ZSBvciBhY2NlcHQgY29ubmVjdGlvbnMgYWZ0ZXIgYmVpbmdcbiAqICBkaXNjb25uZWN0ZWQuIEl0IGFsc28gY2Fubm90IHJlY29ubmVjdCB0byB0aGUgc2VydmVyLlxuICovXG5QZWVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdXRpbC5zZXRaZXJvVGltZW91dChmdW5jdGlvbigpe1xuICAgIGlmICghc2VsZi5kaXNjb25uZWN0ZWQpIHtcbiAgICAgIHNlbGYuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIHNlbGYub3BlbiA9IGZhbHNlO1xuICAgICAgaWYgKHNlbGYuc29ja2V0KSB7XG4gICAgICAgIHNlbGYuc29ja2V0LmNsb3NlKCk7XG4gICAgICB9XG4gICAgICBzZWxmLmVtaXQoJ2Rpc2Nvbm5lY3RlZCcsIHNlbGYuaWQpO1xuICAgICAgc2VsZi5fbGFzdFNlcnZlcklkID0gc2VsZi5pZDtcbiAgICAgIHNlbGYuaWQgPSBudWxsO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKiogQXR0ZW1wdHMgdG8gcmVjb25uZWN0IHdpdGggdGhlIHNhbWUgSUQuICovXG5QZWVyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuZGlzY29ubmVjdGVkICYmICF0aGlzLmRlc3Ryb3llZCkge1xuICAgIHV0aWwubG9nKCdBdHRlbXB0aW5nIHJlY29ubmVjdGlvbiB0byBzZXJ2ZXIgd2l0aCBJRCAnICsgdGhpcy5fbGFzdFNlcnZlcklkKTtcbiAgICB0aGlzLmRpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2luaXRpYWxpemVTZXJ2ZXJDb25uZWN0aW9uKCk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZSh0aGlzLl9sYXN0U2VydmVySWQpO1xuICB9IGVsc2UgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHBlZXIgY2Fubm90IHJlY29ubmVjdCB0byB0aGUgc2VydmVyLiBJdCBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZC4nKTtcbiAgfSBlbHNlIGlmICghdGhpcy5kaXNjb25uZWN0ZWQgJiYgIXRoaXMub3Blbikge1xuICAgIC8vIERvIG5vdGhpbmcuIFdlJ3JlIHN0aWxsIGNvbm5lY3RpbmcgdGhlIGZpcnN0IHRpbWUuXG4gICAgdXRpbC5lcnJvcignSW4gYSBodXJyeT8gV2VcXCdyZSBzdGlsbCB0cnlpbmcgdG8gbWFrZSB0aGUgaW5pdGlhbCBjb25uZWN0aW9uIScpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignUGVlciAnICsgdGhpcy5pZCArICcgY2Fubm90IHJlY29ubmVjdCBiZWNhdXNlIGl0IGlzIG5vdCBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgc2VydmVyIScpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBhIGxpc3Qgb2YgYXZhaWxhYmxlIHBlZXIgSURzLiBJZiB5b3UncmUgcnVubmluZyB5b3VyIG93biBzZXJ2ZXIsIHlvdSdsbFxuICogd2FudCB0byBzZXQgYWxsb3dfZGlzY292ZXJ5OiB0cnVlIGluIHRoZSBQZWVyU2VydmVyIG9wdGlvbnMuIElmIHlvdSdyZSB1c2luZ1xuICogdGhlIGNsb3VkIHNlcnZlciwgZW1haWwgdGVhbUBwZWVyanMuY29tIHRvIGdldCB0aGUgZnVuY3Rpb25hbGl0eSBlbmFibGVkIGZvclxuICogeW91ciBrZXkuXG4gKi9cblBlZXIucHJvdG90eXBlLmxpc3RBbGxQZWVycyA9IGZ1bmN0aW9uKGNiKSB7XG4gIGNiID0gY2IgfHwgZnVuY3Rpb24oKSB7fTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgaHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICB2YXIgcHJvdG9jb2wgPSB0aGlzLm9wdGlvbnMuc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJztcbiAgdmFyIHVybCA9IHByb3RvY29sICsgdGhpcy5vcHRpb25zLmhvc3QgKyAnOicgKyB0aGlzLm9wdGlvbnMucG9ydCArXG4gICAgdGhpcy5vcHRpb25zLnBhdGggKyB0aGlzLm9wdGlvbnMua2V5ICsgJy9wZWVycyc7XG4gIHZhciBxdWVyeVN0cmluZyA9ICc/dHM9JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgJycgKyBNYXRoLnJhbmRvbSgpO1xuICB1cmwgKz0gcXVlcnlTdHJpbmc7XG5cbiAgLy8gSWYgdGhlcmUncyBubyBJRCB3ZSBuZWVkIHRvIHdhaXQgZm9yIG9uZSBiZWZvcmUgdHJ5aW5nIHRvIGluaXQgc29ja2V0LlxuICBodHRwLm9wZW4oJ2dldCcsIHVybCwgdHJ1ZSk7XG4gIGh0dHAub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBzZWxmLl9hYm9ydCgnc2VydmVyLWVycm9yJywgJ0NvdWxkIG5vdCBnZXQgcGVlcnMgZnJvbSB0aGUgc2VydmVyLicpO1xuICAgIGNiKFtdKTtcbiAgfTtcbiAgaHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoaHR0cC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChodHRwLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICB2YXIgaGVscGZ1bEVycm9yID0gJyc7XG4gICAgICBpZiAoc2VsZi5vcHRpb25zLmhvc3QgIT09IHV0aWwuQ0xPVURfSE9TVCkge1xuICAgICAgICBoZWxwZnVsRXJyb3IgPSAnSXQgbG9va3MgbGlrZSB5b3VcXCdyZSB1c2luZyB0aGUgY2xvdWQgc2VydmVyLiBZb3UgY2FuIGVtYWlsICcgK1xuICAgICAgICAgICd0ZWFtQHBlZXJqcy5jb20gdG8gZW5hYmxlIHBlZXIgbGlzdGluZyBmb3IgeW91ciBBUEkga2V5Lic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWxwZnVsRXJyb3IgPSAnWW91IG5lZWQgdG8gZW5hYmxlIGBhbGxvd19kaXNjb3ZlcnlgIG9uIHlvdXIgc2VsZi1ob3N0ZWQgJyArXG4gICAgICAgICAgJ1BlZXJTZXJ2ZXIgdG8gdXNlIHRoaXMgZmVhdHVyZS4nO1xuICAgICAgfVxuICAgICAgY2IoW10pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdCBkb2VzblxcJ3QgbG9vayBsaWtlIHlvdSBoYXZlIHBlcm1pc3Npb24gdG8gbGlzdCBwZWVycyBJRHMuICcgKyBoZWxwZnVsRXJyb3IpO1xuICAgIH0gZWxzZSBpZiAoaHR0cC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgY2IoW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYihKU09OLnBhcnNlKGh0dHAucmVzcG9uc2VUZXh0KSk7XG4gICAgfVxuICB9O1xuICBodHRwLnNlbmQobnVsbCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBlZXI7XG5cbn0se1wiLi9kYXRhY29ubmVjdGlvblwiOjIsXCIuL21lZGlhY29ubmVjdGlvblwiOjQsXCIuL3NvY2tldFwiOjcsXCIuL3V0aWxcIjo4LFwiZXZlbnRlbWl0dGVyM1wiOjl9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpO1xuXG4vKipcbiAqIEFuIGFic3RyYWN0aW9uIG9uIHRvcCBvZiBXZWJTb2NrZXRzIGFuZCBYSFIgc3RyZWFtaW5nIHRvIHByb3ZpZGUgZmFzdGVzdFxuICogcG9zc2libGUgY29ubmVjdGlvbiBmb3IgcGVlcnMuXG4gKi9cbmZ1bmN0aW9uIFNvY2tldChzZWN1cmUsIGhvc3QsIHBvcnQsIHBhdGgsIGtleSkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja2V0KSkgcmV0dXJuIG5ldyBTb2NrZXQoc2VjdXJlLCBob3N0LCBwb3J0LCBwYXRoLCBrZXkpO1xuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIC8vIERpc2Nvbm5lY3RlZCBtYW51YWxseS5cbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5fcXVldWUgPSBbXTtcblxuICB2YXIgaHR0cFByb3RvY29sID0gc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJztcbiAgdmFyIHdzUHJvdG9jb2wgPSBzZWN1cmUgPyAnd3NzOi8vJyA6ICd3czovLyc7XG4gIHRoaXMuX2h0dHBVcmwgPSBodHRwUHJvdG9jb2wgKyBob3N0ICsgJzonICsgcG9ydCArIHBhdGggKyBrZXk7XG4gIHRoaXMuX3dzVXJsID0gd3NQcm90b2NvbCArIGhvc3QgKyAnOicgKyBwb3J0ICsgcGF0aCArICdwZWVyanM/a2V5PScgKyBrZXk7XG59XG5cbnV0aWwuaW5oZXJpdHMoU29ja2V0LCBFdmVudEVtaXR0ZXIpO1xuXG5cbi8qKiBDaGVjayBpbiB3aXRoIElEIG9yIGdldCBvbmUgZnJvbSBzZXJ2ZXIuICovXG5Tb2NrZXQucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oaWQsIHRva2VuKSB7XG4gIHRoaXMuaWQgPSBpZDtcblxuICB0aGlzLl9odHRwVXJsICs9ICcvJyArIGlkICsgJy8nICsgdG9rZW47XG4gIHRoaXMuX3dzVXJsICs9ICcmaWQ9JyArIGlkICsgJyZ0b2tlbj0nICsgdG9rZW47XG5cbiAgdGhpcy5fc3RhcnRYaHJTdHJlYW0oKTtcbiAgdGhpcy5fc3RhcnRXZWJTb2NrZXQoKTtcbn1cblxuXG4vKiogU3RhcnQgdXAgd2Vic29ja2V0IGNvbW11bmljYXRpb25zLiAqL1xuU29ja2V0LnByb3RvdHlwZS5fc3RhcnRXZWJTb2NrZXQgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuX3NvY2tldCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX3NvY2tldCA9IG5ldyBXZWJTb2NrZXQodGhpcy5fd3NVcmwpO1xuXG4gIHRoaXMuX3NvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICB1dGlsLmxvZygnSW52YWxpZCBzZXJ2ZXIgbWVzc2FnZScsIGV2ZW50LmRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLl9zb2NrZXQub25jbG9zZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdXRpbC5sb2coJ1NvY2tldCBjbG9zZWQuJyk7XG4gICAgc2VsZi5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICAgIHNlbGYuZW1pdCgnZGlzY29ubmVjdGVkJyk7XG4gIH07XG5cbiAgLy8gVGFrZSBjYXJlIG9mIHRoZSBxdWV1ZSBvZiBjb25uZWN0aW9ucyBpZiBuZWNlc3NhcnkgYW5kIG1ha2Ugc3VyZSBQZWVyIGtub3dzXG4gIC8vIHNvY2tldCBpcyBvcGVuLlxuICB0aGlzLl9zb2NrZXQub25vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuX3RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLl90aW1lb3V0KTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5faHR0cC5hYm9ydCgpO1xuICAgICAgICBzZWxmLl9odHRwID0gbnVsbDtcbiAgICAgIH0sIDUwMDApO1xuICAgIH1cbiAgICBzZWxmLl9zZW5kUXVldWVkTWVzc2FnZXMoKTtcbiAgICB1dGlsLmxvZygnU29ja2V0IG9wZW4nKTtcbiAgfTtcbn1cblxuLyoqIFN0YXJ0IFhIUiBzdHJlYW1pbmcuICovXG5Tb2NrZXQucHJvdG90eXBlLl9zdGFydFhoclN0cmVhbSA9IGZ1bmN0aW9uKG4pIHtcbiAgdHJ5IHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5faHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHRoaXMuX2h0dHAuX2luZGV4ID0gMTtcbiAgICB0aGlzLl9odHRwLl9zdHJlYW1JbmRleCA9IG4gfHwgMDtcbiAgICB0aGlzLl9odHRwLm9wZW4oJ3Bvc3QnLCB0aGlzLl9odHRwVXJsICsgJy9pZD9pPScgKyB0aGlzLl9odHRwLl9zdHJlYW1JbmRleCwgdHJ1ZSk7XG4gICAgdGhpcy5faHR0cC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBJZiB3ZSBnZXQgYW4gZXJyb3IsIGxpa2VseSBzb21ldGhpbmcgd2VudCB3cm9uZy5cbiAgICAgIC8vIFN0b3Agc3RyZWFtaW5nLlxuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3RpbWVvdXQpO1xuICAgICAgc2VsZi5lbWl0KCdkaXNjb25uZWN0ZWQnKTtcbiAgICB9XG4gICAgdGhpcy5faHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT0gMiAmJiB0aGlzLm9sZCkge1xuICAgICAgICB0aGlzLm9sZC5hYm9ydCgpO1xuICAgICAgICBkZWxldGUgdGhpcy5vbGQ7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVhZHlTdGF0ZSA+IDIgJiYgdGhpcy5zdGF0dXMgPT09IDIwMCAmJiB0aGlzLnJlc3BvbnNlVGV4dCkge1xuICAgICAgICBzZWxmLl9oYW5kbGVTdHJlYW0odGhpcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9odHRwLnNlbmQobnVsbCk7XG4gICAgdGhpcy5fc2V0SFRUUFRpbWVvdXQoKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgdXRpbC5sb2coJ1hNTEh0dHBSZXF1ZXN0IG5vdCBhdmFpbGFibGU7IGRlZmF1bHRpbmcgdG8gV2ViU29ja2V0cycpO1xuICB9XG59XG5cblxuLyoqIEhhbmRsZXMgb25yZWFkeXN0YXRlY2hhbmdlIHJlc3BvbnNlIGFzIGEgc3RyZWFtLiAqL1xuU29ja2V0LnByb3RvdHlwZS5faGFuZGxlU3RyZWFtID0gZnVuY3Rpb24oaHR0cCkge1xuICAvLyAzIGFuZCA0IGFyZSBsb2FkaW5nL2RvbmUgc3RhdGUuIEFsbCBvdGhlcnMgYXJlIG5vdCByZWxldmFudC5cbiAgdmFyIG1lc3NhZ2VzID0gaHR0cC5yZXNwb25zZVRleHQuc3BsaXQoJ1xcbicpO1xuXG4gIC8vIENoZWNrIHRvIHNlZSBpZiBhbnl0aGluZyBuZWVkcyB0byBiZSBwcm9jZXNzZWQgb24gYnVmZmVyLlxuICBpZiAoaHR0cC5fYnVmZmVyKSB7XG4gICAgd2hpbGUgKGh0dHAuX2J1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaW5kZXggPSBodHRwLl9idWZmZXIuc2hpZnQoKTtcbiAgICAgIHZhciBidWZmZXJlZE1lc3NhZ2UgPSBtZXNzYWdlc1tpbmRleF07XG4gICAgICB0cnkge1xuICAgICAgICBidWZmZXJlZE1lc3NhZ2UgPSBKU09OLnBhcnNlKGJ1ZmZlcmVkTWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgaHR0cC5fYnVmZmVyLnNoaWZ0KGluZGV4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBidWZmZXJlZE1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtZXNzYWdlID0gbWVzc2FnZXNbaHR0cC5faW5kZXhdO1xuICBpZiAobWVzc2FnZSkge1xuICAgIGh0dHAuX2luZGV4ICs9IDE7XG4gICAgLy8gQnVmZmVyaW5nLS10aGlzIG1lc3NhZ2UgaXMgaW5jb21wbGV0ZSBhbmQgd2UnbGwgZ2V0IHRvIGl0IG5leHQgdGltZS5cbiAgICAvLyBUaGlzIGNoZWNrcyBpZiB0aGUgaHR0cFJlc3BvbnNlIGVuZGVkIGluIGEgYFxcbmAsIGluIHdoaWNoIGNhc2UgdGhlIGxhc3RcbiAgICAvLyBlbGVtZW50IG9mIG1lc3NhZ2VzIHNob3VsZCBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICAgIGlmIChodHRwLl9pbmRleCA9PT0gbWVzc2FnZXMubGVuZ3RoKSB7XG4gICAgICBpZiAoIWh0dHAuX2J1ZmZlcikge1xuICAgICAgICBodHRwLl9idWZmZXIgPSBbXTtcbiAgICAgIH1cbiAgICAgIGh0dHAuX2J1ZmZlci5wdXNoKGh0dHAuX2luZGV4IC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1lc3NhZ2UgPSBKU09OLnBhcnNlKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHV0aWwubG9nKCdJbnZhbGlkIHNlcnZlciBtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5Tb2NrZXQucHJvdG90eXBlLl9zZXRIVFRQVGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbGQgPSBzZWxmLl9odHRwO1xuICAgIGlmICghc2VsZi5fd3NPcGVuKCkpIHtcbiAgICAgIHNlbGYuX3N0YXJ0WGhyU3RyZWFtKG9sZC5fc3RyZWFtSW5kZXggKyAxKTtcbiAgICAgIHNlbGYuX2h0dHAub2xkID0gb2xkO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGQuYWJvcnQoKTtcbiAgICB9XG4gIH0sIDI1MDAwKTtcbn1cblxuLyoqIElzIHRoZSB3ZWJzb2NrZXQgY3VycmVudGx5IG9wZW4/ICovXG5Tb2NrZXQucHJvdG90eXBlLl93c09wZW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3NvY2tldCAmJiB0aGlzLl9zb2NrZXQucmVhZHlTdGF0ZSA9PSAxO1xufVxuXG4vKiogU2VuZCBxdWV1ZWQgbWVzc2FnZXMuICovXG5Tb2NrZXQucHJvdG90eXBlLl9zZW5kUXVldWVkTWVzc2FnZXMgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5fcXVldWUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMSkge1xuICAgIHRoaXMuc2VuZCh0aGlzLl9xdWV1ZVtpXSk7XG4gIH1cbn1cblxuLyoqIEV4cG9zZWQgc2VuZCBmb3IgREMgJiBQZWVyLiAqL1xuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICBpZiAodGhpcy5kaXNjb25uZWN0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiB3ZSBkaWRuJ3QgZ2V0IGFuIElEIHlldCwgd2UgY2FuJ3QgeWV0IHNlbmQgYW55dGhpbmcgc28gd2Ugc2hvdWxkIHF1ZXVlXG4gIC8vIHVwIHRoZXNlIG1lc3NhZ2VzLlxuICBpZiAoIXRoaXMuaWQpIHtcbiAgICB0aGlzLl9xdWV1ZS5wdXNoKGRhdGEpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghZGF0YS50eXBlKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsICdJbnZhbGlkIG1lc3NhZ2UnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICBpZiAodGhpcy5fd3NPcGVuKCkpIHtcbiAgICB0aGlzLl9zb2NrZXQuc2VuZChtZXNzYWdlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHZhciB1cmwgPSB0aGlzLl9odHRwVXJsICsgJy8nICsgZGF0YS50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgaHR0cC5vcGVuKCdwb3N0JywgdXJsLCB0cnVlKTtcbiAgICBodHRwLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgaHR0cC5zZW5kKG1lc3NhZ2UpO1xuICB9XG59XG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmRpc2Nvbm5lY3RlZCAmJiB0aGlzLl93c09wZW4oKSkge1xuICAgIHRoaXMuX3NvY2tldC5jbG9zZSgpO1xuICAgIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNvY2tldDtcblxufSx7XCIuL3V0aWxcIjo4LFwiZXZlbnRlbWl0dGVyM1wiOjl9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBkZWZhdWx0Q29uZmlnID0geydpY2VTZXJ2ZXJzJzogW3sgJ3VybCc6ICdzdHVuOnN0dW4ubC5nb29nbGUuY29tOjE5MzAyJyB9XX07XG52YXIgZGF0YUNvdW50ID0gMTtcblxudmFyIEJpbmFyeVBhY2sgPSByZXF1aXJlKCdqcy1iaW5hcnlwYWNrJyk7XG52YXIgUlRDUGVlckNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL2FkYXB0ZXInKS5SVENQZWVyQ29ubmVjdGlvbjtcblxudmFyIHV0aWwgPSB7XG4gIG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cbiAgQ0xPVURfSE9TVDogJzAucGVlcmpzLmNvbScsXG4gIENMT1VEX1BPUlQ6IDkwMDAsXG5cbiAgLy8gQnJvd3NlcnMgdGhhdCBuZWVkIGNodW5raW5nOlxuICBjaHVua2VkQnJvd3NlcnM6IHsnQ2hyb21lJzogMX0sXG4gIGNodW5rZWRNVFU6IDE2MzAwLCAvLyBUaGUgb3JpZ2luYWwgNjAwMDAgYnl0ZXMgc2V0dGluZyBkb2VzIG5vdCB3b3JrIHdoZW4gc2VuZGluZyBkYXRhIGZyb20gRmlyZWZveCB0byBDaHJvbWUsIHdoaWNoIGlzIFwiY3V0IG9mZlwiIGFmdGVyIDE2Mzg0IGJ5dGVzIGFuZCBkZWxpdmVyZWQgaW5kaXZpZHVhbGx5LlxuXG4gIC8vIExvZ2dpbmcgbG9naWNcbiAgbG9nTGV2ZWw6IDAsXG4gIHNldExvZ0xldmVsOiBmdW5jdGlvbihsZXZlbCkge1xuICAgIHZhciBkZWJ1Z0xldmVsID0gcGFyc2VJbnQobGV2ZWwsIDEwKTtcbiAgICBpZiAoIWlzTmFOKHBhcnNlSW50KGxldmVsLCAxMCkpKSB7XG4gICAgICB1dGlsLmxvZ0xldmVsID0gZGVidWdMZXZlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhleSBhcmUgdXNpbmcgdHJ1dGh5L2ZhbHN5IHZhbHVlcyBmb3IgZGVidWdcbiAgICAgIHV0aWwubG9nTGV2ZWwgPSBsZXZlbCA/IDMgOiAwO1xuICAgIH1cbiAgICB1dGlsLmxvZyA9IHV0aWwud2FybiA9IHV0aWwuZXJyb3IgPSB1dGlsLm5vb3A7XG4gICAgaWYgKHV0aWwubG9nTGV2ZWwgPiAwKSB7XG4gICAgICB1dGlsLmVycm9yID0gdXRpbC5fcHJpbnRXaXRoKCdFUlJPUicpO1xuICAgIH1cbiAgICBpZiAodXRpbC5sb2dMZXZlbCA+IDEpIHtcbiAgICAgIHV0aWwud2FybiA9IHV0aWwuX3ByaW50V2l0aCgnV0FSTklORycpO1xuICAgIH1cbiAgICBpZiAodXRpbC5sb2dMZXZlbCA+IDIpIHtcbiAgICAgIHV0aWwubG9nID0gdXRpbC5fcHJpbnQ7XG4gICAgfVxuICB9LFxuICBzZXRMb2dGdW5jdGlvbjogZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAoZm4uY29uc3RydWN0b3IgIT09IEZ1bmN0aW9uKSB7XG4gICAgICB1dGlsLndhcm4oJ1RoZSBsb2cgZnVuY3Rpb24geW91IHBhc3NlZCBpbiBpcyBub3QgYSBmdW5jdGlvbi4gRGVmYXVsdGluZyB0byByZWd1bGFyIGxvZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwuX3ByaW50ID0gZm47XG4gICAgfVxuICB9LFxuXG4gIF9wcmludFdpdGg6IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb3B5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGNvcHkudW5zaGlmdChwcmVmaXgpO1xuICAgICAgdXRpbC5fcHJpbnQuYXBwbHkodXRpbCwgY29weSk7XG4gICAgfTtcbiAgfSxcbiAgX3ByaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVyciA9IGZhbHNlO1xuICAgIHZhciBjb3B5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBjb3B5LnVuc2hpZnQoJ1BlZXJKUzogJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb3B5Lmxlbmd0aDsgaSA8IGw7IGkrKyl7XG4gICAgICBpZiAoY29weVtpXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGNvcHlbaV0gPSAnKCcgKyBjb3B5W2ldLm5hbWUgKyAnKSAnICsgY29weVtpXS5tZXNzYWdlO1xuICAgICAgICBlcnIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBlcnIgPyBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGNvcHkpIDogY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgY29weSk7XG4gIH0sXG4gIC8vXG5cbiAgLy8gUmV0dXJucyBicm93c2VyLWFnbm9zdGljIGRlZmF1bHQgY29uZmlnXG4gIGRlZmF1bHRDb25maWc6IGRlZmF1bHRDb25maWcsXG4gIC8vXG5cbiAgLy8gUmV0dXJucyB0aGUgY3VycmVudCBicm93c2VyLlxuICBicm93c2VyOiAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikge1xuICAgICAgcmV0dXJuICdGaXJlZm94JztcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbikge1xuICAgICAgcmV0dXJuICdDaHJvbWUnO1xuICAgIH0gZWxzZSBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgICByZXR1cm4gJ1N1cHBvcnRlZCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnVW5zdXBwb3J0ZWQnO1xuICAgIH1cbiAgfSkoKSxcbiAgLy9cblxuICAvLyBMaXN0cyB3aGljaCBmZWF0dXJlcyBhcmUgc3VwcG9ydGVkXG4gIHN1cHBvcnRzOiAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiBSVENQZWVyQ29ubmVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHRydWU7XG4gICAgdmFyIGF1ZGlvVmlkZW8gPSB0cnVlO1xuXG4gICAgdmFyIGJpbmFyeUJsb2IgPSBmYWxzZTtcbiAgICB2YXIgc2N0cCA9IGZhbHNlO1xuICAgIHZhciBvbm5lZ290aWF0aW9ubmVlZGVkID0gISF3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb247XG5cbiAgICB2YXIgcGMsIGRjO1xuICAgIHRyeSB7XG4gICAgICBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihkZWZhdWx0Q29uZmlnLCB7b3B0aW9uYWw6IFt7UnRwRGF0YUNoYW5uZWxzOiB0cnVlfV19KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkYXRhID0gZmFsc2U7XG4gICAgICBhdWRpb1ZpZGVvID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRjID0gcGMuY3JlYXRlRGF0YUNoYW5uZWwoJ19QRUVSSlNURVNUJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRhdGEgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgLy8gQmluYXJ5IHRlc3RcbiAgICAgIHRyeSB7XG4gICAgICAgIGRjLmJpbmFyeVR5cGUgPSAnYmxvYic7XG4gICAgICAgIGJpbmFyeUJsb2IgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuXG4gICAgICAvLyBSZWxpYWJsZSB0ZXN0LlxuICAgICAgLy8gVW5mb3J0dW5hdGVseSBDaHJvbWUgaXMgYSBiaXQgdW5yZWxpYWJsZSBhYm91dCB3aGV0aGVyIG9yIG5vdCB0aGV5XG4gICAgICAvLyBzdXBwb3J0IHJlbGlhYmxlLlxuICAgICAgdmFyIHJlbGlhYmxlUEMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oZGVmYXVsdENvbmZpZywge30pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlbGlhYmxlREMgPSByZWxpYWJsZVBDLmNyZWF0ZURhdGFDaGFubmVsKCdfUEVFUkpTUkVMSUFCTEVURVNUJywge30pO1xuICAgICAgICBzY3RwID0gcmVsaWFibGVEQy5yZWxpYWJsZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICAgIHJlbGlhYmxlUEMuY2xvc2UoKTtcbiAgICB9XG5cbiAgICAvLyBGSVhNRTogbm90IHJlYWxseSB0aGUgYmVzdCBjaGVjay4uLlxuICAgIGlmIChhdWRpb1ZpZGVvKSB7XG4gICAgICBhdWRpb1ZpZGVvID0gISFwYy5hZGRTdHJlYW07XG4gICAgfVxuXG4gICAgLy8gRklYTUU6IHRoaXMgaXMgbm90IGdyZWF0IGJlY2F1c2UgaW4gdGhlb3J5IGl0IGRvZXNuJ3Qgd29yayBmb3JcbiAgICAvLyBhdi1vbmx5IGJyb3dzZXJzICg/KS5cbiAgICBpZiAoIW9ubmVnb3RpYXRpb25uZWVkZWQgJiYgZGF0YSkge1xuICAgICAgLy8gc3luYyBkZWZhdWx0IGNoZWNrLlxuICAgICAgdmFyIG5lZ290aWF0aW9uUEMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oZGVmYXVsdENvbmZpZywge29wdGlvbmFsOiBbe1J0cERhdGFDaGFubmVsczogdHJ1ZX1dfSk7XG4gICAgICBuZWdvdGlhdGlvblBDLm9ubmVnb3RpYXRpb25uZWVkZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgb25uZWdvdGlhdGlvbm5lZWRlZCA9IHRydWU7XG4gICAgICAgIC8vIGFzeW5jIGNoZWNrLlxuICAgICAgICBpZiAodXRpbCAmJiB1dGlsLnN1cHBvcnRzKSB7XG4gICAgICAgICAgdXRpbC5zdXBwb3J0cy5vbm5lZ290aWF0aW9ubmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIG5lZ290aWF0aW9uUEMuY3JlYXRlRGF0YUNoYW5uZWwoJ19QRUVSSlNORUdPVElBVElPTlRFU1QnKTtcblxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgbmVnb3RpYXRpb25QQy5jbG9zZSgpO1xuICAgICAgfSwgMTAwMCk7XG4gICAgfVxuXG4gICAgaWYgKHBjKSB7XG4gICAgICBwYy5jbG9zZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhdWRpb1ZpZGVvOiBhdWRpb1ZpZGVvLFxuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIGJpbmFyeUJsb2I6IGJpbmFyeUJsb2IsXG4gICAgICBiaW5hcnk6IHNjdHAsIC8vIGRlcHJlY2F0ZWQ7IHNjdHAgaW1wbGllcyBiaW5hcnkgc3VwcG9ydC5cbiAgICAgIHJlbGlhYmxlOiBzY3RwLCAvLyBkZXByZWNhdGVkOyBzY3RwIGltcGxpZXMgcmVsaWFibGUgZGF0YS5cbiAgICAgIHNjdHA6IHNjdHAsXG4gICAgICBvbm5lZ290aWF0aW9ubmVlZGVkOiBvbm5lZ290aWF0aW9ubmVlZGVkXG4gICAgfTtcbiAgfSgpKSxcbiAgLy9cblxuICAvLyBFbnN1cmUgYWxwaGFudW1lcmljIGlkc1xuICB2YWxpZGF0ZUlkOiBmdW5jdGlvbihpZCkge1xuICAgIC8vIEFsbG93IGVtcHR5IGlkc1xuICAgIHJldHVybiAhaWQgfHwgL15bQS1aYS16MC05Xy1dKyg/OlsgXy1dW0EtWmEtejAtOV0rKSokLy5leGVjKGlkKTtcbiAgfSxcblxuICB2YWxpZGF0ZUtleTogZnVuY3Rpb24oa2V5KSB7XG4gICAgLy8gQWxsb3cgZW1wdHkga2V5c1xuICAgIHJldHVybiAha2V5IHx8IC9eW0EtWmEtejAtOV8tXSsoPzpbIF8tXVtBLVphLXowLTldKykqJC8uZXhlYyhrZXkpO1xuICB9LFxuXG5cbiAgZGVidWc6IGZhbHNlLFxuXG4gIGluaGVyaXRzOiBmdW5jdGlvbihjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGV4dGVuZDogZnVuY3Rpb24oZGVzdCwgc291cmNlKSB7XG4gICAgZm9yKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZihzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBkZXN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH0sXG4gIHBhY2s6IEJpbmFyeVBhY2sucGFjayxcbiAgdW5wYWNrOiBCaW5hcnlQYWNrLnVucGFjayxcblxuICBsb2c6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodXRpbC5kZWJ1Zykge1xuICAgICAgdmFyIGVyciA9IGZhbHNlO1xuICAgICAgdmFyIGNvcHkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgY29weS51bnNoaWZ0KCdQZWVySlM6ICcpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb3B5Lmxlbmd0aDsgaSA8IGw7IGkrKyl7XG4gICAgICAgIGlmIChjb3B5W2ldIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBjb3B5W2ldID0gJygnICsgY29weVtpXS5uYW1lICsgJykgJyArIGNvcHlbaV0ubWVzc2FnZTtcbiAgICAgICAgICBlcnIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlcnIgPyBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGNvcHkpIDogY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgY29weSk7XG4gICAgfVxuICB9LFxuXG4gIHNldFplcm9UaW1lb3V0OiAoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICAgdmFyIHRpbWVvdXRzID0gW107XG4gICAgdmFyIG1lc3NhZ2VOYW1lID0gJ3plcm8tdGltZW91dC1tZXNzYWdlJztcblxuICAgIC8vIExpa2Ugc2V0VGltZW91dCwgYnV0IG9ubHkgdGFrZXMgYSBmdW5jdGlvbiBhcmd1bWVudC5cdCBUaGVyZSdzXG4gICAgLy8gbm8gdGltZSBhcmd1bWVudCAoYWx3YXlzIHplcm8pIGFuZCBubyBhcmd1bWVudHMgKHlvdSBoYXZlIHRvXG4gICAgLy8gdXNlIGEgY2xvc3VyZSkuXG4gICAgZnVuY3Rpb24gc2V0WmVyb1RpbWVvdXRQb3N0TWVzc2FnZShmbikge1xuICAgICAgdGltZW91dHMucHVzaChmbik7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZU5hbWUsICcqJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PSBnbG9iYWwgJiYgZXZlbnQuZGF0YSA9PSBtZXNzYWdlTmFtZSkge1xuICAgICAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVvdXRzLmxlbmd0aCkge1xuICAgICAgICAgIHRpbWVvdXRzLnNoaWZ0KCkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb25tZXNzYWdlJywgaGFuZGxlTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBzZXRaZXJvVGltZW91dFBvc3RNZXNzYWdlO1xuICB9KHdpbmRvdykpLFxuXG4gIC8vIEJpbmFyeSBzdHVmZlxuXG4gIC8vIGNodW5rcyBhIGJsb2IuXG4gIGNodW5rOiBmdW5jdGlvbihibCkge1xuICAgIHZhciBjaHVua3MgPSBbXTtcbiAgICB2YXIgc2l6ZSA9IGJsLnNpemU7XG4gICAgdmFyIHN0YXJ0ID0gaW5kZXggPSAwO1xuICAgIHZhciB0b3RhbCA9IE1hdGguY2VpbChzaXplIC8gdXRpbC5jaHVua2VkTVRVKTtcbiAgICB3aGlsZSAoc3RhcnQgPCBzaXplKSB7XG4gICAgICB2YXIgZW5kID0gTWF0aC5taW4oc2l6ZSwgc3RhcnQgKyB1dGlsLmNodW5rZWRNVFUpO1xuICAgICAgdmFyIGIgPSBibC5zbGljZShzdGFydCwgZW5kKTtcblxuICAgICAgdmFyIGNodW5rID0ge1xuICAgICAgICBfX3BlZXJEYXRhOiBkYXRhQ291bnQsXG4gICAgICAgIG46IGluZGV4LFxuICAgICAgICBkYXRhOiBiLFxuICAgICAgICB0b3RhbDogdG90YWxcbiAgICAgIH07XG5cbiAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcblxuICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICBpbmRleCArPSAxO1xuICAgIH1cbiAgICBkYXRhQ291bnQgKz0gMTtcbiAgICByZXR1cm4gY2h1bmtzO1xuICB9LFxuXG4gIGJsb2JUb0FycmF5QnVmZmVyOiBmdW5jdGlvbihibG9iLCBjYil7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGNiKGV2dC50YXJnZXQucmVzdWx0KTtcbiAgICB9O1xuICAgIGZyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICB9LFxuICBibG9iVG9CaW5hcnlTdHJpbmc6IGZ1bmN0aW9uKGJsb2IsIGNiKXtcbiAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgY2IoZXZ0LnRhcmdldC5yZXN1bHQpO1xuICAgIH07XG4gICAgZnIucmVhZEFzQmluYXJ5U3RyaW5nKGJsb2IpO1xuICB9LFxuICBiaW5hcnlTdHJpbmdUb0FycmF5QnVmZmVyOiBmdW5jdGlvbihiaW5hcnkpIHtcbiAgICB2YXIgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5Lmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW5hcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ5dGVBcnJheVtpXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGkpICYgMHhmZjtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVBcnJheS5idWZmZXI7XG4gIH0sXG4gIHJhbmRvbVRva2VuOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyKTtcbiAgfSxcbiAgLy9cblxuICBpc1NlY3VyZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsO1xuXG59LHtcIi4vYWRhcHRlclwiOjEsXCJqcy1iaW5hcnlwYWNrXCI6MTB9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBFdmVudEVtaXR0ZXIgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRXZlbnQgaGFuZGxlciB0byBiZSBjYWxsZWQuXG4gKiBAcGFyYW0ge01peGVkfSBjb250ZXh0IENvbnRleHQgZm9yIGZ1bmN0aW9uIGV4ZWN1dGlvbi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IGVtaXQgb25jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIEV2ZW50RW1pdHRlciBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogRXZlbnRFbWl0dGVyIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHsgLyogTm90aGluZyB0byBzZXQgKi8gfVxuXG4vKipcbiAqIEhvbGRzIHRoZSBhc3NpZ25lZCBFdmVudEVtaXR0ZXJzIGJ5IG5hbWUuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBSZXR1cm4gYSBsaXN0IG9mIGFzc2lnbmVkIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50cyB0aGF0IHNob3VsZCBiZSBsaXN0ZWQuXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW2V2ZW50XSkgcmV0dXJuIFtdO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fZXZlbnRzW2V2ZW50XS5sZW5ndGgsIGVlID0gW107IGkgPCBsOyBpKyspIHtcbiAgICBlZS5wdXNoKHRoaXMuX2V2ZW50c1tldmVudF1baV0uZm4pO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBFbWl0IGFuIGV2ZW50IHRvIGFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxuICogQHJldHVybnMge0Jvb2xlYW59IEluZGljYXRpb24gaWYgd2UndmUgZW1pdHRlZCBhbiBldmVudC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW2V2ZW50XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdXG4gICAgLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBlZSA9IGxpc3RlbmVyc1swXVxuICAgICwgYXJnc1xuICAgICwgaSwgajtcblxuICBpZiAoMSA9PT0gbGVuZ3RoKSB7XG4gICAgaWYgKGVlLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGVlLmZuLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBlZS5mbi5jYWxsKGVlLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gZWUuZm4uY2FsbChlZS5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBlZS5mbi5jYWxsKGVlLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBlZS5mbi5jYWxsKGVlLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gZWUuZm4uY2FsbChlZS5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBlZS5mbi5jYWxsKGVlLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGVlLmZuLmFwcGx5KGVlLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgbmV3IEV2ZW50TGlzdGVuZXIgZm9yIHRoZSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgTmFtZSBvZiB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge0Z1bmN0b259IGZuIENhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBUaGUgY29udGV4dCBvZiB0aGUgZnVuY3Rpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZlbnRdKSB0aGlzLl9ldmVudHNbZXZlbnRdID0gW107XG4gIHRoaXMuX2V2ZW50c1tldmVudF0ucHVzaChuZXcgRUUoIGZuLCBjb250ZXh0IHx8IHRoaXMgKSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBFdmVudExpc3RlbmVyIHRoYXQncyBvbmx5IGNhbGxlZCBvbmNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBOYW1lIG9mIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBUaGUgY29udGV4dCBvZiB0aGUgZnVuY3Rpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG4gIGlmICghdGhpcy5fZXZlbnRzW2V2ZW50XSkgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IFtdO1xuICB0aGlzLl9ldmVudHNbZXZlbnRdLnB1c2gobmV3IEVFKGZuLCBjb250ZXh0IHx8IHRoaXMsIHRydWUgKSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudCB3ZSB3YW50IHRvIHJlbW92ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciB0aGF0IHdlIG5lZWQgdG8gZmluZC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmNlIGxpc3RlbmVycy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIG9uY2UpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1tldmVudF0pIHJldHVybiB0aGlzO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdXG4gICAgLCBldmVudHMgPSBbXTtcblxuICBpZiAoZm4pIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGlzdGVuZXJzW2ldLmZuICE9PSBmbiAmJiBsaXN0ZW5lcnNbaV0ub25jZSAhPT0gb25jZSkge1xuICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gIC8vXG4gIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZlbnRdID0gZXZlbnRzO1xuICBlbHNlIHRoaXMuX2V2ZW50c1tldmVudF0gPSBudWxsO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycyBvciBvbmx5IHRoZSBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudCB3YW50IHRvIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvci5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcblxuICBpZiAoZXZlbnQpIHRoaXMuX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICBlbHNlIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIGRvZXNuJ3QgYXBwbHkgYW55bW9yZS5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIyID0gRXZlbnRFbWl0dGVyO1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlcjMgPSBFdmVudEVtaXR0ZXI7XG5cbmlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cblxufSx7fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIEJ1ZmZlckJ1aWxkZXIgPSByZXF1aXJlKCcuL2J1ZmZlcmJ1aWxkZXInKS5CdWZmZXJCdWlsZGVyO1xudmFyIGJpbmFyeUZlYXR1cmVzID0gcmVxdWlyZSgnLi9idWZmZXJidWlsZGVyJykuYmluYXJ5RmVhdHVyZXM7XG5cbnZhciBCaW5hcnlQYWNrID0ge1xuICB1bnBhY2s6IGZ1bmN0aW9uKGRhdGEpe1xuICAgIHZhciB1bnBhY2tlciA9IG5ldyBVbnBhY2tlcihkYXRhKTtcbiAgICByZXR1cm4gdW5wYWNrZXIudW5wYWNrKCk7XG4gIH0sXG4gIHBhY2s6IGZ1bmN0aW9uKGRhdGEpe1xuICAgIHZhciBwYWNrZXIgPSBuZXcgUGFja2VyKCk7XG4gICAgcGFja2VyLnBhY2soZGF0YSk7XG4gICAgdmFyIGJ1ZmZlciA9IHBhY2tlci5nZXRCdWZmZXIoKTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJpbmFyeVBhY2s7XG5cbmZ1bmN0aW9uIFVucGFja2VyIChkYXRhKXtcbiAgLy8gRGF0YSBpcyBBcnJheUJ1ZmZlclxuICB0aGlzLmluZGV4ID0gMDtcbiAgdGhpcy5kYXRhQnVmZmVyID0gZGF0YTtcbiAgdGhpcy5kYXRhVmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YUJ1ZmZlcik7XG4gIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhQnVmZmVyLmJ5dGVMZW5ndGg7XG59XG5cblVucGFja2VyLnByb3RvdHlwZS51bnBhY2sgPSBmdW5jdGlvbigpe1xuICB2YXIgdHlwZSA9IHRoaXMudW5wYWNrX3VpbnQ4KCk7XG4gIGlmICh0eXBlIDwgMHg4MCl7XG4gICAgdmFyIHBvc2l0aXZlX2ZpeG51bSA9IHR5cGU7XG4gICAgcmV0dXJuIHBvc2l0aXZlX2ZpeG51bTtcbiAgfSBlbHNlIGlmICgodHlwZSBeIDB4ZTApIDwgMHgyMCl7XG4gICAgdmFyIG5lZ2F0aXZlX2ZpeG51bSA9ICh0eXBlIF4gMHhlMCkgLSAweDIwO1xuICAgIHJldHVybiBuZWdhdGl2ZV9maXhudW07XG4gIH1cbiAgdmFyIHNpemU7XG4gIGlmICgoc2l6ZSA9IHR5cGUgXiAweGEwKSA8PSAweDBmKXtcbiAgICByZXR1cm4gdGhpcy51bnBhY2tfcmF3KHNpemUpO1xuICB9IGVsc2UgaWYgKChzaXplID0gdHlwZSBeIDB4YjApIDw9IDB4MGYpe1xuICAgIHJldHVybiB0aGlzLnVucGFja19zdHJpbmcoc2l6ZSk7XG4gIH0gZWxzZSBpZiAoKHNpemUgPSB0eXBlIF4gMHg5MCkgPD0gMHgwZil7XG4gICAgcmV0dXJuIHRoaXMudW5wYWNrX2FycmF5KHNpemUpO1xuICB9IGVsc2UgaWYgKChzaXplID0gdHlwZSBeIDB4ODApIDw9IDB4MGYpe1xuICAgIHJldHVybiB0aGlzLnVucGFja19tYXAoc2l6ZSk7XG4gIH1cbiAgc3dpdGNoKHR5cGUpe1xuICAgIGNhc2UgMHhjMDpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgMHhjMTpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY2FzZSAweGMyOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgMHhjMzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgMHhjYTpcbiAgICAgIHJldHVybiB0aGlzLnVucGFja19mbG9hdCgpO1xuICAgIGNhc2UgMHhjYjpcbiAgICAgIHJldHVybiB0aGlzLnVucGFja19kb3VibGUoKTtcbiAgICBjYXNlIDB4Y2M6XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfdWludDgoKTtcbiAgICBjYXNlIDB4Y2Q6XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfdWludDE2KCk7XG4gICAgY2FzZSAweGNlOlxuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICAgIGNhc2UgMHhjZjpcbiAgICAgIHJldHVybiB0aGlzLnVucGFja191aW50NjQoKTtcbiAgICBjYXNlIDB4ZDA6XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfaW50OCgpO1xuICAgIGNhc2UgMHhkMTpcbiAgICAgIHJldHVybiB0aGlzLnVucGFja19pbnQxNigpO1xuICAgIGNhc2UgMHhkMjpcbiAgICAgIHJldHVybiB0aGlzLnVucGFja19pbnQzMigpO1xuICAgIGNhc2UgMHhkMzpcbiAgICAgIHJldHVybiB0aGlzLnVucGFja19pbnQ2NCgpO1xuICAgIGNhc2UgMHhkNDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY2FzZSAweGQ1OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjYXNlIDB4ZDY6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNhc2UgMHhkNzpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY2FzZSAweGQ4OlxuICAgICAgc2l6ZSA9IHRoaXMudW5wYWNrX3VpbnQxNigpO1xuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX3N0cmluZyhzaXplKTtcbiAgICBjYXNlIDB4ZDk6XG4gICAgICBzaXplID0gdGhpcy51bnBhY2tfdWludDMyKCk7XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfc3RyaW5nKHNpemUpO1xuICAgIGNhc2UgMHhkYTpcbiAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MTYoKTtcbiAgICAgIHJldHVybiB0aGlzLnVucGFja19yYXcoc2l6ZSk7XG4gICAgY2FzZSAweGRiOlxuICAgICAgc2l6ZSA9IHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX3JhdyhzaXplKTtcbiAgICBjYXNlIDB4ZGM6XG4gICAgICBzaXplID0gdGhpcy51bnBhY2tfdWludDE2KCk7XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfYXJyYXkoc2l6ZSk7XG4gICAgY2FzZSAweGRkOlxuICAgICAgc2l6ZSA9IHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX2FycmF5KHNpemUpO1xuICAgIGNhc2UgMHhkZTpcbiAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MTYoKTtcbiAgICAgIHJldHVybiB0aGlzLnVucGFja19tYXAoc2l6ZSk7XG4gICAgY2FzZSAweGRmOlxuICAgICAgc2l6ZSA9IHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX21hcChzaXplKTtcbiAgfVxufVxuXG5VbnBhY2tlci5wcm90b3R5cGUudW5wYWNrX3VpbnQ4ID0gZnVuY3Rpb24oKXtcbiAgdmFyIGJ5dGUgPSB0aGlzLmRhdGFWaWV3W3RoaXMuaW5kZXhdICYgMHhmZjtcbiAgdGhpcy5pbmRleCsrO1xuICByZXR1cm4gYnl0ZTtcbn07XG5cblVucGFja2VyLnByb3RvdHlwZS51bnBhY2tfdWludDE2ID0gZnVuY3Rpb24oKXtcbiAgdmFyIGJ5dGVzID0gdGhpcy5yZWFkKDIpO1xuICB2YXIgdWludDE2ID1cbiAgICAoKGJ5dGVzWzBdICYgMHhmZikgKiAyNTYpICsgKGJ5dGVzWzFdICYgMHhmZik7XG4gIHRoaXMuaW5kZXggKz0gMjtcbiAgcmV0dXJuIHVpbnQxNjtcbn1cblxuVW5wYWNrZXIucHJvdG90eXBlLnVucGFja191aW50MzIgPSBmdW5jdGlvbigpe1xuICB2YXIgYnl0ZXMgPSB0aGlzLnJlYWQoNCk7XG4gIHZhciB1aW50MzIgPVxuICAgICAoKGJ5dGVzWzBdICAqIDI1NiArXG4gICAgICAgYnl0ZXNbMV0pICogMjU2ICtcbiAgICAgICBieXRlc1syXSkgKiAyNTYgK1xuICAgICAgIGJ5dGVzWzNdO1xuICB0aGlzLmluZGV4ICs9IDQ7XG4gIHJldHVybiB1aW50MzI7XG59XG5cblVucGFja2VyLnByb3RvdHlwZS51bnBhY2tfdWludDY0ID0gZnVuY3Rpb24oKXtcbiAgdmFyIGJ5dGVzID0gdGhpcy5yZWFkKDgpO1xuICB2YXIgdWludDY0ID1cbiAgICgoKCgoKGJ5dGVzWzBdICAqIDI1NiArXG4gICAgICAgYnl0ZXNbMV0pICogMjU2ICtcbiAgICAgICBieXRlc1syXSkgKiAyNTYgK1xuICAgICAgIGJ5dGVzWzNdKSAqIDI1NiArXG4gICAgICAgYnl0ZXNbNF0pICogMjU2ICtcbiAgICAgICBieXRlc1s1XSkgKiAyNTYgK1xuICAgICAgIGJ5dGVzWzZdKSAqIDI1NiArXG4gICAgICAgYnl0ZXNbN107XG4gIHRoaXMuaW5kZXggKz0gODtcbiAgcmV0dXJuIHVpbnQ2NDtcbn1cblxuXG5VbnBhY2tlci5wcm90b3R5cGUudW5wYWNrX2ludDggPSBmdW5jdGlvbigpe1xuICB2YXIgdWludDggPSB0aGlzLnVucGFja191aW50OCgpO1xuICByZXR1cm4gKHVpbnQ4IDwgMHg4MCApID8gdWludDggOiB1aW50OCAtICgxIDw8IDgpO1xufTtcblxuVW5wYWNrZXIucHJvdG90eXBlLnVucGFja19pbnQxNiA9IGZ1bmN0aW9uKCl7XG4gIHZhciB1aW50MTYgPSB0aGlzLnVucGFja191aW50MTYoKTtcbiAgcmV0dXJuICh1aW50MTYgPCAweDgwMDAgKSA/IHVpbnQxNiA6IHVpbnQxNiAtICgxIDw8IDE2KTtcbn1cblxuVW5wYWNrZXIucHJvdG90eXBlLnVucGFja19pbnQzMiA9IGZ1bmN0aW9uKCl7XG4gIHZhciB1aW50MzIgPSB0aGlzLnVucGFja191aW50MzIoKTtcbiAgcmV0dXJuICh1aW50MzIgPCBNYXRoLnBvdygyLCAzMSkgKSA/IHVpbnQzMiA6XG4gICAgdWludDMyIC0gTWF0aC5wb3coMiwgMzIpO1xufVxuXG5VbnBhY2tlci5wcm90b3R5cGUudW5wYWNrX2ludDY0ID0gZnVuY3Rpb24oKXtcbiAgdmFyIHVpbnQ2NCA9IHRoaXMudW5wYWNrX3VpbnQ2NCgpO1xuICByZXR1cm4gKHVpbnQ2NCA8IE1hdGgucG93KDIsIDYzKSApID8gdWludDY0IDpcbiAgICB1aW50NjQgLSBNYXRoLnBvdygyLCA2NCk7XG59XG5cblVucGFja2VyLnByb3RvdHlwZS51bnBhY2tfcmF3ID0gZnVuY3Rpb24oc2l6ZSl7XG4gIGlmICggdGhpcy5sZW5ndGggPCB0aGlzLmluZGV4ICsgc2l6ZSl7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCaW5hcnlQYWNrRmFpbHVyZTogaW5kZXggaXMgb3V0IG9mIHJhbmdlJ1xuICAgICAgKyAnICcgKyB0aGlzLmluZGV4ICsgJyAnICsgc2l6ZSArICcgJyArIHRoaXMubGVuZ3RoKTtcbiAgfVxuICB2YXIgYnVmID0gdGhpcy5kYXRhQnVmZmVyLnNsaWNlKHRoaXMuaW5kZXgsIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgdGhpcy5pbmRleCArPSBzaXplO1xuXG4gICAgLy9idWYgPSB1dGlsLmJ1ZmZlclRvU3RyaW5nKGJ1Zik7XG5cbiAgcmV0dXJuIGJ1Zjtcbn1cblxuVW5wYWNrZXIucHJvdG90eXBlLnVucGFja19zdHJpbmcgPSBmdW5jdGlvbihzaXplKXtcbiAgdmFyIGJ5dGVzID0gdGhpcy5yZWFkKHNpemUpO1xuICB2YXIgaSA9IDAsIHN0ciA9ICcnLCBjLCBjb2RlO1xuICB3aGlsZShpIDwgc2l6ZSl7XG4gICAgYyA9IGJ5dGVzW2ldO1xuICAgIGlmICggYyA8IDEyOCl7XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgIGkrKztcbiAgICB9IGVsc2UgaWYgKChjIF4gMHhjMCkgPCAzMil7XG4gICAgICBjb2RlID0gKChjIF4gMHhjMCkgPDwgNikgfCAoYnl0ZXNbaSsxXSAmIDYzKTtcbiAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgaSArPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlID0gKChjICYgMTUpIDw8IDEyKSB8ICgoYnl0ZXNbaSsxXSAmIDYzKSA8PCA2KSB8XG4gICAgICAgIChieXRlc1tpKzJdICYgNjMpO1xuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICBpICs9IDM7XG4gICAgfVxuICB9XG4gIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuVW5wYWNrZXIucHJvdG90eXBlLnVucGFja19hcnJheSA9IGZ1bmN0aW9uKHNpemUpe1xuICB2YXIgb2JqZWN0cyA9IG5ldyBBcnJheShzaXplKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHNpemUgOyBpKyspe1xuICAgIG9iamVjdHNbaV0gPSB0aGlzLnVucGFjaygpO1xuICB9XG4gIHJldHVybiBvYmplY3RzO1xufVxuXG5VbnBhY2tlci5wcm90b3R5cGUudW5wYWNrX21hcCA9IGZ1bmN0aW9uKHNpemUpe1xuICB2YXIgbWFwID0ge307XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplIDsgaSsrKXtcbiAgICB2YXIga2V5ICA9IHRoaXMudW5wYWNrKCk7XG4gICAgdmFyIHZhbHVlID0gdGhpcy51bnBhY2soKTtcbiAgICBtYXBba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBtYXA7XG59XG5cblVucGFja2VyLnByb3RvdHlwZS51bnBhY2tfZmxvYXQgPSBmdW5jdGlvbigpe1xuICB2YXIgdWludDMyID0gdGhpcy51bnBhY2tfdWludDMyKCk7XG4gIHZhciBzaWduID0gdWludDMyID4+IDMxO1xuICB2YXIgZXhwICA9ICgodWludDMyID4+IDIzKSAmIDB4ZmYpIC0gMTI3O1xuICB2YXIgZnJhY3Rpb24gPSAoIHVpbnQzMiAmIDB4N2ZmZmZmICkgfCAweDgwMDAwMDtcbiAgcmV0dXJuIChzaWduID09IDAgPyAxIDogLTEpICpcbiAgICBmcmFjdGlvbiAqIE1hdGgucG93KDIsIGV4cCAtIDIzKTtcbn1cblxuVW5wYWNrZXIucHJvdG90eXBlLnVucGFja19kb3VibGUgPSBmdW5jdGlvbigpe1xuICB2YXIgaDMyID0gdGhpcy51bnBhY2tfdWludDMyKCk7XG4gIHZhciBsMzIgPSB0aGlzLnVucGFja191aW50MzIoKTtcbiAgdmFyIHNpZ24gPSBoMzIgPj4gMzE7XG4gIHZhciBleHAgID0gKChoMzIgPj4gMjApICYgMHg3ZmYpIC0gMTAyMztcbiAgdmFyIGhmcmFjID0gKCBoMzIgJiAweGZmZmZmICkgfCAweDEwMDAwMDtcbiAgdmFyIGZyYWMgPSBoZnJhYyAqIE1hdGgucG93KDIsIGV4cCAtIDIwKSArXG4gICAgbDMyICAgKiBNYXRoLnBvdygyLCBleHAgLSA1Mik7XG4gIHJldHVybiAoc2lnbiA9PSAwID8gMSA6IC0xKSAqIGZyYWM7XG59XG5cblVucGFja2VyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obGVuZ3RoKXtcbiAgdmFyIGogPSB0aGlzLmluZGV4O1xuICBpZiAoaiArIGxlbmd0aCA8PSB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFWaWV3LnN1YmFycmF5KGosIGogKyBsZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQmluYXJ5UGFja0ZhaWx1cmU6IHJlYWQgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gUGFja2VyKCl7XG4gIHRoaXMuYnVmZmVyQnVpbGRlciA9IG5ldyBCdWZmZXJCdWlsZGVyKCk7XG59XG5cblBhY2tlci5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRoaXMuYnVmZmVyQnVpbGRlci5nZXRCdWZmZXIoKTtcbn1cblxuUGFja2VyLnByb3RvdHlwZS5wYWNrID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgdHlwZSA9IHR5cGVvZih2YWx1ZSk7XG4gIGlmICh0eXBlID09ICdzdHJpbmcnKXtcbiAgICB0aGlzLnBhY2tfc3RyaW5nKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh0eXBlID09ICdudW1iZXInKXtcbiAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlKXtcbiAgICAgIHRoaXMucGFja19pbnRlZ2VyKHZhbHVlKTtcbiAgICB9IGVsc2V7XG4gICAgICB0aGlzLnBhY2tfZG91YmxlKHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PSAnYm9vbGVhbicpe1xuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSl7XG4gICAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4YzMpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IGZhbHNlKXtcbiAgICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjMik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3VuZGVmaW5lZCcpe1xuICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjMCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PSAnb2JqZWN0Jyl7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKXtcbiAgICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb25zdHJ1Y3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGNvbnN0cnVjdG9yID09IEFycmF5KXtcbiAgICAgICAgdGhpcy5wYWNrX2FycmF5KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uc3RydWN0b3IgPT0gQmxvYiB8fCBjb25zdHJ1Y3RvciA9PSBGaWxlKSB7XG4gICAgICAgIHRoaXMucGFja19iaW4odmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChjb25zdHJ1Y3RvciA9PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICBpZihiaW5hcnlGZWF0dXJlcy51c2VBcnJheUJ1ZmZlclZpZXcpIHtcbiAgICAgICAgICB0aGlzLnBhY2tfYmluKG5ldyBVaW50OEFycmF5KHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYWNrX2Jpbih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoJ0JZVEVTX1BFUl9FTEVNRU5UJyBpbiB2YWx1ZSl7XG4gICAgICAgIGlmKGJpbmFyeUZlYXR1cmVzLnVzZUFycmF5QnVmZmVyVmlldykge1xuICAgICAgICAgIHRoaXMucGFja19iaW4obmV3IFVpbnQ4QXJyYXkodmFsdWUuYnVmZmVyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYWNrX2Jpbih2YWx1ZS5idWZmZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yID09IE9iamVjdCl7XG4gICAgICAgIHRoaXMucGFja19vYmplY3QodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChjb25zdHJ1Y3RvciA9PSBEYXRlKXtcbiAgICAgICAgdGhpcy5wYWNrX3N0cmluZyh2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvQmluYXJ5UGFjayA9PSAnZnVuY3Rpb24nKXtcbiAgICAgICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCh2YWx1ZS50b0JpbmFyeVBhY2soKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGUgXCInICsgY29uc3RydWN0b3IudG9TdHJpbmcoKSArICdcIiBub3QgeWV0IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGUgXCInICsgdHlwZSArICdcIiBub3QgeWV0IHN1cHBvcnRlZCcpO1xuICB9XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5mbHVzaCgpO1xufVxuXG5cblBhY2tlci5wcm90b3R5cGUucGFja19iaW4gPSBmdW5jdGlvbihibG9iKXtcbiAgdmFyIGxlbmd0aCA9IGJsb2IubGVuZ3RoIHx8IGJsb2IuYnl0ZUxlbmd0aCB8fCBibG9iLnNpemU7XG4gIGlmIChsZW5ndGggPD0gMHgwZil7XG4gICAgdGhpcy5wYWNrX3VpbnQ4KDB4YTAgKyBsZW5ndGgpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA8PSAweGZmZmYpe1xuICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkYSkgO1xuICAgIHRoaXMucGFja191aW50MTYobGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmZmZmZil7XG4gICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgweGRiKTtcbiAgICB0aGlzLnBhY2tfdWludDMyKGxlbmd0aCk7XG4gIH0gZWxzZXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGVuZ3RoJyk7XG4gIH1cbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZChibG9iKTtcbn1cblxuUGFja2VyLnByb3RvdHlwZS5wYWNrX3N0cmluZyA9IGZ1bmN0aW9uKHN0cil7XG4gIHZhciBsZW5ndGggPSB1dGY4TGVuZ3RoKHN0cik7XG5cbiAgaWYgKGxlbmd0aCA8PSAweDBmKXtcbiAgICB0aGlzLnBhY2tfdWludDgoMHhiMCArIGxlbmd0aCk7XG4gIH0gZWxzZSBpZiAobGVuZ3RoIDw9IDB4ZmZmZil7XG4gICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgweGQ4KSA7XG4gICAgdGhpcy5wYWNrX3VpbnQxNihsZW5ndGgpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA8PSAweGZmZmZmZmZmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZDkpO1xuICAgIHRoaXMucGFja191aW50MzIobGVuZ3RoKTtcbiAgfSBlbHNle1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsZW5ndGgnKTtcbiAgfVxuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKHN0cik7XG59XG5cblBhY2tlci5wcm90b3R5cGUucGFja19hcnJheSA9IGZ1bmN0aW9uKGFyeSl7XG4gIHZhciBsZW5ndGggPSBhcnkubGVuZ3RoO1xuICBpZiAobGVuZ3RoIDw9IDB4MGYpe1xuICAgIHRoaXMucGFja191aW50OCgweDkwICsgbGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZGMpXG4gICAgdGhpcy5wYWNrX3VpbnQxNihsZW5ndGgpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA8PSAweGZmZmZmZmZmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZGQpO1xuICAgIHRoaXMucGFja191aW50MzIobGVuZ3RoKTtcbiAgfSBlbHNle1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsZW5ndGgnKTtcbiAgfVxuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuZ3RoIDsgaSsrKXtcbiAgICB0aGlzLnBhY2soYXJ5W2ldKTtcbiAgfVxufVxuXG5QYWNrZXIucHJvdG90eXBlLnBhY2tfaW50ZWdlciA9IGZ1bmN0aW9uKG51bSl7XG4gIGlmICggLTB4MjAgPD0gbnVtICYmIG51bSA8PSAweDdmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKG51bSAmIDB4ZmYpO1xuICB9IGVsc2UgaWYgKDB4MDAgPD0gbnVtICYmIG51bSA8PSAweGZmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4Y2MpO1xuICAgIHRoaXMucGFja191aW50OChudW0pO1xuICB9IGVsc2UgaWYgKC0weDgwIDw9IG51bSAmJiBudW0gPD0gMHg3Zil7XG4gICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgweGQwKTtcbiAgICB0aGlzLnBhY2tfaW50OChudW0pO1xuICB9IGVsc2UgaWYgKCAweDAwMDAgPD0gbnVtICYmIG51bSA8PSAweGZmZmYpe1xuICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjZCk7XG4gICAgdGhpcy5wYWNrX3VpbnQxNihudW0pO1xuICB9IGVsc2UgaWYgKC0weDgwMDAgPD0gbnVtICYmIG51bSA8PSAweDdmZmYpe1xuICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkMSk7XG4gICAgdGhpcy5wYWNrX2ludDE2KG51bSk7XG4gIH0gZWxzZSBpZiAoIDB4MDAwMDAwMDAgPD0gbnVtICYmIG51bSA8PSAweGZmZmZmZmZmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4Y2UpO1xuICAgIHRoaXMucGFja191aW50MzIobnVtKTtcbiAgfSBlbHNlIGlmICgtMHg4MDAwMDAwMCA8PSBudW0gJiYgbnVtIDw9IDB4N2ZmZmZmZmYpe1xuICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkMik7XG4gICAgdGhpcy5wYWNrX2ludDMyKG51bSk7XG4gIH0gZWxzZSBpZiAoLTB4ODAwMDAwMDAwMDAwMDAwMCA8PSBudW0gJiYgbnVtIDw9IDB4N0ZGRkZGRkZGRkZGRkZGRil7XG4gICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgweGQzKTtcbiAgICB0aGlzLnBhY2tfaW50NjQobnVtKTtcbiAgfSBlbHNlIGlmICgweDAwMDAwMDAwMDAwMDAwMDAgPD0gbnVtICYmIG51bSA8PSAweEZGRkZGRkZGRkZGRkZGRkYpe1xuICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjZik7XG4gICAgdGhpcy5wYWNrX3VpbnQ2NChudW0pO1xuICB9IGVsc2V7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVnZXInKTtcbiAgfVxufVxuXG5QYWNrZXIucHJvdG90eXBlLnBhY2tfZG91YmxlID0gZnVuY3Rpb24obnVtKXtcbiAgdmFyIHNpZ24gPSAwO1xuICBpZiAobnVtIDwgMCl7XG4gICAgc2lnbiA9IDE7XG4gICAgbnVtID0gLW51bTtcbiAgfVxuICB2YXIgZXhwICA9IE1hdGguZmxvb3IoTWF0aC5sb2cobnVtKSAvIE1hdGguTE4yKTtcbiAgdmFyIGZyYWMwID0gbnVtIC8gTWF0aC5wb3coMiwgZXhwKSAtIDE7XG4gIHZhciBmcmFjMSA9IE1hdGguZmxvb3IoZnJhYzAgKiBNYXRoLnBvdygyLCA1MikpO1xuICB2YXIgYjMyICAgPSBNYXRoLnBvdygyLCAzMik7XG4gIHZhciBoMzIgPSAoc2lnbiA8PCAzMSkgfCAoKGV4cCsxMDIzKSA8PCAyMCkgfFxuICAgICAgKGZyYWMxIC8gYjMyKSAmIDB4MGZmZmZmO1xuICB2YXIgbDMyID0gZnJhYzEgJSBiMzI7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjYik7XG4gIHRoaXMucGFja19pbnQzMihoMzIpO1xuICB0aGlzLnBhY2tfaW50MzIobDMyKTtcbn1cblxuUGFja2VyLnByb3RvdHlwZS5wYWNrX29iamVjdCA9IGZ1bmN0aW9uKG9iail7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoIDw9IDB4MGYpe1xuICAgIHRoaXMucGFja191aW50OCgweDgwICsgbGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZGUpO1xuICAgIHRoaXMucGFja191aW50MTYobGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmZmZmZil7XG4gICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgweGRmKTtcbiAgICB0aGlzLnBhY2tfdWludDMyKGxlbmd0aCk7XG4gIH0gZWxzZXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGVuZ3RoJyk7XG4gIH1cbiAgZm9yKHZhciBwcm9wIGluIG9iail7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSl7XG4gICAgICB0aGlzLnBhY2socHJvcCk7XG4gICAgICB0aGlzLnBhY2sob2JqW3Byb3BdKTtcbiAgICB9XG4gIH1cbn1cblxuUGFja2VyLnByb3RvdHlwZS5wYWNrX3VpbnQ4ID0gZnVuY3Rpb24obnVtKXtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZChudW0pO1xufVxuXG5QYWNrZXIucHJvdG90eXBlLnBhY2tfdWludDE2ID0gZnVuY3Rpb24obnVtKXtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZChudW0gPj4gOCk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQobnVtICYgMHhmZik7XG59XG5cblBhY2tlci5wcm90b3R5cGUucGFja191aW50MzIgPSBmdW5jdGlvbihudW0pe1xuICB2YXIgbiA9IG51bSAmIDB4ZmZmZmZmZmY7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKG4gJiAweGZmMDAwMDAwKSA+Pj4gMjQpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChuICYgMHgwMGZmMDAwMCkgPj4+IDE2KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobiAmIDB4MDAwMGZmMDApID4+PiAgOCk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKG4gJiAweDAwMDAwMGZmKSk7XG59XG5cblBhY2tlci5wcm90b3R5cGUucGFja191aW50NjQgPSBmdW5jdGlvbihudW0pe1xuICB2YXIgaGlnaCA9IG51bSAvIE1hdGgucG93KDIsIDMyKTtcbiAgdmFyIGxvdyAgPSBudW0gJSBNYXRoLnBvdygyLCAzMik7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGhpZ2ggJiAweGZmMDAwMDAwKSA+Pj4gMjQpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChoaWdoICYgMHgwMGZmMDAwMCkgPj4+IDE2KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgoaGlnaCAmIDB4MDAwMGZmMDApID4+PiAgOCk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGhpZ2ggJiAweDAwMDAwMGZmKSk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGxvdyAgJiAweGZmMDAwMDAwKSA+Pj4gMjQpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChsb3cgICYgMHgwMGZmMDAwMCkgPj4+IDE2KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobG93ICAmIDB4MDAwMGZmMDApID4+PiAgOCk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGxvdyAgJiAweDAwMDAwMGZmKSk7XG59XG5cblBhY2tlci5wcm90b3R5cGUucGFja19pbnQ4ID0gZnVuY3Rpb24obnVtKXtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZChudW0gJiAweGZmKTtcbn1cblxuUGFja2VyLnByb3RvdHlwZS5wYWNrX2ludDE2ID0gZnVuY3Rpb24obnVtKXtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobnVtICYgMHhmZjAwKSA+PiA4KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZChudW0gJiAweGZmKTtcbn1cblxuUGFja2VyLnByb3RvdHlwZS5wYWNrX2ludDMyID0gZnVuY3Rpb24obnVtKXtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobnVtID4+PiAyNCkgJiAweGZmKTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobnVtICYgMHgwMGZmMDAwMCkgPj4+IDE2KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobnVtICYgMHgwMDAwZmYwMCkgPj4+IDgpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChudW0gJiAweDAwMDAwMGZmKSk7XG59XG5cblBhY2tlci5wcm90b3R5cGUucGFja19pbnQ2NCA9IGZ1bmN0aW9uKG51bSl7XG4gIHZhciBoaWdoID0gTWF0aC5mbG9vcihudW0gLyBNYXRoLnBvdygyLCAzMikpO1xuICB2YXIgbG93ICA9IG51bSAlIE1hdGgucG93KDIsIDMyKTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgoaGlnaCAmIDB4ZmYwMDAwMDApID4+PiAyNCk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGhpZ2ggJiAweDAwZmYwMDAwKSA+Pj4gMTYpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChoaWdoICYgMHgwMDAwZmYwMCkgPj4+ICA4KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgoaGlnaCAmIDB4MDAwMDAwZmYpKTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobG93ICAmIDB4ZmYwMDAwMDApID4+PiAyNCk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGxvdyAgJiAweDAwZmYwMDAwKSA+Pj4gMTYpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChsb3cgICYgMHgwMDAwZmYwMCkgPj4+ICA4KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobG93ICAmIDB4MDAwMDAwZmYpKTtcbn1cblxuZnVuY3Rpb24gX3V0ZjhSZXBsYWNlKG0pe1xuICB2YXIgY29kZSA9IG0uY2hhckNvZGVBdCgwKTtcblxuICBpZihjb2RlIDw9IDB4N2ZmKSByZXR1cm4gJzAwJztcbiAgaWYoY29kZSA8PSAweGZmZmYpIHJldHVybiAnMDAwJztcbiAgaWYoY29kZSA8PSAweDFmZmZmZikgcmV0dXJuICcwMDAwJztcbiAgaWYoY29kZSA8PSAweDNmZmZmZmYpIHJldHVybiAnMDAwMDAnO1xuICByZXR1cm4gJzAwMDAwMCc7XG59XG5cbmZ1bmN0aW9uIHV0ZjhMZW5ndGgoc3RyKXtcbiAgaWYgKHN0ci5sZW5ndGggPiA2MDApIHtcbiAgICAvLyBCbG9iIG1ldGhvZCBmYXN0ZXIgZm9yIGxhcmdlIHN0cmluZ3NcbiAgICByZXR1cm4gKG5ldyBCbG9iKFtzdHJdKSkuc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1teXFx1MDAwMC1cXHUwMDdGXS9nLCBfdXRmOFJlcGxhY2UpLmxlbmd0aDtcbiAgfVxufVxuXG59LHtcIi4vYnVmZmVyYnVpbGRlclwiOjExfV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGJpbmFyeUZlYXR1cmVzID0ge307XG5iaW5hcnlGZWF0dXJlcy51c2VCbG9iQnVpbGRlciA9IChmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIG5ldyBCbG9iKFtdKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSkoKTtcblxuYmluYXJ5RmVhdHVyZXMudXNlQXJyYXlCdWZmZXJWaWV3ID0gIWJpbmFyeUZlYXR1cmVzLnVzZUJsb2JCdWlsZGVyICYmIChmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIHJldHVybiAobmV3IEJsb2IoW25ldyBVaW50OEFycmF5KFtdKV0pKS5zaXplID09PSAwO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzLmJpbmFyeUZlYXR1cmVzID0gYmluYXJ5RmVhdHVyZXM7XG52YXIgQmxvYkJ1aWxkZXIgPSBtb2R1bGUuZXhwb3J0cy5CbG9iQnVpbGRlcjtcbmlmICh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnKSB7XG4gIEJsb2JCdWlsZGVyID0gbW9kdWxlLmV4cG9ydHMuQmxvYkJ1aWxkZXIgPSB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHxcbiAgICB3aW5kb3cuTW96QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1TQmxvYkJ1aWxkZXIgfHwgd2luZG93LkJsb2JCdWlsZGVyO1xufVxuXG5mdW5jdGlvbiBCdWZmZXJCdWlsZGVyKCl7XG4gIHRoaXMuX3BpZWNlcyA9IFtdO1xuICB0aGlzLl9wYXJ0cyA9IFtdO1xufVxuXG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGlmKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykge1xuICAgIHRoaXMuX3BpZWNlcy5wdXNoKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgICB0aGlzLl9wYXJ0cy5wdXNoKGRhdGEpO1xuICB9XG59O1xuXG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fcGllY2VzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fcGllY2VzKTtcbiAgICBpZighYmluYXJ5RmVhdHVyZXMudXNlQXJyYXlCdWZmZXJWaWV3KSB7XG4gICAgICBidWYgPSBidWYuYnVmZmVyO1xuICAgIH1cbiAgICB0aGlzLl9wYXJ0cy5wdXNoKGJ1Zik7XG4gICAgdGhpcy5fcGllY2VzID0gW107XG4gIH1cbn07XG5cbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmZsdXNoKCk7XG4gIGlmKGJpbmFyeUZlYXR1cmVzLnVzZUJsb2JCdWlsZGVyKSB7XG4gICAgdmFyIGJ1aWxkZXIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgICBmb3IodmFyIGkgPSAwLCBpaSA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGJ1aWxkZXIuYXBwZW5kKHRoaXMuX3BhcnRzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkZXIuZ2V0QmxvYigpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgQmxvYih0aGlzLl9wYXJ0cyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJ1ZmZlckJ1aWxkZXIgPSBCdWZmZXJCdWlsZGVyO1xuXG59LHt9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKipcbiAqIFJlbGlhYmxlIHRyYW5zZmVyIGZvciBDaHJvbWUgQ2FuYXJ5IERhdGFDaGFubmVsIGltcGwuXG4gKiBBdXRob3I6IEBtaWNoZWxsZWJ1XG4gKi9cbmZ1bmN0aW9uIFJlbGlhYmxlKGRjLCBkZWJ1Zykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVsaWFibGUpKSByZXR1cm4gbmV3IFJlbGlhYmxlKGRjKTtcbiAgdGhpcy5fZGMgPSBkYztcblxuICB1dGlsLmRlYnVnID0gZGVidWc7XG5cbiAgLy8gTWVzc2FnZXMgc2VudC9yZWNlaXZlZCBzbyBmYXIuXG4gIC8vIGlkOiB7IGFjazogbiwgY2h1bmtzOiBbLi4uXSB9XG4gIHRoaXMuX291dGdvaW5nID0ge307XG4gIC8vIGlkOiB7IGFjazogWydhY2snLCBpZCwgbl0sIGNodW5rczogWy4uLl0gfVxuICB0aGlzLl9pbmNvbWluZyA9IHt9O1xuICB0aGlzLl9yZWNlaXZlZCA9IHt9O1xuXG4gIC8vIFdpbmRvdyBzaXplLlxuICB0aGlzLl93aW5kb3cgPSAxMDAwO1xuICAvLyBNVFUuXG4gIHRoaXMuX210dSA9IDUwMDtcbiAgLy8gSW50ZXJ2YWwgZm9yIHNldEludGVydmFsLiBJbiBtcy5cbiAgdGhpcy5faW50ZXJ2YWwgPSAwO1xuXG4gIC8vIE1lc3NhZ2VzIHNlbnQuXG4gIHRoaXMuX2NvdW50ID0gMDtcblxuICAvLyBPdXRnb2luZyBtZXNzYWdlIHF1ZXVlLlxuICB0aGlzLl9xdWV1ZSA9IFtdO1xuXG4gIHRoaXMuX3NldHVwREMoKTtcbn07XG5cbi8vIFNlbmQgYSBtZXNzYWdlIHJlbGlhYmx5LlxuUmVsaWFibGUucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtc2cpIHtcbiAgLy8gRGV0ZXJtaW5lIGlmIGNodW5raW5nIGlzIG5lY2Vzc2FyeS5cbiAgdmFyIGJsID0gdXRpbC5wYWNrKG1zZyk7XG4gIGlmIChibC5zaXplIDwgdGhpcy5fbXR1KSB7XG4gICAgdGhpcy5faGFuZGxlU2VuZChbJ25vJywgYmxdKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9vdXRnb2luZ1t0aGlzLl9jb3VudF0gPSB7XG4gICAgYWNrOiAwLFxuICAgIGNodW5rczogdGhpcy5fY2h1bmsoYmwpXG4gIH07XG5cbiAgaWYgKHV0aWwuZGVidWcpIHtcbiAgICB0aGlzLl9vdXRnb2luZ1t0aGlzLl9jb3VudF0udGltZXIgPSBuZXcgRGF0ZSgpO1xuICB9XG5cbiAgLy8gU2VuZCBwcmVsaW0gd2luZG93LlxuICB0aGlzLl9zZW5kV2luZG93ZWRDaHVua3ModGhpcy5fY291bnQpO1xuICB0aGlzLl9jb3VudCArPSAxO1xufTtcblxuLy8gU2V0IHVwIGludGVydmFsIGZvciBwcm9jZXNzaW5nIHF1ZXVlLlxuUmVsaWFibGUucHJvdG90eXBlLl9zZXR1cEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRPRE86IGZhaWwgZ3JhY2VmdWxseS5cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3RpbWVvdXQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAvLyBGSVhNRTogU3RyaW5nIHN0dWZmIG1ha2VzIHRoaW5ncyB0ZXJyaWJseSBhc3luYy5cbiAgICB2YXIgbXNnID0gc2VsZi5fcXVldWUuc2hpZnQoKTtcbiAgICBpZiAobXNnLl9tdWx0aXBsZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbXNnLmxlbmd0aDsgaSA8IGlpOyBpICs9IDEpIHtcbiAgICAgICAgc2VsZi5faW50ZXJ2YWxTZW5kKG1zZ1tpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuX2ludGVydmFsU2VuZChtc2cpO1xuICAgIH1cbiAgfSwgdGhpcy5faW50ZXJ2YWwpO1xufTtcblxuUmVsaWFibGUucHJvdG90eXBlLl9pbnRlcnZhbFNlbmQgPSBmdW5jdGlvbihtc2cpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBtc2cgPSB1dGlsLnBhY2sobXNnKTtcbiAgdXRpbC5ibG9iVG9CaW5hcnlTdHJpbmcobXNnLCBmdW5jdGlvbihzdHIpIHtcbiAgICBzZWxmLl9kYy5zZW5kKHN0cik7XG4gIH0pO1xuICBpZiAoc2VsZi5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgY2xlYXJUaW1lb3V0KHNlbGYuX3RpbWVvdXQpO1xuICAgIHNlbGYuX3RpbWVvdXQgPSBudWxsO1xuICAgIC8vc2VsZi5fcHJvY2Vzc0Fja3MoKTtcbiAgfVxufTtcblxuLy8gR28gdGhyb3VnaCBBQ0tzIHRvIHNlbmQgbWlzc2luZyBwaWVjZXMuXG5SZWxpYWJsZS5wcm90b3R5cGUuX3Byb2Nlc3NBY2tzID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGlkIGluIHRoaXMuX291dGdvaW5nKSB7XG4gICAgaWYgKHRoaXMuX291dGdvaW5nLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgdGhpcy5fc2VuZFdpbmRvd2VkQ2h1bmtzKGlkKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIEhhbmRsZSBzZW5kaW5nIGEgbWVzc2FnZS5cbi8vIEZJWE1FOiBEb24ndCB3YWl0IGZvciBpbnRlcnZhbCB0aW1lIGZvciBhbGwgbWVzc2FnZXMuLi5cblJlbGlhYmxlLnByb3RvdHlwZS5faGFuZGxlU2VuZCA9IGZ1bmN0aW9uKG1zZykge1xuICB2YXIgcHVzaCA9IHRydWU7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSA8IGlpOyBpICs9IDEpIHtcbiAgICB2YXIgaXRlbSA9IHRoaXMuX3F1ZXVlW2ldO1xuICAgIGlmIChpdGVtID09PSBtc2cpIHtcbiAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0uX211bHRpcGxlICYmIGl0ZW0uaW5kZXhPZihtc2cpICE9PSAtMSkge1xuICAgICAgcHVzaCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAocHVzaCkge1xuICAgIHRoaXMuX3F1ZXVlLnB1c2gobXNnKTtcbiAgICBpZiAoIXRoaXMuX3RpbWVvdXQpIHtcbiAgICAgIHRoaXMuX3NldHVwSW50ZXJ2YWwoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIFNldCB1cCBEYXRhQ2hhbm5lbCBoYW5kbGVycy5cblJlbGlhYmxlLnByb3RvdHlwZS5fc2V0dXBEQyA9IGZ1bmN0aW9uKCkge1xuICAvLyBIYW5kbGUgdmFyaW91cyBtZXNzYWdlIHR5cGVzLlxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX2RjLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbXNnID0gZS5kYXRhO1xuICAgIHZhciBkYXRhdHlwZSA9IG1zZy5jb25zdHJ1Y3RvcjtcbiAgICAvLyBGSVhNRTogbXNnIGlzIFN0cmluZyB1bnRpbCBiaW5hcnkgaXMgc3VwcG9ydGVkLlxuICAgIC8vIE9uY2UgdGhhdCBoYXBwZW5zLCB0aGlzIHdpbGwgaGF2ZSB0byBiZSBzbWFydGVyLlxuICAgIGlmIChkYXRhdHlwZSA9PT0gU3RyaW5nKSB7XG4gICAgICB2YXIgYWIgPSB1dGlsLmJpbmFyeVN0cmluZ1RvQXJyYXlCdWZmZXIobXNnKTtcbiAgICAgIG1zZyA9IHV0aWwudW5wYWNrKGFiKTtcbiAgICAgIHNlbGYuX2hhbmRsZU1lc3NhZ2UobXNnKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBIYW5kbGVzIGFuIGluY29taW5nIG1lc3NhZ2UuXG5SZWxpYWJsZS5wcm90b3R5cGUuX2hhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgdmFyIGlkID0gbXNnWzFdO1xuICB2YXIgaWRhdGEgPSB0aGlzLl9pbmNvbWluZ1tpZF07XG4gIHZhciBvZGF0YSA9IHRoaXMuX291dGdvaW5nW2lkXTtcbiAgdmFyIGRhdGE7XG4gIHN3aXRjaCAobXNnWzBdKSB7XG4gICAgLy8gTm8gY2h1bmtpbmcgd2FzIGRvbmUuXG4gICAgY2FzZSAnbm8nOlxuICAgICAgdmFyIG1lc3NhZ2UgPSBpZDtcbiAgICAgIGlmICghIW1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5vbm1lc3NhZ2UodXRpbC51bnBhY2sobWVzc2FnZSkpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgLy8gUmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBtZXNzYWdlLlxuICAgIGNhc2UgJ2VuZCc6XG4gICAgICBkYXRhID0gaWRhdGE7XG5cbiAgICAgIC8vIEluIGNhc2UgZW5kIGNvbWVzIGZpcnN0LlxuICAgICAgdGhpcy5fcmVjZWl2ZWRbaWRdID0gbXNnWzJdO1xuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FjayhpZCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhY2snOlxuICAgICAgZGF0YSA9IG9kYXRhO1xuICAgICAgaWYgKCEhZGF0YSkge1xuICAgICAgICB2YXIgYWNrID0gbXNnWzJdO1xuICAgICAgICAvLyBUYWtlIHRoZSBsYXJnZXIgQUNLLCBmb3Igb3V0IG9mIG9yZGVyIG1lc3NhZ2VzLlxuICAgICAgICBkYXRhLmFjayA9IE1hdGgubWF4KGFjaywgZGF0YS5hY2spO1xuXG4gICAgICAgIC8vIENsZWFuIHVwIHdoZW4gYWxsIGNodW5rcyBhcmUgQUNLZWQuXG4gICAgICAgIGlmIChkYXRhLmFjayA+PSBkYXRhLmNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICB1dGlsLmxvZygnVGltZTogJywgbmV3IERhdGUoKSAtIGRhdGEudGltZXIpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9vdXRnb2luZ1tpZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcHJvY2Vzc0Fja3MoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gSWYgIWRhdGEsIGp1c3QgaWdub3JlLlxuICAgICAgYnJlYWs7XG4gICAgLy8gUmVjZWl2ZWQgYSBjaHVuayBvZiBkYXRhLlxuICAgIGNhc2UgJ2NodW5rJzpcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBlbnRyeSBpZiBub25lIGV4aXN0cy5cbiAgICAgIGRhdGEgPSBpZGF0YTtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5fcmVjZWl2ZWRbaWRdO1xuICAgICAgICBpZiAoZW5kID09PSB0cnVlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICBhY2s6IFsnYWNrJywgaWQsIDBdLFxuICAgICAgICAgIGNodW5rczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faW5jb21pbmdbaWRdID0gZGF0YTtcbiAgICAgIH1cblxuICAgICAgdmFyIG4gPSBtc2dbMl07XG4gICAgICB2YXIgY2h1bmsgPSBtc2dbM107XG4gICAgICBkYXRhLmNodW5rc1tuXSA9IG5ldyBVaW50OEFycmF5KGNodW5rKTtcblxuICAgICAgLy8gSWYgd2UgZ2V0IHRoZSBjaHVuayB3ZSdyZSBsb29raW5nIGZvciwgQUNLIGZvciBuZXh0IG1pc3NpbmcuXG4gICAgICAvLyBPdGhlcndpc2UsIEFDSyB0aGUgc2FtZSBOIGFnYWluLlxuICAgICAgaWYgKG4gPT09IGRhdGEuYWNrWzJdKSB7XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZU5leHRBY2soaWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWNrKGlkKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBTaG91bGRuJ3QgaGFwcGVuLCBidXQgd291bGQgbWFrZSBzZW5zZSBmb3IgbWVzc2FnZSB0byBqdXN0IGdvXG4gICAgICAvLyB0aHJvdWdoIGFzIGlzLlxuICAgICAgdGhpcy5faGFuZGxlU2VuZChtc2cpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8vIENodW5rcyBCTCBpbnRvIHNtYWxsZXIgbWVzc2FnZXMuXG5SZWxpYWJsZS5wcm90b3R5cGUuX2NodW5rID0gZnVuY3Rpb24oYmwpIHtcbiAgdmFyIGNodW5rcyA9IFtdO1xuICB2YXIgc2l6ZSA9IGJsLnNpemU7XG4gIHZhciBzdGFydCA9IDA7XG4gIHdoaWxlIChzdGFydCA8IHNpemUpIHtcbiAgICB2YXIgZW5kID0gTWF0aC5taW4oc2l6ZSwgc3RhcnQgKyB0aGlzLl9tdHUpO1xuICAgIHZhciBiID0gYmwuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgdmFyIGNodW5rID0ge1xuICAgICAgcGF5bG9hZDogYlxuICAgIH1cbiAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgc3RhcnQgPSBlbmQ7XG4gIH1cbiAgdXRpbC5sb2coJ0NyZWF0ZWQnLCBjaHVua3MubGVuZ3RoLCAnY2h1bmtzLicpO1xuICByZXR1cm4gY2h1bmtzO1xufTtcblxuLy8gU2VuZHMgQUNLIE4sIGV4cGVjdGluZyBOdGggYmxvYiBjaHVuayBmb3IgbWVzc2FnZSBJRC5cblJlbGlhYmxlLnByb3RvdHlwZS5fYWNrID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIGFjayA9IHRoaXMuX2luY29taW5nW2lkXS5hY2s7XG5cbiAgLy8gaWYgYWNrIGlzIHRoZSBlbmQgdmFsdWUsIHRoZW4gY2FsbCBfY29tcGxldGUuXG4gIGlmICh0aGlzLl9yZWNlaXZlZFtpZF0gPT09IGFja1syXSkge1xuICAgIHRoaXMuX2NvbXBsZXRlKGlkKTtcbiAgICB0aGlzLl9yZWNlaXZlZFtpZF0gPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5faGFuZGxlU2VuZChhY2spO1xufTtcblxuLy8gQ2FsY3VsYXRlcyB0aGUgbmV4dCBBQ0sgbnVtYmVyLCBnaXZlbiBjaHVua3MuXG5SZWxpYWJsZS5wcm90b3R5cGUuX2NhbGN1bGF0ZU5leHRBY2sgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgZGF0YSA9IHRoaXMuX2luY29taW5nW2lkXTtcbiAgdmFyIGNodW5rcyA9IGRhdGEuY2h1bmtzO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBjaHVua3MubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMSkge1xuICAgIC8vIFRoaXMgY2h1bmsgaXMgbWlzc2luZyEhISBCZXR0ZXIgQUNLIGZvciBpdC5cbiAgICBpZiAoY2h1bmtzW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRhdGEuYWNrWzJdID0gaTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgZGF0YS5hY2tbMl0gPSBjaHVua3MubGVuZ3RoO1xufTtcblxuLy8gU2VuZHMgdGhlIG5leHQgd2luZG93IG9mIGNodW5rcy5cblJlbGlhYmxlLnByb3RvdHlwZS5fc2VuZFdpbmRvd2VkQ2h1bmtzID0gZnVuY3Rpb24oaWQpIHtcbiAgdXRpbC5sb2coJ3NlbmRXaW5kb3dlZENodW5rcyBmb3I6ICcsIGlkKTtcbiAgdmFyIGRhdGEgPSB0aGlzLl9vdXRnb2luZ1tpZF07XG4gIHZhciBjaCA9IGRhdGEuY2h1bmtzO1xuICB2YXIgY2h1bmtzID0gW107XG4gIHZhciBsaW1pdCA9IE1hdGgubWluKGRhdGEuYWNrICsgdGhpcy5fd2luZG93LCBjaC5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gZGF0YS5hY2s7IGkgPCBsaW1pdDsgaSArPSAxKSB7XG4gICAgaWYgKCFjaFtpXS5zZW50IHx8IGkgPT09IGRhdGEuYWNrKSB7XG4gICAgICBjaFtpXS5zZW50ID0gdHJ1ZTtcbiAgICAgIGNodW5rcy5wdXNoKFsnY2h1bmsnLCBpZCwgaSwgY2hbaV0ucGF5bG9hZF0pO1xuICAgIH1cbiAgfVxuICBpZiAoZGF0YS5hY2sgKyB0aGlzLl93aW5kb3cgPj0gY2gubGVuZ3RoKSB7XG4gICAgY2h1bmtzLnB1c2goWydlbmQnLCBpZCwgY2gubGVuZ3RoXSlcbiAgfVxuICBjaHVua3MuX211bHRpcGxlID0gdHJ1ZTtcbiAgdGhpcy5faGFuZGxlU2VuZChjaHVua3MpO1xufTtcblxuLy8gUHV0cyB0b2dldGhlciBhIG1lc3NhZ2UgZnJvbSBjaHVua3MuXG5SZWxpYWJsZS5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24oaWQpIHtcbiAgdXRpbC5sb2coJ0NvbXBsZXRlZCBjYWxsZWQgZm9yJywgaWQpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjaHVua3MgPSB0aGlzLl9pbmNvbWluZ1tpZF0uY2h1bmtzO1xuICB2YXIgYmwgPSBuZXcgQmxvYihjaHVua3MpO1xuICB1dGlsLmJsb2JUb0FycmF5QnVmZmVyKGJsLCBmdW5jdGlvbihhYikge1xuICAgIHNlbGYub25tZXNzYWdlKHV0aWwudW5wYWNrKGFiKSk7XG4gIH0pO1xuICBkZWxldGUgdGhpcy5faW5jb21pbmdbaWRdO1xufTtcblxuLy8gVXBzIGJhbmR3aWR0aCBsaW1pdCBvbiBTRFAuIE1lYW50IHRvIGJlIGNhbGxlZCBkdXJpbmcgb2ZmZXIvYW5zd2VyLlxuUmVsaWFibGUuaGlnaGVyQmFuZHdpZHRoU0RQID0gZnVuY3Rpb24oc2RwKSB7XG4gIC8vIEFTIHN0YW5kcyBmb3IgQXBwbGljYXRpb24tU3BlY2lmaWMgTWF4aW11bS5cbiAgLy8gQmFuZHdpZHRoIG51bWJlciBpcyBpbiBraWxvYml0cyAvIHNlYy5cbiAgLy8gU2VlIFJGQyBmb3IgbW9yZSBpbmZvOiBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMzI3LnR4dFxuXG4gIC8vIENocm9tZSAzMSsgZG9lc24ndCB3YW50IHVzIG11bmdpbmcgdGhlIFNEUCwgc28gd2UnbGwgbGV0IHRoZW0gaGF2ZSB0aGVpclxuICAvLyB3YXkuXG4gIHZhciB2ZXJzaW9uID0gbmF2aWdhdG9yLmFwcFZlcnNpb24ubWF0Y2goL0Nocm9tZVxcLyguKj8pIC8pO1xuICBpZiAodmVyc2lvbikge1xuICAgIHZlcnNpb24gPSBwYXJzZUludCh2ZXJzaW9uWzFdLnNwbGl0KCcuJykuc2hpZnQoKSk7XG4gICAgaWYgKHZlcnNpb24gPCAzMSkge1xuICAgICAgdmFyIHBhcnRzID0gc2RwLnNwbGl0KCdiPUFTOjMwJyk7XG4gICAgICB2YXIgcmVwbGFjZSA9ICdiPUFTOjEwMjQwMCc7IC8vIDEwMCBNYnBzXG4gICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gcGFydHNbMF0gKyByZXBsYWNlICsgcGFydHNbMV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNkcDtcbn07XG5cbi8vIE92ZXJ3cml0dGVuLCB0eXBpY2FsbHkuXG5SZWxpYWJsZS5wcm90b3R5cGUub25tZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7fTtcblxubW9kdWxlLmV4cG9ydHMuUmVsaWFibGUgPSBSZWxpYWJsZTtcblxufSx7XCIuL3V0aWxcIjoxM31dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBCaW5hcnlQYWNrID0gcmVxdWlyZSgnanMtYmluYXJ5cGFjaycpO1xuXG52YXIgdXRpbCA9IHtcbiAgZGVidWc6IGZhbHNlLFxuICBcbiAgaW5oZXJpdHM6IGZ1bmN0aW9uKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgZXh0ZW5kOiBmdW5jdGlvbihkZXN0LCBzb3VyY2UpIHtcbiAgICBmb3IodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGRlc3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfSxcbiAgcGFjazogQmluYXJ5UGFjay5wYWNrLFxuICB1bnBhY2s6IEJpbmFyeVBhY2sudW5wYWNrLFxuICBcbiAgbG9nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHV0aWwuZGVidWcpIHtcbiAgICAgIHZhciBjb3B5ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb3B5W2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuICAgICAgY29weS51bnNoaWZ0KCdSZWxpYWJsZTogJyk7XG4gICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBjb3B5KTtcbiAgICB9XG4gIH0sXG5cbiAgc2V0WmVyb1RpbWVvdXQ6IChmdW5jdGlvbihnbG9iYWwpIHtcbiAgICB2YXIgdGltZW91dHMgPSBbXTtcbiAgICB2YXIgbWVzc2FnZU5hbWUgPSAnemVyby10aW1lb3V0LW1lc3NhZ2UnO1xuXG4gICAgLy8gTGlrZSBzZXRUaW1lb3V0LCBidXQgb25seSB0YWtlcyBhIGZ1bmN0aW9uIGFyZ3VtZW50Llx0IFRoZXJlJ3NcbiAgICAvLyBubyB0aW1lIGFyZ3VtZW50IChhbHdheXMgemVybykgYW5kIG5vIGFyZ3VtZW50cyAoeW91IGhhdmUgdG9cbiAgICAvLyB1c2UgYSBjbG9zdXJlKS5cbiAgICBmdW5jdGlvbiBzZXRaZXJvVGltZW91dFBvc3RNZXNzYWdlKGZuKSB7XG4gICAgICB0aW1lb3V0cy5wdXNoKGZuKTtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlTmFtZSwgJyonKTtcbiAgICB9XHRcdFxuXG4gICAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PSBnbG9iYWwgJiYgZXZlbnQuZGF0YSA9PSBtZXNzYWdlTmFtZSkge1xuICAgICAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVvdXRzLmxlbmd0aCkge1xuICAgICAgICAgIHRpbWVvdXRzLnNoaWZ0KCkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb25tZXNzYWdlJywgaGFuZGxlTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBzZXRaZXJvVGltZW91dFBvc3RNZXNzYWdlO1xuICB9KHRoaXMpKSxcbiAgXG4gIGJsb2JUb0FycmF5QnVmZmVyOiBmdW5jdGlvbihibG9iLCBjYil7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGNiKGV2dC50YXJnZXQucmVzdWx0KTtcbiAgICB9O1xuICAgIGZyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICB9LFxuICBibG9iVG9CaW5hcnlTdHJpbmc6IGZ1bmN0aW9uKGJsb2IsIGNiKXtcbiAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgY2IoZXZ0LnRhcmdldC5yZXN1bHQpO1xuICAgIH07XG4gICAgZnIucmVhZEFzQmluYXJ5U3RyaW5nKGJsb2IpO1xuICB9LFxuICBiaW5hcnlTdHJpbmdUb0FycmF5QnVmZmVyOiBmdW5jdGlvbihiaW5hcnkpIHtcbiAgICB2YXIgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5Lmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW5hcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ5dGVBcnJheVtpXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGkpICYgMHhmZjtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVBcnJheS5idWZmZXI7XG4gIH0sXG4gIHJhbmRvbVRva2VuOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsO1xuXG59LHtcImpzLWJpbmFyeXBhY2tcIjoxMH1dfSx7fSxbM10pOyIsIi8qIGh0dHBzOi8vZ2l0aHViLmNvbS9qYWtlYXJjaGliYWxkL2VzNi1wcm9taXNlICovXG4hZnVuY3Rpb24oKXt2YXIgYSxiLGMsZDshZnVuY3Rpb24oKXt2YXIgZT17fSxmPXt9O2E9ZnVuY3Rpb24oYSxiLGMpe2VbYV09e2RlcHM6YixjYWxsYmFjazpjfX0sZD1jPWI9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYyhiKXtpZihcIi5cIiE9PWIuY2hhckF0KDApKXJldHVybiBiO2Zvcih2YXIgYz1iLnNwbGl0KFwiL1wiKSxkPWEuc3BsaXQoXCIvXCIpLnNsaWNlKDAsLTEpLGU9MCxmPWMubGVuZ3RoO2Y+ZTtlKyspe3ZhciBnPWNbZV07aWYoXCIuLlwiPT09ZylkLnBvcCgpO2Vsc2V7aWYoXCIuXCI9PT1nKWNvbnRpbnVlO2QucHVzaChnKX19cmV0dXJuIGQuam9pbihcIi9cIil9aWYoZC5fZWFrX3NlZW49ZSxmW2FdKXJldHVybiBmW2FdO2lmKGZbYV09e30sIWVbYV0pdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgbW9kdWxlIFwiK2EpO2Zvcih2YXIgZyxoPWVbYV0saT1oLmRlcHMsaj1oLmNhbGxiYWNrLGs9W10sbD0wLG09aS5sZW5ndGg7bT5sO2wrKylcImV4cG9ydHNcIj09PWlbbF0/ay5wdXNoKGc9e30pOmsucHVzaChiKGMoaVtsXSkpKTt2YXIgbj1qLmFwcGx5KHRoaXMsayk7cmV0dXJuIGZbYV09Z3x8bn19KCksYShcInByb21pc2UvYWxsXCIsW1wiLi91dGlsc1wiLFwiZXhwb3J0c1wiXSxmdW5jdGlvbihhLGIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGMoYSl7dmFyIGI9dGhpcztpZighZChhKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byBhbGwuXCIpO3JldHVybiBuZXcgYihmdW5jdGlvbihiLGMpe2Z1bmN0aW9uIGQoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe2YoYSxiKX19ZnVuY3Rpb24gZihhLGMpe2hbYV09YywwPT09LS1pJiZiKGgpfXZhciBnLGg9W10saT1hLmxlbmd0aDswPT09aSYmYihbXSk7Zm9yKHZhciBqPTA7ajxhLmxlbmd0aDtqKyspZz1hW2pdLGcmJmUoZy50aGVuKT9nLnRoZW4oZChqKSxjKTpmKGosZyl9KX12YXIgZD1hLmlzQXJyYXksZT1hLmlzRnVuY3Rpb247Yi5hbGw9Y30pLGEoXCJwcm9taXNlL2FzYXBcIixbXCJleHBvcnRzXCJdLGZ1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoKXtyZXR1cm4gZnVuY3Rpb24oKXtwcm9jZXNzLm5leHRUaWNrKGUpfX1mdW5jdGlvbiBjKCl7dmFyIGE9MCxiPW5ldyBpKGUpLGM9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7cmV0dXJuIGIub2JzZXJ2ZShjLHtjaGFyYWN0ZXJEYXRhOiEwfSksZnVuY3Rpb24oKXtjLmRhdGE9YT0rK2ElMn19ZnVuY3Rpb24gZCgpe3JldHVybiBmdW5jdGlvbigpe2ouc2V0VGltZW91dChlLDEpfX1mdW5jdGlvbiBlKCl7Zm9yKHZhciBhPTA7YTxrLmxlbmd0aDthKyspe3ZhciBiPWtbYV0sYz1iWzBdLGQ9YlsxXTtjKGQpfWs9W119ZnVuY3Rpb24gZihhLGIpe3ZhciBjPWsucHVzaChbYSxiXSk7MT09PWMmJmcoKX12YXIgZyxoPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93Ont9LGk9aC5NdXRhdGlvbk9ic2VydmVyfHxoLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsaj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDp2b2lkIDA9PT10aGlzP3dpbmRvdzp0aGlzLGs9W107Zz1cInVuZGVmaW5lZFwiIT10eXBlb2YgcHJvY2VzcyYmXCJbb2JqZWN0IHByb2Nlc3NdXCI9PT17fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpP2IoKTppP2MoKTpkKCksYS5hc2FwPWZ9KSxhKFwicHJvbWlzZS9jb25maWdcIixbXCJleHBvcnRzXCJdLGZ1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYSxiKXtyZXR1cm4gMiE9PWFyZ3VtZW50cy5sZW5ndGg/Y1thXTooY1thXT1iLHZvaWQgMCl9dmFyIGM9e2luc3RydW1lbnQ6ITF9O2EuY29uZmlnPWMsYS5jb25maWd1cmU9Yn0pLGEoXCJwcm9taXNlL3BvbHlmaWxsXCIsW1wiLi9wcm9taXNlXCIsXCIuL3V0aWxzXCIsXCJleHBvcnRzXCJdLGZ1bmN0aW9uKGEsYixjKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBkKCl7dmFyIGE7YT1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuZG9jdW1lbnQ/d2luZG93OnNlbGY7dmFyIGI9XCJQcm9taXNlXCJpbiBhJiZcInJlc29sdmVcImluIGEuUHJvbWlzZSYmXCJyZWplY3RcImluIGEuUHJvbWlzZSYmXCJhbGxcImluIGEuUHJvbWlzZSYmXCJyYWNlXCJpbiBhLlByb21pc2UmJmZ1bmN0aW9uKCl7dmFyIGI7cmV0dXJuIG5ldyBhLlByb21pc2UoZnVuY3Rpb24oYSl7Yj1hfSksZihiKX0oKTtifHwoYS5Qcm9taXNlPWUpfXZhciBlPWEuUHJvbWlzZSxmPWIuaXNGdW5jdGlvbjtjLnBvbHlmaWxsPWR9KSxhKFwicHJvbWlzZS9wcm9taXNlXCIsW1wiLi9jb25maWdcIixcIi4vdXRpbHNcIixcIi4vYWxsXCIsXCIuL3JhY2VcIixcIi4vcmVzb2x2ZVwiLFwiLi9yZWplY3RcIixcIi4vYXNhcFwiLFwiZXhwb3J0c1wiXSxmdW5jdGlvbihhLGIsYyxkLGUsZixnLGgpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkoYSl7aWYoIXYoYSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3JcIik7aWYoISh0aGlzIGluc3RhbmNlb2YgaSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTt0aGlzLl9zdWJzY3JpYmVycz1bXSxqKGEsdGhpcyl9ZnVuY3Rpb24gaihhLGIpe2Z1bmN0aW9uIGMoYSl7byhiLGEpfWZ1bmN0aW9uIGQoYSl7cShiLGEpfXRyeXthKGMsZCl9Y2F0Y2goZSl7ZChlKX19ZnVuY3Rpb24gayhhLGIsYyxkKXt2YXIgZSxmLGcsaCxpPXYoYyk7aWYoaSl0cnl7ZT1jKGQpLGc9ITB9Y2F0Y2goail7aD0hMCxmPWp9ZWxzZSBlPWQsZz0hMDtuKGIsZSl8fChpJiZnP28oYixlKTpoP3EoYixmKTphPT09RD9vKGIsZSk6YT09PUUmJnEoYixlKSl9ZnVuY3Rpb24gbChhLGIsYyxkKXt2YXIgZT1hLl9zdWJzY3JpYmVycyxmPWUubGVuZ3RoO2VbZl09YixlW2YrRF09YyxlW2YrRV09ZH1mdW5jdGlvbiBtKGEsYil7Zm9yKHZhciBjLGQsZT1hLl9zdWJzY3JpYmVycyxmPWEuX2RldGFpbCxnPTA7ZzxlLmxlbmd0aDtnKz0zKWM9ZVtnXSxkPWVbZytiXSxrKGIsYyxkLGYpO2EuX3N1YnNjcmliZXJzPW51bGx9ZnVuY3Rpb24gbihhLGIpe3ZhciBjLGQ9bnVsbDt0cnl7aWYoYT09PWIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS5cIik7aWYodShiKSYmKGQ9Yi50aGVuLHYoZCkpKXJldHVybiBkLmNhbGwoYixmdW5jdGlvbihkKXtyZXR1cm4gYz8hMDooYz0hMCxiIT09ZD9vKGEsZCk6cChhLGQpLHZvaWQgMCl9LGZ1bmN0aW9uKGIpe3JldHVybiBjPyEwOihjPSEwLHEoYSxiKSx2b2lkIDApfSksITB9Y2F0Y2goZSl7cmV0dXJuIGM/ITA6KHEoYSxlKSwhMCl9cmV0dXJuITF9ZnVuY3Rpb24gbyhhLGIpe2E9PT1iP3AoYSxiKTpuKGEsYil8fHAoYSxiKX1mdW5jdGlvbiBwKGEsYil7YS5fc3RhdGU9PT1CJiYoYS5fc3RhdGU9QyxhLl9kZXRhaWw9Yix0LmFzeW5jKHIsYSkpfWZ1bmN0aW9uIHEoYSxiKXthLl9zdGF0ZT09PUImJihhLl9zdGF0ZT1DLGEuX2RldGFpbD1iLHQuYXN5bmMocyxhKSl9ZnVuY3Rpb24gcihhKXttKGEsYS5fc3RhdGU9RCl9ZnVuY3Rpb24gcyhhKXttKGEsYS5fc3RhdGU9RSl9dmFyIHQ9YS5jb25maWcsdT0oYS5jb25maWd1cmUsYi5vYmplY3RPckZ1bmN0aW9uKSx2PWIuaXNGdW5jdGlvbix3PShiLm5vdyxjLmFsbCkseD1kLnJhY2UseT1lLnJlc29sdmUsej1mLnJlamVjdCxBPWcuYXNhcDt0LmFzeW5jPUE7dmFyIEI9dm9pZCAwLEM9MCxEPTEsRT0yO2kucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjppLF9zdGF0ZTp2b2lkIDAsX2RldGFpbDp2b2lkIDAsX3N1YnNjcmliZXJzOnZvaWQgMCx0aGVuOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxkPW5ldyB0aGlzLmNvbnN0cnVjdG9yKGZ1bmN0aW9uKCl7fSk7aWYodGhpcy5fc3RhdGUpe3ZhciBlPWFyZ3VtZW50czt0LmFzeW5jKGZ1bmN0aW9uKCl7ayhjLl9zdGF0ZSxkLGVbYy5fc3RhdGUtMV0sYy5fZGV0YWlsKX0pfWVsc2UgbCh0aGlzLGQsYSxiKTtyZXR1cm4gZH0sXCJjYXRjaFwiOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnRoZW4obnVsbCxhKX19LGkuYWxsPXcsaS5yYWNlPXgsaS5yZXNvbHZlPXksaS5yZWplY3Q9eixoLlByb21pc2U9aX0pLGEoXCJwcm9taXNlL3JhY2VcIixbXCIuL3V0aWxzXCIsXCJleHBvcnRzXCJdLGZ1bmN0aW9uKGEsYil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYyhhKXt2YXIgYj10aGlzO2lmKCFkKGEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuXCIpO3JldHVybiBuZXcgYihmdW5jdGlvbihiLGMpe2Zvcih2YXIgZCxlPTA7ZTxhLmxlbmd0aDtlKyspZD1hW2VdLGQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGQudGhlbj9kLnRoZW4oYixjKTpiKGQpfSl9dmFyIGQ9YS5pc0FycmF5O2IucmFjZT1jfSksYShcInByb21pc2UvcmVqZWN0XCIsW1wiZXhwb3J0c1wiXSxmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGEpe3ZhciBiPXRoaXM7cmV0dXJuIG5ldyBiKGZ1bmN0aW9uKGIsYyl7YyhhKX0pfWEucmVqZWN0PWJ9KSxhKFwicHJvbWlzZS9yZXNvbHZlXCIsW1wiZXhwb3J0c1wiXSxmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGEpe2lmKGEmJlwib2JqZWN0XCI9PXR5cGVvZiBhJiZhLmNvbnN0cnVjdG9yPT09dGhpcylyZXR1cm4gYTt2YXIgYj10aGlzO3JldHVybiBuZXcgYihmdW5jdGlvbihiKXtiKGEpfSl9YS5yZXNvbHZlPWJ9KSxhKFwicHJvbWlzZS91dGlsc1wiLFtcImV4cG9ydHNcIl0sZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihhKXtyZXR1cm4gYyhhKXx8XCJvYmplY3RcIj09dHlwZW9mIGEmJm51bGwhPT1hfWZ1bmN0aW9uIGMoYSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgYX1mdW5jdGlvbiBkKGEpe3JldHVyblwiW29iamVjdCBBcnJheV1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKX12YXIgZT1EYXRlLm5vd3x8ZnVuY3Rpb24oKXtyZXR1cm4obmV3IERhdGUpLmdldFRpbWUoKX07YS5vYmplY3RPckZ1bmN0aW9uPWIsYS5pc0Z1bmN0aW9uPWMsYS5pc0FycmF5PWQsYS5ub3c9ZX0pLGIoXCJwcm9taXNlL3BvbHlmaWxsXCIpLnBvbHlmaWxsKCl9KCk7IiwiLypcclxuQ29weXJpZ2h0IChDKSAyMDExIFBhdHJpY2sgR2lsbGVzcGllLCBodHRwOi8vcGF0b3Jqay5jb20vXHJcblxyXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xyXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcblRIRSBTT0ZUV0FSRS5cclxuKi9cclxuXHJcbi8qXHJcbiAgICBFeHRlbmRpYmxlIEJCQ29kZSBQYXJzZXIgdjEuMC4wXHJcbiAgICBCeSBQYXRyaWNrIEdpbGxlc3BpZSAocGF0b3Jqa0BnbWFpbC5jb20pXHJcbiAgICBXZWJzaXRlOiBodHRwOi8vcGF0b3Jqay5jb20vXHJcblxyXG4gICAgVGhpcyBtb2R1bGUgYWxsb3dzIHlvdSB0byBwYXJzZSBCQkNvZGUgYW5kIHRvIGV4dGVuZCB0byB0aGUgbWFyay11cCBsYW5ndWFnZVxyXG4gICAgdG8gYWRkIGluIHlvdXIgb3duIHRhZ3MuXHJcbiovXHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBYQkJDT0RFID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBTZXQgdXAgcHJpdmF0ZSB2YXJpYWJsZXNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgdmFyIG1lID0ge30sXHJcbiAgICAgICAgdXJsUGF0dGVybiA9IC9eKD86aHR0cHM/fGZpbGV8Yyk6KD86XFwvezEsM318XFxcXHsxfSlbLWEtekEtWjAtOTpAIyUmKCl+Xz9cXCs9XFwvXFxcXFxcLl0qJC8sXHJcbiAgICAgICAgY29sb3JOYW1lUGF0dGVybiA9IC9eKD86cmVkfGdyZWVufGJsdWV8b3JhbmdlfHllbGxvd3xibGFja3x3aGl0ZXxicm93bnxncmF5fHNpbHZlcnxwdXJwbGV8bWFyb29ufGZ1c2hzaWF8bGltZXxvbGl2ZXxuYXZ5fHRlYWx8YXF1YSkkLyxcclxuICAgICAgICBjb2xvckNvZGVQYXR0ZXJuID0gL14jP1thLWZBLUYwLTldezZ9JC8sXHJcbiAgICAgICAgdGFncyxcclxuICAgICAgICB0YWdMaXN0LFxyXG4gICAgICAgIHRhZ3NOb1BhcnNlTGlzdCA9IFtdLFxyXG4gICAgICAgIGJiUmVnRXhwLFxyXG4gICAgICAgIHBiYlJlZ0V4cCxcclxuICAgICAgICBwYmJSZWdFeHAyLFxyXG4gICAgICAgIG9wZW5UYWdzLFxyXG4gICAgICAgIGNsb3NlVGFncztcclxuICAgICAgICBcclxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgKiB0YWdzXHJcbiAgICAgKiBUaGlzIG9iamVjdCBjb250YWlucyBhIGxpc3Qgb2YgdGFncyB0aGF0IHlvdXIgY29kZSB3aWxsIGJlIGFibGUgdG8gdW5kZXJzdGFuZC5cclxuICAgICAqIEVhY2ggdGFnIG9iamVjdCBoYXMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICpcclxuICAgICAqICAgb3BlblRhZyAtIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBpbiB0aGUgdGFnJ3MgcGFyYW1ldGVycyAoaWYgYW55KSBhbmQgaXRzXHJcbiAgICAgKiAgICAgICAgICAgICBjb250ZW50cywgYW5kIHJldHVybnMgd2hhdCBpdHMgSFRNTCBvcGVuIHRhZyBzaG91bGQgYmUuIFxyXG4gICAgICogICAgICAgICAgICAgRXhhbXBsZTogW2NvbG9yPXJlZF10ZXN0Wy9jb2xvcl0gd291bGQgdGFrZSBpbiBcIj1yZWRcIiBhcyBhXHJcbiAgICAgKiAgICAgICAgICAgICBwYXJhbWV0ZXIgaW5wdXQsIGFuZCBcInRlc3RcIiBhcyBhIGNvbnRlbnQgaW5wdXQuXHJcbiAgICAgKiAgICAgICAgICAgICBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdCBhbnkgQkJDb2RlIGluc2lkZSBvZiBcImNvbnRlbnRcIiB3aWxsIGhhdmUgXHJcbiAgICAgKiAgICAgICAgICAgICBiZWVuIHByb2Nlc3NlZCBieSB0aGUgdGltZSBpdCBlbnRlciB0aGUgb3BlblRhZyBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiAgIGNsb3NlVGFnIC0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGluIHRoZSB0YWcncyBwYXJhbWV0ZXJzIChpZiBhbnkpIGFuZCBpdHNcclxuICAgICAqICAgICAgICAgICAgICBjb250ZW50cywgYW5kIHJldHVybnMgd2hhdCBpdHMgSFRNTCBjbG9zZSB0YWcgc2hvdWxkIGJlLlxyXG4gICAgICpcclxuICAgICAqICAgZGlzcGxheUNvbnRlbnQgLSBEZWZhdWx0cyB0byB0cnVlLiBJZiBmYWxzZSwgdGhlIGNvbnRlbnQgZm9yIHRoZSB0YWcgd2lsbFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgIG5vdCBiZSBkaXNwbGF5ZWQuIFRoaXMgaXMgdXNlZnVsIGZvciB0YWdzIGxpa2UgSU1HIHdoZXJlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgaXRzIGNvbnRlbnRzIGFyZSBhY3R1YWxseSBhIHBhcmFtZXRlciBpbnB1dC5cclxuICAgICAqXHJcbiAgICAgKiAgIHJlc3RyaWN0Q2hpbGRyZW5UbyAtIEEgbGlzdCBvZiBCQkNvZGUgdGFncyB3aGljaCBhcmUgYWxsb3dlZCB0byBiZSBuZXN0ZWRcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgd2l0aGluIHRoaXMgQkJDb2RlIHRhZy4gSWYgdGhpcyBwcm9wZXJ0eSBpcyBvbWl0dGVkLFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBhbnkgQkJDb2RlIHRhZyBtYXkgYmUgbmVzdGVkIHdpdGhpbiB0aGUgdGFnLlxyXG4gICAgICpcclxuICAgICAqICAgcmVzdHJpY3RQYXJlbnRzVG8gLSBBIGxpc3Qgb2YgQkJDb2RlIHRhZ3Mgd2hpY2ggYXJlIGFsbG93ZWQgdG8gYmUgcGFyZW50cyBvZlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIHRoaXMgQkJDb2RlIHRhZy4gSWYgdGhpcyBwcm9wZXJ0eSBpcyBvbWl0dGVkLCBhbnkgQkJDb2RlIFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIHRhZyBtYXkgYmUgYSBwYXJlbnQgb2YgdGhlIHRhZy5cclxuICAgICAqXHJcbiAgICAgKiAgIG5vUGFyc2UgLSB0cnVlIG9yIGZhbHNlLiBJZiB0cnVlLCBub25lIG9mIHRoZSBjb250ZW50IFdJVEhJTiB0aGlzIHRhZyB3aWxsIGJlXHJcbiAgICAgKiAgICAgICAgICAgICBwYXJzZWQgYnkgdGhlIFhCQkNvZGUgcGFyc2VyLlxyXG4gICAgICogICAgICAgXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIExJTUlUSU9OUyBvbiBhZGRpbmcgTkVXIFRBR1M6XHJcbiAgICAgKiAgLSBUYWcgbmFtZXMgc2hvdWxkIGJlIGFscGhhbnVtZXJpYyAoaW5jbHVkaW5nIHVuZGVyc2NvcmVzKSBhbmQgYWxsIHRhZ3Mgc2hvdWxkIGhhdmUgYW4gb3BlbmluZyB0YWdcclxuICAgICAqICAgIGFuZCBhIGNsb3NpbmcgdGFnLiBcclxuICAgICAqICAgIFRoZSBbKl0gdGFnIGlzIGFuIGV4Y2VwdGlvbiBiZWNhdXNlIGl0IHdhcyBhbHJlYWR5IGEgc3RhbmRhcmRcclxuICAgICAqICAgIGJiY29kZSB0YWcuIFRlY2huZWNpYWxseSB0YWdzIGRvbid0ICpoYXZlKiB0byBiZSBhbHBoYW51bWVyaWMsIGJ1dCBzaW5jZSBcclxuICAgICAqICAgIHJlZ3VsYXIgZXhwcmVzc2lvbnMgYXJlIHVzZWQgdG8gcGFyc2UgdGhlIHRleHQsIGlmIHlvdSB1c2UgYSBub24tYWxwaGFudW1lcmljIFxyXG4gICAgICogICAgdGFnIG5hbWVzLCBqdXN0IG1ha2Ugc3VyZSB0aGUgdGFnIG5hbWUgZ2V0cyBlc2NhcGVkIHByb3Blcmx5IChpZiBuZWVkZWQpLlxyXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICAgICAgXHJcbiAgICB0YWdzID0ge1xyXG4gICAgICAgIFwiYlwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwieGJiY29kZS1iXCI+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKlxyXG4gICAgICAgICAgICBUaGlzIHRhZyBkb2VzIG5vdGhpbmcgYW5kIGlzIGhlcmUgbW9zdGx5IHRvIGJlIHVzZWQgYXMgYSBjbGFzc2lmaWNhdGlvbiBmb3JcclxuICAgICAgICAgICAgdGhlIGJiY29kZSBpbnB1dCB3aGVuIGV2YWx1YXRpbmcgcGFyZW50LWNoaWxkIHRhZyByZWxhdGlvbnNoaXBzXHJcbiAgICAgICAgKi9cclxuICAgICAgICBcImJiY29kZVwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImNvZGVcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cInhiYmNvZGUtY29kZVwiPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L3NwYW4+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbm9QYXJzZTogdHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJjb2xvclwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yQ29kZSA9IHBhcmFtcy5zdWJzdHIoMSkgfHwgXCJibGFja1wiO1xyXG4gICAgICAgICAgICAgICAgY29sb3JOYW1lUGF0dGVybi5sYXN0SW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgY29sb3JDb2RlUGF0dGVybi5sYXN0SW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhY29sb3JOYW1lUGF0dGVybi50ZXN0KCBjb2xvckNvZGUgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoICFjb2xvckNvZGVQYXR0ZXJuLnRlc3QoIGNvbG9yQ29kZSApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckNvZGUgPSBcImJsYWNrXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yQ29kZS5zdWJzdHIoMCwxKSAhPT0gXCIjXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yQ29kZSA9IFwiI1wiICsgY29sb3JDb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHNwYW4gc3R5bGU9XCJjb2xvcjonICsgY29sb3JDb2RlICsgJ1wiPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L3NwYW4+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJpXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCJ4YmJjb2RlLWlcIj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC9zcGFuPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiaW1nXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgbXlVcmwgPSBjb250ZW50O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB1cmxQYXR0ZXJuLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoICF1cmxQYXR0ZXJuLnRlc3QoIG15VXJsICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbXlVcmwgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPGltZyBzcmM9XCInICsgbXlVcmwgKyAnXCIgLz4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGlzcGxheUNvbnRlbnQ6IGZhbHNlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImxpc3RcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8dWw+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvdWw+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVzdHJpY3RDaGlsZHJlblRvOiBbXCIqXCIsIFwibGlcIl1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwibm9wYXJzZVwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBub1BhcnNlOiB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInBocFwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwieGJiY29kZS1jb2RlXCI+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBub1BhcnNlOiB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInF1b3RlXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPGJsb2NrcXVvdGUgY2xhc3M9XCJ4YmJjb2RlLWJsb2NrcXVvdGVcIj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC9ibG9ja3F1b3RlPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwic1wiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwieGJiY29kZS1zXCI+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInNpemVcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHZhciBteVNpemUgPSBwYXJzZUludChwYXJhbXMuc3Vic3RyKDEpLDEwKSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKG15U2l6ZSA8IDQgfHwgbXlTaXplID4gNDApIHtcclxuICAgICAgICAgICAgICAgICAgICBteVNpemUgPSAxNDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwieGJiY29kZS1zaXplLScgKyBteVNpemUgKyAnXCI+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInRhYmxlXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHRhYmxlIGNsYXNzPVwieGJiY29kZS10YWJsZVwiPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L3RhYmxlPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc3RyaWN0Q2hpbGRyZW5UbzogW1widGJvZHlcIixcInRoZWFkXCIsIFwidGZvb3RcIiwgXCJ0clwiXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0Ym9keVwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzx0Ym9keT4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC90Ym9keT4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXN0cmljdENoaWxkcmVuVG86IFtcInRyXCJdLFxyXG4gICAgICAgICAgICByZXN0cmljdFBhcmVudHNUbzogW1widGFibGVcIl1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidGZvb3RcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8dGZvb3Q+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvdGZvb3Q+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVzdHJpY3RDaGlsZHJlblRvOiBbXCJ0clwiXSxcclxuICAgICAgICAgICAgcmVzdHJpY3RQYXJlbnRzVG86IFtcInRhYmxlXCJdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInRoZWFkXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHRoZWFkIGNsYXNzPVwieGJiY29kZS10aGVhZFwiPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L3RoZWFkPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc3RyaWN0Q2hpbGRyZW5UbzogW1widHJcIl0sXHJcbiAgICAgICAgICAgIHJlc3RyaWN0UGFyZW50c1RvOiBbXCJ0YWJsZVwiXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0ZFwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzx0ZCBjbGFzcz1cInhiYmNvZGUtdGRcIj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC90ZD4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXN0cmljdFBhcmVudHNUbzogW1widHJcIl1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidGhcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJ4YmJjb2RlLXRoXCI+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvdGQ+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVzdHJpY3RQYXJlbnRzVG86IFtcInRyXCJdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInRyXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHRyIGNsYXNzPVwieGJiY29kZS10clwiPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L3RyPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc3RyaWN0Q2hpbGRyZW5UbzogW1widGRcIixcInRoXCJdLFxyXG4gICAgICAgICAgICByZXN0cmljdFBhcmVudHNUbzogW1widGFibGVcIixcInRib2R5XCIsXCJ0Zm9vdFwiLFwidGhlYWRcIl1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidVwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwieGJiY29kZS11XCI+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInVybFwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIG15VXJsO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmICghcGFyYW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbXlVcmwgPSBjb250ZW50LnJlcGxhY2UoLzwuKj8+L2csXCJcIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG15VXJsID0gcGFyYW1zLnN1YnN0cigxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdXJsUGF0dGVybi5sYXN0SW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhdXJsUGF0dGVybi50ZXN0KCBteVVybCApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIG15VXJsID0gXCIjXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8YSBocmVmPVwiJyArIG15VXJsICsgJ1wiPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L2E+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLypcclxuICAgICAgICAgICAgVGhlIFsqXSB0YWcgaXMgc3BlY2lhbCBzaW5jZSB0aGUgdXNlciBkb2VzIG5vdCBkZWZpbmUgYSBjbG9zaW5nIFsvKl0gdGFnIHdoZW4gd3JpdGluZyB0aGVpciBiYmNvZGUuXHJcbiAgICAgICAgICAgIEluc3RlYWQgdGhpcyBtb2R1bGUgcGFyc2VzIHRoZSBjb2RlIGFuZCBhZGRzIHRoZSBjbG9zaW5nIFsvKl0gdGFnIGluIGZvciB0aGVtLiBOb25lIG9mIHRoZSB0YWdzIHlvdVxyXG4gICAgICAgICAgICBhZGQgd2lsbCBhY3QgbGlrZSB0aGlzIGFuZCB0aGlzIHRhZyBpcyBhbiBleGNlcHRpb24gdG8gdGhlIG90aGVycy5cclxuICAgICAgICAqL1xyXG4gICAgICAgIFwiKlwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCI8bGk+XCI7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiPC9saT5cIjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVzdHJpY3RQYXJlbnRzVG86IFtcImxpc3RcIl1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBjcmVhdGUgdGFnIGxpc3QgYW5kIGxvb2t1cCBmaWVsZHNcclxuICAgIHRhZ0xpc3QgPSBbXTtcclxuICAgIChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcHJvcCxcclxuICAgICAgICAgICAgaWksXHJcbiAgICAgICAgICAgIGxlbjtcclxuICAgICAgICBmb3IgKHByb3AgaW4gdGFncykge1xyXG4gICAgICAgICAgICBpZiAodGFncy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IFwiKlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFnTGlzdC5wdXNoKFwiXFxcXFwiICsgcHJvcCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhZ0xpc3QucHVzaChwcm9wKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRhZ3NbcHJvcF0ubm9QYXJzZSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnc05vUGFyc2VMaXN0LnB1c2gocHJvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB0YWdzW3Byb3BdLnZhbGlkQ2hpbGRMb29rdXAgPSB7fTtcclxuICAgICAgICAgICAgICAgIHRhZ3NbcHJvcF0udmFsaWRQYXJlbnRMb29rdXAgPSB7fTtcclxuICAgICAgICAgICAgICAgIHRhZ3NbcHJvcF0ucmVzdHJpY3RQYXJlbnRzVG8gPSB0YWdzW3Byb3BdLnJlc3RyaWN0UGFyZW50c1RvIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgdGFnc1twcm9wXS5yZXN0cmljdENoaWxkcmVuVG8gPSB0YWdzW3Byb3BdLnJlc3RyaWN0Q2hpbGRyZW5UbyB8fCBbXTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgbGVuID0gdGFnc1twcm9wXS5yZXN0cmljdENoaWxkcmVuVG8ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpaSA9IDA7IGlpIDwgbGVuOyBpaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFnc1twcm9wXS52YWxpZENoaWxkTG9va3VwWyB0YWdzW3Byb3BdLnJlc3RyaWN0Q2hpbGRyZW5Ub1tpaV0gXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZW4gPSB0YWdzW3Byb3BdLnJlc3RyaWN0UGFyZW50c1RvLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAoaWkgPSAwOyBpaSA8IGxlbjsgaWkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhZ3NbcHJvcF0udmFsaWRQYXJlbnRMb29rdXBbIHRhZ3NbcHJvcF0ucmVzdHJpY3RQYXJlbnRzVG9baWldIF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSkoKTtcclxuICAgIFxyXG4gICAgYmJSZWdFeHAgPSBuZXcgUmVnRXhwKFwiPGJiY2w9KFswLTldKykgKFwiICsgdGFnTGlzdC5qb2luKFwifFwiKSArIFwiKShbID1dW14+XSo/KT8+KCg/Oi58W1xcXFxyXFxcXG5dKSo/KTxiYmNsPVxcXFwxIC9cXFxcMj5cIiwgXCJnaVwiKTsgXHJcbiAgICBwYmJSZWdFeHAgPSBuZXcgUmVnRXhwKFwiXFxcXFsoXCIgKyB0YWdMaXN0LmpvaW4oXCJ8XCIpICsgXCIpKFsgPV1bXlxcXFxdXSo/KT9cXFxcXShbXlxcXFxbXSo/KVxcXFxbL1xcXFwxXFxcXF1cIiwgXCJnaVwiKTsgXHJcbiAgICBwYmJSZWdFeHAyID0gbmV3IFJlZ0V4cChcIlxcXFxbKFwiICsgdGFnc05vUGFyc2VMaXN0LmpvaW4oXCJ8XCIpICsgXCIpKFsgPV1bXlxcXFxdXSo/KT9cXFxcXShbXFxcXHNcXFxcU10qPylcXFxcWy9cXFxcMVxcXFxdXCIsIFwiZ2lcIik7ICAgIFxyXG5cclxuICAgIC8vIGNyZWF0ZSB0aGUgcmVnZXggZm9yIGVzY2FwaW5nIFsncyB0aGF0IGFyZW4ndCBhcGFydCBvZiB0YWdzXHJcbiAgICAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGNsb3NlVGFnTGlzdCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCB0YWdMaXN0Lmxlbmd0aDsgaWkrKykge1xyXG4gICAgICAgICAgICBpZiAoIHRhZ0xpc3RbaWldICE9PSBcIlxcXFwqXCIgKSB7IC8vIHRoZSAqIHRhZyBkb2Vzbid0IGhhdmUgYW4gb2ZmaWNhbCBjbG9zaW5nIHRhZ1xyXG4gICAgICAgICAgICAgICAgY2xvc2VUYWdMaXN0LnB1c2ggKCBcIi9cIiArIHRhZ0xpc3RbaWldICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9wZW5UYWdzID0gbmV3IFJlZ0V4cChcIihcXFxcWykoKD86XCIgKyB0YWdMaXN0LmpvaW4oXCJ8XCIpICsgXCIpKD86WyA9XVteXFxcXF1dKj8pPykoXFxcXF0pXCIsIFwiZ2lcIik7IFxyXG4gICAgICAgIGNsb3NlVGFncyA9IG5ldyBSZWdFeHAoXCIoXFxcXFspKFwiICsgY2xvc2VUYWdMaXN0LmpvaW4oXCJ8XCIpICsgXCIpKFxcXFxdKVwiLCBcImdpXCIpOyBcclxuICAgIH0pKCk7XHJcbiAgICBcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBwcml2YXRlIGZ1bmN0aW9uc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY2hlY2tQYXJlbnRDaGlsZFJlc3RyaWN0aW9ucyhwYXJlbnRUYWcsIGJiY29kZSwgYmJjb2RlTGV2ZWwsIHRhZ05hbWUsIHRhZ1BhcmFtcywgdGFnQ29udGVudHMsIGVyclF1ZXVlKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZXJyUXVldWUgPSBlcnJRdWV1ZSB8fCBbXTtcclxuICAgICAgICBiYmNvZGVMZXZlbCsrO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIGdldCBhIGxpc3Qgb2YgYWxsIG9mIHRoZSBjaGlsZCB0YWdzIHRvIHRoaXMgdGFnXHJcbiAgICAgICAgdmFyIHJlVGFnTmFtZXMgPSBuZXcgUmVnRXhwKFwiKDxiYmNsPVwiICsgYmJjb2RlTGV2ZWwgKyBcIiApKFwiICsgdGFnTGlzdC5qb2luKFwifFwiKSArIFwiKShbID0+XSlcIixcImdpXCIpLFxyXG4gICAgICAgICAgICByZVRhZ05hbWVzUGFydHMgPSBuZXcgUmVnRXhwKFwiKDxiYmNsPVwiICsgYmJjb2RlTGV2ZWwgKyBcIiApKFwiICsgdGFnTGlzdC5qb2luKFwifFwiKSArIFwiKShbID0+XSlcIixcImlcIiksXHJcbiAgICAgICAgICAgIG1hdGNoaW5nVGFncyA9IHRhZ0NvbnRlbnRzLm1hdGNoKHJlVGFnTmFtZXMpIHx8IFtdLFxyXG4gICAgICAgICAgICBjSW5mbyxcclxuICAgICAgICAgICAgZXJyU3RyLFxyXG4gICAgICAgICAgICBpaSxcclxuICAgICAgICAgICAgY2hpbGRUYWcsXHJcbiAgICAgICAgICAgIHBJbmZvID0gdGFnc1twYXJlbnRUYWddIHx8IHt9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJlVGFnTmFtZXMubGFzdEluZGV4ID0gMDtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoIW1hdGNoaW5nVGFncykge1xyXG4gICAgICAgICAgICB0YWdDb250ZW50cyA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAoaWkgPSAwOyBpaSA8IG1hdGNoaW5nVGFncy5sZW5ndGg7IGlpKyspIHtcclxuICAgICAgICAgICAgcmVUYWdOYW1lc1BhcnRzLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGNoaWxkVGFnID0gKG1hdGNoaW5nVGFnc1tpaV0ubWF0Y2gocmVUYWdOYW1lc1BhcnRzKSlbMl0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICggcEluZm8ucmVzdHJpY3RDaGlsZHJlblRvLmxlbmd0aCA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoICFwSW5mby52YWxpZENoaWxkTG9va3VwW2NoaWxkVGFnXSApIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSBcIlRoZSB0YWcgXFxcIlwiICsgY2hpbGRUYWcgKyBcIlxcXCIgaXMgbm90IGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGUgdGFnIFxcXCJcIiArIHBhcmVudFRhZyArIFwiXFxcIi5cIjtcclxuICAgICAgICAgICAgICAgICAgICBlcnJRdWV1ZS5wdXNoKGVyclN0cik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY0luZm8gPSB0YWdzW2NoaWxkVGFnXSB8fCB7fTtcclxuICAgICAgICAgICAgaWYgKCBjSW5mby5yZXN0cmljdFBhcmVudHNUby5sZW5ndGggPiAwICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhY0luZm8udmFsaWRQYXJlbnRMb29rdXBbcGFyZW50VGFnXSApIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSBcIlRoZSB0YWcgXFxcIlwiICsgcGFyZW50VGFnICsgXCJcXFwiIGlzIG5vdCBhbGxvd2VkIGFzIGEgcGFyZW50IG9mIHRoZSB0YWcgXFxcIlwiICsgY2hpbGRUYWcgKyBcIlxcXCIuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyUXVldWUucHVzaChlcnJTdHIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0YWdDb250ZW50cyA9IHRhZ0NvbnRlbnRzLnJlcGxhY2UoYmJSZWdFeHAsIGZ1bmN0aW9uKG1hdGNoU3RyLCBiYmNvZGVMZXZlbCwgdGFnTmFtZSwgdGFnUGFyYW1zLCB0YWdDb250ZW50cyApIHtcclxuICAgICAgICAgICAgZXJyUXVldWUgPSBjaGVja1BhcmVudENoaWxkUmVzdHJpY3Rpb25zKHRhZ05hbWUsIG1hdGNoU3RyLCBiYmNvZGVMZXZlbCwgdGFnTmFtZSwgdGFnUGFyYW1zLCB0YWdDb250ZW50cywgZXJyUXVldWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hTdHI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGVyclF1ZXVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKlxyXG4gICAgICAgIFRoaXMgZnVuY3Rpb24gdXBkYXRlcyBvciBhZGRzIGEgcGllY2Ugb2YgbWV0YWRhdGEgdG8gZWFjaCB0YWcgY2FsbGVkIFwiYmJjbFwiIHdoaWNoIFxyXG4gICAgICAgIGluZGljYXRlcyBob3cgZGVlcGx5IG5lc3RlZCBhIHBhcnRpY3VsYXIgdGFnIHdhcyBpbiB0aGUgYmJjb2RlLiBUaGlzIHByb3BlcnR5IGlzIHJlbW92ZWRcclxuICAgICAgICBmcm9tIHRoZSBIVE1MIGNvZGUgdGFncyBhdCB0aGUgZW5kIG9mIHRoZSBwcm9jZXNzaW5nLlxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZVRhZ0RlcHRocyh0YWdDb250ZW50cykge1xyXG4gICAgICAgIHRhZ0NvbnRlbnRzID0gdGFnQ29udGVudHMucmVwbGFjZSgvXFw8KFteXFw+XVteXFw+XSo/KVxcPi9naSwgZnVuY3Rpb24obWF0Y2hTdHIsIHN1Yk1hdGNoU3RyKSB7XHJcbiAgICAgICAgICAgIHZhciBiYkNvZGVMZXZlbCA9IHN1Yk1hdGNoU3RyLm1hdGNoKC9eYmJjbD0oWzAtOV0rKSAvKTtcclxuICAgICAgICAgICAgaWYgKGJiQ29kZUxldmVsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCI8YmJjbD0wIFwiICsgc3ViTWF0Y2hTdHIgKyBcIj5cIjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIjxcIiArIHN1Yk1hdGNoU3RyLnJlcGxhY2UoL14oYmJjbD0pKFswLTldKykvLCBmdW5jdGlvbihtYXRjaFN0ciwgbTEsIG0yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0xICsgKHBhcnNlSW50KG0yLCAxMCkgKyAxKTtcclxuICAgICAgICAgICAgICAgIH0pICsgXCI+XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGFnQ29udGVudHM7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qXHJcbiAgICAgICAgVGhpcyBmdW5jdGlvbiByZW1vdmVzIHRoZSBtZXRhZGF0YSBhZGRlZCBieSB0aGUgdXBkYXRlVGFnRGVwdGhzIGZ1bmN0aW9uXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gdW5wcm9jZXNzKHRhZ0NvbnRlbnQpIHtcclxuICAgICAgICByZXR1cm4gdGFnQ29udGVudC5yZXBsYWNlKC88YmJjbD1bMC05XSsgXFwvXFwqPi9naSxcIlwiKS5yZXBsYWNlKC88YmJjbD1bMC05XSsgL2dpLFwiJiM5MTtcIikucmVwbGFjZSgvPi9naSxcIiYjOTM7XCIpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2YXIgcmVwbGFjZUZ1bmN0ID0gZnVuY3Rpb24obWF0Y2hTdHIsIGJiY29kZUxldmVsLCB0YWdOYW1lLCB0YWdQYXJhbXMsIHRhZ0NvbnRlbnRzKSB7XHJcbiAgICBcclxuICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgICAgICB2YXIgcHJvY2Vzc2VkQ29udGVudCA9IHRhZ3NbdGFnTmFtZV0ubm9QYXJzZSA/IHVucHJvY2Vzcyh0YWdDb250ZW50cykgOiB0YWdDb250ZW50cy5yZXBsYWNlKGJiUmVnRXhwLCByZXBsYWNlRnVuY3QpLFxyXG4gICAgICAgICAgICBvcGVuVGFnID0gdGFnc1t0YWdOYW1lXS5vcGVuVGFnKHRhZ1BhcmFtcyxwcm9jZXNzZWRDb250ZW50KSxcclxuICAgICAgICAgICAgY2xvc2VUYWcgPSB0YWdzW3RhZ05hbWVdLmNsb3NlVGFnKHRhZ1BhcmFtcyxwcm9jZXNzZWRDb250ZW50KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgaWYgKCB0YWdzW3RhZ05hbWVdLmRpc3BsYXlDb250ZW50ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBwcm9jZXNzZWRDb250ZW50ID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG9wZW5UYWcgKyBwcm9jZXNzZWRDb250ZW50ICsgY2xvc2VUYWc7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlKGNvbmZpZykge1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSBjb25maWcudGV4dDtcclxuICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShiYlJlZ0V4cCwgcmVwbGFjZUZ1bmN0KTtcclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKlxyXG4gICAgICAgIFRoZSBzdGFyIHRhZyBbKl0gaXMgc3BlY2lhbCBpbiB0aGF0IGl0IGRvZXMgbm90IHVzZSBhIGNsb3NpbmcgdGFnLiBTaW5jZSB0aGlzIHBhcnNlciByZXF1aXJlcyB0aGF0IHRhZ3MgdG8gaGF2ZSBhIGNsb3NpbmdcclxuICAgICAgICB0YWcsIHdlIG11c3QgcHJlLXByb2Nlc3MgdGhlIGlucHV0IGFuZCBhZGQgaW4gY2xvc2luZyB0YWdzIFsvKl0gZm9yIHRoZSBzdGFyIHRhZy5cclxuICAgICAgICBXZSBoYXZlIGEgbGl0dGxlIGxldmFyaWRnZSBpbiB0aGF0IHdlIGtub3cgdGhlIHRleHQgd2UncmUgcHJvY2Vzc2luZyB3b250IGNvbnRhaW4gdGhlIDw+IGNoYXJhY3RlcnMgKHRoZXkgaGF2ZSBiZWVuXHJcbiAgICAgICAgY2hhbmdlZCBpbnRvIHRoZWlyIEhUTUwgZW50aXR5IGZvcm0gdG8gcHJldmVudCBYU1MgYW5kIGNvZGUgaW5qZWN0aW9uKSwgc28gd2UgY2FuIHVzZSB0aG9zZSBjaGFyYWN0ZXJzIGFzIG1hcmtlcnMgdG9cclxuICAgICAgICBoZWxwIHVzIGRlZmluZSBib3VuZGFyaWVzIGFuZCBmaWd1cmUgb3V0IHdoZXJlIHRvIHBsYWNlIHRoZSBbLypdIHRhZ3MuXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gZml4U3RhclRhZyh0ZXh0KSB7XHJcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxbKD8hXFwqWyA9XFxdXXxsaXN0KFsgPV1bXlxcXV0qKT9cXF18XFwvbGlzdFtcXF1dKS9pZywgXCI8XCIpO1xyXG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcWyg/PWxpc3QoWyA9XVteXFxdXSopP1xcXXxcXC9saXN0W1xcXV0pL2lnLCBcIj5cIik7XHJcblxyXG4gICAgICAgIHdoaWxlICh0ZXh0ICE9PSAodGV4dCA9IHRleHQucmVwbGFjZSgvPmxpc3QoWyA9XVteXFxdXSopP1xcXShbXj5dKj8pKD5cXC9saXN0XSkvZ2ksIGZ1bmN0aW9uKG1hdGNoU3RyLGNvbnRlbnRzLGVuZFRhZykge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGlubmVyTGlzdFR4dCA9IG1hdGNoU3RyO1xyXG4gICAgICAgICAgICB3aGlsZSAoaW5uZXJMaXN0VHh0ICE9PSAoaW5uZXJMaXN0VHh0ID0gaW5uZXJMaXN0VHh0LnJlcGxhY2UoL1xcW1xcKlxcXShbXlxcW10qPykoXFxbXFwqXFxdfD5cXC9saXN0XSkvaSwgZnVuY3Rpb24obWF0Y2hTdHIsY29udGVudHMsZW5kVGFnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5kVGFnID09PSBcIj4vbGlzdF1cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZFRhZyA9IFwiPC8qXTwvbGlzdF1cIjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kVGFnID0gXCI8LypdWypdXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gXCI8Kl1cIiArIGNvbnRlbnRzICsgZW5kVGFnO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcclxuICAgICAgICAgICAgfSkpKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlubmVyTGlzdFR4dCA9IGlubmVyTGlzdFR4dC5yZXBsYWNlKC8+L2csIFwiPFwiKTsgICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIGlubmVyTGlzdFR4dDtcclxuICAgICAgICB9KSkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIGFkZCBbJ3MgZm9yIG91ciB0YWdzIGJhY2sgaW5cclxuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC88L2csIFwiW1wiKTtcclxuICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGFkZEJiY29kZUxldmVscyh0ZXh0KSB7XHJcbiAgICAgICAgd2hpbGUgKCB0ZXh0ICE9PSAodGV4dCA9IHRleHQucmVwbGFjZShwYmJSZWdFeHAsIGZ1bmN0aW9uKG1hdGNoU3RyLCB0YWdOYW1lLCB0YWdQYXJhbXMsIHRhZ0NvbnRlbnRzKSB7XHJcbiAgICAgICAgICAgIG1hdGNoU3RyID0gbWF0Y2hTdHIucmVwbGFjZSgvXFxbL2csIFwiPFwiKTtcclxuICAgICAgICAgICAgbWF0Y2hTdHIgPSBtYXRjaFN0ci5yZXBsYWNlKC9cXF0vZywgXCI+XCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlVGFnRGVwdGhzKG1hdGNoU3RyKTtcclxuICAgICAgICB9KSkgKTtcclxuICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIHB1YmxpYyBmdW5jdGlvbnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBcclxuICAgIG1lLnByb2Nlc3MgPSBmdW5jdGlvbihjb25maWcpIHtcclxuICAgIFxyXG4gICAgICAgIHZhciByZXQgPSB7aHRtbDogXCJcIiwgZXJyb3I6IGZhbHNlfSxcclxuICAgICAgICAgICAgZXJyUXVldWUgPSBbXTtcclxuXHJcbiAgICAgICAgY29uZmlnLnRleHQgPSBjb25maWcudGV4dC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKTsgLy8gZXNjYXBlIEhUTUwgdGFnIGJyYWNrZXRzXHJcbiAgICAgICAgY29uZmlnLnRleHQgPSBjb25maWcudGV4dC5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKTsgLy8gZXNjYXBlIEhUTUwgdGFnIGJyYWNrZXRzXHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uZmlnLnRleHQgPSBjb25maWcudGV4dC5yZXBsYWNlKG9wZW5UYWdzLCBmdW5jdGlvbihtYXRjaFN0ciwgb3BlbkIsIGNvbnRlbnRzLCBjbG9zZUIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiPFwiICsgY29udGVudHMgKyBcIj5cIjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25maWcudGV4dCA9IGNvbmZpZy50ZXh0LnJlcGxhY2UoY2xvc2VUYWdzLCBmdW5jdGlvbihtYXRjaFN0ciwgb3BlbkIsIGNvbnRlbnRzLCBjbG9zZUIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiPFwiICsgY29udGVudHMgKyBcIj5cIjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBjb25maWcudGV4dCA9IGNvbmZpZy50ZXh0LnJlcGxhY2UoL1xcWy9nLCBcIiYjOTE7XCIpOyAvLyBlc2NhcGUgWydzIHRoYXQgYXJlbid0IGFwYXJ0IG9mIHRhZ3NcclxuICAgICAgICBjb25maWcudGV4dCA9IGNvbmZpZy50ZXh0LnJlcGxhY2UoL1xcXS9nLCBcIiYjOTM7XCIpOyAvLyBlc2NhcGUgWydzIHRoYXQgYXJlbid0IGFwYXJ0IG9mIHRhZ3NcclxuICAgICAgICBjb25maWcudGV4dCA9IGNvbmZpZy50ZXh0LnJlcGxhY2UoLzwvZywgXCJbXCIpOyAvLyBlc2NhcGUgWydzIHRoYXQgYXJlbid0IGFwYXJ0IG9mIHRhZ3NcclxuICAgICAgICBjb25maWcudGV4dCA9IGNvbmZpZy50ZXh0LnJlcGxhY2UoLz4vZywgXCJdXCIpOyAvLyBlc2NhcGUgWydzIHRoYXQgYXJlbid0IGFwYXJ0IG9mIHRhZ3NcclxuXHJcbiAgICAgICAgLy8gcHJvY2VzcyB0YWdzIHRoYXQgZG9uJ3QgaGF2ZSB0aGVpciBjb250ZW50IHBhcnNlZFxyXG4gICAgICAgIHdoaWxlICggY29uZmlnLnRleHQgIT09IChjb25maWcudGV4dCA9IGNvbmZpZy50ZXh0LnJlcGxhY2UocGJiUmVnRXhwMiwgZnVuY3Rpb24obWF0Y2hTdHIsIHRhZ05hbWUsIHRhZ1BhcmFtcywgdGFnQ29udGVudHMpIHtcclxuICAgICAgICAgICAgdGFnQ29udGVudHMgPSB0YWdDb250ZW50cy5yZXBsYWNlKC9cXFsvZywgXCImIzkxO1wiKTtcclxuICAgICAgICAgICAgdGFnQ29udGVudHMgPSB0YWdDb250ZW50cy5yZXBsYWNlKC9cXF0vZywgXCImIzkzO1wiKTtcclxuICAgICAgICAgICAgdGFnUGFyYW1zID0gdGFnUGFyYW1zIHx8IFwiXCI7XHJcbiAgICAgICAgICAgIHRhZ0NvbnRlbnRzID0gdGFnQ29udGVudHMgfHwgXCJcIjtcclxuICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgdGFnTmFtZSArIHRhZ1BhcmFtcyArIFwiXVwiICsgdGFnQ29udGVudHMgKyBcIlsvXCIgKyB0YWdOYW1lICsgXCJdXCI7XHJcbiAgICAgICAgfSkpICk7XHJcblxyXG4gICAgICAgIGNvbmZpZy50ZXh0ID0gZml4U3RhclRhZyhjb25maWcudGV4dCk7IC8vIGFkZCBpbiBjbG9zaW5nIHRhZ3MgZm9yIHRoZSBbKl0gdGFnXHJcbiAgICAgICAgY29uZmlnLnRleHQgPSBhZGRCYmNvZGVMZXZlbHMoY29uZmlnLnRleHQpOyAvLyBhZGQgaW4gbGV2ZWwgbWV0YWRhdGFcclxuXHJcbiAgICAgICAgZXJyUXVldWUgPSBjaGVja1BhcmVudENoaWxkUmVzdHJpY3Rpb25zKFwiYmJjb2RlXCIsIGNvbmZpZy50ZXh0LCAtMSwgXCJcIiwgXCJcIiwgY29uZmlnLnRleHQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldC5odG1sID0gcGFyc2UoY29uZmlnKTtcclxuXHJcbiAgICAgICAgaWYgKCByZXQuaHRtbC5pbmRleE9mKFwiW1wiKSAhPT0gLTEgfHwgcmV0Lmh0bWwuaW5kZXhPZihcIl1cIikgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGVyclF1ZXVlLnB1c2goXCJTb21lIHRhZ3MgYXBwZWFyIHRvIGJlIG1pc2FsaWduZWQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIGlmIChjb25maWcucmVtb3ZlTWlzYWxpZ25lZFRhZ3MpIHtcclxuICAgICAgICAgICAgcmV0Lmh0bWwgPSByZXQuaHRtbC5yZXBsYWNlKC9cXFsuKj9cXF0vZyxcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbmZpZy5hZGRJbkxpbmVCcmVha3MpIHtcclxuICAgICAgICAgICAgcmV0Lmh0bWwgPSByZXQuaHRtbC5yZXBsYWNlKC9cXHJcXG4vZywgXCJcXG5cIik7XHJcbiAgICAgICAgICAgIHJldC5odG1sID0gcmV0Lmh0bWwucmVwbGFjZSgvKFxccnxcXG4pL2csIFwiJDE8YnIvPlwiKTtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICByZXQuaHRtbCA9IHJldC5odG1sLnJlcGxhY2UoXCImIzkxO1wiLCBcIltcIik7IC8vIHB1dCBbJ3MgYmFjayBpblxyXG4gICAgICAgIHJldC5odG1sID0gcmV0Lmh0bWwucmVwbGFjZShcIiYjOTM7XCIsIFwiXVwiKTsgLy8gcHV0IFsncyBiYWNrIGluXHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0LmVycm9yID0gKGVyclF1ZXVlLmxlbmd0aCA9PT0gMCkgPyBmYWxzZSA6IHRydWU7XHJcbiAgICAgICAgcmV0LmVycm9yUXVldWUgPSBlcnJRdWV1ZTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gbWU7XHJcbn0pKCk7IiwiLypcbiAgICBib3Jvbjogc29tZSB1dGlsaXRpZXMgZm9yIGltbXV0YWJpbGl0eVxuKi9cblxuXG5Cb3JvbiA9IHt9XG5cbkJvcm9uLnBlcnNpc3RlbnRfbWVyZ2UgPSBmdW5jdGlvbihwcm9wcywgZGF0YSkge1xuICAgIC8vLyBtZXJnZXMgYSAnZmxhdHRlbmVkJyBkYXRhIGFycmF5IGludG8gcHJvcHMgaW4gYSBwZXJzaXN0ZW50IGZhc2hpb25cbiAgICAvLy8gdGhlIG5ldyBvYmplY3QgcmV1c2VzIG9sZCBkYXRhIHdoZXJlIHBvc3NpYmxlLCBzbyByZXF1aXJlcyB+bG9nIE4gYWRkaXRpb25hbCBzcGFjZVxuICAgIFxuICAgIC8vLyBnaXZlbiBwcm9wcyB7ZnVuOiB7eWF5OjEyMywgb2s6MTIzfSwgY2F0Ontkb2c6MTIzfX0gICAgXG4gICAgLy8vICAgYW5kICBkYXRhIHsnZnVuLnlheSc6MCwgJ2NhdC5hbnQuYmVhcic6MH19ICAgICAgICAgIFxuICAgIC8vLyAgICAgcmV0dXJucyB7ZnVuOiB7eWF5OjAsIG9rOjEyM30sIGNhdDp7YW50OntiZWFyOjB9fX1cbiAgICBcbiAgICBkYXRhID0gZGF0YSB8fCBbXVxuICAgIFxuICAgIGlmKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAvLyBUSElOSzogd2hhdCBkbyB3ZSBkbyB3aXRoIGFycmF5cz9cbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShkYXRhKSAhPT0gQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICAgICAgICAgIC8vIFRISU5LOiBob3cgdG8gZGVhbCB3aXRoIGFycmF5IC8gb2JqZWN0IG1pc21hdGNoP1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFRISU5LOiB3aGF0IGFib3V0IHdoZW4gZGF0YSBpcyB7Y2F0OnsnYW50LmJlYXInOjB9fSA/XG4gICAgXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGRhdGEpLnJlZHVjZShmdW5jdGlvbihwcm9wcywga2V5KSB7ICAgICAgICAgICAgICAvLyBPUFQ6IGNvbWJpbmUgdGhlc2UgaW5zdGVhZCBvZiBkb2luZyB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgcmV0dXJuIEJvcm9uLnNldF9kZWVwX3ZhbHVlKHByb3BzLCBrZXksIGRhdGFba2V5XSlcbiAgICB9LCBwcm9wcylcbn1cblxuQm9yb24uc2V0X2RlZXBfdmFsdWUgPSBmdW5jdGlvbihwcm9wcywgcGF0aCwgdmFsdWUpIHtcbiAgICAvLy8gc2V0IGEgdmFsdWUgZnJvbSBhIGZsYXR0ZW5lZCBwYXRoXG4gICAgXG4gICAgLy8vIGdpdmVuIHByb3BzIHtmdW46IHt5YXk6MTIzLCBvazoxMjN9LCBjYXQ6e2RvZzoxMjN9fVxuICAgIC8vLyAgIGFuZCAgcGF0aCAnZnVuLm9rJyBcbiAgICAvLy8gICBhbmQgdmFsdWUgNDU2XG4gICAgLy8vICAgICByZXR1cm5zIHtmdW46IHt5YXk6MTIzLCBvazo0NTZ9LCBjYXQ6e2RvZzoxMjN9fVxuICAgIFxuICAgIC8vIHZhciBzZWdzID0gcGF0aC5zcGxpdCgnLicpXG4gICAgLy8gVEhJTks6IHRoaXMgaXMgdmFndWVseSBhd2Z1bCwgYnV0IHdpdGhvdXQgbG9va2JlaGluZCBpdCdzIGhhcmQgdG8gc2F5IFwib25seSBzcGxpdCBvbiBkb3RzIHRoYXQgYXJlbid0IHNsYXNoZWRcIlxuICAgIC8vIHZhciBzZWdzID0gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpXG4gICAgLy8gICAgICAgICAgICAgICAgLnNwbGl0KC9cXC4oPyFcXFxcKS8pLnJldmVyc2UoKVxuICAgIC8vICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oY2h1bmspIHtyZXR1cm4gY2h1bmsuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKX0pXG4gICAgLy8gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihjaHVuaykge3JldHVybiBjaHVuay5yZXBsYWNlKC9bXFxcXF0kLywgJycpfSlcbiAgICBcbiAgICAvLyBUSElOSzogdGhpcyBpcyB2YWd1ZWx5IGF3ZnVsbGVyLCBidXQgd29ya3MgYW5kIGlzIGZhaXJseSBmYXN0IGFuZCByZWFkYWJsZS4gXG4gICAgdmFyIG1hZ2ljID0gXCJfX19NQUdJQ19fX1wiXG4gICAgdmFyIG1hZ2ljX3JlZ2V4ID0gbmV3IFJlZ0V4cChtYWdpYywgJ2cnKTtcbiAgICB2YXIgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFxcXFxcLi9nLCBtYWdpYylcbiAgICB2YXIgc2VncyA9IHBhdGguc3BsaXQoJy4nKS5tYXAoZnVuY3Rpb24oY2h1bmspIHtyZXR1cm4gY2h1bmsucmVwbGFjZShtYWdpY19yZWdleCwgJy4nKX0pXG4gICAgXG4gICAgdmFyIGxhc3QgPSBzZWdzLnBvcCgpXG4gICAgdmFyIG5leHRcbiAgICB2YXIgZmluYWwgPSBuZXh0ID0gQm9yb24uc2hhbGxvd19jb3B5KHByb3BzKVxuXG4gICAgc2Vncy5mb3JFYWNoKGZ1bmN0aW9uKHNlZykge1xuICAgICAgICBuZXh0W3NlZ10gPSBCb3Jvbi5zaGFsbG93X2NvcHkobmV4dFtzZWddKVxuICAgICAgICBuZXh0ID0gbmV4dFtzZWddXG4gICAgfSlcblxuICAgIG5leHRbbGFzdF0gPSB2YWx1ZVxuICAgIHJldHVybiBmaW5hbFxufVxuXG5Cb3Jvbi5zaGFsbG93X2NvcHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZihBcnJheS5pc0FycmF5KG9iaikpIHJldHVybiBvYmouc2xpY2UoKVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmogfHwge30pLnJlZHVjZShmdW5jdGlvbihhY2MsIGtleSkge2FjY1trZXldID0gb2JqW2tleV07IHJldHVybiBhY2N9LCB7fSlcbn1cblxuQm9yb24uc2hhbGxvd19kaWZmID0gZnVuY3Rpb24ob2xkT2JqLCBuZXdPYmopIHsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0cyBjb21lIGZyb20gbmV3T2JqXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9sZE9iaikucmVkdWNlKGZ1bmN0aW9uKGFjYywga2V5KSB7XG4gICAgICAgIGlmKEpTT04uc3RyaW5naWZ5KG9sZE9ialtrZXldKSAhPSBKU09OLnN0cmluZ2lmeShuZXdPYmpba2V5XSkpXG4gICAgICAgICAgICBhY2Nba2V5XSA9IG5ld09ialtrZXldICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHBvaW50ZXIgY29waWVzIGRlZXAgZGF0YVxuICAgICAgICByZXR1cm4gYWNjXG4gICAgfSwgb2xkT2JqLmNvbnN0cnVjdG9yKCkpXG59XG5cbkJvcm9uLmRlZXBfZGlmZiA9IGZ1bmN0aW9uKG9sZE9iaiwgbmV3T2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdHMgY29tZSBmcm9tIG5ld09ialxuICAgIHJldHVybiBPYmplY3Qua2V5cyhuZXdPYmopLnJlZHVjZShmdW5jdGlvbihhY2MsIGtleSkge1xuICAgICAgICB2YXIgb2xkdHlwZSA9IHR5cGVvZiBvbGRPYmpba2V5XVxuICAgICAgICB2YXIgbmV3dHlwZSA9IHR5cGVvZiBuZXdPYmpba2V5XVxuICAgICAgICBcbiAgICAgICAgaWYob2xkdHlwZSAhPSBuZXd0eXBlKSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IG5ld09ialtrZXldICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHBvaW50ZXIgY29waWVzIGRlZXAgZGF0YVxuICAgICAgICAgICAgcmV0dXJuIGFjY1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihvbGR0eXBlID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IEJvcm9uLmRlZXBfZGlmZihvbGRPYmpba2V5XSwgbmV3T2JqW2tleV0pXG4gICAgICAgICAgICBpZihPYmplY3Qua2V5cyhkaWZmKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSBkaWZmXG4gICAgICAgICAgICByZXR1cm4gYWNjXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKG9sZE9ialtrZXldICE9PSBuZXdPYmpba2V5XSlcbiAgICAgICAgICAgIGFjY1trZXldID0gbmV3T2JqW2tleV1cbiAgICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIG5ld09iai5jb25zdHJ1Y3RvcigpKVxufVxuXG5Cb3Jvbi5mbGF0dGVuID0gZnVuY3Rpb24ob2JqLCBwcmVmaXgpIHtcbiAgICAvLy8gY29udmVydCB7ZnVuOiB7eWF5OiAxMjN9fSBpbnRvIHsnZnVuLnlheSc6IDEyM31cbiAgICBcbiAgICBpZighQm9yb24ucHJvcGVyX29iamVjdChvYmopKSByZXR1cm4ge31cbiAgICBcbiAgICB2YXIgbmV3b2JqID0ge31cbiAgICBwcmVmaXggPSBwcmVmaXggPyBwcmVmaXggKyAnLicgOiAnJ1xuICAgIFxuICAgIGZvcih2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZighQm9yb24ucHJvcGVyX29iamVjdChvYmpba2V5XSkpIHtcbiAgICAgICAgICAgIG5ld29ialtwcmVmaXgra2V5XSA9IG9ialtrZXldXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdvYmogPSBCb3Jvbi5leHRlbmQobmV3b2JqLCBCb3Jvbi5mbGF0dGVuKG9ialtrZXldLCBwcmVmaXgra2V5KSkgLy8gT1BUOiBsb3RzYSBHQyBoZXJlXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG5ld29ialxufVxuXG5Cb3Jvbi51bmZsYXR0ZW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICAvLy8gY29udmVydCB7J2Z1bi55YXknOiAxMjN9IGludG8ge2Z1bjoge3lheTogMTIzfX1cbiAgICBcbiAgICByZXR1cm4gQm9yb24ucGVyc2lzdGVudF9tZXJnZSh7fSwgb2JqKSAvLyBPUFQ6IEdDXG4gICAgLy8gcmV0dXJuIE9iamVjdC5rZXlzKG9ianx8e30pLnJlZHVjZShmdW5jdGlvbihhY2MsIGtleSkge3JldHVybiBCb3Jvbi5zZXRfZGVlcF92YWx1ZShhY2MsIGtleSwgb2JqW2tleV0pfSwge30pIC8vIE9QVDogR0Ncbn1cblxuQm9yb24ucHJvcGVyX29iamVjdCA9IGZ1bmN0aW9uKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iaiA9PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvYmopICYmICEhb2JqfSBcblxuQm9yb24uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgLy8vIGdpdmVuICh7ZnVuOjEyMywgeWF5OjEyM30sIHt5YXk6NDU2LCBvazo3ODl9KSBhcyBhcmdzLCByZXR1cm5zIGEgbmV3IG9iamVjdCB7ZnVuOjEyMywgeWF5OjQ1Niwgb2s6Nzg5fVxuICAgIFxuICAgIHZhciBuZXdvYmogPSB7fVxuICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZm9yRWFjaChmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgZm9yKHZhciBwcm9wIGluIGFyZykge1xuICAgICAgICAgICAgbmV3b2JqW3Byb3BdID0gYXJnW3Byb3BdIH0gfSlcbiAgICByZXR1cm4gbmV3b2JqXG59XG5cblxuQm9yb24ubWVtb2l6ZSA9IGZ1bmN0aW9uKGYpIHtcbiAgICB2YXIgdGFibGUgPSB7fVxuICAgIGYgPSB0eXBlb2YgZiA9PSAnZnVuY3Rpb24nID8gZiA6IGZ1bmN0aW9uKCkge31cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgICB2YXIga2V5ID0gYXJncy50b1N0cmluZygpXG4gICAgICAgIHJldHVybiB0YWJsZVtrZXldID8gdGFibGVba2V5XSA6ICh0YWJsZVtrZXldID0gZi5hcHBseShudWxsLCBhcmdzKSlcbiAgICB9IFxufVxuIiwiLypcbiAgICAgX19fXyAgX19fX18gX19fX18gX19fX18gX19fX18gX19fX18gXG4gICAgfCAgICBcXHwgIF8gIHwgICBfX3wgICAgIHwgX18gIHwgIF8gIHxcbiAgICB8ICB8ICB8ICAgICB8ICB8ICB8ICB8ICB8IF9fIC18ICAgICB8XG4gICAgfF9fX18vfF9ffF9ffF9fX19ffF9fX19ffF9fX19ffF9ffF9ffFxuICAgIFxuICAgIGRhZ29iYTogYSB0aW55IGluLW1lbW9yeSBncmFwaCBkYXRhYmFzZVxuXG4gICAgZXg6IFxuICAgIFYgPSBbIHtuYW1lOiAnYWxpY2UnfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxpY2UgZ2V0cyBhdXRvLV9pZCAocHJvbGx5IDEpXG4gICAgICAgICwge19pZDogMTAsIG5hbWU6ICdib2InLCBob2JiaWVzOiBbJ2FzZGYnLCB7eDozfV19XSBcbiAgICBFID0gWyB7X291dDogMSwgX2luOiAxMCwgX2xhYmVsOiAna25vd3MnfSBdXG4gICAgZyA9IERhZ29iYS5ncmFwaChWLCBFKVxuICAgIFxuICAgIGcuYWRkVmVydGV4KHtuYW1lOiAnY2hhcmxpZScsIF9pZDogJ2NoYXJsaWUnfSkgICAgICAgICAgICAgICAgLy8gc3RyaW5nIGlkcyBhcmUgZmluZVxuICAgIGcuYWRkVmVydGV4KHtuYW1lOiAnZGVsdGEnLCBfaWQ6ICczMCd9KSAgICAgICAgICAgICAgICAgICAgICAgLy8gYWN0dWFsbHkgdGhleSdyZSBhbGwgc3RyaW5nc1xuXG4gICAgZy5hZGRFZGdlKHtfb3V0OiAxMCwgX2luOiAzMCwgX2xhYmVsOiAncGFyZW50J30pXG4gICAgZy5hZGRFZGdlKHtfb3V0OiAxMCwgX2luOiAnY2hhcmxpZScsIF9sYWJlbDogJ2tub3dzJ30pXG5cbiAgICBnLnYoMSkub3V0KCdrbm93cycpLm91dCgpLnJ1bigpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgW2NoYXJsaWUsIGRlbHRhXVxuICAgIFxuICAgIHEgPSBnLnYoMSkub3V0KCdrbm93cycpLm91dCgpLnRha2UoMSlcbiAgICBxLnJ1bigpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgW2NoYXJsaWVdXG4gICAgcS5ydW4oKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFtkZWx0YV0gICAgKGJ1dCBkb24ndCByZWx5IG9uIHJlc3VsdCBvcmRlciEpXG4gICAgcS5ydW4oKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFtdXG4qL1xuXG5cbkRhZ29iYSA9IHt9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuYW1lc3BhY2VcblxuRGFnb2JhLkcgPSB7fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByb3RvdHlwZVxuXG5EYWdvYmEuZ3JhcGggPSBmdW5jdGlvbihWLCBFKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZmFjdG9yeVxuICB2YXIgZ3JhcGggPSBPYmplY3QuY3JlYXRlKCBEYWdvYmEuRyApXG4gIGdyYXBoLnZlcnRpY2VzID0gW10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcmVzaCBjb3BpZXMgc28gdGhleSdyZSBub3Qgc2hhcmVkXG4gIGdyYXBoLmVkZ2VzID0gW11cbiAgZ3JhcGgudmVydGV4SW5kZXggPSB7fVxuICBpZihWICYmIEFycmF5LmlzQXJyYXkoVikpIGdyYXBoLmFkZFZlcnRpY2VzKFYpICAgICAgICAgICAgICAgICAgLy8gYXJyYXlzIG9ubHksIGJlY2F1c2UgeW91IHdvdWxkbid0XG4gIGlmKEUgJiYgQXJyYXkuaXNBcnJheShFKSkgZ3JhcGguYWRkRWRnZXMoRSkgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHRoaXMgd2l0aCBzaW5ndWxhciBWIGFuZCBFXG4gIHJldHVybiBncmFwaFxufVxuXG5EYWdvYmEuRy52ID0gZnVuY3Rpb24oKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIHF1ZXJ5IGluaXRpYWxpemVyOiBnLnYoKSAtPiBxdWVyeVxuICB2YXIgcXVlcnkgPSBEYWdvYmEucXVlcnkodGhpcylcbiAgcXVlcnkuYWRkKFsndmVydGV4J10uY29uY2F0KCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykgKSlcbiAgcmV0dXJuIHF1ZXJ5XG59XG5cbkRhZ29iYS5HLmFkZFZlcnRleCA9IGZ1bmN0aW9uKHZlcnRleCkge1xuICBpZighdmVydGV4Ll9pZCkgXG4gICAgdmVydGV4Ll9pZCA9IHRoaXMudmVydGljZXMubGVuZ3RoKzFcbiAgLy8gVE9ETzogZW5zdXJlIHVuaXF1ZSBfaWRcbiAgdGhpcy52ZXJ0aWNlcy5wdXNoKHZlcnRleCkgLy8gVEhJTks6IHRoZSB1c2VyIG1heSByZXRhaW4gYSBwb2ludGVyIHRvIHZlcnRleCwgd2hpY2ggdGhleSBtaWdodCBtdXRhdGUgbGF0ZXIgPi48XG4gIC8vIGNhbiB0YWtlIGF3YXkgdXNlcidzIGFiaWxpdHkgdG8gc2V0IF9pZCBhbmQgbG9zZSB0aGUgaW5kZXggY2FjaGUgaGFzaCwgYmVjYXVzZSBidWlsZGluZyBpdCBjYXVzZXMgYmlnIHJlYmFsYW5jaW5nIHNsb3dkb3ducyBhbmQgcnVucyB0aGUgR0MgaGFyZC4gKG9yIGRvZXMgaXQ/KSBbdGhpcyB3YXMgd2l0aCBhIG1pbGxpb24gaXRlbXMsIGluZGV4ZWQgYnkgY29uc2VjdXRpdmUgaW50cy4gZ2VuZXJhbGx5IHdlIG5lZWQgc2V0dGFibGUgX2lkIGJlY2F1c2Ugd2UgbmVlZCB0byBncmFiIHZlcnRpY2VzIHF1aWNrbHkgYnkgZXh0ZXJuYWwga2V5XVxuICB0aGlzLnZlcnRleEluZGV4W3ZlcnRleC5faWRdID0gdmVydGV4XG4gIHZlcnRleC5fb3V0ID0gW107IHZlcnRleC5faW4gPSBbXVxufVxuXG5EYWdvYmEuRy5hZGRFZGdlID0gZnVuY3Rpb24oZWRnZSkge1xuICBpZighZWRnZS5fbGFiZWwpIHJldHVybiBmYWxzZVxuICBlZGdlLl9pbiAgPSB0aGlzLmZpbmRWZXJ0ZXhCeUlkKGVkZ2UuX2luKVxuICBlZGdlLl9vdXQgPSB0aGlzLmZpbmRWZXJ0ZXhCeUlkKGVkZ2UuX291dClcbiAgaWYoIShlZGdlLl9pbiAmJiBlZGdlLl9vdXQpKSByZXR1cm4gZmFsc2VcbiAgZWRnZS5fb3V0Ll9vdXQucHVzaChlZGdlKVxuICBlZGdlLl9pbi5faW4ucHVzaChlZGdlKVxuICB0aGlzLmVkZ2VzLnB1c2goZWRnZSlcbn1cblxuRGFnb2JhLkcuYWRkVmVydGljZXMgPSBmdW5jdGlvbih2ZXJ0aWNlcykgeyB2ZXJ0aWNlcy5mb3JFYWNoKHRoaXMuYWRkVmVydGV4LmJpbmQodGhpcykpIH1cbkRhZ29iYS5HLmFkZEVkZ2VzICAgID0gZnVuY3Rpb24oZWRnZXMpICAgIHsgZWRnZXMgICAuZm9yRWFjaCh0aGlzLmFkZEVkZ2UgIC5iaW5kKHRoaXMpKSB9XG5cbkRhZ29iYS5HLmZpbmRWZXJ0ZXhCeUlkID0gZnVuY3Rpb24odmVydGV4X2lkKSB7XG4gIHJldHVybiB0aGlzLnZlcnRleEluZGV4W3ZlcnRleF9pZF0gfVxuXG5EYWdvYmEuRy5maW5kVmVydGljZXNCeUlkcyA9IGZ1bmN0aW9uKGlkcykge1xuICByZXR1cm4gaWRzLmxlbmd0aCA9PSAxID8gW10uY29uY2F0KCB0aGlzLmZpbmRWZXJ0ZXhCeUlkKGlkc1swXSkgfHwgW10gKVxuICAgICAgIDogaWRzLm1hcCggdGhpcy5maW5kVmVydGV4QnlJZC5iaW5kKHRoaXMpICkuZmlsdGVyKEJvb2xlYW4pIH1cblxuRGFnb2JhLkcuZmluZFZlcnRpY2VzID0gZnVuY3Rpb24oaWRzKSB7XG4gIHJldHVybiB0eXBlb2YgaWRzWzBdID09ICdvYmplY3QnID8gdGhpcy5zZWFyY2hWZXJ0aWNlcyhpZHNbMF0pXG4gICAgICAgOiBpZHMubGVuZ3RoID09IDAgPyB0aGlzLnZlcnRpY2VzLnNsaWNlKCkgICAgICAgICAgICAgICAgICAvLyBPUFQ6IGRvIHdlIG5lZWQgdGhlIHNsaWNlP1xuICAgICAgIDogdGhpcy5maW5kVmVydGljZXNCeUlkcyhpZHMpIH1cblxuRGFnb2JhLkcuc2VhcmNoVmVydGljZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRoaXMudmVydGljZXMuZmlsdGVyKFxuICAgIGZ1bmN0aW9uKHZlcnRleCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKFxuICAgICAgICBmdW5jdGlvbihhY2MsIGtleSkge1xuICAgICAgICAgIHJldHVybiBhY2MgJiYgb2JqW2tleV0gPT0gdmVydGV4W2tleV0gfSwgdHJ1ZSApIH0gKSB9XG5cbkRhZ29iYS5HLmZpbmRFZGdlQnlJZCA9IGZ1bmN0aW9uKGVkZ2VfaWQpIHtcbiAgcmV0dXJuIERhZ29iYS5maW5kKHRoaXMuZWRnZXMsIGZ1bmN0aW9uKGVkZ2UpIHtyZXR1cm4gZWRnZS5faWQgPT0gZWRnZV9pZH0gKSB9XG5cbkRhZ29iYS5HLmZpbmRPdXRFZGdlcyA9IGZ1bmN0aW9uKHZlcnRleCkgeyByZXR1cm4gdmVydGV4Ll9vdXQ7IH1cbkRhZ29iYS5HLmZpbmRJbkVkZ2VzICA9IGZ1bmN0aW9uKHZlcnRleCkgeyByZXR1cm4gdmVydGV4Ll9pbjsgIH1cblxuRGFnb2JhLkcudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2lkcywgZG9uJ3QgaGFuZCBjb2RlIEpTT05cbiAgcmV0dXJuICd7XCJWXCI6JyArIEpTT04uc3RyaW5naWZ5KHRoaXMudmVydGljZXMsIERhZ29iYS5jbGVhbnZlcnRleClcbiAgICAgICArICcsXCJFXCI6JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZWRnZXMsICAgIERhZ29iYS5jbGVhbmVkZ2UpIFxuICAgICAgICsgJ30nIH1cblxuRGFnb2JhLmZyb21TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5vdGhlciBncmFwaCBjb25zdHJ1Y3RvclxuICB2YXIgb2JqID0gSlNPTi5wYXJzZShzdHIpXG4gIHJldHVybiBEYWdvYmEuZ3JhcGgob2JqLlYsIG9iai5FKSBcbn1cblxuXG5cbkRhZ29iYS5RID0ge30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3RvdHlwZVxuXG5EYWdvYmEucXVlcnkgPSBmdW5jdGlvbihncmFwaCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWN0b3J5IChvbmx5IGNhbGxlZCBieSBhIGdyYXBoJ3MgcXVlcnkgaW5pdGlhbGl6ZXJzKVxuICB2YXIgcXVlcnkgPSBPYmplY3QuY3JlYXRlKCBEYWdvYmEuUSApXG4gIFxuICBxdWVyeS4gICBncmFwaCA9IGdyYXBoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGdyYXBoIGl0c2VsZlxuICBxdWVyeS4gICBzdGF0ZSA9IFtdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhdGUgZm9yIGVhY2ggc3RlcFxuICBxdWVyeS4gcHJvZ3JhbSA9IFtdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBzdGVwcyB0byB0YWtlICBcbiAgcXVlcnkuZ3JlbWxpbnMgPSBbXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdyZW1saW5zIGZvciBlYWNoIHN0ZXBcbiAgXG4gIHJldHVybiBxdWVyeVxufVxuXG5EYWdvYmEuUS5ydW4gPSBmdW5jdGlvbigpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbWFnaWMgbGl2ZXMgaGVyZVxuICBcbiAgdmFyIGdyYXBoID0gdGhpcy5ncmFwaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXNlIGFyZSBjbG9zZWQgb3ZlciBpbiB0aGUgaGVscGVyc1xuICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgZ2l2ZSB0aGVtIGEgc3BvdCBpbiB0aGUgZnJhbWVcbiAgdmFyIHByb2dyYW0gID0gdGhpcy5wcm9ncmFtXG4gIHZhciBncmVtbGlucyA9IHRoaXMuZ3JlbWxpbnNcblxuICB2YXIgbWF4ID0gcHJvZ3JhbS5sZW5ndGgtMSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd29yayBiYWNrd2FyZHNcbiAgdmFyIHBjID0gbWF4ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2dyYW0gY291bnRlclxuICB2YXIgZG9uZSA9IC0xICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVoaW5kd2hpY2ggdGhpbmdzIGhhdmUgZmluaXNoZWRcbiAgdmFyIHJlc3VsdHMgPSBbXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdHMgZm9yIHRoaXMgcnVuXG4gIHZhciBtYXliZV9ncmVtbGluID0gZmFsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIG15dGhpY2FsIGJlYXN0XG5cbiAgaWYoIXByb2dyYW0ubGVuZ3RoKSByZXR1cm4gW10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGJvdGhlclxuICBcbiAgXG4gIC8vIGRyaXZlciBsb29wXG4gIHdoaWxlKGRvbmUgPCBtYXgpIHtcbiAgICBtYXliZV9ncmVtbGluID0gdHJ5X3N0ZXAocGMsIG1heWJlX2dyZW1saW4pICAgICAgICAgICAgICAgICAgIC8vIG1heWJlX2dyZW1saW4gaXMgYSBncmVtbGluIG9yIChzdHJpbmcgfCBmYWxzZSlcbiAgICBcbiAgICBpZihtYXliZV9ncmVtbGluID09ICdwdWxsJykge1xuICAgICAgbWF5YmVfZ3JlbWxpbiA9IGZhbHNlXG4gICAgICBpZihwYy0xID4gZG9uZSkge1xuICAgICAgICBwYy0tXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lID0gcGNcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYobWF5YmVfZ3JlbWxpbiA9PSAnZG9uZScpIHtcbiAgICAgIGRvbmUgPSBwY1xuICAgICAgbWF5YmVfZ3JlbWxpbiA9IGZhbHNlXG4gICAgfVxuICAgIFxuICAgIHBjKytcbiAgICBcbiAgICBpZihwYyA+IG1heCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgZ3JlbWxpbiBpcyBwb3BwaW5nIG91dCBvZiB0aGUgcGlwZWxpbmUuIGNhdGNoIGl0IVxuICAgICAgaWYobWF5YmVfZ3JlbWxpbilcbiAgICAgICAgcmVzdWx0cy5wdXNoKG1heWJlX2dyZW1saW4pXG4gICAgICBtYXliZV9ncmVtbGluID0gZmFsc2VcbiAgICAgIHBjLS1cbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBkZWFsIHdpdGggZ3JlbWxpbiBwYXRocyAvIGhpc3RvcnkgYW5kIGdyZW1saW4gXCJjb2xsaXNpb25zXCJcbiAgXG4gIHJlc3VsdHMgPSByZXN1bHRzLm1hcChmdW5jdGlvbihncmVtbGluKSB7ICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHRoaXMgYSBxdWVyeSBjb21wb25lbnQgKG9yIHBvc3Rob29rKVxuICAgIHJldHVybiBncmVtbGluLnJlc3VsdCA/IGdyZW1saW4ucmVzdWx0IDogZ3JlbWxpbi52ZXJ0ZXggfSApXG5cbiAgcmVzdWx0cyA9IERhZ29iYS5maXJlaG9va3MoJ3Bvc3RxdWVyeScsIHRoaXMsIHJlc3VsdHMpWzBdIFxuICBcbiAgcmV0dXJuIHJlc3VsdHNcbiAgXG4gIC8vIE5BTUVEIEhFTFBFUlNcbiAgXG4gIGZ1bmN0aW9uIHRyeV9zdGVwKHBjLCBtYXliZV9ncmVtbGluKSB7XG4gICAgdmFyIHN0ZXAgPSBwcm9ncmFtW3BjXVxuICAgIHZhciBteV9zdGF0ZSA9IChzdGF0ZVtwY10gPSBzdGF0ZVtwY10gfHwge30pXG4gICAgaWYoIURhZ29iYS5RRnVuc1tzdGVwWzBdXSkgcmV0dXJuIERhZ29iYS5vbkVycm9yKCdVbnJlY29nbml6ZWQgZnVuY3Rpb24gY2FsbDogJyArIHN0ZXBbMF0pIHx8IG1heWJlX2dyZW1saW4gfHwgJ3B1bGwnXG4gICAgcmV0dXJuIERhZ29iYS5RRnVuc1tzdGVwWzBdXShncmFwaCwgc3RlcC5zbGljZSgxKSB8fCB7fSwgbWF5YmVfZ3JlbWxpbiwgbXlfc3RhdGUpXG4gIH1cbiAgICBcbiAgZnVuY3Rpb24gZ3JlbWxpbl9ib3hlcihzdGVwX2luZGV4KSB7IHJldHVybiBmdW5jdGlvbihncmVtbGluKSB7IHJldHVybiBbc3RlcF9pbmRleCwgZ3JlbWxpbl0gfSB9XG4gIFxuICBmdW5jdGlvbiBzdGVwcGVyKHN0ZXBfaW5kZXgsIGdyZW1saW4pIHtcbiAgICB2YXIgc3RlcCA9IHByb2dyYW1bc3RlcF9pbmRleF1cbiAgICBpZighRGFnb2JhLlFGdW5zW3N0ZXBbMF1dKSByZXR1cm4gRGFnb2JhLm9uRXJyb3IoJ1VucmVjb2duaXplZCBmdW5jdGlvbiBjYWxsOiAnICsgc3RlcFswXSkgfHwge31cbiAgICByZXR1cm4gRGFnb2JhLlFGdW5zW3N0ZXBbMF1dKGdyYXBoLCBzdGVwLnNsaWNlKDEpIHx8IHt9LCBncmVtbGluIHx8IHt9LCBzdGF0ZVtzdGVwX2luZGV4XSB8fCB7fSlcbiAgfVxuICBcbiAgZnVuY3Rpb24gZWF0X2dyZW1saW5zKGdyZW1saW5zLCBzdGVwX2luZGV4LCByZXN1bHQpIHtcbiAgICByZXR1cm4gZ3JlbWxpbnMuY29uY2F0KCAocmVzdWx0LnN0YXkgfHwgW10pLm1hcChncmVtbGluX2JveGVyKHN0ZXBfaW5kZXgpKSAgIClcbiAgICAgICAgICAgICAgICAgICAuY29uY2F0KCAocmVzdWx0LmdvICAgfHwgW10pLm1hcChncmVtbGluX2JveGVyKHN0ZXBfaW5kZXgrMSkpICkgfVxuICBcbiAgZnVuY3Rpb24gc2V0YmFuZ19ncmVtbGlucyhzdGVwX2luZGV4LCByZXN1bHQpIHtncmVtbGlucyA9IGVhdF9ncmVtbGlucyhncmVtbGlucywgc3RlcF9pbmRleCwgcmVzdWx0KX1cbn1cblxuXG5EYWdvYmEuUS5hZGQgPSBmdW5jdGlvbihsaXN0KSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhIG5ldyB0cmF2ZXJzYWwgdG8gdGhlIHF1ZXJ5XG4gIHRoaXMucHJvZ3JhbS5wdXNoKGxpc3QpXG4gIHJldHVybiB0aGlzXG59XG5cbkRhZ29iYS5hZGRRRnVuID0gZnVuY3Rpb24obmFtZSwgZnVuKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhIG5ldyB0cmF2ZXJzYWwgdHlwZVxuICBEYWdvYmEuUUZ1bnNbbmFtZV0gPSBmdW5cbiAgRGFnb2JhLlFbbmFtZV0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuYWRkKFtuYW1lXS5jb25jYXQoW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzKSkpIH0gXG4gIC8vIFRPRE86IGFjY2VwdCBzdHJpbmcgZnVuIGFuZCBhbGxvdyBleHRyYSBwYXJhbXMsIGZvciBidWlsZGluZyBxdWljayBhbGlhc2VzIGxpa2VcbiAgLy8gICAgICAgRGFnb2JhLmFkZFFGdW4oJ2NoaWxkcmVuJywgJ291dCcpIDwtLSBpZiBhbGwgb3V0IGVkZ2VzIGFyZSBraWRzXG4gIC8vICAgICAgIERhZ29iYS5hZGRRRnVuKCdudGhHR1AnLCAnaW5OJywgJ3BhcmVudCcpXG4gIC8vIHZhciBtZXRob2RzID0gWydvdXQnLCAnaW4nLCAndGFrZScsICdwcm9wZXJ0eScsICdvdXRBbGxOJywgJ2luQWxsTicsICd1bmlxdWUnLCAnZmlsdGVyJywgJ291dFYnLCAnb3V0RScsICdpblYnLCAnaW5FJywgJ2JvdGgnLCAnYm90aFYnLCAnYm90aEUnXVxufVxuXG5cbkRhZ29iYS5RRnVucyA9IHt9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCB0cmF2ZXJzYWwgdHlwZXNcblxuRGFnb2JhLmFkZFFGdW4oJ3ZlcnRleCcsIGZ1bmN0aW9uKGdyYXBoLCBhcmdzLCBncmVtbGluLCBzdGF0ZSkge1xuICBpZighc3RhdGUudmVydGljZXMpIHN0YXRlLnZlcnRpY2VzID0gZ3JhcGguZmluZFZlcnRpY2VzKGFyZ3MpXG4gIGlmKCFzdGF0ZS52ZXJ0aWNlcy5sZW5ndGgpIHJldHVybiAnZG9uZSdcbiAgdmFyIHZlcnRleCA9IHN0YXRlLnZlcnRpY2VzLnBvcCgpIFxuICByZXR1cm4gRGFnb2JhLm1ha2VfZ3JlbWxpbih2ZXJ0ZXgpXG59KVxuICBcbkRhZ29iYS5hZGRRRnVuKCdvdXQnLCBmdW5jdGlvbihncmFwaCwgYXJncywgZ3JlbWxpbiwgc3RhdGUpIHtcbiAgaWYoIWdyZW1saW4gJiYgKCFzdGF0ZS5lZGdlcyB8fCAhc3RhdGUuZWRnZXMubGVuZ3RoKSkgcmV0dXJuICdwdWxsJ1xuICBpZighc3RhdGUuZWRnZXMgfHwgIXN0YXRlLmVkZ2VzLmxlbmd0aCkgXG4gICAgc3RhdGUuZWRnZXMgPSBncmFwaC5maW5kT3V0RWRnZXMoZ3JlbWxpbi52ZXJ0ZXgpLmZpbHRlcihEYWdvYmEuZmlsdGVyVGhpbmdzKGFyZ3NbMF0pKVxuICBpZighc3RhdGUuZWRnZXMubGVuZ3RoKSByZXR1cm4gJ3B1bGwnXG4gIHZhciB2ZXJ0ZXggPSBzdGF0ZS5lZGdlcy5wb3AoKS5faW4gLy8gd2hhdD9cbiAgdmFyIGNsb25lID0gRGFnb2JhLm1ha2VfZ3JlbWxpbih2ZXJ0ZXgpIC8vIHdlIGxvc2UgaGlzdG9yeSBoZXJlOiB1c2UgY2xvbmVfZ3JlbWxpbihncmVtbGluKS5nb3RvKHZlcnRleCkgaW5zdGVhZFxuICByZXR1cm4gY2xvbmVcbn0pXG5cbkRhZ29iYS5hZGRRRnVuKCdvdXRBbGxOJywgZnVuY3Rpb24oZ3JhcGgsIGFyZ3MsIGdyZW1saW4sIHN0YXRlKSB7XG4gIHZhciBmaWx0ZXIgPSBhcmdzWzBdXG4gIHZhciBsaW1pdCA9IGFyZ3NbMV0tMVxuICBcbiAgaWYoIXN0YXRlLmVkZ2VMaXN0KSB7IC8vIGluaXRpYWxpemVcbiAgICBpZighZ3JlbWxpbikgcmV0dXJuICdwdWxsJ1xuICAgIHN0YXRlLmVkZ2VMaXN0ID0gW11cbiAgICBzdGF0ZS5jdXJyZW50ID0gMFxuICAgIHN0YXRlLmVkZ2VMaXN0WzBdID0gZ3JhcGguZmluZE91dEVkZ2VzKGdyZW1saW4udmVydGV4KS5maWx0ZXIoRGFnb2JhLmZpbHRlclRoaW5ncyhmaWx0ZXIpKVxuICB9XG4gIFxuICBpZighc3RhdGUuZWRnZUxpc3Rbc3RhdGUuY3VycmVudF0ubGVuZ3RoKSB7IC8vIGZpbmlzaGVkIHRoaXMgcm91bmRcbiAgICBpZihzdGF0ZS5jdXJyZW50ID49IGxpbWl0IHx8ICFzdGF0ZS5lZGdlTGlzdFtzdGF0ZS5jdXJyZW50KzFdICAgLy8gdG90YWxseSBkb25lLCBvciB0aGUgbmV4dCByb3VuZCBoYXMgbm8gaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8ICFzdGF0ZS5lZGdlTGlzdFtzdGF0ZS5jdXJyZW50KzFdLmxlbmd0aCkge1xuICAgICAgc3RhdGUuZWRnZUxpc3QgPSBmYWxzZVxuICAgICAgcmV0dXJuICdwdWxsJ1xuICAgIH1cbiAgICBzdGF0ZS5jdXJyZW50KysgLy8gZ28gdG8gbmV4dCByb3VuZFxuICAgIHN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0gPSBbXSBcbiAgfVxuICBcbiAgdmFyIHZlcnRleCA9IHN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnRdLnBvcCgpLl9pblxuICBcbiAgaWYoc3RhdGUuY3VycmVudCA8IGxpbWl0KSB7IC8vIGFkZCBhbGwgb3VyIG1hdGNoaW5nIGVkZ2VzIHRvIHRoZSBuZXh0IGxldmVsXG4gICAgaWYoIXN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0pIHN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0gPSBbXVxuICAgIHN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0gPSBzdGF0ZS5lZGdlTGlzdFtzdGF0ZS5jdXJyZW50KzFdLmNvbmNhdChcbiAgICAgIGdyYXBoLmZpbmRPdXRFZGdlcyh2ZXJ0ZXgpLmZpbHRlcihEYWdvYmEuZmlsdGVyVGhpbmdzKGZpbHRlcikpXG4gICAgKVxuICB9XG4gIFxuICB2YXIgY2xvbmUgPSBEYWdvYmEubWFrZV9ncmVtbGluKHZlcnRleCkgLy8gd2UgbG9zZSBoaXN0b3J5IGhlcmU6IHVzZSBjbG9uZV9ncmVtbGluKGdyZW1saW4pLmdvdG8odmVydGV4KSBpbnN0ZWFkXG4gIHJldHVybiBjbG9uZVxufSlcbiAgXG5EYWdvYmEuYWRkUUZ1bignaW5BbGxOJywgZnVuY3Rpb24oZ3JhcGgsIGFyZ3MsIGdyZW1saW4sIHN0YXRlKSB7XG4gIHZhciBmaWx0ZXIgPSBhcmdzWzBdXG4gIHZhciBsaW1pdCA9IGFyZ3NbMV0tMVxuICBcbiAgaWYoIXN0YXRlLmVkZ2VMaXN0KSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemVcbiAgICBpZighZ3JlbWxpbikgcmV0dXJuICdwdWxsJ1xuICAgIHN0YXRlLmVkZ2VMaXN0ID0gW11cbiAgICBzdGF0ZS5jdXJyZW50ID0gMFxuICAgIHN0YXRlLmVkZ2VMaXN0WzBdID0gZ3JhcGguZmluZEluRWRnZXMoZ3JlbWxpbi52ZXJ0ZXgpLmZpbHRlcihEYWdvYmEuZmlsdGVyVGhpbmdzKGZpbHRlcikpXG4gIH1cbiAgXG4gIGlmKCFzdGF0ZS5lZGdlTGlzdFtzdGF0ZS5jdXJyZW50XS5sZW5ndGgpIHsgICAgICAgICAgICAgICAgICAgICAvLyBmaW5pc2hlZCB0aGlzIHJvdW5kXG4gICAgaWYoc3RhdGUuY3VycmVudCA+PSBsaW1pdCB8fCAhc3RhdGUuZWRnZUxpc3Rbc3RhdGUuY3VycmVudCsxXSAvLyB0b3RhbGx5IGRvbmUsIG9yIHRoZSBuZXh0IHJvdW5kIGhhcyBubyBpdGVtc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgIXN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0ubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5lZGdlTGlzdCA9IGZhbHNlXG4gICAgICByZXR1cm4gJ3B1bGwnXG4gICAgfVxuICAgIHN0YXRlLmN1cnJlbnQrKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ28gdG8gbmV4dCByb3VuZFxuICAgIHN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0gPSBbXSBcbiAgfVxuICBcbiAgdmFyIHZlcnRleCA9IHN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnRdLnBvcCgpLl9vdXRcbiAgXG4gIGlmKHN0YXRlLmN1cnJlbnQgPCBsaW1pdCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgYWxsIG91ciBtYXRjaGluZyBlZGdlcyB0byB0aGUgbmV4dCBsZXZlbFxuICAgIGlmKCFzdGF0ZS5lZGdlTGlzdFtzdGF0ZS5jdXJyZW50KzFdKSBzdGF0ZS5lZGdlTGlzdFtzdGF0ZS5jdXJyZW50KzFdID0gW11cbiAgICBzdGF0ZS5lZGdlTGlzdFtzdGF0ZS5jdXJyZW50KzFdID0gc3RhdGUuZWRnZUxpc3Rbc3RhdGUuY3VycmVudCsxXS5jb25jYXQoXG4gICAgICBncmFwaC5maW5kSW5FZGdlcyh2ZXJ0ZXgpLmZpbHRlcihEYWdvYmEuZmlsdGVyVGhpbmdzKGZpbHRlcikpXG4gICAgKVxuICB9XG4gIFxuICB2YXIgY2xvbmUgPSBEYWdvYmEubWFrZV9ncmVtbGluKHZlcnRleCkgLy8gd2UgbG9zZSBoaXN0b3J5IGhlcmU6IHVzZSBjbG9uZV9ncmVtbGluKGdyZW1saW4pLmdvdG8odmVydGV4KSBpbnN0ZWFkXG4gIHJldHVybiBjbG9uZVxufSlcbiAgXG5EYWdvYmEuYWRkUUZ1bignaW4nLCBmdW5jdGlvbihncmFwaCwgYXJncywgZ3JlbWxpbiwgc3RhdGUpIHtcbiAgaWYoIWdyZW1saW4gJiYgKCFzdGF0ZS5lZGdlcyB8fCAhc3RhdGUuZWRnZXMubGVuZ3RoKSkgcmV0dXJuICdwdWxsJ1xuICBpZighc3RhdGUuZWRnZXMgfHwgIXN0YXRlLmVkZ2VzLmxlbmd0aCkgXG4gICAgc3RhdGUuZWRnZXMgPSBncmFwaC5maW5kSW5FZGdlcyhncmVtbGluLnZlcnRleCkuZmlsdGVyKERhZ29iYS5maWx0ZXJUaGluZ3MoYXJnc1swXSkpXG4gIGlmKCFzdGF0ZS5lZGdlcy5sZW5ndGgpIHJldHVybiAncHVsbCdcbiAgdmFyIHZlcnRleCA9IHN0YXRlLmVkZ2VzLnBvcCgpLl9vdXQgLy8gd2hhdD8gLy8gYWxzbywgYWJzdHJhY3QgdGhpcy4uLlxuICB2YXIgY2xvbmUgPSBEYWdvYmEubWFrZV9ncmVtbGluKHZlcnRleCkgLy8gd2UgbG9zZSBoaXN0b3J5IGhlcmU6IHVzZSBjbG9uZV9ncmVtbGluKGdyZW1saW4pLmdvdG8odmVydGV4KSBpbnN0ZWFkXG4gIHJldHVybiBjbG9uZVxufSlcbiAgXG5EYWdvYmEuYWRkUUZ1bigncHJvcGVydHknLCBmdW5jdGlvbihncmFwaCwgYXJncywgZ3JlbWxpbiwgc3RhdGUpIHtcbiAgaWYoIWdyZW1saW4pIHJldHVybiAncHVsbCdcbiAgZ3JlbWxpbi5yZXN1bHQgPSBncmVtbGluLnZlcnRleFthcmdzWzBdXVxuICByZXR1cm4gZ3JlbWxpblxufSlcbiAgXG5EYWdvYmEuYWRkUUZ1bigndW5pcXVlJywgZnVuY3Rpb24oZ3JhcGgsIGFyZ3MsIGdyZW1saW4sIHN0YXRlKSB7XG4gIGlmKCFncmVtbGluKSByZXR1cm4gJ3B1bGwnXG4gIGlmKHN0YXRlW2dyZW1saW4udmVydGV4Ll9pZF0pIHJldHVybiAncHVsbCcgICAgICAgICAgICAgICAgICAgICAvLyB3ZSd2ZSBzZWVuIHRoaXMgZ3JlbWxpbiwgc28gZ2V0IGFub3RoZXIgaW5zdGVhZFxuICBzdGF0ZVtncmVtbGluLnZlcnRleC5faWRdID0gdHJ1ZVxuICByZXR1cm4gZ3JlbWxpblxufSlcbiAgXG5EYWdvYmEuYWRkUUZ1bignZmlsdGVyJywgZnVuY3Rpb24oZ3JhcGgsIGFyZ3MsIGdyZW1saW4sIHN0YXRlKSB7XG4gIGlmKCFncmVtbGluKSByZXR1cm4gJ3B1bGwnXG4gIGlmKHR5cGVvZiBhcmdzWzBdICE9ICdmdW5jdGlvbicpIHJldHVybiBEYWdvYmEub25FcnJvcignRmlsdGVyIGFyZyBpcyBub3QgYSBmdW5jdGlvbjogJyArIGFyZ3NbMF0pIHx8IGdyZW1saW5cbiAgaWYoIWFyZ3NbMF0oZ3JlbWxpbi52ZXJ0ZXgpKSByZXR1cm4gJ3B1bGwnICAgICAgICAgICAgICAgICAgICAgIC8vIGdyZW1saW4gZmFpbHMgZmlsdGVyIGZ1bmN0aW9uIFxuICAvLyBUSElOSzogd291bGQgd2UgZXZlciB3YW50IHRvIGZpbHRlciBieSBvdGhlciBwYXJ0cyBvZiB0aGUgZ3JlbWxpbj9cbiAgcmV0dXJuIGdyZW1saW5cbn0pXG4gIFxuRGFnb2JhLmFkZFFGdW4oJ3Rha2UnLCBmdW5jdGlvbihncmFwaCwgYXJncywgZ3JlbWxpbiwgc3RhdGUpIHtcbiAgc3RhdGUudGFrZW4gPSBzdGF0ZS50YWtlbiA/IHN0YXRlLnRha2VuIDogMFxuICBpZihzdGF0ZS50YWtlbiA9PSBhcmdzWzBdKSB7XG4gICAgc3RhdGUudGFrZW4gPSAwXG4gICAgcmV0dXJuICdkb25lJ1xuICB9XG4gIGlmKCFncmVtbGluKSByZXR1cm4gJ3B1bGwnXG4gIHN0YXRlLnRha2VuKysgLy8gVEhJTks6IG11dGF0aW5nIHN0YXRlXG4gIHJldHVybiBncmVtbGluXG59KVxuXG5cblxuLy8gaGkhIFxuLy8gLSB0dW5lIGdyZW1saW5zIChjb2xsaXNpb25zLCBoaXN0b3J5LCBldGMpXG4vLyAtIGludGVyZmFjZTogc2hvdyBxdWVyeSBwaWVjZXMgYW5kIHBhcmFtcyxcbi8vIC0gaW50ZXJmYWNlOiByZXN1bWFibGUgcXVlcmllc1xuLy8gLSBnZW5lcmF0aW9uYWwgcXVlcmllc1xuLy8gLSBpbnRlcnNlY3Rpb25zXG4vLyAtIGFkdmVyYnNcbi8vIC0geW91IGFyZSBncmVhdCFcblxuXG5cbkRhZ29iYS5ob29rcyA9IHt9XG5cbkRhZ29iYS5hZGRob29rID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2spIHtcbiAgaWYoIURhZ29iYS5ob29rc1t0eXBlXSkgRGFnb2JhLmhvb2tzW3R5cGVdID0gW11cbiAgRGFnb2JhLmhvb2tzW3R5cGVdLnB1c2goY2FsbGJhY2spXG59XG5cbkRhZ29iYS5maXJlaG9va3MgPSBmdW5jdGlvbih0eXBlLCBxdWVyeSkge1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKVxuICByZXR1cm4gKChEYWdvYmEuaG9va3MgfHwge30pW3R5cGVdIHx8IFtdKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBjYWxsYmFjaykge3JldHVybiBjYWxsYmFjay5hcHBseShxdWVyeSwgYWNjKX0sIGFyZ3MpXG59XG5cbkRhZ29iYS5tYWtlX2dyZW1saW4gPSBmdW5jdGlvbih2ZXJ0ZXgsIHN0YXRlKSB7IHJldHVybiB7dmVydGV4OiB2ZXJ0ZXgsIHN0YXRlOiBzdGF0ZX0gfVxuXG5EYWdvYmEuZmlsdGVyVGhpbmdzID0gZnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiAhYXJnID8gdHJ1ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgaXMgdHJ1ZVxuICAgICAgICAgOiBhcmcrJycgPT09IGFyZyA/IHRoaW5nLl9sYWJlbCA9PSBhcmcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBsYWJlbFxuICAgICAgICAgOiBBcnJheS5pc0FycmF5KGFyZykgPyAhIX5hcmcuaW5kZXhPZih0aGluZy5fbGFiZWwpIDogRGFnb2JhLm9iakZpbHRlcih0aGluZywgYXJnKSB9IH0gIC8vIG9yIGEgbGlzdCBvZiBsYWJlbHNcblxuRGFnb2JhLm9iakZpbHRlciA9IGZ1bmN0aW9uKHRoaW5nLCBvYmopIHtcbiAgZm9yKHZhciBrZXkgaW4gb2JqKVxuICAgIGlmKHRoaW5nW2tleV0gIT0gb2JqW2tleV0pXG4gICAgICByZXR1cm4gZmFsc2U7IHJldHVybiB0cnVlIH1cblxuRGFnb2JhLmZpbmQgPSBmdW5jdGlvbihhcnIsIGZ1bikge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgIGlmKGZ1bihhcnJbaV0sIGksIGFycikpXG4gICAgICByZXR1cm4gYXJyW2ldIH1cblxuRGFnb2JhLmNsZWFudmVydGV4ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge3JldHVybiAoa2V5ID09ICdfaW4nIHx8IGtleSA9PSAnX291dCcpID8gdW5kZWZpbmVkIDogdmFsdWV9IC8vIGZvciBKU09OLnN0cmluZ2lmeVxuRGFnb2JhLmNsZWFuZWRnZSAgID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge3JldHVybiBrZXkgPT0gJ19pbicgPyB2YWx1ZS5faWQgOiBrZXkgPT0gJ19vdXQnID8gdmFsdWUuX2lkIDogdmFsdWV9XG5cbkRhZ29iYS51bmlxdWVpZnkgPSBmdW5jdGlvbiAocmVzdWx0cykgeyAvLyBPUFQ6IGRvIHRoaXMgaW4gdGhlIHF1ZXJ5IHZpYSBncmVtbGluIGNvbGxpc2lvbiBjb3VudGluZ1xuICByZXR1cm4gW3Jlc3VsdHMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0sIGluZGV4LCBhcnJheSkge3JldHVybiBhcnJheS5pbmRleE9mKGl0ZW0pID09IGluZGV4fSldfVxuXG5EYWdvYmEuY2xlYW5jbG9uZSA9IGZ1bmN0aW9uIChyZXN1bHRzKSB7IC8vIHJlbW92ZSBhbGwgXy1wcmVmaXhlZCBwcm9wZXJ0aWVzXG4gcmV0dXJuIFtyZXN1bHRzLm1hcChmdW5jdGlvbihpdGVtKSB7cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaXRlbSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge3JldHVybiBrZXlbMF09PSdfJyA/IHVuZGVmaW5lZCA6IHZhbHVlfSkpfSldfVxuXG4vLyBOT1RFOiBhZGQgdGhlc2UgaG9va3MgaWYgeW91IG5lZWQgdGhlbS4gKG91ciB2ZXJ0ZXggcGF5bG9hZHMgYXJlIGltbXV0YWJsZSwgYW5kIHdlIHVuaXF1ZWlmeSBwcmlvciB0byB0YWtpbmcuKVxuXG4vLyBEYWdvYmEuYWRkaG9vaygncG9zdHF1ZXJ5JywgRGFnb2JhLnVuaXF1ZWlmeSlcbi8vIERhZ29iYS5hZGRob29rKCdwb3N0cXVlcnknLCBEYWdvYmEuY2xlYW5jbG9uZSlcblxuLy8gVEhJTks6IHRoZSB1bmlxdWlmeSBob29rIGhhcHBlbnMgYWZ0ZXIgdGhlIHRha2UgY29tcG9uZW50IHNvIGl0IHNtdXNoZXMgcmVzdWx0cyBkb3duLCBwb3NzaWJseSByZXR1cm5pbmcgZmV3ZXIgdGhhbiB5b3Ugd2FudGVkLi4uXG4gIFxuRGFnb2JhLm9uRXJyb3IgPSBmdW5jdGlvbihtc2cpIHtcbiAgY29uc29sZS5sb2cobXNnKVxuICByZXR1cm4gZmFsc2UgXG59IiwiLypcbiAgICBldmVudHM6IGEgcHViL3N1YiBzeXN0ZW0gd2l0aCB3aWxkY2FyZCBwYXRoc1xuKi9cblxuXG5FdmVudHMgPSB7fVxuRXZlbnRzLnN1YnMgPSB7fVxuXG5FdmVudHMucHViID0gZnVuY3Rpb24ocGF0aCwgZGF0YSkge1xuICAgIHJldHVybiBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7RXZlbnRzLnN0YXJ0X3B1YihwYXRoLCBkYXRhKX0pICAgICAgICAgICAgICAvLyBkbyBpdCBuZXh0IHRpY2tcbn1cblxuRXZlbnRzLnN1YiA9IGZ1bmN0aW9uKHBhdGgsIGhhbmRsZXIpIHtcbiAgICBwYXRoID0gRXZlbnRzLnNjcnViX3BhdGgocGF0aCkuam9pbignLycpXG4gICAgaWYoIUV2ZW50cy5zdWJzW3BhdGhdKSBFdmVudHMuc3Vic1twYXRoXSA9IFtdXG4gICAgRXZlbnRzLnN1YnNbcGF0aF0ucHVzaChoYW5kbGVyKVxufVxuXG5FdmVudHMudW5zdWIgPSBmdW5jdGlvbihwYXRoLCBoYW5kbGVyKSB7XG4gICAgcGF0aCA9IEV2ZW50cy5zY3J1Yl9wYXRoKHBhdGgpLmpvaW4oJy8nKVxuXG4gICAgdmFyIHN1YnMgPSBFdmVudHMuc3Vic1twYXRoXVxuICAgIGlmKCFzdWJzKSByZXR1cm4gZmFsc2VcblxuICAgIHZhciBpbmRleCA9IHN1YnMuaW5kZXhPZihoYW5kbGVyKVxuICAgIGlmKGluZGV4ID09IC0xKSByZXR1cm4gZmFsc2VcblxuICAgIHN1YnMuc3BsaWNlKGluZGV4LCAxKVxufVxuXG5FdmVudHMuc3RhcnRfcHViID0gZnVuY3Rpb24ocGF0aCwgZGF0YSkge1xuICAgIC8vLy8gcHViIHRvICogYXQgZWFjaCBsZXZlbCBhbmQgdGhlbiB0byBwYXRoIGl0c2VsZlxuICAgIHZhciBwYXRobGlzdCA9IEV2ZW50cy5zY3J1Yl9wYXRoKHBhdGgpXG4gICAgdmFyIHJlYWxwYXRoID0gcGF0aGxpc3Quam9pbignLycpXG5cbiAgICBFdmVudHMudHJ5X3B1YignKicsIGRhdGEsIHJlYWxwYXRoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2xvYmFsIGNhdGNoYWxsXG5cbiAgICBwYXRobGlzdC5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBzZWcpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbm5lbCBjYXRjaGFsbHNcbiAgICAgICAgdmFyIG5ld2FjYyA9IGFjYyArIHNlZyArICcvJ1xuICAgICAgICBFdmVudHMudHJ5X3B1YihuZXdhY2MgKyAnKicsIGRhdGEsIHJlYWxwYXRoKVxuICAgICAgICByZXR1cm4gbmV3YWNjXG4gICAgfSwgJycpXG5cbiAgICBFdmVudHMudHJ5X3B1YihyZWFscGF0aCwgZGF0YSwgcmVhbHBhdGgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWN0dWFsIGNoYW5uZWxcbn1cblxuRXZlbnRzLnRyeV9wdWIgPSBmdW5jdGlvbihwYXRoLCBkYXRhLCByZWFscGF0aCkge1xuICAgIHZhciBoYW5kbGVycyA9IEV2ZW50cy5zdWJzW3BhdGhdXG4gICAgaWYoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHJldHVybiBmYWxzZVxuICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlcikge2hhbmRsZXIoZGF0YSwgcmVhbHBhdGgpfSlcbiAgICAvLyBUSElOSzogdXNlIHNldEltbWVkaWF0ZSBoZXJlP1xufVxuXG5cbkV2ZW50cy5zY3J1Yl9wYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL15bXlxcdyotXSsvLCAnJykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJpbSBsZWFkaW5nIHNsYXNoZXMgZXRjXG4gICAgICAgIC5yZXBsYWNlKC9bXlxcdyotXSskLywgJycpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmltIHRyYWlsaW5nIGd1bmtcbiAgICAgICAgLnNwbGl0KCcvJykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWsgb3V0IHRoZSBwYXRoIHNlZ21lbnRzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oaXRlbSkge3JldHVybiBpdGVtLnJlcGxhY2UoL1teXFx3Ki1dL2csICcnKX0pICAgICAgICAgICAgICAvLyBzY3J1YiBlYWNoIHNlZ21lbnRcbn1cblxuXG4vLyBtYXliZSBsYXRlclxuLy8gZXZlbnRsb2cgPSBbXVxuLy8gRXZlbnRzLnN1YignKicsIGZ1bmN0aW9uKGRhdGEsIHBhdGgpIHtcbi8vICAgICBldmVudGxvZy5wdXNoKFtwYXRoLCBkYXRhXSlcbi8vIH0pXG5cbiIsIkZpbGVGaWxlID0ge31cblxuRmlsZUZpbGUub2xkRmlsZSA9IG51bGxcblxuRmlsZUZpbGUucHJlcEJsb2IgPSBmdW5jdGlvbihzdHIsIHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPSAnc3RyaW5nJylcbiAgICAgICAgc3RyID0gSlNPTi5zdHJpbmdpZnkoc3RyKVxuXG4gICAgdmFyIGJsb2JcblxuICAgIGlmICh0eXBlID09ICdmaWxlJylcbiAgICAgICAgYmxvYiA9IEZpbGVGaWxlLmRhdGFVUkl0b0Jsb2Ioc3RyKVxuICAgIGVsc2VcbiAgICAgICAgYmxvYiA9IG5ldyBCbG9iKFtzdHJdLCB7dHlwZTogJ3RleHQvcGxhaW4nfSlcblxuICAgIGlmIChuYXZpZ2F0b3IuYXBwVmVyc2lvbi50b1N0cmluZygpLmluZGV4T2YoJy5ORVQnKSA+IDApICAgICAgICAgICAgLy8gSUUgbmVlZHMgdG8gZGlyZWN0bHkgc2F2ZSB0aGUgYmxvYiBvYmplY3RcbiAgICAgICAgcmV0dXJuIGJsb2JcblxuICAgIGlmKEZpbGVGaWxlLm9sZEZpbGUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudHMgb2xkIGJsb2JzIGZyb20gY2F1c2luZyBtZW0gbGVha3NcbiAgICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTChGaWxlRmlsZS5vbGRGaWxlKVxuXG4gICAgRmlsZUZpbGUub2xkRmlsZSA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG5cbiAgICByZXR1cm4gRmlsZUZpbGUub2xkRmlsZVxufVxuXG5GaWxlRmlsZS5vcGVuUHVmZkZpbGUgPSBmdW5jdGlvbihlbGVtZW50KSB7ICAgICAgICAgICAgICAgIFxuICAgIHJldHVybiBGaWxlRmlsZS5oYW5kbGVGaWxlT3BlbihlbGVtZW50KVxufVxuXG5GaWxlRmlsZS5vcGVuVGV4dEZpbGUgPSBmdW5jdGlvbihlbGVtZW50KSB7ICAgICAgICAgICAgICAgIFxuICAgIHJldHVybiBGaWxlRmlsZS5oYW5kbGVGaWxlT3BlbihlbGVtZW50KVxufVxuXG5GaWxlRmlsZS5vcGVuQmluYXJ5RmlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHsgICAgICAgICAgICAgICAgXG4gICAgcmV0dXJuIEZpbGVGaWxlLmhhbmRsZUZpbGVPcGVuKGVsZW1lbnQsICdhc0RhdGFVUkknKVxufVxuXG5GaWxlRmlsZS5oYW5kbGVGaWxlT3BlbiA9IGZ1bmN0aW9uKGVsZW1lbnQsIGFzRGF0YVVSSSkgeyAgICAgICAgICAgICAgICBcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG5cbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhyZWFkZXIpXG4gICAgICAgICAgICB2YXIgZGF0YVVSSUNvbnRlbnQgPSBldmVudC50YXJnZXQucmVzdWx0XG4gICAgICAgICAgICAvLyB2YXIgYmxvYiA9IEZpbGVGaWxlLmRhdGFVUkl0b0Jsb2IoZGF0YVVSSUNvbnRlbnQpXG4gICAgICAgICAgICByZXNvbHZlKGRhdGFVUklDb250ZW50KVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZighZWxlbWVudC5maWxlc1swXSkgLy8gVEhJTks6IGlzIGZhbHNlIHRoZSByaWdodCByZXNwb25zZT9cbiAgICAgICAgICAgIHJldHVybiByZWplY3QoJ05vIGZpbGUgc2VsZWN0ZWQnKVxuICAgICAgICAgICAgXG4gICAgICAgIGlmKGFzRGF0YVVSSSlcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGVsZW1lbnQuZmlsZXNbMF0pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGVsZW1lbnQuZmlsZXNbMF0pXG4gICAgfSlcbn1cblxuRmlsZUZpbGUuZGF0YVVSSXRvQmxvYiA9IGZ1bmN0aW9uKGRhdGFVUkkpIHtcbiAgICAvLyBjb252ZXJ0IGJhc2U2NC9VUkxFbmNvZGVkIGRhdGEgY29tcG9uZW50IHRvIHJhdyBiaW5hcnkgZGF0YSBoZWxkIGluIGEgQmxvYlxuICAgIC8vIHZpYSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5OTg5MDgvY29udmVydC1kYXRhLXVyaS10by1maWxlLXRoZW4tYXBwZW5kLXRvLWZvcm1kYXRhXG4gICAgdmFyIGJ5dGVTdHJpbmdcbiAgICBcbiAgICBpZiAoZGF0YVVSSS5zcGxpdCgnLCcpWzBdLmluZGV4T2YoJ2Jhc2U2NCcpID49IDApXG4gICAgICAgIGJ5dGVTdHJpbmcgPSBhdG9iKGRhdGFVUkkuc3BsaXQoJywnKVsxXSlcbiAgICBlbHNlXG4gICAgICAgIGJ5dGVTdHJpbmcgPSB1bmVzY2FwZShkYXRhVVJJLnNwbGl0KCcsJylbMV0pXG5cbiAgICAvLyBzZXBhcmF0ZSBvdXQgdGhlIG1pbWUgY29tcG9uZW50XG4gICAgdmFyIG1pbWVTdHJpbmcgPSBkYXRhVVJJLnNwbGl0KCcsJylbMF0uc3BsaXQoJzonKVsxXS5zcGxpdCgnOycpWzBdXG5cbiAgICAvLyB3cml0ZSB0aGUgYnl0ZXMgb2YgdGhlIHN0cmluZyB0byBhIHR5cGVkIGFycmF5XG4gICAgdmFyIGlhID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZVN0cmluZy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlhW2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCbG9iKFtpYV0sIHt0eXBlOm1pbWVTdHJpbmd9KVxufVxuIiwiLypcbiAgICBncmlkYm94OiBhIHNpbXBsZSBzeXN0ZW0gZm9yIHB1dHRpbmcgdGhpbmdzIGluIHBsYWNlc1xuKi9cblxuR3JpZGJveCA9IHt9XG5cbkdyaWRib3guZ2V0R3JpZENvb3JkQm94ID0gZnVuY3Rpb24ocm93cywgY29scywgb3V0ZXJ3aWR0aCwgb3V0ZXJoZWlnaHQsIHZlcnRpY2FsUGFkZGluZykge1xuICAgIHZhciBtaW4gPSBmdW5jdGlvbihhLCBiKSB7cmV0dXJuIE1hdGgubWluKGEsIGIpfVxuICAgIHZhciBtYXggPSBmdW5jdGlvbihhLCBiKSB7cmV0dXJuIE1hdGgubWF4KGEsIGIpfVxuICAgIHZhciBncmlkd2lkdGggID0gb3V0ZXJ3aWR0aCAgLyBjb2xzXG4gICAgdmFyIGdyaWRoZWlnaHQgPSBvdXRlcmhlaWdodCAvIHJvd3NcbiAgICB2YXIgZXEgPSBmdW5jdGlvbihhLCBiKSB7cmV0dXJuIGEgPT0gYn1cbiAgICB2YXIgZ3JpZCA9IEFycmF5LmFwcGx5KDAsIEFycmF5KHJvd3MpKVxuICAgICAgICAubWFwKGZ1bmN0aW9uKCkge3JldHVybiBBcnJheS5hcHBseSgwLCBBcnJheShjb2xzKSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oKSB7cmV0dXJuIDB9KX0pIC8vIGJ1aWxkIDJEIGFycmF5XG5cbiAgICByZXR1cm4geyBnZXQ6IGZ1bmN0aW9uKCkge3JldHVybiBncmlkfVxuICAgICAgICAsIHNldF9lcTogZnVuY3Rpb24obmV3X2VxKSB7ZXEgPSBuZXdfZXF9XG4gICAgICAgICwgYWRkOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBtaW55LCBtaW54LCBtYXh5LCBtYXh4LCBwb2ludGVyKSB7XG4gICAgICAgICAgICBtYXh5ID0gbWluKG1heHl8fHJvd3MtaGVpZ2h0LCByb3dzLWhlaWdodCksIG1heHggPSBtaW4obWF4eHx8Y29scy13aWR0aCwgY29scy13aWR0aClcbiAgICAgICAgICAgIG1pbnkgPSBtaW4obWlueXx8MCwgbWF4eSksIG1pbnggPSBtaW4obWlueHx8MCwgbWF4eClcbiAgICAgICAgICAgIGlmKG1heHg8MCB8fCBtYXh5PDApIHJldHVybiBFQi5vbkVycm9yKCdCbG9jayBpcyB0b28gYmlnIGZvciB0aGUgZ3JpZCcpXG5cbiAgICAgICAgICAgIHRvcDogZm9yKHZhciB5ID0gbWlueTsgeSA8PSBtYXh5OyB5KyspIHtcbiAgICAgICAgICAgICAgICBib3Q6IGZvcih2YXIgeCA9IG1pbng7IHggPD0gbWF4eDsgIHgrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGR5ID0gMDsgZHkgPCBoZWlnaHQ7IGR5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgZHggPSAwOyBkeCA8IHdpZHRoOyBkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZ3JpZFt5K2R5XVt4K2R4XSkgY29udGludWUgYm90IH19XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcCB9fVxuICAgICAgICAgICAgaWYoeCA9PSBtYXh4KzEgJiYgeSA9PSBtYXh5KzEpIHJldHVybiBFQi5vbkVycm9yKCdObyByb29tIGluIHRoZSBncmlkJylcbiAgICAgICAgICAgIGlmKHggPT0gbnVsbCB8fCB5ID09IG51bGwpIHJldHVybiBFQi5vbkVycm9yKCdCbG9jayB0b28gYmlnIGZvciB0aGUgZ3JpZCcpXG4gICAgICAgICAgICBmb3IodmFyIGR5ID0gMDsgZHkgPCBoZWlnaHQ7IGR5KyspIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGR4ID0gMDsgZHggPCB3aWR0aDsgZHgrKykge1xuICAgICAgICAgICAgICAgICAgICBncmlkW3krZHldW3grZHhdID0gcG9pbnRlciB8fCAxIH0gfVxuICAgICAgICAgICAgcmV0dXJuIHt3aWR0aDogd2lkdGgqZ3JpZHdpZHRoLCBoZWlnaHQ6IGhlaWdodCpncmlkaGVpZ2h0LCB4OiB4KmdyaWR3aWR0aCwgeTogeSpncmlkaGVpZ2h0Kyh2ZXJ0aWNhbFBhZGRpbmcvMS41KX0gLy8gVEhJTks6IGdlbmVyYWxpemUgdmVydGljYWxQYWRkaW5nIFxuICAgICAgICB9XG4gICAgfVxufVxuXG5HcmlkYm94LmZpbmROZWlnaGJvciA9IGZ1bmN0aW9uKGdyaWQsIHBvaW50ZXIsIGRpcikge1xuICAgIHZhciBib3hDb29yZHMgPSBHcmlkYm94LmZpbmRCb3hJbkdyaWQoZ3JpZCwgcG9pbnRlcilcbiAgICBpZighYm94Q29vcmRzKSByZXR1cm4gZmFsc2VcblxuICAgIC8vIFRPRE86IG5lZWQgdG8gaW5kaWNhdGUgaWYgZGlyQm94IGlzIG91dHNpZGUgb2YgZ3JpZCwgdmVyc3VzIHBvaW50ZXIgbm90IGZvdW5kXG5cbiAgICB2YXIgZGlyQm94ID0gR3JpZGJveC5tYWtlRGlyQm94KGJveENvb3JkcywgZGlyKVxuICAgIGlmKCFkaXJCb3gpIHJldHVybiBmYWxzZVxuXG4gICAgcmV0dXJuIEdyaWRib3guZmlyc3RUaGluZ0luQm94KGdyaWQsIGRpckJveFswXSwgZGlyQm94WzFdKVxufVxuXG5HcmlkYm94LmZpbmRCb3hJbkdyaWQgPSBmdW5jdGlvbihncmlkLCB0YXJnZXQsIGVxKSB7XG4gICAgLy8vIGZpbmQgc29tZXRoaW5nIGluIGEgZ3JpZCBib3ggYW5kIHJldHVybiBjb29yZHNcbiAgICAvLy8gTk9URTogdGhpcyBhc3N1bWVzIHJlY3RpbGluZWFyIHNoYXBlc1xuICAgIGVxID0gZXEgfHwgZnVuY3Rpb24oYSwgYikge3JldHVybiBhID09PSBifVxuICAgIGVxID0gZnVuY3Rpb24oYSwgYikge3JldHVybiBhLnNpZyA9PT0gYi5zaWd9IC8vIFRPRE86IGVuY2Fwc3VsYXRlIGVxIGluIGdyaWRCb3ggLy8gT1BUOiBkb24ndCBsb29rIGluc2lkZVxuXG4gICAgdG9wOiBmb3IodmFyIHkgPSAwLCBseSA9IGdyaWQubGVuZ3RoOyB5IDwgbHk7IHkrKylcbiAgICAgICAgZm9yKHZhciB4ID0gMCwgbHggPSBncmlkW3ldLmxlbmd0aDsgeCA8IGx4OyB4KyspXG4gICAgICAgICAgICBpZihlcShncmlkW3ldW3hdLCB0YXJnZXQpKSBicmVhayB0b3AgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHRvcCBhbmQgbGVmdCBjb29yZHNcblxuICAgIGlmKHkgPT0gZ3JpZC5sZW5ndGggJiYgeCA9PSBncmlkWzBdLmxlbmd0aCkgcmV0dXJuIGZhbHNlICAgICAgICAgICAgLy8gdGFyZ2V0IG5vdCBpbiBib3hcblxuICAgIGZvcih2YXIgZHkgPSAwLCBseSA9IGdyaWQubGVuZ3RoLXk7IGR5IDwgbHk7IGR5KyspXG4gICAgICAgIGlmKCFlcShncmlkW3krZHldW3hdLCB0YXJnZXQpKSBicmVhayAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIGJvdHRvbSBjb29yZFxuXG4gICAgZm9yKHZhciBkeCA9IDAsIGx4ID0gZ3JpZFt5XS5sZW5ndGgteDsgZHggPCBseDsgZHgrKylcbiAgICAgICAgaWYoIWVxKGdyaWRbeV1beCtkeF0sIHRhcmdldCkpIGJyZWFrICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgcmlnaHQgY29vcmRcblxuICAgIHJldHVybiBbW3gsIHldLCBbeCtkeC0xLCB5K2R5LTFdXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWludXMgb25lIGJlY2F1c2UgZGVsdGFzIGFsd2F5cyBvdmVyc2hvb3Rcbn1cblxuR3JpZGJveC5maXJzdFRoaW5nSW5Cb3ggPSBmdW5jdGlvbihncmlkLCB0b3BsZWZ0LCBib3RyaWdodCkge1xuICAgIGZvcih2YXIgeSA9IE1hdGgubWF4KHRvcGxlZnRbMV0sIDApLCBseSA9IE1hdGgubWluKGJvdHJpZ2h0WzFdLCBncmlkLmxlbmd0aC0xKTsgeSA8PSBseTsgeSsrKVxuICAgICAgICBmb3IodmFyIHggPSBNYXRoLm1heCh0b3BsZWZ0WzBdLCAwKSwgbHggPSBNYXRoLm1pbihib3RyaWdodFswXSwgZ3JpZFswXS5sZW5ndGgtMSk7IHggPD0gbHg7IHgrKylcbiAgICAgICAgICAgIGlmKGdyaWRbeV1beF0pIHJldHVybiBncmlkW3ldW3hdICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGx0ZXEgYmVjYXVzZSBvdXIgYm94ZXMgYXJlIGluY2x1c2l2ZTtcbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvdW5kYXJpZXMgYXJlIGJ1aWx0IGluLlxuXG5HcmlkYm94Lm1ha2VEaXJCb3ggPSBmdW5jdGlvbihib3hDb29yZHMsIGRpcikge1xuICAgIHZhciB0b3AgICA9IGJveENvb3Jkc1swXVsxXVxuICAgIHZhciBsZWZ0ICA9IGJveENvb3Jkc1swXVswXVxuICAgIHZhciBib3QgICA9IGJveENvb3Jkc1sxXVsxXVxuICAgIHZhciByaWdodCA9IGJveENvb3Jkc1sxXVswXVxuXG4gICAgaWYoZGlyID09ICd1cCcpICAgIHJldHVybiBbW2xlZnQsIHRvcC0xXSwgIFtyaWdodCwgdG9wLTFdXVxuICAgIGlmKGRpciA9PSAnZG93bicpICByZXR1cm4gW1tsZWZ0LCBib3QrMV0sICBbcmlnaHQsIGJvdCsxXV1cbiAgICBpZihkaXIgPT0gJ2xlZnQnKSAgcmV0dXJuIFtbbGVmdC0xLCB0b3BdLCAgW2xlZnQtMSwgYm90XV1cbiAgICBpZihkaXIgPT0gJ3JpZ2h0JykgcmV0dXJuIFtbcmlnaHQrMSwgdG9wXSwgW3JpZ2h0KzEsIGJvdF1dXG59XG4iLCIvKlxuICAgIFRpbWluZyBpcyBldmVyeXRoaW5nXG4qL1xuXG5+ZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNldEltbWVkaWF0ZSwgaGFuZGxlTWVzc2FnZVxuICAgIFxuICAgIH5mdW5jdGlvbigpIHtcbiAgICAgICAgLy8vLyBwb3N0cG9uZSB1bnRpbCBuZXh0IHRpY2tcbiAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cDovL2RiYXJvbi5vcmcvbG9nLzIwMTAwMzA5LWZhc3Rlci10aW1lb3V0c1xuICAgICAgICB2YXIgbGF0ZXIgPSBbXVxuICAgICAgICB2YXIgbWVzc2FnZU5hbWUgPSAxMjM0NVxuICAgICAgICB2YXIgZ2ltbWVfYV90aWNrID0gdHJ1ZVxuXG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGZ1bikge1xuICAgICAgICAgICAgbGF0ZXIucHVzaChmdW4pXG5cbiAgICAgICAgICAgIGlmKGdpbW1lX2FfdGljaykge1xuICAgICAgICAgICAgICAgIGdpbW1lX2FfdGljayA9IGZhbHNlXG4gICAgICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2VOYW1lLCBcIipcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYoZXZlbnQuZGF0YSAhPSBtZXNzYWdlTmFtZSkgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICBnaW1tZV9hX3RpY2sgPSB0cnVlXG5cbiAgICAgICAgICAgIHZhciBub3cgPSBsYXRlclxuICAgICAgICAgICAgbGF0ZXIgPSBbXVxuXG4gICAgICAgICAgICBmb3IodmFyIGk9MCwgbD1ub3cubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgICAgIG5vd1tpXSgpXG4gICAgICAgIH1cbiAgICB9KClcblxuICAgIGZ1bmN0aW9uIHF1ZXVlcigpIHtcbiAgICAgICAgLy8vLyBkbyBzb21ldGhpbmcgYWZ0ZXIgc29tZSBvdGhlciB0aGluZ3NcbiAgICAgICAgdmFyIHF1ZXVlID0gW11cblxuICAgICAgICB2YXIgbmV4dHRpbWUgPSBmdW5jdGlvbihpbnZva2VyKSB7XG4gICAgICAgICAgICBpbnZva2VyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmKCFxdWV1ZS5sZW5ndGgpIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIHF1ZXVlLnNoaWZ0KCkoKVxuICAgICAgICAgICAgICAgIG5leHR0aW1lKGludm9rZXIpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHF1ZXVlciA9IGZ1bmN0aW9uKGludm9rZXIsIGZ1bikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmdW4pXG4gICAgICAgICAgICBpZihxdWV1ZS5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2UgLy8gVEhJTks6IHBvc3NpYmxlIHJhY2UgY29uZGl0aW9uXG4gICAgICAgICAgICBuZXh0dGltZShpbnZva2VyKSBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBxdWV1ZXJcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbmNlKCkge1xuICAgICAgICAvLy8vIGRvIHNvbWV0aGluZyBsYXRlciwgYnV0IG9ubHkgb25jZVxuICAgICAgICB2YXIgbGF0ZXIgPSBbXVxuXG4gICAgICAgIHZhciBzdGVwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbm93ID0gbGF0ZXJcbiAgICAgICAgICAgIGxhdGVyID0gW11cbiAgICAgICAgICAgIGZvcih2YXIgaT0wLCBsPW5vdy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICAgICAgbm93W2ldKClcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvbmNlID0gZnVuY3Rpb24oaW52b2tlciwgZnVuKSB7XG4gICAgICAgICAgICBpZih+bGF0ZXIuaW5kZXhPZihmdW4pKSByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIGxhdGVyLnB1c2goZnVuKVxuICAgICAgICAgICAgaWYobGF0ZXIubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlIC8vIFRISU5LOiBwb3NzaWJsZSByYWNlIGNvbmRpdGlvblxuICAgICAgICAgICAgaW52b2tlcihzdGVwKSBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvbmNlXG4gICAgfVxuXG4gICAgaWYodHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UsIHRydWUpXG4gICAgICAgIHdpbmRvdy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGVcbiAgICAgICAgXG4gICAgICAgIHdpbmRvdy5xdWV1ZUltbWVkaWF0ZSA9IHF1ZXVlcigpLmJpbmQobnVsbCwgc2V0SW1tZWRpYXRlKVxuICAgICAgICB3aW5kb3cub25jZUltbWVkaWF0ZSAgPSBvbmNlKCkuYmluZChudWxsLCBzZXRJbW1lZGlhdGUpXG4gICAgICAgIHdpbmRvdy5xdWV1ZVJBRiA9IHF1ZXVlcigpLmJpbmQobnVsbCwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKVxuICAgICAgICB3aW5kb3cub25jZVJBRiAgPSBvbmNlKCkuYmluZChudWxsLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXG4gICAgXG4gICAgICAgIHZhciB0aW1lZnVuYmluZCA9IHt9XG4gICAgICAgIHdpbmRvdy5vbmNlSW5Bd2hpbGUgPSBmdW5jdGlvbihmdW4sIHRpbWUpIHtcbiAgICAgICAgICAgIC8vLy8gTk9URTogZG9uJ3QgdXNlIHRoZSBzYW1lIGZ1biB3aXRoIGRpZmZlcmVudCB0aW1lc1xuICAgICAgICAgICAgaWYodGltZWZ1bmJpbmRbZnVuXSkgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB0aW1lZnVuYmluZFtmdW5dID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtmdW4oKTsgdGltZWZ1bmJpbmRbZnVuXSA9IGZhbHNlfSwgdGltZSlcbiAgICAgICAgfVxuICAgIH1cbn0oKVxuIiwiLypcbiAgICAgX19fX19fICAgICBfXyAgIF9fICAgX19fX19fICAgICBfX19fX18gICAgIF9fICBfXyAgICAgX19fX19fICAgICBfXyAgICAgX19fX19fICBcbiAgICAvXFwgIF9fX1xcICAgL1xcIFxcIC8gLyAgL1xcICBfX19cXCAgIC9cXCAgPT0gXFwgICAvXFwgXFxfXFwgXFwgICAvXFwgID09IFxcICAgL1xcIFxcICAgL1xcX18gIF9cXCBcbiAgICBcXCBcXCAgX19cXCAgIFxcIFxcIFxcJy8gICBcXCBcXCAgX19cXCAgIFxcIFxcICBfXzwgICBcXCBcXF9fX18gXFwgIFxcIFxcICBfXzwgICBcXCBcXCBcXCAgXFwvXy9cXCBcXC8gXG4gICAgIFxcIFxcX19fX19cXCAgXFwgXFxfX3wgICAgXFwgXFxfX19fX1xcICBcXCBcXF9cXCBcXF9cXCAgXFwvXFxfX19fX1xcICBcXCBcXF9fX19fXFwgIFxcIFxcX1xcICAgIFxcIFxcX1xcIFxuICAgICAgXFwvX19fX18vICAgXFwvXy8gICAgICBcXC9fX19fXy8gICBcXC9fLyAvXy8gICBcXC9fX19fXy8gICBcXC9fX19fXy8gICBcXC9fLyAgICAgXFwvXy8gXG5cbiAgICBUaGUgbWFpbiBpbnRlcmZhY2UgZm9yIHRoZSBFdmVyeUJpdCBwbGF0Zm9ybS5cblxuICAgIE1vc3QgY2FsbHMgdG8gdGhlIHBsYXRmb3JtIHNob3VsZCBnbyB0aHJvdWdoIGhlcmUsXG4gICAgcmF0aGVyIHRoYW4gYWNjZXNzaW5nIGNvcmUgc3lzdGVtcyBsaWtlIEVCLkRhdGEgYW5kIEVCLkNyeXB0byBkaXJlY3RseS5cblxuICAgIEluIGFkZGl0aW9uIHRvIHRoZSBwdWJsaWMtZmFjaW5nIEFQSSBzb21lIGdlbmVyYWwgaGVscGVyIGZ1bmN0aW9uc1xuICAgIGFyZSBlc3RhYmxpc2hlZCBoZXJlIGZvciB1c2UgYnkgdGhlIGRlZXBlciBsYXllcnMuXG5cbiAgICBDb3B5cmlnaHQgMjAxNC0yMDE1IEV2ZXJ5Qml0LiBTZWUgUkVBRE1FIGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG4qL1xuXG5pZih0eXBlb2YgRUIgPT09ICd1bmRlZmluZWQnKSBFQiA9IHt9ICAgICAgICAgICAgICAgICAgIC8vIHdlIG1pZ2h0IGxvYWQgY29uZmlnLmpzIGZpcnN0XG5pZighRUIuQ09ORklHKSBFQi5DT05GSUcgPSB7fSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIHdlIG1pZ2h0IG5vdFxuXG5FQi5Nb2R1bGVzID0ge30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1cHBsZW1lbnRhcnkgZXh0ZW5zaW9ucyBsaXZlIGhlcmVcbkVCLk0gPSBFQi5Nb2R1bGVzXG5cbkVCLnZlcnNpb24gPSAnMC44LjAnXG5cblxuLy8vLy8vLy8vLy8vLy8gU1RBTkRBUkQgQVBJIEZVTkNUSU9OUyAvLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gTm90ZSB0aGF0IGFsbW9zdCBhbGwgb2YgdGhlIEVCLiogQVBJIGZ1bmN0aW9ucyByZXR1cm4gYSBwcm9taXNlLCB3aXRoIHRoZSBleGNlcHRpb24gb2YgRUIuZm9ybWF0SWRlbnRpdHlGaWxlIGFuZCBFQi5sb2dpbldpdGhJZGVudGl0eUZpbGUuIChUaGUgZmlyZS1hbmQtZm9yZ2V0IGludGVyZmFjZSBob3VzZWQgaW4gdGhpcyBmaWxlIGlzIGFsc28gbm9uLXByb21pc2UtYmFzZWQuKVxuXG5cbi8vLy8gVEhFIEZJUkUgQU5EIEZPUkdFVCBJTlRFUkZBQ0UgRk9SIFJFQ0VJVklORyBNRVNTQUdFU1xuXG4vLyBUaGUgZmlyZS1hbmQtZm9yZ2V0IHN0eWxlIGludGVyZmFjZSwgd2hlcmUgd2UgYXNrIGZvciBhIHB1ZmYgYW5kIGVpdGhlclxuLy8gLSByZWNlaXZlIGl0IGRpcmVjdGx5IGlmIGl0J3MgaW4gdGhlIGNhY2hlLCBvclxuLy8gLSByZWNlaXZlIGZhbHNlLCBidXQgbWVhbndoaWxlIGEgcmVxdWVzdCBpcyBzZW50XG4vLyBUaGlzIGNhbiBiZSBlYXNpZXIgdGhhbiBkZWFsaW5nIHdpdGggcHJvbWlzZXMgd2hlbiBlLmcuIHNob3dpbmcgY2F0IHBob3Rvczpcbi8vIHN0YXJ0IGJ5IHNob3dpbmcgd2hpY2hldmVyIGNhdHMgeW91IGhhdmUgaW4gdGhlIGNhY2hlIGF0IHRoYXQgbW9tZW50LiBcbi8vIFdoZW4gbW9yZSBjYXRzIGFycml2ZSBhIHJlZnJlc2ggaXMgdHJpZ2dlcmVkIGFuZCB0aG9zZSBhZGRpdGlvbmFsIGNhdHMgYXJlIHNob3duIHRvby5cbi8vIElmIHlvdSByZXR1cm4gYSBwcm9taXNlIHRoZW4geW91J2QgaGF2ZSB0byB3YWl0IGZvciAnYWxsIGF2YWlsYWJsZSBjYXRzJyBiZWZvcmUgcmVzb2x2aW5nIGl0LFxuLy8gYnV0IHRoZXJlJ3Mgbm8gd2F5IHRvIGtub3cgd2hlbiB0aGUgbGFzdCBjYXQgaGFzIGFycml2ZWQgLS0gaGFsdGluZyBwcm9ibGVtLlxuXG5cbkVCLkZBRiA9IHt9XG5cbi8qKlxuICogVHJ5IHRvIGdldCBhIHB1ZmYgYnkgaXRzIHNpZyBmcm9tIHRoZSBsb2NhbCBjYWNoZSwgb3IgYXNrIHRoZSBuZXR3b3JrIGFuZCByZXR1cm4gZmFsc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSAgc2lnXG4gKiBAcmV0dXJuIHsocHVmZnxmYWxzZSl9XG4gKi9cbkVCLkZBRi5nZXRQdWZmQnlTaWcgPSBmdW5jdGlvbihzaWcpIHtcbiAgICByZXR1cm4gRUIuRGF0YS5nZXRQdWZmT3JOb3Qoc2lnKVxufVxuXG5cbi8qKlxuICogR2V0IGEgbGlzdCBvZiB0aGUgY3VycmVudCBpZGVudGl0eSdzIGN1cnJlbnRseSBjYWNoZWQgcHVmZnMsIGFuZCBhc2sgdGhlIG5ldHdvcmsgZm9yIG1vcmVcbiAqIEByZXR1cm4ge1twdWZmc119XG4gKi9cbkVCLkZBRi5nZXRNeU1lc3NhZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gZ2V0IGN1cnJlbnQgdXNlcm5hbWVcbiAgICAvLyBhc2sgdGhlIG5ldHdvcmsgZm9yIGFueXRoaW5nIG5ldyBmcm9tIG9yIGZvciBtZVxuICAgIC8vIHJldHVybiB0aGluZ3MgZnJvbSBjYWNoZXNcbn1cblxuXG5cblxuLy8vLyBSRUNFSVZFIE1FU1NBR0VTXG5cblxuLyoqXG4gKiBUcnkgdG8gZ2V0IGEgcGFydGljdWxhciBwdWZmIGJ5IGl0cyBzaWduYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfSAgVGhlIHNpZ25hdHVyZSBvZiBhIHB1ZmZcbiAqIEByZXR1cm4ge3Byb21pc2V9XG4gKi9cbkVCLmdldFB1ZmZCeVNpZyA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHJldHVybiBFQi5EYXRhLmdldFB1ZmZCeVNpZyhzaWcpICAgICAgICAgICAgICAgICAgICAvLyBnZXQgYSBwcm9taXNlIGZvciB0aGUgcHVmZiBmcm9tIGNhY2hlIG9yIG5ldHdvcmtcbn1cblxuXG4vLy8vIFNFTkQgTUVTU0FHRVNcblxuXG4vKipcbiAqIFNlbmQgYSBwdWJsaWMgbWVzc2FnZVxuICogQHBhcmFtIHtzdHJpbmd9ICAgIEEgbWVzc2FnZSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICBPcHRpb25hbCwgZGVmYXVsdHMgdG8gJ3RleHQnXG4gKiBAcmV0dXJuIHtwcm9taXNlfVxuICovXG5FQi5wb3N0UHVibGljTWVzc2FnZSA9IGZ1bmN0aW9uKGNvbnRlbnQsIHR5cGUpIHtcbiAgICB0eXBlID0gdHlwZSB8fCAndGV4dCdcbiAgICBcbiAgICB2YXIgbXlVc2VybmFtZSA9IEVCLmdldEN1cnJlbnRVc2VybmFtZSgpXG4gICAgaWYoIW15VXNlcm5hbWUpXG4gICAgICAgIHJldHVybiBFQi5lbXB0eVByb21pc2UoJ1lvdSBtdXN0IGhhdmUgYSBjdXJyZW50IGlkZW50aXR5IHRvIHBvc3QgYSBwdWJsaWMgbWVzc2FnZScpXG4gICAgXG4gICAgdmFyIHB1ZmYgPSBFQi5QdWZmLnNpbXBsZUJ1aWxkKHR5cGUsIGNvbnRlbnQpXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShFQi5EYXRhLmFkZFB1ZmZUb1N5c3RlbShwdWZmKSlcbn1cblxuXG4vKipcbiAqIFNlbmQgYSBwcml2YXRlIG1lc3NhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICBBIG1lc3NhZ2Ugc3RyaW5nXG4gKiBAcGFyYW0ge2FycmF5fSAgICAgQSBsaXN0IG9mIHVzZXJuYW1lc1xuICogQHBhcmFtIHtzdHJpbmd9ICAgIE9wdGlvbmFsLCBkZWZhdWx0cyB0byAndGV4dCdcbiAqIEByZXR1cm4ge3Byb21pc2V9XG4gKi9cbkVCLnBvc3RQcml2YXRlTWVzc2FnZSA9IGZ1bmN0aW9uKGNvbnRlbnQsIHVzZXJuYW1lcywgdHlwZSkge1xuICAgIHR5cGUgPSB0eXBlIHx8ICd0ZXh0J1xuXG4gICAgdmFyIG15VXNlcm5hbWUgPSBFQi5nZXRDdXJyZW50VXNlcm5hbWUoKVxuICAgIGlmKCFteVVzZXJuYW1lKVxuICAgICAgICByZXR1cm4gRUIuZW1wdHlQcm9taXNlKCdZb3UgbXVzdCBoYXZlIGEgY3VycmVudCBpZGVudGl0eSB0byBwb3N0IGEgcHJpdmF0ZSBtZXNzYWdlJylcbiAgICBcbiAgICB1c2VybmFtZXMgPSB1c2VybmFtZXMgfHwgW11cbiAgICBpZighQXJyYXkuaXNBcnJheSh1c2VybmFtZXMpKVxuICAgICAgICB1c2VybmFtZXMgPSBbdXNlcm5hbWVzXVxuICAgIFxuICAgIHVzZXJuYW1lcy5wdXNoKG15VXNlcm5hbWUpXG4gICAgdXNlcm5hbWVzID0gRUIudW5pcXVpZnkodXNlcm5hbWVzKVxuICAgIHZhciBwcm9tID0gRUIuVXNlcnMudXNlcm5hbWVzVG9Vc2VyUmVjb3Jkc1Byb21pc2UodXNlcm5hbWVzKVxuICAgIFxuICAgIHJldHVybiBwcm9tLnRoZW4oZnVuY3Rpb24odXNlclJlY29yZHMpIHsgICAgICAgIFxuICAgICAgICB2YXIgcHVmZiA9IEVCLlB1ZmYuc2ltcGxlQnVpbGQodHlwZSwgY29udGVudCwgbnVsbCwgdXNlcm5hbWVzLCB1c2VyUmVjb3JkcylcbiAgICAgICAgcmV0dXJuIEVCLkRhdGEuYWRkUHVmZlRvU3lzdGVtKHB1ZmYpXG4gICAgfSlcbiAgICBcbiAgICByZXR1cm4gcHJvbVxufVxuXG5cbi8qKlxuICogU2VuZCBhbiBhbm9ueW1vdXMgcHJpdmF0ZSBtZXNzYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgQSBtZXNzYWdlIHN0cmluZ1xuICogQHBhcmFtIHthcnJheX0gICAgIEEgbGlzdCBvZiB1c2VybmFtZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICBPcHRpb25hbCwgZGVmYXVsdHMgdG8gJ3RleHQnXG4gKiBAcmV0dXJuIHtwcm9taXNlfVxuICovXG5FQi5wb3N0QW5vbnltb3VzUHJpdmF0ZU1lc3NhZ2UgPSBmdW5jdGlvbihjb250ZW50LCB1c2VybmFtZXMsIHR5cGUpIHtcbiAgICByZXR1cm4gRUIuRGF0YS5zZW5kQW5vbk1vZGVQdWZmKGNvbnRlbnQsIHVzZXJuYW1lcywgdHlwZSwgJ2Fub24nKVxufVxuXG5cbi8qKlxuICogU2VuZCBhIHRyYWNlbGVzcyBwcml2YXRlIG1lc3NhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICBBIG1lc3NhZ2Ugc3RyaW5nXG4gKiBAcGFyYW0ge2FycmF5fSAgICAgQSBsaXN0IG9mIHVzZXJuYW1lc1xuICogQHBhcmFtIHtzdHJpbmd9ICAgIE9wdGlvbmFsLCBkZWZhdWx0cyB0byAndGV4dCdcbiAqIEByZXR1cm4ge3Byb21pc2V9XG4gKi9cbkVCLnBvc3RUcmFjZWxlc3NQcml2YXRlTWVzc2FnZSA9IGZ1bmN0aW9uKGNvbnRlbnQsIHVzZXJuYW1lcywgdHlwZSkge1xuICAgIHJldHVybiBFQi5EYXRhLnNlbmRBbm9uTW9kZVB1ZmYoY29udGVudCwgdXNlcm5hbWVzLCB0eXBlLCAnZG91Ymx5YW5vbicpXG59XG5cblxuLy8vLyBJREVOVElUWSBBTkQgVVNFUiBNQU5BR0VNRU5UXG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaWRlbnRpdHlcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICBuZXcgdXNlcm5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICBhIHN0cmluZyBwYXNzcGhyYXNlXG4gKiBAcmV0dXJuIHtwcm9taXNlfSAgdXNlclJlY29yZCBmb3IgdGhlIG5ld2x5IGNyZWF0ZWQgdXNlclxuICovXG5FQi5jcmVhdGVJZGVudGl0eSA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBwYXNzcGhyYXNlKSB7XG4gICAgLy8gVE9ETzogdmFsaWRhdGlvbnMgYW5kIGVycm9yIGhhbmRsaW5nIChsb3RzIG9mIGl0KVxuICAgIFxuICAgIHZhciBwcmVwZW5kZWRQYXNzcGhyYXNlID0gdXNlcm5hbWUgKyBwYXNzcGhyYXNlXG4gICAgICAgIHZhciBwcml2YXRlS2V5ID0gRUIuQ3J5cHRvLnBhc3NwaHJhc2VUb1ByaXZhdGVLZXlXaWYocHJlcGVuZGVkUGFzc3BocmFzZSlcbiAgICBcbiAgICB2YXIgcHJvbSA9IEVCLnJlZ2lzdGVyVG9wTGV2ZWxVc2VyKHVzZXJuYW1lLCBwcml2YXRlS2V5LCBwcml2YXRlS2V5LCBwcml2YXRlS2V5KVxuICAgIFxuICAgIHByb20udGhlbihmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgICAgIHZhciBjYXBhID0gMSAvLyBUSElOSzogZG9lcyBjYXBhIGFsd2F5cyBzdGFydCBhdCAxPyB3aGVyZSBzaG91bGQgdGhhdCBrbm93bGVkZ2UgbGl2ZT9cbiAgICAgICAgRUIuYWRkQWxpYXModXNlcm5hbWUsIHVzZXJuYW1lLCBjYXBhLCBwcml2YXRlS2V5LCBwcml2YXRlS2V5LCBwcml2YXRlS2V5LCB7cGFzc3BocmFzZTogcGFzc3BocmFzZX0pXG4gICAgICAgIEVCLnN3aXRjaElkZW50aXR5VG8odXNlcm5hbWUpXG4gICAgfSlcbiAgICBcbiAgICAvLyBUT0RPOiBvbiBzd2l0Y2hJZGVudGl0eVRvIGZhbHNlIGNoYW5nZSB1bmRlZmluZWQgdG8gJydcbiAgICBcbiAgICByZXR1cm4gcHJvbVxufVxuXG5cbi8qKlxuICogUmVnaXN0ZXIgYSBuZXcgdG9wLWxldmVsIHVzZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgbmV3IHVzZXJuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgIG5ldyBwcml2YXRlIHJvb3Qga2V5XG4gKiBAcGFyYW0ge3N0cmluZ30gICAgIG5ldyBwcml2YXRlIGFkbWluIGtleVxuICogQHBhcmFtIHtzdHJpbmd9ICAgICBuZXcgcHJpdmF0ZSBkZWZhdWx0IGtleVxuICogQHJldHVybiB7cHJvbWlzZX0gICB1c2VyUmVjb3JkIGZvciB0aGUgbmV3bHkgY3JlYXRlZCB1c2VyXG4gKi9cbkVCLnJlZ2lzdGVyVG9wTGV2ZWxVc2VyID0gZnVuY3Rpb24odXNlcm5hbWUsIHByaXZhdGVSb290S2V5LCBwcml2YXRlQWRtaW5LZXksIHByaXZhdGVEZWZhdWx0S2V5KSB7XG4gICAgLy8gT1BUOiBwcml2YXRlVG9QdWJsaWMgaXMgZXhwZW5zaXZlIC0tIHdlIGNvdWxkIHJlZHVjZSB0aGUgbnVtYmVyIG9mIGNhbGxzIGlmIHRoZSBwcml2YXRlIGtleXMgYXJlIGlkZW50aWNhbFxuICAgIHZhciByb290S2V5ICAgID0gRUIuQ3J5cHRvLnByaXZhdGVUb1B1YmxpYyhwcml2YXRlUm9vdEtleSlcbiAgICB2YXIgYWRtaW5LZXkgICA9IEVCLkNyeXB0by5wcml2YXRlVG9QdWJsaWMocHJpdmF0ZUFkbWluS2V5KVxuICAgIHZhciBkZWZhdWx0S2V5ID0gRUIuQ3J5cHRvLnByaXZhdGVUb1B1YmxpYyhwcml2YXRlRGVmYXVsdEtleSlcblxuICAgIHZhciBwdWZmID0gRUIuUHVmZi5idWlsZFVzZXJSZWdpc3RyYXRpb24odXNlcm5hbWUsIHByaXZhdGVBZG1pbktleSwgdXNlcm5hbWUsIHJvb3RLZXksIGFkbWluS2V5LCBkZWZhdWx0S2V5KVxuICAgIHZhciBwcm9tID0gRUIuTmV0LnVwZGF0ZVVzZXJSZWNvcmQocHVmZilcbiAgICBcbiAgICByZXR1cm4gcHJvbVxufVxuXG5cbi8qKlxuICogUmVnaXN0ZXIgYSBzdWJ1c2VyIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBpZGVudGl0eVxuICogQHBhcmFtICB7c3RyaW5nfSAgICBkZXNpcmVkIG5ldyBzdWJ1c2VyIG5hbWVcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgcHVibGljIHJvb3Qga2V5IGZvciB0aGUgbmV3IHN1YnVzZXJcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgcHVibGljIGFkbWluIGtleSBmb3IgdGhlIG5ldyBzdWJ1c2VyXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgIHB1YmxpYyBkZWZhdWx0IGtleSBmb3IgdGhlIG5ldyBzdWJ1c2VyXG4gKiBAcmV0dXJuIHtwcm9taXNlfSAgIHVzZXJSZWNvcmQgZm9yIHRoZSBuZXdseSBjcmVhdGVkIHN1YnVzZXJcbiAqL1xuRUIucmVnaXN0ZXJTdWJ1c2VyID0gZnVuY3Rpb24obmV3VXNlcm5hbWUsIHJvb3RLZXksIGFkbWluS2V5LCBkZWZhdWx0S2V5KSB7XG4gICAgdmFyIHNpZ25pbmdVc2VybmFtZSA9IEVCLmdldEN1cnJlbnRVc2VybmFtZSgpXG4gICAgdmFyIHByb21cbiAgICBcbiAgICBFQi51c2VTZWN1cmVJbmZvKGZ1bmN0aW9uKF8sIF8sIF8sIHByaXZhdGVBZG1pbktleSwgXykge1xuICAgICAgICBwcm9tID0gRUIuVXNlcnMucmVnaXN0ZXJTdWJ1c2VyRm9yVXNlcihzaWduaW5nVXNlcm5hbWUsIHByaXZhdGVBZG1pbktleSwgbmV3VXNlcm5hbWUsIHJvb3RLZXksIGFkbWluS2V5LCBkZWZhdWx0S2V5KVxuICAgIH0pXG4gICAgXG4gICAgcmV0dXJuIHByb21cbn1cblxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHVwZGF0ZSBhIHByaXZhdGUga2V5IGZvciB0aGUgY3VycmVudCB1c2VyXG4gKiBJZiBzdWNjZXNzZnVsIGl0IGFkZHMgdGhlIG5ldyBhbGlhcyB0byB0aGUgY3VycmVudCBpZGVudGl0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgJ2RlZmF1bHRLZXknLCAnYWRtaW5LZXknLCBvciAncm9vdEtleSdcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgdGhlIG5ldyBwcml2YXRlIGtleVxuICogQHBhcmFtIHtzdHJpbmd9ICAgICBzZWNyZXQgaW5mb3JtYXRpb24gdG8gaW5jbHVkZSBpbiB0aGUgdXNlclJlY29yZFxuICogQHJldHVybiB7cHJvbWlzZX0gICB0aGUgbmV3IHVzZXJSZWNvcmRcbiAqL1xuRUIudXBkYXRlUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKGtleVRvTW9kaWZ5LCBuZXdQcml2YXRlS2V5LCBzZWNyZXRzKSB7ICAgIFxuICAgIHZhciB1c2VybmFtZSA9IEVCLmdldEN1cnJlbnRVc2VybmFtZSgpXG4gICAgdmFyIG5ld1B1YmxpY0tleSA9IEVCLkNyeXB0by5wcml2YXRlVG9QdWJsaWMobmV3UHJpdmF0ZUtleSlcblxuICAgIGlmKFsnZGVmYXVsdEtleScsICdhZG1pbktleScsICdyb290S2V5J10uaW5kZXhPZihrZXlUb01vZGlmeSkgPT0gLTEpXG4gICAgICAgIHJldHVybiBFQi5lbXB0eVByb21pc2UoJ1RoYXQgaXMgbm90IGEgdmFsaWQga2V5IHRvIG1vZGlmeScpXG5cbiAgICB2YXIgcGF5bG9hZCA9IHt9XG4gICAgdmFyIHJvdXRlcyAgPSBbXVxuICAgIHZhciBjb250ZW50ID0gJ21vZGlmeVVzZXJLZXknXG4gICAgdmFyIHR5cGUgICAgPSAndXBkYXRlVXNlclJlY29yZCdcblxuICAgIHBheWxvYWQua2V5VG9Nb2RpZnkgPSBrZXlUb01vZGlmeVxuICAgIHBheWxvYWQubmV3S2V5ID0gbmV3UHVibGljS2V5XG4gICAgcGF5bG9hZC50aW1lID0gRGF0ZS5ub3coKVxuXG4gICAgdmFyIHByb20gPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHB1ZmYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgdXNlIHRoaXMgdmFyIHRvIHJldHVybiBwdWJsaWNseSBhY2Nlc3NpYmxlIGRhdGEgXG5cbiAgICAgICAgRUIudXNlU2VjdXJlSW5mbyhmdW5jdGlvbihfLCBfLCBwcml2YXRlUm9vdEtleSwgcHJpdmF0ZUFkbWluS2V5LCBwcml2YXRlRGVmYXVsdEtleSkge1xuICAgICAgICAgICAgdmFyIHNpZ25pbmdVc2VyS2V5ID0gJ3ByaXZhdGVSb290S2V5JyAgICAgICAvLyBjaGFuZ2luZyBhZG1pbiBvciByb290IGtleXMgcmVxdWlyZXMgcm9vdCBwcml2aWxlZ2VzXG4gICAgICAgICAgICB2YXIgcHJpdmF0ZUtleSA9IHByaXZhdGVSb290S2V5XG5cbiAgICAgICAgICAgIGlmIChrZXlUb01vZGlmeSA9PSAnZGVmYXVsdEtleScpIHsgXG4gICAgICAgICAgICAgICAgc2lnbmluZ1VzZXJLZXkgPSAncHJpdmF0ZUFkbWluS2V5JyAgICAgIC8vIGNoYW5naW5nIHRoZSBkZWZhdWx0IGtleSBvbmx5IHJlcXVpcmVzIGFkbWluIHByaXZpbGVnZXNcbiAgICAgICAgICAgICAgICBwcml2YXRlS2V5ID0gcHJpdmF0ZUFkbWluS2V5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChFQi5tYWtlRXJyb3IoXCJZb3UgbmVlZCB0aGUgXCIgKyBzaWduaW5nVXNlcktleSArIFwiIHRvIGNoYW5nZSB0aGUgXCIgKyBrZXlUb01vZGlmeSArIFwiIGtleS5cIikpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHB1ZmYgPSBFQi5QdWZmLmJ1aWxkKHVzZXJuYW1lLCBwcml2YXRlS2V5LCByb3V0ZXMsIHR5cGUsIGNvbnRlbnQsIHBheWxvYWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgdmFyIHVzZXJSZWNvcmRQcm9taXNlID0gRUIuTmV0LnVwZGF0ZVVzZXJSZWNvcmQocHVmZilcblxuICAgICAgICB1c2VyUmVjb3JkUHJvbWlzZS50aGVuKGZ1bmN0aW9uKHVzZXJSZWNvcmQpIHtcbiAgICAgICAgICAgIGlmKGtleVRvTW9kaWZ5ID09ICdkZWZhdWx0S2V5Jykge1xuICAgICAgICAgICAgICAgIEVCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oXywgdXNlcm5hbWUsIHByaXZhdGVSb290S2V5LCBwcml2YXRlQWRtaW5LZXksIF8pIHtcbiAgICAgICAgICAgICAgICAgICAgRUIuYWRkQWxpYXModXNlcm5hbWUsIHVzZXJuYW1lLCB1c2VyUmVjb3JkLmNhcGEsIHByaXZhdGVSb290S2V5LCBwcml2YXRlQWRtaW5LZXksIG5ld1ByaXZhdGVLZXksIHNlY3JldHMpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoa2V5VG9Nb2RpZnkgPT0gJ2FkbWluS2V5Jykge1xuICAgICAgICAgICAgICAgIEVCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oXywgdXNlcm5hbWUsIHByaXZhdGVSb290S2V5LCBfLCBwcml2YXRlRGVmYXVsdEtleSkge1xuICAgICAgICAgICAgICAgICAgICBFQi5hZGRBbGlhcyh1c2VybmFtZSwgdXNlcm5hbWUsIHVzZXJSZWNvcmQuY2FwYSwgcHJpdmF0ZVJvb3RLZXksIG5ld1ByaXZhdGVLZXksIHByaXZhdGVEZWZhdWx0S2V5LCBzZWNyZXRzKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGtleVRvTW9kaWZ5ID09ICdyb290S2V5Jykge1xuICAgICAgICAgICAgICAgIEVCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oXywgdXNlcm5hbWUsIF8sIHByaXZhdGVBZG1pbktleSwgcHJpdmF0ZURlZmF1bHRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgRUIuYWRkQWxpYXModXNlcm5hbWUsIHVzZXJuYW1lLCB1c2VyUmVjb3JkLmNhcGEsIG5ld1ByaXZhdGVLZXksIHByaXZhdGVBZG1pbktleSwgIHByaXZhdGVEZWZhdWx0S2V5LCBzZWNyZXRzKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHVzZXJSZWNvcmQpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoRUIubWFrZUVycm9yKGVycikpXG4gICAgICAgIH0pXG4gICAgfSlcblxuICAgIHJldHVybiBwcm9tXG59XG5cblxuLyoqXG4gKiBUcnkgdG8gZ2V0IGEgdXNlcidzIHByb2ZpbGUgcHVmZlxuICogQHBhcmFtIHtzdHJpbmd9ICBUaGUgdXNlcm5hbWVcbiAqIEByZXR1cm4ge3Byb21pc2V9XG4gKi9cbkVCLmdldFByb2ZpbGVQdWZmID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICB2YXIgY2FjaGVkX3Byb2ZpbGUgPSBFQi5EYXRhLnByb2ZpbGVzW3VzZXJuYW1lXVxuICAgIFxuICAgIGlmKGNhY2hlZF9wcm9maWxlKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZF9wcm9maWxlKVxuXG4gICAgdmFyIHByb20gPSBFQi5OZXQuZ2V0UHJvZmlsZVB1ZmYodXNlcm5hbWUpXG5cbiAgICBwcm9tID0gcHJvbS50aGVuKGZ1bmN0aW9uKHB1ZmZzKSB7XG4gICAgICAgIHZhciBwdWZmID0gcHVmZnNbMF1cbiAgICBcbiAgICAgICAgLy8gTk9URTogU2V0dGluZyB0aGlzIHByZXZlbnRzIHVzIGZyb20gcmUtdHJ5aW5nIHRvIGNvbGxlY3QgcHJvZmlsZXMgZnJvbSB1c2VycyB3aG8gZG9uJ3QgaGF2ZSB0aGVtLlxuICAgICAgICAvLyAgICAgICBUaGlzIGlzIGdvb2QsIGJlY2F1c2UgaXQgcHJldmVudHMgbmV0d29yayBub2lzZSwgYnV0IHJlcXVpcmVzIGEgcmVmcmVzaCB0byBzZWUgbmV3IHByb2ZpbGUgaW5mby5cbiAgICAgICAgaWYoIXB1ZmYpXG4gICAgICAgICAgICBwdWZmID0ge3BheWxvYWQ6e319IC8vIFRPRE86IGdldCBhIHByb3BlciBlbXB0eSBwdWZmIGZyb20gc29tZXdoZXJlXG4gICAgICAgIFxuICAgICAgICBFQi5EYXRhLnByb2ZpbGVzW0VCLlVzZXJzLmp1c3RVc2VybmFtZShwdWZmLnVzZXJuYW1lIHx8IHVzZXJuYW1lKV0gPSBwdWZmXG4gICAgXG4gICAgICAgIHJldHVybiBwdWZmXG4gICAgfSlcblxuICAgIHJldHVybiBwcm9tXG59XG5cblxuLy8vLyBMT0dJTiAmIElEIEZJTEUgTUFOQUdFTUVOVFxuXG5cbi8qKlxuICogTWFrZSBhbiBpZGVudGl0eSB0aGUgY3VycmVudCBvbmVcbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG1haW4gdXNlcm5hbWUgZm9yIHRoZSBpZGVudGl0eVxuICogQHBhcmFtIHtzdHJpbmd9ICAgdGhlIGtleSBmb3IgdGhlIHVzZXIncyBpZGVudGl0eSBmaWxlXG4gKiBAcmV0dXJuIHtwcm9taXNlfVxuICovXG5FQi5sb2dpbiA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBwcml2YXRlS2V5KSB7XG4gICAgLy8gVE9ETzogaGFuZGxlIG9mZmxpbmUgY2FzZS4uLlxuICAgIC8vIFRPRE86IGVuY3J5cHRlZCBsb2NhbFN0b3JhZ2UgaWRlbnRpdHkgZmlsZXNcbiAgICAvLyBUT0RPOiBjYWNoZSBlbmNyeXB0ZWQgcHVmZnMgaW4gbG9jYWxTdG9yYWdlXG4gICAgLy8gVE9ETzogZ3JhYiB0aGUgdXNlciByZWNvcmQgZnJvbSBFQi5sb2dpbldpdGhQYXNzcGhyYXNlXG4gICAgXG4gICAgdXNlcnByb20gPSBFQi5Vc2Vycy5nZXRVc2VyUmVjb3JkTm9DYWNoZSh1c2VybmFtZSlcbiAgICBcbiAgICByZXR1cm4gdXNlcnByb20udGhlbihmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgICAgIGlmKCF1c2VyUmVjb3JkKVxuICAgICAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ0NvdWxkIG5vdCBhY2Nlc3MgdXNlciByZWNvcmQnKVxuICAgICAgICBcbiAgICAgICAgdmFyIGlkZW50aXR5U2lnID0gdXNlclJlY29yZC5pZGVudGl0eVxuICAgICAgICBcbiAgICAgICAgaWYoaWRlbnRpdHlTaWcpIHtcbiAgICAgICAgICAgIHZhciBkZWNyeXB0cHJvbSA9IEVCLlVzZXJzLmdldElkZW50aXR5UHVmZih1c2VyUmVjb3JkLCBwcml2YXRlS2V5KVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gZGVjcnlwdHByb20udGhlbihmdW5jdGlvbihsZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZihsZXR0ZXIgJiYgbGV0dGVyLnBheWxvYWQgJiYgbGV0dGVyLnBheWxvYWQuY29udGVudClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVCLmxvZ2luV2l0aElkZW50aXR5RmlsZShsZXR0ZXIucGF5bG9hZC5jb250ZW50KVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVCLnRocm93RXJyb3IoJ0ludmFsaWQgcGFzc3dvcmQnKSAvLyBUSElOSzogdGhpcyBjb3VsZCBoYXBwZW4gZm9yIG90aGVyIHJlYXNvbnNcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBFQi5jYXRjaEVycm9yKCdDb3VsZCBub3QgYWNjZXNzIGlkZW50aXR5IGZpbGUnKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gbm8gaWRlbnRpdHkgcHVmZiwgc28gdHJ5IGl0IHRoZSBvbGQgZmFzaGlvbmVkIHdheVxuICAgICAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgaW50byBhIGhlbHBlciBmdW5jdGlvblxuICAgICAgICB2YXIgcHVibGljS2V5ID0gRUIuQ3J5cHRvLnByaXZhdGVUb1B1YmxpYyhwcml2YXRlS2V5KVxuICAgICAgICBcbiAgICAgICAgaWYoICh1c2VyUmVjb3JkLmRlZmF1bHRLZXkgIT0gcHVibGljS2V5KSBcbiAgICAgICAgICYmICh1c2VyUmVjb3JkLmFkbWluS2V5ICAgIT0gcHVibGljS2V5KSBcbiAgICAgICAgICYmICh1c2VyUmVjb3JkLnJvb3RLZXkgICAgIT0gcHVibGljS2V5KSApXG4gICAgICAgICAgICByZXR1cm4gRUIub25FcnJvcignVGhhdCB1c2VyIHJlY29yZCBoYXMgbm8gaWRlbnRpdHkgZmlsZSwgYW5kIHRoZSBwdWJsaWMga2V5IHByb3ZpZGVkIGRvZXMgbm90IG1hdGNoJylcbiAgICBcbiAgICAgICAgdmFyIHNlY3JldHMgPSB7fSAvLyB7cGFzc3BocmFzZTogcGFzc3BocmFzZX0gLy8gVEhJTks6IG1heWJlIG1vdmUgdGhpcyB1cCBhIGxldmVsIHRvIGxvZ2luV2l0aFBhc3NwaHJhc2VcbiAgICAgICAgRUIuYWRkQWxpYXModXNlcm5hbWUsIHVzZXJuYW1lLCB1c2VyUmVjb3JkLmNhcGEsIHByaXZhdGVLZXksIHByaXZhdGVLZXksIHByaXZhdGVLZXksIHNlY3JldHMpXG5cbiAgICAgICAgRUIuc3dpdGNoSWRlbnRpdHlUbyh1c2VybmFtZSlcbiAgICAgICAgXG4gICAgICAgIEVCLnN0b3JlSWRlbnRpdHlGaWxlSW5DbG91ZCgpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG59XG5cblxuLyoqXG4gKiBUYWtlcyBhIGNhbm9uaWNhbCBpZGVudGl0eSBmaWxlIG9iamVjdCwgYWRkcyBpdCB0byB0aGUgd2FyZHJvYmUsIGFuZCBzaWducyB5b3UgaW5cbiAqIEBwYXJhbSB7b2JqZWN0fSBJZGVudGl0eSBmaWxlXG4gKiBAcmV0dXJuIFxuICovXG5FQi5sb2dpbldpdGhJZGVudGl0eUZpbGUgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgdXNlcm5hbWUgPSBvYmplY3QudXNlcm5hbWVcbiAgICB2YXIgYWxpYXNlcyAgPSBvYmplY3QuYWxpYXNlc1xuICAgIHZhciBwcmVmZXJlbmNlcyA9IG9iamVjdC5wcmVmZXJlbmNlc1xuICAgIFxuICAgIGlmKCF1c2VybmFtZSB8fCAhYWxpYXNlcyB8fCAhcHJlZmVyZW5jZXMpXG4gICAgICAgIHJldHVybiBFQi5vbkVycm9yKCdUaGF0IGlzIG5vdCBhIHZhbGlkIGlkZW50aXR5IG9iamVjdCcpXG4gICAgXG4gICAgRUIuY3VycmVudElkZW50aXR5SGFzaCA9IEVCLkNyeXB0by5jcmVhdGVNZXNzYWdlSGFzaChKU09OLnN0cmluZ2lmeShvYmplY3QpKVxuICAgIFxuICAgIEVCLmFkZElkZW50aXR5KHVzZXJuYW1lLCBhbGlhc2VzLCBwcmVmZXJlbmNlcylcbiAgICBcbiAgICByZXR1cm4gRUIuc3dpdGNoSWRlbnRpdHlUbyh1c2VybmFtZSlcbn1cblxuXG4vKipcbiAqIFRyeSB0byBhY2Nlc3MgdGhlIHN5c3RlbSB3aXRoIGEgdXNlcm5hbWUvcGFzc3BocmFzZSBjb21ib1xuICogQHBhcmFtIHtzdHJpbmd9ICAgSWRlbnRpdHkncyBwcmltYXJ5IHVzZXJuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gICBQYXNzcGhyYXNlIHRvIHVubG9jayB0aGUgaWRlbnRpdHkgZmlsZVxuICogQHBhcmFtIHtzdHJpbmd9ICAgVXNlZCBpbnRlcm5hbGx5XG4gKiBAcmV0dXJuIHtwcm9taXNlfVxuICovXG5FQi5sb2dpbldpdGhQYXNzcGhyYXNlID0gZnVuY3Rpb24odXNlcm5hbWUsIHBhc3NwaHJhc2UsIGxlZ2FjeSkge1xuICAgIC8vIEZpcnN0IGF0dGVtcHQgdG8gcHJlcGVuZCB1c2VybmFtZSB0byBwYXNzcGhyYXNlXG4gICAgLy8gSWYgdGhhdCBmYWlscyB0aGVuIHRyeSBqdXN0IHVzaW5nIHRoZSBwYXNzcGhyYXNlXG4gICAgdmFyIHBhc3MgPSBsZWdhY3kgPyBwYXNzcGhyYXNlIDogdXNlcm5hbWUgKyBwYXNzcGhyYXNlXG5cbiAgICB2YXIgcHJpdmF0ZUtleSA9IEVCLkNyeXB0by5wYXNzcGhyYXNlVG9Qcml2YXRlS2V5V2lmKHBhc3MpXG4gICAgdmFyIHB1YmxpY0tleSA9IEVCLkNyeXB0by5wcml2YXRlVG9QdWJsaWMocHJpdmF0ZUtleSlcblxuICAgIHZhciB1c2VycHJvbSA9IEVCLlVzZXJzLmdldFVzZXJSZWNvcmROb0NhY2hlKHVzZXJuYW1lKVxuXG4gICAgcmV0dXJuIHVzZXJwcm9tLnRoZW4oZnVuY3Rpb24odXNlclJlY29yZCkge1xuICAgICAgICBpZighdXNlclJlY29yZClcbiAgICAgICAgICAgIHJldHVybiBFQi5vbkVycm9yKCdDb3VsZCBub3QgYWNjZXNzIHVzZXIgcmVjb3JkJylcbiAgICAgICAgXG4gICAgICAgIGlmKCAodXNlclJlY29yZC5kZWZhdWx0S2V5ICE9IHB1YmxpY0tleSkgXG4gICAgICAgICAmJiAodXNlclJlY29yZC5hZG1pbktleSAgICE9IHB1YmxpY0tleSkgXG4gICAgICAgICAmJiAodXNlclJlY29yZC5yb290S2V5ICAgICE9IHB1YmxpY0tleSkgKVxuICAgICAgICAgICAgcmV0dXJuIChsZWdhY3kpID8gZmFsc2UgOiBFQi5sb2dpbldpdGhQYXNzcGhyYXNlKHVzZXJuYW1lLCBwYXNzcGhyYXNlLCB0cnVlKVxuXG4gICAgICAgIHJldHVybiBFQi5sb2dpbih1c2VybmFtZSwgcHJpdmF0ZUtleSlcbiAgICB9KVxufVxuXG5cbi8qKlxuICogU3RvcmUgdGhlIGN1cnJlbnQgaWRlbnRpdHkncyBpZGVudGl0eSBmaWxlIGluIHRoZSBjbG91ZFxuICogQHJldHVybiB7cHJvbWlzZX1cbiAqL1xuRUIuc3RvcmVJZGVudGl0eUZpbGVJbkNsb3VkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYoIUVCLmN1cnJlbnRJZGVudGl0eUhhc2gpIHtcbiAgICAgICAgLy8gVEhJTks6IHVzZXIgZGlkIG5vdCBsb2cgaW4gd2l0aCBpZGVudGl0eSBmaWxlLi4uIHNvIHdoYXQgc2hvdWxkIHdlIGRvIGhlcmU/XG4gICAgfVxuXG4gICAgLy8gZ2V0IGlkZW50aXR5IGZpbGVcbiAgICB2YXIgY29udGVudCA9IEVCLmZvcm1hdElkZW50aXR5RmlsZSgpXG4gICAgaWYoIWNvbnRlbnQpIHJldHVybiBmYWxzZVxuICAgIFxuICAgIC8vIGNoZWNrIGFnYWluc3QgbGF0ZXN0XG4gICAgdmFyIG5ld0lkZW50aXR5SGFzaCA9IEVCLkNyeXB0by5jcmVhdGVNZXNzYWdlSGFzaChKU09OLnN0cmluZ2lmeShjb250ZW50KSlcbiAgICBpZihFQi5jdXJyZW50SWRlbnRpdHlIYXNoID09IG5ld0lkZW50aXR5SGFzaCkgcmV0dXJuIGZhbHNlXG4gICAgRUIuY3VycmVudElkZW50aXR5SGFzaCA9IG5ld0lkZW50aXR5SGFzaFxuICAgIFxuICAgIC8vIHBhY2thZ2UgYXMgZW5jcnlwdGVkIHB1ZmZcbiAgICB2YXIgcGF5bG9hZCA9IHt9XG4gICAgdmFyIHJvdXRlcyAgPSBbXVxuICAgIHZhciB0eXBlICAgID0gJ2lkZW50aXR5J1xuICAgICAgICBcbiAgICB2YXIgdXNlclJlY29yZCA9IEVCLmdldEN1cnJlbnRVc2VyUmVjb3JkKClcbiAgICB2YXIgdXNlclJlY29yZHNGb3JXaG9tVG9FbmNyeXB0ID0gW3VzZXJSZWNvcmRdXG5cbiAgICBpZighdXNlclJlY29yZCkgcmV0dXJuIGZhbHNlXG5cbiAgICAvLyBUSElOSzogdXNpbmcgc2ltcGxlQnVpbGRQdWZmIHB1dHMgYSB0aW1lc3RhbXAgaW4gdGhlIGlkZW50aXR5IGZpbGUuLi5cbiAgICB2YXIgcHVmZiA9IEVCLlB1ZmYuc2ltcGxlQnVpbGQodHlwZSwgY29udGVudCwgcGF5bG9hZCwgcm91dGVzLCB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHQpXG4gICAgXG4gICAgaWYoIXB1ZmYpIHJldHVybiBmYWxzZVxuICAgICAgICBcbiAgICAvLyBpZihwdWZmLnNpZyA9PSB1c2VyUmVjb3JkLmlkZW50aXR5KSByZXR1cm4gZmFsc2UgLy8gYWx3YXlzIGZhbHNlLCBiZWNhdXNlIG9mIHRoZSB0aW1lc3RhbXAgLS0gaWYgeW91IHJlbW92ZSBpdCwgYWRkIHRoaXMgYmFja1xuICAgIFxuICAgIEVCLk5ldC5kaXN0cmlidXRlUHVmZihwdWZmKSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZW5kIGl0IHRvIHRoZSBzZXJ2ZXJcbiAgICBcbiAgICAvLyB1cGRhdGUgdXNlciByZWNvcmRcbiAgICB2YXIgcGF5bG9hZCA9IHt9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogdGhlIGRvdWJsZSBcInZhclwicyBkb24ndCBodXJ0LCBhbmQgaGVscCBrZWVwIHVzIGZvY3VzZWRcbiAgICB2YXIgcm91dGVzICA9IFtdXG4gICAgdmFyIHR5cGUgICAgPSAndXBkYXRlVXNlclJlY29yZCdcbiAgICB2YXIgY29udGVudCA9ICdzZXRJZGVudGl0eSdcbiAgICB2YXIgdXBkYXRlX3B1ZmZcblxuICAgIHBheWxvYWQuaWRlbnRpdHkgPSBwdWZmLnNpZ1xuXG4gICAgRUIudXNlU2VjdXJlSW5mbyhmdW5jdGlvbihfLCBjdXJyZW50VXNlcm5hbWUsIF8sIHByaXZhdGVBZG1pbktleSwgXykge1xuICAgICAgICBpZighcHJpdmF0ZUFkbWluS2V5KVxuICAgICAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ1lvdSBtdXN0IGhhdmUgYW4gYWRtaW5pc3RyYXRpdmUga2V5IHRvIHVwbG9hZCB5b3VyIGlkZW50aXR5IGZpbGUnKVxuICAgICAgICBcbiAgICAgICAgdXBkYXRlX3B1ZmYgPSBFQi5QdWZmLmJ1aWxkKGN1cnJlbnRVc2VybmFtZSwgcHJpdmF0ZUFkbWluS2V5LCByb3V0ZXMsIHR5cGUsIGNvbnRlbnQsIHBheWxvYWQpXG4gICAgfSlcbiAgICBcbiAgICBpZighdXBkYXRlX3B1ZmYpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIFxuICAgIHZhciB1cGRhdGVfcHJvbSA9IEVCLk5ldC51cGRhdGVVc2VyUmVjb3JkKHVwZGF0ZV9wdWZmKVxuICAgICAgICBcbiAgICByZXR1cm4gdXBkYXRlX3Byb21cbn1cblxuXG4vKipcbiAqIFRyeSB0byBnZXQgYW4gaWRlbnRpdHkgZmlsZSBhbmQgZm9ybWF0IGl0IGNvcnJlY3RseVxuICogQHBhcmFtIHtzdHJpbmd9IElkZW50aXR5J3MgcHJpbWFyeSB1c2VybmFtZVxuICogQHJldHVybiB7KG9iamVjdHxmYWxzZSl9XG4gKi9cbkVCLmZvcm1hdElkZW50aXR5RmlsZSA9IGZ1bmN0aW9uKHVzZXJuYW1lKSB7XG4gICAgLy8gVEhJTks6IGNvbnNpZGVyIHBhc3NwaHJhc2UgcHJvdGVjdGluZyB0aGUgaWRlbnRpdHkgZmlsZSBieSBkZWZhdWx0XG4gICAgLy8gVE9ETzogYWRkIGF1dGhGcm9tSWRGaWxlIC0tIG5lZWQgY29uc2lzdGVuY3kgYm90aCB3YXlzXG4gICAgXG4gICAgdXNlcm5hbWUgPSB1c2VybmFtZSB8fCBFQi5nZXRDdXJyZW50VXNlcm5hbWUoKVxuICAgIFxuICAgIGlmKCF1c2VybmFtZSkgcmV0dXJuIGZhbHNlXG5cbiAgICB2YXIgaWRGaWxlID0ge31cblxuICAgIEVCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oaWRlbnRpdGllcywgY3VycmVudFVzZXJuYW1lLCBwcml2YXRlUm9vdEtleSwgcHJpdmF0ZUFkbWluS2V5LCBwcml2YXRlRGVmYXVsdEtleSkge1xuICAgICAgICAvLyB0aGlzIGxlYWtzIGFsbCBvZiB0aGUgaWRlbnRpdHkgaW5mb3JtYXRpb24gYmFjayB0byB0aGUgY2FsbGVyXG4gICAgICAgIC8vIGlmIHdlIHBhc3NwaHJhc2UgcHJvdGVjdCB0aGUgZmlsZSwgZG8gaXQgaGVyZSB0byBwcmV2ZW50IHRoYXQgbGVha2FnZVxuXG4gICAgICAgIHZhciBpZGVudGl0eSA9IGlkZW50aXRpZXNbdXNlcm5hbWVdXG5cbiAgICAgICAgLy8gYXNzZW1ibGUgaWRGaWxlIG1hbnVhbGx5IHRvIGtlZXAgZXZlcnl0aGluZyBpbiB0aGUgcmlnaHQgb3JkZXJcbiAgICAgICAgLy8gaWRGaWxlLmNvbW1lbnQgPSBcIlRoaXMgZmlsZSBjb250YWlucyB5b3VyIHByaXZhdGUgcGFzc3BocmFzZS4gVGhlIGluZm9ybWF0aW9uIGhlcmUgY2FuIGJlIHVzZWQgdG8gbG9naW4gdG8gd2Vic2l0ZXMgb24gdGhlIEV2ZXJ5Qml0IHBsYXRmb3JtLiBLZWVwIHRoaXMgZmlsZSBzYWZlIGFuZCBzZWN1cmUhXCJcblxuICAgICAgICBpZEZpbGUudXNlcm5hbWUgPSB1c2VybmFtZVxuICAgICAgICAvLyBpZEZpbGUucHJpbWFyeSAgPSBpZGVudGl0eS5wcmltYXJ5IC8vIE5PVEU6IHByaW1hcnkgaXMgYXV0b21hdGljYWxseSBnYXRoZXJlZCBmcm9tIGFsaWFzZXNcbiAgICAgICAgaWRGaWxlLmFsaWFzZXMgID0gaWRlbnRpdHkuYWxpYXNlc1xuICAgICAgICBpZEZpbGUucHJlZmVyZW5jZXMgPSBpZGVudGl0eS5wcmVmZXJlbmNlc1xuICAgICAgICBpZEZpbGUudmVyc2lvbiAgPSBcIjEuMVwiXG4gICAgfSlcblxuICAgIHJldHVybiBpZEZpbGVcbn1cblxuLy8vLyBFTkQgU1RBTkRBUkQgQVBJIC8vLy9cblxuXG5cblxuXG4vLy8vIFNFQ1VSRSBJTkZPUk1BVElPTiBJTlRFUkZBQ0VcblxuRUIuaW1wbGVtZW50U2VjdXJlSW50ZXJmYWNlID0gZnVuY3Rpb24odXNlU2VjdXJlSW5mbywgYWRkSWRlbnRpdHksIGFkZEFsaWFzLCBzZXRQcmltYXJ5QWxpYXMsIHNldFByZWZlcmVuY2UsIHN3aXRjaElkZW50aXR5VG8sIHJlbW92ZUlkZW50aXR5KSB7XG4gICAgLy8gQVBJIGNoZWF0c2hlZXQ6XG4gICAgLy8gdXNlU2VjdXJlSW5mbyAgICA9IGZ1bmN0aW9uKCBmdW5jdGlvbihpZGVudGl0aWVzLCB1c2VybmFtZSwgcHJpdmF0ZVJvb3RLZXksIHByaXZhdGVBZG1pbktleSwgcHJpdmF0ZURlZmF1bHRLZXkpIClcbiAgICAvLyBhZGRJZGVudGl0eSAgICAgID0gZnVuY3Rpb24odXNlcm5hbWUsIGFsaWFzZXMsIHByZWZlcmVuY2VzKVxuICAgIC8vIGFkZEFsaWFzICAgICAgICAgPSBmdW5jdGlvbihpZGVudGl0eVVzZXJuYW1lLCBhbGlhc1VzZXJuYW1lLCBjYXBhLCBwcml2YXRlUm9vdEtleSwgcHJpdmF0ZUFkbWluS2V5LCBwcml2YXRlRGVmYXVsdEtleSwgc2VjcmV0cylcbiAgICAvLyBzZXRQcmltYXJ5QWxpYXMgID0gZnVuY3Rpb24oaWRlbnRpdHlVc2VybmFtZSwgYWxpYXNVc2VybmFtZSlcbiAgICAvLyByZW1vdmVJZGVudGl0eSAgID0gZnVuY3Rpb24odXNlcm5hbWUpXG4gICAgLy8gc2V0UHJlZmVyZW5jZSAgICA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIC8vIGZvciBjdXJyZW50IGlkZW50aXR5XG4gICAgLy8gc3dpdGNoSWRlbnRpdHlUbyA9IGZ1bmN0aW9uKHVzZXJuYW1lKVxuXG4gICAgLy8gVEhJTks6IGNvbnNpZGVyIGVuc3VyaW5nIGFsbCBmdW5jdGlvbnMgYXJlIHByZXNlbnQgZmlyc3QsIHNvIGl0J3MgaGFyZGVyIHRvIG1peCBhbmQgbWF0Y2ggd2FyZHJvYmUgaW1wbGVtZW50YXRpb25zXG4gICAgXG4gICAgaWYodHlwZW9mIHVzZVNlY3VyZUluZm8gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBFQi51c2VTZWN1cmVJbmZvID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IHVzZVNlY3VyZUluZm8gcmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGEgY3VycmVudCBpZGVudGl0eSwgYW5kIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgICAgcmV0dXJuIHVzZVNlY3VyZUluZm8oIGZ1bmN0aW9uKGlkZW50aXRpZXMsIHVzZXJuYW1lLCBwcml2YXRlUm9vdEtleSwgcHJpdmF0ZUFkbWluS2V5LCBwcml2YXRlRGVmYXVsdEtleSkge1xuICAgICAgICAgICAgICAgIHZhciBjbG9uZWRJZGVudGl0aWVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpZGVudGl0aWVzKSkgLy8gcHJldmVudCBhY2NpZGVudGFsIG11dGF0aW9uXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY2xvbmVkSWRlbnRpdGllcywgdXNlcm5hbWUsIHByaXZhdGVSb290S2V5LCBwcml2YXRlQWRtaW5LZXksIHByaXZhdGVEZWZhdWx0S2V5KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZih0eXBlb2YgYWRkSWRlbnRpdHkgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgRUIuYWRkSWRlbnRpdHkgPSBhZGRJZGVudGl0eVxuICAgICAgICBcbiAgICBpZih0eXBlb2YgYWRkQWxpYXMgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgRUIuYWRkQWxpYXMgPSBhZGRBbGlhc1xuICAgICAgICBcbiAgICBpZih0eXBlb2Ygc2V0UHJpbWFyeUFsaWFzID09ICdmdW5jdGlvbicpXG4gICAgICAgIEVCLnNldFByaW1hcnlBbGlhcyA9IHNldFByaW1hcnlBbGlhc1xuICAgICAgICBcbiAgICBpZih0eXBlb2Ygc2V0UHJlZmVyZW5jZSA9PSAnZnVuY3Rpb24nKVxuICAgICAgICBFQi5zZXRQcmVmZXJlbmNlID0gc2V0UHJlZmVyZW5jZVxuICAgICAgICBcbiAgICBpZih0eXBlb2Ygc3dpdGNoSWRlbnRpdHlUbyA9PSAnZnVuY3Rpb24nKVxuICAgICAgICBFQi5zd2l0Y2hJZGVudGl0eVRvID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAgICAgICAgIEVCLnJ1bkhhbmRsZXJzKCdiZWZvcmVTd2l0Y2hJZGVudGl0eScsIHVzZXJuYW1lKVxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHN3aXRjaElkZW50aXR5VG8odXNlcm5hbWUpXG4gICAgICAgICAgICBFQi5ydW5IYW5kbGVycygnYWZ0ZXJTd2l0Y2hJZGVudGl0eScsIHVzZXJuYW1lKVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICB9XG4gICAgICAgIFxuICAgIGlmKHR5cGVvZiByZW1vdmVJZGVudGl0eSA9PSAnZnVuY3Rpb24nKVxuICAgICAgICBFQi5yZW1vdmVJZGVudGl0eSA9IHJlbW92ZUlkZW50aXR5XG4gICAgICAgIFxuICAgIEVCLmdldEN1cnJlbnRVc2VybmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBOT1RFOiB3ZSdyZSB1c2luZyB0aGUgb3V0cHV0IHZhciB0byBsZWFrIGluZm9ybWF0aW9uIG91dCBvZiB1c2VTZWN1cmVJbmZvLiBiZSBjYXJlZnVsIHdpdGggdGhpcyB0ZWNobmlxdWUuXG4gICAgICAgIHZhciBvdXRwdXRcbiAgICAgICAgRUIudXNlU2VjdXJlSW5mbyhmdW5jdGlvbihpZGVudGl0aWVzLCB1c2VybmFtZSkgeyBvdXRwdXQgPSB1c2VybmFtZSB9KVxuICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgfVxuICAgIFxuICAgIEVCLmdldEN1cnJlbnRDYXBhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvdXRwdXRcbiAgICAgICAgRUIudXNlU2VjdXJlSW5mbyhmdW5jdGlvbihpZGVudGl0aWVzLCB1c2VybmFtZSkgeyBvdXRwdXQgPSAoKGlkZW50aXRpZXNbdXNlcm5hbWVdfHx7fSkucHJpbWFyeXx8e30pLmNhcGF8fDAgfSlcbiAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgIH1cbiAgICBcbiAgICBFQi5nZXRDdXJyZW50VmVyc2lvbmVkVXNlcm5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHVzZXJuYW1lID0gRUIuZ2V0Q3VycmVudFVzZXJuYW1lKClcbiAgICAgICAgaWYoIXVzZXJuYW1lKVxuICAgICAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ05vIGN1cnJlbnQgdXNlciBpbiB3YXJkcm9iZScpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gRUIuVXNlcnMubWFrZVZlcnNpb25lZCh1c2VybmFtZSwgRUIuZ2V0Q3VycmVudENhcGEoKSlcbiAgICB9XG4gICAgXG4gICAgRUIuZ2V0Q3VycmVudFVzZXJSZWNvcmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZlcnNpb25lZFVzZXJuYW1lID0gRUIuZ2V0Q3VycmVudFZlcnNpb25lZFVzZXJuYW1lKClcbiAgICAgICAgaWYoIXZlcnNpb25lZFVzZXJuYW1lKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIFxuICAgICAgICAvLyBUSElOSzogaXQncyB3ZWlyZCB0byBoaXQgdGhlIGNhY2hlIGRpcmVjdGx5IGZyb20gaGVyZSwgYnV0IGlmIHdlIGRvbid0IHRoZW4gd2UgYWx3YXlzIGdldCBhIHByb21pc2UsXG4gICAgICAgIC8vICAgICAgICBldmVuIGlmIHdlIGhpdCB0aGUgY2FjaGUsIGFuZCB0aGlzIHNob3VsZCByZXR1cm4gYSBwcm9wZXIgdXNlclJlY29yZCwgbm90IGEgcHJvbWlzZSwgXG4gICAgICAgIC8vICAgICAgICBzaW5jZSBhZnRlciBhbGwgd2UgaGF2ZSBzdG9yZWQgdGhlIHVzZXJSZWNvcmQgaW4gb3VyIHdhcmRyb2JlLCBoYXZlbid0IHdlP1xuICAgIFxuICAgICAgICB2YXIgdXNlclJlY29yZCA9IEVCLlVzZXJzLnJlY29yZHNbdmVyc2lvbmVkVXNlcm5hbWVdXG4gICAgICAgIGlmKCF1c2VyUmVjb3JkKVxuICAgICAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ1RoYXQgdXNlciBkb2VzIG5vdCBleGlzdCBpbiBvdXIgcmVjb3JkcycpXG4gICAgXG4gICAgICAgIHJldHVybiB1c2VyUmVjb3JkXG4gICAgfVxuXG4gICAgRUIuZ2V0QWxsSWRlbnRpdHlVc2VybmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG91dHB1dFxuICAgICAgICBFQi51c2VTZWN1cmVJbmZvKGZ1bmN0aW9uKGlkZW50aXRpZXMsIHVzZXJuYW1lKSB7IG91dHB1dCA9IE9iamVjdC5rZXlzKGlkZW50aXRpZXMpIH0pXG4gICAgICAgIHJldHVybiBvdXRwdXRcbiAgICB9XG4gICAgXG59XG5cblxuLy8vLyBJTklUSUFMSVpBVElPTlxuXG5FQi5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIC8vLy8gaW5pdGlhbGl6ZXMgYWxsIGF2YWlsYWJsZSBtb2R1bGVzIGFuZCB0aGUgcGxhdGZvcm0gc3Vic3lzdGVtcy5cbiAgICAvLy8vIG9wdGlvbnMgaXMgYW4gb2JqZWN0IG9mIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0aGF0IGlzIHBhc3NlZCB0byBlYWNoIG1vZHVsZSBhbmQgc3Vic3lzdGVtLlxuICAgIFxuICAgIC8vIEJFR0lOIENPTkZJRyBBTkQgT1BUSU9OUyAvL1xuICAgIFxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgXG4gICAgc2V0RGVmYXVsdCgnem9uZScsICcnKVxuICAgIHNldERlZmF1bHQoJ3B1ZmZBcGknLCAnaHR0cHM6Ly9pLmN4L2FwaS9wdWZmcy9hcGkucGhwJylcbiAgICBzZXREZWZhdWx0KCd1c2VyQXBpJywgJ2h0dHBzOi8vaS5jeC9hcGkvdXNlcnMvYXBpLnBocCcpXG4gICAgc2V0RGVmYXVsdCgnZXZlbnRzQXBpJywgJ2h0dHBzOi8vaS5jeC9hcGkvcHVmZnMvYXBpLnBocCcpXG4gICAgc2V0RGVmYXVsdCgnZW5hYmxlUDJQJywgZmFsc2UpXG4gICAgc2V0RGVmYXVsdCgncGFnZUJhdGNoU2l6ZScsIDEwKVxuICAgIHNldERlZmF1bHQoJ2luaXRMb2FkR2l2ZXVwJywgMjAwKVxuICAgIHNldERlZmF1bHQoJ25ldHdvcmtUaW1lb3V0JywgMjAwMDApICAgICAgICAgLy8gdHdlbnR5IHNlY29uZCB0aW1lb3V0XG4gICAgc2V0RGVmYXVsdCgnbm9Mb2NhbFN0b3JhZ2UnLCBmYWxzZSlcbiAgICBzZXREZWZhdWx0KCduZXRibG9ja1N1ZmZpeCcsICdsb2NhbCcpXG4gICAgc2V0RGVmYXVsdCgnY3J5cHRvd29ya2VyVVJMJywgJycpICAgICAgICAgICAvLyBwb2ludCB0byBjcnlwdG93b3JrZXIuanMgdG8gZW5hYmxlIHdvcmtlciB0aHJlYWRcbiAgICBzZXREZWZhdWx0KCdlcGhlbWVyYWxLZXljaGFpbicsIGZhbHNlKSAgICAgIC8vIHByZXZlbnRzIGtleWNoYWluIGZyb20gYmVpbmcgc2F2ZWQgdG8gbG9jYWxTdG9yYWdlXG4gICAgc2V0RGVmYXVsdCgnaW5pdExvYWRCYXRjaFNpemUnLCAyMClcbiAgICBzZXREZWZhdWx0KCdpbk1lbW9yeVNoZWxsTGltaXQnLCAxMDAwMCkgICAgIC8vIHNoZWxscyBhcmUgcmVtb3ZlZCB0byBjb21wZW5zYXRlXG4gICAgc2V0RGVmYXVsdCgnZ2xvYmFsQmlnQmF0Y2hMaW1pdCcsIDIwMDApICAgICAvLyBtYXhpbXVtIG51bWJlciBvZiBzaGVsbHMgdG8gcmVjZWl2ZSBhdCBvbmNlIC8vIFRPRE86IGFsaWduIHdpdGggQVBJXG4gICAgc2V0RGVmYXVsdCgnaW5NZW1vcnlNZW1vcnlMaW1pdCcsIDMwMEU2KSAgICAvLyB+MzAwTUJcbiAgICBzZXREZWZhdWx0KCdhbm9uUHJpdmF0ZUFkbWluS2V5JywgJzVLZFZqUXdqaE1jaHJadWRGVmZlUmlpUE1kck42cmM0Q291Tmg3S1BabWg4aUhFaVdNeCcpIC8vIGZvciByZWdpc3RlcmluZyBhbm9uIHVzZXJzXG4gICAgc2V0RGVmYXVsdCgnZGlzYWJsZVNlbmRUb1NlcnZlcicsIGZhbHNlKSAgICAvLyBzbyB5b3UgY2FuIHdvcmsgbG9jYWxseVxuICAgIHNldERlZmF1bHQoJ2Rpc2FibGVSZWNlaXZlUHVibGljJywgZmFsc2UpICAgLy8gbm8gcHVibGljIHB1ZmZzIGV4Y2VwdCBwcm9maWxlc1xuICAgIHNldERlZmF1bHQoJ2Rpc2FibGVDbG91ZElkZW50aXR5JywgZmFsc2UpICAgLy8gZG9uJ3Qgc3RvcmUgZW5jcnlwdGVkIGlkZW50aXR5IGluIHRoZSBjbG91ZFxuICAgIHNldERlZmF1bHQoJ3N1cHBvcnRlZENvbnRlbnRUeXBlcycsIGZhbHNlKSAgLy8gd2hpdGVsaXN0IG9mIGNvbnRleHQgdHlwZXM7IGZhbHNlIGxvYWRzIGFsbFxuICAgIHNldERlZmF1bHQoJ3NoZWxsQ29udGVudFRocmVzaG9sZCcsIDEwMDApICAgLy8gc2l6ZSBvZiB1bmNvbXBhY3RlZCBjb250ZW50XG4gICAgc2V0RGVmYXVsdCgnbG9jYWxTdG9yYWdlU2hlbGxMaW1pdCcsIDEwMDApICAvLyBtYXhpbXVtIG51bWJlciBvZiBzaGVsbHNcbiAgICBzZXREZWZhdWx0KCdsb2NhbFN0b3JhZ2VNZW1vcnlMaW1pdCcsIDNFNikgIC8vIH4zTUJcbiAgICBcbiAgICBmdW5jdGlvbiBzZXREZWZhdWx0KGtleSwgdmFsKSB7XG4gICAgICAgIEVCLkNPTkZJR1trZXldID0gb3B0aW9uc1trZXldIHx8IEVCLkNPTkZJR1trZXldIHx8IHZhbFxuICAgIH1cbiAgICBcbiAgICAvLyBFTkQgQ09ORklHIEFORCBPUFRJT05TIC8vXG4gICAgICAgIFxuICAgIEVCLlVzZXJzLmluaXQob3B0aW9ucykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSB1c2VyIHJlY29yZCBzdWJzeXN0ZW1cbiAgICBFQi5EYXRhLmluaXQob3B0aW9ucykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgZGF0YSBzdWJzeXN0ZW1cbiAgICBFQi5OZXQuaW5pdChvcHRpb25zKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgbmV0d29yayBzdWJzeXN0ZW1cbiAgICBcbiAgICB2YXIgbW9kdWxlS2V5cyA9IE9iamVjdC5rZXlzKEVCLk0pXG4gICAgbW9kdWxlS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkgeyAgICAgICAgICAgICAgICAgIC8vIGNhbGwgYWxsIG1vZHVsZSBpbml0aWFsaXplcnNcbiAgICAgICAgaWYoRUIuTVtrZXldLmluaXQpIFxuICAgICAgICAgICAgRUIuTVtrZXldLmluaXQob3B0aW9ucylcbiAgICB9KVxuICAgIFxuICAgIHBvcE1vZHMoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZsYXRlIGFueSBtYWNoaW5lIHByZWZzXG4gICAgZnVuY3Rpb24gcG9wTW9kcygpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRISU5LOiBtYXliZSBtb3ZlIHRoaXMgdG8gRUIuUGVyc2lzdC5pbml0XG4gICAgICAgIHZhciBtb2RzID0gRUIuUGVyc2lzdC5nZXQoJ0NPTkZJRycpXG4gICAgICAgIGlmKCFtb2RzKSByZXR1cm4gZmFsc2VcbiAgICBcbiAgICAgICAgRUIuQ09ORklHLm1vZHMgPSBtb2RzXG4gICAgICAgIE9iamVjdC5rZXlzKEVCLkNPTkZJRy5tb2RzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkgeyBFQi5DT05GSUdba2V5XSA9IG1vZHNba2V5XSB9KVxuICAgIH1cbiAgICBcbiAgICBFQi5idWlsZENyeXB0b3dvcmtlcihvcHRpb25zKVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vIEVORCBTVEFOREFSRCBBUEkgLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuXG4vLy8vLy8vLy8vLy8vLyBIQU5ETEVSIEhBTkRMRVJTIC8vLy8vLy8vLy8vLy8vLy8vL1xuXG5FQi5oYW5kbGVycyA9IHt9XG5cbkVCLmFkZEhhbmRsZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaykge1xuICBpZighRUIuaGFuZGxlcnNbdHlwZV0pIEVCLmhhbmRsZXJzW3R5cGVdID0gW11cbiAgRUIuaGFuZGxlcnNbdHlwZV0ucHVzaChjYWxsYmFjaylcbn1cblxuRUIucnVuSGFuZGxlcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gIHJldHVybiAoRUIuaGFuZGxlcnNbdHlwZV0gfHwgW10pLnJlZHVjZShcbiAgICAgIGZ1bmN0aW9uKGFjYywgY2FsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYWNjID09IG51bGwgPyBhcmdzIDogQXJyYXkuaXNBcnJheShhY2MpID8gYWNjIDogW2FjY10pfSwgYXJncylcbn1cblxuRUIubWFrZUhhbmRsZXJIYW5kbGVyID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge3JldHVybiBFQi5hZGRIYW5kbGVyKHR5cGUsIGNhbGxiYWNrKX1cbn1cblxuLy8gVVNFRlVMIEhBTkRMRVJTOlxuXG5FQi5hZGRFcnJvckhhbmRsZXIgICAgICAgICAgID0gRUIubWFrZUhhbmRsZXJIYW5kbGVyKCdlcnJvcicpICAgICAgICAgICAvLyByZWNlaXZlcyBhbGwgZXJyb3IgbWVzc2FnZXNcblxuRUIuYWRkTmV3UHVmZkhhbmRsZXIgICAgICAgICA9IEVCLm1ha2VIYW5kbGVySGFuZGxlcignbmV3UHVmZnMnKSAgICAgICAgLy8gY2FsbGVkIHdoZW4gbmV3IHB1ZmZzIGFyZSBhdmFpbGFibGVcblxuRUIuYWRkREhURXJyb3JIYW5kbGVyICAgICAgICA9IEVCLm1ha2VIYW5kbGVySGFuZGxlcignREhURXJyb3InKSAgICAgICAgLy8gcmVjZWl2ZXMgREhUIGVycm9yIG1lc3NhZ2VzXG5cbkVCLmFkZFJlbGF0aW9uc2hpcEhhbmRsZXIgICAgPSBFQi5tYWtlSGFuZGxlckhhbmRsZXIoJ3JlbGF0aW9uc2hpcCcpICAgIC8vIG1hbmFnZSByZWxhdGlvbnNoaXBzIGJldHdlZW4gcHVmZnNcblxuRUIuYWRkVGltZW91dEVycm9ySGFuZGxlciAgICA9IEVCLm1ha2VIYW5kbGVySGFuZGxlcigndGltZW91dEVycm9yJykgICAgLy8gcmVjZWl2ZXMgdGltZW91dCBlcnJvciBtZXNzYWdlc1xuXG5FQi5hZGROZXR3b3JrRXJyb3JIYW5kbGVyICAgID0gRUIubWFrZUhhbmRsZXJIYW5kbGVyKCduZXR3b3JrRXJyb3InKSAgICAvLyByZWNlaXZlcyBuZXR3b3JrIGVycm9yIG1lc3NhZ2VzXG5cbkVCLmFkZE5ld1B1ZmZSZXBvcnRIYW5kbGVyICAgPSBFQi5tYWtlSGFuZGxlckhhbmRsZXIoJ25ld1B1ZmZSZXBvcnQnKSAgIC8vIGhhbmRsZXMgcmVwb3J0cyBvbiBpbmNvbWluZyBwdWZmc1xuXG5FQi5hZGRJZGVudGl0eVVwZGF0ZUhhbmRsZXIgID0gRUIubWFrZUhhbmRsZXJIYW5kbGVyKCdpZGVudGl0eVVwZGF0ZScpICAvLyBnZW5lcmFsIEdVSSB1cGRhdGUgdHJpZ2dlclxuXG5FQi5hZGROZXR3b3JrUmVzcG9uc2VIYW5kbGVyID0gRUIubWFrZUhhbmRsZXJIYW5kbGVyKCduZXR3b3JrcmVzcG9uc2UnKSAvLyByZWNlaXZlcyBhbGwgbmV0d29yayByZXNwb25zZVxuXG5FQi5hZGRQYXlsb2FkTW9kaWZpZXJIYW5kbGVyID0gRUIubWFrZUhhbmRsZXJIYW5kbGVyKCdwYXlsb2FkTW9kaWZpZXInKSAvLyBkZWNvcmF0ZSBwdWZmIHBheWxvYWRzIFxuXG4vLyBFQi5hZGRDbGVhclB1ZmZDYWNoZUhhbmRsZXIgPSBFQi5tYWtlSGFuZGxlckhhbmRsZXIoJ2NsZWFycHVmZmNhY2hlJylcblxuLy8gYmVmb3JlU3dpdGNoSWRlbnRpdHkgaXMgY2FsbGVkIHByaW9yIHRvIHN3aXRjaElkZW50aXR5IGFuZCByZW1vdmVJZGVudGl0eSwgd2hpbGUgdGhlIG9sZCBpZGVudGl0eSBpcyBhY3RpdmVcbi8vIGFmdGVyU3dpdGNoSWRlbnRpdHkgIGlzIGNhbGxlZCBhZnRlciBzd2l0Y2hJZGVudGl0eSwgb25jZSB0aGUgbmV3IGlkZW50aXR5IGlzIGFjdGl2ZVxuRUIuYWRkQmVmb3JlU3dpdGNoSWRlbnRpdHlIYW5kbGVyID0gRUIubWFrZUhhbmRsZXJIYW5kbGVyKCdiZWZvcmVTd2l0Y2hJZGVudGl0eScpXG5FQi5hZGRBZnRlclN3aXRjaElkZW50aXR5SGFuZGxlciAgPSBFQi5tYWtlSGFuZGxlckhhbmRsZXIoJ2FmdGVyU3dpdGNoSWRlbnRpdHknKVxuXG4vLy8vLy8vLy8vLy8vLyBFTkQgSEFORExFUiBIQU5ETEVSUyAvLy8vLy8vLy8vLy8vL1xuXG5cblxuXG4vLy8vIFBVRkYgSEVMUEVSUyAvLy8vXG5cbkVCLmRlY3J5cHRQdWZmRm9yUmVhbHMgPSBmdW5jdGlvbihlbnZlbG9wZSwgeW91clB1YmxpY1dpZiwgbXlWZXJzaW9uZWRVc2VybmFtZSwgbXlQcml2YXRlV2lmKSB7XG4gICAgLy8vLyBpbnRlcmZhY2Ugd2l0aCBFQi5DcnlwdG8gZm9yIGRlY3J5cHRpbmcgYSBtZXNzYWdlXG4gICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgaW4gRUIuRGF0YSwgYnV0IGlzIGluIEVCIGZvciBjcnlwdG93b3JrZXIncyBzYWtlXG4gICAgaWYoIWVudmVsb3BlLmtleXMpIHJldHVybiBmYWxzZVxuICAgIHZhciBrZXlGb3JNZSA9IGVudmVsb3BlLmtleXNbbXlWZXJzaW9uZWRVc2VybmFtZV1cbiAgICB2YXIgcHVmZmtleSAgPSBFQi5DcnlwdG8uZGVjcnlwdFByaXZhdGVNZXNzYWdlKGtleUZvck1lLCB5b3VyUHVibGljV2lmLCBteVByaXZhdGVXaWYpXG4gICAgdmFyIGxldHRlckNpcGhlciA9IGVudmVsb3BlLnBheWxvYWQuY29udGVudFxuICAgIHZhciBsZXR0ZXJTdHJpbmcgPSBFQi5DcnlwdG8uZGVjcnlwdFdpdGhBRVMobGV0dGVyQ2lwaGVyLCBwdWZma2V5KVxuICAgIHZhciBiZXR0ZXJTdHJpbmcgPSBFQi50cnlEZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGxldHRlclN0cmluZykpICAgLy8gdHJ5IGRlY29kaW5nXG4gICAgcmV0dXJuIEVCLnBhcnNlSlNPTihiZXR0ZXJTdHJpbmcpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkgcGFyc2luZ1xufVxuXG4vLy8vIEVORCBQVUZGIEhFTFBFUlMgLy8vL1xuXG5cblxuXG5cblxuLy8vLyBCVUlMRCBDUllQVE8gV09SS0VSIC8vLy9cblxuRUIuYnVpbGRDcnlwdG93b3JrZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGNyeXB0b3dvcmtlclVSTCA9IG9wdGlvbnMuY3J5cHRvd29ya2VyVVJMIHx8IEVCLkNPTkZJRy5jcnlwdG93b3JrZXJVUkwgLy8gfHwgJ2NyeXB0b3dvcmtlci5qcydcbiAgICBcbiAgICBpZighY3J5cHRvd29ya2VyVVJMKSByZXR1cm4gZmFsc2VcbiAgICBcbiAgICBFQi5jcnlwdG93b3JrZXIgPSBuZXcgV29ya2VyKGNyeXB0b3dvcmtlclVSTClcbiAgICBFQi5jcnlwdG93b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgRUIud29ya2VycmVjZWl2ZSlcbn1cblxuRUIud29ya2VycXVldWUgPSBbXVxuRUIud29ya2VyYXV0b2lkID0gMFxuXG5FQi53b3JrZXJyZWNlaXZlID0gZnVuY3Rpb24obXNnKSB7XG4gICAgdmFyIGlkID0gbXNnLmRhdGEuaWRcbiAgICBpZighaWQpIHJldHVybiBmYWxzZSAvLyBUT0RPOiBhZGQgb25FcnJvciBoZXJlXG5cbiAgICB2YXIgZnVuID0gRUIud29ya2VycXVldWVbaWRdXG4gICAgaWYoIWZ1bikgcmV0dXJuIGZhbHNlIC8vIFRPRE86IGFkZCBvbkVycm9yIGhlcmVcblxuICAgIGZ1bihtc2cuZGF0YS5ldmFsdWF0ZWQpXG5cbiAgICBkZWxldGUgRUIud29ya2VycXVldWVbaWRdIC8vIFRISU5LOiB0aGlzIGxlYXZlcyBhIHNwYXJzZSBhcnJheSwgYnV0IGlzIHByb2JhYmx5IGZhc3RlciB0aGFuIHNwbGljaW5nXG59XG5cbkVCLndvcmtlcnNlbmQgPSBmdW5jdGlvbihmdW5zdHIsIGFyZ3MsIHJlc29sdmUsIHJlamVjdCkge1xuICAgIEVCLndvcmtlcmF1dG9pZCArPSAxXG4gICAgRUIud29ya2VycXVldWVbRUIud29ya2VyYXV0b2lkXSA9IHJlc29sdmVcbiAgICBpZighQXJyYXkuaXNBcnJheShhcmdzKSlcbiAgICAgICAgYXJncyA9IFthcmdzXVxuICAgIEVCLmNyeXB0b3dvcmtlci5wb3N0TWVzc2FnZSh7ZnVuOiBmdW5zdHIsIGFyZ3M6IGFyZ3MsIGlkOiBFQi53b3JrZXJhdXRvaWR9KVxufVxuXG4vLy8vIEVORCBCVUlMRCBDUllQVE8gV09SS0VSIC8vLy9cblxuXG5cblxuLy8vLyBFUlJPUiBIRUxQRVJTXG5cbi8vIFRPRE86IGJ1aWxkIGEgbW9yZSBnZW5lcmFsIGVycm9yIGhhbmRsaW5nIHN5c3RlbSBmb3IgR1VJIGludGVncmF0aW9uXG5cbkVCLm9uRXJyb3IgPSBmdW5jdGlvbihtc2csIG9iaiwgdHJpZ2dlcikge1xuICAgIC8vLy8gb3ZlcnJpZGUgdGhpcyBmb3IgY3VzdG9tIGVycm9yIGJlaGF2aW9yXG4gICAgXG4gICAgdmFyIGNvbXBvc2l0ZSA9IHttc2c6IG1zZywgb2JqOiBvYmp9XG5cbiAgICBFQi5ydW5IYW5kbGVycygnZXJyb3InLCBjb21wb3NpdGUpXG4gICAgXG4gICAgaWYodHJpZ2dlcilcbiAgICAgICAgRUIucnVuSGFuZGxlcnModHJpZ2dlciwgY29tcG9zaXRlKVxuICAgICAgICBcbiAgICAvLyBmb3IgZGVidWdnaW5nIGhlbHAsIHJ1biB0aGlzIGluIHRoZSBjb25zb2xlOlxuICAgIC8vIEVCLmFkZEVycm9ySGFuZGxlcihmdW5jdGlvbihjb21wb3NpdGUpIHtjb25zb2xlLmxvZyhjb21wb3NpdGUpfSlcblxuICAgIHJldHVybiBmYWxzZVxufVxuXG5FQi5jYXRjaEVycm9yID0gZnVuY3Rpb24obXNnKSB7XG4gICAgLy8vLyBleDogcHJvbS5jYXRjaCggRUIuY2F0Y2hFcnJvcignaW52YWxpZCBmb28nKSApLnRoZW4oZnVuY3Rpb24oZm9vKSB7Li4ufSlcbiAgICByZXR1cm4gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIEVCLm9uRXJyb3IobXNnLCBlcnIpXG4gICAgICAgIHRocm93IGVyclxuICAgIH1cbn1cblxuRUIudGhyb3dFcnJvciA9IGZ1bmN0aW9uKG1zZywgZXJybXNnKSB7XG4gICAgLy8vLyBleDogcHJvbS50aGVuKGZ1bmN0aW9uKGZvbykge2lmKCFmb28pIEVCLnRocm93RXJyb3IoJ25vIGZvbycpOyAuLi59KVxuICAgIHZhciBlcnIgPSBlcnJtc2cgPyBFcnJvcihlcnJtc2cpIDogJydcbiAgICB0aHJvdyBFQi5tYWtlRXJyb3IobXNnLCBlcnIpXG59XG5cbkVCLm1ha2VFcnJvciA9IGZ1bmN0aW9uKG1zZywgZXJyLCB0cmlnZ2VyKSB7XG4gICAgLy8vLyBleDogbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7IGlmKCFmb28pIHJlamVjdCggRUIubWFrZUVycm9yKCdubyBmb28nKSApIC4uLiB9KVxuICAgIEVCLm9uRXJyb3IobXNnLCBlcnIsIHRyaWdnZXIpXG4gICAgcmV0dXJuIEVycm9yKG1zZylcbn1cblxuRUIuZW1wdHlQcm9taXNlID0gZnVuY3Rpb24obXNnKSB7XG4gICAgLy8vLyBleDogZnVuY3Rpb24oZm9vKSB7IGlmKCFmb28pIHJldHVybiBFQi5lbXB0eVByb21pc2UoJ25vIGZvbycpOyByZXR1cm4gZ2V0Rm9vUHJvbWlzZShmb28pIH1cbiAgICBpZihtc2cpIEVCLm9uRXJyb3IobXNnKVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChtc2cpXG59XG5cbkVCLnRocm93TmV0RXJyb3IgPSBmdW5jdGlvbihtc2csIGVycm1zZykge1xuICAgIC8vLy8gbGlrZSB0aHJvdyBlcnJvciBidXQgdHJpZ2dlcnMgdGhlIG5ldHdvcmtFcnJvciBoYW5kbGVyXG4gICAgdmFyIHRyaWdnZXIgPSAnbmV0d29ya0Vycm9yJ1xuICAgIHZhciBlcnIgPSBlcnJtc2cgPyBFcnJvcihlcnJtc2cpIDogJydcbiAgICB0aHJvdyBFQi5tYWtlRXJyb3IobXNnLCBlcnIsIHRyaWdnZXIpXG59XG5cbkVCLnRocm93REhURXJyb3IgPSBmdW5jdGlvbihtc2csIGVycm1zZykge1xuICAgIC8vLy8gbGlrZSB0aHJvdyBlcnJvciBidXQgdHJpZ2dlcnMgdGhlIERIVEVycm9yIGhhbmRsZXJcbiAgICB2YXIgdHJpZ2dlciA9ICdESFRFcnJvcidcbiAgICB2YXIgZXJyID0gZXJybXNnID8gRXJyb3IoZXJybXNnKSA6ICcnXG4gICAgdGhyb3cgRUIubWFrZUVycm9yKG1zZywgZXJyLCB0cmlnZ2VyKVxufVxuXG5cbi8vLy8gRXhjZXB0aW9uYWwgQVBJIHdyYXBwZXJzXG5cbkVCLnBhcnNlSlNPTiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIC8vLy8gSlNPTi5wYXJzZSB0aHJvd3MsIHNvIHdlIGNhdGNoIGl0LiB0aHJvdy9jYXRjaCBib3JrcyB0aGUgSlMgVk0gb3B0aW1pemVyLCBzbyB3ZSBib3ggaXQuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIHJldHVybiBFQi5vbkVycm9yKCdJbnZhbGlkIEpTT04gc3RyaW5nJywgZXJyKVxuICAgIH1cbn1cblxuRUIuc3RyaW5naWZ5SlNPTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIC8vLy8gSlNPTi5zdHJpbmdpZnkgdGhyb3dzIG9uIGR1bWIgRE9NIG9iamVjdHMsIHNvIHdlIGNhdGNoIGl0LiB0aHJvdy9jYXRjaCBib3JrcyB0aGUgSlMgVk0gb3B0aW1pemVyLCBzbyB3ZSBib3ggaXQuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iailcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICByZXR1cm4gRUIub25FcnJvcignSW52YWxpZCBvYmplY3QnLCBlcnIpXG4gICAgfVxufVxuXG5FQi50cnlEZWNvZGVVUklDb21wb25lbnQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAvLy8vIGRlY29kZVVSSUNvbXBvbmVudCB0aHJvd3MsIHNvIHdlIHdyYXAgaXQuIHRyeS9jYXRjaCBraWxscyB0aGUgb3B0aW1pemVyLCBzbyB3ZSBpc29sYXRlIGl0LlxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIHJldHVybiBFQi5vbkVycm9yKCdJbnZhbGlkIFVSSSBzdHJpbmcnLCBlcnIpXG4gICAgfVxufVxuXG5cbi8vLy8gc29tZXRoaW5nIGRpZmZlcmVudFxuXG5FQi5wcm9taXNlc1BlbmRpbmcgPSB7fVxuXG4vLyBNYWpvciBqdWppdHN1IGhlcmVcbkVCLnByb21pc2VNZW1vaXplID0gZnVuY3Rpb24oZnVuLCBvaGJveSkge1xuICAgIGlmKCFvaGJveSkgb2hib3kgPSBFQi5yZW1vdmVQcm9taXNlUGVuZGluZ1xuICAgIFxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGtleSA9IEpTT04uc3RyaW5naWZ5KFtmdW4udG9TdHJpbmcoKSxhcmd1bWVudHNdKVxuICAgICAgICBcbiAgICAgICAgaWYoRUIucHJvbWlzZXNQZW5kaW5nW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gRUIucHJvbWlzZXNQZW5kaW5nW2tleV1cbiAgICAgICAgXG4gICAgICAgIHZhciBwcm9tID0gZnVuLmFwcGx5KGZ1biwgYXJndW1lbnRzKVxuICAgICAgICBwcm9tID0gcHJvbS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBvaGJveShrZXksIHZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlbGl2ZXIgc3VjY2Vzc2VzXG4gICAgICAgIH0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBvaGJveShrZXksIHZhbHVlKVxuICAgICAgICAgICAgdGhyb3cgdmFsdWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSBmYWlsdXJlc1xuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgRUIucHJvbWlzZXNQZW5kaW5nW2tleV0gPSBwcm9tXG4gICAgICAgIHJldHVybiBwcm9tXG4gICAgfVxufVxuXG5FQi5yZW1vdmVQcm9taXNlUGVuZGluZyA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGRlbGV0ZSBFQi5wcm9taXNlc1BlbmRpbmdba2V5XVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vIEEgZmV3IHNtYWxsIGhlbHBlcnMgZm9yIGJ1aWxkaW5nIGZ1bmN0aW9uYWwgcGlwZWxpbmVzIC8vLy8vLy8vLy8vLy8vL1xuXG5FQi5wcm9wID0gZnVuY3Rpb24ocCwgb2JqKSB7IC8vIFRISU5LOiBjb25zaWRlciBpbXBvcnRpbmcgYWxsIG9mIFJhbWJkYS5qc1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9ialtwXTsgfSA6IG9ialtwXVxufVxuXG5FQi51bmlxdWlmeSA9IGZ1bmN0aW9uKGxpc3QpIHtcbiAgICByZXR1cm4gbGlzdC5maWx0ZXIoRUIudW5pcXVlKVxufVxuXG5FQi51bmlxdWUgPSBmdW5jdGlvbihpdGVtLCBpbmRleCwgYXJyYXkpIHtyZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKSA9PSBpbmRleH1cbiIsIi8qXG5cbiAgICBDcnlwdG9ncmFwaGljIG1hbmFnZW1lbnQgZm9yIHRoZSBFdmVyeUJpdCBwbGF0Zm9ybS5cblxuICAgIENvbnRhaW5zIHZhcmlvdXMgZnVuY3Rpb25zIHRoYXQgcmVseSBvbiBiaXRjb2luLWxpYi5qcyBmb3IgdGhlaXIgY3J5cHRvZ3JhcGhpYyBmdW5jdGlvbmFsaXR5LFxuICAgIGFuIEVDREggaW1wbGVtZW50YXRpb24sIGEgcmFuZG9tIG51bWJlciBzaGltIGZvciBvbGRlciBicm93c2VycywgYW5kIHJhbmRvbSBoZWxwZXIgZnVuY3Rpb25zLlxuXG4gICAgQ29weXJpZ2h0IDIwMTQtMjAxNSBFdmVyeUJpdC4gU2VlIFJFQURNRSBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuKi9cblxuRUIuQ3J5cHRvID0ge307XG5cbi8qKlxuICogR2VuZXJhdGUgcHJpdmF0ZSBrZXlcbiAqIEByZXR1cm4ge3N0cmluZ30gXG4gKi9cbkVCLkNyeXB0by5nZW5lcmF0ZVByaXZhdGVLZXkgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBPUFQ6IHJlbW92ZSB0aGlzIHRlc3Qgb25jZSBCaXRjb2luLkVDS2V5IG5vIGxvbmdlciBnZW5lcmF0ZXMgaW52YWxpZCBrZXlzIChhYm91dCAxIGluIDEsMDAwIHJpZ2h0IG5vdylcbiAgICB2YXIgcHJpa2V5ID0gbmV3IEJpdGNvaW4uRUNLZXkoKS50b1dpZigpXG4gICAgaWYoRUIuQ3J5cHRvLndpZlRvUHJpS2V5KHByaWtleSkpXG4gICAgICAgIHJldHVybiBwcmlrZXlcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBFQi5DcnlwdG8uZ2VuZXJhdGVQcml2YXRlS2V5KCkgIC8vIFRISU5LOiB0aGlzIGNvdWxkIGdlbmVyYXRlIGFuIGV0ZXJuYWwgZXJyb3IgZXhwbG9zaW9uXG59XG5cblxuLyoqXG4gKiBDb252ZXJ0IHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleVxuICogQHBhcmFtICB7c3RyaW5nfSBwcml2YXRlS2V5V0lGXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbkVCLkNyeXB0by5wcml2YXRlVG9QdWJsaWMgPSBmdW5jdGlvbihwcml2YXRlS2V5V0lGKSB7XG4gICAgLy8gVE9ETzogVGhpcyBzaG91bGQgcmV0dXJuIGZhbHNlIGlmIHN0cmluZyBpcyBlbXB0eVxuICAgIGlmKCFwcml2YXRlS2V5V0lGKVxuICAgICAgICByZXR1cm4gRUIub25FcnJvcignVGhhdCBwcml2YXRlIGtleSBjb250YWluZWQgbm8gZGF0YScpXG4gICAgICAgIFxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBFQi5DcnlwdG8ud2lmVG9QcmlLZXkocHJpdmF0ZUtleVdJRikuZ2V0UHViKHRydWUpLnRvV2lmKClcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICByZXR1cm4gRUIub25FcnJvcignSW52YWxpZCBwcml2YXRlIGtleTogY291bGQgbm90IGNvbnZlcnQgdG8gcHVibGljIGtleScsIFtwcml2YXRlS2V5V0lGLCBlcnJdKVxuICAgIH1cbn1cblxuXG4vKipcbiAqIFNpZ24gdGhlIGhhc2ggb2Ygc29tZSBkYXRhIHdpdGggYSBwcml2YXRlIGtleSBhbmQgcmV0dXJuIHRoZSBzaWcgaW4gYmFzZSA1OFxuICogQHBhcmFtICB7b2JqZWN0fSB1bnNpZ25lZFB1ZmZcbiAqIEBwYXJhbSAge3N0cmluZ30gcHJpdmF0ZUtleVdJRlxuICogQHJldHVybiB7KGJvb2xlYW58ZXJyb3IpfVxuICovXG5FQi5DcnlwdG8uc2lnblB1ZmYgPSBmdW5jdGlvbih1bnNpZ25lZFB1ZmYsIHByaXZhdGVLZXlXSUYpIHtcbiAgICAvLy8vIHNpZ24gdGhlIGhhc2ggb2Ygc29tZSBkYXRhIHdpdGggYSBwcml2YXRlIGtleSBhbmQgcmV0dXJuIHRoZSBzaWcgaW4gYmFzZSA1OFxuXG4gICAgdmFyIHByaWtleSA9IEVCLkNyeXB0by53aWZUb1ByaUtleShwcml2YXRlS2V5V0lGKVxuICAgIHZhciBtZXNzYWdlID0gRUIuQ3J5cHRvLnB1ZmZUb1NpZ2xlc3NTdHJpbmcodW5zaWduZWRQdWZmKVxuICAgIHZhciBtZXNzYWdlSGFzaCA9IEVCLkNyeXB0by5jcmVhdGVNZXNzYWdlSGFzaChtZXNzYWdlKVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBCaXRjb2luLmJhc2U1OC5lbmNvZGUocHJpa2V5LnNpZ24obWVzc2FnZUhhc2gpKVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIHJldHVybiBFQi5vbkVycm9yKCdDb3VsZCBub3QgcHJvcGVybHkgZW5jb2RlIHNpZ25hdHVyZScsIFtwcmlrZXksIG1lc3NhZ2VIYXNoLCBlcnJdKVxuICAgIH1cbn1cblxuXG4vKipcbiAqIHRvIHZlcmlmeSBwdWZmIHNpZ1xuICogQHBhcmFtICB7b2JqZWN0fSBwdWZmXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGRlZmF1bHRLZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkVCLkNyeXB0by52ZXJpZnlQdWZmU2lnID0gZnVuY3Rpb24ocHVmZiwgZGVmYXVsdEtleSkge1xuICAgIHZhciBwdWZmU3RyaW5nID0gRUIuQ3J5cHRvLnB1ZmZUb1NpZ2xlc3NTdHJpbmcocHVmZik7XG4gICAgcmV0dXJuIEVCLkNyeXB0by52ZXJpZnlNZXNzYWdlKHB1ZmZTdHJpbmcsIHB1ZmYuc2lnLCBkZWZhdWx0S2V5KTtcbn1cblxuXG4vKipcbiAqIGFjY2VwdCBhIGJhc2UgNTggc2lnLCBhIG1lc3NhZ2UgKG11c3QgYmUgYSBzdHJpbmcpIGFuZCBhIGJhc2UgNTggcHVibGljIGtleS4gcmV0dXJucyB0cnVlIGlmIHRoZXkgbWF0Y2gsIGZhbHNlIG90aGVyd2lzZVxuICogQHBhcmFtICB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNpZ1xuICogQHBhcmFtICB7c3RyaW5nfSBwdWJsaWNLZXlXSUZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkVCLkNyeXB0by52ZXJpZnlNZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSwgc2lnLCBwdWJsaWNLZXlXSUYpIHtcbiAgICAvLy8vIGFjY2VwdCBhIGJhc2UgNTggc2lnLCBhIG1lc3NhZ2UgKG11c3QgYmUgYSBzdHJpbmcpIGFuZCBhIGJhc2UgNTggcHVibGljIGtleS4gcmV0dXJucyB0cnVlIGlmIHRoZXkgbWF0Y2gsIGZhbHNlIG90aGVyd2lzZVxuICBcbiAgICB0cnkge1xuICAgICAgICB2YXIgcHVia2V5ID0gRUIuQ3J5cHRvLndpZlRvUHViS2V5KHB1YmxpY0tleVdJRilcbiAgICAgICAgXG4gICAgICAgIHZhciBzaWdCeXRlcyA9IEJpdGNvaW4uYmFzZTU4LmRlY29kZShzaWcpLnRvSlNPTigpXG4gICAgICAgIHNpZ0J5dGVzID0gc2lnQnl0ZXMuZGF0YSB8fCBzaWdCeXRlc1xuICAgICAgICBcbiAgICAgICAgdmFyIG1lc3NhZ2VIYXNoID0gRUIuQ3J5cHRvLmNyZWF0ZU1lc3NhZ2VIYXNoKG1lc3NhZ2UpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcHVia2V5LnZlcmlmeShtZXNzYWdlSGFzaCwgc2lnQnl0ZXMpXG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ0ludmFsaWQga2V5IG9yIHNpZzogY291bGQgbm90IHZlcmlmeSBtZXNzYWdlJywgW21lc3NhZ2VIYXNoLCBzaWcsIHB1YmxpY0tleVdJRiwgZXJyXSlcbiAgICB9XG59XG5cblxuLyoqXG4gKiB0byBjcmVhdGUgbWVzc2FnZSBoYXNoXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuRUIuQ3J5cHRvLmNyZWF0ZU1lc3NhZ2VIYXNoID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHJldHVybiBCaXRjb2luLkNyeXB0by5TSEEyNTYobWVzc2FnZSkudG9TdHJpbmcoKVxufVxuXG5cbi8qKlxuICogY3J5cHQgd2lmIHRvIHByaXZhdGUga2V5XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHByaXZhdGVLZXlXSUZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkVCLkNyeXB0by53aWZUb1ByaUtleSA9IGZ1bmN0aW9uKHByaXZhdGVLZXlXSUYpIHtcbiAgICBpZighcHJpdmF0ZUtleVdJRilcbiAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ1RoYXQgcHJpdmF0ZSBrZXkgd2lmIGNvbnRhaW5zIG5vIGRhdGEnKVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaXRjb2luLkVDS2V5KHByaXZhdGVLZXlXSUYsIHRydWUpXG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXk6IGFyZSB5b3Ugc3VyZSBpdCBpcyBwcm9wZXJseSBXSUZmZWQ/JywgW3ByaXZhdGVLZXlXSUYsIGVycl0pXG4gICAgfVxufVxuXG4vKipcbiAqIGNyeXB0IHdpZiB0byBwdWJsaWMgdHJ5XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHB1YmxpY0tleVdJRlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuRUIuQ3J5cHRvLndpZlRvUHViS2V5ID0gZnVuY3Rpb24ocHVibGljS2V5V0lGKSB7XG4gICAgaWYoIXB1YmxpY0tleVdJRilcbiAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ1RoYXQgcHVibGljIGtleSB3aWYgY29udGFpbnMgbm8gZGF0YScpXG5cbiAgICB0cnkge1xuICAgICAgICB2YXIgcHVia2V5Qnl0ZXMgPSBCaXRjb2luLmJhc2U1OGNoZWNrLmRlY29kZShwdWJsaWNLZXlXSUYpLnBheWxvYWQudG9KU09OKClcbiAgICAgICAgcHVia2V5Qnl0ZXMgPSBwdWJrZXlCeXRlcy5kYXRhIHx8IHB1YmtleUJ5dGVzXG4gICAgICAgIHJldHVybiBuZXcgQml0Y29pbi5FQ1B1YktleShwdWJrZXlCeXRlcywgdHJ1ZSlcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICByZXR1cm4gRUIub25FcnJvcignSW52YWxpZCBwdWJsaWMga2V5OiBhcmUgeW91IHN1cmUgaXQgaXMgcHJvcGVybHkgV0lGZmVkPycsIFtwdWJsaWNLZXlXSUYsIGVycl0pXG4gICAgfVxufVxuXG5cbi8qKlxuICogY3J5cHQgcHVmZiB0byBzdHJpbmcgd2l0aG91dCBzaWdcbiAqIEBwYXJhbSAge29iamVjdH0gcHVmZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5FQi5DcnlwdG8ucHVmZlRvU2lnbGVzc1N0cmluZyA9IGZ1bmN0aW9uKHB1ZmYpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocHVmZiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge2lmKGtleSA9PSAnc2lnJykgcmV0dXJuIHVuZGVmaW5lZDsgcmV0dXJuIHZhbHVlfSlcbn1cblxuXG4vKipcbiAqIENvbnZlcnQgYSBwYXNzcGhyYXNlIHRvIGEgcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSAge3N0cmluZ30gcGFzc3BocmFzZVxuICogQHJldHVybiB7c3RyaW5nfSBwcml2YXRlIGtleSBXSUZcbiAqL1xuRUIuQ3J5cHRvLnBhc3NwaHJhc2VUb1ByaXZhdGVLZXlXaWYgPSBmdW5jdGlvbihwYXNzcGhyYXNlKSB7XG4gICAgdmFyIGhhc2hTdHIgPSBCaXRjb2luLkNyeXB0by5TSEEyNTYocGFzc3BocmFzZSkudG9TdHJpbmcoKVxuICAgIHZhciBoYXNoID0gQml0Y29pbi5jb252ZXJ0LmhleFRvQnl0ZXMoaGFzaFN0cilcbiAgICByZXR1cm4gQml0Y29pbi5FQ0tleShoYXNoKS50b1dpZigpXG59XG5cblxuLyoqXG4gKiBFbmNyeXB0IGEgc3RyaW5nIHdpdGggQUVTXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbkVCLkNyeXB0by5lbmNyeXB0V2l0aEFFUyA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGtleSkge1xuICAgIGlmKHR5cGVvZiBtZXNzYWdlICE9ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gRUIub25FcnJvcignVGhlIG1lc3NhZ2UgdG8gZW5jcnlwdFdpdGhBRVMgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgaWYodHlwZW9mIGtleSAhPSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ1RoZSBrZXkgdG8gZW5jcnlwdFdpdGhBRVMgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgICAgIFxuICAgIHZhciBlbmMgPSBCaXRjb2luLkNyeXB0by5BRVMuZW5jcnlwdChtZXNzYWdlLCBrZXkpXG4gICAgcmV0dXJuIEJpdGNvaW4uQ3J5cHRvLmZvcm1hdC5PcGVuU1NMLnN0cmluZ2lmeShlbmMpXG59XG5cblxuLyoqXG4gKiBEZWNyeXB0IGEgc3RyaW5nIHdpdGggQUVTXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNpcGhlcnRleHRcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbkVCLkNyeXB0by5kZWNyeXB0V2l0aEFFUyA9IGZ1bmN0aW9uKGNpcGhlcnRleHQsIGtleSkge1xuICAgIGlmKCFrZXkgfHwgIWNpcGhlcnRleHQpIHJldHVybiBmYWxzZVxuXG4gICAgaWYodHlwZW9mIGNpcGhlcnRleHQgIT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBFQi5vbkVycm9yKCdUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0V2l0aEFFUyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICBpZih0eXBlb2Yga2V5ICE9ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gRUIub25FcnJvcignVGhlIGtleSB0byBkZWNyeXB0V2l0aEFFUyBtdXN0IGJlIGEgc3RyaW5nJylcblxuICAgIHZhciBtZXNzYWdlID0gQml0Y29pbi5DcnlwdG8uZm9ybWF0Lk9wZW5TU0wucGFyc2UoY2lwaGVydGV4dClcbiAgICB2YXIgd29yZHMgPSBCaXRjb2luLkNyeXB0by5BRVMuZGVjcnlwdChtZXNzYWdlLCBrZXkpXG4gICAgdmFyIGJ5dGVzID0gQml0Y29pbi5jb252ZXJ0LndvcmRzVG9CeXRlcyh3b3Jkcy53b3JkcykgXG4gICAgLy8gdmFyIHVnbHlSZWdleCA9IC9bXFx1MDAwMlxcdTAwMDRcXHUwMDA3XFx1MDAwZV0rJC9nXG4gICAgdmFyIHVnbHlSZWdleCA9IC9bXFx1MDAwMC1cXHUwMDEwXSskL2cgLy8gVE9ETzogY29udGFpbiBBRVMgcGFkZGluZ1xuICAgIHJldHVybiBieXRlcy5tYXAoZnVuY3Rpb24oeCkge3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpfSkuam9pbignJykucmVwbGFjZSh1Z2x5UmVnZXgsICcnKVxufVxuXG5cbi8qKlxuICogR2V0IHRoZSBzaGFyZWQgc2VjcmV0IG9mIHR3byB1c2Vyc1xuICogQHBhcmFtICB7c3RyaW5nfSB5b3VyUHVibGljV2lmXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG15UHJpdmF0ZVdpZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5FQi5DcnlwdG8uZ2V0T3VyU2hhcmVkU2VjcmV0ID0gZnVuY3Rpb24oeW91clB1YmxpY1dpZiwgbXlQcml2YXRlV2lmKSB7XG4gICAgLy8gVE9ETzogdW5pdCB0ZXN0aW5nIGZvciBFQ0RIIG1hdGhzXG4gICAgdmFyIHB1YmtleSA9IEVCLkNyeXB0by53aWZUb1B1YktleSh5b3VyUHVibGljV2lmKVxuICAgIHZhciBwcmlrZXkgPSBFQi5DcnlwdG8ud2lmVG9QcmlLZXkobXlQcml2YXRlV2lmKVxuICAgIGlmKCFwdWJrZXkgfHwgIXByaWtleSkgcmV0dXJuIGZhbHNlICBcbiAgICB2YXIgc2VjcmV0ID0gcHVia2V5Lm11bHRpcGx5KHByaWtleSkudG9XaWYoKVxuICAgIHZhciBrZXkgPSBCaXRjb2luLkNyeXB0by5TSEEyNTYoc2VjcmV0KS50b1N0cmluZygpXG4gICAgXG4gICAgcmV0dXJuIGtleVxufVxuXG5cbi8qKlxuICogRW5jcnlwdCBhIHByaXZhdGUgbWVzc2FnZVxuICogQHBhcmFtICB7c3RyaW5nfSBwbGFpbnRleHRcbiAqIEBwYXJhbSAge3N0cmluZ30geW91clB1YmxpY1dpZlxuICogQHBhcmFtICB7c3RyaW5nfSBteVByaXZhdGVXaWZcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuRUIuQ3J5cHRvLmVuY3J5cHRQcml2YXRlTWVzc2FnZSA9IGZ1bmN0aW9uKHBsYWludGV4dCwgeW91clB1YmxpY1dpZiwgbXlQcml2YXRlV2lmKSB7XG4gICAgdmFyIGtleSA9IEVCLkNyeXB0by5nZXRPdXJTaGFyZWRTZWNyZXQoeW91clB1YmxpY1dpZiwgbXlQcml2YXRlV2lmKVxuICAgIGlmKCFrZXkpIHJldHVybiBmYWxzZVxuICAgIHZhciBjaXBoZXJ0ZXh0ID0gRUIuQ3J5cHRvLmVuY3J5cHRXaXRoQUVTKHBsYWludGV4dCwga2V5KVxuICAgIHJldHVybiBjaXBoZXJ0ZXh0XG59XG5cblxuLyoqXG4gKiBEZWNyeXB0IGEgcHJpdmF0ZSBtZXNzYWdlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBsYWludGV4dFxuICogQHBhcmFtICB7c3RyaW5nfSB5b3VyUHVibGljV2lmXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG15UHJpdmF0ZVdpZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5FQi5DcnlwdG8uZGVjcnlwdFByaXZhdGVNZXNzYWdlID0gZnVuY3Rpb24oY2lwaGVydGV4dCwgeW91clB1YmxpY1dpZiwgbXlQcml2YXRlV2lmKSB7XG4gICAgdmFyIGtleSA9IEVCLkNyeXB0by5nZXRPdXJTaGFyZWRTZWNyZXQoeW91clB1YmxpY1dpZiwgbXlQcml2YXRlV2lmKVxuICAgIGlmKCFrZXkgfHwgIWNpcGhlcnRleHQpIHJldHVybiBmYWxzZVxuICAgIHZhciBwbGFpbnRleHQgPSBFQi5DcnlwdG8uZGVjcnlwdFdpdGhBRVMoY2lwaGVydGV4dCwga2V5KVxuICAgIHJldHVybiBwbGFpbnRleHQgLy8gLnJlcGxhY2UoL1xcbiskL2csICcnKVxufVxuXG5cbi8qKlxuICogR2V0IHRoZSAna2V5cycgb2JqZWN0IGZvciBhIHByaXZhdGUgcHVmZlxuICogQHBhcmFtICB7c3RyaW5nfSBwdWZma2V5XG4gKiBAcGFyYW0gIHtzdHJpbmd9IG15UHJpdmF0ZVdpZlxuICogQHBhcmFtICB7b2JqZWN0fSB1c2VyUmVjb3Jkc1xuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5FQi5DcnlwdG8uY3JlYXRlS2V5UGFpcnMgPSBmdW5jdGlvbihwdWZma2V5LCBteVByaXZhdGVXaWYsIHVzZXJSZWNvcmRzKSB7XG4gICAgaWYoIUFycmF5LmlzQXJyYXkodXNlclJlY29yZHMpKVxuICAgICAgICByZXR1cm4gRUIudGhyb3dFcnJvcignSW52YWxpZCB1c2VyUmVjb3JkcycpXG4gICAgXG4gICAgcmV0dXJuIHVzZXJSZWNvcmRzLnJlZHVjZShmdW5jdGlvbihhY2MsIHVzZXJSZWNvcmQpIHtcbiAgICAgICAgdmFyIHZlcnNpb25lZFVzZXJuYW1lID0gRUIuVXNlcnMudXNlclJlY29yZFRvVmVyc2lvbmVkVXNlcm5hbWUodXNlclJlY29yZClcbiAgICAgICAgYWNjW3ZlcnNpb25lZFVzZXJuYW1lXSA9IEVCLkNyeXB0by5lbmNyeXB0UHJpdmF0ZU1lc3NhZ2UocHVmZmtleSwgdXNlclJlY29yZC5kZWZhdWx0S2V5LCBteVByaXZhdGVXaWYpXG4gICAgICAgIHJldHVybiBhY2NcbiAgICB9LCB7fSlcbn1cblxuXG4vLyBFQi5DcnlwdG8udmVyaWZ5QmxvY2sgPSBmdW5jdGlvbihibG9jaywgcHVibGljS2V5QmFzZTU4KSB7XG4vLyAgICAgcmV0dXJuIEVCLkNyeXB0by52ZXJpZnlNZXNzYWdlKGJsb2NrLmJsb2NrUGF5bG9hZCwgYmxvY2suYmxvY2tTaWcucmVwbGFjZSgvXFwqL2csIFwiXCIpLCBwdWJsaWNLZXlCYXNlNTgpO1xuLy8gfVxuXG4vLyBFQi5DcnlwdG8uc2lnbkJsb2NrID0gZnVuY3Rpb24oYmxvY2tQYXlsb2FkLCBwcml2YXRlS2V5V0lGKSB7XG4vLyAgICAgcmV0dXJuIEVCLkNyeXB0by5zaWduUGF5bG9hZChibG9ja1BheWxvYWQsIHByaXZhdGVLZXlXSUYpO1xuLy8gfVxuXG5cblxuLy8vLyBSYW5kb21uZXNzIGVuaGFuY2VtZW50c1xuXG5cblxuLyoqXG4gKiBHZXQgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5FQi5DcnlwdG8ucmFuZG9tID0gZnVuY3Rpb24oKSB7IFxuICAgIC8vIGp1c3QgbGlrZSBNYXRoLnJhbmRvbSwgYnV0IGJldHRlclxuICAgIC8vIHZpYSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzNjk0NjI2L2dlbmVyYXRpbmctcmFuZG9tLW51bWJlcnMtMC10by0xLXdpdGgtY3J5cHRvLWdlbmVyYXRldmFsdWVzXG5cbiAgICB2YXIgbGlzdCA9IEVCLkNyeXB0by5nZXRSYW5kb21WYWx1ZXMoMiwgMzIpXG5cbiAgICAvLyBrZWVwIGFsbCAzMiBiaXRzIG9mIHRoZSB0aGUgZmlyc3QsIHRvcCAyMCBvZiB0aGUgc2Vjb25kIGZvciA1MiByYW5kb20gYml0c1xuICAgIHZhciBtYW50aXNzYSA9IChsaXN0WzBdICogTWF0aC5wb3coMiwyMCkpICsgKGxpc3RbMV0gPj4gMTIpXG5cbiAgICAvLyBzaGlmdCBhbGwgNTIgYml0cyB0byB0aGUgcmlnaHQgb2YgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICB2YXIgcmVzdWx0ID0gbWFudGlzc2EgKiBNYXRoLnBvdygyLC01MilcbiAgICBcbiAgICByZXR1cm4gcmVzdWx0XG4gICAgXG4gICAgLy8gdmFyIGxvZzIgPSBNYXRoLmxvZyhtYXgpIC8gTWF0aC5MTjJcbiAgICAvLyB2YXIgc2l6ZSA9IE1hdGguY2VpbChsb2cyKSArIDEgLy8gTk9URTogdGhpcyBpcyBhYm91dCA4IHRpbWVzIGhpZ2hlciB0aGFuIG5lY2Vzc2FyeVxufVxuXG5cbi8qKlxuICogR2V0IGEgcmFuZG9tIGludGVnZXJcbiAqIEBwYXJhbSAge251bWJlcn0gTWF4aW11bSBpbnRlZ2VyLiBEZWZhdWx0cyB0byAyXjMxIC0gMSwgdGhlIGxhcmdlc3QgYml0b3Agc2FmZSBpbnRlZ2VyLlxuICogQHBhcmFtICB7bnVtYmVyfSBNaW5pbXVtIGludGVnZXIuIERlZmF1bHRzIHRvIDAuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkVCLkNyeXB0by5nZXRSYW5kb21JbnRlZ2VyID0gZnVuY3Rpb24obWF4LCBtaW4pIHsgXG4gICAgLy8gTk9URTogbWluIGlzIGluY2x1c2l2ZSwgbWF4IGlzIGV4Y2x1c2l2ZVxuICAgIC8vIFRPRE86IGVycm9yIGlmIG1heCBhbmQgbWluIGFyZSBub3QgcHJvcGVyIChub24tTmFOKSBudW1iZXJzXG4gICAgbWluID0gTWF0aC5mbG9vcihtaW4gfHwgMClcbiAgICBtYXggPSBNYXRoLmZsb29yKG1heCB8fCAweDdmZmZmZmZmKSAvLyAweDdmZmZmZmZmID09IE1hdGgucG93KDIsIDMxKSAtIDEsIHRoZSBsYXJnZXN0IGJpdG9wIHNhZmUgaW50XG4gICAgdmFyIHJhbmdlID0gbWF4IC0gbWluXG4gICAgdmFyIHJhbmRGbG9hdCA9IEVCLkNyeXB0by5yYW5kb20oKVxuICAgIHJldHVybiBNYXRoLmZsb29yKHJhbmRGbG9hdCpyYW5nZSArIG1pbilcbn1cblxuXG4vKipcbiAqIEdldCBhIHJhbmRvbSBpdGVtIGZyb20gYSBsaXN0XG4gKiBAcGFyYW0gIHsoYXJyYXl8c3RyaW5nKX0gQW4gYXJyYXkgb3Igc3RyaW5nIGZyb20gd2hpY2ggdG8gY2hvb3NlIGFuIGVsZW1lbnRcbiAqIEByZXR1cm4ge2FueX0gXG4gKi9cbkVCLkNyeXB0by5nZXRSYW5kb21JdGVtID0gZnVuY3Rpb24obGlzdCkge1xuICAgIC8vIFRPRE86IGVycm9yIGlmIGxpc3QgaXMgbm90IGFuIGFycmF5IG9yIHN0cmluZ1xuICAgIHZhciBpbmRleCA9IEVCLkNyeXB0by5nZXRSYW5kb21JbnRlZ2VyKGxpc3QubGVuZ3RoKVxuICAgIHJldHVybiBsaXN0W2luZGV4XVxufVxuXG5cbi8qKlxuICogR2V0IGEgbmV3IEFFUyBrZXlcbiAqIEBwYXJhbSAge251bWJlcn0gbGVuIExlbmd0aCBpbiBieXRlcyAoZGVmYXVsdHMgdG8gMjU2IGJpdHMpXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFFUyBrZXlcbiAqL1xuRUIuQ3J5cHRvLmdldFJhbmRvbUtleSA9IGZ1bmN0aW9uKGxlbikge1xuICAgIGxlbiA9IGxlbiB8fCAyNTYvOCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQUVTIGtleSBzaXplIGlzIDI1NiBiaXRzXG4gICAgdmFyIGJ5dGVzID0gRUIuQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhsZW4sIDgpXG4gICAgLy8gdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAvLyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKVxuICAgIHJldHVybiBCaXRjb2luLmNvbnZlcnQuYnl0ZXNUb0Jhc2U2NChieXRlcylcbn1cblxuXG4vKipcbiAqIEEgd3JhcHBlciBmb3IgY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICogQHBhcmFtICB7bnVtYmVyfSBOdW1iZXIgb2Ygc2FtcGxlcyBcbiAqIEBwYXJhbSAge251bWJlcn0gU2l6ZSBvZiBzYW1wbGVzIGluIGJpdHMgKDMyIG9yIDgsIGRlZmF1bHRzIHRvIDgpXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuRUIuQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9IGZ1bmN0aW9uKG51bWJlciwgc2l6ZSkge1xuICAgIGlmKHdpbmRvdy5jcnlwdG8gJiYgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgdmFyIGJ5dGVzXG4gICAgICAgIGlmKHNpemUgPT0gMzIpXG4gICAgICAgICAgICBieXRlcyA9IG5ldyBVaW50MzJBcnJheShudW1iZXIpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobnVtYmVyKVxuICAgIFxuICAgICAgICByZXR1cm4gd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpXG4gICAgfVxuXG4gICAgcmV0dXJuIEVCLkNyeXB0by5nZXRSYW5kb21WYWx1ZXNTaGltKG51bWJlciwgc2l6ZSlcbn1cblxuXG4vKipcbiAqIEEgc2hpbSBmb3IgY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICogQHBhcmFtICB7bnVtYmVyfSBOdW1iZXIgb2Ygc2FtcGxlcyBcbiAqIEBwYXJhbSAge251bWJlcn0gU2l6ZSBvZiBzYW1wbGVzIGluIGJpdHMgKDMyIG9yIDgsIGRlZmF1bHRzIHRvIDgpXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuRUIuQ3J5cHRvLmdldFJhbmRvbVZhbHVlc1NoaW0gPSBmdW5jdGlvbihudW1iZXIsIHNpemUpIHtcbiAgICAvLyB2aWEgaHR0cHM6Ly9naXRodWIuY29tL2V2YW52b3NiZXJnL2NyeXB0by1qcy9pc3N1ZXMvN1xuICAgIC8vIGZhbGxiYWNrIGZvciBvbGQgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGNyeXB0by5nZXRSYW5kb21WYWx1ZXNcbiAgICAvLyBiZXR0ZXIgdGhhbiBwbGFpbiBNYXRoLnJhbmRvbSgpLCB3b3JzZSB0aGFuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoKVxuICAgIHZhciB3b3JkcyA9IFtdO1xuXG4gICAgdmFyIHIgPSAoZnVuY3Rpb24gKG1fdykge1xuICAgICAgICB2YXIgbV93ID0gbV93O1xuICAgICAgICB2YXIgbV96ID0gMHgzYWRlNjhiMTtcbiAgICAgICAgdmFyIG1hc2sgPSAweGZmZmZmZmZmO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtX3ogPSAoMHg5MDY5ICogKG1feiAmIDB4RkZGRikgKyAobV96ID4+IDB4MTApKSAmIG1hc2s7XG4gICAgICAgICAgICBtX3cgPSAoMHg0NjUwICogKG1fdyAmIDB4RkZGRikgKyAobV93ID4+IDB4MTApKSAmIG1hc2s7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gKChtX3ogPDwgMHgxMCkgKyBtX3cpICYgbWFzaztcbiAgICAgICAgICAgIHJlc3VsdCAvPSAweDEwMDAwMDAwMDtcbiAgICAgICAgICAgIHJlc3VsdCArPSAwLjU7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKE1hdGgucmFuZG9tKCkgPiAuNSA/IDEgOiAtMSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCByY2FjaGU7IGkgPCBudW1iZXI7IGkgKz0gNCkge1xuICAgICAgICB2YXIgX3IgPSByKChyY2FjaGUgfHwgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwMDAwMCk7XG5cbiAgICAgICAgcmNhY2hlID0gX3IoKSAqIDB4M2FkZTY3Yjc7XG5cbiAgICAgICAgaWYoc2l6ZSA9PSAzMikge1xuICAgICAgICAgICAgd29yZHMucHVzaChNYXRoLmFicyggKF9yKCkgKiAweDEwMDAwMDAwMCkgfCAwICkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSB3YW50IGJ5dGVzIGluc3RlYWQgb2YgMzItYml0IGNodW5rc1xuICAgICAgICAgICAgdmFyIGludDMyID0gKF9yKCkgKiAweDEwMDAwMDAwMCkgfCAwO1xuICAgICAgICAgICAgd29yZHMucHVzaChNYXRoLmFicyhpbnQzMiAmIDB4RkYwMDAwMDApID4+IDI0KTtcbiAgICAgICAgICAgIHdvcmRzLnB1c2goTWF0aC5hYnMoaW50MzIgJiAweDAwRkYwMDAwKSA+PiAxNik7XG4gICAgICAgICAgICB3b3Jkcy5wdXNoKE1hdGguYWJzKGludDMyICYgMHgwMDAwRkYwMCkgPj4gOCk7XG4gICAgICAgICAgICB3b3Jkcy5wdXNoKE1hdGguYWJzKGludDMyICYgMHgwMDAwMDBGRikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmRzO1xufSIsIi8qXG5cbiAgICBEYXRhIG1hbmFnZW1lbnQgZm9yIHRoZSBFdmVyeUJpdCBwbGF0Zm9ybS5cbiAgICBcbiAgICBBbGwgcHVmZi1yZWxhdGVkIGRhdGEgZmxvd3MgdGhyb3VnaCBoZXJlOlxuICAgIGNhY2hpbmcsIHBlcnNpc3RlbmNlLCBvcHRpbWl6YXRpb25zIGFuZCBuZXR3b3JrIGFjY2VzcyBhcmUgbWFuYWdlZCB0aHJvdWdoIHRoaXMgbW9kdWxlLlxuXG4gICAgQ29weXJpZ2h0IDIwMTQtMjAxNSBFdmVyeUJpdC4gU2VlIFJFQURNRSBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuICovXG5cbkVCLkRhdGEgPSB7fVxuRUIuRGF0YS5ib25paSA9IHt9XG5FQi5EYXRhLnNoZWxscyA9IFtdXG5FQi5EYXRhLnNoZWxsU29ydCA9IHt9XG5FQi5EYXRhLnBlbmRpbmdQdWZmUHJvbWlzZXMgPSB7fVxuXG5FQi5EYXRhLnByb2ZpbGVzID0ge31cblxuRUIuRGF0YS5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIC8vIFRISU5LOiBkaXNhYmxpbmcgcHJlbG9hZGluZyBtYXkgYWZmZWN0IG9sZGVyIEVCIGV4YW1wbGUgY29kZVxuICAgIC8vIGlmKCFvcHRpb25zLmRpc2FibGVQdWJsaWNQdWZmcylcbiAgICAvLyAgICAgRUIuRGF0YS5pbXBvcnRTaGVsbHMoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZWxvYWQgcmVsZXZhbnQgc2hlbGxzXG4gICAgRUIuYWRkQmVmb3JlU3dpdGNoSWRlbnRpdHlIYW5kbGVyKEVCLkRhdGEucmVtb3ZlQWxsUHJpdmF0ZVNoZWxscykgICAvLyBjbGVhciBwcml2YXRlIGNhY2hlcyBvbiBpZCBjaGFuZ2Vcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLyBuZXcgZ3JhcGggc3R1ZmYgLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuRUIuRGF0YS5hZGRTaWdBc1ZlcnRleCA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHZhciBtYXRjaGVzID0gRUIuRGF0YS5ncmFwaC52KHNpZykucnVuKClcbiAgICBcbiAgICBpZihtYXRjaGVzLmxlbmd0aCkgcmV0dXJuIGZhbHNlICAgICAgICAgLy8gcmV0dXJucyBmYWxzZSBpZiBub3RoaW5nIGhhcHBlbnNcbiAgICBcbiAgICByZXR1cm4gRUIuRGF0YS5ncmFwaC5hZGRWZXJ0ZXgoe19pZDogc2lnLCBuYW1lOiBzaWcsIHR5cGU6ICdzaGVsbCd9KSB8fCB0cnVlXG59XG5cbkVCLkRhdGEuYWRkU2hlbGxBc1ZlcnRleCA9IGZ1bmN0aW9uKHNoZWxsKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBFQi5EYXRhLmdyYXBoLnYoc2hlbGwuc2lnKS5ydW4oKVxuICAgIFxuICAgIGlmKCFtYXRjaGVzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIEVCLkRhdGEuZ3JhcGguYWRkVmVydGV4KHsgX2lkOiBzaGVsbC5zaWcsIG5hbWU6IHNoZWxsLnNpZywgc2hlbGw6IHNoZWxsLCB0eXBlOiAnc2hlbGwnIH0pIHx8IHRydWVcbiAgICBcbiAgICB2YXIgdmVydGV4ID0gbWF0Y2hlc1swXVxuICAgIGlmKHZlcnRleC5zaGVsbCkgcmV0dXJuIGZhbHNlICAgICAgICAgICAvLyBOT1RFOiByZXR1cm5zIGZhbHNlIGlmIGl0IGRvZXMgbm90aGluZ1xuICAgIFxuICAgIHJldHVybiB2ZXJ0ZXguc2hlbGwgPSBzaGVsbCAgICAgICAgICAgICAvLyBOT1RFOiBtdXRhdGlvbiAmIHBvaW50ZXIgc2V0dGluZ1xufVxuXG5FQi5EYXRhLmFkZFNoZWxsVXNlcm5hbWVBc1ZlcnRleCA9IGZ1bmN0aW9uKHNoZWxsKSB7XG4gICAgLy8vLyBhZGQgc2hlbGwudXNlcm5hbWUgdG8gZ3JhcGggYW5kIGNvbm5lY3QgdGhlbSB1cFxuICAgIFxuICAgIHZhciB1c2VybmFtZSA9IHNoZWxsLnVzZXJuYW1lXG4gICAgdmFyIG1hdGNoZXMgPSBFQi5EYXRhLmdyYXBoLnYodXNlcm5hbWUpLnJ1bigpXG4gICAgdmFyIHZlcnRleCA9IG1hdGNoZXNbMF1cbiAgICBcbiAgICBpZighdmVydGV4KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVEhJTks6IG1ha2UgdXNlcm5hbWVzIHVuaXF1ZSBsaWtlIFVTRVJOQU1FOjo8dXNlcm5hbWU+IG9yIHNvbWV0aGluZ1xuICAgICAgICB2ZXJ0ZXggPSBFQi5EYXRhLmdyYXBoLmFkZFZlcnRleCh7IF9pZDogdXNlcm5hbWUsIG5hbWU6IHVzZXJuYW1lLCB0eXBlOiAndXNlcm5hbWUnIH0pXG4gICAgZWxzZVxuICAgICAgICBpZihFQi5EYXRhLmdyYXBoLnYoc2hlbGwuc2lnKS5vdXQoJ2F1dGhvcicpLnByb3BlcnR5KCduYW1lJykucnVuKClbMF0gPT0gdXNlcm5hbWUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgXG4gICAgLy8gVE9ETzogYWRkIGVhc3kgZmlsdGVyaW5nIGJ5IHZlcnRleCB0eXBlIGZvciBib3RoICd2JyBhbmQgYWxzbyBvdXRWIGV0Y1xuICAgIEVCLkRhdGEuZ3JhcGguYWRkRWRnZSh7IF9vdXQ6IHNoZWxsLnNpZywgX2luOiBzaGVsbC51c2VybmFtZSwgX2xhYmVsOiAnYXV0aG9yJ30pXG59XG5cbkVCLkRhdGEuZ3JhcGggPSBEYWdvYmEuZ3JhcGgoKVxuXG5FQi5EYXRhLmFkZFRvR3JhcGggPSBmdW5jdGlvbihzaGVsbHMpIHtcbiAgICBzaGVsbHMuZm9yRWFjaChFQi5EYXRhLmFkZFNoZWxsQXNWZXJ0ZXgpXG4gICAgc2hlbGxzLmZvckVhY2goRUIuRGF0YS5hZGRTaGVsbFVzZXJuYW1lQXNWZXJ0ZXgpXG4gICAgRUIucnVuSGFuZGxlcnMoJ3JlbGF0aW9uc2hpcCcsIHNoZWxscylcbn1cblxuLy8gVE9ETzogYWxpYXMgY2hpbGRyZW4oKSBhcyAuaW4oJ3BhcmVudCcpIGFuZCBwYXJlbnRzKCkgYXMgLm91dCgncGFyZW50JykgYW5kIHVzZSB0aG9zZSBpbnN0ZWFkIChoYWx2ZXMgIyBvZiBlZGdlcylcblxuLy8vLy8vLy8vLy8vLy8vLy8gZW5kIG5ldyBncmFwaCBzdHVmZiAvLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbi8vLy8gQ09OVEVOVCBUWVBFUyAvLy8vXG5cbkVCLkRhdGEuY29udGVudFR5cGVzID0ge31cblxuLy8gVE9ETzogdGhpcyBtaWdodCBnZXQgYmlnLCBuZWVkIHNvbWUgR0MgaGVyZVxuRUIuRGF0YS5wdWZmQ29udGVudFN0YXNoID0ge31cblxuRUIuRGF0YS5jbGVhclB1ZmZDb250ZW50U3Rhc2ggPSBmdW5jdGlvbigpIHtcbiAgICBFQi5EYXRhLnB1ZmZDb250ZW50U3Rhc2ggPSB7fVxufVxuXG5cbi8qKlxuICogdG8gcHJvY2VzcyB0aGUgY29udGVudFxuICogQHBhcmFtICB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSAge3B1ZmZ9IHB1ZmZcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuRUIuRGF0YS5wcm9jZXNzQ29udGVudCA9IGZ1bmN0aW9uKHR5cGUsIGNvbnRlbnQsIHB1ZmYpIHtcbiAgICB2YXIgdHlwZU9iaiA9IEVCLkRhdGEuY29udGVudFR5cGVzW3R5cGVdXG4gICAgXG4gICAgaWYoIXR5cGVPYmopXG4gICAgICAgIHR5cGVPYmogPSBFQi5EYXRhLmNvbnRlbnRUeXBlc1sndGV4dCddXG5cbiAgICByZXR1cm4gdHlwZU9iai50b0h0bWwoY29udGVudCwgcHVmZilcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgY29udGVudCBvZiBhIHB1ZmZcbiAqIEBwYXJhbSAge3B1ZmZ9IHB1ZmZcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuRUIuRGF0YS5nZXRQcm9jZXNzZWRQdWZmQ29udGVudCA9IGZ1bmN0aW9uKHB1ZmYpIHtcbiAgICAvLyBUSElOSzogd2UndmUgYWxyZWFkeSBlbnN1cmVkIHRoZXNlIGFyZSBwcm9wZXIgcHVmZnMsIHNvIHdlIGRvbid0IGhhdmUgdG8gY2hlY2sgZm9yIHBheWxvYWQuLi4gcmlnaHQ/XG4gICAgaWYoRUIuRGF0YS5wdWZmQ29udGVudFN0YXNoW3B1ZmYuc2lnXSlcbiAgICAgICAgcmV0dXJuIEVCLkRhdGEucHVmZkNvbnRlbnRTdGFzaFtwdWZmLnNpZ11cbiAgICBcbiAgICB2YXIgY29udGVudCA9IEVCLkRhdGEucHJvY2Vzc0NvbnRlbnQocHVmZi5wYXlsb2FkLnR5cGUsIHB1ZmYucGF5bG9hZC5jb250ZW50LCBwdWZmKVxuICAgIEVCLkRhdGEucHVmZkNvbnRlbnRTdGFzaFtwdWZmLnNpZ10gPSBjb250ZW50XG4gICAgXG4gICAgcmV0dXJuIGNvbnRlbnRcbn1cblxuLyoqXG4gKiBBZGQgc3VwcG9ydCBmb3IgdHlwZXMgb2YgY29udGVudCB0byB0aGUgc3lzdGVtXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqL1xuRUIuRGF0YS5hZGRDb250ZW50VHlwZSA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUpIHtcbiAgICAvLyBUSElOSzogbW92ZSB0aGlzIGRvd24gaW50byBFQj9cbiAgICBcbiAgICBpZighbmFtZSkgXG4gICAgICAgIHJldHVybiBFQi5vbkVycm9yKCdJbnZhbGlkIGNvbnRlbnQgdHlwZSBuYW1lJylcbiAgICBpZihFQi5DT05GSUcuc3VwcG9ydGVkQ29udGVudFR5cGVzICYmIEVCLkNPTkZJRy5zdXBwb3J0ZWRDb250ZW50VHlwZXMuaW5kZXhPZihuYW1lKSA9PSAtMSlcbiAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvbnRlbnQgdHlwZTogJyArIG5hbWUpXG4gICAgaWYoIXR5cGUudG9IdG1sKSBcbiAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ0ludmFsaWQgY29udGVudCB0eXBlOiBvYmplY3QgaXMgbWlzc2luZyB0b0h0bWwgbWV0aG9kJywgbmFtZSlcbiAgICBcbiAgICBFQi5EYXRhLmNvbnRlbnRUeXBlc1tuYW1lXSA9IHR5cGVcbn1cblxuLy8vLyBFTkQgQ09OVEVOVCBUWVBFUyAvLy8vXG5cblxuXG5cbkVCLkRhdGEuZ2V0QWxsTXlTaGVsbHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcHVibGljU2hlbGxzID0gRUIuRGF0YS5nZXRQdWJsaWNTaGVsbHMoKVxuICAgIHZhciBwcml2YXRlU2hlbGxzID0gRUIuRGF0YS5nZXRDdXJyZW50RGVjcnlwdGVkTGV0dGVycygpXG4gICAgcmV0dXJuIHB1YmxpY1NoZWxscy5jb25jYXQocHJpdmF0ZVNoZWxscylcbn1cblxuXG4vKipcbiAqIGdldCBhbGwgY3VycmVudGx5IGtub3duIHNoZWxsc1xuICogQHJldHVybiB7U2hlbGxbXX1cbiAqL1xuRUIuRGF0YS5nZXRTaGVsbHMgPSBmdW5jdGlvbigpIHtcbiAgICAvLy8vIEdldCBhbGwgY3VycmVudGx5IGtub3duIHNoZWxsc1xuICAgIC8vIE5PVEU6IGFsd2F5cyB1c2UgdGhpcyBhY2Nlc3NvciBpbnN0ZWFkIG9mIHJlZmVyZW5jaW5nIEVCLkRhdGEuc2hlbGxzIGRpcmVjdGx5LCBhcyB3aGF0IHRoaXMgZnVuY3Rpb24gZG9lcyB3aWxsIGNoYW5nZS5cbiAgICByZXR1cm4gRUIuRGF0YS5zaGVsbHNcbn1cblxuLyoqXG4gKiBnZXQgYWxsIHB1YmxpYyBzaGVsbHNcbiAqIEByZXR1cm5zIHtTaGVsbFtdfVxuICovXG5FQi5EYXRhLmdldFB1YmxpY1NoZWxscyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vLy8gR2V0IGFsbCBwdWJsaWMgc2hlbGxzXG4gICAgdmFyIHNoZWxscyA9IEVCLkRhdGEuZ2V0U2hlbGxzKClcbiAgICByZXR1cm4gc2hlbGxzLmZpbHRlcihmdW5jdGlvbihzaGVsbCkge3JldHVybiAhc2hlbGwua2V5c30pXG59XG5cbi8qKlxuICogR2V0IGNhY2hlZCBzaGVsbHMgYnkgc2lnXG4gKiBAcGFyYW0ge3N0cmluZ30gc2lnXG4gKiBAcmV0dXJucyB7c2hlbGxbXX1cbiAqL1xuRUIuRGF0YS5nZXRDYWNoZWRTaGVsbEJ5U2lnID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgcmV0dXJuIEVCLkRhdGEuc2hlbGxTb3J0W3NpZ11cbiAgICAvLyByZXR1cm4gRUIuRGF0YS5nZXRTaGVsbHMoKS5maWx0ZXIoZnVuY3Rpb24oc2hlbGwpIHsgcmV0dXJuIHNpZyA9PT0gc2hlbGwuc2lnIH0pWzBdXG59XG5cbi8qKlxuICogYWRkcyBib251c1xuICogQHBhcmFtIHtvYmplY3R9IHB1ZmZcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5FQi5EYXRhLmFkZEJvbnVzID0gZnVuY3Rpb24ocHVmZiwga2V5LCB2YWx1ZSkge1xuICAgIC8vLy8gdGhpcyBzaW11bGF0ZXMgYSBXZWFrTWFwXG4gICAgLy8gVEhJTks6IHdlJ2xsIG5lZWQgdG8gcHJvdmlkZSBzb21lIEdDIGhlcmVcbiAgICB2YXIgaWQgPSBwdWZmLnNpZ1xuICAgIFxuICAgIGlmKCFFQi5EYXRhLmJvbmlpW2lkXSlcbiAgICAgICAgRUIuRGF0YS5ib25paVtpZF0gPSB7fVxuICAgIFxuICAgIEVCLkRhdGEuYm9uaWlbaWRdW2tleV0gPSB2YWx1ZVxufVxuXG4vKipcbiAqIGdldHMgYm9udXNcbiAqIEBwYXJhbSBwdWZmXG4gKiBAcGFyYW0ga2V5XG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5FQi5EYXRhLmdldEJvbnVzID0gZnVuY3Rpb24ocHVmZiwga2V5KSB7XG4gICAgLy8vLyBwdWxsIGZyb20gb3VyIEZhdXhXZWFrTWFwXG4gICAgdmFyIGlkID0gcHVmZi5zaWdcbiAgICB2YXIgcHVmZkJvbmlpID0gRUIuRGF0YS5ib25paVtpZF1cbiAgICByZXR1cm4gcHVmZkJvbmlpICYmIHB1ZmZCb25paVtrZXldXG59XG5cblxuXG5cblxuXG5cblxuRUIuRGF0YS5hZGRTdGFyID0gZnVuY3Rpb24oc2lnLCB1c2VybmFtZSwgc3RhcnNpZykge1xuICAgIC8vIFRPRE86IGNvbnNpZGVyIG1vdmluZyB0aGlzIHRvIGEgbW9kdWxlXG4gICAgXG4gICAgdmFyIGZhdXhzaGVsbCA9IHtzaWc6IHNpZ30gLy8gVEhJTks6IGNhbiB3ZSBmb3JtYWxpemUgdGhpcz9cbiAgICB2YXIgc3RhclN0YXRzID0gRUIuRGF0YS5nZXRCb251cyhmYXV4c2hlbGwsICdzdGFyU3RhdHMnKSB8fCB7c2NvcmU6IDAsIGZyb206IHt9fVxuICAgIFxuICAgIHN0YXJTdGF0cy5mcm9tW3VzZXJuYW1lXSA9IHN0YXJzaWcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRtaXR0ZWRseSBzdHJhbmdlLCBidXQgaGVscGZ1bCB3aGVuIHVuc3RhcnJpbmdcbiAgICBzdGFyU3RhdHMuc2NvcmUgPSBFQi5EYXRhLnNjb3JlU3RhcnMoT2JqZWN0LmtleXMoc3RhclN0YXRzLmZyb20pKSAgLy8gT1BUOiBPKG5eMikgaW4gc3RhcnMtcGVyLXB1ZmZcbiAgICBcbiAgICBFQi5EYXRhLmFkZEJvbnVzKGZhdXhzaGVsbCwgJ3N0YXJTdGF0cycsIHN0YXJTdGF0cylcbn1cblxuRUIuRGF0YS5yZW1vdmVTdGFyID0gZnVuY3Rpb24oc2lnLCB1c2VybmFtZSkge1xuICAgIC8vIFRPRE86IGNvbnNpZGVyIG1vdmluZyB0aGlzIHRvIGEgbW9kdWxlXG4gICAgXG4gICAgdmFyIGZhdXhzaGVsbCA9IHtzaWc6IHNpZ30gLy8gVEhJTks6IHllIGdhZHMgaXMgdGhpcyB1Z2x5XG4gICAgdmFyIHN0YXJTdGF0cyA9IEVCLkRhdGEuZ2V0Qm9udXMoZmF1eHNoZWxsLCAnc3RhclN0YXRzJykgfHwge3Njb3JlOiAwLCBmcm9tOiB7fX1cbiAgICBcbiAgICBkZWxldGUgc3RhclN0YXRzLmZyb21bdXNlcm5hbWVdXG4gICAgXG4gICAgc3RhclN0YXRzLnNjb3JlID0gRUIuRGF0YS5zY29yZVN0YXJzKE9iamVjdC5rZXlzKHN0YXJTdGF0cy5mcm9tKSkgIC8vIE9QVDogTyhuXjIpIGluIHN0YXJzLXBlci1wdWZmXG4gICAgXG4gICAgRUIuRGF0YS5hZGRCb251cyhmYXV4c2hlbGwsICdzdGFyU3RhdHMnLCBzdGFyU3RhdHMpXG59XG5cbkVCLkRhdGEuc2NvcmVTdGFycyA9IGZ1bmN0aW9uKHVzZXJuYW1lcykge1xuICAgIFxuICAgIHJldHVybiAwXG4gICAgXG4gICAgLy8gVE9ETzogbW92ZSB0aGlzIGludG8gYSBtb2R1bGVcbiAgICAvKlxuICAgIHZhciB0bHVTY29yZSA9IDA7XG4gICAgdmFyIHN1U2NvcmUgPSAwO1xuICAgIHZhciBzY29yZVByZWYgPSBCb3Jvbi5zaGFsbG93X2NvcHkocHVmZndvcmxkcHJvcHMudmlldy5zY29yZSk7XG4gICAgZm9yICh2YXIgayBpbiBzY29yZVByZWYpIHtcbiAgICAgICAgaWYgKHNjb3JlUHJlZltrXSkge1xuICAgICAgICAgICAgdmFyIHMgPSBwYXJzZUZsb2F0KHNjb3JlUHJlZltrXSk7XG4gICAgICAgICAgICBpZiAoaXNOYU4ocykpXG4gICAgICAgICAgICAgICAgcyA9IHBhcnNlRmxvYXQocHVmZndvcmxkZGVmYXVsdHMudmlldy5zY29yZVtrXSk7XG4gICAgICAgICAgICBzY29yZVByZWZba10gPSBzO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHVzZXJuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKHVzZXJuYW1lKSB7XG4gICAgICAgIGlmICh1c2VybmFtZS5pbmRleE9mKCcuJykgPT0gLTEpIHtcbiAgICAgICAgICAgIHRsdVNjb3JlICs9IHNjb3JlUHJlZi50bHVWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1U2NvcmUgKz0gc2NvcmVQcmVmLnN1VmFsdWU7XG4gICAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIHZhciBzY29yZSA9IHRsdVNjb3JlICsgTWF0aC5taW4oc2NvcmVQcmVmLm1heFN1VmFsdWUsIHN1U2NvcmUpO1xuICAgIHNjb3JlID0gc2NvcmUudG9GaXhlZCgxKTtcbiAgICBpZiAoc2NvcmUgPT0gcGFyc2VJbnQoc2NvcmUpKSBzY29yZSA9IHBhcnNlSW50KHNjb3JlKTtcbiAgICByZXR1cm4gc2NvcmVcbiAgICAqL1xufVxuXG5cbi8qKlxuICogaGFuZGxlIGEgbmV3bHkgY3JlYXRlZCBwdWZmOiBhZGQgdG8gb3VyIGxvY2FsIGNhY2hlIGFuZCBmaXJlIG5ldyBjb250ZW50IGNhbGxiYWNrc1xuICogQHBhcmFtIHtvYmplY3R9IHB1ZmZcbiAqL1xuRUIuRGF0YS5hZGRQdWZmVG9TeXN0ZW0gPSBmdW5jdGlvbihwdWZmKSB7XG4gICAgaWYoRUIuRGF0YS5nZXRDYWNoZWRTaGVsbEJ5U2lnKHB1ZmYuc2lnKSkgcmV0dXJuIGZhbHNlXG4gICAgXG4gICAgRUIuRGF0YS5hZGRTaGVsbHNUaGVuTWFrZUF2YWlsYWJsZShwdWZmKVxuXG4gICAgRUIuTmV0LmRpc3RyaWJ1dGVQdWZmKHB1ZmYpXG4gICAgXG4gICAgcmV0dXJuIHB1ZmZcbn1cblxuXG5cblxuXG5cblxuXG4vKlxuICAgIFNvbWUgbmV3IHNoZWxsIGhhbmRsaW5nIGVxdWlwbWVudC4gTmVlZCB0byBpbnRlZ3JhdGUgdGhpcyBtb3JlIGRlZXBseSBhbmQgY2xlYW4gYW5kIHRlc3QuXG4qL1xuXG5FQi5EYXRhLmFkZFNoZWxsc1RoZW5NYWtlQXZhaWxhYmxlID0gZnVuY3Rpb24oc2hlbGxzKSB7XG4gICAgLy8vLyBhZGRzIHNoZWxscyB0byB0aGUgc3lzdGVtLCB0aGVuIHJldHVybnMgYSByZXBvcnQgb24gaXRzIHByb2dyZXNzXG4gICAgXG4gICAgLy8gcmVwb3J0LmRlbGl2ZXJlZDogMTBcbiAgICAvLyByZXBvcnQudmFsaWQ6IDhcbiAgICAvLyByZXBvcnQubmV3X3NoZWxsczogN1xuICAgIC8vIHJlcG9ydC5uZXdfcHVmZnM6IDVcbiAgICAvLyByZXBvcnQuR0M6IDBcbiAgICBcbiAgICAvLyByZXBvcnQucHVibGljOiAyXG4gICAgLy8gcmVwb3J0LnN0YXJzOiAwXG4gICAgXG4gICAgLy8gcmVwb3J0LnByaXZhdGVfcHJvbWlzZToge3NpZ3M6W10sIGZhaWxlZDogfVxuICAgIFxuICAgIC8vIHJlcG9ydC5wdWJsaWNfcHVmZl9zaWdzOiBbXVxuICAgIFxuICAgIGZ1bmN0aW9uIG5vdChmdW4pIHtyZXR1cm4gZnVuY3Rpb24oeCkge3JldHVybiAhZnVuKHgpfX1cbiAgICBcbiAgICB2YXIgcmVwb3J0ID0ge2NvdW50czoge319XG4gICAgXG4gICAgc2hlbGxzID0gQXJyYXkuaXNBcnJheShzaGVsbHMpID8gc2hlbGxzIDogW3NoZWxsc11cbiAgICByZXBvcnQuY291bnRzLmRlbGl2ZXJlZCA9IHNoZWxscy5sZW5ndGhcbiAgICBcbiAgICBzaGVsbHMgPSBzaGVsbHMuZmlsdGVyKEVCLlNwZWMuaXNWYWxpZFNoZWxsKVxuICAgIHJlcG9ydC5jb3VudHMudmFsaWQgPSBzaGVsbHMubGVuZ3RoXG4gICAgXG4gICAgcmVwb3J0Lm1ldGEgPSBFQi5EYXRhLmhhbmRsZU1ldGFQdWZmcyhzaGVsbHMpXG4gICAgXG4gICAgc2hlbGxzID0gc2hlbGxzLmZpbHRlcihub3QoRUIuRGF0YS5pc01ldGFQdWZmKSlcbiAgICByZXBvcnQuY291bnRzLm5vbm1ldGEgPSBzaGVsbHMubGVuZ3RoXG4gICAgXG4gICAgcmVwb3J0LnByaXZhdGVfcHJvbWlzZSA9IEVCLkRhdGEuaGFuZGxlUHJpdmF0ZVB1ZmZzKHNoZWxscylcbiAgICBcbiAgICBzaGVsbHMgPSBzaGVsbHMuZmlsdGVyKG5vdChFQi5QdWZmLmlzUHJpdmF0ZSkpXG4gICAgcmVwb3J0LmNvdW50cy5wdWJsaWMgPSBzaGVsbHMubGVuZ3RoXG4gICAgXG4gICAgc2hlbGxzID0gRUIuRGF0YS5oYW5kbGVBbmRGaWx0ZXJFeGlzdGluZ1NoZWxscyhzaGVsbHMpXG4gICAgcmVwb3J0LmNvdW50cy5uZXdfcHVibGljID0gcmVwb3J0LmNvdW50cy5wdWJsaWMgLSBzaGVsbHMubGVuZ3RoXG4gICAgXG4gICAgRUIuRGF0YS5oYW5kbGVOZXdQdWJsaWNTaGVsbHMoc2hlbGxzKVxuICAgIFxuICAgIHNoZWxscyA9IEVCLkRhdGEuaGFuZGxlQW5kRmlsdGVyQnlHQyhzaGVsbHMpXG4gICAgcmVwb3J0LmNvdW50cy5nYyA9IHJlcG9ydC5jb3VudHMubmV3X3B1YmxpYyAtIHNoZWxscy5sZW5ndGhcblxuICAgIHJlcG9ydC5wdWJsaWNfcHVmZl9zaWdzID0gc2hlbGxzLm1hcChFQi5wcm9wKCdzaWcnKSlcbiAgICBcbiAgICBFQi5ydW5IYW5kbGVycygnbmV3UHVmZnMnLCBzaGVsbHMpXG4gICAgRUIucnVuSGFuZGxlcnMoJ25ld1B1ZmZSZXBvcnQnLCByZXBvcnQpXG4gICAgXG4gICAgcmV0dXJuIHJlcG9ydFxufVxuXG5cbkVCLkRhdGEuaGFuZGxlTWV0YVB1ZmZzID0gZnVuY3Rpb24oc2hlbGxzKSB7XG4gICAgLy8gVE9ETzogbW92ZSB0aGlzIHRvIGEgbW9kdWxlXG4gICAgdmFyIG1ldGFwdWZmcyA9IHNoZWxscy5maWx0ZXIoRUIuRGF0YS5pc01ldGFQdWZmKVxuICAgIFxuICAgIG1ldGFwdWZmcy5mb3JFYWNoKGZ1bmN0aW9uKHNoZWxsKSB7XG4gICAgICAgIHZhciBzaWcgPSBzaGVsbC5wYXlsb2FkLmNvbnRlbnRcbiAgICAgICAgRUIuRGF0YS5hZGRTdGFyKHNpZywgc2hlbGwudXNlcm5hbWUsIHNoZWxsLnNpZylcbiAgICB9KVxuICAgIFxuICAgIHJldHVybiB7c3RhcnM6IG1ldGFwdWZmcy5sZW5ndGh9XG59XG5cbkVCLkRhdGEuaXNNZXRhUHVmZiA9IGZ1bmN0aW9uKHNoZWxsKSB7XG4gICAgLy8gVE9ETzogbW92ZSB0aGlzIHRvIGEgbW9kdWxlXG4gICAgcmV0dXJuIHNoZWxsLnBheWxvYWQudHlwZSA9PSAnc3RhcicgICAgXG59XG5cblxuRUIuRGF0YS5oYW5kbGVQcml2YXRlUHVmZnMgPSBmdW5jdGlvbihzaGVsbHMpIHtcbiAgICB2YXIgcHJpdmF0ZXB1ZmZzID0gc2hlbGxzLmZpbHRlcihFQi5QdWZmLmlzUHJpdmF0ZSkgICAgXG4gICAgcmV0dXJuIEVCLkRhdGEuaW5nZXN0RW5jcnlwdGVkU2hlbGxzKHByaXZhdGVwdWZmcykgICAgICAgICAgLy8gVE9ETzogdGhpcyByZXR1cm5zIG91ciBwcm9taXNlIHJlcG9ydFxufVxuXG5cbkVCLkRhdGEuaGFuZGxlQW5kRmlsdGVyRXhpc3RpbmdTaGVsbHMgPSBmdW5jdGlvbihzaGVsbHMpIHtcbiAgICAvLyBUSElOSzogdGhpcyBjYW4ndCBhbnN3ZXIgdGhlIHF1ZXN0aW9uIG9mIFwiZGlkIHdlIHVwZGF0ZWQgYW4gZXhpc3Rpbmcgc2hlbGwgd2l0aCBjb250ZW50XCI/XG4gICAgcmV0dXJuIHNoZWxscy5maWx0ZXIoZnVuY3Rpb24oc2hlbGwpIHsgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBhbGwgbmV3IChhbmQgbmV3bHkgZnVsbCkgcHVmZnNcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gRUIuRGF0YS5nZXRDYWNoZWRTaGVsbEJ5U2lnKHNoZWxsLnNpZylcblxuICAgICAgICBpZighZXhpc3RpbmcpIHJldHVybiB0cnVlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgbmV3XG4gICAgICAgIGlmKEVCLlB1ZmYuaXNGdWxsKGV4aXN0aW5nKSkgcmV0dXJuIGZhbHNlICAgICAgICAgICAgICAgLy8gaXQncyBrbm93blxuICAgICAgICBpZihFQi5QdWZmLmlzRW1wdHkoc2hlbGwpKSByZXR1cm4gZmFsc2UgICAgICAgICAgICAgICAgIC8vIGl0J3MgYW4gZW1wdHkgc2hlbGxcblxuICAgICAgICBleGlzdGluZy5wYXlsb2FkLmNvbnRlbnQgPSBzaGVsbC5wYXlsb2FkLmNvbnRlbnQgICAgICAgIC8vIGFkZCB0aGUgbWlzc2luZyBjb250ZW50XG4gICAgICAgIHJldHVybiB0cnVlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBiZWNhdXNlIHdlIGNoYW5nZWQgaXRcbiAgICB9KVxufVxuXG5cbkVCLkRhdGEuaGFuZGxlTmV3UHVibGljU2hlbGxzID0gZnVuY3Rpb24oc2hlbGxzKSB7XG4gICAgc2hlbGxzLmZvckVhY2goZnVuY3Rpb24oc2hlbGwpIHtcbiAgICAgICAgRUIuRGF0YS5zaGVsbHMucHVzaChzaGVsbClcbiAgICAgICAgRUIuRGF0YS5zaGVsbFNvcnRbc2hlbGwuc2lnXSA9IHNoZWxsXG4gICAgfSlcblxuICAgIEVCLkRhdGEuYWRkVG9HcmFwaChzaGVsbHMpXG4gICAgRUIuRGF0YS5yYXRlU29tZVB1ZmZzKHNoZWxscylcbiAgICBFQi5EYXRhLnBlcnNpc3RTaGVsbHMoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcm9wIG5ldyBzdHVmZiBpbnRvIGxvY2FsU3RvcmFnZVxufVxuXG5cbkVCLkRhdGEuaGFuZGxlQW5kRmlsdGVyQnlHQyA9IGZ1bmN0aW9uKHNoZWxscykge1xuICAgIHZhciBjb21wYWN0ZWQgPSBFQi5EYXRhLmdhcmJhZ2VDb21wYWN0b3IoKSAgICAgICAgICAgICAgICAgIC8vIE9QVDogY2FsbCB0aGlzIGVhcmxpZXJcbiAgICBpZighY29tcGFjdGVkKSByZXR1cm4gc2hlbGxzXG4gICAgXG4gICAgcmV0dXJuIHNoZWxscy5tYXAoRUIucHJvcCgnc2lnJykpICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIEdDIGVhdHMgcHVmZnMgdGhpcyBzcGl0cyB0aGVtIG91dFxuICAgICAgICAgICAgICAgICAubWFwKEVCLkRhdGEuZ2V0Q2FjaGVkU2hlbGxCeVNpZylcbiAgICAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxufVxuXG5cbi8qKlxuICogdG8gcGVyc2lzdCBzaGVsbHNcbiAqIEBwYXJhbSB7U2hlbGxbXX1cbiAqIEByZXR1cm5zIHsoYm9vbGVhbnwqKX1cbiAqL1xuRUIuRGF0YS5wZXJzaXN0U2hlbGxzID0gZnVuY3Rpb24oc2hlbGxzKSB7XG4gICAgaWYoRUIuQ09ORklHLm5vTG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2UgICAgICAgICAgICAgICAgICAgICAgLy8gVEhJTks6IHRoaXMgaXMgb25seSBmb3IgZGVidWdnaW5nIGFuZCBkZXZlbG9wbWVudFxuICAgIFxuICAgIC8vIFRISU5LOiB3aGVuIHdlIHJlY2VpdmUgc2hlbGxzIGRpcmVjdGx5IHdlIHNob3VsZCBjb21wYWN0IHRoZW0gdG9vXG4gICAgaWYoIXNoZWxscykgXG4gICAgICAgIHNoZWxscyA9IGZ1bmN0aW9uKCkge3JldHVybiBFQi5EYXRhLmdldFNoZWxsc0ZvckxvY2FsU3RvcmFnZSgpfSAvLyB0aHVua2VkIGZvciBwZXJmXG4gICAgXG4gICAgLy8gd2hlbiB5b3Ugc2F2ZSBzaGVsbHMsIEdDIG9sZGVyIFwidW5pbnRlcmVzdGluZ1wiIHNoZWxscyBhbmQganVzdCBzYXZlIHRoZSBsYXRlc3Qgb25lc1xuICAgIC8vIFRISU5LOiBpcyB0aGlzIG15IHB1ZmY/IHRoZW4gc2F2ZSBpdC4gb3RoZXJ3aXNlLCBpZiB0aGUgY29udGVudCBpcyA+MWsgc3RyaXAgaXQgZG93bi5cbiAgICAvLyBUSElOSzogd2UgbmVlZCBrbm93bGVkZ2Ugb2Ygb3VyIHVzZXIgcmVjb3JkcyBoZXJlLi4uIGhvdyBkbyB3ZSBnZXQgdGhhdD8gXG4gICAgLy8gRUIuRGF0YS5pbnRlcmVzdGluZ191c2VybmFtZXM/XG4gICAgXG4gICAgLy8gc2hlbGxzID0gc2hlbGxzLmZpbHRlcihmdW5jdGlvbihzaGVsbCkgeyByZXR1cm4gIXNoZWxsLnBheWxvYWQuY29udGVudCB8fCAoc2hlbGwucGF5bG9hZC5jb250ZW50Lmxlbmd0aCA8IDEwMDApIH0pXG4gICAgXG4gICAgRUIuUGVyc2lzdC5zYXZlKCdzaGVsbHMnLCBzaGVsbHMpXG59XG5cblxuXG5FQi5EYXRhLmdldENvbnZlcnNhdGlvblB1ZmZzID0gZnVuY3Rpb24oY29udm9JZCwgb2Zmc2V0LCBiYXRjaHNpemUpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICAgIGJhdGNoc2l6ZSA9IGJhdGNoc2l6ZSB8fCBFQi5DT05GSUcucGFnZUJhdGNoU2l6ZSB8fCAxMFxuICAgIFxuICAgIHZhciBwcm9tXG4gICAgcHJvbSA9IEVCLk5ldC5nZXRDb252ZXJzYXRpb25QdWZmcyhjb252b0lkLCBiYXRjaHNpemUsIG9mZnNldClcbiAgICBwcm9tID0gcHJvbS50aGVuKEVCLkRhdGEuYWRkU2hlbGxzVGhlbk1ha2VBdmFpbGFibGUpXG4gICAgcmV0dXJuIHByb21cbn1cblxuRUIuRGF0YS5nZXRDb252ZXJzYXRpb25QdWZmcyA9IEVCLnByb21pc2VNZW1vaXplKEVCLkRhdGEuZ2V0Q29udmVyc2F0aW9uUHVmZnMsIGZ1bmN0aW9uKGtleSwgcmVwb3J0KSB7XG4gICAgcmVwb3J0LnByaXZhdGVfcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBFQi5yZW1vdmVQcm9taXNlUGVuZGluZyhrZXkpXG4gICAgfSlcbn0pXG5cblxuLyoqXG4gKiB0byBpbXBvcnQgc2hlbGxzIGZyb20gbG9jYWwgYW5kIHJlbW90ZSBzb3VyY2VzXG4gKi9cbkVCLkRhdGEuaW1wb3J0U2hlbGxzID0gZnVuY3Rpb24oKSB7XG4gICAgLy8vLyBmZXRjaCBzaGVsbHMgZnJvbSBsb2NhbCBhbmQgcmVtb3RlIHNvdXJjZXNcbiAgICBcbiAgICAvLyBUSElOSzogdGhpcyBzaG91bGQgdGFrZSBhIHNldCBvZiByb3V0ZXMgc28gd2UgY2FuIHBhc3MgdGhlbSB0byBpbXBvcnRSZW1vdGVTaGVsbHNcbiAgICBcbiAgICAvLyBncmFiIHRoZSBsb2NhbCBzaGVsbHMgYW5kIGFkZCB0aGVtIHRvIHRoZSBzeXN0ZW1cbiAgICAvLyB0aGVuIGdyYWIgc29tZSByZW1vdGUgc2hlbGxzIChsYXRlc3QgMTAwKSBhbmQgY29tcGFyZSB0aGVtXG4gICAgLy8gZ28gYmFjayB1bnRpbCB3ZSBmaWxsIGluIHRoZSBnYXBzLCBvciBoaXQgdGhlIHRocmVzaG9sZCAoNTAwPylcbiAgICBcbiAgICAvLyB3aGVuIHlvdSB3YW50IHRvIGxvb2sgYXQgc2hlbGxzIHRoYXQgZG9uJ3QgZXhpc3QsIGxpa2Ugd2hlbiBzY3JvbGxpbmcsIGdyYWIgdGhlbSBhcyBhIGJhdGNoXG4gICAgXG4gICAgRUIuRGF0YS5pbXBvcnRMb2NhbFNoZWxscygpXG4gICAgLy8gRUIuRGF0YS5nZXRNb3JlU2hlbGxzKClcbiAgICBFQi5EYXRhLmltcG9ydFJlbW90ZVNoZWxscygpXG4gICAgLy8gRUIuRGF0YS5pbXBvcnRBbGxTdGFycygpXG59XG5cbi8qKlxuICogdG8gaW1wb3J0IGxvY2FsIHNoZWxsc1xuICovXG5FQi5EYXRhLmltcG9ydExvY2FsU2hlbGxzID0gZnVuY3Rpb24oKSB7ICAgLy8gY2FsbGJhY2spIHtcbiAgICAvLyBFQi5EYXRhLnNoZWxscyA9IEVCLlBlcnNpc3QuZ2V0KCdzaGVsbHMnKSB8fCBbXVxuICAgIHZhciBsb2NhbFNoZWxscyA9IEVCLlBlcnNpc3QuZ2V0KCdzaGVsbHMnKSB8fCBbXVxuICAgIFxuICAgIEVCLkRhdGEuYWRkU2hlbGxzVGhlbk1ha2VBdmFpbGFibGUobG9jYWxTaGVsbHMpXG59XG5cblxuRUIuRGF0YS5pbXBvcnRBbGxTdGFycyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRPRE86IGNvbnNpZGVyIG1vdmluZyB0aGlzIHRvIGEgbW9kdWxlXG4gICAgdmFyIHByb20gPSBFQi5OZXQuZ2V0U3RhclNoZWxscygpXG4gICAgcHJvbS50aGVuKEVCLkRhdGEuYWRkU2hlbGxzVGhlbk1ha2VBdmFpbGFibGUpXG59XG5cblxuRUIuRGF0YS5ob3JyaWRTdGFzaCA9IHt9XG5cbkVCLkRhdGEuaXNCYWRFbnZlbG9wZSA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHJldHVybiBFQi5EYXRhLmhvcnJpZFN0YXNoW3NpZ11cbn1cblxuRUIuRGF0YS5hZGRCYWRFbnZlbG9wZSA9IGZ1bmN0aW9uKHNpZykge1xuICAgIEVCLkRhdGEuaG9ycmlkU3Rhc2hbc2lnXSA9IHRydWVcbn1cblxuXG5FQi5EYXRhLmN1cnJlbnREZWNyeXB0ZWRMZXR0ZXJzID0gW11cbkVCLkRhdGEuY3VycmVudERlY3J5cHRlZExldHRlck1hcCA9IHt9XG5cbkVCLkRhdGEuZ2V0Q3VycmVudERlY3J5cHRlZExldHRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAvLy8vIE5PVEU6IGFsd2F5cyB1c2UgdGhpcyBpbnN0ZWFkIG9mIGhpdHRpbmcgY3VycmVudERlY3J5cHRlZExldHRlcnMgZGlyZWN0bHksIGFzIHRoaXMgZnVuY3Rpb24gbWF5IGNoYW5nZVxuICAgIHJldHVybiBFQi5EYXRhLmN1cnJlbnREZWNyeXB0ZWRMZXR0ZXJzXG59XG5cbkVCLkRhdGEuZ2V0RGVjcnlwdGVkTGV0dGVyQnlTaWcgPSBmdW5jdGlvbihzaWcpIHtcbiAgICBpZihFQi5EYXRhLmN1cnJlbnREZWNyeXB0ZWRMZXR0ZXJNYXBbc2lnXSlcbiAgICAgICAgcmV0dXJuIEVCLkRhdGEuY3VycmVudERlY3J5cHRlZExldHRlck1hcFtzaWddXG59XG5cblxuRUIuRGF0YS5hZGREZWNyeXB0ZWRMZXR0ZXIgPSBmdW5jdGlvbihsZXR0ZXIsIGVudmVsb3BlKSB7XG4gICAgLy8gVEhJTks6IGhvdyBjYW4gd2UgYXZvaWQgZG9pbmcgdGhpcyAnZXhpc3RpbmcgbGV0dGVyJyBjaGVjayB0d2ljZT9cbiAgICB2YXIgbWF5YmVMZXR0ZXIgPSBFQi5EYXRhLmdldERlY3J5cHRlZExldHRlckJ5U2lnKGVudmVsb3BlLnNpZylcbiAgICBpZihtYXliZUxldHRlcikgcmV0dXJuIGZhbHNlXG4gICAgXG4gICAgaWYobGV0dGVyLnBheWxvYWQudHlwZSA9PSAnaWRlbnRpdHknKSByZXR1cm4gZmFsc2UgICAgICAgICAgICAgLy8gVEhJTks6IHdoZXJlIHNob3VsZCB0aGlzIGxpdmU/XG4gICAgXG4gICAgRUIuRGF0YS5jdXJyZW50RGVjcnlwdGVkTGV0dGVycy5wdXNoKGxldHRlcilcbiAgICBcbiAgICBFQi5EYXRhLmN1cnJlbnREZWNyeXB0ZWRMZXR0ZXJNYXBbZW52ZWxvcGUuc2lnXSA9IGxldHRlciAgICAgICAvLyBsZXR0ZXIgaXMgYSBwdWZmIHRvb1xuICAgIEVCLkRhdGEuY3VycmVudERlY3J5cHRlZExldHRlck1hcFtsZXR0ZXIuc2lnXSA9IGxldHRlciAgICAgICAgIC8vIHN0YXNoIGl0IGJvdGggd2F5c1xuICAgIEVCLkRhdGEuYWRkQm9udXMobGV0dGVyLCAnZW52ZWxvcGUnLCBlbnZlbG9wZSkgICAgICAgICAgICAgICAgIC8vIG1hcmsgaXQgZm9yIGxhdGVyXG4gICAgXG4gICAgRUIuRGF0YS5hZGRUb0dyYXBoKFtsZXR0ZXJdKVxuXG4gICAgcmV0dXJuIHRydWVcbn1cblxuRUIuRGF0YS5yZW1vdmVBbGxQcml2YXRlU2hlbGxzID0gZnVuY3Rpb24oKSB7XG4gICAgRUIuRGF0YS5jdXJyZW50RGVjcnlwdGVkTGV0dGVycy5mb3JFYWNoKGZ1bmN0aW9uKHNoZWxsKSB7XG4gICAgICAgIEVCLkRhdGEucmVtb3ZlU2hlbGxGcm9tQ2FjaGUoc2hlbGwuc2lnKVxuICAgIH0pXG4gICAgXG4gICAgRUIuRGF0YS5jdXJyZW50RGVjcnlwdGVkTGV0dGVyTWFwID0ge31cbiAgICBFQi5EYXRhLmN1cnJlbnREZWNyeXB0ZWRMZXR0ZXJzID0gW10gXG4gICAgRUIuRGF0YS5jbGVhclB1ZmZDb250ZW50U3Rhc2goKVxufVxuXG5cblxuXG5cblxuRUIuRGF0YS5nZXRNb3JlUHJpdmF0ZVB1ZmZzID0gZnVuY3Rpb24odXNlcm5hbWUsIG9mZnNldCwgYmF0Y2hzaXplKSB7XG4gICAgLy8gVEhJTks6IHJhY2UgY29uZGl0aW9uIHdoaWxlIHRvZ2dsaW5nIGlkZW50aXRpZXM/IHVzZXJuYW1lIGlzbid0IHVzZWQgYmVsb3cuXG4gICAgaWYoIXVzZXJuYW1lKSB1c2VybmFtZSA9IEVCLmdldEN1cnJlbnRVc2VybmFtZSgpXG4gICAgXG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDBcbiAgICAvLyBvZmZzZXQgPSBvZmZzZXQgfHwgRUIuQ09ORklHLmluaXRMb2FkQmF0Y2hTaXplIHx8IDIwXG4gICAgYmF0Y2hzaXplID0gYmF0Y2hzaXplIHx8IEVCLkNPTkZJRy5wYWdlQmF0Y2hTaXplIHx8IDEwXG4gICAgXG4gICAgdmFyIHByb21cbiAgICBwcm9tID0gRUIuTmV0LmdldE15UHJpdmF0ZVB1ZmZzKEVCLmdldEN1cnJlbnRVc2VybmFtZSgpLCBiYXRjaHNpemUsIG9mZnNldCkgLy8gVEhJTks6IHdoeSBzd2l0Y2hlZCBwYXJhbSBvcmRlcj9cbiAgICBwcm9tID0gcHJvbS50aGVuKEVCLkRhdGEuYWRkU2hlbGxzVGhlbk1ha2VBdmFpbGFibGUpXG4gICAgcmV0dXJuIHByb21cbn1cblxuXG5FQi5EYXRhLnVwZGF0ZVByaXZhdGVTaGVsbHMgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICB2YXIgdXNlcm5hbWUgPSBFQi5nZXRDdXJyZW50VXNlcm5hbWUoKVxuICAgIHZhciBiYXRjaHNpemUgPSAxXG4gICAgdmFyIGZ1bGxPclNoZWxsID0gJ2Z1bGwnIC8vIE9QVDoganVzdCBnYXRoZXIgdGhlIHNoZWxsIChvciBzaWcpIGhlcmUgd2hlbiBjaGVja2luZyBsYXRlc3RcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMCAgICAgLy8gICAgICBhY3R1YWxseS4uLiB3ZSBuZWVkIGEgbGlzdCBvZiBhbGwgc2lncyB3ZSd2ZSBlbmNvdW50ZXJlZCAobm90IGp1c3QgZ29vZCBvbmVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgIG90aGVyd2lzZSBiYWQgZW52ZWxvcGVzIChldGMpIGNvdWxkIGJsb2NrIHByaW9yIGdvb2QgY29udGVudC5cblxuICAgIEVCLk5ldC5nZXRNeVByaXZhdGVQdWZmcyh1c2VybmFtZSwgYmF0Y2hzaXplLCBvZmZzZXQsIGZ1bGxPclNoZWxsKVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHNoZWxscykge1xuICAgICAgICAgICAgICB2YXIgc2hlbGwgPSBzaGVsbHNbMF1cbiAgICAgICAgICAgICAgaWYoIXNoZWxsKSByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHZhciBwcm9tID0gRUIuRGF0YS5pbmdlc3RBbkVuY3J5cHRlZFNoZWxsKHNoZWxsKSAvLyBtYW51YWwgYmVjYXVzZSB3ZSBuZWVkIHRoZSBkZWNyeXB0aW9uIHByb21pc2VcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHByb20udGhlbihmdW5jdGlvbihmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgaWYoZnJlc2gpXG4gICAgICAgICAgICAgICAgICAgICAgRUIuRGF0YS51cGRhdGVQcml2YXRlU2hlbGxzKDErb2Zmc2V0KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG59XG5cblxuRUIuRGF0YS5pbmdlc3RFbmNyeXB0ZWRTaGVsbHMgPSBmdW5jdGlvbihzaGVsbHMpIHtcbiAgICB2YXIgcHJvbXMgPSBzaGVsbHMubWFwKEVCLkRhdGEuaW5nZXN0QW5FbmNyeXB0ZWRTaGVsbClcbiAgICBcbiAgICAvLyBOT1RFOiBQcm9taXNlLmFsbCByZWplY3RzIGltbWVkaWF0ZWx5IHVwb24gYW55IHJlamVjdGlvbiwgc28gd2UgaGF2ZSB0byBkbyB0aGlzIG1hbnVhbGx5XG4gICAgXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gcHJvbXMubGVuZ3RoXG4gICAgICAgIHZhciByZXBvcnQgPSB7Z29vZDogMCwgYmFkOiAwLCBnb29kc2lnczogW119XG4gICAgICAgIFxuICAgICAgICAvLyBUT0RPOiBhZGQgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IHdlbnQgd3JvbmcgdG8gdGhlIHJlcG9ydFxuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gdW5oYXBweV9wYXRoKCkge1xuICAgICAgICAgICAgcmVwb3J0LmJhZCsrXG4gICAgICAgICAgICBpZighLS1yZW1haW5pbmcpIHJlc29sdmUocmVwb3J0KVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBwcm9tcy5mb3JFYWNoKGZ1bmN0aW9uKHByb20pIHtcbiAgICAgICAgICAgIHByb20udGhlbihmdW5jdGlvbihsZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZighbGV0dGVyKSByZXR1cm4gdW5oYXBweV9wYXRoKCkgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhdGNoZXMgb2xkIG9yIHdlaXJkIHB1ZmZzIFxuICAgICAgICAgICAgICAgIHJlcG9ydC5nb29kKysgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGlmZmVyZW50aWF0ZSBhYm92ZSBjYXNlc1xuICAgICAgICAgICAgICAgIHJlcG9ydC5nb29kc2lncy5wdXNoKGxldHRlci5zaWcpXG4gICAgICAgICAgICAgICAgaWYoIS0tcmVtYWluaW5nKSByZXNvbHZlKHJlcG9ydClcbiAgICAgICAgICAgIH0sIHVuaGFwcHlfcGF0aCApICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhdGNoZXMgZGVjcnlwdGlvbiBlcnJvcnNcbiAgICAgICAgfSlcbiAgICB9KVxufVxuXG5cbkVCLkRhdGEuaW5nZXN0QW5FbmNyeXB0ZWRTaGVsbCA9IGZ1bmN0aW9uKGVudmVsb3BlKSB7XG4gICAgdmFyIHByb20gPSBFQi5QdWZmLnByb21pc2VMZXR0ZXIoZW52ZWxvcGUpXG5cbiAgICBwcm9tID0gcHJvbS50aGVuKGZ1bmN0aW9uKGxldHRlcikge1xuICAgICAgICBpZighbGV0dGVyKSByZXR1cm4gZmFsc2VcbiAgICAgICAgXG4gICAgICAgIHZhciBmcmVzaCA9IEVCLkRhdGEuYWRkRGVjcnlwdGVkTGV0dGVyKGxldHRlciwgZW52ZWxvcGUpICAgICAgICAvLyBhZGQgdGhlIGxldHRlciB0byBvdXIgc3lzdGVtXG4gICAgICAgIGlmKCFmcmVzaCkgcmV0dXJuIGZhbHNlXG4gICAgICAgIFxuICAgICAgICBFQi5ydW5IYW5kbGVycygnbmV3UHVmZnMnLCBbbGV0dGVyXSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIHJlY2VpdmVzIGFuIGFycmF5IG9mIHB1ZmZzXG4gICAgICAgIHJldHVybiBsZXR0ZXJcbiAgICB9KVxuICAgIFxuICAgIHJldHVybiBwcm9tXG4gICAgXG4gICAgLy8gTk9URTogdGhpcyBkb2Vzbid0IGFwcGVhciB0byBkbyBtdWNoLCBtb3N0bHkgYmVjYXVzZSBleHRyYWN0TGV0dGVyRnJvbUVudmVsb3BlIGlzIHF1aXRlIGVmZmVjdGZ1bC5cbiAgICAvLyAgICAgICBpdCBjYWxscyBFQi5EYXRhLmFkZERlY3J5cHRlZExldHRlciBhcyBwYXJ0IG9mIGl0cyBwcm9jZXNzaW5nLCB3aGljaCBkb2VzIGFsbCB0aGUgcmVhbCB3b3JrLlxuICAgIFxuICAgIC8vIFRISU5LOiBjb25zaWRlciBhZGRpbmcgdGhpcyBiYWNrIGluLCB0aG91Z2ggcmVtZW1iZXIgdGhhdCBlYWNoIGRlY3J5cHRpb24gcHVzaGVzIGl0cyBvd24gZXJyb3JzLi4uXG4gICAgLy8gaWYgKGxldHRlcnMubGVuZ3RoICE9IHByaXZhdGVTaGVsbHMubGVuZ3RoKSB7XG4gICAgLy8gICAgIEV2ZW50cy5wdWIoJ3RyYWNrL2RlY3J5cHQvc29tZS1kZWNyeXB0LWZhaWxzJyxcbiAgICAvLyAgICAgICAgICAgICAgICAge2xldHRlcnM6IGxldHRlcnMubWFwKGZ1bmN0aW9uKHApe3JldHVybiBwLnNpZ30pLFxuICAgIC8vICAgICAgICAgICAgICAgICAgcHJpdmF0ZVNoZWxsczogcHJpdmF0ZVNoZWxscy5tYXAoZnVuY3Rpb24ocCl7cmV0dXJuIHAuc2lnfSl9KVxuICAgIC8vIH1cbn1cblxuXG5cblxuLy8gdGhlIHNsb3QgbG9ja2VyIGNvbnRhaW5zIGluZm9ybWF0aW9uIG9uIHF1ZXJpZXMgbWFkZSB0byBmaWxsIHNsb3RzLiBcbi8vIGluIHBhcnRpY3VsYXIgaXQgaG9sZHMgdGhlIG9mZnNldCwgd2hpY2ggd2lsbCBiZSAtMSB3aGVuIFtdIGlzIHJldHVybmVkLlxuLy8gaXQga2VlcHMgcXVlcmllcyBmcm9tIHJlLXJlcXVlc3RpbmcgdGhlIHNhbWUgc2hlbGxzIG92ZXIgYW5kIG92ZXIsIFxuLy8gYW5kIHByb3ZpZGVzIHNvbWUgY29uY3VycmVuY3kgLyBmbG93IGNvbnRyb2wgYnkgYWxsb3dpbmcgYSBxdWVyeVxuLy8gdG8gc2V0IGl0IHRvIC0xIHdoZW4gaXQgaXMgcnVubmluZyBhbmQgdGhlbiByZXBsYWNlIGl0IHdoZW4gZG9uZS5cbkVCLkRhdGEuc2xvdExvY2tlciA9IHt9XG5cbi8vIFRISU5LOiB3ZSdyZSBjYWxsaW5nIHRoaXMgZnJvbSB0aGUgJ3JlZnJlc2gnIGJ1dHRvbiBub3cuLi5cblxuXG5FQi5EYXRhLmltcG9ydFJlbW90ZVNoZWxscyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vLy8gb25seSBjYWxsZWQgZHVyaW5nIGluaXRpYWwgYXBwbGljYXRpb24gYm9vdHVwLiBoYW5kbGVzIGJvdGggY29sZCBsb2FkcyBhbmQgaG90IGxvYWRzLlxuICAgIFxuICAgIHZhciBvZmZzZXQgPSAwXG4gICAgdmFyIGdpdmV1cCA9IEVCLkNPTkZJRy5pbml0TG9hZEdpdmV1cFxuICAgIHZhciBsaW1pdCAgPSBFQi5DT05GSUcuaW5pdExvYWRCYXRjaFNpemVcbiAgICB2YXIgbmV3X3NoZWxscyA9IFtdXG4gICAgdmFyIGtlZXBfZ29pbmcgPSB0cnVlXG4gICAgXG4gICAgdmFyIGtleSA9ICdbe1wic29ydFwiOlwiREVTQ1wifSx7XCJ0YWdzXCI6W10sXCJ0eXBlc1wiOltdLFwidXNlcnNcIjpbXSxcInJvdXRlc1wiOltdfV0nIC8vIFRPRE86IHVwZ3JhZGUgdGhpcyBkZWZhdWx0IHF1ZXJ5XG4gICAgRUIuRGF0YS5zbG90TG9ja2VyW2tleV0gPSAtMVxuICAgIFxuICAgIC8vIFRPRE86IGluZGV4IGJ5IHVzZXJuYW1lXG4gICAgLy8gVE9ETzogaWYgZHVwbGljYXRlIGNoZWNrIHVwZGF0ZSB0aW1lcyBmb3IgbGF0ZXN0XG4gICAgLy8gVE9ETzogcGVyc2lzdCB0byBMUyAobWF5YmUgb25seSBzb21ldGltZXM/IG9udW5sb2FkPyBwcm9iYWJpbGlzdGljPylcbiAgICAgICAgIFxuICAgIGZ1bmN0aW9uIGdldE1lU29tZVNoZWxscyhwdWZmcykge1xuICAgICAgICBpZihwdWZmcykge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gRUIuRGF0YS5hZGRTaGVsbHNUaGVuTWFrZUF2YWlsYWJsZShwdWZmcylcbiAgICAgICAgICAgIC8vIG5ld19zaGVsbHMgPSBuZXdfc2hlbGxzLmNvbmNhdChteV9uZXdfc2hlbGxzKVxuICAgICAgICAgICAgLy8gdmFyIGRlbHRhID0gbXlfbmV3X3NoZWxscy5sZW5ndGhcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoZGVsdGEgIT0gbGltaXQpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc29tZSBzaGVsbHMgd2VyZSBhbHJlYWR5IGluIG91ciBjYWNoZVxuICAgICAgICAgICAgICAgIGtlZXBfZ29pbmcgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihvZmZzZXQgPiBnaXZldXApXG4gICAgICAgICAgICBrZWVwX2dvaW5nID0gZmFsc2VcblxuICAgICAgICBpZigha2VlcF9nb2luZykge1xuICAgICAgICAgICAgRUIuRGF0YS5zbG90TG9ja2VyW2tleV0gPSAxXG4gICAgICAgICAgICAvLyBFQi5EYXRhLnN0dXBpZEhvcnJpYmxlR2xvYmFsVGhpbmcgPSB0cnVlXG4gICAgICAgICAgICAvLyBFQi5EYXRhLm1ha2VTaGVsbHNBdmFpbGFibGUobmV3X3NoZWxscylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgcHJvbSA9IEVCLk5ldC5nZXRTb21lU2hlbGxzKHt9LCB7fSwgbGltaXQsIG9mZnNldClcbiAgICAgICAgcHJvbS50aGVuKGdldE1lU29tZVNoZWxscylcblxuICAgICAgICBvZmZzZXQgKz0gbGltaXRcbiAgICB9XG4gICAgXG4gICAgZ2V0TWVTb21lU2hlbGxzKClcbn1cblxuXG5cbi8qXG4gICAgRW5kIHNoZWxsIGNvbGxlY3Rpb24gaW50YWtlIGVxdWlwbWVudFxuKi9cblxuXG4vKipcbiAqIFNlbmQgYSBwcml2YXRlIHB1ZmYgdXNpbmcgYSBuZXcgYW5vbnltb3VzIHVzZXIgYXMgdGhlIHNlbmRlciBhbmQgcG9zc2libHkgYW5vdGhlciBhcyByZXBseS10b1xuICogQHBhcmFtIHtzdHJpbmd9IEVpdGhlciAnYW5vbicgb3IgJ2RvdWJseWFub24nXG4gKiBAcmV0dXJucyB7cHJvbWlzZX1cbiAqL1xuRUIuRGF0YS5zZW5kQW5vbk1vZGVQdWZmID0gZnVuY3Rpb24oY29udGVudCwgdXNlcm5hbWVzLCB0eXBlLCBtb2RlLCBwYXlsb2FkLCByb3V0ZXMpIHtcbiAgICBpZighRUIuZ2V0Q3VycmVudFVzZXJuYW1lKCkpXG4gICAgICAgIHJldHVybiBFQi5lbXB0eVByb21pc2UoJ1lvdSBtdXN0IGhhdmUgYSBjdXJyZW50IGlkZW50aXR5IHRvIHNlbmQgbWVzc2FnZXMnKVxuICAgICAgICBcbiAgICBwYXlsb2FkID0gcGF5bG9hZCB8fCB7fVxuICAgIGlmKCFBcnJheS5pc0FycmF5KHVzZXJuYW1lcykpXG4gICAgICAgIHVzZXJuYW1lcyA9IHVzZXJuYW1lcyA/IFt1c2VybmFtZXNdIDogW11cbiAgICBcbiAgICB2YXIgcHJpdmF0ZUVudmVsb3BlQWxpYXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZXMgdGhlIHByaXZhdGUga2V5cyBvZiBuZXcgYW5vbiB1c2VyXG4gICAgdmFyIHByb20gPSBQcm9taXNlLnJlc29sdmUoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIHByb21pc2Ugd2UgdXNlIHRvIHN0cmluZyBldmVyeXRoaW5nIGFsb25nIFxuXG4gICAgcHJvbSA9IHByb20udGhlbihmdW5jdGlvbigpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSdkIGxpa2UgdG8gYmUgYW5vbnltb3VzLCBzbyBtYWtlIGEgbmV3IHVzZXJcbiAgICAgICAgcmV0dXJuIEVCLlVzZXJzLmFkZEFub255bW91c1VzZXIoKS50aGVuKGZ1bmN0aW9uKHVzZXJSZWNvcmQpIHtcbiAgICAgICAgICAgIEVCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oaWRlbnRpdGllcywgY3VycmVudFVzZXJuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aXR5ID0gaWRlbnRpdGllc1tjdXJyZW50VXNlcm5hbWVdXG4gICAgICAgICAgICAgICAgdmFyIGFsaWFzZXMgPSBpZGVudGl0eS5hbGlhc2VzXG4gICAgICAgICAgICAgICAgcHJpdmF0ZUVudmVsb3BlQWxpYXMgPSBhbGlhc2VzW2FsaWFzZXMubGVuZ3RoLTFdICAgICAgICAvLyBvdXIgbmV3IGFub24gYWxpYXNlcyBzaG91bGQgYmUgdGhlIGxhc3Qgb25lXG4gICAgICAgICAgICAgICAgdXNlcm5hbWVzLnB1c2godXNlclJlY29yZC51c2VybmFtZSkgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgbmV3IGFub24gdXNlcm5hbWUgdG8gdGhlIGxpc3Qgb2YgcmVjaXBpZW50c1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9KVxuXG4gICAgaWYobW9kZSA9PSAnZG91Ymx5YW5vbicpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmUgd2UgZG91Ymx5IGFub255bW91cz8gbWFrZSBhbm90aGVyIG5ldyB1c2VyXG4gICAgICAgIHByb20gPSBwcm9tLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gRUIuVXNlcnMuYWRkQW5vbnltb3VzVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlclJlY29yZCkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQucmVwbHlUbyA9IHVzZXJSZWNvcmQudXNlcm5hbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcHJvbSA9IHByb20udGhlbihmdW5jdGlvbigpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmNlIHRoZSB1c2VycyBhcmUgbWFkZSwgc2VuZCBvZmYgdGhlIHB1ZmZcbiAgICAgICAgdmFyIHVzZXJwcm9tID0gRUIuVXNlcnMudXNlcm5hbWVzVG9Vc2VyUmVjb3Jkc1Byb21pc2UodXNlcm5hbWVzKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHVzZXJwcm9tLnRoZW4oZnVuY3Rpb24odXNlclJlY29yZHMpIHsgICAgICAgIFxuICAgICAgICAgICAgdmFyIHB1ZmYgPSBFQi5QdWZmLnNpbXBsZUJ1aWxkKHR5cGUsIGNvbnRlbnQsIHBheWxvYWQsIHJvdXRlcywgdXNlclJlY29yZHMsIHByaXZhdGVFbnZlbG9wZUFsaWFzKVxuICAgICAgICAgICAgcmV0dXJuIEVCLkRhdGEuYWRkUHVmZlRvU3lzdGVtKHB1ZmYpXG4gICAgICAgIH0pXG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIEVCLmNhdGNoRXJyb3IoZXJyKVxuICAgIH0pXG4gICAgXG4gICAgcmV0dXJuIHByb21cbn1cblxuXG4vKipcbiAqIGdldCBhIHB1ZmYgYnkgaXRzIHNpZ1xuICogQHBhcmFtIHtzdHJpbmd9IHNpZ1xuICogQHJldHVybnMge3Byb21pc2V9XG4gKi9cbkVCLkRhdGEuZ2V0UHVmZkJ5U2lnID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgdmFyIHNoZWxsID0gRUIuRGF0YS5nZXRDYWNoZWRTaGVsbEJ5U2lnKHNpZykgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGluIHB1YmxpYyBjYWNoZVxuICAgIFxuICAgIGlmKCFzaGVsbClcbiAgICAgICAgc2hlbGwgPSBFQi5EYXRhLmdldERlY3J5cHRlZExldHRlckJ5U2lnKHNpZykgICAgICAgICAgICAgICAgLy8gY2hlY2sgaW4gcHJpdmF0ZSBjYWNoZVxuICAgIFxuICAgIGlmKEVCLlB1ZmYuaXNGdWxsKHNoZWxsKSlcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzaGVsbCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgaGFzIGNvbnRlbnRcbiAgICBcbiAgICBpZihFQi5EYXRhLnBlbmRpbmdQdWZmUHJvbWlzZXNbc2lnXSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXN0YWJsaXNoIGEgZm9vdGhvbGRcbiAgICAgICAgcmV0dXJuIEVCLkRhdGEucGVuZGluZ1B1ZmZQcm9taXNlc1tzaWddXG4gICAgXG4gICAgcmV0dXJuIEVCLkRhdGEuZ2V0UHVmZkJ5U2lnRnJvbUVsc2V3aGVyZShzaWcpICAgICAgICAgICAgICAgICAgIC8vIGdhdGhlciBhIHByb21pc2Vcbn1cblxuRUIuRGF0YS5nZXRQdWZmT3JOb3QgPSBmdW5jdGlvbihzaWcpIHtcbiAgICAvLyBTdXBwb3J0cyB0aGUgZmlyZS1hbmQtZm9yZ2V0IHN0eWxlIC0tIHNlZSBub3RlIGluIEVCLmpzXG4gICBcbiAgICB2YXIgc2hlbGwgPSBFQi5EYXRhLmdldENhY2hlZFNoZWxsQnlTaWcoc2lnKSAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaW4gcHVibGljIGNhY2hlXG4gICAgXG4gICAgaWYoIXNoZWxsKVxuICAgICAgICBzaGVsbCA9IEVCLkRhdGEuZ2V0RGVjcnlwdGVkTGV0dGVyQnlTaWcoc2lnKSAgICAgICAgICAgICAgICAvLyBjaGVjayBpbiBwcml2YXRlIGNhY2hlXG5cbiAgICBpZihFQi5QdWZmLmlzRnVsbChzaGVsbCkpXG4gICAgICAgIHJldHVybiBzaGVsbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGhhcyBjb250ZW50XG4gICAgICAgIFxuICAgIEVCLkRhdGEuZ2V0UHVmZkJ5U2lnRnJvbUVsc2V3aGVyZShzaWcpICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHB1ZmYgZnJvbSB0aGUgbmV0d29ya1xuICAgICAgICBcbiAgICByZXR1cm4gZmFsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHJldHVybiBmYWxzZSBmb3IgZWFzeSBmaWx0ZXJpbmdcbn1cblxuXG4vKipcbiAqIGdldCBhIHB1ZmYgYnkgaXRzIHNpZyBmcm9tIGVsc2V3aGVyZVxuICogQHBhcmFtIHtzdHJpbmd9IHNpZ1xuICogQHJldHVybnMge3Byb21pc2V9XG4gKi9cbkVCLkRhdGEuZ2V0UHVmZkJ5U2lnRnJvbUVsc2V3aGVyZSA9IGZ1bmN0aW9uKHNpZykge1xuICAgIEVCLkRhdGEucGVuZGluZ1B1ZmZQcm9taXNlc1tzaWddID0gRUIuTmV0LmdldFB1ZmZCeVNpZyhzaWcpXG4gICAgdmFyIG91dHB1dCA9IEVCLkRhdGEucGVuZGluZ1B1ZmZQcm9taXNlc1tzaWddLnRoZW4oYmFkU2hlbGxDbGVhckNhY2hlKVxuXG4gICAgb3V0cHV0LnRoZW4oRUIuRGF0YS5hZGRTaGVsbHNUaGVuTWFrZUF2YWlsYWJsZSlcbiAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVsYXkgR0MgdG8gc3RvcCBydW5hd2F5IG5ldHdvcmsgcmVxdWVzdHNcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgZGVsZXRlIEVCLkRhdGEucGVuZGluZ1B1ZmZQcm9taXNlc1tzaWddIH0sIDEwMDAwKSB9KVxuICAgIFxuICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgXG4gICAgLy8gbG9jYWxseSBjYWNoZWQgc2hlbGxzIHRoYXQgYXJlIG1pc3NpbmcgY29udGVudCBvbiB0aGUgbmV0d29yayBwcmV2ZW50IHNsb3RmaWxscyBmcm9tIHJlc29sdmluZyxcbiAgICAvLyBzbyB3ZSBjbGVhciBpdCBmcm9tIG91ciBjYWNoZSBpZiB3ZSBjYW4ndCBmaW5kIGl0LlxuICAgIGZ1bmN0aW9uIGJhZFNoZWxsQ2xlYXJDYWNoZShzaGVsbHMpIHtcbiAgICAgICAgaWYoIXNoZWxscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmYXV4c2hlbGwgPSB7c2lnOiBzaWd9XG4gICAgICAgICAgICBpZighRUIuRGF0YS5nZXRCb251cyhmYXV4c2hlbGwsICdlbnZlbG9wZScpKSB7XG4gICAgICAgICAgICAgICAgRUIuRGF0YS5yZW1vdmVTaGVsbEZyb21DYWNoZShzaWcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoXCJDb250ZW50IGNhbiBub3QgYmUgZm91bmQgZm9yIHNoZWxsICdcIiArIHNpZyArIFwiJ1wiKSAvLyBUSElOSzogd2h5IHdhcyB0aGlzIHRocm93RXJyb3I/XG4gICAgICAgICAgICAgICAgLy8gVEhJTks6IHVubG9jayBFQi5EYXRhLnBlbmRpbmdQdWZmUHJvbWlzZXNbc2lnXT8gcHJvYmFibHkgbm90LCBidXQgaXQgbWlnaHQgcmUtYXBwZWFyIGxhdGVyLi4uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNoZWxsc1xuICAgIH1cbn1cblxuRUIuRGF0YS5yZW1vdmVTaGVsbEZyb21DYWNoZSA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHZhciBzaGVsbCA9IEVCLkRhdGEuZ2V0Q2FjaGVkU2hlbGxCeVNpZyhzaWcpICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBFQi5EYXRhLnNoZWxsc1xuICAgIEVCLkRhdGEuc2hlbGxzLnNwbGljZSggRUIuRGF0YS5zaGVsbHMuaW5kZXhPZihzaGVsbCksIDEgKVxuICAgIFxuICAgIGRlbGV0ZSBFQi5EYXRhLnNoZWxsU29ydFtzaWddICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBFQi5EYXRhLnNoZWxsU29ydFxuICAgIFxuICAgIGRlbGV0ZSBFQi5EYXRhLmJvbmlpW3NpZ10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgc2hlbGwncyBib25paVxuICAgIFxuICAgIEVCLkRhdGEucHVyZ2VTaGVsbEZyb21HcmFwaChzaWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBncmFwaFxuICAgIFxuICAgIEVCLkRhdGEucmVtb3ZlQ2FjaGVkUHVmZlNjb3JlKHNoZWxsKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgYWxsb2NhdG9yIHNjb3JlXG59XG5cbkVCLkRhdGEucHVyZ2VTaGVsbEZyb21HcmFwaCA9IGZ1bmN0aW9uKHNpZykge1xuICAgIC8vIGNoYW5nZSBncmFwaCB2ZXJ0ZXggdG8gJ3BzZXVkby1zaGVsbCcgdHlwZSAob3IgJ3B1cmdlZCcgdHlwZT8pXG4gICAgLy8gICBhbmQgcmVtb3ZlIHRoZSBjb250ZW50IG9mIHRoZSAnc2hlbGwnIHByb3BlcnR5XG4gICAgLy8gVE9ETzogdGhpcyBpcyBpY2t5IG1ha2UgaXQgYmV0dGVyXG4gICAgdmFyIHZlcnRleCA9IEVCLkRhdGEuZ3JhcGgudihzaWcpLnJ1bigpWzBdXG4gICAgaWYodmVydGV4KSB7XG4gICAgICAgIHZlcnRleC50eXBlID0gJ3B1cmdlZCdcbiAgICAgICAgdmVydGV4LnNoZWxsID0gdW5kZWZpbmVkXG4gICAgfVxufVxuXG5cbi8qKlxuICogdG8gZ2V0IG15IHB1ZmYgY2hhaW5cbiAqIEBwYXJhbSAge3N0cmluZ30gdXNlcm5hbWUgXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbkVCLkRhdGEuZ2V0TXlQdWZmQ2hhaW4gPSBmdW5jdGlvbih1c2VybmFtZSkge1xuICAgIC8vIENVUlJFTlRMWSBVTlVTRURcbiAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBncmFiIG15IHB1ZmZzIGZyb20gYSBmaWxlIG9yIGxvY2FsU3RvcmFnZSBvciB3aGVyZXZlciBteSBpZGVudGl0eSdzIHB1ZmZzIGdldCBzdG9yZWRcbiAgICAvLyBUT0RPOiB0aGF0IGNvbGxlY3Rpb24gc2hvdWxkIGJlIHVwZGF0ZWQgYXV0b21hdGljYWxseSB3aXRoIG5ldyBwdWZmcyBjcmVhdGVkIHRocm91Z2ggb3RoZXIgZGV2aWNlc1xuICAgIC8vIFRPRE86IHRoZSBwdWZmY2hhaW4gc2hvdWxkIGFsc28gYmUgc29ydGVkIGluIGNoYWluIG9yZGVyLCBub3QgZ2VuZXJhbCBjb2xsZWN0aW9uIG9yZGVyXG4gICAgXG4gICAgdmFyIHNoZWxscyA9IEVCLkRhdGEuZ2V0U2hlbGxzKClcbiAgICBcbiAgICByZXR1cm4gc2hlbGxzLmZpbHRlcihmdW5jdGlvbihwdWZmKSB7IHJldHVybiBwdWZmICYmIHB1ZmYudXNlcm5hbWUgPT0gdXNlcm5hbWUgfSkgLy8gVE9ETzogdXNlIHRoZSBncmFwaFxuICAgIC8vIHJldHVybiBFQi5NLkZvcnVtLmdldEJ5VXNlcih1c2VybmFtZSkgLy8gVE9ETzogdGVzdCB0aGlzIFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuLy8gICAgICAgR2FyYmFnZSBDb2xsZWN0b3IgVGhpbmcgICAgICAgICAvL1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cblxuRUIuRGF0YS5ydW5uaW5nU2l6ZVRhbGx5ID0gMFxuRUIuRGF0YS5zY29yZVNvcnQgPSB7fVxuXG5FQi5EYXRhLmhldXJpc3RpY3MgPSBbXVxuRUIuRGF0YS5hZGRIZXVyaXN0aWNzID0gZnVuY3Rpb24oZnVuKSB7XG4gICAgRUIuRGF0YS5oZXVyaXN0aWNzLnB1c2goZnVuKVxufVxuXG5FQi5EYXRhLmFkZEhldXJpc3RpY3MoZnVuY3Rpb24oc2hlbGwpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCggKEVCLkRhdGEuZ2V0Qm9udXMoc2hlbGwsICdzdGFyU3RhdHMnKSB8fCB7fSkuc2NvcmUgfHwgMCApICogMTAwXG59KVxuXG4vLyBUT0RPOiBhZGQgaGV1cmlzdGljcyBmb3I6IG15IHB1ZmZzICh3aGljaCBnbyBlbHNld2hlcmUsIHVsdGltYXRlbHkpLCByZXBsaWVzIHRvIG15IHB1ZmZzLCBteSBwdWZmJ3MgcGFyZW50cywgXG4vLyAgICAgICBmcmllbmQncyBwdWZmcyAod2hhdGV2ZXIgdGhhdCBtZWFucyksIHB1ZmYgZnJlc2huZXNzLCBsYXN0IHNlZW4sIGV0Y1xuXG5cbkVCLkRhdGEucmF0ZU15UHVmZiA9IGZ1bmN0aW9uKHB1ZmYpIHtcbiAgICB2YXIgc2NvcmVzID0gRUIuRGF0YS5oZXVyaXN0aWNzLm1hcChmdW5jdGlvbihoKSB7cmV0dXJuIGgocHVmZil9KSAgICAgICAgICAgLy8gYXBwbHkgaGV1cmlzdGljc1xuICAgIHZhciB0b3RhbCAgPSBzY29yZXMucmVkdWNlKGZ1bmN0aW9uKGFjYywgc2NvcmUpIHtyZXR1cm4gYWNjKyhzY29yZXx8MCl9LCAwKSAvLyBnZXQgdG90YWwgLy8gVE9ETzogaW1wcm92ZSBhbGdvXG4gICAgcmV0dXJuIHRvdGFsXG59XG5cbkVCLkRhdGEucmF0ZVNvbWVQdWZmcyA9IGZ1bmN0aW9uKHB1ZmZzKSB7XG4gICAgcHVmZnMuZm9yRWFjaChmdW5jdGlvbihwdWZmKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJhdGUgZWFjaCBwdWZmXG4gICAgICAgIHZhciBzY29yZSA9IEVCLkRhdGEucmF0ZU15UHVmZihwdWZmKVxuICAgICAgICBFQi5EYXRhLmRvU3R1ZmZXaXRoU2NvcmUocHVmZiwgc2NvcmUpXG4gICAgICAgIEVCLkRhdGEuZG9TdHVmZldpdGhQdWZmIChwdWZmKVxuICAgIH0pXG4gICAgLy8gVEhJTks6IHNvbWUgaGV1cmlzdGljcyByZWx5IG9uIHNjb3JlcyBvZiByZWxhdGVkIHB1ZmZzLi4uIHBvc3NpYmxlIGZlZWRiYWNrIGxvb3A/IHRvcG9sb2dpY2FsIG9yZGVyaW5nP1xuICAgIC8vICAgICAgICBhIHRvcG9zb3J0IGlzIGVhc3ktaXNoIHcvIGdyYXBoIGRiLi4uXG59XG5cbi8vIFRPRE86IHdoZW4geW91IHN3aXRjaCBpZGVudGl0aWVzLCByZXNjb3JlIHRoZSBwdWZmc1xuXG5cbkVCLkRhdGEuZG9TdHVmZldpdGhTY29yZSA9IGZ1bmN0aW9uKHB1ZmYsIHNjb3JlKSB7XG4gICAgRUIuRGF0YS5yZW1vdmVDYWNoZWRQdWZmU2NvcmUocHVmZikgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IGhhcyB0byBjb21lIGJlZm9yZSBib25paVxuICAgIEVCLkRhdGEuYWRkQm9udXMocHVmZiwgJ3JhdGluZycsIHNjb3JlKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgcmF0aW5nIHRvIGJvbmlpXG4gICAgRUIuRGF0YS5jYWNoZVB1ZmZTY29yZShwdWZmLCBzY29yZSkgICAgXG4gICAgLy8gT1BUOiBjYWNoZSBzb3J0ZWQgdmVyc2lvblxuICAgIC8vIG1heWJlIGJpbnNbc2NvcmUuZmxvb3JdLnB1c2gocHVmZikgb3Igc29tZXRoaW5nLi4uXG59XG5cbkVCLkRhdGEuZG9TdHVmZldpdGhQdWZmID0gZnVuY3Rpb24ocHVmZikge1xuICAgIHZhciBwdWZmc2l6ZSA9IEpTT04uc3RyaW5naWZ5KHB1ZmYpLmxlbmd0aFxuICAgIEVCLkRhdGEuYWRkQm9udXMocHVmZiwgJ3NpemUnLCBwdWZmc2l6ZSlcbiAgICBFQi5EYXRhLnJ1bm5pbmdTaXplVGFsbHkgKz0gcHVmZnNpemUgfHwgMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBibG9jayBOYU5zXG59XG5cbkVCLkRhdGEuY2FjaGVQdWZmU2NvcmUgPSBmdW5jdGlvbihwdWZmLCBzY29yZSkge1xuICAgIHZhciBrZXkgPSBFQi5EYXRhLmNvbnZlcnRTY29yZVRvS2V5KHNjb3JlKVxuICAgIEVCLkRhdGEuc2NvcmVTb3J0W2tleV0gPSBFQi5EYXRhLnNjb3JlU29ydFtrZXldIHx8IFtdXG4gICAgRUIuRGF0YS5zY29yZVNvcnRba2V5XS5wdXNoKHB1ZmYpXG59XG5cbkVCLkRhdGEucmVtb3ZlQ2FjaGVkUHVmZlNjb3JlID0gZnVuY3Rpb24ocHVmZikge1xuICAgIGlmKCFwdWZmKSByZXR1cm4gZmFsc2VcbiAgICBcbiAgICB2YXIgc2NvcmUgPSBFQi5EYXRhLmdldEJvbnVzKHB1ZmYsICdzY29yZScpXG4gICAgdmFyIGtleSA9IEVCLkRhdGEuY29udmVydFNjb3JlVG9LZXkoc2NvcmUpXG4gICAgdmFyIGJpbiA9IEVCLkRhdGEuc2NvcmVTb3J0W2tleV1cbiAgICBpZighYmluKSByZXR1cm4gZmFsc2VcbiAgICBpZighYmluLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG4gICAgXG4gICAgZm9yKHZhciBpID0gYmluLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmKGJpbltpXS5zaWcgPT0gcHVmZi5zaWcpIHtcbiAgICAgICAgICAgIGJpbi5zcGxpY2UoaSwgMSlcbiAgICAgICAgICAgIHZhciBwdWZmc2l6ZSA9IEVCLkRhdGEuZ2V0Qm9udXMocHVmZiwgJ3NpemUnKVxuICAgICAgICAgICAgRUIuRGF0YS5ydW5uaW5nU2l6ZVRhbGx5IC09IHB1ZmZzaXplIHx8IDAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJsb2NrIE5hTnNcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgfVxufVxuXG5FQi5EYXRhLmdldENhY2hlZFB1ZmZzID0gZnVuY3Rpb24obGltaXQsIGJvdHRvbSkge1xuICAgIHZhciBzZWVuID0gMFxuICAgIHZhciByZXN1bHQgPSBbXVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoRUIuRGF0YS5zY29yZVNvcnQpLm1hcChwYXJzZUZsb2F0KS5zb3J0KClcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgICAgdmFyIHB1ZmZzID0gRUIuRGF0YS5zY29yZVNvcnRba2V5XSAvLyBPUFQ6IHNob3J0LWNpcmN1aXQgb24gIWJvdHRvbVxuICAgICAgICBcbiAgICAgICAgcHVmZnMucmVkdWNlKGZ1bmN0aW9uKHNlZW4sIHB1ZmYpIHtcbiAgICAgICAgICAgIGlmKHNlZW4gPiBsaW1pdCA9PSAhIWJvdHRvbSkgcmVzdWx0LnB1c2gocHVmZilcbiAgICAgICAgICAgIHJldHVybiBzZWVuKzFcbiAgICAgICAgfSwgMClcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3VsdFxufVxuXG5FQi5EYXRhLmNvbnZlcnRTY29yZVRvS2V5ID0gZnVuY3Rpb24oc2NvcmUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihzY29yZSAvIDEwKSB8fCAwIC8vIFRPRE86IG1ha2UgdGhpcyBzbWFydGVyXG59XG5cblxuRUIuRGF0YS5nZXRUb3BQdWZmcyA9IGZ1bmN0aW9uKGxpbWl0KSB7XG4gICAgcmV0dXJuIEVCLkRhdGEuZ2V0Q2FjaGVkUHVmZnMobGltaXQpXG59XG5cbkVCLkRhdGEuZ2V0Tm90VG9wUHVmZnMgPSBmdW5jdGlvbihsaW1pdCkge1xuICAgIC8vIGdyYWIgdGhlIHB1ZmZzIGJlbG93IHRoZSBsaW1pdCB0aHJlc2hvbGQgKHcvIDMwMCBwdWZmcyBhbmQgbGltaXQ9MTAwIHRoaXMgcmV0dXJucyB0aGUgMjAwIHdvcnN0IHB1ZmZzKVxuICAgIHJldHVybiBFQi5EYXRhLmdldENhY2hlZFB1ZmZzKGxpbWl0LCAnYm90dG9tJylcbn1cblxuLy8gRUIuRGF0YS5nZXRUb3BQdWZmcyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbi8vICAgICB2YXIgbnVtYmVyTGltaXQgPSAgb3B0aW9ucy5udW1iZXIgfHwgMFxuLy8gICAgIHZhciBzaXplTGltaXQgICA9ICAgIG9wdGlvbnMuc2l6ZSB8fCAwXG4vLyAgICAgdmFyIGNvbXBhY3QgICAgID0gb3B0aW9ucy5jb21wYWN0IHx8IGZhbHNlICAvLyB3aGV0aGVyIHRvIGFsbG93IGNvbXBhY3Rpb24gb2YgcmV0dXJuZWQgcHVmZnNcbi8vICAgICB2YXIgcmV2ZXJzZSAgICAgPSBvcHRpb25zLnJldmVyc2UgfHwgZmFsc2UgIC8vIHJldHVybiBib3R0b20gcHVmZnMgaW5zdGVhZCBvZiB0b3AgcHVmZnNcbi8vIH1cblxuRUIuRGF0YS5nYXJiYWdlQ29tcGFjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gYXJlIHdlIG92ZXIgdGhlIGxpbWl0cz9cbiAgICB2YXIgbGltaXQgICAgID0gRUIuQ09ORklHLmluTWVtb3J5U2hlbGxMaW1pdFxuICAgIHZhciBtZW1saW1pdCAgPSBFQi5DT05GSUcuaW5NZW1vcnlNZW1vcnlMaW1pdFxuICAgIHZhciBzaXplbGltaXQgPSBFQi5DT05GSUcuc2hlbGxDb250ZW50VGhyZXNob2xkXG4gICAgdmFyIGRpZFN0dWZmICA9IGZhbHNlXG5cbiAgICBpZihFQi5EYXRhLnNoZWxscy5sZW5ndGggPiBsaW1pdCkge1xuICAgICAgICBkaWRTdHVmZiA9IHRydWVcbiAgICAgICAgRUIuRGF0YS5zaGVsbHMuc2xpY2UobGltaXQpLm1hcChFQi5wcm9wKCdzaWcnKSkuZm9yRWFjaChFQi5EYXRhLnJlbW92ZVNoZWxsRnJvbUNhY2hlKVxuICAgIH1cbiAgICBcbiAgICBpZihFQi5EYXRhLnJ1bm5pbmdTaXplVGFsbHkgPiBtZW1saW1pdCkge1xuICAgICAgICBkaWRTdHVmZiA9IHRydWVcbiAgICAgICAgZm9yICh2YXIgaSA9IEVCLkRhdGEuc2hlbGxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgc2hlbGwgPSBFQi5EYXRhLnNoZWxsc1tpXVxuICAgICAgICAgICAgdmFyIGNvbnRlbnRfc2l6ZSA9IChzaGVsbC5wYXlsb2FkLmNvbnRlbnR8fFwiXCIpLnRvU3RyaW5nKCkubGVuZ3RoIC8vIFRISU5LOiBub24tZmxhdCBjb250ZW50IGJvcmtzIHRoaXNcbiAgICAgICAgICAgIGlmIChjb250ZW50X3NpemUgPiBzaXplbGltaXQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2hlbGwucGF5bG9hZC5jb250ZW50IC8vIFRISU5LOiB0aGlzIGlzIGhhcmRjb3JlXG4gICAgICAgICAgICAgICAgdG90YWwgLT0gY29udGVudF9zaXplICsgMTMgLy8gTk9URTogbWFnaWMgbnVtYmVyID09ICdcImNvbnRlbnRcIjpcIlwiLCcubGVuZ3RoXG4gICAgICAgICAgICAgICAgaWYodG90YWwgPD0gbWVtbGltaXQpIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRpZFN0dWZmXG59XG5cblxuRUIuRGF0YS5nZXRTaGVsbHNGb3JMb2NhbFN0b3JhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGltaXQgICAgID0gRUIuQ09ORklHLmxvY2FsU3RvcmFnZVNoZWxsTGltaXRcbiAgICB2YXIgbWVtbGltaXQgID0gRUIuQ09ORklHLmxvY2FsU3RvcmFnZU1lbW9yeUxpbWl0XG4gICAgdmFyIHNpemVsaW1pdCA9IEVCLkNPTkZJRy5zaGVsbENvbnRlbnRUaHJlc2hvbGRcbiAgICBcbiAgICB2YXIgc2hlbGxzID0gRUIuRGF0YS5nZXRUb3BQdWZmcyhsaW1pdClcbiAgICB2YXIgdG90YWwgPSBzaGVsbHMucmVkdWNlKGZ1bmN0aW9uKHNpemUsIHNoZWxsKSB7XG4gICAgICAgIHJldHVybiBzaXplICsgKEVCLkRhdGEuZ2V0Qm9udXMoc2hlbGwsICdzaXplJykgfHwgMClcbiAgICB9LCAwKVxuICAgIFxuICAgIGlmICh0b3RhbCA8PSBtZW1saW1pdCkgcmV0dXJuIHNoZWxsc1xuICAgIFxuICAgIC8vIGNvbXBhY3QgdGhlIHB1ZmZzXG4gICAgZm9yICh2YXIgaSA9IHNoZWxscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgc2hlbGwgPSBzaGVsbHNbaV1cbiAgICAgICAgdmFyIGNvbnRlbnRfc2l6ZSA9IChzaGVsbC5wYXlsb2FkLmNvbnRlbnR8fFwiXCIpLnRvU3RyaW5nKCkubGVuZ3RoIC8vIFRISU5LOiBub24tZmxhdCBjb250ZW50IGJvcmtzIHRoaXNcbiAgICAgICAgaWYgKGNvbnRlbnRfc2l6ZSA+IHNpemVsaW1pdCkge1xuICAgICAgICAgICAgdmFyIG5ld19zaGVsbCA9IEVCLlB1ZmYuY29tcGFjdFB1ZmYoc2hlbGwpXG4gICAgICAgICAgICBzaGVsbHNbaV0gPSBuZXdfc2hlbGxcbiAgICAgICAgICAgIHRvdGFsIC09IGNvbnRlbnRfc2l6ZSArIDEzIC8vIE5PVEU6IG1hZ2ljIG51bWJlciA9PSAnXCJjb250ZW50XCI6XCJcIiwnLmxlbmd0aFxuICAgICAgICAgICAgaWYodG90YWwgPD0gbWVtbGltaXQpIGJyZWFrXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHRvdGFsIDw9IG1lbWxpbWl0KSByZXR1cm4gc2hlbGxzXG4gICAgXG4gICAgLy8gcmVtb3ZlIHNoZWxscyB1bnRpbCB1bmRlciBtZW1saW1pdFxuICAgIGZvciAodmFyIGkgPSBzaGVsbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGNvbnRlbnRfc2l6ZSA9IEpTT04uc3RyaW5naWZ5KHNoZWxsKS5sZW5ndGhcbiAgICAgICAgdG90YWwgLT0gY29udGVudF9zaXplXG4gICAgICAgIGlmKHRvdGFsIDw9IG1lbWxpbWl0KSBicmVha1xuICAgIH1cbiAgICBcbiAgICBzaGVsbHMgPSBzaGVsbHMuc2xpY2UoMCwgTWF0aC5tYXgoaSwgMSkpIC8vIHByZXZlbnQgLTEgXG4gICAgXG4gICAgcmV0dXJuIHNoZWxsc1xufVxuXG5cblxuXG5cblxuLy8gLyoqXG4vLyAgKiB0byBmaWxsIHNvbWUgc2xvdHNcbi8vICAqIEBwYXJhbSB7bnVtYmVyfSBuZWVkXG4vLyAgKiBAcGFyYW0ge251bWJlcn0gaGF2ZVxuLy8gICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5XG4vLyAgKiBAcGFyYW0ge3N0cmluZ30gZmlsdGVyc1xuLy8gICogQHJldHVybnMge2Jvb2xlYW59XG4vLyAgKi9cbi8vIEVCLkRhdGEuZmlsbFNvbWVTbG90c1BsZWFzZSA9IGZ1bmN0aW9uKG5lZWQsIGhhdmUsIHF1ZXJ5LCBmaWx0ZXJzKSB7XG4vLyAgICAgLy8vLyB3ZSBoYXZlIGVtcHR5IHNsb3RzIG9uIHNjcmVlbi4gZmlsbCB0aGVtIHdpdGggcHVmZnMuXG4vL1xuLy8gICAgIGlmKGhhdmUgPj0gbmVlZCkgcmV0dXJuIGZhbHNlXG4vL1xuLy8gICAgIC8vIC0tIHJlZHJhdyBzY3JlZW4gb24gbmV3IHB1ZmZzIGJlaW5nIGluZ2VzdGVkICh3L28gbG9vcGluZylcbi8vICAgICAvLyAtLSBjeWNsZSBhbGwgbmV3IHB1ZmZzIHRocm91Z2ggZ3JhcGggc3R1ZmZcbi8vICAgICAvLyAtLSBjYWxsIGZpbGxTb21lU2xvdHNQbGVhc2UgZXZlcnkgdGltZSB3ZSBoYXZlIHNsb3RzIHRvIGZpbGxcbi8vICAgICAvLyAtLSBnZXQgZm9jdXNlZCBwdWZmIGltbWVkaWF0ZWx5XG4vL1xuLy8gICAgIC8vIC0gcGVyZm9ybSBHQyBvbiBpbi1tZW1vcnkgcHVmZnMgKGNhbiByZW1vdmUgY29udGVudCBhbHNvKVxuLy8gICAgIC8vIC0gdXNlIEdDIGZ1bnMgZm9yIHBlcnNpc3Rpbmcgc2hlbGxzXG4vLyAgICAgLy8gLSBzdG9yZSBzaXplIG9mIGVhY2ggc2hlbGwvcHVmZiBmb3IgR0Ncbi8vICAgICAvLyAtIG1hbmFnZSBlbXB0eSB2ZXJ0aWNlcyBiZXR0ZXIgKGRpZmZlcmVudCB0eXBlPylcbi8vXG4vLyAgICAgdmFyIGFyZ3MgPSBbcXVlcnksIGZpbHRlcnNdXG4vLyAgICAgLy8gdmFyIGFyZ3MgPSBbcXVlcnksIGZpbHRlcnMsIG5lZWRdXG4vLyAgICAgLy8gaWYoIXF1ZXJ5Lm1vZGUpIGFyZ3MucHVzaChoYXZlKSAvLyBoYWNrIGZvciBhbHRlcm5hdGUgcXVlcnkgbW9kZXNcbi8vXG4vLyAgICAgdmFyIGtleSA9IEpTT04uc3RyaW5naWZ5KGFyZ3MpXG4vLyAgICAgdmFyIG15X29mZnNldCA9IEVCLkRhdGEuc2xvdExvY2tlcltrZXldIHx8IDBcbi8vXG4vLyAgICAgaWYobXlfb2Zmc2V0IDwgMClcbi8vICAgICAgICAgcmV0dXJuIGZhbHNlIC8vIHNsb3QgaXMgbG9ja2VkLCBnbyBlbHNld2hlcmVcbi8vXG4vLyAgICAgRUIuRGF0YS5zbG90TG9ja2VyW2tleV0gPSAtMSAvLyBwcmV2ZW50IGNvbmN1cnJlbnQgdmVyc2lvbnMgb2YgdGhlIHNhbWUgcmVxdWVzdFxuLy9cbi8vICAgICAvLy8vLy9cbi8vXG4vLyAgICAgLy8gdmFyIGxpbWl0ID0gbmVlZCAtIGhhdmUgKyAzIC8vIDMgZm9yIGx1Y2tcbi8vXG4vLyAgICAgdmFyIGxpbWl0ID0gbmVlZCAvLyBzby4uLiBpZiB3ZSBvbmx5IGRvIHRoaXMgb25jZSwgYW5kIHdlIGhhdmUgaGFsZiB0aGUgcHVmZnMgYWxyZWFkeSwgd2UgbWlnaHQgb25seSBncmFiIHRoYXQgaGFsZiBhZ2Fpbi4gdGhpcyBpcyB0cnVlIGV2ZW4gaWYgd2Ugc2VuZCBhbiBvZmZzZXQgb2YgJ2hhdmUnIHRvIHRoZSBzZXJ2ZXIsIGJlY2F1c2Ugd2hhdCB3ZSBoYXZlIG1pZ2h0IG1hcCB0byB0aGF0IHNsaWNlIChvciB0byBhbnl0aGluZyBlbHNlIC0tIG91ciBvZmZzZXRzIGFyZSB0b3RhbGx5IGRpZmZlcmVudCB0aGFuIHRoZSBzZXJ2ZXJzKS4gc28gd2UgaGF2ZSB0byBncmFiIGVub3VnaCB0byBjb3ZlciB0aGUgZGlmZmVyZW5jZSwgd2hpY2ggbWVhbnMgZ3JhYmJpbmcgdGhlIHNhbWUgc2hlbGxzIG11bHRpcGxlIHRpbWVzLi4uIChidXQgb25seSBlbXB0eSBzaGVsbHMsIGZvcnR1bmF0ZWx5LiBidXQgc3RpbGwuKVxuLy9cbi8vICAgICAvLyB2YXIgcmVjZWl2ZWRfc2hlbGxzID0gMFxuLy9cbi8vICAgICB2YXIgcHJvbSA9IEVCLk5ldC5nZXRTb21lU2hlbGxzKHF1ZXJ5LCBmaWx0ZXJzLCBsaW1pdCwgcXVlcnkub2Zmc2V0KVxuLy8gICAgIC8vIHByb20udGhlbihmdW5jdGlvbihzaGVsbHMpIHtyZWNlaXZlZF9zaGVsbHMgPSBzaGVsbHMubGVuZ3RoOyByZXR1cm4gc2hlbGxzfSlcbi8vICAgICBwcm9tLnRoZW4oRUIuRGF0YS5hZGRTaGVsbHNUaGVuTWFrZUF2YWlsYWJsZSlcbi8vICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGVsdGEpIHtcbi8vICAgICAgICAgICAgIEVCLkRhdGEuc2xvdExvY2tlcltrZXldID0gZGVsdGEgPyAxIDogLTF9KVxuLy8gICAgICAgICAgICAgLy8gaWYgdGhlIHJlcXVlc3QgaXMgZnJ1aXRmdWwsIHVubG9jayBpdCAoYnV0IGJlIGNhcmVmdWwgb2Ygb2Zmc2V0cyBoZXJlKS5cbi8vICAgICAgICAgICAgIC8vIGFsc28sIHRoaXMgbG9ja3Mgd2hlbiB3ZSByZWNlaXZlZCBkYXRhIGJ1dCBjaG9zZSBub3QgdG8ga2VlcCBpdCAoZWl0aGVyIGR1cHMgb3IgR0MpLFxuLy8gICAgICAgICAgICAgLy8gc28gd2UgY291bGQgaGF2ZSBhbiBpc3N1ZSB3aXRoIGxvY2tlZCBxdWVyaWVzIHRoYXQgd291bGQgYmUgZnJ1aXRmdWwgdy8gZGlmZmVyZW50IG9mZnNldCAvIGxpbWl0cy4uLlxuLy9cbi8vXG4vLyAgICAgLy8gVE9ETzogdGhlIHNsb3RMb2NrZXIgcmVhbGx5IHNob3VsZCBrZWVwIHRyYWNrIG9mIHdoYXQgJ3NsaWNlcycgb2YgdGhlIHNlcnZlciB5b3UndmUgc2Vlbiwgc28gd2Uga25vdyBub3QgdG8gcmUtcmVxdWVzdCB0aG9zZSBvdmVyIGFuZCBvdmVyLiB0aGlzIGlzLi4uIGNvbXBsaWNhdGVkLlxuLy8gICAgIC8vICAgICAgIHNvIHNlbmQgcXVlcnkub2Zmc2V0K2hhdmUgdG8gZ2V0U29tZVNoZWxscywgYW5kIHN0b3JlIHRoYXQgc2FtZSBvZmZzZXQgYXMgcGFydCBvZiB0aGUgc2xvdExvY2tlci5cbi8vICAgICAvLyAgICAgICB0aGVuIHlvdSBjYW4gdHJhY2sgaG93IG11Y2ggb2Ygc29tZSB0eXBlIG9mIHN0dWZmIGlzIG9uIHRoZSBzZXJ2ZXIuLi4gZXhjZXB0IHRoYXQgZG9lc24ndCB3b3JrIGZvciB0aGUgUDJQIG5ldHdvcmsuXG4vL1xuLy8gICAgIHJldHVybiB0cnVlXG4vL1xuLy8gICAgIC8vLy8vL1xuLy9cbi8vXG4vLyAgICAgLy8gT0xEIFNUVUZGIFNBVkUgRk9SIFJFRkVSRU5DRVxuLy9cbi8vICAgICAvLyB2YXIgYmF0Y2hTaXplID0gRUIuQ09ORklHLmZpbGxTbG90c0JhdGNoU2l6ZVxuLy8gICAgIC8vIHZhciBnaXZldXAgPSBFQi5DT05GSUcuZmlsbFNsb3RzR2l2ZXVwXG4vLyAgICAgLy8gdmFyIG5ld19zaGVsbHMgPSBbXVxuLy8gICAgIC8vXG4vLyAgICAgLy8gZ2l2ZXVwID0gZ2l2ZXVwICsgbXlfb2Zmc2V0XG4vLyAgICAgLy9cbi8vICAgICAvLyBmdW5jdGlvbiBnZXRNZVNvbWVTaGVsbHMocHVmZnMpIHtcbi8vICAgICAvLyAgICAgaWYocHVmZnMpIHtcbi8vICAgICAvLyAgICAgICAgIHZhciBteV9uZXdfc2hlbGxzID0gRUIuRGF0YS5oZXJlSGF2ZVNvbWVOZXdTaGVsbHMocHVmZnMpXG4vLyAgICAgLy8gICAgICAgICBuZXdfc2hlbGxzID0gbmV3X3NoZWxscy5jb25jYXQobXlfbmV3X3NoZWxscylcbi8vICAgICAvLyAgICAgICAgIHZhciBkZWx0YSA9IG15X25ld19zaGVsbHMubGVuZ3RoXG4vLyAgICAgLy8gICAgICAgICAvLyBUSElOSzogYnV0IGRvIHRoZXkgcGFzcyB0aGUgZmlsdGVyP1xuLy8gICAgIC8vICAgICAgICAgLy8gVE9ETzogY2FuIHdlIG1ha2UgYXZhaWxhYmxlIGhlcmUgbm93IHRoYXQgd2UncmUgbG9ja2luZz9cbi8vICAgICAvLyAgICAgICAgIGhhdmUgKz0gZGVsdGEgfHwgMFxuLy8gICAgIC8vICAgICB9XG4vLyAgICAgLy9cbi8vICAgICAvLyAgICAgaWYoaGF2ZSA+PSBuZWVkIHx8IG15X29mZnNldCA+IGdpdmV1cCB8fCAocXVlcnkubW9kZSAmJiAobXlfb2Zmc2V0IC0gZ2l2ZXVwIDwgMCkpKSB7XG4vLyAgICAgLy8gICAgICAgICBFQi5EYXRhLm1ha2VTaGVsbHNBdmFpbGFibGUobmV3X3NoZWxscylcbi8vICAgICAvLyAgICAgICAgIEVCLkRhdGEuc2xvdExvY2tlcltrZXldID0gbXlfb2Zmc2V0LWxpbWl0XG4vLyAgICAgLy8gICAgICAgICByZXR1cm4gZmFsc2Vcbi8vICAgICAvLyAgICAgfVxuLy8gICAgIC8vXG4vLyAgICAgLy8gICAgIHZhciBsaW1pdCA9IG5lZWQgLSBoYXZlXG4vLyAgICAgLy8gICAgIC8vIGlmKCFxdWVyeS5tb2RlKSBsaW1pdCArPSA1MCAvLyBncmFiIGEgZmV3IGV4dHJhcyB0byBoZWxwIHdvcmsgdGhyb3VnaCBiYXJlIHBhdGNoZXNcbi8vICAgICAvL1xuLy8gICAgIC8vICAgICB2YXIgcHJvbSA9IEVCLk5ldC5nZXRTb21lU2hlbGxzKHF1ZXJ5LCBmaWx0ZXJzLCBsaW1pdCwgbXlfb2Zmc2V0KVxuLy8gICAgIC8vICAgICBwcm9tLnRoZW4oZ2V0TWVTb21lU2hlbGxzKVxuLy8gICAgIC8vXG4vLyAgICAgLy8gICAgIG15X29mZnNldCArPSBsaW1pdFxuLy8gICAgIC8vIH1cbi8vICAgICAvL1xuLy8gICAgIC8vIGdldE1lU29tZVNoZWxscygpXG4vLyB9XG5cbiIsIi8qXG5cbiAgICBOZXR3b3JrIGxpYnJhcnkgZm9yIHRoZSBFdmVyeUJpdCBwbGF0Zm9ybS5cblxuICAgIENvbnRhaW5zIGEgcGVlci5qcy1iYXNlZCBwMnAgbGF5ZXIsIGEgcHJvbWlzZS1iYXNlZCBYSFIgaW1wbGVtZW50YXRpb24sIFxuICAgIGhlbHBlciBmdW5jdGlvbnMgZm9yIGFjY2Vzc2luZyB2YXJpb3VzIHNlcnZlci1iYXNlZCBBUElzLCBcbiAgICBhbmQgaGVscGVyIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgcHVmZiBkaXN0cmlidXRpb24gYW5kIGFjcXVpc2l0aW9uLlxuXG4gICAgQ29weXJpZ2h0IDIwMTQtMjAxNSBFdmVyeUJpdC4gU2VlIFJFQURNRSBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuICovXG5cbkVCLk5ldCA9IHt9XG5cbi8qKlxuICogRmlyZSB1cCBuZXR3b3JrcyAoY3VycmVudGx5IGp1c3QgdGhlIHBlZXIgY29ubmVjdGlvbnMpXG4gKi9cbkVCLk5ldC5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgRUIuTmV0LlAyUC5pbml0KClcbn1cblxuLyoqXG4gKiBHaXZlbiBhIHNpZ25hdHVyZSwgcmV0dXJuIHB1ZmYgd2l0aCB0aGF0IHNpZ25hdHVyZVxuICogQHBhcmFtICB7c3RyaW5nfSBzaWcgc2lnbmF0dXJlIG9mIGEgcHVmZlxuICogQHJldHVybiB7b2JqZWN0fSAgICAgcHVmZiBjb3JyZXNwb25kcyB0byB0aGUgc3BlY2lmaWVkIHNpZ25hdHVyZVxuICovXG5FQi5OZXQuZ2V0UHVmZkJ5U2lnID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgdmFyIHVybCAgPSBFQi5DT05GSUcucHVmZkFwaVxuICAgIHZhciBkYXRhID0ge3R5cGU6ICdnZXRQdWZmQnlTaWcnLCBzaWc6IHNpZ31cbiAgICBcbiAgICByZXR1cm4gRUIuTmV0LkVCZ2V0SlNPTih1cmwsIGRhdGEpXG59XG5cbkVCLk5ldC5nZXRLaWRTaWdzID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgdmFyIHVybCAgPSBFQi5DT05GSUcucHVmZkFwaVxuICAgIHZhciBkYXRhID0ge3R5cGU6ICdnZXRDaGlsZHJlbkJ5U2lnJywgc2lnOiBzaWd9XG4gICAgXG4gICAgcmV0dXJuIEVCLk5ldC5FQmdldEpTT04odXJsLCBkYXRhKVxufVxuXG5FQi5OZXQuZ2V0S2lkU2lncyA9IEJvcm9uLm1lbW9pemUoRUIuTmV0LmdldEtpZFNpZ3MpIC8vIFRISU5LOiB0aGlzIGFzc3VtZXMgd2UnbGwgZ2V0IGFsbCBuZXcgdGhpbmdzIG92ZXIgdGhlIFAyUCBuZXR3b3JrLCB3aGljaCB3b24ndCBhbHdheXMgYmUgdHJ1ZS5cblxuXG5cbkVCLk5ldC5nZXRTdGFyU2hlbGxzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHVybCAgPSBFQi5DT05GSUcucHVmZkFwaVxuICAgIHZhciBkYXRhID0ge3R5cGU6ICdnZXRQdWZmcycsIGNvbnRlbnRUeXBlOiAnc3RhcicsIG51bWI6IEVCLkNPTkZJRy5nbG9iYWxCaWdCYXRjaExpbWl0fVxuICAgIFxuICAgIHJldHVybiBFQi5OZXQuRUJnZXRKU09OKHVybCwgZGF0YSlcbn1cblxuRUIuTmV0LmdldENvbnZlcnNhdGlvblB1ZmZzID0gZnVuY3Rpb24oY29udm9JZCwgYmF0Y2hzaXplLCBvZmZzZXQsIGZ1bGxPclNoZWxsKSB7XG4gICAgY29udm9JZCAgPSBjb252b0lkLnJlcGxhY2UoJyYnLCcsJylcblxuICAgIHZhciB1cmwgID0gRUIuQ09ORklHLnB1ZmZBcGlcbiAgICB2YXIgZGF0YSA9IHsgdHlwZTogJ2dldFB1ZmZzJywgY29udGVudFR5cGU6ICdlbmNyeXB0ZWRwdWZmJ1xuICAgICAgICAgICAgICAgLCBjb252ZXJzYXRpb25QYXJ0bmVyczogY29udm9JZFxuICAgICAgICAgICAgICAgLCBudW1iOiBiYXRjaHNpemVcbiAgICAgICAgICAgICAgICwgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICByZXR1cm4gRUIuTmV0LkVCZ2V0SlNPTih1cmwsIGRhdGEpXG59XG5cbkVCLk5ldC5nZXRNeVByaXZhdGVQdWZmcyA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBiYXRjaHNpemUsIG9mZnNldCwgZnVsbE9yU2hlbGwpIHtcbiAgICBpZighdXNlcm5hbWUpIHJldHVybiBFQi5lbXB0eVByb21pc2UoKVxuICAgIGJhdGNoc2l6ZSA9IGJhdGNoc2l6ZSB8fCBFQi5DT05GSUcuZ2xvYmFsQmlnQmF0Y2hMaW1pdFxuICAgIFxuICAgIHZhciB1cmwgID0gRUIuQ09ORklHLnB1ZmZBcGlcbiAgICB2YXIgZGF0YSA9IHsgcm91dGU6IHVzZXJuYW1lLCB1c2VybmFtZTogdXNlcm5hbWUsIGZyb21BbmRUbzogMVxuICAgICAgICAgICAgICAgLCB0eXBlOiAnZ2V0UHVmZnMnLCBjb250ZW50VHlwZTogJ2VuY3J5cHRlZHB1ZmYnXG4gICAgICAgICAgICAgICAsIGZ1bGxPclNoZWxsOiBmdWxsT3JTaGVsbCB8fCAnZnVsbCdcbiAgICAgICAgICAgICAgICwgbnVtYjogYmF0Y2hzaXplXG4gICAgICAgICAgICAgICAsIG9mZnNldDogb2Zmc2V0XG4gICAgICAgICAgICAgICB9XG4gICAgXG4gICAgcmV0dXJuIEVCLk5ldC5FQmdldEpTT04odXJsLCBkYXRhKVxuICAgIFxuLypcblxuICAgIFNvIHNvbWV0aGluZyBsaWtlOlxuXG4gICAgRUIuZ2V0U29tZVB1ZmZzKHF1ZXJ5LCBsaW1pdCwgZXRjKVxuXG4gICAgaGVscGVyLmpzOlxuICAgIHRyeUdldHRpbmdNb3JlUHVmZnModmlzaWJsZUxpbWl0KSB7XG4gICAgICAgIC8vIGZpZ3VyZSBvdXQgaG93IG1hbnkgd2UndmUgcmVxdWVzdGVkIGFscmVhZHkgKEVCLmN1cnJlbnRPZmZzZXQpXG4gICAgICAgIC8vIGZpZ3VyZSBvdXQgaG93IG1hbnkgd2UgYWN0dWFsbHkgaGF2ZSAoRUIuRGF0YS5nZXREZWNyeXB0ZWRQdWZmcylcbiAgICAgICAgdmFyIGRlbHRhID0gdmlzaWJsZUxpbWl0IC0gRUIuRGF0YS5nZXREZWNyeXB0ZWRQdWZmcygpLmxlbmd0aFxuICAgICAgICBFQi5jdXJyZW50T2Zmc2V0ICs9IGRlbHRhXG4gICAgICAgIHJldHVybiBFQi5nZXRTb21lUHVmZnMocXVlcnksIEVCLmN1cnJlbnRPZmZzZXQpXG4gICAgfVxuXG5cbiovIFxuXG4gICAgLy8gVE9ETzogY2hhaW4gdGhpcyBpbiB0byB0aGUgdGFibGUgdmlld1xuICAgIFxufVxuXG5cbkVCLk5ldC5nZXRQcm9maWxlUHVmZiA9IGZ1bmN0aW9uKHVzZXJuYW1lKSB7XG4gICAgdmFyIHVybCAgPSBFQi5DT05GSUcucHVmZkFwaVxuICAgIHZhciBkYXRhID0geyB1c2VybmFtZTogdXNlcm5hbWVcbiAgICAgICAgICAgICAgICwgZnVsbE9yU2hlbGw6ICdmdWxsJ1xuICAgICAgICAgICAgICAgLCBjb250ZW50VHlwZTogJ3Byb2ZpbGUnXG4gICAgICAgICAgICAgICAsIHR5cGU6ICdnZXRQdWZmcydcbiAgICAgICAgICAgICAgICwgc29ydDogJ0RFU0MnXG4gICAgICAgICAgICAgICAsIG51bWI6IDFcbiAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICByZXR1cm4gRUIuTmV0LkVCZ2V0SlNPTih1cmwsIGRhdGEpXG59XG5cbkVCLk5ldC5nZXRQcm9maWxlUHVmZiA9IEVCLnByb21pc2VNZW1vaXplKEVCLk5ldC5nZXRQcm9maWxlUHVmZilcblxuXG4vKipcbiAqIHRvIGdldCBzb21lIHNoZWxsc1xuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7U2hlbGxbXX1cbiAqL1xuRUIuTmV0LmdldFNvbWVTaGVsbHMgPSBmdW5jdGlvbihxdWVyeSwgZmlsdGVycywgbGltaXQsIG9mZnNldCkge1xuICAgIC8vIFRPRE86IHN3aXRjaGluZyBieSBxdWVyeSAnbW9kZScgd2lsbCBuZWVkIHRvIGJlIGNoYW5nZWQgd2hlbiB0aGUgbmV0d29yayBhcGkgbWF0Y2hlcyBvdXIgbG9jYWwgYXBpIChpLmUuIG9uY2Ugd2UgdXNlIGJyb3dzZXIgcDJwICYgaGVhZGxlc3MgY2xpZW50cyB0byBzZXJ2aWNlIHJlcXVlc3RzKVxuICAgIFxuICAgIHZhciBtb2RlID0gcXVlcnkubW9kZVxuICAgIC8vIGlmKG1vZGUgPT0gJ2FuY2VzdG9ycycpICAgcmV0dXJuIEVCLk5ldC5nZXRBbmNlc3RvcnMgIChbcXVlcnkuZm9jdXNdLCBsaW1pdClcbiAgICAvLyBpZihtb2RlID09ICdkZXNjZW5kYW50cycpIHJldHVybiBFQi5OZXQuZ2V0RGVzY2VuZGFudHMoW3F1ZXJ5LmZvY3VzXSwgbGltaXQpXG4gICAgLy8gaWYobW9kZSA9PSAnc2libGluZ3MnKSAgICByZXR1cm4gRUIuTmV0LmdldFNpYmxpbmdzICAgKFtxdWVyeS5mb2N1c10sIGxpbWl0KVxuXG4gICAgLy8gXCJub3JtYWxcIiBtb2RlIChqdXN0IGFzayBmb3Igc2hlbGxzIGZyb20gbGlzdHMgb3Igc29tZXRoaW5nKVxuICAgIHZhciB1cmwgID0gRUIuQ09ORklHLnB1ZmZBcGlcblxuICAgIC8vICBpZihmaWx0ZXJzLnR5cGVzKSAgIGRhdGEudHlwZSAgICAgICA9IGZpbHRlcnMudHlwZXMgICAgICAvLyBmaWx0ZXIgYnkgdHlwZXNcblxuICAgIHZhciBkYXRhID0ge3R5cGU6ICdnZXRQdWZmcycsIGNvbnRlbnRUeXBlOiAncGxhaW4nfVxuICAgIC8vIHZhciBkYXRhID0ge3R5cGU6ICdnZXRQdWZmcycsIGNvbnRlbnRUeXBlOiAnW1wiaW1hZ2VcIl0nfVxuXG5cbiAgICBpZihsaW1pdCkgIGRhdGEubnVtYiAgICA9IGxpbWl0ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHRzIHRvIDIwIG9uIHRoZSBzZXJ2ZXJcbiAgICBpZihvZmZzZXQpIGRhdGEub2Zmc2V0ICA9IG9mZnNldCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHRzIHRvIDAsIHdoaWNoIGlzIGxhdGVzdFxuICAgIFxuICAgIGlmKHF1ZXJ5LnNvcnQpICAgICAgZGF0YS5zb3J0ICAgICAgICA9IHF1ZXJ5LnNvcnQgICAgICAgLy8gQVNDIG9yIERFU0NcbiAgICBpZihmaWx0ZXJzLnVzZXJzKSAgIGRhdGEudXNlcm5hbWUgICAgPSBmaWx0ZXJzLnVzZXJzICAgIC8vIGZpbHRlciBieSB1c2VybmFtZVxuICAgIGlmKGZpbHRlcnMucm91dGVzKSAgZGF0YS5yb3V0ZSAgICAgICA9IGZpbHRlcnMucm91dGVzICAgLy8gZmlsdGVyIGJ5IHJvdXRlXG4gICAgaWYoZmlsdGVycy50YWdzKSAgICBkYXRhLnRhZ3MgICAgICAgID0gZmlsdGVycy50YWdzICAgICAvLyBmaWx0ZXIgYnkgdGFnc1xuICAgIGlmKGZpbHRlcnMudHlwZXMpICAgZGF0YS5jb250ZW50VHlwZSA9IGZpbHRlcnMudHlwZXMgICAgLy8gZmlsdGVyIGJ5IHR5cGVzXG4gICAgaWYocXVlcnkuYW5jZXN0b3JzKSBkYXRhLm1heFBhcmVudHMgID0gcXVlcnkuYW5jZXN0b3JzICAvLyBkZWZhdWx0cyB0byBhbGwgc2hlbGxzIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCBpcyByb290cywgMSBpcyBzaW5nbGUgcGFyZW50LCBldGNcbiAgICAvLyBkYXRhLmZsYWdnZWQgPSBmYWxzZVxuICAgIFxuICAgIC8vIGRhdGEuZm9jdXNcbiAgICAvLyBkYXRhLmFuY2VzdG9yc1xuICAgIC8vIGRhdGEuZGVzY2VuZGFudHNcbiAgICBcbiAgICB2YXIgZmlsdGVyc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZmlsdGVycy50eXBlcylcbiAgICB2YXIgcHJvZmlsZV9yZXF1ZXN0ID0gKGZpbHRlcnN0cmluZyA9PSAnW1wicHJvZmlsZVwiXScpXG4gICAgXG4gICAgaWYoRUIuQ09ORklHLmRpc2FibGVSZWNlaXZlUHVibGljICYmICFwcm9maWxlX3JlcXVlc3QpXG4gICAgICAgIHJldHVybiBFQi5lbXB0eVByb21pc2UoKVxuICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtyZXR1cm4gW119KVxuICAgIFxuICAgIHJldHVybiBFQi5OZXQuRUJnZXRKU09OKHVybCwgZGF0YSkgICAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIHJldHVybnMgYSB2YWxpZCBhcnJheVxuICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbih4KSB7cmV0dXJuIHggfHwgW119LCBmdW5jdGlvbigpIHtyZXR1cm4gW119KVxufVxuXG5cbi8qKlxuICogYWRkIHB1ZmYgdG8gdGhlIHNlcnZlciBhbmQgYnJvYWRjYXN0IHRvIHBlZXJzXG4gKiBAcGFyYW0gIHtvYmplY3R9IHB1ZmYgdGhlIHB1ZmYgdG8gYmUgYWRkZWQgdG8gdGhlIHNlcnZlclxuICovXG5FQi5OZXQuZGlzdHJpYnV0ZVB1ZmYgPSBmdW5jdGlvbihwdWZmKSB7XG4gICAgLy8vLyBkaXN0cmlidXRlIGEgcHVmZiB0byB0aGUgbmV0d29ya1xuXG4gICAgaWYoRUIuQ09ORklHLmRpc2FibGVTZW5kVG9TZXJ2ZXIpIHJldHVybiBmYWxzZSAgICAgICAgICAvLyBzbyB5b3UgY2FuIHdvcmsgbG9jYWxseVxuXG4gICAgaWYoRUIuQ09ORklHLm5ldGJsb2NrU3VmZml4KSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBibG9jayBkaXN0cmlidXRpb24gb2YgbG9jYWwgcHVmZnNcbiAgICAgICAgdmFyIHVzZXJuYW1lcyA9IFtwdWZmLnVzZXJuYW1lXVxuICAgICAgICBpZihwdWZmLmtleXMpXG4gICAgICAgICAgICB1c2VybmFtZXMgPSB1c2VybmFtZXMuY29uY2F0KE9iamVjdC5rZXlzKHB1ZmYua2V5cykpXG5cbiAgICAgICAgdXNlcm5hbWVzID0gdXNlcm5hbWVzLm1hcChFQi5Vc2Vycy5qdXN0VXNlcm5hbWUpXG4gICAgICAgIHZhciBzdWZmaXhlcyA9IHVzZXJuYW1lcy5tYXAoZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAgICAgICAgIHZhciBjaHVua3MgPSB1c2VybmFtZS5zcGxpdCgnLicpXG4gICAgICAgICAgICByZXR1cm4gY2h1bmtzW2NodW5rcy5sZW5ndGgtMV1cbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIGlmKHN1ZmZpeGVzLmluZGV4T2YoRUIuQ09ORklHLm5ldGJsb2NrU3VmZml4KSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgRUIuTmV0LnNlbmRQdWZmVG9TZXJ2ZXIocHVmZikgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIHNlcnZlcidzIHB1ZmZsaXN0XG5cbiAgICBFQi5OZXQuUDJQLnNlbmRQdWZmVG9QZWVycyhwdWZmKSAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyb2FkY2FzdCBpdCB0byBwZWVyc1xufVxuXG4vKipcbiAqIGFkZCBhIHB1ZmYgdG8gdGhlIHNlcnZlcidzIHB1ZmZsaXN0XG4gKiBAcGFyYW0gIHtvYmplY3R9IHB1ZmZcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuRUIuTmV0LnNlbmRQdWZmVG9TZXJ2ZXIgPSBmdW5jdGlvbihwdWZmKSB7XG4gICAgLy8gVEhJTks6IHRoaXMgaXMgZmlyZS1hbmQtZm9yZ2V0LCBidXQgd2Ugc2hvdWxkIGRvIHNvbWV0aGluZyBzbWFydCBpZiB0aGUgbmV0d29yayBpcyBvZmZsaW5lIG9yIGl0IG90aGVyd2lzZSBmYWlscy4gXG4gICAgLy8gICAgICAgIG9uIHRoZSBvdGhlciBoYW5kLCB3ZSdsbCBwcm9iYWJseSB3YW50IHRvIGRvIHRoaXMgd2l0aCBzb2NrZXRzIGluc3RlYWQgb2YgYWpheCB1bHRpbWF0ZWx5Li4uXG4gICAgLy8gICAgICAgIG9yIG1hbmFnZSBpdCBlbnRpcmVseSB3aXRoIHJvdXRpbmcsIGV2ZW4gZm9yIHNlcnZlci1zZW50IHB1ZmZzP1xuICAgIFxuICAgIHZhciBkYXRhID0geyB0eXBlOiAnYWRkUHVmZidcbiAgICAgICAgICAgICAgICwgcHVmZjogSlNPTi5zdHJpbmdpZnkocHVmZikgfVxuICAgICAgICAgICAgICAgXG4gICAgcmV0dXJuIEVCLk5ldC5FQnBvc3QoRUIuQ09ORklHLnB1ZmZBcGksIGRhdGEpXG4gICAgICAgICAgICAgICAgIC5jYXRjaChFQi5jYXRjaEVycm9yKCdDb3VsZCBub3Qgc2VuZCBwdWZmIHRvIHNlcnZlcicpKVxufVxuXG4vKipcbiAqIGZldGNoIGEgcGFydGljdWxhciB1c2VyUmVjb3JkXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICB1c2VybmFtZSBcbiAqIEBwYXJhbSAge3N0cmluZ30gIGNhcGEgXG4gKiBAcmV0dXJuIHtwcm9taXNlfSBvbiBmdWxmaWxsZWQgcGFzc2VzIHRoZSB1c2VyIHJlY29yZCBhcyBvYmplY3QsIG90aGVyd2lzZSByZS10aHJvdyBlcnJvclxuICovXG5FQi5OZXQuZ2V0VXNlclJlY29yZCA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBjYXBhKSB7XG4gICAgdmFyIHVybCAgID0gRUIuQ09ORklHLnVzZXJBcGlcbiAgICBcbiAgICB2YXIgdmVyc2lvbmVkVXNlcm5hbWUgPSBFQi5Vc2Vycy5tYWtlVmVyc2lvbmVkKHVzZXJuYW1lLCBjYXBhKVxuICAgIHVzZXJuYW1lID0gRUIuVXNlcnMuanVzdFVzZXJuYW1lKHZlcnNpb25lZFVzZXJuYW1lKVxuICAgIFxuICAgIGlmKGNhcGEgIT09IDApIC8vIDAgc2lnbmFscyB0aGF0IHdlIG5lZWQgdG8gZmV0Y2ggdGhlIGxhdGVzdCB1c2VyUmVjb3JkXG4gICAgICAgIGNhcGEgPSBFQi5Vc2Vycy5qdXN0Q2FwYSh2ZXJzaW9uZWRVc2VybmFtZSlcbiAgICBcbiAgICB2YXIgZGF0YSAgPSB7IHR5cGU6ICdnZXRVc2VyJ1xuICAgICAgICAgICAgICAgICwgdXNlcm5hbWU6IHVzZXJuYW1lXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgaWYoY2FwYSlcbiAgICAgICAgZGF0YS5jYXBhID0gY2FwYVxuXG4gICAgcmV0dXJuIEVCLk5ldC5FQmdldEpTT04odXJsLCBkYXRhKVxufVxuXG5cbi8qKlxuICogbW9kaWZ5IGEgdXNlciByZWNvcmRcbiAqIEBwYXJhbSAge3B1ZmZ9ICAgcHVmZiBhIHNpZ25lZCBwdWZmIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gb2YgbW9kaWZpZWQgdXNlciByZWNvcmRcbiAqIEByZXR1cm4ge29iamVjdH0gcHJvbWlzZSBmb3IgbmV3IHVzZXJSZWNvcmQgb3IgZXJyb3Igd2hlbiB0aGUgdXBkYXRlIGZhaWxzXG4gKi9cbkVCLk5ldC51cGRhdGVVc2VyUmVjb3JkID0gZnVuY3Rpb24ocHVmZikge1xuICAgIHZhciBkYXRhID0geyB0eXBlOiAndXBkYXRlVXNpbmdQdWZmJ1xuICAgICAgICAgICAgICAgLCBwdWZmOiBwdWZmXG4gICAgICAgICAgICAgICB9XG5cbiAgICB2YXIgcHJvbSA9IEVCLk5ldC5FQnBvc3QoRUIuQ09ORklHLnVzZXJBcGksIGRhdGEpXG4gICAgXG4gICAgcmV0dXJuIHByb20uY2F0Y2goRUIuY2F0Y2hFcnJvcignU2VuZGluZyB1c2VyIHJlY29yZCBtb2RpZmljYXRpb24gcHVmZiBmYWlsZWQnKSlcbiAgICAgICAgICAgICAgIC50aGVuKEpTT04ucGFyc2UpIC8vIFRISU5LOiB0aGlzIHRocm93cyBvbiBpbnZhbGlkIEpTT05cbiAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHVzZXJSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gRUIuVXNlcnMucHJvY2Vzcyh1c2VyUmVjb3JkKVxuICAgICAgICAgICAgICAgICAgICAgICB8fCBFQi50aHJvd0Vycm9yKCdJbnZhbGlkIHVzZXIgcmVjb3JkJywgSlNPTi5zdHJpbmdpZnkodXNlclJlY29yZCkpXG4gICAgICAgICAgICAgICB9KVxufVxuXG5cblxuLyoqXG4gKiBFQi5OZXQgcHJvbWlzZS1iYXNlZCBYSFIgbGF5ZXJcbiAqIFxuICogV2UgdXNlIHByb21pc2VzIGFzIG91ciBkZWZhdWx0IGNvbmN1cnJlbmN5IGNvbnN0cnVjdCwgXG4gKiBiZWNhdXNlIHVsdGltYXRlbHkgdGhpcyBwbGF0Zm9ybSBpcyBjb21wb3NlZCBvZiBhIFxuICogaHVnZSBzZXQgb2YgaW50ZXJkZXBlbmRlbnQgYXN5bmMgY2FsbHMgd2hpY2ggbW9zdGx5IFxuICogZWFjaCByZXNvbHZlIHRvIGEgc2luZ2xlIGltbXV0YWJsZSBlbnRpdHkgXG4gKiAtLSBha2EgdGhlIHByb21pc2Ugc3dlZXQgc3BvdC5cbiAqIFxuICogQHBhcmFtICB7c3RyaW5nfSB1cmwgICAgIHJlcXVlc3RlZCB1cmxcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBcbiAqIEBwYXJhbSAge29iamVjdH0gZGF0YSAgICBcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuRUIuTmV0LnhociA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucywgZGF0YSkge1xuICAgIC8vLy8gdmVyeSBzaW1wbGUgcHJvbWlzZS1iYXNlZCBYSFIgaW1wbGVtZW50YXRpb25cbiAgICBcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICAgICAgICByZXEub3BlbihvcHRpb25zLm1ldGhvZCB8fCAnR0VUJywgdXJsKVxuICAgICAgICBcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5oZWFkZXJzIHx8IHt9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgb3B0aW9ucy5oZWFkZXJzW2tleV0pXG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICB2YXIgZm9ybWRhdGEgPSBuZXcgRm9ybURhdGEoKVxuICAgICAgICBPYmplY3Qua2V5cyhkYXRhIHx8IHt9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBkYXR1bSA9IHR5cGVvZiBkYXRhW2tleV0gPT0gJ29iamVjdCcgPyBFQi5zdHJpbmdpZnlKU09OKGRhdGFba2V5XSkgOiBkYXRhW2tleV1cbiAgICAgICAgICAgIGZvcm1kYXRhLmFwcGVuZChrZXksIGRhdHVtKVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLnR5cGUpXG4gICAgICAgICAgICByZXEucmVzcG9uc2VUeXBlID0gb3B0aW9ucy50eXBlXG4gICAgICAgICAgICAgICAgXG4gICAgICAgIHJlcS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHJlcS5zdGF0dXMgIT0gMjAwKSAvLyBzaWxseSBzYWZhcmlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KEVCLm1ha2VFcnJvcihyZXEuc3RhdHVzVGV4dCkpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHJlcS5yZXNwb25zZVR5cGUgPT0gJ2pzb24nICYmIHJlcS5yZXNwb25zZSA9PT0gbnVsbCkgLy8gTk9URTogdHJhcHMgSlNPTmlmaWVkICdudWxsJyByZXNwb25zZXMgYWxzbzogdXNlIGVtcHR5IHN0cmluZyBvciBbXSB0byBpbmRpY2F0ZSBhbiBlbXB0eSByZXN1bHRcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KEVCLm1ha2VFcnJvcihcIkludmFsaWQgSlNPTiBpbiByZXNwb25zZVwiLCByZXEucmVzcG9uc2UpKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXNvbHZlKCAocmVxLnJlc3BvbnNlVHlwZSAhPSBvcHRpb25zLnR5cGUpIC8vIG1hbnVhbGx5IGNvbnZlcnQganNvbiBmb3Igb2xkIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgICAmJiBvcHRpb25zLnR5cGUgPT0gJ2pzb24nID8gRUIucGFyc2VKU09OKHJlcS5yZXNwb25zZSkgOiByZXEucmVzcG9uc2UpXG4gICAgICAgIH1cblxuICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICByZWplY3QoRUIubWFrZUVycm9yKFwiTmV0d29yayBFcnJvclwiLCBldmVudCwgJ25ldHdvcmtFcnJvcicpKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXEub250aW1lb3V0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHJlamVjdChFQi5tYWtlRXJyb3IoXCJUaW1lb3V0IEVycm9yXCIsIGV2ZW50LCAndGltZW91dEVycm9yJykpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJlcS50aW1lb3V0ID0gRUIuQ09ORklHLm5ldHdvcmtUaW1lb3V0XG5cbiAgICAgICAgcmVxLnNlbmQoZm9ybWRhdGEpXG4gICAgfSlcbn1cblxuLyoqXG4gKiByZXF1ZXN0IGFuIHVybCwgZ2V0IHJlc3VsdCBpbiBKU09OXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVybCAgICBcbiAqIEBwYXJhbSAge29iamVjdH0gcGFyYW1zIFxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5FQi5OZXQuZ2V0SlNPTiA9IGZ1bmN0aW9uKHVybCwgcGFyYW1zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7IGhlYWRlcnM6IHsgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICAgICAgICAsICBtZXRob2Q6ICdHRVQnXG4gICAgICAgICAgICAgICAgICAsICAgIHR5cGU6ICdqc29uJ1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9IHBhcmFtcyB8fCB7fVxuICAgIHZhciBlbmMgPSBmdW5jdGlvbihwYXJhbSkge3JldHVybiAhcGFyYW0gJiYgcGFyYW0hPT0wID8gJycgOiBlbmNvZGVVUklDb21wb25lbnQocGFyYW0pfVxuICAgIHZhciBxc3RyaW5nID0gT2JqZWN0LmtleXMocGFyYW1zKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBrZXkpIHtyZXR1cm4gYWNjICsgZW5jKGtleSkgKyc9JysgZW5jKHBhcmFtc1trZXldKSArJyYnfSwgJz8nKVxuXG4gICAgcmV0dXJuIEVCLk5ldC54aHIodXJsICsgcXN0cmluZywgb3B0aW9ucykgXG59XG5cblxuLyoqXG4gKiBzZW5kIGEgcG9zdCByZXF1ZXN0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVybCAgcmVxdWVzdGVkIHVybFxuICogQHBhcmFtICB7b2JqZWN0fSBkYXRhIFxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5FQi5OZXQucG9zdCA9IGZ1bmN0aW9uKHVybCwgZGF0YSkge1xuICAgIHZhciBvcHRpb25zID0geyBoZWFkZXJzOiB7ICAgXG4vLyAgICAgICAgICdDb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgLCAnQ29udGVudC1sZW5ndGgnOiBwYXJhbXMubGVuZ3RoXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICwgICAgICdDb25uZWN0aW9uJzogJ2Nsb3NlJyAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICwgIG1ldGhvZDogJ1BPU1QnXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICByZXR1cm4gRUIuTmV0Lnhocih1cmwsIG9wdGlvbnMsIGRhdGEpXG59XG5cblxuXG4vKipcbiAqIEEgY3VzdG9taXplZCB3cmFwcGVyIGZvciB0aGUgRXZlcnlCaXQgc2VydmVyIG92ZXIgdGhlIGJhc2UgWEhSIHByb21pc2Ugd3JhcHBlclxuICogQHBhcmFtICB7c3RyaW5nfSB1cmwgICAgXG4gKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtcyBcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuRUIuTmV0LkVCeGhyID0gZnVuY3Rpb24odXJsLCBvcHRpb25zLCBkYXRhKSB7XG4gICAgdmFyIHByb20gPSBFQi5OZXQueGhyKHVybCwgb3B0aW9ucywgZGF0YSlcbiAgICAgICAgXG4gICAgcmV0dXJuIHByb20udGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBpZihyZXNwb25zZS5GQUlMKVxuICAgICAgICAgICAgcmV0dXJuIEVCLnRocm93REhURXJyb3IocmVzcG9uc2UuRkFJTClcblxuICAgICAgICBpZih0eXBlb2YgcmVzcG9uc2UgPT0gJ3N0cmluZycgJiYgcmVzcG9uc2Uuc2xpY2UoMCw2KSA9PSAne1wiRkFJTCcpXG4gICAgICAgICAgICByZXR1cm4gRUIudGhyb3dESFRFcnJvcigoRUIucGFyc2VKU09OKHJlc3BvbnNlKXx8e30pLkZBSUwpXG5cbiAgICAgICAgRUIucnVuSGFuZGxlcnMoJ25ldHdvcmtyZXNwb25zZScsIHJlc3BvbnNlKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgfSlcbn1cblxuRUIuTmV0LkVCcG9zdCA9IGZ1bmN0aW9uKHVybCwgZGF0YSkge1xuICAgIC8vLy8gVGhpcyBpcyB0aGUgRXZlcnlCaXQgc2VydmVyIHZlcnNpb24gb2YgRUIuTmV0LmdldEpTT04gLS0gdXNlIHRoYXQgZnVuY3Rpb24gaWYgeW91J3JlIG5vdCBhY2Nlc3NpbmcgdGhlIEV2ZXJ5Qml0IHNlcnZlclxuICAgIC8vIFRISU5LOiBzaG91bGQgd2UgcGFyYW1ldHJpemUgb3ZlciB0aGUgZGlzcGF0Y2ggZnVuY3Rpb24/XG4gICAgdmFyIG9wdGlvbnMgPSB7IGhlYWRlcnM6IHt9XG4gICAgICAgICAgICAgICAgICAsICBtZXRob2Q6ICdQT1NUJ1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXG4gICAgcmV0dXJuIEVCLk5ldC5FQnhocih1cmwsIG9wdGlvbnMsIGRhdGEpXG59XG5cbkVCLk5ldC5FQmdldEpTT04gPSBmdW5jdGlvbih1cmwsIHBhcmFtcykge1xuICAgIC8vLy8gVGhpcyBpcyB0aGUgRXZlcnlCaXQgc2VydmVyIHZlcnNpb24gb2YgRUIuTmV0LmdldEpTT04gLS0gdXNlIHRoYXQgZnVuY3Rpb24gaWYgeW91J3JlIG5vdCBhY2Nlc3NpbmcgdGhlIEV2ZXJ5Qml0IHNlcnZlclxuICAgIC8vIFRISU5LOiBzaG91bGQgd2UgcGFyYW1ldHJpemUgb3ZlciB0aGUgZGlzcGF0Y2ggZnVuY3Rpb24/XG4gICAgdmFyIG9wdGlvbnMgPSB7IGhlYWRlcnM6IHsgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICAgICAgICAgICAgICAsICBtZXRob2Q6ICdHRVQnXG4gICAgICAgICAgICAgICAgICAsICAgIHR5cGU6ICdqc29uJ1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9IHBhcmFtcyB8fCB7fVxuICAgIHZhciBlbmMgPSBmdW5jdGlvbihwYXJhbSkge3JldHVybiAhcGFyYW0gJiYgcGFyYW0hPT0wID8gJycgOiBlbmNvZGVVUklDb21wb25lbnQocGFyYW0pfVxuICAgIHZhciBxc3RyaW5nID0gT2JqZWN0LmtleXMocGFyYW1zKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBrZXkpIHtyZXR1cm4gYWNjICsgZW5jKGtleSkgKyc9JysgZW5jKHBhcmFtc1trZXldKSArJyYnfSwgJz8nKVxuXG4gICAgcmV0dXJuIEVCLk5ldC5FQnhocih1cmwgKyBxc3RyaW5nLCBvcHRpb25zKSBcbn1cblxuXG5cblxuXG5cblxuXG4vKlxuXG4gICAgRUIuTmV0IFBlZXItdG8tUGVlciBsYXllclxuXG4gICAgV2UncmUgY3VycmVudGx5IHVzaW5nIHBlZXIuanMgdG8gbmVnb3RpYXRlIHRoZSBXZWJSVEMgY29ubmVjdGlvbi4gVGhlcmUncyBhIGxvdCBvZiB3b3JrIGxlZnQgdG8gYmUgZG9uZSBoZXJlLlxuXG4qL1xuXG5cbkVCLk5ldC5QMlAgPSB7fVxuRUIuTmV0LlAyUC5wZWVycyA9IHt9XG5cbi8qKlxuICogaW5pdGlhbGl6ZSB0aGUgcGVlci10by1wZWVyIGxheWVyXG4gKi9cbkVCLk5ldC5QMlAuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIE5PVEU6IHlvdSBoYXZlIHRvIG1hbnVhbGx5IGVuYWJsZSB0aGUgUDJQIGxheWVyIHZpYSBjb25maWcgb3IgaW5pdCBvcHRpb25zXG4gICAgLy8gZS5nLiBFQi5pbml0KHtlbmFibGVQMlA6IHRydWV9KVxuICAgIC8vIG9yICAgRUIuQ09ORklHLmVuYWJsZVAyUCA9IHRydWVcbiAgICBpZighRUIuQ09ORklHLmVuYWJsZVAyUCkgcmV0dXJuIGZhbHNlXG4gICAgXG4gICAgRUIuTmV0LlAyUC5QZWVyID0gbmV3IFBlZXIoeyBob3N0OiAgJzE2Mi4yMTkuMTYyLjU2J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgcG9ydDogIDkwMDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHBhdGg6ICAnLydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIGRlYnVnOiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICBcbiAgICBFQi5OZXQuUDJQLlBlZXIub24oJ29wZW4nLCBFQi5OZXQuUDJQLm9wZW5QZWVyQ29ubmVjdGlvbilcbiAgICBFQi5OZXQuUDJQLlBlZXIub24oJ2Nvbm5lY3Rpb24nLCBFQi5OZXQuUDJQLmNvbm5lY3Rpb24pXG59XG5cbi8qKlxuICogdG8gcmVsb2FkIHBlZXJzXG4gKiBAcmV0dXJuIHtvYmplY3R9IFxuICovXG5FQi5OZXQuUDJQLnJlbG9hZFBlZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEVCLk5ldC5QMlAuUGVlci5saXN0QWxsUGVlcnMoRUIuTmV0LlAyUC5oYW5kbGVQZWVycylcbn1cblxuLyoqXG4gKiBvcGVuIHBlZXIgY29ubmVjdGlvblxuICogQHBhcmFtICB7c3RyaW5nfSBpZCBcbiAqIEByZXR1cm4ge29iamVjdFtdfVxuICovXG5FQi5OZXQuUDJQLm9wZW5QZWVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgLy8gT1BUOiBkbyB3ZSByZWFsbHkgbmVlZCB0aGlzPyBcbiAgICAvLyBUSElOSzogd2h5IG5vdCBqdXN0IGNhbGwgRUIuTmV0LlAyUC5yZWxvYWRQZWVycz9cbiAgICByZXR1cm4gRUIuTmV0LlAyUC5QZWVyLmxpc3RBbGxQZWVycyhFQi5OZXQuUDJQLmhhbmRsZVBlZXJzKVxufVxuXG4vKipcbiAqIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBjb25uZWN0aW9uXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuRUIuTmV0LlAyUC5jb25uZWN0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgIEVCLk5ldC5QMlAucmVsb2FkUGVlcnMoKSAvLyBPUFQ6IGRvIHdlIHJlYWxseSBuZWVkIHRoaXM/IFxuXG4gICAgcmV0dXJuIGNvbm5lY3Rpb24ub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIEVCLkRhdGEuYWRkU2hlbGxzVGhlbk1ha2VBdmFpbGFibGUoZGF0YSkgLy8gVE9ETzogcGFzcyBhIGNhbGxiYWNrIGluIHRvIEVCLk5ldCBpbnN0ZWFkIG9mIGNhbGxpbmcgdGhpcyBkaXJlY3RseVxuICAgIH0pXG59XG5cbi8qKlxuICogdG8gaGFuZGxlIHBlZXJzXG4gKiBAcGFyYW0gIHtvYmplY3R9IHBlZXJzIFxuICogQHJldHVybiB7Ym9vbGVhbn0gICBcbiAqL1xuRUIuTmV0LlAyUC5oYW5kbGVQZWVycyA9IGZ1bmN0aW9uKHBlZXJzKSB7XG4gICAgcGVlcnMuZm9yRWFjaChmdW5jdGlvbihwZWVyKSB7XG4gICAgICAgIGlmKEVCLk5ldC5QMlAucGVlcnNbcGVlcl0pIFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIEVCLk5ldC5QMlAucGVlcnNbcGVlcl0gPSBFQi5OZXQuUDJQLlBlZXIuY29ubmVjdChwZWVyKVxuICAgIH0pXG59XG5cbi8qKlxuICogdG8gc2VuZCBwdWZmIHRvIHBlZXJzXG4gKiBAcGFyYW0gIHtvYmplY3R9IHB1ZmZcbiAqL1xuRUIuTmV0LlAyUC5zZW5kUHVmZlRvUGVlcnMgPSBmdW5jdGlvbihwdWZmKSB7XG4gICAgZm9yKHZhciBwZWVyIGluIEVCLk5ldC5QMlAucGVlcnMpIHtcbiAgICAgICAgRUIuTmV0LlAyUC5wZWVyc1twZWVyXS5zZW5kKHB1ZmYpXG4gICAgfVxufVxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8vIEVCLk5ldC5nZXRBbmNlc3RvcnMgPSBmdW5jdGlvbihzdGFydCwgbGltaXQpIHtcbi8vICAgICBnZXRFbShzdGFydCwgW10sIGxpbWl0KVxuLy8gICAgIHJldHVybiBFQi5lbXB0eVByb21pc2UoKVxuLy9cbi8vICAgICBmdW5jdGlvbiBnZXRFbSh0b2RvLCBkb25lLCByZW1haW5pbmcpIHtcbi8vICAgICAgICAgaWYoIXRvZG8ubGVuZ3RoKSByZXR1cm4gZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBkb25lXG4vLyAgICAgICAgIGlmKCFyZW1haW5pbmcpIHJldHVybiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgZG9uZVxuLy9cbi8vICAgICAgICAgdmFyIHNpZyA9IHRvZG9bMF1cbi8vXG4vLyAgICAgICAgIGlmKH5kb25lLmluZGV4T2Yoc2lnKSkge1xuLy8gICAgICAgICAgICAgcmV0dXJuIGdldEVtKHRvZG8uc2xpY2UoMSksIGRvbmUsIHJlbWFpbmluZykgICAgLy8gd2UndmUgYWxyZWFkeSBkb25lIHRoaXMgb25lXG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIC8vIFRPRE86IHNldCBhIGNhbGxiYWNrIGluIEVCLk5ldCBpbnN0ZWFkIG9mIGNhbGxpbmcgRUIuRGF0YSBkaXJlY3RseVxuLy8gICAgICAgICB2YXIgcHVmZiA9IEVCLkRhdGEuZ2V0UHVmZkJ5U2lnKHNpZykgICAgICAgICAgICAgICAgLy8gZWZmZWN0ZnVsXG4vL1xuLy8gICAgICAgICBpZihwdWZmKVxuLy8gICAgICAgICAgICAgcmV0dXJuIGdldEVtKHRvZG8uc2xpY2UoMSkuY29uY2F0KHB1ZmYucGF5bG9hZC5wYXJlbnRzKSwgZG9uZS5jb25jYXQoc2lnKSwgcmVtYWluaW5nKVxuLy9cbi8vICAgICAgICAgLy8gbm8gcHVmZj8gdGhhdCdzIG9rLiBhdHRhY2ggYSB0aGVuIGNsYXVzZSB0byBpdHMgcGVuZGluZyBwcm9taXNlLlxuLy8gICAgICAgICAvLyBUT0RPOiBmaW5kIGJldHRlciBtZXRob2QgdG8gZG8gdGhpc1xuLy8gICAgICAgICByZW1haW5pbmctLSAvLyBiZWNhdXNlIHdlJ3JlIGFkZGluZyBhIG5ldyBwdWZmLCBvciBhdCBsZWFzdCBuZXcgY29udGVudFxuLy8gICAgICAgICB2YXIgcHJvbSA9IEVCLkRhdGEucGVuZGluZ1B1ZmZQcm9taXNlc1tzaWddXG4vLyAgICAgICAgIHByb20udGhlbihmdW5jdGlvbihwdWZmcykge1xuLy8gICAgICAgICAgICAgZ2V0RW0odG9kby5zbGljZSgxKS5jb25jYXQoKChwdWZmc1swXXx8e30pLnBheWxvYWR8fHt9KS5wYXJlbnRzKSwgZG9uZS5jb25jYXQoc2lnKSwgcmVtYWluaW5nKVxuLy8gICAgICAgICB9KVxuLy8gICAgIH1cbi8vXG4vLyAgICAgLy9cbi8vICAgICAvLyBpZighdG9kby5sZW5ndGgpXG4vLyAgICAgLy8gICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0cykgICAgICAgICAgICAgLy8gYWxsIGRvbmVcbi8vICAgICAvLyBpZihyZXN1bHRzLmxlbmd0aCA+PSBsaW1pdClcbi8vICAgICAvLyAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRzKSAgICAgICAgICAgICAvLyBhbGwgZG9uZVxuLy8gICAgIC8vXG4vLyAgICAgLy8gdmFyIHNpZyA9IHRvZG9bMF1cbi8vICAgICAvLyB2YXIgc2hlbGwgPSBFQi5EYXRhLmdldENhY2hlZFNoZWxsQnlTaWcoc2lnKSAgIC8vIFRPRE86IHNldCBhIGNhbGxiYWNrIGluIEVCLk5ldCBpbnN0ZWFkIG9mIGNhbGxpbmcgdGhpcyBkaXJlY3RseVxuLy8gICAgIC8vICAgICAgICAgIHx8IHJlc3VsdHMuZmlsdGVyKGZ1bmN0aW9uKHJlc3VsdCkge3JldHVybiByZXN1bHQuc2lnID09IHNpZ30pWzBdXG4vLyAgICAgLy9cbi8vICAgICAvLyAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBwdWZmIGZvciBzaWcsIHRoZW4gd2UganVzdCBuZWVkIHRvIHB1dCBpdHMgcGFyZW50cyBvbiB0aGUgdG9kbyBzdGFja1xuLy8gICAgIC8vIGlmKHNoZWxsKSB7XG4vLyAgICAgLy8gICAgIHRvZG8uc2hpZnQoKSAvLyB0YWtlIG9mZiB0aGUgc2hlbGwgd2UganVzdCB3b3JrZWQgb25cbi8vICAgICAvLyAgICAgcmV0dXJuIEVCLk5ldC5nZXRBbmNlc3RvcnModG9kby5jb25jYXQoc2hlbGwucGF5bG9hZC5wYXJlbnRzKSwgbGltaXQsIHJlc3VsdHMpXG4vLyAgICAgLy8gfVxuLy8gICAgIC8vXG4vLyAgICAgLy8gLy8gb3RoZXJ3aXNlLCBnZXQgYSBwcm9taXNlIGZvciB0aGUgc2hlbGwsIHRoZW4gYWRkIGl0IHRvIHJlc3VsdHNcbi8vICAgICAvLyB2YXIgcHJvbSA9IEVCLk5ldC5nZXRQdWZmQnlTaWcoc2lnKVxuLy8gICAgIC8vIHJldHVybiBwcm9tLnRoZW4oZnVuY3Rpb24ocHVmZnMpIHtcbi8vICAgICAvLyAgICAgcmV0dXJuIEVCLk5ldC5nZXRBbmNlc3RvcnModG9kbywgbGltaXQsIHJlc3VsdHMuY29uY2F0KHB1ZmZzKSlcbi8vICAgICAvLyB9KVxuLy8gfVxuXG4vLyBFQi5OZXQuZ2V0RGVzY2VuZGFudHMgPSBmdW5jdGlvbihzdGFydCwgbGltaXQpIHtcbi8vICAgICBnZXRFbShzdGFydCwgW10sIGxpbWl0KVxuLy8gICAgIHJldHVybiBFQi5lbXB0eVByb21pc2UoKVxuLy9cbi8vICAgICBmdW5jdGlvbiBnZXRFbSh0b2RvLCBkb25lLCByZW1haW5pbmcpIHtcbi8vICAgICAgICAgaWYoIXRvZG8ubGVuZ3RoKSByZXR1cm4gZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBkb25lXG4vLyAgICAgICAgIGlmKCFyZW1haW5pbmcpIHJldHVybiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgZG9uZVxuLy9cbi8vICAgICAgICAgdmFyIHNpZyA9IHRvZG9bMF1cbi8vXG4vLyAgICAgICAgIGlmKH5kb25lLmluZGV4T2Yoc2lnKSkge1xuLy8gICAgICAgICAgICAgcmV0dXJuIGdldEVtKHRvZG8uc2xpY2UoMSksIGRvbmUsIHJlbWFpbmluZykgICAgLy8gd2UndmUgYWxyZWFkeSBkb25lIHRoaXMgb25lXG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIC8vIFRPRE86IHNldCBhIGNhbGxiYWNrIGluIEVCLk5ldCBpbnN0ZWFkIG9mIGNhbGxpbmcgRUIuRGF0YSBkaXJlY3RseVxuLy8gICAgICAgICB2YXIgaGF2ZVNoZWxsID0gRUIuRGF0YS5nZXRDYWNoZWRTaGVsbEJ5U2lnKHNpZylcbi8vXG4vLyAgICAgICAgIGlmKCFoYXZlU2hlbGwpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIHRoZSBzaGVsbCB5ZXQsIHNvIGdvIGdldCBpdFxuLy8gICAgICAgICAgICAgLy8gVE9ETzogdXNlIGFib3ZlIGNhbGxiYWNrIHRvIEVCLkRhdGFcbi8vICAgICAgICAgICAgIEVCLkRhdGEuZ2V0UHVmZkJ5U2lnKHNpZykgICAgICAgICAgICAgICAgICAgICAgIC8vIGVmZmVjdGZ1bFxuLy8gICAgICAgICAgICAgcmVtYWluaW5nLS1cbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgdmFyIGtpZHNpZ3Byb20gPSBFQi5OZXQuZ2V0S2lkU2lncyhzaWcpICAgICAgICAgICAgIC8vIGdldCBhbGwgaXRzIGNoaWxkcmVuXG4vLyAgICAgICAgIHJldHVybiBraWRzaWdwcm9tLnRoZW4oZnVuY3Rpb24oa2lkc2lncykge1xuLy8gICAgICAgICAgICAgZ2V0RW0odG9kby5zbGljZSgxKS5jb25jYXQoa2lkc2lncyksIGRvbmUuY29uY2F0KHNpZyksIHJlbWFpbmluZylcbi8vICAgICAgICAgfSlcbi8vICAgICB9XG4vLyB9XG5cbi8vIEVCLk5ldC5nZXRTaWJsaW5ncyA9IGZ1bmN0aW9uKCkge1xuLy8gICAgIC8vIHRoaXMgY2FzZSBpcyB1Z2x5LCBzbyB3ZSdyZSBsZWF2aW5nIGl0IHVudGlsIHRoZSBjbGllbnQgYXBpIGNhbiBhbnN3ZXIgcXVlc3Rpb25zIGZvciB1c1xuLy8gICAgIHJldHVybiBFQi5lbXB0eVByb21pc2UoKVxuLy8gfVxuIiwiLypcblxuICAgIFBlcnNpc3RlbmNlIGxheWVyIGZvciB0aGUgRXZlcnlCaXQgcGxhdGZvcm0uXG5cbiAgICBJdCdzIGxpa2UgYSBuZXR3b3JrIG9uIHlvdXIgaGFyZCBkcml2ZS4uLiB3aGljaCBtZWFucyB0aGlzIGNvdWxkIGJlIHBhcnQgb2YgRUIuTmV0LlxuXG4gICAgQ29weXJpZ2h0IDIwMTQtMjAxNSBFdmVyeUJpdC4gU2VlIFJFQURNRSBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuICovXG5cbkVCLlBlcnNpc3QgPSB7fTtcbkVCLlBlcnNpc3QudG9kbyA9IHt9XG5FQi5QZXJzaXN0LnRvZG9mbGFnID0gZmFsc2VcblxuLyoqXG4gKiB0byBzYXZlIGtleS92YWx1ZVxuICogQHBhcmFtICB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWVcbiAqL1xuRUIuUGVyc2lzdC5zYXZlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGlmKHZhbHVlID09IG51bGwpXG4gICAgICAgIHZhbHVlID0gZmFsc2VcbiAgICBFQi5QZXJzaXN0LnRvZG9ba2V5XSA9IHZhbHVlXG4gICAgaWYoIUVCLlBlcnNpc3QudG9kb2ZsYWcpIHtcbiAgICAgICAgb25jZUluQXdoaWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gRUIuUGVyc2lzdC50b2RvKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWxrZXkgPSAnUFVGRjo6JyArIGtleTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmVwZW5kIFBVRkY6OiBzbyB3ZSdyZSBnb29kIG5laWdoYm9yc1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IEVCLlBlcnNpc3QudG9kb1trZXldO1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSdyZSBwYXNzZWQgYSB0aHVua1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0ocmVhbGtleSwgc3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEVCLlBlcnNpc3QudG9kbyA9IHt9O1xuICAgICAgICAgICAgRUIuUGVyc2lzdC50b2RvZmxhZyA9IGZhbHNlO1xuICAgICAgICB9LCAxMDApOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBhdCBtb3N0IGV2ZXJ5IDEwMG1zXG4gICAgfVxuICAgIEVCLlBlcnNpc3QudG9kb2ZsYWcgPSB0cnVlXG59XG5cbi8qKlxuICogZ2V0IHRoZSBwYXJzZWQgSlNPTiBpbmZvIGZyb20gdGhlIGdpdmVuIGtleVxuICogQHBhcmFtICB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge2FueXRoaW5nfVxuICovXG5FQi5QZXJzaXN0LmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIC8vIFRPRE86IHJldHVybiBlbXB0eSBzdHJpbmcgaW5zdGVhZCBvZiBmYWxzZVxuXG4gICAgdmFyIHJlYWxrZXkgPSAnUFVGRjo6JyArIGtleTtcbiAgICB2YXIgc3RyID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0ocmVhbGtleSk7XG4gICAgaWYoIXN0cikgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBFQi5wYXJzZUpTT04oc3RyKTtcbn1cblxuLyoqXG4gKiB0byByZW1vdmUgdGhlIGl0ZW0gYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBrZXlcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKi9cbkVCLlBlcnNpc3QucmVtb3ZlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIHJlYWxrZXkgPSAnUFVGRjo6JyArIGtleTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShyZWFsa2V5KTtcbn1cbiIsIi8qXG5cbiAgICBQdWZmcyBhcmUgdGhlIGxpZmVibG9vZCBvZiBFdmVyeUJpdC4gVGhpcyBmaWxlIGNvbnRhaW5zIHJlbGF0aXZlbHkgcHVyZSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCB0aGVtLlxuXG4gICAgQ29weXJpZ2h0IDIwMTUgRXZlcnlCaXQuIFNlZSBSRUFETUUgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbiovXG5cbkVCLlB1ZmYgPSB7fVxuXG5cbi8vLy8gQnVpbGRpbmcgcHVmZnNcblxuRUIuUHVmZi5jcmVhdGVQcml2YXRlID0gZnVuY3Rpb24oY29udGVudCwgdHlwZSkge1xuICAgIHZhciBwYXlsb2FkID0ge31cbiAgICBcbiAgICB2YXIgdHlwZSAgID0gdHlwZSB8fCAnZmlsZSdcbiAgICB2YXIgcm91dGVzID0gWydsb2NhbCddXG5cbiAgICB2YXIgdXNlclJlY29yZCA9IEVCLmdldEN1cnJlbnRVc2VyUmVjb3JkKClcbiAgICB2YXIgdXNlclJlY29yZHNGb3JXaG9tVG9FbmNyeXB0ID0gW3VzZXJSZWNvcmRdXG4gICAgdmFyIHByZXZpb3VzLCBwdWZmXG4gICAgXG4gICAgcHVmZiA9IEVCLlB1ZmYuc2ltcGxlQnVpbGQodHlwZSwgY29udGVudCwgcGF5bG9hZCwgcm91dGVzLCB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHQpXG4gICAgXG4gICAgcmV0dXJuIHB1ZmZcbn1cblxuXG5FQi5QdWZmLnNpbXBsZUJ1aWxkID0gZnVuY3Rpb24odHlwZSwgY29udGVudCwgcGF5bG9hZCwgcm91dGVzLCB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHQsIHByaXZhdGVFbnZlbG9wZUFsaWFzKSB7XG4gICAgLy8vLyBidWlsZCBhIHB1ZmYgZm9yIHRoZSAnY3VycmVudCB1c2VyJywgYXMgZGV0ZXJtaW5lZCBieSB0aGUga2V5IG1hbmFnZXIgKGJ5IGRlZmF1bHQgRUIuTS5XYXJkcm9iZSlcbiAgICB2YXIgcHVmZiBcblxuICAgIHBheWxvYWQgPSBFQi5ydW5IYW5kbGVycygncGF5bG9hZE1vZGlmaWVyJywgcGF5bG9hZClcblxuICAgIEVCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oaWRlbnRpdGllcywgY3VycmVudFVzZXJuYW1lLCBwcml2YXRlUm9vdEtleSwgcHJpdmF0ZUFkbWluS2V5LCBwcml2YXRlRGVmYXVsdEtleSkge1xuICAgICAgICAvLyBUSElOSzogc2hvdWxkIHdlIGNvbmZpcm0gdGhhdCBvdXIgbG9jYWwgY2FwYSBtYXRjaGVzIHRoZSBESFQncyBsYXRlc3QgY2FwYSBmb3IgdGhlIGN1cnJlbnQgdXNlciBoZXJlPyBpdCB0dXJucyB0aGUgb3V0cHV0IGludG8gYSBwcm9taXNlLi4uXG4gICAgICAgIHZhciBwcmV2aW91cyA9IGZhbHNlIC8vIFRPRE86IGdldCB0aGUgc2lnIG9mIHRoaXMgdXNlcidzIGxhdGVzdCBwdWZmXG4gICAgICAgIHZhciB2ZXJzaW9uZWRVc2VybmFtZSA9IEVCLmdldEN1cnJlbnRWZXJzaW9uZWRVc2VybmFtZSgpXG4gICAgICAgIFxuICAgICAgICBwdWZmID0gRUIuUHVmZi5idWlsZCh2ZXJzaW9uZWRVc2VybmFtZSwgcHJpdmF0ZURlZmF1bHRLZXksIHJvdXRlcywgdHlwZSwgY29udGVudCwgcGF5bG9hZCwgcHJldmlvdXMsIHVzZXJSZWNvcmRzRm9yV2hvbVRvRW5jcnlwdCwgcHJpdmF0ZUVudmVsb3BlQWxpYXMpXG4gICAgfSlcbiAgICBcbiAgICByZXR1cm4gcHVmZlxufVxuXG5cbi8qKlxuICogYnVpbGQgYSBuZXcgcHVmZiBvYmplY3QgYmFzZWQgb24gdGhlIHBhcmFtZXRlcnMgIFxuICogZG9lcyBub3QgaGl0IHRoZSBuZXR3b3JrLCBoZW5jZSBkb2VzIG5vIHJlYWwgdmVyaWZpY2F0aW9uIHdoYXRzb2V2ZXJcbiAqIEBwYXJhbSAge3N0cmluZ30gdXNlcm5hbWUgICAgICAgICAgICAgICAgICAgIHVzZXIgd2hvIHNpZ24gdGhlIHB1ZmZcbiAqIEBwYXJhbSAge3N0cmluZ30gcHJpdmF0ZUtleSAgICAgICAgICAgICAgICAgIHByaXZhdGUgZGVmYXVsdCBrZXkgZm9yIHRoZSB1c2VyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHJvdXRlcyAgICAgICAgICAgICAgICAgICAgICByb3V0ZXMgb2YgdGhlIHB1ZmZcbiAqIEBwYXJhbSAge3N0cmluZ30gdHlwZSAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgb2YgdGhlIHB1ZmZcbiAqIEBwYXJhbSAge3N0cmluZ30gY29udGVudCAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgb2YgdGhlIHB1ZmZcbiAqIEBwYXJhbSAge29iamVjdH0gcGF5bG9hZCAgICAgICAgICAgICAgICAgICAgIG90aGVyIHBheWxvYWQgaW5mb3JtYXRpb24gZm9yIHRoZSBwdWZmXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHByZXZpb3VzICAgICAgICAgICAgICAgICAgICBtb3N0IHJlY2VudGx5IHB1Ymxpc2hlZCBjb250ZW50IGJ5IHRoZSB1c2VyXG4gKiBAcGFyYW0gIHtvYmplY3R9IHVzZXJSZWNvcmRzRm9yV2hvbVRvRW5jcnlwdFxuICogQHBhcmFtICB7b2JqZWN0fSBwcml2YXRlRW52ZWxvcGVBbGlhc1xuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5ldyBwdWZmIG9iamVjdFxuICovXG5FQi5QdWZmLmJ1aWxkID0gZnVuY3Rpb24odmVyc2lvbmVkVXNlcm5hbWUsIHByaXZhdGVLZXksIHJvdXRlcywgdHlwZSwgY29udGVudCwgcGF5bG9hZCwgcHJldmlvdXMsIHVzZXJSZWNvcmRzRm9yV2hvbVRvRW5jcnlwdCwgcHJpdmF0ZUVudmVsb3BlQWxpYXMpIHtcbiAgICB2YXIgcHVmZiA9IEVCLlB1ZmYucGFja2FnZVN0cnVjdHVyZSh2ZXJzaW9uZWRVc2VybmFtZSwgcm91dGVzLCB0eXBlLCBjb250ZW50LCBwYXlsb2FkLCBwcmV2aW91cylcblxuICAgIHB1ZmYuc2lnID0gRUIuQ3J5cHRvLnNpZ25QdWZmKHB1ZmYsIHByaXZhdGVLZXkpXG4gICAgXG4gICAgaWYodXNlclJlY29yZHNGb3JXaG9tVG9FbmNyeXB0KSB7XG4gICAgICAgIHB1ZmYgPSBFQi5QdWZmLmVuY3J5cHQocHVmZiwgcHJpdmF0ZUtleSwgdXNlclJlY29yZHNGb3JXaG9tVG9FbmNyeXB0LCBwcml2YXRlRW52ZWxvcGVBbGlhcylcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHB1ZmZcbn1cblxuXG5FQi5QdWZmLnBhY2thZ2VTdHJ1Y3R1cmUgPSBmdW5jdGlvbih2ZXJzaW9uZWRVc2VybmFtZSwgcm91dGVzLCB0eXBlLCBjb250ZW50LCBwYXlsb2FkLCBwcmV2aW91cykge1xuICAgIC8vLy8gcGFjayBhbGwgdGhlIHBhcmFtZXRlcnMgaW50byBhbiBvYmplY3Qgd2l0aCBwdWZmIHN0cnVjdHVyZSAod2l0aG91dCBzaWduYXR1cmUpXG4gICAgXG4gICAgcGF5bG9hZCA9IHBheWxvYWQgfHwge30gICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBjaGVjayBhbGwgb2YgdGhlc2UgdmFsdWVzIG1vcmUgY2FyZWZ1bGx5XG4gICAgcGF5bG9hZC5jb250ZW50ID0gY29udGVudFxuICAgIHBheWxvYWQudHlwZSA9IHR5cGVcblxuICAgIHJvdXRlcyA9IHJvdXRlcyB8fCBbXVxuICAgIHByZXZpb3VzID0gcHJldmlvdXMgfHwgZmFsc2UgICAgICAgICAgICAgICAgLy8gZmFsc2UgZm9yIERIVCByZXF1ZXN0cyBhbmQgYmVnaW5uaW5nIG9mIGJsb2NrY2hhaW4sIGVsc2UgdmFsaWQgc2lnXG5cbiAgICB2YXIgcHVmZiA9IHsgdXNlcm5hbWU6IHZlcnNpb25lZFVzZXJuYW1lXG4gICAgICAgICAgICAgICAsICAgcm91dGVzOiByb3V0ZXNcbiAgICAgICAgICAgICAgICwgcHJldmlvdXM6IHByZXZpb3VzXG4gICAgICAgICAgICAgICAsICB2ZXJzaW9uOiAnMC40LjAnICAgICAgICAgICAgICAvLyB2ZXJzaW9uIGFjY291bnRzIGZvciBjcnlwdG8gdHlwZSBhbmQgcHVmZiBzaGFwZVxuICAgICAgICAgICAgICAgLCAgcGF5bG9hZDogcGF5bG9hZCAgICAgICAgICAgICAgLy8gZWFybHkgdmVyc2lvbnMgd2lsbCBiZSBhZ2dyZXNzaXZlbHkgZGVwcmVjYXRlZCBhbmQgdW5zdXBwb3J0ZWRcbiAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICByZXR1cm4gcHVmZlxufVxuXG5cbi8qKlxuICogQnVpbGQgdXNlciByZWdpc3RyYXRpb24gcHVmZlxuICogQHBhcmFtICB7c3RyaW5nfSAgdXNlcm5hbWUgb2YgZXhpc3RpbmcgdXNlclxuICogQHBhcmFtICB7c3RyaW5nfSAgcHJpdmF0ZSBhZG1pbiBrZXkgZm9yIGV4aXN0aW5nIHVzZXJcbiAqIEBwYXJhbSAge3N0cmluZ30gIGRlc2lyZWQgbmV3IHVzZXIgbmFtZVxuICogQHBhcmFtICB7c3RyaW5nfSAgcHVibGljIHJvb3Qga2V5IGZvciB0aGUgbmV3IHVzZXJcbiAqIEBwYXJhbSAge3N0cmluZ30gIHB1YmxpYyBhZG1pbiBrZXkgZm9yIHRoZSBuZXcgdXNlclxuICogQHBhcmFtICB7c3RyaW5nfSAgcHVibGljIGRlZmF1bHQga2V5IGZvciB0aGUgbmV3IHVzZXJcbiAqIEByZXR1cm4ge29iamVjdH0gIHB1ZmYgdG8gcmVnaXN0ZXIgdGhlIHVzZXJcbiAqL1xuRUIuUHVmZi5idWlsZFVzZXJSZWdpc3RyYXRpb24gPSBmdW5jdGlvbihzaWduaW5nVXNlcm5hbWUsIHByaXZhdGVBZG1pbktleSwgbmV3VXNlcm5hbWUsIHJvb3RLZXksIGFkbWluS2V5LCBkZWZhdWx0S2V5KSB7XG5cbiAgICAvLyB0aGUgREhUIHVwZGF0ZSBwdWZmIHBheWxvYWRcbiAgICB2YXIgcGF5bG9hZCA9IHsgcmVxdWVzdGVkVXNlcm5hbWU6IG5ld1VzZXJuYW1lXG4gICAgICAgICAgICAgICAgICAsICAgICAgICBkZWZhdWx0S2V5OiBkZWZhdWx0S2V5XG4gICAgICAgICAgICAgICAgICAsICAgICAgICAgIGFkbWluS2V5OiBhZG1pbktleVxuICAgICAgICAgICAgICAgICAgLCAgICAgICAgICAgcm9vdEtleTogcm9vdEtleVxuICAgICAgICAgICAgICAgICAgLCAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgLy8gYnVpbGQgdGhlIERIVCB1cGRhdGUgcHVmZlxuICAgIHZhciByb3V0aW5nID0gW10gLy8gVEhJTks6IERIVD9cbiAgICB2YXIgY29udGVudCA9ICdyZXF1ZXN0VXNlcm5hbWUnXG4gICAgdmFyIHR5cGUgICAgPSAndXBkYXRlVXNlclJlY29yZCdcblxuICAgIC8vIE5PVEU6IHdlJ3JlIHNraXBwaW5nIHByZXZpb3VzLCBiZWNhdXNlIHJlcXVlc3RVc2VybmFtZS1zdHlsZSBwdWZmcyBkb24ndCB1c2UgaXQuXG4gICAgdmFyIHB1ZmYgPSBFQi5QdWZmLmJ1aWxkKHNpZ25pbmdVc2VybmFtZSwgcHJpdmF0ZUFkbWluS2V5LCByb3V0aW5nLCB0eXBlLCBjb250ZW50LCBwYXlsb2FkKVxuXG4gICAgcmV0dXJuIHB1ZmZcbn1cblxuXG5cblxuXG4vLy8vIEVuY3J5cHRpb24gYW5kIGRlY3J5cHRpb25cblxuXG5FQi5QdWZmLmlzUHJpdmF0ZSA9IGZ1bmN0aW9uKHNoZWxsKSB7XG4gICAgcmV0dXJuIHNoZWxsLnBheWxvYWQudHlwZSA9PSAnZW5jcnlwdGVkcHVmZidcbn1cblxuXG5FQi5QdWZmLmVuY3J5cHQgPSBmdW5jdGlvbihsZXR0ZXIsIG15UHJpdmF0ZVdpZiwgdXNlclJlY29yZHMsIHByaXZhdGVFbnZlbG9wZUFsaWFzKSB7XG4gICAgLy8vLyBzdGljayBhIGxldHRlciBpbiBhbiBlbnZlbG9wZS4gdXNlclJlY29yZHMgbXVzdCBiZSBmdWxseSBpbnN0YW50aWF0ZWQuXG4gICAgdmFyIHB1ZmZrZXkgPSBFQi5DcnlwdG8uZ2V0UmFuZG9tS2V5KCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGEgbmV3IHJhbmRvbSBrZXlcbiAgICBcbiAgICB2YXIgbGV0dGVyQ2lwaGVyID0gRUIuQ3J5cHRvLmVuY3J5cHRXaXRoQUVTKEpTT04uc3RyaW5naWZ5KGxldHRlciksIHB1ZmZrZXkpICAvLyBlbmNyeXB0IHRoZSBsZXR0ZXJcbiAgICB2YXIgdmVyc2lvbmVkVXNlcm5hbWUgPSBsZXR0ZXIudXNlcm5hbWVcbiAgICBcbiAgICBpZihwcml2YXRlRW52ZWxvcGVBbGlhcykge1xuICAgICAgICBteVByaXZhdGVXaWYgPSBwcml2YXRlRW52ZWxvcGVBbGlhcy5wcml2YXRlRGVmYXVsdEtleVxuICAgICAgICB2ZXJzaW9uZWRVc2VybmFtZSA9IEVCLlVzZXJzLm1ha2VWZXJzaW9uZWQocHJpdmF0ZUVudmVsb3BlQWxpYXMudXNlcm5hbWUsIHByaXZhdGVFbnZlbG9wZUFsaWFzLmNhcGEpXG4gICAgfVxuICAgIFxuICAgIHZhciBlbnZlbG9wZSA9IEVCLlB1ZmYucGFja2FnZVN0cnVjdHVyZSh2ZXJzaW9uZWRVc2VybmFtZSwgbGV0dGVyLnJvdXRlcyAgICAgIC8vIGVudmVsb3BlIGlzIGFsc28gYSBwdWZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAsICdlbmNyeXB0ZWRwdWZmJywgbGV0dGVyQ2lwaGVyLCB7fSwgbGV0dGVyLnByZXZpb3VzKSAgLy8gaXQgaW5jbHVkZXMgdGhlIGxldHRlclxuICAgIFxuICAgIGVudmVsb3BlLmtleXMgPSBFQi5DcnlwdG8uY3JlYXRlS2V5UGFpcnMocHVmZmtleSwgbXlQcml2YXRlV2lmLCB1c2VyUmVjb3JkcykgIC8vIGFkZCBkZWNyeXB0aW9uIGtleXNcbiAgICBlbnZlbG9wZS5zaWcgPSBFQi5DcnlwdG8uc2lnblB1ZmYoZW52ZWxvcGUsIG15UHJpdmF0ZVdpZikgICAgICAgICAgICAgICAgICAgICAvLyBzaWduIHRoZSBlbnZlbG9wZVxuICAgIFxuICAgIHJldHVybiBlbnZlbG9wZVxufVxuXG5FQi5QdWZmLnByb21pc2VMZXR0ZXIgPSBmdW5jdGlvbihlbnZlbG9wZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZW52ZWxvcGUgaXMgYSBwdWZmXG4gICAgaWYoRUIuRGF0YS5pc0JhZEVudmVsb3BlKGVudmVsb3BlLnNpZykpIFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0JhZCBlbnZlbG9wZScpICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmxhZ2dlZCBhcyBpbnZhbGlkIGVudmVsb3BlXG5cbiAgICB2YXIgbWF5YmVMZXR0ZXIgPSBFQi5EYXRhLmdldERlY3J5cHRlZExldHRlckJ5U2lnKGVudmVsb3BlLnNpZykgICAgIC8vIGhhdmUgd2UgYWxyZWFkeSBvcGVuZWQgaXQ/XG4gICAgXG4gICAgaWYobWF5YmVMZXR0ZXIpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWF5YmVMZXR0ZXIpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlIHRvIGV4aXN0aW5nIGxldHRlclxuICAgIFxuICAgIHZhciBwcm9tID0gRUIuUHVmZi5wcm9taXNlRGVjcnlwdGVkTGV0dGVyKGVudmVsb3BlKSAgICAgICAgICAgICAgICAgLy8gZG8gdGhlIGRlY3J5cHRpb25cbiAgICBcbiAgICByZXR1cm4gcHJvbS5jYXRjaChmdW5jdGlvbihlcnIpIHsgcmV0dXJuIGZhbHNlIH0pXG4gICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihsZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICBpZighbGV0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIEVCLkRhdGEuYWRkQmFkRW52ZWxvcGUoZW52ZWxvcGUuc2lnKSAgICAgICAgICAgICAvLyBkZWNyeXB0aW9uIGZhaWxlZDogZmxhZyBlbnZlbG9wZVxuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRUIudGhyb3dFcnJvcignSW52YWxpZCBlbnZlbG9wZScpICAgICAgICAgLy8gdGhlbiBiYWlsIG91dFxuICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgIHJldHVybiBsZXR0ZXJcbiAgICAgICAgICAgICAgIH0pXG4gICAgXG59XG5cbkVCLlB1ZmYucHJvbWlzZURlY3J5cHRlZExldHRlciA9IGZ1bmN0aW9uKGVudmVsb3BlKSB7XG4gICAgLy8vLyBwdWxsIGEgbGV0dGVyIG91dCBvZiB0aGUgZW52ZWxvcGUgLS0gcmV0dXJucyBhIHByb21pc2UhXG5cbiAgICBpZighZW52ZWxvcGUgfHwgIWVudmVsb3BlLmtleXMpIFxuICAgICAgICByZXR1cm4gRUIuZW1wdHlQcm9taXNlKCdFbnZlbG9wZSBkb2VzIG5vdCBjb250YWluIGFuIGVuY3J5cHRlZCBsZXR0ZXInKVxuICAgIFxuICAgIHZhciBzZW5kZXJWZXJzaW9uZWRVc2VybmFtZSA9IGVudmVsb3BlLnVzZXJuYW1lXG4gICAgdmFyIHVzZXJQcm9tID0gRUIuVXNlcnMuZ2V0VXNlclJlY29yZFByb21pc2Uoc2VuZGVyVmVyc2lvbmVkVXNlcm5hbWUpXG4gICAgXG4gICAgdmFyIHB1ZmZwcm9tID0gdXNlclByb21cbiAgICAuY2F0Y2goRUIuY2F0Y2hFcnJvcignVXNlciByZWNvcmQgYWNxdWlzaXRpb24gZmFpbGVkJykpXG4gICAgLnRoZW4oZnVuY3Rpb24oc2VuZGVyVmVyc2lvbmVkVXNlclJlY29yZCkge1xuICAgICAgICB2YXIgcHJvbSAvLyB1c2VkIGZvciBsZWFraW5nIHNlY3VyZSBwcm9taXNlXG5cbiAgICAgICAgRUIudXNlU2VjdXJlSW5mbyhmdW5jdGlvbihpZGVudGl0aWVzLCBjdXJyZW50VXNlcm5hbWUpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IGxlYWtzIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB1bmVuY3J5cHRlZCBwdWZmXG4gICAgICAgIFxuICAgICAgICAgICAgdmFyIGlkZW50aXR5ID0gaWRlbnRpdGllc1tjdXJyZW50VXNlcm5hbWVdXG4gICAgICAgICAgICB2YXIgYWxpYXNlcyAgPSBpZGVudGl0eS5hbGlhc2VzXG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdVc2VybmFtZSA9ICcnXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB0b3A6IGZvcih2YXIga2V5a2V5IGluIGVudmVsb3BlLmtleXMpIHsgICAgICAgICAgICAgLy8gbWF0Y2ggb3VyIGFsaWFzZXMgYWdhaW5zdCBhbGwgcmVjaXBpZW50c1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxpYXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWxpYXMgPSBhbGlhc2VzW2ldXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZihhbGlhcy51c2VybmFtZSA9PSBrZXlrZXkpIHsgICAgICAgICAgICAgIC8vIG9ubHkgZm9yIG9sZCwgdW52ZXJzaW9uZWQgdXNlcm5hbWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZ1VzZXJuYW1lID0gYWxpYXMudXNlcm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgdmVyc2lvblVzZXJuYW1lID0gRUIuVXNlcnMubWFrZVZlcnNpb25lZChhbGlhcy51c2VybmFtZSwgYWxpYXMuY2FwYSlcbiAgICAgICAgICAgICAgICAgICAgaWYodmVyc2lvblVzZXJuYW1lID09IGtleWtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdVc2VybmFtZSA9IHZlcnNpb25Vc2VybmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFtYXRjaGluZ1VzZXJuYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBFQi50aHJvd0Vycm9yKCdObyBrZXkgZm91bmQgZm9yIGN1cnJlbnQgdXNlcicpXG5cbiAgICAgICAgICAgIHZhciByZWNpcGllbnRQcml2YXRlS2V5ID0gYWxpYXMucHJpdmF0ZURlZmF1bHRLZXlcbiAgICAgICAgICAgIHZhciBzZW5kZXJQdWJsaWNLZXkgPSBzZW5kZXJWZXJzaW9uZWRVc2VyUmVjb3JkLmRlZmF1bHRLZXlcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcHJvbSA9IEVCLlB1ZmYucHJvbWlzZVRvRGVjcnlwdEZvclJlYWxzKGVudmVsb3BlLCBzZW5kZXJQdWJsaWNLZXksIG1hdGNoaW5nVXNlcm5hbWUsIHJlY2lwaWVudFByaXZhdGVLZXkpXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIHByb21cbiAgICB9KVxuICAgIFxuICAgIHJldHVybiBwdWZmcHJvbVxufVxuXG5FQi5QdWZmLnByb21pc2VUb0RlY3J5cHRGb3JSZWFscyA9IGZ1bmN0aW9uKGVudmVsb3BlLCBzZW5kZXJQdWJsaWNLZXksIHJlY2lwaWVudFVzZXJuYW1lLCByZWNpcGllbnRQcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZXR1cm4gRUIuY3J5cHRvd29ya2VyXG4gICAgICAgICAgICAgPyBFQi53b3JrZXJzZW5kKCAnZGVjcnlwdFB1ZmZGb3JSZWFscydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIFsgZW52ZWxvcGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgc2VuZGVyUHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHJlY2lwaWVudFVzZXJuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHJlY2lwaWVudFByaXZhdGVLZXkgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgcmVzb2x2ZSwgcmVqZWN0IClcbiAgICAgICAgICAgICA6IHJlc29sdmUoIEVCLmRlY3J5cHRQdWZmRm9yUmVhbHMoIGVudmVsb3BlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBzZW5kZXJQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHJlY2lwaWVudFVzZXJuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCByZWNpcGllbnRQcml2YXRlS2V5ICkgKVxuICAgIH0pXG59XG5cblxuLy8vLyBTaGVsbHMgYW5kIHB1ZmZzXG5cblxuRUIuUHVmZi5pc0Z1bGwgPSBmdW5jdGlvbihzaGVsbCkge1xuICAgIC8vIEEgcHVmZiBoYXMgcGF5bG9hZC5jb250ZW50IC0tIGEgc2hlbGwgZG9lcyBub3RcbiAgICByZXR1cm4gKChzaGVsbHx8e30pLnBheWxvYWR8fHt9KS5jb250ZW50ICE9PSB1bmRlZmluZWRcbn1cblxuRUIuUHVmZi5pc0VtcHR5ID0gZnVuY3Rpb24oc2hlbGwpIHtcbiAgICByZXR1cm4gIUVCLlB1ZmYuaXNGdWxsKHNoZWxsKVxufVxuXG5FQi5QdWZmLmNvbXBhY3RQdWZmID0gZnVuY3Rpb24ocHVmZikge1xuICAgIC8vIFRISU5LOiBpbnN0ZWFkIG9mIHJlYnVpbGRpbmcgdGhlIHB1ZmYsIHVzZSBhIEpTT04uc3RyaW5naWZ5IHJlZHVjZXIgdGhhdCBzdHJpcHMgb3V0IHRoZSBjb250ZW50XG4gICAgdmFyIG5ld19zaGVsbCA9IEJvcm9uLmV4dGVuZChwdWZmKVxuICAgIHZhciBuZXdfcGF5bG9hZCA9IHt9XG4gICAgZm9yKHZhciBwcm9wIGluIHB1ZmYucGF5bG9hZClcbiAgICAgICAgaWYocHJvcCAhPSAnY29udGVudCcpXG4gICAgICAgICAgICBuZXdfcGF5bG9hZFtwcm9wXSA9IHB1ZmYucGF5bG9hZFtwcm9wXSBcblxuICAgIG5ld19zaGVsbC5wYXlsb2FkID0gbmV3X3BheWxvYWRcbiAgICByZXR1cm4gbmV3X3NoZWxsXG59XG5cbiIsIi8qXG5cbiAgICBDb21wcmVoZW5zaXZlIChpbiBwcm9ncmVzcyEpLCBjYW5vbmljYWwgc2V0IG9mIGZ1bmN0aW9ucyBkZWZpbmluZyBhbmQgdmFsaWRhdGluZyBhIHB1ZmYuXG5cbiAgICBBbGwgb2YgdGhlc2UgYXJlIFNUUklDVExZIEZPUk1BTCB2YWxpZGF0aW9uczogdGhleSBkb24ndCBkZXBlbmQgb24gdGhlIHN0YXRlIG9mIHRoZSB1bml2ZXJzZS5cblxuICAgIENvcHlyaWdodCAyMDE0LTIwMTUgRXZlcnlCaXQuIFNlZSBSRUFETUUgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbiAqL1xuXG5cbkVCLlNwZWMgPSB7fVxuXG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIHVzZXJuYW1lXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVzZXJuYW1lXG4gKi9cbkVCLlNwZWMuaXNWYWxpZFVzZXJuYW1lID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAvKlxuICAgIFJVTEVTOlxuICAgIC0gTWluaW11bSBsZW5ndGggaXMgMVxuICAgIC0gTWF4aW11bSBsZW5ndGggb2YgZnVsbCB1c2VybmFtZSAoaW5jbHVkaW5nIHN1YnVzZXJzIGFuZCAuKSBpcyAyNTUgY2hhcmFjdGVyc1xuICAgIC0gT25seSBhbHBoYW51bWVyaWNcbiAgICAtIE9ubHkgbG93ZXJjYXNlXG4gICAgLSBDYW5ub3QgYmVnaW4gb3IgZW5kIHdpdGggYSAuXG4gICAgICovXG5cbiAgICBFQi5TcGVjLmlzVmFsaWRVc2VybmFtZS5ydWxlc1N0YXRlbWVudCA9ICdVc2VybmFtZXMgY2FuIG9ubHkgY29udGFpbiBsb3dlcmNhc2UgbGV0dGVycywgbnVtYmVycywgYW5kIHBlcmlvZHMuIFRoZXkgY2Fubm90ICcgK1xuICAgICAgICAnYmUgbG9uZ2VyIHRoYW4gMjU1IGNoYXJhY3RlcnMsIG9yIGJlZ2luIG9yIGVuZCB3aXRoIGEgcGVyaW9kLidcblxuICAgIGlmKCF1c2VybmFtZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICBpZih1c2VybmFtZS5sZW5ndGggPiAyNTUpXG4gICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgaWYoIXVzZXJuYW1lLm1hdGNoKC9eW2EtejAtOS5dKyQvKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICBpZih1c2VybmFtZS5zbGljZSgwLCAxKSA9PSAnLicpXG4gICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgaWYodXNlcm5hbWUuc2xpY2UoLTEpID09ICcuJylcbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICByZXR1cm4gdHJ1ZVxufVxuXG5cbi8qKlxuICogRG9lcyBldmVyeXRoaW5nIHBvc3NpYmxlIHRvIG1ha2UgYSB1c2VybmFtZSB2YWxpZFxuICogTm90ZTogVGhpcyBtYXkgaGF2ZSB1bmludGVuZGVkIGNvbnNlcXVlbmNlcyBmb3IgdGhlIHVzZXJcbiAqL1xuRUIuU3BlYy5zYW5pdGl6ZVVzZXJuYW1lID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAvKlxuICAgICBUUkFOU0ZPUk1BVElPTlM6XG4gICAgIC0gUmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlXG4gICAgIC0gQ29udmVydCB0byBsb3dlcmNhc2VcbiAgICAgLSBSZW1vdmUgYWxsIGlsbGVnYWwgY2hhcmFjdGVycywgaW5jbHVkaW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nIC5cbiAgICAgKi9cbiAgICB1c2VybmFtZSA9IHVzZXJuYW1lLnRyaW0oKVxuXG4gICAgdXNlcm5hbWUgPSB1c2VybmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICBpZih1c2VybmFtZS5zbGljZSgwLCAxKSA9PSAnLicpXG4gICAgICAgIHVzZXJuYW1lID0gdXNlcm5hbWUuc2xpY2UoMSlcblxuICAgIGlmKHVzZXJuYW1lLnNsaWNlKC0xKSA9PSAnLicpXG4gICAgICAgIHVzZXJuYW1lID0gdXNlcm5hbWUuc2xpY2UoMCwtMSlcblxuICAgIHVzZXJuYW1lID0gdXNlcm5hbWUucmVwbGFjZSgvW15hLXowLTkuXSsvZywgJycpXG5cbiAgICByZXR1cm4gdXNlcm5hbWVcbn1cblxuXG4vKipcbiAqIGNoZWNrIGlmIGl0IGlzIGEgdmFsaWQgcHVibGljIGtleVxuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0tleVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkVCLlNwZWMuaXNWYWxpZFB1YmxpY0tleSA9IGZ1bmN0aW9uKHB1YmxpY0tleSkge1xuICAgIC8vIFRPRE86IGRvIFwiY2hlY2tzdW1cIiB2YWxpZGF0aW9uXG5cbiAgICBpZighaXNzZXQocHVibGljS2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG59XG5cbi8qKlxuICogY2hlY2sgaWYgaXQgaXMgYSB2YWxpZCBwcml2YXRlIGtleVxuICogQHBhcmFtIHtzdHJpbmd9IHByaXZhdGVLZXlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5FQi5TcGVjLmlzVmFsaWRQcml2YXRlS2V5ID0gZnVuY3Rpb24ocHJpdmF0ZUtleSkge1xuICAgIC8vIFRPRE86IFZhbGlkYXRlIGJ5IHRlc3RpbmcgaWYgY2FuIGJlIGNvbnZlcnRlZCB0byBwdWJsaWMga2V5XG5cbiAgICBpZighaXNzZXQocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGlzIGEgdmFsaWQgY2FwYVxuICogQHBhcmFtIGNhcGFcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5FQi5TcGVjLmlzVmFsaWRDYXBhID0gZnVuY3Rpb24oY2FwYSkge1xuXG4gICAgLypcbiAgICAgUlVMRVM6XG4gICAgIC0gTXVzdCBiZSBhIG5hdHVyYWwgbnVtYmVyICgxIG9yIGdyZWF0ZXIpXG4gICAgICovXG5cbiAgICBFQi5TcGVjLmlzVmFsaWRDYXBhLnJ1bGVzU3RhdGVtZW50ID0gJ2NhcGEgbXVzdCBiZSBhIG5hdHVyYWwgbnVtYmVyLic7XG5cblxuICAgIGNhcGEgPSBjYXBhLnRvU3RyaW5nKCk7IC8vIENvbnZlcnQgdG8gc3RyaW5nXG4gICAgdmFyIG4xID0gTWF0aC5hYnMobik7XG4gICAgdmFyIG4yID0gcGFyc2VJbnQobiwgMTApO1xuXG4gICAgaWYobjIgPCAxKVxuICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgIHJldHVybiAhaXNOYU4objEpICYmIG4yID09PSBuMSAmJiBuMS50b1N0cmluZygpID09PSBuO1xufVxuXG5cblxuLyoqXG4gKiBjaGVjayBpZiBhIHVzZXJuYW1lIGlzIHZhbGlkXG4gKiAgICAgYSB1c2VybmFtZSBtdXN0IGJlIHNob3J0ZXIgdGhhbiAyNTYgY2hhcmFjdGVycywgYWxsIGxvd2VyY2FzZSBhbmQgY29udGFpbnMgb25seSBhbHBoYW51bWVyaWMgYW5kIC4gc2lnblxuICogQHBhcmFtICB7c3RyaW5nfSB1c2VybmFtZSB0aGUgc3RyaW5nIHRvIGJlIGNoZWNrXG4gKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgICByZXR1cm4gdHJ1ZSBpZiAgdGhlIHBhcmFtZXRlciBzdHJpbmcgaXMgYSB2YWxpZCB1c2VybmFtZSwgb3RoZXJ3aXNlIHRocm93IGVycm9yXG4gKi9cbkVCLlNwZWMudmFsaWRhdGVVc2VybmFtZSA9IGZ1bmN0aW9uKHVzZXJuYW1lKSB7XG4gICAgaWYoIXVzZXJuYW1lKSBcbiAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ1VzZXJuYW1lIGlzIHJlcXVpcmVkJywgdXNlcm5hbWUpXG5cbiAgICBpZih1c2VybmFtZS5sZW5ndGggPiAyNTYpIFxuICAgICAgICByZXR1cm4gRUIub25FcnJvcignVXNlcm5hbWVzIG11c3QgYmUgc2hvcnRlciB0aGFuIDI1NiBjaGFyYWN0ZXJzJywgdXNlcm5hbWUpXG5cbiAgICBpZih1c2VybmFtZSAhPSB1c2VybmFtZS50b0xvd2VyQ2FzZSgpKSBcbiAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ1VzZXJuYW1lcyBtdXN0IGJlIGxvd2VyY2FzZScsIHVzZXJuYW1lKVxuICAgIFxuICAgIGlmKCEvXlswLTlhLXouXSskLy50ZXN0KHVzZXJuYW1lKSlcbiAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ1VzZXJuYW1lcyBtdXN0IGJlIGFscGhhbnVtZXJpYycsIHVzZXJuYW1lKVxuICAgIFxuICAgIHJldHVybiB0cnVlXG59XG5cblxuLyoqXG4gKiBkZXRlcm1pbmUgaWYgaXQgaXMgYSBnb29kIHNoZWxsLCBjaGVja3MgZm9yIHRoZSBleGlzdGVuY2Ugb2YgcmVxdWlyZWQgZmllbGRzXG4gKiBAcGFyYW0ge1NoZWxsW119XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuRUIuU3BlYy5pc1ZhbGlkU2hlbGwgPSBmdW5jdGlvbihzaGVsbCkge1xuICAgIC8vLy8gdGhpcyBqdXN0IGNoZWNrcyBmb3IgdGhlIGV4aXN0ZW5jZSBvZiByZXF1aXJlZCBmaWVsZHNcbiAgICBpZighc2hlbGwuc2lnKSByZXR1cm4gZmFsc2VcbiAgICBpZighc2hlbGwucm91dGVzKSByZXR1cm4gZmFsc2VcbiAgICBpZighc2hlbGwudXNlcm5hbWUpIHJldHVybiBmYWxzZVxuICAgIGlmKHR5cGVvZiBzaGVsbC5wYXlsb2FkICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2VcbiAgICBpZighc2hlbGwucGF5bG9hZC50eXBlKSByZXR1cm4gZmFsc2VcbiAgICAgICAgXG4gICAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiB0byB2ZXJpZnkgYSBwdWZmXG4gKiBAcGFyYW0gIHtvYmplY3R9IHB1ZmZcbiAqIEByZXR1cm4geyhzdHJpbmd8Ym9vbGVhbil9XG4gKi9cbkVCLlNwZWMuaXNHb29kUHVmZiA9IGZ1bmN0aW9uKHB1ZmYpIHtcbiAgICAvLyBDVVJSRU5UTFkgVU5VU0VEXG4gICAgLy8gVE9ETzogY2hlY2sgcHJldmlvdXMgc2lnLCBtYXliZVxuICAgIC8vIFRPRE86IGNoZWNrIGZvciB3ZWxsLWZvcm1lZC1uZXNzXG4gICAgLy8gVE9ETzogdXNlIHRoaXMgdG8gdmVyaWZ5IGluY29taW5nIHB1ZmZzXG4gICAgLy8gVE9ETzogaWYgcHJvbSBkb2Vzbid0IG1hdGNoLCB0cnkgYWdhaW4gd2l0aCBnZXRVc2VyUmVjb3JkTm9DYWNoZVxuICAgIFxuICAgIC8vIFRPRE86IHJld3JpdGUgdGhpcyBmdW5jdGlvbiB0byBnaXZlIGEgY29uc2lzdGVudCByZXR1cm4gdmFsdWVcbiAgICBcbiAgICBpZiAoIUVCLkRhdGEuY29udGVudFR5cGVzW3NoZWxsLnBheWxvYWQudHlwZV0pIHtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBuZWVkcyB0byBpbmNsdWRlICdlbmNyeXB0ZWRwdWZmJyBhcyBhIHZhbGlkIHR5cGVcbiAgICAgICAgRXZlbnRzLnB1YigndHJhY2svdW5zdXBwb3J0ZWQtY29udGVudC10eXBlJywge3R5cGU6IHNoZWxsLnBheWxvYWQudHlwZSwgc2lnOiBzaGVsbC5zaWd9KVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgXG4gICAgdmFyIHByb20gPSBFQi5Vc2Vycy5nZXRVc2VyUmVjb3JkUHJvbWlzZShwdWZmLnVzZXJuYW1lKSAvLyBOT1RFOiB2ZXJzaW9uZWRVc2VybmFtZVxuICAgIFxuICAgIHJldHVybiBwcm9tLnRoZW4oZnVuY3Rpb24odXNlcikge1xuICAgICAgICByZXR1cm4gRUIuQ3J5cHRvLnZlcmlmeVB1ZmZTaWcocHVmZiwgdXNlci5kZWZhdWx0S2V5KVxuICAgIH0pXG59XG4iLCIvKlxuXG4gICAgVXNlciBtYW5hZ2VtZW50IGZvciB0aGUgRXZlcnlCaXQgcGxhdGZvcm0uXG5cbiAgICBNb3N0IGZ1bmN0aW9ucyByZWxhdGVkIHRvIHVzZXJSZWNvcmRzIGxpdmUgaGVyZS5cbiAgICBOb3RlIHRoYXQgdXNlclJlY29yZHMgYXJlIGVudGlyZWx5IHB1YmxpYztcbiAgICBwcml2YXRlIGtleSBpZGVudGl0aWVzIGFyZSBoYW5kbGVkIGVsc2V3aGVyZS5cblxuICAgIENvcHlyaWdodCAyMDE0LTIwMTUgRXZlcnlCaXQuIFNlZSBSRUFETUUgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbiAqL1xuXG5FQi5Vc2VycyA9IHt9XG5cbkVCLlVzZXJzLnJlY29yZHMgID0ge30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXBzIHZlcnNpb25lZCB1c2VybmFtZSB0byBhbiBhcnJheSBvZiBESFQgdXNlclJlY29yZHNcbkVCLlVzZXJzLnByb21pc2VzID0ge30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwZW5kaW5nIHVzZXJSZWNvcmQgcmVxdWVzdHNcblxuXG5FQi5Vc2Vycy5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIEVCLlVzZXJzLmRlcGVyc2lzdCgpICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvcCB1c2VyUmVjb3JkcyBvdXQgb2YgbG9jYWxTdG9yYWdlXG59XG5cblxuRUIuVXNlcnMucHJvY2VzcyA9IGZ1bmN0aW9uKHVzZXJSZWNvcmQpIHtcbiAgICAvLy8vIFByb2Nlc3NlcyBhbGwgaW5jb21pbmcgdXNlclJlY29yZHNcbiAgICBcbiAgICB1c2VyUmVjb3JkID0gRUIuVXNlcnMuYnVpbGQoIHVzZXJSZWNvcmQudXNlcm5hbWUsIHVzZXJSZWNvcmQuZGVmYXVsdEtleSwgdXNlclJlY29yZC5hZG1pbktleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgdXNlclJlY29yZC5yb290S2V5LCAgdXNlclJlY29yZC5sYXRlc3QsICAgICB1c2VyUmVjb3JkLmNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHVzZXJSZWNvcmQudXBkYXRlZCwgIHVzZXJSZWNvcmQucHJvZmlsZSwgICAgdXNlclJlY29yZC5pZGVudGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgdXNlclJlY29yZC5jYXBhIClcbiAgICBcbiAgICBpZighdXNlclJlY29yZClcbiAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ1RoYXQgaXMgbm90IGFuIGFjY2VwdGFibGUgdXNlciByZWNvcmQnLCB1c2VyUmVjb3JkKVxuICAgIFxuICAgIEVCLlVzZXJzLmNhY2hlKHVzZXJSZWNvcmQpXG4gICAgXG4gICAgcmV0dXJuIHVzZXJSZWNvcmRcbn1cblxuXG5FQi5Vc2Vycy5nZXRDYWNoZWRVc2VyUmVjb3JkID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICBpZihFQi5Vc2Vycy5tYWtlVmVyc2lvbmVkKHVzZXJuYW1lKSA9PSB1c2VybmFtZSkgICAgLy8gdXNlcm5hbWUgaXMgdmVyc2lvbmVkXG4gICAgICAgIHJldHVybiBFQi5Vc2Vycy5yZWNvcmRzW3VzZXJuYW1lXVxuICAgIFxuICAgIHJldHVybiBFQi5Vc2Vycy5maW5kRnJlc2hlc3QodXNlcm5hbWUpICAgICAgICAgICAgICAvLyB1c2VybmFtZSBpc24ndCB2ZXJzaW9uZWRcbn1cblxuXG4vKipcbiAqIENoZWNrcyB0aGUgY2FjaGUsIGFuZCBhbHdheXMgcmV0dXJucyBhIHByb21pc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZVxuICogQHBhcmFtIHtpbnR9IGNhcGEgaXMgdGhlIHZlcnNpb24gb2YgdGhlIHVzZXJuYW1lIGtleXNcbiAqIEByZXR1cm5zIHtvYmplY3R9IFByb21pc2UgZm9yIGEgdXNlciByZWNvcmRcbiAqIExvb2tzIGZpcnN0IGluIHRoZSBjYWNoZSwgdGhlbiBncmFicyBmcm9tIHRoZSBuZXR3b3JrXG4gKi9cbkVCLlVzZXJzLmdldFVzZXJSZWNvcmRQcm9taXNlID0gZnVuY3Rpb24odXNlcm5hbWUsIGNhcGEpIHtcbiAgICAvLy8vIFRoaXMgYWx3YXlzIGNoZWNrcyB0aGUgY2FjaGUsIGFuZCBhbHdheXMgcmV0dXJucyBhIHByb21pc2VcbiAgICBcbiAgICB2YXIgdmVyc2lvbmVkVXNlcm5hbWUgPSBFQi5Vc2Vycy5tYWtlVmVyc2lvbmVkKHVzZXJuYW1lLCBjYXBhKVxuICAgIFxuICAgIHZhciB1c2VyUmVjb3JkID0gRUIuVXNlcnMuZ2V0Q2FjaGVkVXNlclJlY29yZCh2ZXJzaW9uZWRVc2VybmFtZSlcbiAgICBcbiAgICBpZih1c2VyUmVjb3JkKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVzZXJSZWNvcmQpXG4gICAgXG4gICAgdmFyIHVzZXJQcm9taXNlID0gRUIuVXNlcnMucHJvbWlzZXNbdmVyc2lvbmVkVXNlcm5hbWVdXG4gICAgXG4gICAgaWYodXNlclByb21pc2UpXG4gICAgICAgIHJldHVybiB1c2VyUHJvbWlzZVxuICAgIFxuICAgIHJldHVybiBFQi5Vc2Vycy5nZXRVc2VyUmVjb3JkTm9DYWNoZSh2ZXJzaW9uZWRVc2VybmFtZSlcbn1cblxuXG4vKipcbiAqIEZvcmNlcyBhIHJlcXVlc3QgdG8gdGhlIG5ldHdvcmssIGlnbm9yZXMgY2FjaGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWVcbiAqIEBwYXJhbSB7aW50fSBjYXBhIGlzIHRoZSB2ZXJzaW9uIG9mIHRoZSB1c2VybmFtZSBrZXlzXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBQcm9taXNlIGZvciBhIHVzZXIgcmVjb3JkXG4gKi9cbkVCLlVzZXJzLmdldFVzZXJSZWNvcmROb0NhY2hlID0gZnVuY3Rpb24odXNlcm5hbWUsIGNhcGEpIHtcbiAgICAvLy8vIFRoaXMgbmV2ZXIgY2hlY2tzIHRoZSBjYWNoZVxuICAgIFxuICAgIGNhcGEgPSBjYXBhIHx8IDAgLy8gMCBzaWduYWxzIEVCLk5ldC5nZXRVc2VyUmVjb3JkIHRvIGdldCB0aGUgbGF0ZXN0IHVzZXJSZWNvcmRcbiAgICBcbiAgICB2YXIgcHJvbSA9IEVCLk5ldC5nZXRVc2VyUmVjb3JkKHVzZXJuYW1lLCBjYXBhKSBcbiAgICBcbiAgICBwcm9tID0gcHJvbS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHVzZXJSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVzZXJSZWNvcmQgPSBFQi5Vc2Vycy5wcm9jZXNzKHVzZXJSZWNvcmQpXG4gICAgICAgICAgICAgICAgICAgIGlmKCF1c2VyUmVjb3JkKSAgRUIudGhyb3dFcnJvcignSW52YWxpZCB1c2VyIHJlY29yZCByZXR1cm5lZCcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1c2VyUmVjb3JkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICwgRUIuY2F0Y2hFcnJvcignVW5hYmxlIHRvIGFjY2VzcyB1c2VyIGluZm9ybWF0aW9uIGZyb20gdGhlIERIVCcpKVxuICAgIFxuICAgIHZhciB2ZXJzaW9uZWRVc2VybmFtZSA9IEVCLlVzZXJzLm1ha2VWZXJzaW9uZWQodXNlcm5hbWUsIGNhcGEpXG4gICAgRUIuVXNlcnMucHJvbWlzZXNbdmVyc2lvbmVkVXNlcm5hbWVdID0gcHJvbVxuICAgIFxuICAgIHJldHVybiBwcm9tXG59XG5cbkVCLlVzZXJzLmRvZXNVc2VyRXhpc3QgPSBmdW5jdGlvbih1c2VybmFtZSkge1xuICAgIHJldHVybiBFQi5OZXQuZ2V0VXNlclJlY29yZCh1c2VybmFtZSkudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKCF1c2VyUmVjb3JkIHx8IHVzZXJSZWNvcmQuRkFJTCkgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnVXNlciBkb2VzIG5vdCBleGlzdCdcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLCBFQi5jYXRjaEVycm9yKCdVbmFibGUgdG8gYWNjZXNzIHVzZXIgaW5mb3JtYXRpb24gZnJvbSB0aGUgREhUJykpXG59XG5cblxuLy9cbi8vIFVTRVJOQU1FIEhFTFBFUlNcbi8vXG5cbkVCLlVzZXJzLnVzZXJSZWNvcmRUb1ZlcnNpb25lZFVzZXJuYW1lID0gZnVuY3Rpb24odXNlclJlY29yZCkge1xuICAgIHJldHVybiBFQi5Vc2Vycy5tYWtlVmVyc2lvbmVkKHVzZXJSZWNvcmQudXNlcm5hbWUsIHVzZXJSZWNvcmQuY2FwYSlcbn1cblxuRUIuVXNlcnMuanVzdFVzZXJuYW1lID0gZnVuY3Rpb24odmVyc2lvbmVkVXNlcm5hbWUpIHtcbiAgICB2YXIgdWMgPSBFQi5Vc2Vycy5icmVha1ZlcnNpb25lZFVzZXJuYW1lKHZlcnNpb25lZFVzZXJuYW1lKVxuICAgIHJldHVybiB1Yy51c2VybmFtZVxufVxuXG5FQi5Vc2Vycy5qdXN0Q2FwYSA9IGZ1bmN0aW9uKHZlcnNpb25lZFVzZXJuYW1lKSB7XG4gICAgdmFyIHVjID0gRUIuVXNlcnMuYnJlYWtWZXJzaW9uZWRVc2VybmFtZSh2ZXJzaW9uZWRVc2VybmFtZSlcbiAgICByZXR1cm4gdWMuY2FwYVxufVxuXG5FQi5Vc2Vycy5tYWtlVmVyc2lvbmVkID0gZnVuY3Rpb24odXNlcm5hbWUsIGNhcGEpIHtcbiAgICBpZighdXNlcm5hbWUgfHwgIXVzZXJuYW1lLmluZGV4T2YpXG4gICAgICAgIHJldHVybiAnJ1xuICAgIFxuICAgIGlmKGNhcGEpXG4gICAgICAgIHJldHVybiBhY3R1YWxseVZlcnNpb25UaGlzVXNlcm5hbWVPa2F5KHVzZXJuYW1lLCBjYXBhKVxuICAgIFxuICAgIGlmKHVzZXJuYW1lLmluZGV4T2YoJzonKSA+IDApXG4gICAgICAgIHJldHVybiB1c2VybmFtZVxuICAgIFxuICAgIHJldHVybiBhY3R1YWxseVZlcnNpb25UaGlzVXNlcm5hbWVPa2F5KHVzZXJuYW1lKVxuICAgIFxuICAgIGZ1bmN0aW9uIGFjdHVhbGx5VmVyc2lvblRoaXNVc2VybmFtZU9rYXkodXNlcm5hbWUsIGNhcGEpIHtcbiAgICAgICAgY2FwYSA9IGNhcGEgfHwgMSAvLyBOT1RFOiBkZWZhdWx0IGNhcGFcbiAgICAgICAgcmV0dXJuIHVzZXJuYW1lICsgJzonICsgY2FwYVxuICAgIH1cbn1cblxuRUIuVXNlcnMuYnJlYWtWZXJzaW9uZWRVc2VybmFtZSA9IGZ1bmN0aW9uKHZlcnNpb25lZFVzZXJuYW1lKSB7XG4gICAgdmFyIGxpc3QgPSAodmVyc2lvbmVkVXNlcm5hbWV8fCcnKS5zcGxpdCgnOicpXG5cbiAgICByZXR1cm4geyB1c2VybmFtZTogbGlzdFswXVxuICAgICAgICAgICAsIGNhcGE6ICAgICBsaXN0WzFdIHx8IDEgLy8gTk9URTogZGVmYXVsdCBjYXBhXG4gICAgICAgICAgIH1cbn1cblxuXG4vL1xuLy8gR0VORVJBTCBIRUxQRVJTXG4vL1xuXG5cbkVCLlVzZXJzLmJ1aWxkID0gZnVuY3Rpb24odXNlcm5hbWUsIGRlZmF1bHRLZXksIGFkbWluS2V5LCByb290S2V5LCBsYXRlc3QsIGNyZWF0ZWQsIHVwZGF0ZWQsIHByb2ZpbGUsIGlkZW50aXR5LCBjYXBhKSB7XG4gICAgLy8vLyByZXR1cm5zIGEgY2Fub25pY2FsIHVzZXIgb2JqZWN0OiB1c2UgdGhpcyBldmVyeXdoZXJlIHVzZXIgb2JqZWN0cyBhcmUgbmVlZGVkIChESFQsIGlkZW50aXRpZXMsIGV0YylcblxuICAgIGxhdGVzdCAgID0gbGF0ZXN0ICAgfHwgXCJcIiAgICAgICAgICAgICAgICAgICAgICAgLy8gc2lnbmF0dXJlIG9mIHRoZSBtb3N0IHJlY2VudCBwdWZmIHB1Ymxpc2hlZCBieSB0aGUgdXNlclxuICAgIHVwZGF0ZWQgID0gdXBkYXRlZCAgfHwgXCJcIiAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0ZSBvZiB0aGUgbW9zdCByZWNlbnQgdXBkYXRlIHRvIHRoZSB1c2VybmFtZVxuICAgIHByb2ZpbGUgID0gcHJvZmlsZSAgfHwgXCJcIiAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvZmlsZSBwdWZmIHNpZ25hdHVyZVxuICAgIGlkZW50aXR5ID0gaWRlbnRpdHkgfHwgXCJcIiAgICAgICAgICAgICAgICAgICAgICAgLy8gaWRlbnRpdHkgcHVmZiBzaWduYXR1cmVcbiAgICBjYXBhICAgICA9IGNhcGEgICAgIHx8IDEgICAgICAgICAgICAgICAgICAgICAgICAvLyB2ZXJzaW9uIG9mIHRoZSB1c2VybmFtZVxuICAgIFxuICAgIC8vIFRISU5LOiBzaG91bGQgd2UgY2hlY2sgZm9yIHZhbGlkIGtleXM/IHZhbGlkIHRpbWVzdGFtcCBmb3IgdXBkYXRlZD8gd2hhdCBpZiB5b3Ugd2FudCBhIHBhcnRpYWxseSBpbnZhbGlkIHVzZXIgbGlrZSBhbm9uP1xuICAgIFxuICAgIC8vIFRISU5LOiBzcGxpdCB1c2VybmFtZSBhbmQgY2FwYSBpZiBpdCdzIGEgdmVyc2lvbmVkVXNlcm5hbWU/XG5cbiAgICBpZighRUIuU3BlYy52YWxpZGF0ZVVzZXJuYW1lKHVzZXJuYW1lKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlcnJvciBpcyBsb2dnZWQgaW5zaWRlIEVCLlNwZWMudmFsaWRhdGVVc2VybmFtZVxuICAgIFxuICAgIHJldHVybiB7ICAgdXNlcm5hbWU6IHVzZXJuYW1lICAgICAgICAgICAgICAgICAgIC8vIHVudmVyc2lvbmVkIHVzZXJuYW1lXG4gICAgICAgICAgICwgICAgICAgY2FwYTogY2FwYVxuICAgICAgICAgICAsICAgIHJvb3RLZXk6IHJvb3RLZXkgICAgICAgICAgICAgICAgICAgIC8vIHB1YmxpYyByb290IGtleVxuICAgICAgICAgICAsICAgYWRtaW5LZXk6IGFkbWluS2V5ICAgICAgICAgICAgICAgICAgIC8vIHB1YmxpYyBhZG1pbiBrZXlcbiAgICAgICAgICAgLCBkZWZhdWx0S2V5OiBkZWZhdWx0S2V5ICAgICAgICAgICAgICAgICAvLyBwdWJsaWMgZGVmYXVsdCBrZXlcbiAgICAgICAgICAgLCAgICBjcmVhdGVkOiBjcmVhdGVkICAgICAgICAgICAgICAgICAgICAvLyBEYXRlIHRoZSByZWNvcmQgd2FzIGNyZWF0ZWRcbiAgICAgICAgICAgLCAgICAgbGF0ZXN0OiBsYXRlc3RcbiAgICAgICAgICAgLCAgICB1cGRhdGVkOiB1cGRhdGVkXG4gICAgICAgICAgICwgICAgcHJvZmlsZTogcHJvZmlsZVxuICAgICAgICAgICAsICAgaWRlbnRpdHk6IGlkZW50aXR5XG4gICAgICAgICAgIH1cbn1cblxuXG5FQi5Vc2Vycy51c2VybmFtZXNUb1VzZXJSZWNvcmRzUHJvbWlzZSA9IGZ1bmN0aW9uKHVzZXJuYW1lcykge1xuICAgIC8vLy8gcmV0dXJucyBhIHByb21pc2Ugb2YgdXNlclJlY29yZHMuIHRoYW5rcyB0byBjYXBhIHdlIHVzdWFsbHkgZG9uJ3QgbmVlZCB0aGUgbGF0ZXN0IGFuZCBjYW4gdXNlIGNhY2hlZCB2ZXJzaW9ucy5cbiAgICBpZighdXNlcm5hbWVzIHx8ICF1c2VybmFtZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKVxuICAgIFxuICAgIGlmKCFBcnJheS5pc0FycmF5KHVzZXJuYW1lcykpXG4gICAgICAgIHVzZXJuYW1lcyA9IFt1c2VybmFtZXNdXG4gICAgICAgIFxuICAgIHZhciB1c2VyUmVjb3JkcyA9IHVzZXJuYW1lcy5tYXAoRUIuVXNlcnMuZ2V0Q2FjaGVkVXNlclJlY29yZCkuZmlsdGVyKEJvb2xlYW4pXG4gICAgXG4gICAgaWYgKHVzZXJSZWNvcmRzLmxlbmd0aCA9PSB1c2VybmFtZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVzZXJSZWNvcmRzKSAvLyBnb3QgJ2VtIGFsbCFcbiAgICBcbiAgICB2YXIgcHJvbSA9IFByb21pc2UucmVzb2x2ZSgpIC8vIGEgcHJvbWlzZSB3ZSB1c2UgdG8gc3RyaW5nIGV2ZXJ5dGhpbmcgYWxvbmdcblxuICAgIHZhciB1c2VyUmVjb3JkVXNlcm5hbWVzID0gdXNlclJlY29yZHMubWFwKGZ1bmN0aW9uICh1c2VyUmVjb3JkKSB7XG4gICAgICAgIHJldHVybiB1c2VyUmVjb3JkLnVzZXJuYW1lXG4gICAgfSlcbiAgICBcbiAgICB1c2VybmFtZXMuZm9yRWFjaChmdW5jdGlvbiAodXNlcm5hbWUpIHtcbiAgICAgICAgaWYgKCF+dXNlclJlY29yZFVzZXJuYW1lcy5pbmRleE9mKHVzZXJuYW1lKSkgeyAvLyB3ZSBuZWVkIHRoaXMgb25lXG4gICAgICAgICAgICBwcm9tID0gcHJvbS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFQi5Vc2Vycy5nZXRVc2VyUmVjb3JkTm9DYWNoZSh1c2VybmFtZSkudGhlbihmdW5jdGlvbiAodXNlclJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICB1c2VyUmVjb3Jkcy5wdXNoKHVzZXJSZWNvcmQpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIHJldHVybiBwcm9tLnRoZW4oZnVuY3Rpb24oKSB7IHJldHVybiB1c2VyUmVjb3JkcyB9KSAvLyB3aGVuIGl0J3MgYWxsIGRvbmUsIGdpdmUgYmFjayB0aGUgdXNlclJlY29yZHNcbn1cblxuRUIuVXNlcnMuY2FjaGUgPSBmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgLy8vLyBUaGlzIGNhY2hlcyB3aXRoIG5vIHZhbGlkYXRpb246IHVzZSBFQi5Vc2Vycy5wcm9jZXNzIGluc3RlYWRcbiAgICBcbiAgICB2YXIgdmVyc2lvbmVkVXNlcm5hbWUgPSBFQi5Vc2Vycy51c2VyUmVjb3JkVG9WZXJzaW9uZWRVc2VybmFtZSh1c2VyUmVjb3JkKVxuICAgIFxuICAgIEVCLlVzZXJzLnJlY29yZHNbdmVyc2lvbmVkVXNlcm5hbWVdID0gdXNlclJlY29yZFxuICAgIFxuICAgIGRlbGV0ZSBFQi5Vc2Vycy5wcm9taXNlc1t2ZXJzaW9uZWRVc2VybmFtZV1cbiAgICBcbiAgICBFQi5QZXJzaXN0LnNhdmUoJ3VzZXJSZWNvcmRzJywgRUIuVXNlcnMucmVjb3JkcylcbiAgICBcbiAgICByZXR1cm4gdXNlclJlY29yZFxufVxuXG5FQi5Vc2Vycy5kZXBlcnNpc3QgPSBmdW5jdGlvbigpIHtcbiAgICAvLy8vIGdyYWIgdXNlclJlY29yZHMgZnJvbSBsb2NhbCBzdG9yYWdlLiB0aGlzIHNtYXNoZXMgdGhlIGN1cnJlbnQgdXNlclJlY29yZHMgaW4gbWVtb3J5LCBzbyBkb24ndCBjYWxsIGl0IGFmdGVyIGluaXQhXG4gICAgRUIuVXNlcnMucmVjb3JkcyA9IEVCLlBlcnNpc3QuZ2V0KCd1c2VyUmVjb3JkcycpIHx8IHt9XG59XG5cblxuRUIuVXNlcnMuZmluZEZyZXNoZXN0ID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICB1c2VybmFtZSA9IEVCLlVzZXJzLmp1c3RVc2VybmFtZSh1c2VybmFtZSlcbiAgICBcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKEVCLlVzZXJzLnJlY29yZHMpXG4gICAgdmFyIGNhcGEgPSAwXG4gICAgXG4gICAga2V5cy5maWx0ZXIoZnVuY3Rpb24odmVyc2lvbmVkVXNlcm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIEVCLlVzZXJzLmp1c3RVc2VybmFtZSh2ZXJzaW9uZWRVc2VybmFtZSkgPT0gdXNlcm5hbWVcbiAgICB9KS5mb3JFYWNoKCBmdW5jdGlvbih2ZXJzaW9uZWRVc2VybmFtZSkge1xuICAgICAgICB2YXIgdGhpc19jYXBhID0gK0VCLlVzZXJzLmp1c3RDYXBhKHZlcnNpb25lZFVzZXJuYW1lKVxuICAgICAgICBpZih0aGlzX2NhcGEgPiBjYXBhKVxuICAgICAgICAgICAgY2FwYSA9IHRoaXNfY2FwYVxuICAgIH0pXG4gICAgXG4gICAgdmFyIHZlcnNpb25lZFVzZXJuYW1lID0gRUIuVXNlcnMubWFrZVZlcnNpb25lZCh1c2VybmFtZSwgY2FwYSlcbiAgICByZXR1cm4gRUIuVXNlcnMucmVjb3Jkc1t2ZXJzaW9uZWRVc2VybmFtZV1cbn1cblxuXG5FQi5Vc2Vycy5nZXRJZGVudGl0eVB1ZmYgPSBmdW5jdGlvbih1c2VyUmVjb3JkLCBwcml2YXRlS2V5KSB7XG4gICAgLy8vLyB1c2VyUmVjb3JkIGlzIHRoZSB1c2VyJ3MgY2Fub25pY2FsIHVzZXIgcmVjb3JkXG4gICAgLy8vLyBwcml2YXRlS2V5IGlzIHRoZSB1c2VyJ3MgcHJpdmF0ZSBkZWZhdWx0IGtleVxuICAgIFxuICAgIGlmKCF1c2VyUmVjb3JkIHx8ICF1c2VyUmVjb3JkLmRlZmF1bHRLZXkgfHwgIXVzZXJSZWNvcmQudXNlcm5hbWUpXG4gICAgICAgIHJldHVybiBFQi5lbXB0eVByb21pc2UoJ0ludmFsaWQgdXNlciByZWNvcmQnKVxuICAgIFxuICAgIGlmKCF1c2VyUmVjb3JkLmlkZW50aXR5KVxuICAgICAgICByZXR1cm4gRUIuZW1wdHlQcm9taXNlKCdVc2VyIHJlY29yZCBoYXMgbm8gaWRlbnRpdHknKVxuICAgIFxuICAgIHB1ZmZwcm9tID0gRUIuTmV0LmdldFB1ZmZCeVNpZyh1c2VyUmVjb3JkLmlkZW50aXR5KVxuXG4gICAgcmV0dXJuIHB1ZmZwcm9tLnRoZW4oZnVuY3Rpb24ocHVmZnMpIHtcbiAgICAgICAgdmFyIGVudmVsb3BlID0gcHVmZnNbMF1cbiAgICAgICAgaWYoIWVudmVsb3BlIHx8ICFlbnZlbG9wZS5zaWcpXG4gICAgICAgICAgICByZXR1cm4gRUIudGhyb3dFcnJvcignSW52YWxpZCBpZGVudGl0eSBwdWZmJylcbiAgICAgICAgXG4gICAgICAgIHZhciBzZW5kZXJQdWJsaWNLZXkgPSB1c2VyUmVjb3JkLmRlZmF1bHRLZXlcbiAgICAgICAgdmFyIHJlY2lwaWVudFVzZXJuYW1lID0gRUIuVXNlcnMubWFrZVZlcnNpb25lZCh1c2VyUmVjb3JkLnVzZXJuYW1lLCB1c2VyUmVjb3JkLmNhcGEpXG4gICAgICAgIHZhciByZWNpcGllbnRQcml2YXRlS2V5ID0gcHJpdmF0ZUtleVxuXG4gICAgICAgIHJldHVybiBFQi5QdWZmLnByb21pc2VUb0RlY3J5cHRGb3JSZWFscyhlbnZlbG9wZSwgc2VuZGVyUHVibGljS2V5LCByZWNpcGllbnRVc2VybmFtZSwgcmVjaXBpZW50UHJpdmF0ZUtleSlcbiAgICB9KSAgICAgICAgXG59XG5cblxuLyoqXG4gKiByZWdpc3RlciBhIHN1YnVzZXJcbiAqIEBwYXJhbSAge3N0cmluZ30gc2lnbmluZ1VzZXJuYW1lIHVzZXJuYW1lIG9mIGV4aXN0ZWQgdXNlclxuICogQHBhcmFtICB7c3RyaW5nfSBwcml2YXRlQWRtaW5LZXkgcHJpdmF0ZSBhZG1pbiBrZXkgZm9yIGV4aXN0ZWQgdXNlclxuICogQHBhcmFtICB7c3RyaW5nfSBuZXdVc2VybmFtZSAgICAgZGVzaXJlZCBuZXcgc3VidXNlciBuYW1lXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RLZXkgICAgICAgICBwdWJsaWMgcm9vdCBrZXkgZm9yIHRoZSBuZXcgc3VidXNlclxuICogQHBhcmFtICB7c3RyaW5nfSBhZG1pbktleSAgICAgICAgcHVibGljIGFkbWluIGtleSBmb3IgdGhlIG5ldyBzdWJ1c2VyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGRlZmF1bHRLZXkgICAgICBwdWJsaWMgZGVmYXVsdCBrZXkgZm9yIHRoZSBuZXcgc3VidXNlclxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICB1c2VyIHJlY29yZCBmb3IgdGhlIG5ld2x5IGNyZWF0ZWQgc3VidXNlclxuICovXG5FQi5Vc2Vycy5yZWdpc3RlclN1YnVzZXJGb3JVc2VyID0gZnVuY3Rpb24oc2lnbmluZ1VzZXJuYW1lLCBwcml2YXRlQWRtaW5LZXksIG5ld1VzZXJuYW1lLCByb290S2V5LCBhZG1pbktleSwgZGVmYXVsdEtleSkge1xuICAgIHZhciBwdWZmID0gRUIuUHVmZi5idWlsZFVzZXJSZWdpc3RyYXRpb24oc2lnbmluZ1VzZXJuYW1lLCBwcml2YXRlQWRtaW5LZXksIG5ld1VzZXJuYW1lLCByb290S2V5LCBhZG1pbktleSwgZGVmYXVsdEtleSlcbiAgICByZXR1cm4gRUIuTmV0LnVwZGF0ZVVzZXJSZWNvcmQocHVmZilcbn1cblxuXG5cbi8vLy8gQU5PTllNT1VTIFVTRVJTXG5cblxuLyoqXG4gKiBBZGQgYSBuZXcgdXNlciBhbmQgYXR0YWNoIGl0IHRvIHRoZSBjdXJyZW50IGlkZW50aXR5IGFzIGFuIGFsaWFzXG4gKiBUaGlzIGlzIGJ5IHRoZSBtb3N0IGNvbW1vbiB1c2UgY2FzZSwgc2luY2UgbW9zdCBhbm9uIHVzZXJzIGFyZSBjcmVhdGVkIHRvIHNlbmQvcmVjZWl2ZSBtZXNzYWdlc1xuICogQHBhcmFtIHtzdHJpbmd9IE9wdGlvbmFsIHByaXZhdGUgZGVmYXVsdCBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBPcHRpb25hbCBwcml2YXRlIGFkbWluIGtleVxuICogQHBhcmFtIHtzdHJpbmd9IE9wdGlvbmFsIHByaXZhdGUgcm9vdCBrZXlcbiAqIEByZXR1cm5zIHtwcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgdXNlciByZWNvcmQgb3IgZmFpbHNcbiAqL1xuRUIuVXNlcnMuYWRkQW5vbnltb3VzVXNlciA9IGZ1bmN0aW9uKHByaXZhdGVEZWZhdWx0S2V5LCBwcml2YXRlQWRtaW5LZXksIHByaXZhdGVSb290S2V5KSB7XG4gICAgdmFyIGN1cnJlbnRVc2VybmFtZSA9IEVCLmdldEN1cnJlbnRVc2VybmFtZSgpXG4gICAgcmV0dXJuIEVCLlVzZXJzLmFkZEFub255bW91c1VzZXJUb0lkZW50aXR5KGN1cnJlbnRVc2VybmFtZSwgcHJpdmF0ZURlZmF1bHRLZXksIHByaXZhdGVBZG1pbktleSwgcHJpdmF0ZVJvb3RLZXkpXG59XG5cblxuLyoqXG4gKiBBZGQgYSBuZXcgdXNlciBhbmQgYXR0YWNoIHRvIGFuIGlkZW50aXR5IGFzIGFuIGFsaWFzXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIHVzZXJuYW1lIG9mIHRoZSBpZGVudGl0eSB0byB3aGljaCB0byBhdHRhY2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBPcHRpb25hbCBwcml2YXRlIGRlZmF1bHQga2V5XG4gKiBAcGFyYW0ge3N0cmluZ30gT3B0aW9uYWwgcHJpdmF0ZSBhZG1pbiBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBPcHRpb25hbCBwcml2YXRlIHJvb3Qga2V5XG4gKiBAcmV0dXJucyB7cHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIHVzZXIgcmVjb3JkIG9yIGZhaWxzXG4gKi9cbkVCLlVzZXJzLmFkZEFub255bW91c1VzZXJUb0lkZW50aXR5ID0gZnVuY3Rpb24odXNlcm5hbWUsIHByaXZhdGVEZWZhdWx0S2V5LCBwcml2YXRlQWRtaW5LZXksIHByaXZhdGVSb290S2V5KSB7XG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24odXNlclJlY29yZCwgcHJpdmF0ZURlZmF1bHRLZXksIHByaXZhdGVBZG1pbktleSwgcHJpdmF0ZVJvb3RLZXkpIHtcbiAgICAgICAgRUIuYWRkQWxpYXModXNlcm5hbWUsIHVzZXJSZWNvcmQudXNlcm5hbWUsIG51bGwsIHByaXZhdGVSb290S2V5LCBwcml2YXRlQWRtaW5LZXksIHByaXZhdGVEZWZhdWx0S2V5KVxuICAgICAgICByZXR1cm4gdXNlclJlY29yZFxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gRUIuVXNlcnMuYWRkQW5vbnltb3VzVXNlclRvREhUKGNhbGxiYWNrLCBwcml2YXRlRGVmYXVsdEtleSwgcHJpdmF0ZUFkbWluS2V5LCBwcml2YXRlUm9vdEtleSlcbn1cblxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgbmV3IGFub255bW91cyB1c2VyXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhpcyBjYWxsYmFjayB0YWtlcyB1c2VyUmVjb3JkLCBwcml2YXRlRGVmYXVsdEtleSwgcHJpdmF0ZUFkbWluS2V5LCBhbmQgcHJpdmF0ZVJvb3RLZXkgYXMgYXJnc1xuICogQHBhcmFtIHtzdHJpbmd9IE9wdGlvbmFsIHByaXZhdGUgZGVmYXVsdCBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBPcHRpb25hbCBwcml2YXRlIGFkbWluIGtleVxuICogQHBhcmFtIHtzdHJpbmd9IE9wdGlvbmFsIHByaXZhdGUgcm9vdCBrZXlcbiAqIEByZXR1cm5zIHtwcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgdXNlciByZWNvcmQgb3IgZmFpbHNcbiAqL1xuRUIuVXNlcnMuYWRkQW5vbnltb3VzVXNlclRvREhUID0gZnVuY3Rpb24oY2FsbGJhY2ssIHByaXZhdGVEZWZhdWx0S2V5LCBwcml2YXRlQWRtaW5LZXksIHByaXZhdGVSb290S2V5KSB7XG4gICAgLy8gZ2V0IHVzZXJuYW1lXG4gICAgdmFyIG5ld1VzZXJuYW1lID0gJ2Fub24uJyArIEVCLlVzZXJzLmdlbmVyYXRlUmFuZG9tVXNlcm5hbWUoMTIpXG4gICAgXG4gICAgLy8gZ2VuZXJhdGUgcHJpdmF0ZSBrZXlzXG4gICAgcHJpdmF0ZURlZmF1bHRLZXkgPSBwcml2YXRlRGVmYXVsdEtleSB8fCBFQi5DcnlwdG8uZ2VuZXJhdGVQcml2YXRlS2V5KClcbiAgICBwcml2YXRlQWRtaW5LZXkgICA9IHByaXZhdGVBZG1pbktleSAgIHx8IEVCLkNyeXB0by5nZW5lcmF0ZVByaXZhdGVLZXkoKVxuICAgIHByaXZhdGVSb290S2V5ICAgID0gcHJpdmF0ZVJvb3RLZXkgICAgfHwgRUIuQ3J5cHRvLmdlbmVyYXRlUHJpdmF0ZUtleSgpXG4gICAgXG4gICAgLy8gZ2VuZXJhdGUgcHVibGljIGtleXNcbiAgICB2YXIgZGVmYXVsdEtleSA9IEVCLkNyeXB0by5wcml2YXRlVG9QdWJsaWMocHJpdmF0ZURlZmF1bHRLZXkpXG4gICAgdmFyIGFkbWluS2V5ICAgPSBFQi5DcnlwdG8ucHJpdmF0ZVRvUHVibGljKHByaXZhdGVBZG1pbktleSlcbiAgICB2YXIgcm9vdEtleSAgICA9IEVCLkNyeXB0by5wcml2YXRlVG9QdWJsaWMocHJpdmF0ZVJvb3RLZXkpXG4gICAgXG4gICAgdmFyIHB1ZmYgPSBFQi5QdWZmLmJ1aWxkVXNlclJlZ2lzdHJhdGlvbignYW5vbicsIEVCLkNPTkZJRy5hbm9uUHJpdmF0ZUFkbWluS2V5LCBuZXdVc2VybmFtZSwgcm9vdEtleSwgYWRtaW5LZXksIGRlZmF1bHRLZXkpXG4gICAgXG4gICAgLy8gc2VuZCBESFQgdXBkYXRlIHB1ZmZcbiAgICByZXR1cm4gRUIuTmV0LnVwZGF0ZVVzZXJSZWNvcmQocHVmZikudGhlbihmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgICAgIGlmKGNhbGxiYWNrKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHVzZXJSZWNvcmQsIHByaXZhdGVEZWZhdWx0S2V5LCBwcml2YXRlQWRtaW5LZXksIHByaXZhdGVSb290S2V5KVxuICAgICAgICByZXR1cm4gdXNlclJlY29yZFxuICAgIH0pXG59XG5cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHJhbmRvbSB1c2VybmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBvZiB1c2VybmFtZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5FQi5Vc2Vycy5nZW5lcmF0ZVJhbmRvbVVzZXJuYW1lID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHNpemUgPSArc2l6ZXwwfHwwXG5cbiAgICB2YXIgZ2VuZXJhdGVkTmFtZSA9ICcnXG4gICAgdmFyIGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSdcbiAgICBmb3IodmFyIGk9MDsgaTxzaXplOyBpKyspIHtcbiAgICAgICAgZ2VuZXJhdGVkTmFtZSArPSBFQi5DcnlwdG8uZ2V0UmFuZG9tSXRlbShhbHBoYWJldClcbiAgICB9XG4gICAgcmV0dXJuIGdlbmVyYXRlZE5hbWVcbn1cblxuXG5cbkVCLlVzZXJzLmNyZWF0ZUFub25Vc2VyQW5kTWFrZUN1cnJlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBUT0RPOiBjb252ZXJ0IHRoaXMgdG8gdXNlIEVCLlVzZXJzLmFkZEFub255bW91c1VzZXJUb0RIVFxuICAgIFxuICAgIHZhciBuZXdVc2VybmFtZSA9ICdhbm9uLicgKyBFQi5Vc2Vycy5nZW5lcmF0ZVJhbmRvbVVzZXJuYW1lKDEyKVxuICAgIHZhciBwYXNzcGhyYXNlID0gRUIuQ3J5cHRvLmdlbmVyYXRlUHJpdmF0ZUtleSgpLnNsaWNlKC0xMilcbiAgICB2YXIgcHJlcGVuZGVkUGFzc3BocmFzZSA9IG5ld1VzZXJuYW1lICsgcGFzc3BocmFzZVxuICAgIHZhciBwcml2YXRlS2V5ID0gRUIuQ3J5cHRvLnBhc3NwaHJhc2VUb1ByaXZhdGVLZXlXaWYocHJlcGVuZGVkUGFzc3BocmFzZSlcbiAgICB2YXIgcHVibGljS2V5ID0gRUIuQ3J5cHRvLnByaXZhdGVUb1B1YmxpYyhwcml2YXRlS2V5KVxuXG4gICAgLy8gQnVpbGQgcHVmZiB0byByZWdpc3RlciB0aGlzIHVzZXJcbiAgICB2YXIgcHVmZiA9IEVCLlB1ZmYuYnVpbGRVc2VyUmVnaXN0cmF0aW9uKCdhbm9uJywgRUIuQ09ORklHLmFub25Qcml2YXRlQWRtaW5LZXksIG5ld1VzZXJuYW1lLCBwdWJsaWNLZXksIHB1YmxpY0tleSwgcHVibGljS2V5KVxuXG4gICAgdmFyIHByb20gPSBFQi5OZXQudXBkYXRlVXNlclJlY29yZChwdWZmKVxuXG4gICAgLy8gV29ya3M/XG4gICAgcmV0dXJuIHByb20udGhlbihmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgICAgIC8vIFN3aXRjaCB0byB0aGlzIHVzZXJcbiAgICAgICAgRUIuYWRkQWxpYXModXNlclJlY29yZC51c2VybmFtZSwgdXNlclJlY29yZC51c2VybmFtZSwgMSwgcHJpdmF0ZUtleSwgcHJpdmF0ZUtleSwgcHJpdmF0ZUtleSwge3Bhc3NwaHJhc2U6IHBhc3NwaHJhc2V9KVxuXG4gICAgICAgIEVCLnN3aXRjaElkZW50aXR5VG8odXNlclJlY29yZC51c2VybmFtZSlcblxuICAgICAgICByZXR1cm4gdXNlclJlY29yZFxuICAgIH0pXG59XG4iLCIvKiBcbiAgICAgXyAgXyAgX19fXyAgX19fXyAgX19fXyAgIF9fICAgIF9fXyAgX19fXyAgX19fXyBcbiAgICAoIFxcLyApKCAgX18pLyBfX18pLyBfX18pIC8gX1xcICAvIF9fKSggIF9fKS8gX19fKVxuICAgIC8gXFwvIFxcICkgXykgXFxfX18gXFxcXF9fXyBcXC8gICAgXFwoIChfIFxcICkgXykgXFxfX18gXFxcbiAgICBcXF8pKF8vKF9fX18pKF9fX18vKF9fX18vXFxfL1xcXy8gXFxfX18vKF9fX18pKF9fX18vICBcbiAgXG4gIFdoZW4gaW5jbHVkZWQgdGhpcyBtb2R1bGUgYWRkcyB0d28gcGFzc2l2ZSBlbmhhbmNlbWVudHM6XG4gIC0gYWxsIHB1ZmZzIHJlY2VpdmUgYSBwYXlsb2FkLnRpbWUgZmllbGQgY29udGFpbmluZyB0aGUgY3VycmVudCB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAtIGFueSBwdWZmIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2Ygc2lnbmF0dXJlcyBpbiB0aGUgcGF5bG9hZC5wYXJlbnRzIGZpZWxkIHdpbGwgaGF2ZSBoYXZlIHRob3NlIHBhcmVudHMgbGlmdGVkIGluIHRvIHRoZSBncmFwaFxuXG4qL1xuXG5FQi5NLk1lc3NhZ2VzID0ge31cblxuRUIuTS5NZXNzYWdlcy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgRUIuYWRkUmVsYXRpb25zaGlwSGFuZGxlcihFQi5NLk1lc3NhZ2VzLmFkZEZhbWlsaWFsRWRnZXMpICAgICAgICAgICAgICAvLyBtYW5hZ2VzIHBhcmVudC1jaGlsZCByZWxhdGlvbnNoaXBzXG4gICAgRUIuYWRkUGF5bG9hZE1vZGlmaWVySGFuZGxlcihFQi5NLk1lc3NhZ2VzLmFkZFRpbWVzdGFtcCkgICAgICAgICAgICAgICAvLyBhZGQgdGltZXN0YW1wIHRvIGFsbCBuZXcgcHVmZnNcbn1cblxuXG5FQi5NLk1lc3NhZ2VzLmFkZFRpbWVzdGFtcCA9IGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICBwYXlsb2FkID0gcGF5bG9hZCB8fCB7fVxuICAgIHBheWxvYWQudGltZSA9IHBheWxvYWQudGltZSB8fCBEYXRlLm5vdygpXG4gICAgcmV0dXJuIHBheWxvYWRcbn1cblxuXG5FQi5NLk1lc3NhZ2VzLmFkZEZhbWlsaWFsRWRnZXMgPSBmdW5jdGlvbihzaGVsbHMpIHtcbiAgICBzaGVsbHMuZm9yRWFjaChFQi5NLk1lc3NhZ2VzLmFkZEZhbWlsaWFsRWRnZXNGb3JTaGVsbClcbn1cblxuRUIuTS5NZXNzYWdlcy5hZGRGYW1pbGlhbEVkZ2VzRm9yU2hlbGwgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgIHZhciBhZGRQYXJlbnRFZGdlcyA9IEVCLk0uTWVzc2FnZXMuYWRkRmFtaWxpYWxFZGdlc0ZvclBhcmVudChjaGlsZCk7XG4gICAgKGNoaWxkLnBheWxvYWQucGFyZW50c3x8W10pLmZvckVhY2goYWRkUGFyZW50RWRnZXMpO1xufVxuXG5FQi5NLk1lc3NhZ2VzLmFkZEZhbWlsaWFsRWRnZXNGb3JQYXJlbnQgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgIHZhciBleGlzdGluZ1BhcmVudHMgPSBFQi5EYXRhLmdyYXBoLnYoY2hpbGQuc2lnKS5vdXQoJ3BhcmVudCcpLnByb3BlcnR5KCdzaGVsbCcpLnJ1bigpLm1hcChFQi5wcm9wKCdzaWcnKSlcbiAgICBcbiAgICByZXR1cm4gZnVuY3Rpb24ocGFyZW50U2lnKSB7XG4gICAgICAgIGlmKH5leGlzdGluZ1BhcmVudHMuaW5kZXhPZihwYXJlbnRTaWcpKSByZXR1cm4gZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbmU/XG4gICAgICAgIEVCLkRhdGEuYWRkU2lnQXNWZXJ0ZXgocGFyZW50U2lnKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlkZW1wb3RlbnRcbiAgICAgICAgRUIuRGF0YS5ncmFwaC5hZGRFZGdlKHtfbGFiZWw6ICdwYXJlbnQnLCBfaW46IHBhcmVudFNpZywgX291dDogY2hpbGQuc2lnfSkgLy8gbm90IGlkZW1wb3RlbnRcbiAgICAgICAgRUIuRGF0YS5ncmFwaC5hZGRFZGdlKHtfbGFiZWw6ICdjaGlsZCcsIF9vdXQ6IHBhcmVudFNpZywgIF9pbjogY2hpbGQuc2lnfSlcbiAgICB9XG59XG5cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5cblxuXG5cblxuRUIuTS5NZXNzYWdlcy5mbGFnUHVmZiA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgb3V0IG9mIHRoZSBNZXNzYWdlIG1vZHVsZSBhbmQgcmV3cml0ZSBpdFxuXG4gICAgdmFyIHBheWxvYWQgPSB7fTtcbiAgICB2YXIgcm91dGVzID0gW107XG4gICAgdmFyIHR5cGUgPSAnZmxhZ1B1ZmYnO1xuICAgIHZhciBjb250ZW50ID0gc2lnO1xuICAgIHZhciBwdWZmOyAvLyB2YXJpYWJsZSBmb3IgbGVha2luZyB0aGUgc2lnbmVkIHB1ZmYgb3V0IG9mIHRoZSBzZWN1cmUgem9uZVxuICAgIFxuICAgIHBheWxvYWQudGltZSA9IERhdGUubm93KCk7XG5cbiAgICBFQi51c2VTZWN1cmVJbmZvKGZ1bmN0aW9uKGlkZW50aXRpZXMsIGN1cnJlbnRVc2VybmFtZSwgcHJpdmF0ZVJvb3RLZXksIHByaXZhdGVBZG1pbktleSwgcHJpdmF0ZURlZmF1bHRLZXkpIHsgICAgXG5cbiAgICAgICAgaWYoIWN1cnJlbnRVc2VybmFtZSkge1xuICAgICAgICAgICAgYWxlcnQoXCJZb3UgbXVzdCBmaXJzdCBzZXQgeW91ciB1c2VybmFtZSBiZWZvcmUgeW91IGNhbiBmbGFnIGNvbnRlbnRcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyppZighY3VycmVudFVzZXJuYW1lID09IEVCLmdldFB1ZmZCeVNpZyhzaWcpLnVzZXJuYW1lKSB7XG4gICAgICAgICAgICBhbGVydChcIllvdSBtdXN0IHNldCB5b3VyIGlkZW50aXR5IHRvIHRoZSBhdXRob3Igb2YgdGhlIHB1ZmYgeW91IHdhbnQgdG8gZmxhZ1wiKTtcbiAgICAgICAgfSovXG4gICAgICAgIGlmKCFwcml2YXRlQWRtaW5LZXkpIHtcbiAgICAgICAgICAgIGFsZXJ0KFwiWW91IG11c3QgZmlyc3Qgc2V0IHlvdXIgcHJpdmF0ZSBhZG1pbiBrZXkgYmVmb3JlIHlvdSBjYW4gZmxhZyBjb250ZW50XCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHB1ZmYgPSBFQi5QdWZmLmJ1aWxkKGN1cnJlbnRVc2VybmFtZSwgcHJpdmF0ZUFkbWluS2V5LCByb3V0ZXMsIHR5cGUsIGNvbnRlbnQsIHBheWxvYWQpO1xuICAgIH0pXG5cbiAgICB2YXIgZGF0YSA9IHsgdHlwZTogJ2ZsYWdQdWZmJ1xuICAgICAgICAgICAgICAgLCBwdWZmOiBwdWZmXG4gICAgICAgICAgICAgICB9O1xuXG4gICAgdmFyIHByb20gPSBFQi5OZXQuRUJwb3N0KEVCLkNPTkZJRy5wdWZmQXBpLCBkYXRhKTtcbiAgICBcbiAgICBwcm9tID0gcHJvbS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAgIC8vIHZhciBzdG9yZWRTaGVsbHMgPSBFQi5QZXJzaXN0LmdldCgnc2hlbGxzJyk7XG4gICAgICAgIC8vIHZhciBmaWx0ZXJlZFNoZWxscyA9IHN0b3JlZFNoZWxscy5maWx0ZXIoZnVuY3Rpb24ocyl7cmV0dXJuIHMuc2lnICE9IGNvbnRlbnQgJiYgcy5jb250ZW50ICE9IGNvbnRlbnR9KTtcbiAgICAgICAgdmFyIGZsYWdnZWRTaWcgPSBFQi5QZXJzaXN0LmdldCgnZmxhZ2dlZCcpIHx8IFtdO1xuICAgICAgICBmbGFnZ2VkU2lnLnB1c2goY29udGVudCk7XG5cbiAgICAgICAgLy8gRUIuUGVyc2lzdC5zYXZlKCdzaGVsbHMnLCBmaWx0ZXJlZFNoZWxscyk7XG4gICAgICAgIEVCLlBlcnNpc3Quc2F2ZSgnZmxhZ2dlZCcsIGZsYWdnZWRTaWcpO1xuICAgICAgICAvLyByZWxvYWQ/XG4gICAgICAgIC8vIGRvY3VtZW50LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICBFdmVudHMucHViKCd1aS9mbGFnJywge30pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pXG4gICAgcmV0dXJuIHByb207XG59XG5cbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcblxuLy8gREVUUklUVVMgVE8gQkUgREVBTFQgV0lUSFxuICAgIFxuICAgXG4vLyAvKipcbi8vICAqIEZpbHRlciBwdWZmcyBhY2NvcmRpbmcgdG8gY3JpdGVyaWFcbi8vICAqIEBwYXJhbSAge3N0cmluZ30gcXVlcnlcbi8vICAqIEBwYXJhbSAge3N0cmluZ30gZmlsdGVyc1xuLy8gICogQHBhcmFtICB7bnVtYmVyfSBsaW1pdFxuLy8gICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIHB1ZmZzXG4vLyAgKi9cbi8vIEVCLk0uRm9ydW0uZ2V0UHVmZkxpc3QgPSBmdW5jdGlvbihxdWVyeSwgZmlsdGVycywgbGltaXQpIHtcbi8vICAgICAvLy8vIHJldHVybnMgYSBsaXN0IG9mIHB1ZmZzXG4vL1xuLy8gICAgIC8vIFRISU5LOiB0aGUgZ3JhcGggY2FuIGhlbHAgdXMgaGVyZSwgYnV0IG9ubHkgaWYgd2UncmUgbW9yZSBjbGV2ZXIgYWJvdXQgZm9ybWluZyByZWxhdGlvbnNoaXBzIGFuZCB1c2luZyB0aG9zZSBpbiBvdXIgZmlsdGVycy5cbi8vXG4vLyAgICAgbGltaXQgPSBsaW1pdCB8fCBJbmZpbml0eVxuLy8gICAgIHZhciBvZmZzZXQgPSArcXVlcnkub2Zmc2V0fHwwXG4vL1xuLy8gICAgIC8vIHZhciBzaGVsbHMgPSBFQi5NLkZvcnVtLmdldFNoZWxscyhxdWVyeSwgZmlsdGVycylcbi8vICAgICB2YXIgc2hlbGxzID0gRUIuRGF0YS5nZXRBbGxNeVNoZWxscygpXG4vL1xuLy8gICAgIHZhciBmaWx0ZXJlZF9zaGVsbHMgPSBzaGVsbHMuZmlsdGVyKEVCLk0uRm9ydW0uZmlsdGVyQnlGaWx0ZXJzKEJvcm9uLmV4dGVuZCh7fSwgcXVlcnksIGZpbHRlcnMpKSlcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoRUIuTS5Gb3J1bS5zb3J0QnlQYXlsb2FkKSAvLyBUT0RPOiBzb3J0IGJ5IHF1ZXJ5XG4vL1xuLy8gICAgIHZhciBzbGljZWRfc2hlbGxzID0gZmlsdGVyZWRfc2hlbGxzLnNsaWNlKG9mZnNldCwgb2Zmc2V0K2xpbWl0KVxuLy9cbi8vICAgICB2YXIgcHVmZnMgPSBzbGljZWRfc2hlbGxzLm1hcChFQi5EYXRhLmdldFB1ZmZGcm9tU2hlbGwpXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbi8vXG4vLyAgICAgdmFyIGhhdmUgPSBzbGljZWRfc2hlbGxzLmxlbmd0aFxuLy8gICAgIC8vIHZhciBoYXZlID0gcHVmZnMubGVuZ3RoXG4vLyAgICAgaWYoaGF2ZSA+PSBsaW1pdClcbi8vICAgICAgICAgcmV0dXJuIHB1ZmZzICAvLyBhcyBsb25nIGFzIHdlIGhhdmUgZW5vdWdoIGZpbHRlcmVkIHNoZWxscyB0aGUgcHVmZnMgd2lsbCBldmVudHVhbGx5IGZpbGwgaW4gZW1wdHkgc3BvdHNcbi8vXG4vLyAgICAgRUIuRGF0YS5maWxsU29tZVNsb3RzUGxlYXNlKGxpbWl0LCBoYXZlLCBxdWVyeSwgZmlsdGVycylcbi8vXG4vLyAgICAgcmV0dXJuIHB1ZmZzO1xuLy8gfVxuLy9cblxuLy8gLyoqXG4vLyAgKiBGaWx0ZXIgcHVmZnMgYnkgcHJvcCBmaWx0ZXJzXG4vLyAgKiBAcGFyYW0gIHtzdHJpbmd9IGZpbHRlcnNcbi8vICAqIEByZXR1cm4ge2Jvb2xlYW59XG4vLyAgKi9cbi8vIEVCLk0uRm9ydW0uZmlsdGVyQnlGaWx0ZXJzID0gZnVuY3Rpb24oZmlsdGVycykge1xuLy9cbi8vICAgICBpZighZmlsdGVycykgcmV0dXJuIGZ1bmN0aW9uKCkge3JldHVybiB0cnVlfVxuLy9cbi8vICAgICAvLy8vIGdldCBhIGZpbHRlcmluZyBmdW5jdGlvblxuLy8gICAgIHJldHVybiBmdW5jdGlvbihzaGVsbCkge1xuLy9cbi8vICAgICAgICAgLy8gUk9VVEVTXG4vLyAgICAgICAgIGlmIChmaWx0ZXJzLnJvdXRlcyAmJiBmaWx0ZXJzLnJvdXRlcy5sZW5ndGggPiAwKSB7XG4vLyAgICAgICAgICAgICB2YXIgcm91dGVNYXRjaCA9IGZhbHNlO1xuLy8gICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJzLnJvdXRlcy5sZW5ndGg7IGkrKykge1xuLy8gICAgICAgICAgICAgICAgIGlmIChzaGVsbC5yb3V0ZXMuaW5kZXhPZihmaWx0ZXJzLnJvdXRlc1tpXSkgPiAtMSkgcm91dGVNYXRjaCA9IHRydWU7XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICBpZiAoIXJvdXRlTWF0Y2gpIHJldHVybiBmYWxzZTtcbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgLy8gVEFHU1xuLy8gICAgICAgICBpZiAoZmlsdGVycy50YWdzICYmIGZpbHRlcnMudGFncy5sZW5ndGggPiAwKSB7XG4vLyAgICAgICAgICAgICBpZiAoIXNoZWxsLnBheWxvYWQudGFncyB8fCAhc2hlbGwucGF5bG9hZC50YWdzLmxlbmd0aCkge1xuLy8gICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIHZhciB0YWdNYXRjaCA9IGZhbHNlO1xuLy8gICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJzLnRhZ3MubGVuZ3RoOyBpKyspIHtcbi8vICAgICAgICAgICAgICAgICBpZiAoc2hlbGwucGF5bG9hZC50YWdzLmluZGV4T2YoZmlsdGVycy50YWdzW2ldKSA+IC0xKSB0YWdNYXRjaCA9IHRydWU7XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICBpZiAoIXRhZ01hdGNoKSByZXR1cm4gZmFsc2U7XG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIC8vIFRZUEVTXG4vLyAgICAgICAgIGlmIChmaWx0ZXJzLnR5cGVzICYmIGZpbHRlcnMudHlwZXMubGVuZ3RoID4gMCkge1xuLy8gICAgICAgICAgICAgaWYgKCF+ZmlsdGVycy50eXBlcy5pbmRleE9mKHNoZWxsLnBheWxvYWQudHlwZSkpIHtcbi8vICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhzaGVsbC50eXBlKVxuLy8gICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICAvLyBVU0VSU1xuLy8gICAgICAgICBpZihmaWx0ZXJzLnVzZXJzICYmIGZpbHRlcnMudXNlcnMubGVuZ3RoID4gMClcbi8vICAgICAgICAgICAgIGlmKCF+ZmlsdGVycy51c2Vycy5pbmRleE9mKEVCLlVzZXJzLmp1c3RVc2VybmFtZShzaGVsbC51c2VybmFtZSkpKSByZXR1cm4gZmFsc2Vcbi8vXG4vL1xuLy8gICAgICAgICBpZihmaWx0ZXJzLnJvb3RzKVxuLy8gICAgICAgICAgICAgaWYoKHNoZWxsLnBheWxvYWQucGFyZW50c3x8W10pLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG4vL1xuLy8gICAgICAgICBpZihmaWx0ZXJzLmFuY2VzdG9ycyAmJiBmaWx0ZXJzLmZvY3VzKSB7XG4vLyAgICAgICAgICAgICB2YXIgZm9jdXMgPSBFQi5nZXRQdWZmQnlTaWcoZmlsdGVycy5mb2N1cykgLy8gVE9ETzogZmluZCBiZXR0ZXIgd2F5IHRvIGRvIHRoaXNcbi8vICAgICAgICAgICAgIGlmKGZvY3VzLnBheWxvYWQgJiYgIX5mb2N1cy5wYXlsb2FkLnBhcmVudHMuaW5kZXhPZihzaGVsbC5zaWcpKSByZXR1cm4gZmFsc2Vcbi8vICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgaWYoZmlsdGVycy5kZXNjZW5kYW50cyAmJiBmaWx0ZXJzLmZvY3VzKVxuLy8gICAgICAgICAgICAgaWYoIX5zaGVsbC5wYXlsb2FkLnBhcmVudHMuaW5kZXhPZihmaWx0ZXJzLmZvY3VzKSkgcmV0dXJuIGZhbHNlXG4vL1xuLy8gICAgICAgICAvLyBUT0RPOiBkZXByZWNhdGUgdGhpcywgYXMgaXQncyBoYW5kbGVkIGFib3ZlOlxuLy8gICAgICAgICBpZiAoZmlsdGVycy50eXBlICYmIGZpbHRlcnMudHlwZS5sZW5ndGgpXG4vLyAgICAgICAgICAgICBpZiAoIX5maWx0ZXJzLnR5cGUuaW5kZXhPZihzaGVsbC5wYXlsb2FkLnR5cGUpKSByZXR1cm4gZmFsc2Vcbi8vXG4vLyAgICAgICAgIHJldHVybiB0cnVlXG4vLyAgICAgfVxuLy8gfVxuXG5cbi8vIC8qKlxuLy8gICogSGVscGVyIGZvciBzb3J0aW5nIGJ5IHBheWxvYWQudGltZVxuLy8gICogQHBhcmFtICB7T2JqZWN0fSBhXG4vLyAgKiBAcGFyYW0gIHtvYmplY3R9IGJcbi8vICAqIEByZXR1cm4ge251bWJlcn0gYmFzZWQgb24gZGVzaXJlZCBzb3J0aW5nIG9yZGVyXG4vLyAgKi9cbi8vIEVCLk0uRm9ydW0uc29ydEJ5UGF5bG9hZCA9IGZ1bmN0aW9uKGEsYikge1xuLy8gICAgIC8vLy8gaGVscGVyIGZvciBzb3J0aW5nIGJ5IHBheWxvYWQudGltZVxuLy8gICAgIGlmKHB1ZmZ3b3JsZHByb3BzLnZpZXcucXVlcnkuc29ydCA9PSAnREVTQycpXG4vLyAgICAgICAgIHJldHVybiBiLnBheWxvYWQudGltZSAtIGEucGF5bG9hZC50aW1lO1xuLy8gICAgIGVsc2Vcbi8vICAgICAgICAgcmV0dXJuIGEucGF5bG9hZC50aW1lIC0gYi5wYXlsb2FkLnRpbWU7XG4vLyB9XG5cblxuXG4vLyAvKipcbi8vICAqIEdldCB0aGUgY3VycmVudCBwdWZmJ3MgcGFyZW50c1xuLy8gICogQHBhcmFtICB7T2JqZWN0fSBwdWZmXG4vLyAgKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzXG4vLyAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgcGFyZW50c1xuLy8gICovXG4vLyBFQi5NLkZvcnVtLmdldFBhcmVudENvdW50ID0gZnVuY3Rpb24ocHVmZiwgcHJvcHMpIHtcbi8vICAgICBpZighcHVmZikgcmV0dXJuIDBcbi8vXG4vLyAgICAgdmFyIHNpZyA9IHB1ZmYuc2lnIHx8IHB1ZmZcbi8vXG4vLyAgICAgcmV0dXJuIEVCLkRhdGEuZ3JhcGgudihzaWcpLm91dCgncGFyZW50JykucnVuKCkubGVuZ3RoXG4vLyB9XG5cblxuLy8gLyoqXG4vLyAgKiBHZXQgYSBjb3VudCBvZiB0aGUgY3VycmVudCBwdWZmJ3MgY2hpbGRyZW5cbi8vICAqIEBwYXJhbSAge09iamVjdH0gcHVmZlxuLy8gICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuXG4vLyAgKi9cbi8vIEVCLk0uRm9ydW0uZ2V0Q2hpbGRDb3VudCA9IGZ1bmN0aW9uKHB1ZmYpIHtcbi8vICAgICBpZighcHVmZikgcmV0dXJuIDBcbi8vXG4vLyAgICAgdmFyIHNpZyA9IHB1ZmYuc2lnIHx8IHB1ZmZcbi8vXG4vLyAgICAgcmV0dXJuIEVCLkRhdGEuZ3JhcGgudihzaWcpLm91dCgnY2hpbGQnKS5ydW4oKS5sZW5ndGhcbi8vIH1cblxuXG4vLyAvLyBBZGRpbmcgZGVmYXVsdCBtZXRhZmllbGRzIHRvIGluY2x1ZGVkIGluIGEgcHVmZlxuLy8gRUIuTS5Gb3J1bS5tZXRhRmllbGRzID0gW11cbi8vIEVCLk0uRm9ydW0uY29udGV4dCA9IHt9O1xuLy8gRUIuTS5Gb3J1bS5hZGRNZXRhRmllbGRzID0gZnVuY3Rpb24oZmllbGRJbmZvLCBjb250ZXh0LCBleGNsdWRlQ29udGV4dCkge1xuLy8gICAgIC8vIE5PVEU6IHRoaXMgaXNuJ3QgdXNlZCBvdXRzaWRlIG9mIHB1Ymxpc2hFbWJlZC5qcywgYnV0IGl0IG1pZ2h0IHByb3ZpZGUgYSBnb29kIGJhc2lzIGZvciBnZW5lcmljL3JlcXVpcmVkIG1ldGFkYXRhXG4vL1xuLy8gICAgIGlmICghZmllbGRJbmZvLm5hbWUpIHJldHVybiBjb25zb2xlLmxvZygnSW52YWxpZCBtZXRhIGZpZWxkIG5hbWUuJyk7XG4vL1xuLy8gICAgIC8vIHN1cHBvcnRlZCB0eXBlOiB0ZXh0LCB0ZXh0YXJlYSwgcHVsbGRvd24sIGFycmF5XG4vLyAgICAgaWYgKCFmaWVsZEluZm8udHlwZSkgcmV0dXJuIGNvbnNvbGUubG9nKCdJbnZhbGlkIG1ldGEgZmllbGQgdHlwZS4nKTtcbi8vXG4vLyAgICAgaWYgKCFmaWVsZEluZm8udmFsaWRhdG9yIHx8IHR5cGVvZiBmaWVsZEluZm8udmFsaWRhdG9yICE9ICdmdW5jdGlvbicpIHtcbi8vICAgICAgICAgZmllbGRJbmZvLnZhbGlkYXRvciA9IGZhbHNlO1xuLy8gICAgIH1cbi8vXG4vLyAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgT2JqZWN0LmtleXMoRUIuRGF0YS5jb250ZW50VHlwZXMpO1xuLy8gICAgIGlmICh0eXBlb2YgY29udGV4dCA9PSAnc3RyaW5nJykge1xuLy8gICAgICAgICBjb250ZXh0ID0gW2NvbnRleHRdO1xuLy8gICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoY29udGV4dCkpIHtcbi8vICAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ0ludmFsaWQgY29udGV4dC4nKVxuLy8gICAgIH1cbi8vXG4vLyAgICAgZXhjbHVkZUNvbnRleHQgPSBleGNsdWRlQ29udGV4dCB8fCBbXTtcbi8vICAgICBpZiAodHlwZW9mIGV4Y2x1ZGVDb250ZXh0ID09ICdzdHJpbmcnKSB7XG4vLyAgICAgICAgIGV4Y2x1ZGVDb250ZXh0ID0gW2V4Y2x1ZGVDb250ZXh0XTtcbi8vICAgICB9ZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZXhjbHVkZUNvbnRleHQpKSB7XG4vLyAgICAgICAgIHJldHVybiBFQi5vbkVycm9yKCdJbnZhbGlkIGNvbnRleHQuJylcbi8vICAgICB9XG4vL1xuLy8gICAgIEVCLk0uRm9ydW0ubWV0YUZpZWxkcy5wdXNoKGZpZWxkSW5mbyk7XG4vLyAgICAgZm9yICh2YXIgaT0wOyBpPGNvbnRleHQubGVuZ3RoOyBpKyspIHtcbi8vICAgICAgICAgaWYgKGV4Y2x1ZGVDb250ZXh0LmluZGV4T2YoY29udGV4dFtpXSkgIT0gLTEpXG4vLyAgICAgICAgICAgICBjb250aW51ZTtcbi8vICAgICAgICAgdmFyIGNvbnRleHRGaWVsZHMgPSBFQi5NLkZvcnVtLmNvbnRleHRbY29udGV4dFtpXV0gfHwgW107XG4vLyAgICAgICAgIGNvbnRleHRGaWVsZHMucHVzaChmaWVsZEluZm8ubmFtZSk7XG4vLyAgICAgICAgIEVCLk0uRm9ydW0uY29udGV4dFtjb250ZXh0W2ldXSA9IGNvbnRleHRGaWVsZHM7XG4vLyAgICAgfVxuLy8gfVxuLy9cbi8vIEVCLk0uRm9ydW0uYWRkTWV0YUZpZWxkcyhcbi8vICAgICB7bmFtZTogJ3JlcGx5IHByaXZhY3knLFxuLy8gICAgICB0eXBlOiAncHVsbGRvd24nLFxuLy8gICAgICBlbnVtOiBbJycsICdwdWJsaWMnLCAncHJpdmF0ZScsICdhbm9ueW1vdXMnLCAnaW52aXNpYmxlJ10sXG4vLyAgICAgIGRlZmF1bHRWYWx1ZTogJyd9KTtcbi8vXG4vLyBFQi5NLkZvcnVtLmFkZE1ldGFGaWVsZHMoXG4vLyAgICAge25hbWU6ICdjb250ZW50IGxpY2Vuc2UnLFxuLy8gICAgICB0eXBlOiAncHVsbGRvd24nLFxuLy8gICAgICBlbnVtOiBbJycsICdDcmVhdGl2ZUNvbW1vbnNBdHRyaWJ1dGlvbicsICdHTlVQdWJsaWNMaWNlbnNlJywgJ1B1YmxpY2RvbWFpbicsICdSaWdodHMtbWFuYWdlZCcsICdSb3lhbHR5LWZyZWUnXSxcbi8vICAgICAgZGVmYXVsdFZhbHVlOiAnJ30pO1xuLy9cbi8vIEVCLk0uRm9ydW0uYWRkTWV0YUZpZWxkcyhcbi8vICAgICB7bmFtZTogJ3RhZ3MnLFxuLy8gICAgICB0eXBlOiAnYXJyYXknLFxuLy8gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uKHYpe3JldHVybiAvXlthLXowLTldKyQvaS50ZXN0KHYpfVxuLy8gICAgICB9LFxuLy8gICAgIGZhbHNlLCAncHJvZmlsZScpO1xuLy9cbi8vIEVCLk0uRm9ydW0uYWRkTWV0YUZpZWxkcyhcbi8vICAgICB7bmFtZTogJ2xhbmd1YWdlJyxcbi8vICAgICAgdHlwZTogJ3RleHQnLFxuLy8gICAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uKCl7cmV0dXJuIHB1ZmZ3b3JsZHByb3BzLnZpZXcubGFuZ3VhZ2V9fSk7XG4vL1xuLy8gRUIuTS5Gb3J1bS5hZGRNZXRhRmllbGRzKFxuLy8gICAgIHtuYW1lOiAnbmFtZScsXG4vLyAgICAgIHR5cGU6ICd0ZXh0J30sXG4vLyAgICAgJ3Byb2ZpbGUnKTtcblxuXG4vLyAvKipcbi8vICAqIFRha2VzIGEgc3RyaW5nIG9mIGNvbnRlbnQsIGNyZWF0ZSBhIHB1ZmYgYW5kIHB1c2ggaXQgaW50byB0aGUgc3lzdGVtXG4vLyAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuLy8gICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbi8vICAqIEBwYXJhbSB7YXJyYXl9IHBhcmVudHNcbi8vICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhZGF0YVxuLy8gICogQHBhcmFtIHtzdHJpbmdbXX0gdXNlclJlY29yZHNGb3JXaG9tVG9FbmNyeXB0XG4vLyAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwcml2YXRlRW52ZWxvcGVBbGlhc1xuLy8gICogQHJldHVybnMge3Byb21pc2V9XG4vLyAgKi9cbi8vIEVCLk0uRm9ydW0uYWRkUG9zdCA9IGZ1bmN0aW9uKHR5cGUsIGNvbnRlbnQsIHBhcmVudHMsIG1ldGFkYXRhLCB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHQsIHByaXZhdGVFbnZlbG9wZUFsaWFzKSB7XG4vLyAgICAgLy8vLyBHaXZlbiBhIHN0cmluZyBvZiBjb250ZW50LCBjcmVhdGUgYSBwdWZmIGFuZCBwdXNoIGl0IGludG8gdGhlIHN5c3RlbVxuLy9cbi8vICAgICAvLyBlbnN1cmUgcGFyZW50cyBpcyBhbiBhcnJheVxuLy8gICAgIGlmKCFwYXJlbnRzKSBwYXJlbnRzID0gW11cbi8vICAgICBpZighQXJyYXkuaXNBcnJheShwYXJlbnRzKSkgcGFyZW50cyA9IFtwYXJlbnRzXVxuLy9cbi8vICAgICAvLyBlbnN1cmUgcGFyZW50cyBjb250YWlucyBvbmx5IHB1ZmYgaWRzXG4vLyAgICAgaWYocGFyZW50cy5tYXAoRUIuZ2V0UHVmZkJ5U2lnKS5maWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4geCAhPSBudWxsIH0pLmxlbmd0aCAhPSBwYXJlbnRzLmxlbmd0aClcbi8vICAgICAgICAgcmV0dXJuIEVCLmVtcHR5UHJvbWlzZSgnVGhvc2UgYXJlIG5vdCBnb29kIHBhcmVudHMnKVxuLy9cbi8vICAgICAvLyBlbnN1cmUgcGFyZW50cyBhcmUgdW5pcXVlXG4vLyAgICAgcGFyZW50cyA9IEVCLnVuaXF1aWZ5KHBhcmVudHMpXG4vL1xuLy8gICAgIC8vIGZpbmQgdGhlIHJvdXRlcyB1c2luZyBwYXJlbnRzXG4vLyAgICAgdmFyIHJvdXRlcyA9IHBhcmVudHMubWFwKGZ1bmN0aW9uKGlkKSB7XG4vLyAgICAgICAgIHJldHVybiBFQi5nZXRQdWZmQnlTaWcoaWQpLnVzZXJuYW1lXG4vLyAgICAgfSk7XG4vLyAgICAgaWYgKG1ldGFkYXRhLnJvdXRlcykge1xuLy8gICAgICAgICByb3V0ZXMgPSBtZXRhZGF0YS5yb3V0ZXMgLy8gVEhJTks6IHRoaXMgc2hvdWxkIHByb2JhYmx5IG1lcmdlIHdpdGggYWJvdmUgaW5zdGVhZCBvZiByZXBsYWNpbmcgaXQuLi5cbi8vICAgICAgICAgZGVsZXRlIG1ldGFkYXRhWydyb3V0ZXMnXVxuLy8gICAgIH1cbi8vXG4vLyAgICAgLy8gZW5zdXJlIGFsbCByb3V0ZXMgYXJlIHVuaXF1ZVxuLy8gICAgIHJvdXRlcyA9IEVCLnVuaXF1aWZ5KHJvdXRlcylcbi8vXG4vLyAgICAgdmFyIHRha2VVc2VyTWFrZVB1ZmYgPSBFQi5NLkZvcnVtLnBhcnRpYWxseUFwcGx5UHVmZk1ha2VyKHR5cGUsIGNvbnRlbnQsIHBhcmVudHMsIG1ldGFkYXRhLCByb3V0ZXMsIHVzZXJSZWNvcmRzRm9yV2hvbVRvRW5jcnlwdCwgcHJpdmF0ZUVudmVsb3BlQWxpYXMpXG4vL1xuLy8gICAgIC8vIGdldCBhIHVzZXIgcHJvbWlzZVxuLy8gICAgIHZhciB1c2VycHJvbSA9IEVCLlVzZXJzLmdldFVwVG9EYXRlVXNlckF0QW55Q29zdCgpXG4vL1xuLy8gICAgIHZhciBwcm9tID0gdXNlcnByb20uY2F0Y2goRUIuY2F0Y2hFcnJvcignRmFpbGVkIHRvIGFkZCBwb3N0OiBjb3VsZCBub3QgYWNjZXNzIG9yIGNyZWF0ZSBhIHZhbGlkIHVzZXInKSlcbi8vICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4odGFrZVVzZXJNYWtlUHVmZilcbi8vICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKEVCLmNhdGNoRXJyb3IoJ1Bvc3RpbmcgZmFpbGVkJykpXG4vL1xuLy8gICAgIHJldHVybiBwcm9tXG4vL1xuLy8gICAgIC8vIE5PVEU6IGFueSBwdWZmIHRoYXQgaGFzICd0aW1lJyBhbmQgJ3BhcmVudHMnIGZpZWxkcyBmdWxmaWxscyB0aGUgZm9ydW0gaW50ZXJmYWNlXG4vLyAgICAgLy8gVE9ETzogbWFrZSBhbiBvZmZpY2lhbCBpbnRlcmZhY2UgZnVsZmlsbG1lbnQgdGhpbmdcbi8vIH1cbi8vXG4vL1xuLy8gLyoqXG4vLyAgKiBNYWtlIGEgcHVmZi4uLiBleGNlcHQgdGhlIHBhcnRzIHRoYXQgcmVxdWlyZSBhIHVzZXJcbi8vICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4vLyAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuLy8gICogQHBhcmFtIHthcnJheX0gcGFyZW50c1xuLy8gICogQHBhcmFtIHtvYmplY3R9IG1ldGFkYXRhXG4vLyAgKiBAcGFyYW0ge2FycmF5fSByb3V0ZXNcbi8vICAqIEBwYXJhbSB7YXJyYXl9IHVzZXJSZWNvcmRzRm9yV2hvbVRvRW5jcnlwdFxuLy8gICogQHBhcmFtIHthcnJheX0gcHJpdmF0ZUVudmVsb3BlQWxpYXNcbi8vICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbi8vICAqL1xuLy8gRUIuTS5Gb3J1bS5wYXJ0aWFsbHlBcHBseVB1ZmZNYWtlciA9IGZ1bmN0aW9uKHR5cGUsIGNvbnRlbnQsIHBhcmVudHMsIG1ldGFkYXRhLCByb3V0ZXMsIHVzZXJSZWNvcmRzRm9yV2hvbVRvRW5jcnlwdCwgcHJpdmF0ZUVudmVsb3BlQWxpYXMpIHtcbi8vICAgICAvLy8vIE1ha2UgYSBwdWZmLi4uIGV4Y2VwdCB0aGUgcGFydHMgdGhhdCByZXF1aXJlIGEgdXNlclxuLy9cbi8vICAgICAvLyBUSElOSzogaWYgeW91IHVzZSB0aGUgc2FtZSBtZXRhZGF0YSBvYmplY3QgZm9yIG11bHRpcGxlIHB1ZmZzIHlvdXIgY2FjaGVkIHZlcnNpb24gb2YgdGhlIG9sZGVyIHB1ZmZzIHdpbGwgZ2V0IG1lc3NlZCB1cFxuLy9cbi8vICAgICB2YXIgcGF5bG9hZCA9IG1ldGFkYXRhIHx8IHt9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ldGFkYXRhIGJlY29tZXMgdGhlIGJhc2lzIG9mIHBheWxvYWRcbi8vICAgICBwYXlsb2FkLnBhcmVudHMgPSBwYXlsb2FkLnBhcmVudHMgfHwgcGFyZW50cyAgICAgICAgICAgIC8vIGlkcyBvZiB0aGUgcGFyZW50IHB1ZmZzXG4vLyAgICAgcGF5bG9hZC50aW1lID0gbWV0YWRhdGEudGltZSB8fCBEYXRlLm5vdygpICAgICAgICAgICAgICAvLyB0aW1lIGlzIGFsd2F5cyBhIHVuaXggdGltZXN0YW1wXG4vLyAgICAgcGF5bG9hZC50YWdzID0gbWV0YWRhdGEudGFncyB8fCBbXSAgICAgICAgICAgICAgICAgICAgICAvLyBhbiBhcnJheSBvZiB0YWdzIC8vIFRPRE86IG1ha2UgdGhlc2Ugd29ya1xuLy9cbi8vICAgICB2YXIgdHlwZSAgPSB0eXBlIHx8ICd0ZXh0J1xuLy8gICAgIHZhciByb3V0ZXMgPSByb3V0ZXMgPyByb3V0ZXMgOiBbXTtcbi8vICAgICByb3V0ZXMgPSByb3V0ZXMuY29uY2F0KEVCLkNPTkZJRy56b25lKTtcbi8vXG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uKHVzZXJSZWNvcmQpIHtcbi8vICAgICAgICAgLy8gdXNlclJlY29yZCBpcyBhbHdheXMgYW4gdXAtdG8tZGF0ZSByZWNvcmQgZnJvbSB0aGUgREhULCBzbyB3ZSBjYW4gdXNlIGl0cyAnbGF0ZXN0JyB2YWx1ZSBoZXJlXG4vL1xuLy8gICAgICAgICB2YXIgcHJldmlvdXMgPSB1c2VyUmVjb3JkLmxhdGVzdFxuLy8gICAgICAgICB2YXIgcHVmZiA9IEVCLlB1ZmYuc2ltcGxlQnVpbGQodHlwZSwgY29udGVudCwgcGF5bG9hZCwgcm91dGVzLCB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHQsIHByaXZhdGVFbnZlbG9wZUFsaWFzKVxuLy9cbi8vICAgICAgICAgcmV0dXJuIEVCLkRhdGEuYWRkUHVmZlRvU3lzdGVtKHB1ZmYpIC8vIFRISU5LOiB0aGlzIGZhaWxzIHNpbGVudGx5IGlmIHRoZSBzaWcgZXhpc3RzIGFscmVhZHlcbi8vICAgICB9XG4vLyB9XG4iLCIvKiBcbiAgICAgICAgICAgICAgICAgICBfX19fXyAgX19fX18gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX18gICAgICAgICAgICBfX18uICAgICAgICAgICBcbiAgICBfX19fX18gIF9fIF9fXy8gX19fX1xcLyBfX19fXFxfICBfICBfX19fX19fIF9fX19fX18gIF9ffCBfL19fX19fXyAgX19fX1xcXyB8X18gICBfX19fICBcbiAgICBcXF9fX18gXFx8ICB8ICBcXCAgIF9fXFxcXCAgIF9fXFxcXCBcXC8gXFwvIC9cXF9fICBcXFxcXyAgX18gXFwvIF9fIHxcXF8gIF9fIFxcLyAgXyBcXHwgX18gXFxfLyBfXyBcXCBcbiAgICB8ICB8Xz4gPiAgfCAgL3wgIHwgICB8ICB8ICAgXFwgICAgIC8gIC8gX18gXFx8ICB8IFxcLyAvXy8gfCB8ICB8IFxcKCAgPF8+ICkgXFxfXFwgXFwgIF9fXy8gXG4gICAgfCAgIF9fL3xfX19fLyB8X198ICAgfF9ffCAgICBcXC9cXF8vICAoX19fXyAgL19ffCAgXFxfX19fIHwgfF9ffCAgIFxcX19fXy98X19fICAvXFxfX18gID5cbiAgICB8X198ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcLyAgICAgICAgICAgXFwvICAgICAgICAgICAgICAgICAgXFwvICAgICBcXC8gXG4gIFxuICBBbiBFdmVyeUJpdCBtb2R1bGUgZm9yIG1hbmFnaW5nIGlkZW50aXRpZXMgYW5kIHByaXZhdGUgZGF0YSBsb2NhbGx5LlxuICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIFRoZSBXYXJkcm9iZSBtYW5hZ2VzIGlkZW50aXRpZXMsIGFsaWFzZXMsIGFuZCBwcml2YXRlIGRhdGEuXG5cbiAgQW4gaWRlbnRpdHkgaXMgYSB1c2VybmFtZSBhbmQgYSBsaXN0IG9mIGFsbCBrbm93biBhbGlhc2VzLiBUaGUgaWRlbnRpdHkgYWxzbyBsaXN0cyB0aGUgbGFzdCBrbm93biBwcmltYXJ5IGFsaWFzLCBpZiB0aGVyZSBpcyBvbmUsIGFuZCB0aGUgaWRlbnRpdHkncyBwcml2YXRlIHByZWZlcmVuY2VzLiBcblxuICBBbiBhbGlhcyBpcyBhIHVzZXJuYW1lLCBhICdjYXBhJywgYW5kIGEgc2V0IG9mIHByaXZhdGUga2V5cy4gQWRkaXRpb25hbCBwcml2YXRlIGluZm9ybWF0aW9uIChsaWtlIGEgcGFzc3BocmFzZSkgbWF5IGJlIHN0b3JlZCBpbiB0aGUgYWxpYXMncyAnc2VjcmV0cycgZmllbGQuXG5cbiAgQWxpYXNlcyBnZW5lcmFsbHkgY29ycmVzcG9uZCBlaXRoZXIgdG8gcHJldmlvdXMgdmVyc2lvbnMgb2YgdGhlIGlkZW50aXR5J3MgdXNlcm5hbWUgKHByZXZpb3VzIHByaW1hcmllcyksIG9yIHRvIGFub255bW91cyB1c2VybmFtZXMgY3JlYXRlZCBmb3Igb25lLXRpbWUgZW5jcnlwdGVkIHRyYW5zZmVyLiBcblxuICBVc2VybmFtZSBhbmQgY2FwYSBkZWZpbmUgYSB1bmlxdWUgYWxpYXMuIFRoZSBjYXBhIGZpZWxkIHJlZmVyZW5jZXMgYSBzcGVjaWZpYyBtb21lbnQgaW4gdGhlIHVzZXJuYW1lJ3MgbGlmZWN5Y2xlLCBhbmQgY29ycmVsYXRlcyB0byB0aGUgdXNlclJlY29yZCB3aXRoIHRoZSBzYW1lIHVzZXJuYW1lIGFuZCBjYXBhIHdob3NlIHB1YmxpYyBrZXlzIG1hdGNoIHRoZSBhbGlhcydzIHByaXZhdGUga2V5cy4gSW4gb3RoZXIgd29yZHMsIGNhcGEgPT0gdmVyc2lvbi5cblxuICBDdXJyZW50bHkgY2FwYSBjb3VudHMgYnkgY29uc2VjdXRpdmUgaW50ZWdlcnMuIFRoaXMgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlLiBBbnkgc2V0IGRlcml2aW5nIEVxIGFuZCBPcmQgd2lsbCB3b3JrLlxuXG4gIEFuIGlkZW50aXR5IGZpbGUgY2FuIGJlIGV4cG9ydGVkIHRvIHRoZSBsb2NhbCBmaWxlc3lzdGVtIGFuZCBpbXBvcnRlZCBiYWNrIGluIHRvIHRoZSBzeXN0ZW0uXG5cbiAgUHJpdmF0ZSBkYXRhIGlzIGEgYmxhY2sgYm94IGZvciBcblxuICBVc2FnZSBleGFtcGxlczpcbiAgICAgIEVCLnN3aXRjaElkZW50aXR5VG8odXNlcm5hbWUpXG5cbiovXG5cbi8qXG4gIFRISU5LOlxuICAgIC0gcmVnaXN0ZXIgY2FsbGJhY2sgaGFuZGxlcnMgZm9yIHVzZXIgcmVjb3JkIGNyZWF0aW9uIGFuZCBtb2RpZmljYXRpb25cbiAgICAtIEVCLk0uV2FyZHJvYmUuaW5pdCByZWdpc3RlcnMgdGhvc2Ugd2l0aCBFQi5vblVzZXJDcmVhdGlvbiBhbmQgRUIub25Vc2VyTW9kaWZpY2F0aW9uXG4gICAgLSBpZGVudGl0eSBmaWxlIGVuY3J5cHRpb24gdXNpbmcgYSBwYXNzcGhyYXNlXG4qL1xuXG5cbkVCLk0uV2FyZHJvYmUgPSB7fVxuXG5+ZnVuY3Rpb24oKSB7IC8vIGJlZ2luIHRoZSBjbG9zdXJlXG5cbiAgICB2YXIgaWRlbnRpdGllcyA9IHt9XG4gICAgdmFyIGFsaWFzZXMgPSB7fVxuICAgIC8vIHthc2RmOiB7IHVzZXJuYW1lOiAnYXNkZicsIHByaW1hcnk6IGFzZGYtMTIsIGFsaWFzZXM6IFthc2RmLTExLCBhc2RmLTEwXSwgcHJlZmVyZW5jZXM6IHt9IH0gfVxuXG4gICAgLy8gYW4gYWxpYXM6IHsgdXNlcm5hbWU6ICdhc2RmJywgY2FwYTogMTIsIHByaXZhdGVSb290S2V5OiAnMTIzJywgcHJpdmF0ZUFkbWluS2V5OiAnMzMzJywgcHJpdmF0ZURlZmF1bHRLZXk6ICc0NDQnLCBzZWNyZXRzOiB7fSB9XG5cbiAgICB2YXIgY3VycmVudFVzZXJuYW1lID0gZmFsc2VcblxuXG4gICAgLy8gVE9ETzogaW50ZWdyYXRlIGNhcGEgd2l0aCB1c2VyUmVjb3JkcyBhbmQgcHVmZnMgZXZlcnl3aGVyZVxuICAgIC8vIFRPRE86IHVzZSBjYXBhIHJldHVybmVkIGZyb20gc2VydmVyIG9uIHVwZGF0ZSBwYXNzcGhyYXNlXG4gICAgLy8gVE9ETzogZ2V0IGFub24gY3JlYXRpb24gd29ya2luZ1xuXG5cbiAgICBFQi5NLldhcmRyb2JlLmluaXQgPSBpbml0XG4gICAgXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgRUIuaW1wbGVtZW50U2VjdXJlSW50ZXJmYWNlKHVzZVNlY3VyZUluZm8sIGFkZElkZW50aXR5LCBhZGRBbGlhcywgc2V0UHJpbWFyeUFsaWFzLCBzZXRQcmVmZXJlbmNlLCBzd2l0Y2hJZGVudGl0eVRvLCByZW1vdmVJZGVudGl0eSlcbiAgICAgICAgXG4gICAgICAgIEVCLmFkZElkZW50aXR5VXBkYXRlSGFuZGxlcihmdW5jdGlvbigpIHsgLy8gVEhJTks6IHdoZXJlIHNob3VsZCB0aGlzIGxpdmU/XG4gICAgICAgICAgICBpZighRUIuQ09ORklHLmRpc2FibGVDbG91ZElkZW50aXR5KVxuICAgICAgICAgICAgICAgIEVCLnN0b3JlSWRlbnRpdHlGaWxlSW5DbG91ZCgpXG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIHdheSB0byBkbyB0aGlzXG4gICAgICAgIHZhciBvbGRDb25maWdWYWx1ZSA9IEVCLkNPTkZJRy5kaXNhYmxlQ2xvdWRJZGVudGl0eVxuICAgICAgICBFQi5DT05GSUcuZGlzYWJsZUNsb3VkSWRlbnRpdHkgPSB0cnVlXG4gICAgICAgIFxuICAgICAgICB2YXIgc3RvcmVkSWRlbnRpdGllcyA9IEVCLlBlcnNpc3QuZ2V0KCdpZGVudGl0aWVzJykgfHwge31cbiAgICBcbiAgICAgICAgT2JqZWN0LmtleXMoc3RvcmVkSWRlbnRpdGllcykuZm9yRWFjaChmdW5jdGlvbih1c2VybmFtZSkge1xuICAgICAgICAgICAgdmFyIGlkZW50aXR5ID0gc3RvcmVkSWRlbnRpdGllc1t1c2VybmFtZV1cbiAgICAgICAgICAgIGFkZElkZW50aXR5KHVzZXJuYW1lLCBpZGVudGl0eS5hbGlhc2VzLCBpZGVudGl0eS5wcmVmZXJlbmNlcywgdHJ1ZSlcbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIEVCLkNPTkZJRy5kaXNhYmxlQ2xvdWRJZGVudGl0eSA9IG9sZENvbmZpZ1ZhbHVlXG4gICAgICAgIFxuICAgICAgICB2YXIgbGFzdFVzZXJuYW1lID0gRUIuUGVyc2lzdC5nZXQoJ2N1cnJlbnRVc2VybmFtZScpXG4gICAgICAgIFxuICAgICAgICBpZiAobGFzdFVzZXJuYW1lKVxuICAgICAgICAgICAgRUIuc3dpdGNoSWRlbnRpdHlUbyhsYXN0VXNlcm5hbWUpIC8vIE5PVEU6IGNhbGwgd3JhcHBlZCB2ZXJzaW9uIHRvIGdldCBoYW5kbGVyc1xuICAgIH1cbiAgICBcbiAgICBcbiAgICAvLy8vIGV4cG9ydGVkIHZpYSBpbXBsZW1lbnRTZWN1cmVJbnRlcmZhY2VcblxuICAgIHZhciB1c2VTZWN1cmVJbmZvID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGlkZW50aXR5ID0gZ2V0Q3VycmVudElkZW50aXR5KCkgfHwge31cbiAgICAgICAgdmFyIHByaW1hcnkgPSBpZGVudGl0eS5wcmltYXJ5IHx8IHt9XG5cbiAgICAgICAgLy8gd2UgaGF2ZSB0byByZXR1cm4gYWxsIHRoZSBpZGVudGl0aWVzIGJlY2F1c2UgdGhlIHVzZXIgbWlnaHQgYmUgdHJ5aW5nIHRvIGxpc3QgdGhlbVxuICAgICAgICBjYWxsYmFjayhpZGVudGl0aWVzLCBjdXJyZW50VXNlcm5hbWUsIHByaW1hcnkucHJpdmF0ZVJvb3RLZXksIHByaW1hcnkucHJpdmF0ZUFkbWluS2V5LCBwcmltYXJ5LnByaXZhdGVEZWZhdWx0S2V5KVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICB2YXIgYWRkSWRlbnRpdHkgPSBmdW5jdGlvbih1c2VybmFtZSwgYWxpYXNlcywgcHJlZmVyZW5jZXMsIG5vc2F2ZSkgeyAvLyBUT0RPOiBjaGVjayBpZiBub3NhdmUgaXMgbmVlZGVkXG4gICAgICAgIC8vIFRPRE86IHZhbGlkYXRpb24gb24gYWxsIGF2YWlsYWJsZSB2YWx1ZXNcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgZm9yIGV4aXN0aW5nIGlkZW50aXR5XG4gICAgICAgIC8vIFRPRE86IGFkZCBhbnkgdW5rbm93biBhbGlhc2VzXG4gICAgICAgIC8vIFRISU5LOiB3aGF0IGFib3V0IGFsaWFzZXMgdGhhdCBiZWxvbmcgdG8gb3RoZXIgaWRlbnRpdGllcz9cbiAgICAgICAgLy8gVEhJTks6IGVuc3VyZSBwcmltYXJ5IGFsaWFzIGV4aXN0cz9cbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHByaW1hcnkgKHVzZSB1c2VybmFtZSttYXhjYXBhIGluc3RlYWQpXG5cbiAgICAgICAgdmFyIGlkZW50aXR5ID0geyB1c2VybmFtZTogdXNlcm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgLCBwcmltYXJ5OiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAsIGFsaWFzZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICwgcHJlZmVyZW5jZXM6IHByZWZlcmVuY2VzIHx8IHt9XG4gICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICBpZGVudGl0aWVzW3VzZXJuYW1lXSA9IGlkZW50aXR5XG4gICAgICAgIFxuICAgICAgICBpZighQXJyYXkuaXNBcnJheShhbGlhc2VzKSlcbiAgICAgICAgICAgIGFsaWFzZXMgPSBhbGlhc2VzID8gW2FsaWFzZXNdIDogW11cbiAgICAgICAgXG4gICAgICAgIGFsaWFzZXMuZm9yRWFjaChcbiAgICAgICAgICAgIGZ1bmN0aW9uKGFsaWFzKSB7XG4gICAgICAgICAgICAgICAgYWRkQWxpYXModXNlcm5hbWUsIGFsaWFzLnVzZXJuYW1lLCBhbGlhcy5jYXBhLCBhbGlhcy5wcml2YXRlUm9vdEtleSwgYWxpYXMucHJpdmF0ZUFkbWluS2V5LCBhbGlhcy5wcml2YXRlRGVmYXVsdEtleSwgYWxpYXMuc2VjcmV0cyl9KVxuICAgICAgICBcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIHByZWZzXG4gICAgICAgIFxuICAgICAgICBpZighbm9zYXZlKSAvLyBUT0RPOiBjaGFuZ2UgcHJvY2Vzc1VwZGF0ZXMgc28gaXQgb25seSBzYXZlcyBpZiB3ZSdyZSBub3QgYnVzeSBvcGVuaW5nIGFsbCBpZGVudGl0aWVzPyBvciBqdXN0IGxldCB0aGUgMTAwbXMgdGhyb3R0bGUgaGFuZGxlIGl0Li4uXG4gICAgICAgICAgICBwcm9jZXNzVXBkYXRlcygpXG4gICAgICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICB2YXIgYWRkQWxpYXMgPSBmdW5jdGlvbihpZGVudGl0eVVzZXJuYW1lLCBhbGlhc1VzZXJuYW1lLCBjYXBhLCBwcml2YXRlUm9vdEtleSwgcHJpdmF0ZUFkbWluS2V5LCBwcml2YXRlRGVmYXVsdEtleSwgc2VjcmV0cykge1xuICAgICAgICAvLyBUT0RPOiB2YWxpZGF0aW9uIG9uIGFsbCBhdmFpbGFibGUgdmFsdWVzXG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGZvciBleGlzdGluZyB1c2VybmFtZS9jYXBhXG4gICAgICAgIC8vIFRISU5LOiBoaXQgbmV0d29yayBmb3IgY29uZmlybWF0aW9uP1xuICAgICAgICAvLyBUSElOSzogbWF5YmUgb25seSBpbmNsdWRlIHZpYWJsZSB2YWx1ZXM/XG5cbiAgICAgICAgdmFyIGFsaWFzID0geyB1c2VybmFtZTogYWxpYXNVc2VybmFtZVxuICAgICAgICAgICAgICAgICAgICAsIGNhcGE6IGNhcGEgfHwgMSAvLyBOT1RFOiBkZWZhdWx0IGNhcGFcbiAgICAgICAgICAgICAgICAgICAgLCBwcml2YXRlUm9vdEtleTogcHJpdmF0ZVJvb3RLZXkgfHwgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgLCBwcml2YXRlQWRtaW5LZXk6IHByaXZhdGVBZG1pbktleSB8fCBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAsIHByaXZhdGVEZWZhdWx0S2V5OiBwcml2YXRlRGVmYXVsdEtleSB8fCBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAsIHNlY3JldHM6IHNlY3JldHMgfHwge31cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZGVudGl0eSA9IGdldElkZW50aXR5KGlkZW50aXR5VXNlcm5hbWUpXG4gICAgICAgIFxuICAgICAgICBpZighaWRlbnRpdHkpIHtcbiAgICAgICAgICAgIGFkZElkZW50aXR5KGlkZW50aXR5VXNlcm5hbWUpICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZXMgYW4gZW1wdHkgaWRlbnRpdHlcbiAgICAgICAgICAgIGlkZW50aXR5ID0gZ2V0SWRlbnRpdHkoaWRlbnRpdHlVc2VybmFtZSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gbWVyZ2UgYWxpYXNcbiAgICAgICAgdmFyIG9sZF9hbGlhcyA9IGdldE9sZEFsaWFzKGlkZW50aXR5LCBhbGlhcylcbiAgICAgICAgaWYob2xkX2FsaWFzKSB7XG4gICAgICAgICAgICBhbGlhcy5zZWNyZXRzID0gQm9yb24uZXh0ZW5kKG9sZF9hbGlhcy5zZWNyZXRzLCBhbGlhcy5zZWNyZXRzKVxuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gYWxpYXMpIFxuICAgICAgICAgICAgICAgIGlmKGFsaWFzW2tleV0pXG4gICAgICAgICAgICAgICAgICAgIG9sZF9hbGlhc1trZXldID0gYWxpYXNba2V5XVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWRlbnRpdHkuYWxpYXNlcy5wdXNoKGFsaWFzKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihhbGlhc1VzZXJuYW1lID09IGlkZW50aXR5VXNlcm5hbWUgJiYgYWxpYXMuY2FwYSA+PSAoaWRlbnRpdHkuY2FwYXx8MCkpIHtcbiAgICAgICAgICAgIGlkZW50aXR5LnByaW1hcnkgPSBhbGlhcyAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBwcmltYXJ5IGZvciBpZGVudGl0eSAod2hpY2ggbWF5IGhhdmUgYmVlbiBlbXB0eSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgYWxpYXNlc1thbGlhc1VzZXJuYW1lXSA9IGlkZW50aXR5ICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGlzIHRvIHRoZSBhbGlhcy1pZGVudGl0eSBtYXBwaW5nXG5cbiAgICAgICAgcHJvY2Vzc1VwZGF0ZXMoKVxuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgdmFyIHNldFByaW1hcnlBbGlhcyA9IGZ1bmN0aW9uKGlkZW50aXR5VXNlcm5hbWUsIGFsaWFzVXNlcm5hbWUpIHtcbiAgICAgICAgdmFyIGlkZW50aXR5ID0gZ2V0SWRlbnRpdHkoaWRlbnRpdHlVc2VybmFtZSlcbiAgICAgICAgXG4gICAgICAgIGlmKCFpZGVudGl0eSlcbiAgICAgICAgICAgIHJldHVybiBFQi5vbkVycm9yKCdQcmltYXJ5IGFsaWFzIGNhbiBvbmx5IGJlIHNldCBmb3Iga25vd24gaWRlbnRpdGllcycpXG4gICAgICAgICAgICBcbiAgICAgICAgdmFyIGFsaWFzID0gZ2V0TGF0ZXN0QWxpYXMoaWRlbnRpdHksIGFsaWFzVXNlcm5hbWUpXG4gICAgICAgIFxuICAgICAgICBpZighYWxpYXMpXG4gICAgICAgICAgICByZXR1cm4gRUIub25FcnJvcignVGhhdCBhbGlhcyBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIHRoYXQgaWRlbnRpdHknKVxuICAgIFxuICAgICAgICAvLyBhbGwgY2xlYXIhXG4gICAgICAgIFxuICAgICAgICBpZGVudGl0eS51c2VybmFtZSA9IGFsaWFzVXNlcm5hbWVcbiAgICAgICAgaWRlbnRpdHkucHJpbWFyeSA9IGFsaWFzXG5cbiAgICAgICAgZGVsZXRlIGlkZW50aXRpZXNbaWRlbnRpdHlVc2VybmFtZV1cbiAgICAgICAgaWRlbnRpdGllc1thbGlhc1VzZXJuYW1lXSA9IGlkZW50aXR5XG4gICAgICAgIFxuICAgICAgICBpZihpZGVudGl0eVVzZXJuYW1lID09IGN1cnJlbnRVc2VybmFtZSlcbiAgICAgICAgICAgIHN3aXRjaElkZW50aXR5VG8oYWxpYXNVc2VybmFtZSlcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgICBcbiAgICB2YXIgc2V0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgLy8gTk9URTogdGhpcyBvbmx5IHdvcmtzIGZvciB0aGUgY3VycmVudCBpZGVudGl0eVxuICAgICAgICB2YXIgaWRlbnRpdHkgPSBnZXRDdXJyZW50SWRlbnRpdHkoKVxuICAgIFxuICAgICAgICBpZighaWRlbnRpdHkpXG4gICAgICAgICAgICByZXR1cm4gRUIub25FcnJvcignUHJlZmVyZW5jZXMgY2FuIG9ubHkgYmUgc2V0IGZvciBhbiBhY3RpdmUgaWRlbnRpdHknKVxuICAgIFxuICAgICAgICBpZGVudGl0eS5wcmVmZXJlbmNlc1trZXldID0gdmFsdWVcblxuICAgICAgICBwcm9jZXNzVXBkYXRlcygpXG4gICAgfVxuICAgIFxuICAgIHZhciBzd2l0Y2hJZGVudGl0eVRvID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAgICAgaWYodXNlcm5hbWUpIHtcbiAgICAgICAgICAgIHZhciBpZGVudGl0eSA9IGdldElkZW50aXR5KHVzZXJuYW1lKVxuXG4gICAgICAgICAgICBpZighaWRlbnRpdHkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ05vIGlkZW50aXR5IGZvdW5kIHdpdGggdXNlcm5hbWUgXCInICsgdXNlcm5hbWUgKyAnXCInKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjdXJyZW50VXNlcm5hbWUgPSB1c2VybmFtZSB8fCBmYWxzZVxuXG4gICAgICAgIGlmKCFFQi5jdXJyZW50SWRlbnRpdHlIYXNoKSAvLyBUSElOSzogd2hhdCBhcmUgdGhlIGNhc2VzP1xuICAgICAgICAgICAgRUIuY3VycmVudElkZW50aXR5SGFzaCA9IEVCLkNyeXB0by5jcmVhdGVNZXNzYWdlSGFzaChKU09OLnN0cmluZ2lmeShFQi5mb3JtYXRJZGVudGl0eUZpbGUoKSkpXG4gICAgICAgIFxuICAgICAgICBwcm9jZXNzVXBkYXRlcygpXG4gICAgICAgIFxuICAgICAgICBpZih1c2VybmFtZSAmJiBpZGVudGl0eSAmJiBpZGVudGl0eS5wcmltYXJ5KVxuICAgICAgICAgICAgRUIuVXNlcnMuZ2V0VXNlclJlY29yZFByb21pc2UodXNlcm5hbWUsIGlkZW50aXR5LnByaW1hcnkuY2FwYSkgLy8gZmV0Y2ggb3VyIHVzZXJSZWNvcmQgXG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgXG4gICAgdmFyIHJlbW92ZUlkZW50aXR5ID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAgICAgdmFyIGlkZW50aXR5ID0gZ2V0SWRlbnRpdHkodXNlcm5hbWUpXG5cbiAgICAgICAgaWYoIWlkZW50aXR5KVxuICAgICAgICAgICAgcmV0dXJuIEVCLm9uRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHRoYXQgaWRlbnRpdHkgZm9yIHJlbW92YWwnKVxuXG4gICAgICAgIGRlbGV0ZSBpZGVudGl0aWVzW3VzZXJuYW1lXVxuXG4gICAgICAgIGlmKGN1cnJlbnRVc2VybmFtZSA9PSB1c2VybmFtZSlcbiAgICAgICAgICAgIGN1cnJlbnRVc2VybmFtZSA9IGZhbHNlXG5cbiAgICAgICAgcHJvY2Vzc1VwZGF0ZXMoKVxuICAgIH1cblxuICAgIC8vLy9cbiAgICAvLy8vIGludGVybmFsIGhlbHBlciBmdW5jdGlvbnMuIG5vdCBleHBvcnRlZC5cbiAgICAvLy8vXG5cbiAgICBmdW5jdGlvbiBnZXRMYXRlc3RBbGlhcyhpZGVudGl0eSwgYWxpYXNVc2VybmFtZSkge1xuICAgICAgICB2YXIgbWF4Y2FwYSA9IDBcbiAgICAgICAgdmFyIGFsaWFzID0gZmFsc2VcbiAgICAgICAgXG4gICAgICAgIGZvcih2YXIgaT0wLCBsPWlkZW50aXR5LmFsaWFzZXMubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRlc3QgPSBpZGVudGl0eS5hbGlhc2VzW2ldXG4gICAgICAgICAgICBpZih0ZXN0LnVzZXJuYW1lID09IGFsaWFzVXNlcm5hbWUgJiYgdGVzdC5jYXBhID4gbWF4Y2FwYSkge1xuICAgICAgICAgICAgICAgIGFsaWFzID0gdGVzdFxuICAgICAgICAgICAgICAgIG1heGNhcGEgPSB0ZXN0LmNhcGFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGFsaWFzXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0T2xkQWxpYXMoaWRlbnRpdHksIGFsaWFzKSB7XG4gICAgICAgIGZvcih2YXIgaT0wLCBsPWlkZW50aXR5LmFsaWFzZXMubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRlc3QgPSBpZGVudGl0eS5hbGlhc2VzW2ldXG4gICAgICAgICAgICBpZihhbGlhcy51c2VybmFtZSA9PSB0ZXN0LnVzZXJuYW1lICYmIGFsaWFzLmNhcGEgPT0gdGVzdC5jYXBhKVxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXN0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByaXZhdGVLZXlzKHVzZXJuYW1lLCBjYXBhLCBwcml2YXRlUm9vdEtleSwgcHJpdmF0ZUFkbWluS2V5LCBwcml2YXRlRGVmYXVsdEtleSkge1xuICAgICAgICAvLyBDVVJSRU5UTFkgVU5VU0VEXG4gICAgICAgIC8vLy8gRW5zdXJlIGtleXMgbWF0Y2ggdGhlIHVzZXJSZWNvcmRcbiAgICBcbiAgICAgICAgdmFyIHByb20gPSBFQi5Vc2Vycy5nZXRVc2VyUmVjb3JkUHJvbWlzZSh1c2VybmFtZSwgY2FwYSlcbiAgICBcbiAgICAgICAgcmV0dXJuIHByb21cbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHVzZXJSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAvLyB2YWxpZGF0ZSBhbnkgcHJvdmlkZWQgcHJpdmF0ZSBrZXlzIGFnYWluc3QgdGhlIHVzZXJSZWNvcmQncyBwdWJsaWMga2V5c1xuICAgICAgICAgICAgICAgIGlmKCAgIHByaXZhdGVSb290S2V5ICYmIEVCLkNyeXB0by5wcml2YXRlVG9QdWJsaWMocHJpdmF0ZVJvb3RLZXkpICE9IHVzZXJSZWNvcmQucm9vdEtleSlcbiAgICAgICAgICAgICAgICAgICAgRUIudGhyb3dFcnJvcignVGhhdCBwcml2YXRlIHJvb3Qga2V5IGRvZXMgbm90IG1hdGNoIHRoZSBwdWJsaWMgcm9vdCBrZXkgb24gcmVjb3JkJylcbiAgICAgICAgICAgICAgICBpZiggIHByaXZhdGVBZG1pbktleSAmJiBFQi5DcnlwdG8ucHJpdmF0ZVRvUHVibGljKHByaXZhdGVBZG1pbktleSkgIT0gdXNlclJlY29yZC5hZG1pbktleSlcbiAgICAgICAgICAgICAgICAgICAgRUIudGhyb3dFcnJvcignVGhhdCBwcml2YXRlIGFkbWluIGtleSBkb2VzIG5vdCBtYXRjaCB0aGUgcHVibGljIGFkbWluIGtleSBvbiByZWNvcmQnKVxuICAgICAgICAgICAgICAgIGlmKHByaXZhdGVEZWZhdWx0S2V5ICYmIEVCLkNyeXB0by5wcml2YXRlVG9QdWJsaWMocHJpdmF0ZURlZmF1bHRLZXkpICE9IHVzZXJSZWNvcmQuZGVmYXVsdEtleSlcbiAgICAgICAgICAgICAgICAgICAgRUIudGhyb3dFcnJvcignVGhhdCBwcml2YXRlIGRlZmF1bHQga2V5IGRvZXMgbm90IG1hdGNoIHRoZSBwdWJsaWMgZGVmYXVsdCBrZXkgb24gcmVjb3JkJylcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJSZWNvcmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICwgRUIuY2F0Y2hFcnJvcignQ291bGQgbm90IHN0b3JlIHByaXZhdGUga2V5cyBkdWUgdG8gZmF1bHR5IHVzZXIgcmVjb3JkJykpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZXMoKSB7XG4gICAgICAgIGlmKCFFQi5DT05GSUcuZXBoZW1lcmFsS2V5Y2hhaW4pXG4gICAgICAgICAgICBFQi5QZXJzaXN0LnNhdmUoJ2lkZW50aXRpZXMnLCBpZGVudGl0aWVzKVxuXG4gICAgICAgIC8vIFRISU5LOiBjb25zaWRlciB6aXBwaW5nIGlkZW50aXRpZXMgaW4gbG9jYWxTdG9yYWdlIHRvIHByZXZlbnQgc2hvdWxkZXItc3VyZmluZyBhbmQgc2F2ZSBzcGFjZSAoc2FtZSBmb3IgcHVmZnMpXG4gICAgICAgIC8vIFRISU5LOiBjb25zaWRlciBwYXNzcGhyYXNlIHByb3RlY3RpbmcgaWRlbnRpdGllcyBhbmQgcHJpdmF0ZSBwdWZmcyBpbiBsb2NhbFN0b3JhZ2VcbiAgICAgICAgLy8gVE9ETzogZG9uJ3QgcGVyc2lzdCBwcmltYXJ5IC0tIHJlZ2VuZXJhdGUgaXQgYXQgbG9hZCB0aW1lLCBzbyB3ZSBkb24ndCBkdXBsaWNhdGUgdGhlIGFsaWFzXG4gICAgICAgIEVCLlBlcnNpc3Quc2F2ZSgnY3VycmVudFVzZXJuYW1lJywgY3VycmVudFVzZXJuYW1lKVxuXG4gICAgICAgIEVCLnJ1bkhhbmRsZXJzKCdpZGVudGl0eVVwZGF0ZScpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudElkZW50aXR5KCkge1xuICAgICAgICByZXR1cm4gZ2V0SWRlbnRpdHkoY3VycmVudFVzZXJuYW1lKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElkZW50aXR5KHVzZXJuYW1lKSB7XG4gICAgICAgIGlmKCF1c2VybmFtZSkgXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICB2YXIgaWRlbnRpdHkgPSBpZGVudGl0aWVzW3VzZXJuYW1lXVxuXG4gICAgICAgIC8vIFRISU5LOiB3ZSBjb3VsZCBjaGVjayB0aGUgYWxpYXNlcyBtYXAgaGVyZSBpbiBjYXNlIHRoZSB1c2VybmFtZSBpc24ndCBwcmltYXJ5XG5cbiAgICAgICAgaWYoIWlkZW50aXR5KSBcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgICAgIHJldHVybiBpZGVudGl0eVxuICAgIH1cblxufSgpIC8vIGVuZCB0aGUgY2xvc3VyZSIsIkVCLkRhdGEuYWRkQ29udGVudFR5cGUoJ2JiY29kZScsIHtcbiAgICB0b0h0bWw6IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIGJiY29kZVBhcnNlID0gWEJCQ09ERS5wcm9jZXNzKHsgdGV4dDogY29udGVudCB9KTtcbiAgICAgICAgdmFyIHBhcnNlZFRleHQgID0gYmJjb2RlUGFyc2UuaHRtbC5yZXBsYWNlKC9cXG4vZywgJzxiciAvPicpOyBcbiAgICAgICAgcmV0dXJuIHBhcnNlZFRleHQ7XG4gICAgfVxufSlcbiIsIkVCLkRhdGEuYWRkQ29udGVudFR5cGUoJ2ZpbGUnLCB7XG4gICAgdG9IdG1sOiBmdW5jdGlvbihjb250ZW50LCBwdWZmKSB7XG4gICAgICAgIHJldHVybiBwdWZmLnBheWxvYWQuZmlsZW5hbWVcbiAgICB9XG59KVxuIiwiRUIuRGF0YS5hZGRDb250ZW50VHlwZSgnaWRlbnRpdHknLCB7XG4gICAgdG9IdG1sOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICcnXG4gICAgfVxufSlcbiIsIkVCLkRhdGEuYWRkQ29udGVudFR5cGUoJ2ltYWdlJywge1xuICAgIHRvSHRtbDogZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICBpZihwdWZmd29ybGRwcm9wcy52aWV3Lm1vZGUgPT0gXCJ0YWJsZVZpZXdcIilcbiAgICAgICAgICAgIHJldHVybiAnPGltZyBzcmM9JyArIGNvbnRlbnQgKyAnIC8+JztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuICc8aW1nIGNsYXNzPVwiaW1nSW5Cb3hcIiBzcmM9JyArIGNvbnRlbnQgKyAnIC8+JztcbiAgICB9XG59KVxuIiwiLy8gVE9ETzogQWRkIHN1cHBvcnQgZm9yIExhVGV4XG4vKkVCLkRhdGEuYWRkQ29udGVudFR5cGUoJ0xhVGV4Jywge1xuICAgIHRvSHRtbDogZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICB2YXIgc2FmZV9jb250ZW50ID0gWEJCQ09ERS5wcm9jZXNzKHsgdGV4dDogY29udGVudCB9KSBcbiAgICAgICAgcmV0dXJuICc8cD4nICsgc2FmZV9jb250ZW50Lmh0bWwgKyAnPC9wPidcbiAgICB9XG59KSAqL1xuIiwiRUIuRGF0YS5hZGRDb250ZW50VHlwZSgnbWFya2Rvd24nLCB7XG4gICAgdG9IdG1sOiBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgIHZhciBjb252ZXJ0ZXIgPSBuZXcgTWFya2Rvd24uQ29udmVydGVyKCk7XG4gICAgICAgIHJldHVybiAnPHNwYW4+Jytjb252ZXJ0ZXIubWFrZUh0bWwoY29udGVudCkrJzwvc3Bhbj4nO1xuICAgIH1cbn0pXG4iLCIvLyBVc2VkIHRvIGRpc3BsYXkgY2hlc3MgYm9hcmRzXG5FQi5EYXRhLmFkZENvbnRlbnRUeXBlKCdQR04nLCB7XG4gICAgdG9IdG1sOiBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBjaGVzc0JvYXJkKGNvbnRlbnQpO1xuICAgIH1cbn0pXG4iLCJFQi5EYXRhLmFkZENvbnRlbnRUeXBlKCdwcm9maWxlJywge1xuICAgIHRvSHRtbDogZnVuY3Rpb24oY29udGVudCwgcHVmZikge1xuICAgICAgICBpZihwdWZmd29ybGRwcm9wcy52aWV3Lm1vZGUgPT0gXCJ0YWJsZVZpZXdcIilcbiAgICAgICAgICAgIHJldHVybiAnPGltZyBzcmM9JyArIGNvbnRlbnQgKyAnIC8+JztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuICc8aW1nIGNsYXNzPVwiaW1nSW5Cb3hcIiBzcmM9JyArIGNvbnRlbnQgKyAnIC8+JztcbiAgICAgICAgLyp2YXIga2V5c05vdFNob3cgPSBbJ2NvbnRlbnQnLCAndHlwZSddO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHVmZi5wYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwdWZmLnBheWxvYWRba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXlzTm90U2hvdy5pbmRleE9mKGtleSk9PS0xICYmIHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRvUmV0ICs9ICc8ZGl2PjxzcGFuIGNsYXNzPVwicHJvZmlsZUtleVwiPicgKyBrZXkgKyAnOiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJwcm9maWxlVmFsdWVcIj4nICsgdmFsdWUgKyAnPC9zcGFuPjwvZGl2Pic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0qL1xuICAgIH1cbn0pXG4iLCJFQi5EYXRhLmFkZENvbnRlbnRUeXBlKCd0ZXh0Jywge1xuICAgIHRvSHRtbDogZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICB2YXIgc2FmZV9jb250ZW50ID0gWEJCQ09ERS5wcm9jZXNzKHsgdGV4dDogY29udGVudCB9KSAgIC8vIG5vdCBpZGVhbCwgYnV0IGl0IGRvZXMgc2VlbSB0byBzdHJpcCBvdXQgcmF3IGh0bWxcbiAgICAgICAgc2FmZV9jb250ZW50Lmh0bWwgPSBzYWZlX2NvbnRlbnQuaHRtbC5yZXBsYWNlKC9cXG4vZywgJzwvYnI+Jyk7ICAvLyBTZXQgbGluZSBicmVha3NcbiAgICAgICAgcmV0dXJuICc8c3Bhbj4nICsgc2FmZV9jb250ZW50Lmh0bWwgKyAnPC9zcGFuPidcbiAgICB9XG59KVxuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9