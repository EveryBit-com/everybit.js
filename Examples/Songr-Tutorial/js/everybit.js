!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Bitcoin=e()}}(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(_dereq_,module,exports){var util=_dereq_("util/");var pSlice=Array.prototype.slice;var hasOwn=Object.prototype.hasOwnProperty;var assert=module.exports=ok;assert.AssertionError=function AssertionError(options){this.name="AssertionError";this.actual=options.actual;this.expected=options.expected;this.operator=options.operator;if(options.message){this.message=options.message;this.generatedMessage=false}else{this.message=getMessage(this);this.generatedMessage=true}var stackStartFunction=options.stackStartFunction||fail;if(Error.captureStackTrace){Error.captureStackTrace(this,stackStartFunction)}else{var err=new Error;if(err.stack){var out=err.stack;var fn_name=stackStartFunction.name;var idx=out.indexOf("\n"+fn_name);if(idx>=0){var next_line=out.indexOf("\n",idx+1);out=out.substring(next_line+1)}this.stack=out}}};util.inherits(assert.AssertionError,Error);function replacer(key,value){if(util.isUndefined(value)){return""+value}if(util.isNumber(value)&&(isNaN(value)||!isFinite(value))){return value.toString()}if(util.isFunction(value)||util.isRegExp(value)){return value.toString()}return value}function truncate(s,n){if(util.isString(s)){return s.length<n?s:s.slice(0,n)}else{return s}}function getMessage(self){return truncate(JSON.stringify(self.actual,replacer),128)+" "+self.operator+" "+truncate(JSON.stringify(self.expected,replacer),128)}function fail(actual,expected,message,operator,stackStartFunction){throw new assert.AssertionError({message:message,actual:actual,expected:expected,operator:operator,stackStartFunction:stackStartFunction})}assert.fail=fail;function ok(value,message){if(!value)fail(value,true,message,"==",assert.ok)}assert.ok=ok;assert.equal=function equal(actual,expected,message){if(actual!=expected)fail(actual,expected,message,"==",assert.equal)};assert.notEqual=function notEqual(actual,expected,message){if(actual==expected){fail(actual,expected,message,"!=",assert.notEqual)}};assert.deepEqual=function deepEqual(actual,expected,message){if(!_deepEqual(actual,expected)){fail(actual,expected,message,"deepEqual",assert.deepEqual)}};function _deepEqual(actual,expected){if(actual===expected){return true}else if(util.isBuffer(actual)&&util.isBuffer(expected)){if(actual.length!=expected.length)return false;for(var i=0;i<actual.length;i++){if(actual[i]!==expected[i])return false}return true}else if(util.isDate(actual)&&util.isDate(expected)){return actual.getTime()===expected.getTime()}else if(util.isRegExp(actual)&&util.isRegExp(expected)){return actual.source===expected.source&&actual.global===expected.global&&actual.multiline===expected.multiline&&actual.lastIndex===expected.lastIndex&&actual.ignoreCase===expected.ignoreCase}else if(!util.isObject(actual)&&!util.isObject(expected)){return actual==expected}else{return objEquiv(actual,expected)}}function isArguments(object){return Object.prototype.toString.call(object)=="[object Arguments]"}function objEquiv(a,b){if(util.isNullOrUndefined(a)||util.isNullOrUndefined(b))return false;if(a.prototype!==b.prototype)return false;if(isArguments(a)){if(!isArguments(b)){return false}a=pSlice.call(a);b=pSlice.call(b);return _deepEqual(a,b)}try{var ka=objectKeys(a),kb=objectKeys(b),key,i}catch(e){return false}if(ka.length!=kb.length)return false;ka.sort();kb.sort();for(i=ka.length-1;i>=0;i--){if(ka[i]!=kb[i])return false}for(i=ka.length-1;i>=0;i--){key=ka[i];if(!_deepEqual(a[key],b[key]))return false}return true}assert.notDeepEqual=function notDeepEqual(actual,expected,message){if(_deepEqual(actual,expected)){fail(actual,expected,message,"notDeepEqual",assert.notDeepEqual)}};assert.strictEqual=function strictEqual(actual,expected,message){if(actual!==expected){fail(actual,expected,message,"===",assert.strictEqual)}};assert.notStrictEqual=function notStrictEqual(actual,expected,message){if(actual===expected){fail(actual,expected,message,"!==",assert.notStrictEqual)}};function expectedException(actual,expected){if(!actual||!expected){return false}if(Object.prototype.toString.call(expected)=="[object RegExp]"){return expected.test(actual)}else if(actual instanceof expected){return true}else if(expected.call({},actual)===true){return true}return false}function _throws(shouldThrow,block,expected,message){var actual;if(util.isString(expected)){message=expected;expected=null}try{block()}catch(e){actual=e}message=(expected&&expected.name?" ("+expected.name+").":".")+(message?" "+message:".");if(shouldThrow&&!actual){fail(actual,expected,"Missing expected exception"+message)}if(!shouldThrow&&expectedException(actual,expected)){fail(actual,expected,"Got unwanted exception"+message)}if(shouldThrow&&actual&&expected&&!expectedException(actual,expected)||!shouldThrow&&actual){throw actual}}assert.throws=function(block,error,message){_throws.apply(this,[true].concat(pSlice.call(arguments)))};assert.doesNotThrow=function(block,message){_throws.apply(this,[false].concat(pSlice.call(arguments)))};assert.ifError=function(err){if(err){throw err}};var objectKeys=Object.keys||function(obj){var keys=[];for(var key in obj){if(hasOwn.call(obj,key))keys.push(key)}return keys}},{"util/":3}],2:[function(_dereq_,module,exports){module.exports=function isBuffer(arg){return arg&&typeof arg==="object"&&typeof arg.copy==="function"&&typeof arg.fill==="function"&&typeof arg.readUInt8==="function"}},{}],3:[function(_dereq_,module,exports){(function(process,global){var formatRegExp=/%[sdj%]/g;exports.format=function(f){if(!isString(f)){var objects=[];for(var i=0;i<arguments.length;i++){objects.push(inspect(arguments[i]))}return objects.join(" ")}var i=1;var args=arguments;var len=args.length;var str=String(f).replace(formatRegExp,function(x){if(x==="%%")return"%";if(i>=len)return x;switch(x){case"%s":return String(args[i++]);case"%d":return Number(args[i++]);case"%j":try{return JSON.stringify(args[i++])}catch(_){return"[Circular]"}default:return x}});for(var x=args[i];i<len;x=args[++i]){if(isNull(x)||!isObject(x)){str+=" "+x}else{str+=" "+inspect(x)}}return str};exports.deprecate=function(fn,msg){if(isUndefined(global.process)){return function(){return exports.deprecate(fn,msg).apply(this,arguments)}}if(process.noDeprecation===true){return fn}var warned=false;function deprecated(){if(!warned){if(process.throwDeprecation){throw new Error(msg)}else if(process.traceDeprecation){console.trace(msg)}else{console.error(msg)}warned=true}return fn.apply(this,arguments)}return deprecated};var debugs={};var debugEnviron;exports.debuglog=function(set){if(isUndefined(debugEnviron))debugEnviron=process.env.NODE_DEBUG||"";set=set.toUpperCase();if(!debugs[set]){if(new RegExp("\\b"+set+"\\b","i").test(debugEnviron)){var pid=process.pid;debugs[set]=function(){var msg=exports.format.apply(exports,arguments);console.error("%s %d: %s",set,pid,msg)}}else{debugs[set]=function(){}}}return debugs[set]};function inspect(obj,opts){var ctx={seen:[],stylize:stylizeNoColor};if(arguments.length>=3)ctx.depth=arguments[2];if(arguments.length>=4)ctx.colors=arguments[3];if(isBoolean(opts)){ctx.showHidden=opts}else if(opts){exports._extend(ctx,opts)}if(isUndefined(ctx.showHidden))ctx.showHidden=false;if(isUndefined(ctx.depth))ctx.depth=2;if(isUndefined(ctx.colors))ctx.colors=false;if(isUndefined(ctx.customInspect))ctx.customInspect=true;if(ctx.colors)ctx.stylize=stylizeWithColor;return formatValue(ctx,obj,ctx.depth)}exports.inspect=inspect;inspect.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]};inspect.styles={special:"cyan",number:"yellow","boolean":"yellow",undefined:"grey","null":"bold",string:"green",date:"magenta",regexp:"red"};function stylizeWithColor(str,styleType){var style=inspect.styles[styleType];if(style){return"["+inspect.colors[style][0]+"m"+str+"["+inspect.colors[style][1]+"m"}else{return str}}function stylizeNoColor(str,styleType){return str}function arrayToHash(array){var hash={};array.forEach(function(val,idx){hash[val]=true});return hash}function formatValue(ctx,value,recurseTimes){if(ctx.customInspect&&value&&isFunction(value.inspect)&&value.inspect!==exports.inspect&&!(value.constructor&&value.constructor.prototype===value)){var ret=value.inspect(recurseTimes,ctx);if(!isString(ret)){ret=formatValue(ctx,ret,recurseTimes)}return ret}var primitive=formatPrimitive(ctx,value);if(primitive){return primitive}var keys=Object.keys(value);var visibleKeys=arrayToHash(keys);if(ctx.showHidden){keys=Object.getOwnPropertyNames(value)}if(isError(value)&&(keys.indexOf("message")>=0||keys.indexOf("description")>=0)){return formatError(value)}if(keys.length===0){if(isFunction(value)){var name=value.name?": "+value.name:"";return ctx.stylize("[Function"+name+"]","special")}if(isRegExp(value)){return ctx.stylize(RegExp.prototype.toString.call(value),"regexp")}if(isDate(value)){return ctx.stylize(Date.prototype.toString.call(value),"date")}if(isError(value)){return formatError(value)}}var base="",array=false,braces=["{","}"];if(isArray(value)){array=true;braces=["[","]"]}if(isFunction(value)){var n=value.name?": "+value.name:"";base=" [Function"+n+"]"}if(isRegExp(value)){base=" "+RegExp.prototype.toString.call(value)}if(isDate(value)){base=" "+Date.prototype.toUTCString.call(value)}if(isError(value)){base=" "+formatError(value)}if(keys.length===0&&(!array||value.length==0)){return braces[0]+base+braces[1]}if(recurseTimes<0){if(isRegExp(value)){return ctx.stylize(RegExp.prototype.toString.call(value),"regexp")}else{return ctx.stylize("[Object]","special")}}ctx.seen.push(value);var output;if(array){output=formatArray(ctx,value,recurseTimes,visibleKeys,keys)}else{output=keys.map(function(key){return formatProperty(ctx,value,recurseTimes,visibleKeys,key,array)})}ctx.seen.pop();return reduceToSingleString(output,base,braces)}function formatPrimitive(ctx,value){if(isUndefined(value))return ctx.stylize("undefined","undefined");if(isString(value)){var simple="'"+JSON.stringify(value).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return ctx.stylize(simple,"string")}if(isNumber(value))return ctx.stylize(""+value,"number");if(isBoolean(value))return ctx.stylize(""+value,"boolean");if(isNull(value))return ctx.stylize("null","null")}function formatError(value){return"["+Error.prototype.toString.call(value)+"]"}function formatArray(ctx,value,recurseTimes,visibleKeys,keys){var output=[];for(var i=0,l=value.length;i<l;++i){if(hasOwnProperty(value,String(i))){output.push(formatProperty(ctx,value,recurseTimes,visibleKeys,String(i),true))}else{output.push("")}}keys.forEach(function(key){if(!key.match(/^\d+$/)){output.push(formatProperty(ctx,value,recurseTimes,visibleKeys,key,true))}});return output}function formatProperty(ctx,value,recurseTimes,visibleKeys,key,array){var name,str,desc;desc=Object.getOwnPropertyDescriptor(value,key)||{value:value[key]};if(desc.get){if(desc.set){str=ctx.stylize("[Getter/Setter]","special")}else{str=ctx.stylize("[Getter]","special")}}else{if(desc.set){str=ctx.stylize("[Setter]","special")}}if(!hasOwnProperty(visibleKeys,key)){name="["+key+"]"}if(!str){if(ctx.seen.indexOf(desc.value)<0){if(isNull(recurseTimes)){str=formatValue(ctx,desc.value,null)}else{str=formatValue(ctx,desc.value,recurseTimes-1)}if(str.indexOf("\n")>-1){if(array){str=str.split("\n").map(function(line){return"  "+line}).join("\n").substr(2)}else{str="\n"+str.split("\n").map(function(line){return"   "+line}).join("\n")}}}else{str=ctx.stylize("[Circular]","special")}}if(isUndefined(name)){if(array&&key.match(/^\d+$/)){return str}name=JSON.stringify(""+key);if(name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)){name=name.substr(1,name.length-2);name=ctx.stylize(name,"name")}else{name=name.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'");name=ctx.stylize(name,"string")}}return name+": "+str}function reduceToSingleString(output,base,braces){var numLinesEst=0;var length=output.reduce(function(prev,cur){numLinesEst++;if(cur.indexOf("\n")>=0)numLinesEst++;return prev+cur.replace(/\u001b\[\d\d?m/g,"").length+1},0);if(length>60){return braces[0]+(base===""?"":base+"\n ")+" "+output.join(",\n  ")+" "+braces[1]}return braces[0]+base+" "+output.join(", ")+" "+braces[1]}function isArray(ar){return Array.isArray(ar)}exports.isArray=isArray;function isBoolean(arg){return typeof arg==="boolean"}exports.isBoolean=isBoolean;function isNull(arg){return arg===null}exports.isNull=isNull;function isNullOrUndefined(arg){return arg==null}exports.isNullOrUndefined=isNullOrUndefined;function isNumber(arg){return typeof arg==="number"}exports.isNumber=isNumber;function isString(arg){return typeof arg==="string"}exports.isString=isString;function isSymbol(arg){return typeof arg==="symbol"}exports.isSymbol=isSymbol;function isUndefined(arg){return arg===void 0}exports.isUndefined=isUndefined;function isRegExp(re){return isObject(re)&&objectToString(re)==="[object RegExp]"}exports.isRegExp=isRegExp;function isObject(arg){return typeof arg==="object"&&arg!==null}exports.isObject=isObject;function isDate(d){return isObject(d)&&objectToString(d)==="[object Date]"}exports.isDate=isDate;function isError(e){return isObject(e)&&(objectToString(e)==="[object Error]"||e instanceof Error)}exports.isError=isError;function isFunction(arg){return typeof arg==="function"}exports.isFunction=isFunction;function isPrimitive(arg){return arg===null||typeof arg==="boolean"||typeof arg==="number"||typeof arg==="string"||typeof arg==="symbol"||typeof arg==="undefined"}exports.isPrimitive=isPrimitive;exports.isBuffer=_dereq_("./support/isBuffer");function objectToString(o){return Object.prototype.toString.call(o)}function pad(n){return n<10?"0"+n.toString(10):n.toString(10)}var months=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function timestamp(){var d=new Date;var time=[pad(d.getHours()),pad(d.getMinutes()),pad(d.getSeconds())].join(":");return[d.getDate(),months[d.getMonth()],time].join(" ")}exports.log=function(){console.log("%s - %s",timestamp(),exports.format.apply(exports,arguments))};exports.inherits=_dereq_("inherits");exports._extend=function(origin,add){if(!add||!isObject(add))return origin;var keys=Object.keys(add);var i=keys.length;while(i--){origin[keys[i]]=add[keys[i]]}return origin};function hasOwnProperty(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop)}}).call(this,_dereq_("FWaASH"),typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./support/isBuffer":2,FWaASH:15,inherits:14}],4:[function(_dereq_,module,exports){},{}],5:[function(_dereq_,module,exports){var base64=_dereq_("base64-js");var ieee754=_dereq_("ieee754");exports.Buffer=Buffer;exports.SlowBuffer=Buffer;exports.INSPECT_MAX_BYTES=50;Buffer.poolSize=8192;Buffer._useTypedArrays=function(){try{var buf=new ArrayBuffer(0);var arr=new Uint8Array(buf);arr.foo=function(){return 42};return 42===arr.foo()&&typeof arr.subarray==="function"}catch(e){return false}}();function Buffer(subject,encoding,noZero){if(!(this instanceof Buffer))return new Buffer(subject,encoding,noZero);var type=typeof subject;if(encoding==="base64"&&type==="string"){subject=stringtrim(subject);while(subject.length%4!==0){subject=subject+"="}}var length;if(type==="number")length=coerce(subject);else if(type==="string")length=Buffer.byteLength(subject,encoding);else if(type==="object")length=coerce(subject.length);else throw new Error("First argument needs to be a number, array or string.");var buf;if(Buffer._useTypedArrays){buf=Buffer._augment(new Uint8Array(length))}else{buf=this;buf.length=length;buf._isBuffer=true}var i;if(Buffer._useTypedArrays&&typeof subject.byteLength==="number"){buf._set(subject)}else if(isArrayish(subject)){if(Buffer.isBuffer(subject)){for(i=0;i<length;i++)buf[i]=subject.readUInt8(i)}else{for(i=0;i<length;i++)buf[i]=(subject[i]%256+256)%256}}else if(type==="string"){buf.write(subject,0,encoding)}else if(type==="number"&&!Buffer._useTypedArrays&&!noZero){for(i=0;i<length;i++){buf[i]=0}}return buf}Buffer.isEncoding=function(encoding){switch(String(encoding).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"raw":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return true;default:return false}};Buffer.isBuffer=function(b){return!!(b!==null&&b!==undefined&&b._isBuffer)};Buffer.byteLength=function(str,encoding){var ret;str=str.toString();switch(encoding||"utf8"){case"hex":ret=str.length/2;break;case"utf8":case"utf-8":ret=utf8ToBytes(str).length;break;case"ascii":case"binary":case"raw":ret=str.length;break;case"base64":ret=base64ToBytes(str).length;break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":ret=str.length*2;break;default:throw new Error("Unknown encoding")}return ret};Buffer.concat=function(list,totalLength){assert(isArray(list),"Usage: Buffer.concat(list[, length])");if(list.length===0){return new Buffer(0)}else if(list.length===1){return list[0]}var i;if(totalLength===undefined){totalLength=0;for(i=0;i<list.length;i++){totalLength+=list[i].length}}var buf=new Buffer(totalLength);var pos=0;for(i=0;i<list.length;i++){var item=list[i];item.copy(buf,pos);pos+=item.length}return buf};Buffer.compare=function(a,b){assert(Buffer.isBuffer(a)&&Buffer.isBuffer(b),"Arguments must be Buffers");var x=a.length;var y=b.length;for(var i=0,len=Math.min(x,y);i<len&&a[i]===b[i];i++){}if(i!==len){x=a[i];y=b[i]}if(x<y){return-1}if(y<x){return 1}return 0};function hexWrite(buf,string,offset,length){offset=Number(offset)||0;var remaining=buf.length-offset;if(!length){length=remaining}else{length=Number(length);if(length>remaining){length=remaining}}var strLen=string.length;assert(strLen%2===0,"Invalid hex string");if(length>strLen/2){length=strLen/2}for(var i=0;i<length;i++){var byte=parseInt(string.substr(i*2,2),16);assert(!isNaN(byte),"Invalid hex string");buf[offset+i]=byte}return i}function utf8Write(buf,string,offset,length){var charsWritten=blitBuffer(utf8ToBytes(string),buf,offset,length);return charsWritten}function asciiWrite(buf,string,offset,length){var charsWritten=blitBuffer(asciiToBytes(string),buf,offset,length);return charsWritten}function binaryWrite(buf,string,offset,length){return asciiWrite(buf,string,offset,length)}function base64Write(buf,string,offset,length){var charsWritten=blitBuffer(base64ToBytes(string),buf,offset,length);return charsWritten}function utf16leWrite(buf,string,offset,length){var charsWritten=blitBuffer(utf16leToBytes(string),buf,offset,length);return charsWritten}Buffer.prototype.write=function(string,offset,length,encoding){if(isFinite(offset)){if(!isFinite(length)){encoding=length;length=undefined}}else{var swap=encoding;encoding=offset;offset=length;length=swap}offset=Number(offset)||0;var remaining=this.length-offset;if(!length){length=remaining}else{length=Number(length);if(length>remaining){length=remaining}}encoding=String(encoding||"utf8").toLowerCase();var ret;switch(encoding){case"hex":ret=hexWrite(this,string,offset,length);break;case"utf8":case"utf-8":ret=utf8Write(this,string,offset,length);break;case"ascii":ret=asciiWrite(this,string,offset,length);break;case"binary":ret=binaryWrite(this,string,offset,length);break;case"base64":ret=base64Write(this,string,offset,length);break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":ret=utf16leWrite(this,string,offset,length);break;default:throw new Error("Unknown encoding")}return ret};Buffer.prototype.toString=function(encoding,start,end){var self=this;encoding=String(encoding||"utf8").toLowerCase();start=Number(start)||0;end=end===undefined?self.length:Number(end);if(end===start)return"";var ret;switch(encoding){case"hex":ret=hexSlice(self,start,end);break;case"utf8":case"utf-8":ret=utf8Slice(self,start,end);break;case"ascii":ret=asciiSlice(self,start,end);break;case"binary":ret=binarySlice(self,start,end);break;case"base64":ret=base64Slice(self,start,end);break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":ret=utf16leSlice(self,start,end);break;default:throw new Error("Unknown encoding")}return ret};Buffer.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};Buffer.prototype.equals=function(b){assert(Buffer.isBuffer(b),"Argument must be a Buffer");return Buffer.compare(this,b)===0};Buffer.prototype.compare=function(b){assert(Buffer.isBuffer(b),"Argument must be a Buffer");return Buffer.compare(this,b)};Buffer.prototype.copy=function(target,target_start,start,end){var source=this;if(!start)start=0;if(!end&&end!==0)end=this.length;if(!target_start)target_start=0;if(end===start)return;if(target.length===0||source.length===0)return;assert(end>=start,"sourceEnd < sourceStart");assert(target_start>=0&&target_start<target.length,"targetStart out of bounds");assert(start>=0&&start<source.length,"sourceStart out of bounds");assert(end>=0&&end<=source.length,"sourceEnd out of bounds");if(end>this.length)end=this.length;if(target.length-target_start<end-start)end=target.length-target_start+start;var len=end-start;if(len<100||!Buffer._useTypedArrays){for(var i=0;i<len;i++){target[i+target_start]=this[i+start]}}else{target._set(this.subarray(start,start+len),target_start)}};function base64Slice(buf,start,end){if(start===0&&end===buf.length){return base64.fromByteArray(buf)}else{return base64.fromByteArray(buf.slice(start,end))}}function utf8Slice(buf,start,end){var res="";var tmp="";end=Math.min(buf.length,end);for(var i=start;i<end;i++){if(buf[i]<=127){res+=decodeUtf8Char(tmp)+String.fromCharCode(buf[i]);tmp=""}else{tmp+="%"+buf[i].toString(16)}}return res+decodeUtf8Char(tmp)}function asciiSlice(buf,start,end){var ret="";end=Math.min(buf.length,end);for(var i=start;i<end;i++){ret+=String.fromCharCode(buf[i])}return ret}function binarySlice(buf,start,end){return asciiSlice(buf,start,end)}function hexSlice(buf,start,end){var len=buf.length;if(!start||start<0)start=0;if(!end||end<0||end>len)end=len;var out="";for(var i=start;i<end;i++){out+=toHex(buf[i])}return out}function utf16leSlice(buf,start,end){var bytes=buf.slice(start,end);var res="";for(var i=0;i<bytes.length;i+=2){res+=String.fromCharCode(bytes[i]+bytes[i+1]*256)}return res}Buffer.prototype.slice=function(start,end){var len=this.length;start=clamp(start,len,0);end=clamp(end,len,len);if(Buffer._useTypedArrays){return Buffer._augment(this.subarray(start,end))}else{var sliceLen=end-start;var newBuf=new Buffer(sliceLen,undefined,true);for(var i=0;i<sliceLen;i++){newBuf[i]=this[i+start]}return newBuf}};Buffer.prototype.get=function(offset){console.log(".get() is deprecated. Access using array indexes instead.");return this.readUInt8(offset)};Buffer.prototype.set=function(v,offset){console.log(".set() is deprecated. Access using array indexes instead.");return this.writeUInt8(v,offset)};Buffer.prototype.readUInt8=function(offset,noAssert){if(!noAssert){assert(offset!==undefined&&offset!==null,"missing offset");assert(offset<this.length,"Trying to read beyond buffer length")}if(offset>=this.length)return;return this[offset]};function readUInt16(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+1<buf.length,"Trying to read beyond buffer length")}var len=buf.length;if(offset>=len)return;var val;if(littleEndian){val=buf[offset];if(offset+1<len)val|=buf[offset+1]<<8}else{val=buf[offset]<<8;if(offset+1<len)val|=buf[offset+1]}return val}Buffer.prototype.readUInt16LE=function(offset,noAssert){return readUInt16(this,offset,true,noAssert)};Buffer.prototype.readUInt16BE=function(offset,noAssert){return readUInt16(this,offset,false,noAssert)};function readUInt32(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+3<buf.length,"Trying to read beyond buffer length")}var len=buf.length;if(offset>=len)return;var val;if(littleEndian){if(offset+2<len)val=buf[offset+2]<<16;if(offset+1<len)val|=buf[offset+1]<<8;val|=buf[offset];if(offset+3<len)val=val+(buf[offset+3]<<24>>>0)}else{if(offset+1<len)val=buf[offset+1]<<16;if(offset+2<len)val|=buf[offset+2]<<8;if(offset+3<len)val|=buf[offset+3];val=val+(buf[offset]<<24>>>0)}return val}Buffer.prototype.readUInt32LE=function(offset,noAssert){return readUInt32(this,offset,true,noAssert)};Buffer.prototype.readUInt32BE=function(offset,noAssert){return readUInt32(this,offset,false,noAssert)};Buffer.prototype.readInt8=function(offset,noAssert){if(!noAssert){assert(offset!==undefined&&offset!==null,"missing offset");assert(offset<this.length,"Trying to read beyond buffer length")}if(offset>=this.length)return;var neg=this[offset]&128;if(neg)return(255-this[offset]+1)*-1;else return this[offset]};function readInt16(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+1<buf.length,"Trying to read beyond buffer length")}var len=buf.length;if(offset>=len)return;var val=readUInt16(buf,offset,littleEndian,true);var neg=val&32768;if(neg)return(65535-val+1)*-1;else return val}Buffer.prototype.readInt16LE=function(offset,noAssert){return readInt16(this,offset,true,noAssert)};Buffer.prototype.readInt16BE=function(offset,noAssert){return readInt16(this,offset,false,noAssert)};function readInt32(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+3<buf.length,"Trying to read beyond buffer length")}var len=buf.length;if(offset>=len)return;var val=readUInt32(buf,offset,littleEndian,true);var neg=val&2147483648;if(neg)return(4294967295-val+1)*-1;else return val}Buffer.prototype.readInt32LE=function(offset,noAssert){return readInt32(this,offset,true,noAssert)};Buffer.prototype.readInt32BE=function(offset,noAssert){return readInt32(this,offset,false,noAssert)};function readFloat(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset+3<buf.length,"Trying to read beyond buffer length")}return ieee754.read(buf,offset,littleEndian,23,4)}Buffer.prototype.readFloatLE=function(offset,noAssert){return readFloat(this,offset,true,noAssert)};Buffer.prototype.readFloatBE=function(offset,noAssert){return readFloat(this,offset,false,noAssert)};function readDouble(buf,offset,littleEndian,noAssert){if(!noAssert){assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset+7<buf.length,"Trying to read beyond buffer length")}return ieee754.read(buf,offset,littleEndian,52,8)}Buffer.prototype.readDoubleLE=function(offset,noAssert){return readDouble(this,offset,true,noAssert)};Buffer.prototype.readDoubleBE=function(offset,noAssert){return readDouble(this,offset,false,noAssert)};Buffer.prototype.writeUInt8=function(value,offset,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset<this.length,"trying to write beyond buffer length");verifuint(value,255)}if(offset>=this.length)return;this[offset]=value;return offset+1};function writeUInt16(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+1<buf.length,"trying to write beyond buffer length");verifuint(value,65535)}var len=buf.length;if(offset>=len)return;for(var i=0,j=Math.min(len-offset,2);i<j;i++){buf[offset+i]=(value&255<<8*(littleEndian?i:1-i))>>>(littleEndian?i:1-i)*8}return offset+2}Buffer.prototype.writeUInt16LE=function(value,offset,noAssert){return writeUInt16(this,value,offset,true,noAssert)};Buffer.prototype.writeUInt16BE=function(value,offset,noAssert){return writeUInt16(this,value,offset,false,noAssert)};function writeUInt32(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+3<buf.length,"trying to write beyond buffer length");verifuint(value,4294967295)}var len=buf.length;if(offset>=len)return;for(var i=0,j=Math.min(len-offset,4);i<j;i++){buf[offset+i]=value>>>(littleEndian?i:3-i)*8&255}return offset+4}Buffer.prototype.writeUInt32LE=function(value,offset,noAssert){return writeUInt32(this,value,offset,true,noAssert)};Buffer.prototype.writeUInt32BE=function(value,offset,noAssert){return writeUInt32(this,value,offset,false,noAssert)};Buffer.prototype.writeInt8=function(value,offset,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset<this.length,"Trying to write beyond buffer length");verifsint(value,127,-128)}if(offset>=this.length)return;if(value>=0)this.writeUInt8(value,offset,noAssert);else this.writeUInt8(255+value+1,offset,noAssert);return offset+1};function writeInt16(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+1<buf.length,"Trying to write beyond buffer length");verifsint(value,32767,-32768)}var len=buf.length;if(offset>=len)return;if(value>=0)writeUInt16(buf,value,offset,littleEndian,noAssert);else writeUInt16(buf,65535+value+1,offset,littleEndian,noAssert);return offset+2}Buffer.prototype.writeInt16LE=function(value,offset,noAssert){return writeInt16(this,value,offset,true,noAssert)};Buffer.prototype.writeInt16BE=function(value,offset,noAssert){return writeInt16(this,value,offset,false,noAssert)};function writeInt32(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+3<buf.length,"Trying to write beyond buffer length");verifsint(value,2147483647,-2147483648)}var len=buf.length;if(offset>=len)return;if(value>=0)writeUInt32(buf,value,offset,littleEndian,noAssert);else writeUInt32(buf,4294967295+value+1,offset,littleEndian,noAssert);return offset+4}Buffer.prototype.writeInt32LE=function(value,offset,noAssert){return writeInt32(this,value,offset,true,noAssert)};Buffer.prototype.writeInt32BE=function(value,offset,noAssert){return writeInt32(this,value,offset,false,noAssert)};function writeFloat(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+3<buf.length,"Trying to write beyond buffer length");verifIEEE754(value,3.4028234663852886e38,-3.4028234663852886e38)}var len=buf.length;if(offset>=len)return;ieee754.write(buf,value,offset,littleEndian,23,4);return offset+4
}Buffer.prototype.writeFloatLE=function(value,offset,noAssert){return writeFloat(this,value,offset,true,noAssert)};Buffer.prototype.writeFloatBE=function(value,offset,noAssert){return writeFloat(this,value,offset,false,noAssert)};function writeDouble(buf,value,offset,littleEndian,noAssert){if(!noAssert){assert(value!==undefined&&value!==null,"missing value");assert(typeof littleEndian==="boolean","missing or invalid endian");assert(offset!==undefined&&offset!==null,"missing offset");assert(offset+7<buf.length,"Trying to write beyond buffer length");verifIEEE754(value,1.7976931348623157e308,-1.7976931348623157e308)}var len=buf.length;if(offset>=len)return;ieee754.write(buf,value,offset,littleEndian,52,8);return offset+8}Buffer.prototype.writeDoubleLE=function(value,offset,noAssert){return writeDouble(this,value,offset,true,noAssert)};Buffer.prototype.writeDoubleBE=function(value,offset,noAssert){return writeDouble(this,value,offset,false,noAssert)};Buffer.prototype.fill=function(value,start,end){if(!value)value=0;if(!start)start=0;if(!end)end=this.length;assert(end>=start,"end < start");if(end===start)return;if(this.length===0)return;assert(start>=0&&start<this.length,"start out of bounds");assert(end>=0&&end<=this.length,"end out of bounds");var i;if(typeof value==="number"){for(i=start;i<end;i++){this[i]=value}}else{var bytes=utf8ToBytes(value.toString());var len=bytes.length;for(i=start;i<end;i++){this[i]=bytes[i%len]}}return this};Buffer.prototype.inspect=function(){var out=[];var len=this.length;for(var i=0;i<len;i++){out[i]=toHex(this[i]);if(i===exports.INSPECT_MAX_BYTES){out[i+1]="...";break}}return"<Buffer "+out.join(" ")+">"};Buffer.prototype.toArrayBuffer=function(){if(typeof Uint8Array!=="undefined"){if(Buffer._useTypedArrays){return new Buffer(this).buffer}else{var buf=new Uint8Array(this.length);for(var i=0,len=buf.length;i<len;i+=1){buf[i]=this[i]}return buf.buffer}}else{throw new Error("Buffer.toArrayBuffer not supported in this browser")}};var BP=Buffer.prototype;Buffer._augment=function(arr){arr._isBuffer=true;arr._get=arr.get;arr._set=arr.set;arr.get=BP.get;arr.set=BP.set;arr.write=BP.write;arr.toString=BP.toString;arr.toLocaleString=BP.toString;arr.toJSON=BP.toJSON;arr.equals=BP.equals;arr.compare=BP.compare;arr.copy=BP.copy;arr.slice=BP.slice;arr.readUInt8=BP.readUInt8;arr.readUInt16LE=BP.readUInt16LE;arr.readUInt16BE=BP.readUInt16BE;arr.readUInt32LE=BP.readUInt32LE;arr.readUInt32BE=BP.readUInt32BE;arr.readInt8=BP.readInt8;arr.readInt16LE=BP.readInt16LE;arr.readInt16BE=BP.readInt16BE;arr.readInt32LE=BP.readInt32LE;arr.readInt32BE=BP.readInt32BE;arr.readFloatLE=BP.readFloatLE;arr.readFloatBE=BP.readFloatBE;arr.readDoubleLE=BP.readDoubleLE;arr.readDoubleBE=BP.readDoubleBE;arr.writeUInt8=BP.writeUInt8;arr.writeUInt16LE=BP.writeUInt16LE;arr.writeUInt16BE=BP.writeUInt16BE;arr.writeUInt32LE=BP.writeUInt32LE;arr.writeUInt32BE=BP.writeUInt32BE;arr.writeInt8=BP.writeInt8;arr.writeInt16LE=BP.writeInt16LE;arr.writeInt16BE=BP.writeInt16BE;arr.writeInt32LE=BP.writeInt32LE;arr.writeInt32BE=BP.writeInt32BE;arr.writeFloatLE=BP.writeFloatLE;arr.writeFloatBE=BP.writeFloatBE;arr.writeDoubleLE=BP.writeDoubleLE;arr.writeDoubleBE=BP.writeDoubleBE;arr.fill=BP.fill;arr.inspect=BP.inspect;arr.toArrayBuffer=BP.toArrayBuffer;return arr};function stringtrim(str){if(str.trim)return str.trim();return str.replace(/^\s+|\s+$/g,"")}function clamp(index,len,defaultValue){if(typeof index!=="number")return defaultValue;index=~~index;if(index>=len)return len;if(index>=0)return index;index+=len;if(index>=0)return index;return 0}function coerce(length){length=~~Math.ceil(+length);return length<0?0:length}function isArray(subject){return(Array.isArray||function(subject){return Object.prototype.toString.call(subject)==="[object Array]"})(subject)}function isArrayish(subject){return isArray(subject)||Buffer.isBuffer(subject)||subject&&typeof subject==="object"&&typeof subject.length==="number"}function toHex(n){if(n<16)return"0"+n.toString(16);return n.toString(16)}function utf8ToBytes(str){var byteArray=[];for(var i=0;i<str.length;i++){var b=str.charCodeAt(i);if(b<=127){byteArray.push(b)}else{var start=i;if(b>=55296&&b<=57343)i++;var h=encodeURIComponent(str.slice(start,i+1)).substr(1).split("%");for(var j=0;j<h.length;j++){byteArray.push(parseInt(h[j],16))}}}return byteArray}function asciiToBytes(str){var byteArray=[];for(var i=0;i<str.length;i++){byteArray.push(str.charCodeAt(i)&255)}return byteArray}function utf16leToBytes(str){var c,hi,lo;var byteArray=[];for(var i=0;i<str.length;i++){c=str.charCodeAt(i);hi=c>>8;lo=c%256;byteArray.push(lo);byteArray.push(hi)}return byteArray}function base64ToBytes(str){return base64.toByteArray(str)}function blitBuffer(src,dst,offset,length){for(var i=0;i<length;i++){if(i+offset>=dst.length||i>=src.length)break;dst[i+offset]=src[i]}return i}function decodeUtf8Char(str){try{return decodeURIComponent(str)}catch(err){return String.fromCharCode(65533)}}function verifuint(value,max){assert(typeof value==="number","cannot write a non-number as a number");assert(value>=0,"specified a negative value for writing an unsigned value");assert(value<=max,"value is larger than maximum value for type");assert(Math.floor(value)===value,"value has a fractional component")}function verifsint(value,max,min){assert(typeof value==="number","cannot write a non-number as a number");assert(value<=max,"value larger than maximum allowed value");assert(value>=min,"value smaller than minimum allowed value");assert(Math.floor(value)===value,"value has a fractional component")}function verifIEEE754(value,max,min){assert(typeof value==="number","cannot write a non-number as a number");assert(value<=max,"value larger than maximum allowed value");assert(value>=min,"value smaller than minimum allowed value")}function assert(test,message){if(!test)throw new Error(message||"Failed assertion")}},{"base64-js":6,ieee754:7}],6:[function(_dereq_,module,exports){var lookup="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";(function(exports){"use strict";var Arr=typeof Uint8Array!=="undefined"?Uint8Array:Array;var ZERO="0".charCodeAt(0);var PLUS="+".charCodeAt(0);var SLASH="/".charCodeAt(0);var NUMBER="0".charCodeAt(0);var LOWER="a".charCodeAt(0);var UPPER="A".charCodeAt(0);function decode(elt){var code=elt.charCodeAt(0);if(code===PLUS)return 62;if(code===SLASH)return 63;if(code<NUMBER)return-1;if(code<NUMBER+10)return code-NUMBER+26+26;if(code<UPPER+26)return code-UPPER;if(code<LOWER+26)return code-LOWER+26}function b64ToByteArray(b64){var i,j,l,tmp,placeHolders,arr;if(b64.length%4>0){throw new Error("Invalid string. Length must be a multiple of 4")}var len=b64.length;placeHolders="="===b64.charAt(len-2)?2:"="===b64.charAt(len-1)?1:0;arr=new Arr(b64.length*3/4-placeHolders);l=placeHolders>0?b64.length-4:b64.length;var L=0;function push(v){arr[L++]=v}for(i=0,j=0;i<l;i+=4,j+=3){tmp=decode(b64.charAt(i))<<18|decode(b64.charAt(i+1))<<12|decode(b64.charAt(i+2))<<6|decode(b64.charAt(i+3));push((tmp&16711680)>>16);push((tmp&65280)>>8);push(tmp&255)}if(placeHolders===2){tmp=decode(b64.charAt(i))<<2|decode(b64.charAt(i+1))>>4;push(tmp&255)}else if(placeHolders===1){tmp=decode(b64.charAt(i))<<10|decode(b64.charAt(i+1))<<4|decode(b64.charAt(i+2))>>2;push(tmp>>8&255);push(tmp&255)}return arr}function uint8ToBase64(uint8){var i,extraBytes=uint8.length%3,output="",temp,length;function encode(num){return lookup.charAt(num)}function tripletToBase64(num){return encode(num>>18&63)+encode(num>>12&63)+encode(num>>6&63)+encode(num&63)}for(i=0,length=uint8.length-extraBytes;i<length;i+=3){temp=(uint8[i]<<16)+(uint8[i+1]<<8)+uint8[i+2];output+=tripletToBase64(temp)}switch(extraBytes){case 1:temp=uint8[uint8.length-1];output+=encode(temp>>2);output+=encode(temp<<4&63);output+="==";break;case 2:temp=(uint8[uint8.length-2]<<8)+uint8[uint8.length-1];output+=encode(temp>>10);output+=encode(temp>>4&63);output+=encode(temp<<2&63);output+="=";break}return output}module.exports.toByteArray=b64ToByteArray;module.exports.fromByteArray=uint8ToBase64})()},{}],7:[function(_dereq_,module,exports){exports.read=function(buffer,offset,isLE,mLen,nBytes){var e,m,eLen=nBytes*8-mLen-1,eMax=(1<<eLen)-1,eBias=eMax>>1,nBits=-7,i=isLE?nBytes-1:0,d=isLE?-1:1,s=buffer[offset+i];i+=d;e=s&(1<<-nBits)-1;s>>=-nBits;nBits+=eLen;for(;nBits>0;e=e*256+buffer[offset+i],i+=d,nBits-=8);m=e&(1<<-nBits)-1;e>>=-nBits;nBits+=mLen;for(;nBits>0;m=m*256+buffer[offset+i],i+=d,nBits-=8);if(e===0){e=1-eBias}else if(e===eMax){return m?NaN:(s?-1:1)*Infinity}else{m=m+Math.pow(2,mLen);e=e-eBias}return(s?-1:1)*m*Math.pow(2,e-mLen)};exports.write=function(buffer,value,offset,isLE,mLen,nBytes){var e,m,c,eLen=nBytes*8-mLen-1,eMax=(1<<eLen)-1,eBias=eMax>>1,rt=mLen===23?Math.pow(2,-24)-Math.pow(2,-77):0,i=isLE?0:nBytes-1,d=isLE?1:-1,s=value<0||value===0&&1/value<0?1:0;value=Math.abs(value);if(isNaN(value)||value===Infinity){m=isNaN(value)?1:0;e=eMax}else{e=Math.floor(Math.log(value)/Math.LN2);if(value*(c=Math.pow(2,-e))<1){e--;c*=2}if(e+eBias>=1){value+=rt/c}else{value+=rt*Math.pow(2,1-eBias)}if(value*c>=2){e++;c/=2}if(e+eBias>=eMax){m=0;e=eMax}else if(e+eBias>=1){m=(value*c-1)*Math.pow(2,mLen);e=e+eBias}else{m=value*Math.pow(2,eBias-1)*Math.pow(2,mLen);e=0}}for(;mLen>=8;buffer[offset+i]=m&255,i+=d,m/=256,mLen-=8);e=e<<mLen|m;eLen+=mLen;for(;eLen>0;buffer[offset+i]=e&255,i+=d,e/=256,eLen-=8);buffer[offset+i-d]|=s*128}},{}],8:[function(_dereq_,module,exports){var Buffer=_dereq_("buffer").Buffer;var intSize=4;var zeroBuffer=new Buffer(intSize);zeroBuffer.fill(0);var chrsz=8;function toArray(buf,bigEndian){if(buf.length%intSize!==0){var len=buf.length+(intSize-buf.length%intSize);buf=Buffer.concat([buf,zeroBuffer],len)}var arr=[];var fn=bigEndian?buf.readInt32BE:buf.readInt32LE;for(var i=0;i<buf.length;i+=intSize){arr.push(fn.call(buf,i))}return arr}function toBuffer(arr,size,bigEndian){var buf=new Buffer(size);var fn=bigEndian?buf.writeInt32BE:buf.writeInt32LE;for(var i=0;i<arr.length;i++){fn.call(buf,arr[i],i*4,true)}return buf}function hash(buf,fn,hashSize,bigEndian){if(!Buffer.isBuffer(buf))buf=new Buffer(buf);var arr=fn(toArray(buf,bigEndian),buf.length*chrsz);return toBuffer(arr,hashSize,bigEndian)}module.exports={hash:hash}},{buffer:5}],9:[function(_dereq_,module,exports){var Buffer=_dereq_("buffer").Buffer;var sha=_dereq_("./sha");var sha256=_dereq_("./sha256");var rng=_dereq_("./rng");var md5=_dereq_("./md5");var algorithms={sha1:sha,sha256:sha256,md5:md5};var blocksize=64;var zeroBuffer=new Buffer(blocksize);zeroBuffer.fill(0);function hmac(fn,key,data){if(!Buffer.isBuffer(key))key=new Buffer(key);if(!Buffer.isBuffer(data))data=new Buffer(data);if(key.length>blocksize){key=fn(key)}else if(key.length<blocksize){key=Buffer.concat([key,zeroBuffer],blocksize)}var ipad=new Buffer(blocksize),opad=new Buffer(blocksize);for(var i=0;i<blocksize;i++){ipad[i]=key[i]^54;opad[i]=key[i]^92}var hash=fn(Buffer.concat([ipad,data]));return fn(Buffer.concat([opad,hash]))}function hash(alg,key){alg=alg||"sha1";var fn=algorithms[alg];var bufs=[];var length=0;if(!fn)error("algorithm:",alg,"is not yet supported");return{update:function(data){if(!Buffer.isBuffer(data))data=new Buffer(data);bufs.push(data);length+=data.length;return this},digest:function(enc){var buf=Buffer.concat(bufs);var r=key?hmac(fn,key,buf):fn(buf);bufs=null;return enc?r.toString(enc):r}}}function error(){var m=[].slice.call(arguments).join(" ");throw new Error([m,"we accept pull requests","http://github.com/dominictarr/crypto-browserify"].join("\n"))}exports.createHash=function(alg){return hash(alg)};exports.createHmac=function(alg,key){return hash(alg,key)};exports.randomBytes=function(size,callback){if(callback&&callback.call){try{callback.call(this,undefined,new Buffer(rng(size)))}catch(err){callback(err)}}else{return new Buffer(rng(size))}};function each(a,f){for(var i in a)f(a[i],i)}each(["createCredentials","createCipher","createCipheriv","createDecipher","createDecipheriv","createSign","createVerify","createDiffieHellman","pbkdf2"],function(name){exports[name]=function(){error("sorry,",name,"is not implemented yet")}})},{"./md5":10,"./rng":11,"./sha":12,"./sha256":13,buffer:5}],10:[function(_dereq_,module,exports){var helpers=_dereq_("./helpers");function md5_vm_test(){return hex_md5("abc")=="900150983cd24fb0d6963f7d28e17f72"}function core_md5(x,len){x[len>>5]|=128<<len%32;x[(len+64>>>9<<4)+14]=len;var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;a=md5_ff(a,b,c,d,x[i+0],7,-680876936);d=md5_ff(d,a,b,c,x[i+1],12,-389564586);c=md5_ff(c,d,a,b,x[i+2],17,606105819);b=md5_ff(b,c,d,a,x[i+3],22,-1044525330);a=md5_ff(a,b,c,d,x[i+4],7,-176418897);d=md5_ff(d,a,b,c,x[i+5],12,1200080426);c=md5_ff(c,d,a,b,x[i+6],17,-1473231341);b=md5_ff(b,c,d,a,x[i+7],22,-45705983);a=md5_ff(a,b,c,d,x[i+8],7,1770035416);d=md5_ff(d,a,b,c,x[i+9],12,-1958414417);c=md5_ff(c,d,a,b,x[i+10],17,-42063);b=md5_ff(b,c,d,a,x[i+11],22,-1990404162);a=md5_ff(a,b,c,d,x[i+12],7,1804603682);d=md5_ff(d,a,b,c,x[i+13],12,-40341101);c=md5_ff(c,d,a,b,x[i+14],17,-1502002290);b=md5_ff(b,c,d,a,x[i+15],22,1236535329);a=md5_gg(a,b,c,d,x[i+1],5,-165796510);d=md5_gg(d,a,b,c,x[i+6],9,-1069501632);c=md5_gg(c,d,a,b,x[i+11],14,643717713);b=md5_gg(b,c,d,a,x[i+0],20,-373897302);a=md5_gg(a,b,c,d,x[i+5],5,-701558691);d=md5_gg(d,a,b,c,x[i+10],9,38016083);c=md5_gg(c,d,a,b,x[i+15],14,-660478335);b=md5_gg(b,c,d,a,x[i+4],20,-405537848);a=md5_gg(a,b,c,d,x[i+9],5,568446438);d=md5_gg(d,a,b,c,x[i+14],9,-1019803690);c=md5_gg(c,d,a,b,x[i+3],14,-187363961);b=md5_gg(b,c,d,a,x[i+8],20,1163531501);a=md5_gg(a,b,c,d,x[i+13],5,-1444681467);d=md5_gg(d,a,b,c,x[i+2],9,-51403784);c=md5_gg(c,d,a,b,x[i+7],14,1735328473);b=md5_gg(b,c,d,a,x[i+12],20,-1926607734);a=md5_hh(a,b,c,d,x[i+5],4,-378558);d=md5_hh(d,a,b,c,x[i+8],11,-2022574463);c=md5_hh(c,d,a,b,x[i+11],16,1839030562);b=md5_hh(b,c,d,a,x[i+14],23,-35309556);a=md5_hh(a,b,c,d,x[i+1],4,-1530992060);d=md5_hh(d,a,b,c,x[i+4],11,1272893353);c=md5_hh(c,d,a,b,x[i+7],16,-155497632);b=md5_hh(b,c,d,a,x[i+10],23,-1094730640);a=md5_hh(a,b,c,d,x[i+13],4,681279174);d=md5_hh(d,a,b,c,x[i+0],11,-358537222);c=md5_hh(c,d,a,b,x[i+3],16,-722521979);b=md5_hh(b,c,d,a,x[i+6],23,76029189);a=md5_hh(a,b,c,d,x[i+9],4,-640364487);d=md5_hh(d,a,b,c,x[i+12],11,-421815835);c=md5_hh(c,d,a,b,x[i+15],16,530742520);b=md5_hh(b,c,d,a,x[i+2],23,-995338651);a=md5_ii(a,b,c,d,x[i+0],6,-198630844);d=md5_ii(d,a,b,c,x[i+7],10,1126891415);c=md5_ii(c,d,a,b,x[i+14],15,-1416354905);b=md5_ii(b,c,d,a,x[i+5],21,-57434055);a=md5_ii(a,b,c,d,x[i+12],6,1700485571);d=md5_ii(d,a,b,c,x[i+3],10,-1894986606);c=md5_ii(c,d,a,b,x[i+10],15,-1051523);b=md5_ii(b,c,d,a,x[i+1],21,-2054922799);a=md5_ii(a,b,c,d,x[i+8],6,1873313359);d=md5_ii(d,a,b,c,x[i+15],10,-30611744);c=md5_ii(c,d,a,b,x[i+6],15,-1560198380);b=md5_ii(b,c,d,a,x[i+13],21,1309151649);a=md5_ii(a,b,c,d,x[i+4],6,-145523070);d=md5_ii(d,a,b,c,x[i+11],10,-1120210379);c=md5_ii(c,d,a,b,x[i+2],15,718787259);b=md5_ii(b,c,d,a,x[i+9],21,-343485551);a=safe_add(a,olda);b=safe_add(b,oldb);c=safe_add(c,oldc);d=safe_add(d,oldd)}return Array(a,b,c,d)}function md5_cmn(q,a,b,x,s,t){return safe_add(bit_rol(safe_add(safe_add(a,q),safe_add(x,t)),s),b)}function md5_ff(a,b,c,d,x,s,t){return md5_cmn(b&c|~b&d,a,b,x,s,t)}function md5_gg(a,b,c,d,x,s,t){return md5_cmn(b&d|c&~d,a,b,x,s,t)}function md5_hh(a,b,c,d,x,s,t){return md5_cmn(b^c^d,a,b,x,s,t)}function md5_ii(a,b,c,d,x,s,t){return md5_cmn(c^(b|~d),a,b,x,s,t)}function safe_add(x,y){var lsw=(x&65535)+(y&65535);var msw=(x>>16)+(y>>16)+(lsw>>16);return msw<<16|lsw&65535}function bit_rol(num,cnt){return num<<cnt|num>>>32-cnt}module.exports=function md5(buf){return helpers.hash(buf,core_md5,16)}},{"./helpers":8}],11:[function(_dereq_,module,exports){(function(){var _global=this;var mathRNG,whatwgRNG;mathRNG=function(size){var bytes=new Array(size);var r;for(var i=0,r;i<size;i++){if((i&3)==0)r=Math.random()*4294967296;bytes[i]=r>>>((i&3)<<3)&255}return bytes};if(_global.crypto&&crypto.getRandomValues){whatwgRNG=function(size){var bytes=new Uint8Array(size);crypto.getRandomValues(bytes);return bytes}}module.exports=whatwgRNG||mathRNG})()},{}],12:[function(_dereq_,module,exports){var helpers=_dereq_("./helpers");function core_sha1(x,len){x[len>>5]|=128<<24-len%32;x[(len+64>>9<<4)+15]=len;var w=Array(80);var a=1732584193;var b=-271733879;var c=-1732584194;var d=271733878;var e=-1009589776;for(var i=0;i<x.length;i+=16){var olda=a;var oldb=b;var oldc=c;var oldd=d;var olde=e;for(var j=0;j<80;j++){if(j<16)w[j]=x[i+j];else w[j]=rol(w[j-3]^w[j-8]^w[j-14]^w[j-16],1);var t=safe_add(safe_add(rol(a,5),sha1_ft(j,b,c,d)),safe_add(safe_add(e,w[j]),sha1_kt(j)));e=d;d=c;c=rol(b,30);b=a;a=t}a=safe_add(a,olda);b=safe_add(b,oldb);c=safe_add(c,oldc);d=safe_add(d,oldd);e=safe_add(e,olde)}return Array(a,b,c,d,e)}function sha1_ft(t,b,c,d){if(t<20)return b&c|~b&d;if(t<40)return b^c^d;if(t<60)return b&c|b&d|c&d;return b^c^d}function sha1_kt(t){return t<20?1518500249:t<40?1859775393:t<60?-1894007588:-899497514}function safe_add(x,y){var lsw=(x&65535)+(y&65535);var msw=(x>>16)+(y>>16)+(lsw>>16);return msw<<16|lsw&65535}function rol(num,cnt){return num<<cnt|num>>>32-cnt}module.exports=function sha1(buf){return helpers.hash(buf,core_sha1,20,true)}},{"./helpers":8}],13:[function(_dereq_,module,exports){var helpers=_dereq_("./helpers");var safe_add=function(x,y){var lsw=(x&65535)+(y&65535);var msw=(x>>16)+(y>>16)+(lsw>>16);return msw<<16|lsw&65535};var S=function(X,n){return X>>>n|X<<32-n};var R=function(X,n){return X>>>n};var Ch=function(x,y,z){return x&y^~x&z};var Maj=function(x,y,z){return x&y^x&z^y&z};var Sigma0256=function(x){return S(x,2)^S(x,13)^S(x,22)};var Sigma1256=function(x){return S(x,6)^S(x,11)^S(x,25)};var Gamma0256=function(x){return S(x,7)^S(x,18)^R(x,3)};var Gamma1256=function(x){return S(x,17)^S(x,19)^R(x,10)};var core_sha256=function(m,l){var K=new Array(1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298);var HASH=new Array(1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225);var W=new Array(64);var a,b,c,d,e,f,g,h,i,j;var T1,T2;m[l>>5]|=128<<24-l%32;m[(l+64>>9<<4)+15]=l;for(var i=0;i<m.length;i+=16){a=HASH[0];b=HASH[1];c=HASH[2];d=HASH[3];e=HASH[4];f=HASH[5];g=HASH[6];h=HASH[7];for(var j=0;j<64;j++){if(j<16){W[j]=m[j+i]}else{W[j]=safe_add(safe_add(safe_add(Gamma1256(W[j-2]),W[j-7]),Gamma0256(W[j-15])),W[j-16])}T1=safe_add(safe_add(safe_add(safe_add(h,Sigma1256(e)),Ch(e,f,g)),K[j]),W[j]);T2=safe_add(Sigma0256(a),Maj(a,b,c));h=g;g=f;f=e;e=safe_add(d,T1);d=c;c=b;b=a;a=safe_add(T1,T2)}HASH[0]=safe_add(a,HASH[0]);HASH[1]=safe_add(b,HASH[1]);HASH[2]=safe_add(c,HASH[2]);HASH[3]=safe_add(d,HASH[3]);HASH[4]=safe_add(e,HASH[4]);HASH[5]=safe_add(f,HASH[5]);HASH[6]=safe_add(g,HASH[6]);HASH[7]=safe_add(h,HASH[7])}return HASH};module.exports=function sha256(buf){return helpers.hash(buf,core_sha256,32,true)}},{"./helpers":8}],14:[function(_dereq_,module,exports){if(typeof Object.create==="function"){module.exports=function inherits(ctor,superCtor){ctor.super_=superCtor;ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:false,writable:true,configurable:true}})}}else{module.exports=function inherits(ctor,superCtor){ctor.super_=superCtor;var TempCtor=function(){};TempCtor.prototype=superCtor.prototype;ctor.prototype=new TempCtor;ctor.prototype.constructor=ctor}}},{}],15:[function(_dereq_,module,exports){var process=module.exports={};process.nextTick=function(){var canSetImmediate=typeof window!=="undefined"&&window.setImmediate;var canPost=typeof window!=="undefined"&&window.postMessage&&window.addEventListener;if(canSetImmediate){return function(f){return window.setImmediate(f)}}if(canPost){var queue=[];window.addEventListener("message",function(ev){var source=ev.source;if((source===window||source===null)&&ev.data==="process-tick"){ev.stopPropagation();if(queue.length>0){var fn=queue.shift();fn()}}},true);return function nextTick(fn){queue.push(fn);window.postMessage("process-tick","*")}}return function nextTick(fn){setTimeout(fn,0)}}();process.title="browser";process.browser=true;process.env={};process.argv=[];function noop(){}process.on=noop;process.addListener=noop;process.once=noop;process.off=noop;process.removeListener=noop;process.removeAllListeners=noop;process.emit=noop;process.binding=function(name){throw new Error("process.binding is not supported")};process.cwd=function(){return"/"};process.chdir=function(dir){throw new Error("process.chdir is not supported")}},{}],16:[function(_dereq_,module,exports){module.exports=_dereq_(2)},{}],17:[function(_dereq_,module,exports){module.exports=_dereq_(3)},{"./support/isBuffer":16,FWaASH:15,inherits:14}],18:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./evpkdf"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var BlockCipher=C_lib.BlockCipher;var C_algo=C.algo;var SBOX=[];var INV_SBOX=[];var SUB_MIX_0=[];var SUB_MIX_1=[];var SUB_MIX_2=[];var SUB_MIX_3=[];var INV_SUB_MIX_0=[];var INV_SUB_MIX_1=[];var INV_SUB_MIX_2=[];var INV_SUB_MIX_3=[];(function(){var d=[];for(var i=0;i<256;i++){if(i<128){d[i]=i<<1}else{d[i]=i<<1^283}}var x=0;var xi=0;for(var i=0;i<256;i++){var sx=xi^xi<<1^xi<<2^xi<<3^xi<<4;sx=sx>>>8^sx&255^99;SBOX[x]=sx;INV_SBOX[sx]=x;var x2=d[x];var x4=d[x2];var x8=d[x4];var t=d[sx]*257^sx*16843008;SUB_MIX_0[x]=t<<24|t>>>8;SUB_MIX_1[x]=t<<16|t>>>16;SUB_MIX_2[x]=t<<8|t>>>24;SUB_MIX_3[x]=t;var t=x8*16843009^x4*65537^x2*257^x*16843008;INV_SUB_MIX_0[sx]=t<<24|t>>>8;INV_SUB_MIX_1[sx]=t<<16|t>>>16;INV_SUB_MIX_2[sx]=t<<8|t>>>24;INV_SUB_MIX_3[sx]=t;if(!x){x=xi=1}else{x=x2^d[d[d[x8^x2]]];xi^=d[d[xi]]}}})();var RCON=[0,1,2,4,8,16,32,64,128,27,54];var AES=C_algo.AES=BlockCipher.extend({_doReset:function(){var key=this._key;var keyWords=key.words;var keySize=key.sigBytes/4;var nRounds=this._nRounds=keySize+6;var ksRows=(nRounds+1)*4;var keySchedule=this._keySchedule=[];for(var ksRow=0;ksRow<ksRows;ksRow++){if(ksRow<keySize){keySchedule[ksRow]=keyWords[ksRow]}else{var t=keySchedule[ksRow-1];if(!(ksRow%keySize)){t=t<<8|t>>>24;t=SBOX[t>>>24]<<24|SBOX[t>>>16&255]<<16|SBOX[t>>>8&255]<<8|SBOX[t&255];t^=RCON[ksRow/keySize|0]<<24}else if(keySize>6&&ksRow%keySize==4){t=SBOX[t>>>24]<<24|SBOX[t>>>16&255]<<16|SBOX[t>>>8&255]<<8|SBOX[t&255]}keySchedule[ksRow]=keySchedule[ksRow-keySize]^t}}var invKeySchedule=this._invKeySchedule=[];for(var invKsRow=0;invKsRow<ksRows;invKsRow++){var ksRow=ksRows-invKsRow;if(invKsRow%4){var t=keySchedule[ksRow]}else{var t=keySchedule[ksRow-4]}if(invKsRow<4||ksRow<=4){invKeySchedule[invKsRow]=t}else{invKeySchedule[invKsRow]=INV_SUB_MIX_0[SBOX[t>>>24]]^INV_SUB_MIX_1[SBOX[t>>>16&255]]^INV_SUB_MIX_2[SBOX[t>>>8&255]]^INV_SUB_MIX_3[SBOX[t&255]]}}},encryptBlock:function(M,offset){this._doCryptBlock(M,offset,this._keySchedule,SUB_MIX_0,SUB_MIX_1,SUB_MIX_2,SUB_MIX_3,SBOX)},decryptBlock:function(M,offset){var t=M[offset+1];M[offset+1]=M[offset+3];M[offset+3]=t;this._doCryptBlock(M,offset,this._invKeySchedule,INV_SUB_MIX_0,INV_SUB_MIX_1,INV_SUB_MIX_2,INV_SUB_MIX_3,INV_SBOX);var t=M[offset+1];M[offset+1]=M[offset+3];M[offset+3]=t},_doCryptBlock:function(M,offset,keySchedule,SUB_MIX_0,SUB_MIX_1,SUB_MIX_2,SUB_MIX_3,SBOX){var nRounds=this._nRounds;var s0=M[offset]^keySchedule[0];var s1=M[offset+1]^keySchedule[1];var s2=M[offset+2]^keySchedule[2];var s3=M[offset+3]^keySchedule[3];var ksRow=4;for(var round=1;round<nRounds;round++){var t0=SUB_MIX_0[s0>>>24]^SUB_MIX_1[s1>>>16&255]^SUB_MIX_2[s2>>>8&255]^SUB_MIX_3[s3&255]^keySchedule[ksRow++];var t1=SUB_MIX_0[s1>>>24]^SUB_MIX_1[s2>>>16&255]^SUB_MIX_2[s3>>>8&255]^SUB_MIX_3[s0&255]^keySchedule[ksRow++];var t2=SUB_MIX_0[s2>>>24]^SUB_MIX_1[s3>>>16&255]^SUB_MIX_2[s0>>>8&255]^SUB_MIX_3[s1&255]^keySchedule[ksRow++];var t3=SUB_MIX_0[s3>>>24]^SUB_MIX_1[s0>>>16&255]^SUB_MIX_2[s1>>>8&255]^SUB_MIX_3[s2&255]^keySchedule[ksRow++];s0=t0;s1=t1;s2=t2;s3=t3}var t0=(SBOX[s0>>>24]<<24|SBOX[s1>>>16&255]<<16|SBOX[s2>>>8&255]<<8|SBOX[s3&255])^keySchedule[ksRow++];var t1=(SBOX[s1>>>24]<<24|SBOX[s2>>>16&255]<<16|SBOX[s3>>>8&255]<<8|SBOX[s0&255])^keySchedule[ksRow++];var t2=(SBOX[s2>>>24]<<24|SBOX[s3>>>16&255]<<16|SBOX[s0>>>8&255]<<8|SBOX[s1&255])^keySchedule[ksRow++];var t3=(SBOX[s3>>>24]<<24|SBOX[s0>>>16&255]<<16|SBOX[s1>>>8&255]<<8|SBOX[s2&255])^keySchedule[ksRow++];M[offset]=t0;M[offset+1]=t1;M[offset+2]=t2;M[offset+3]=t3},keySize:256/32});C.AES=BlockCipher._createHelper(AES)})();return CryptoJS.AES})},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":29}],19:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.lib.Cipher||function(undefined){var C=CryptoJS;var C_lib=C.lib;var Base=C_lib.Base;var WordArray=C_lib.WordArray;var BufferedBlockAlgorithm=C_lib.BufferedBlockAlgorithm;var C_enc=C.enc;var Utf8=C_enc.Utf8;var Base64=C_enc.Base64;var C_algo=C.algo;var EvpKDF=C_algo.EvpKDF;var Cipher=C_lib.Cipher=BufferedBlockAlgorithm.extend({cfg:Base.extend(),createEncryptor:function(key,cfg){return this.create(this._ENC_XFORM_MODE,key,cfg)},createDecryptor:function(key,cfg){return this.create(this._DEC_XFORM_MODE,key,cfg)},init:function(xformMode,key,cfg){this.cfg=this.cfg.extend(cfg);this._xformMode=xformMode;this._key=key;this.reset()},reset:function(){BufferedBlockAlgorithm.reset.call(this);this._doReset()},process:function(dataUpdate){this._append(dataUpdate);return this._process()},finalize:function(dataUpdate){if(dataUpdate){this._append(dataUpdate)}var finalProcessedData=this._doFinalize();return finalProcessedData},keySize:128/32,ivSize:128/32,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(){function selectCipherStrategy(key){if(typeof key=="string"){return PasswordBasedCipher}else{return SerializableCipher}}return function(cipher){return{encrypt:function(message,key,cfg){return selectCipherStrategy(key).encrypt(cipher,message,key,cfg)},decrypt:function(ciphertext,key,cfg){return selectCipherStrategy(key).decrypt(cipher,ciphertext,key,cfg)}}}}()});var StreamCipher=C_lib.StreamCipher=Cipher.extend({_doFinalize:function(){var finalProcessedBlocks=this._process(!!"flush");return finalProcessedBlocks},blockSize:1});var C_mode=C.mode={};var BlockCipherMode=C_lib.BlockCipherMode=Base.extend({createEncryptor:function(cipher,iv){return this.Encryptor.create(cipher,iv)},createDecryptor:function(cipher,iv){return this.Decryptor.create(cipher,iv)},init:function(cipher,iv){this._cipher=cipher;this._iv=iv}});var CBC=C_mode.CBC=function(){var CBC=BlockCipherMode.extend();CBC.Encryptor=CBC.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;xorBlock.call(this,words,offset,blockSize);cipher.encryptBlock(words,offset);this._prevBlock=words.slice(offset,offset+blockSize)}});CBC.Decryptor=CBC.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;var thisBlock=words.slice(offset,offset+blockSize);cipher.decryptBlock(words,offset);xorBlock.call(this,words,offset,blockSize);this._prevBlock=thisBlock}});function xorBlock(words,offset,blockSize){var iv=this._iv;if(iv){var block=iv;this._iv=undefined}else{var block=this._prevBlock}for(var i=0;i<blockSize;i++){words[offset+i]^=block[i]}}return CBC}();var C_pad=C.pad={};var Pkcs7=C_pad.Pkcs7={pad:function(data,blockSize){var blockSizeBytes=blockSize*4;var nPaddingBytes=blockSizeBytes-data.sigBytes%blockSizeBytes;var paddingWord=nPaddingBytes<<24|nPaddingBytes<<16|nPaddingBytes<<8|nPaddingBytes;var paddingWords=[];for(var i=0;i<nPaddingBytes;i+=4){paddingWords.push(paddingWord)}var padding=WordArray.create(paddingWords,nPaddingBytes);data.concat(padding)},unpad:function(data){var nPaddingBytes=data.words[data.sigBytes-1>>>2]&255;data.sigBytes-=nPaddingBytes}};var BlockCipher=C_lib.BlockCipher=Cipher.extend({cfg:Cipher.cfg.extend({mode:CBC,padding:Pkcs7}),reset:function(){Cipher.reset.call(this);var cfg=this.cfg;var iv=cfg.iv;var mode=cfg.mode;if(this._xformMode==this._ENC_XFORM_MODE){var modeCreator=mode.createEncryptor}else{var modeCreator=mode.createDecryptor;this._minBufferSize=1}this._mode=modeCreator.call(mode,this,iv&&iv.words)},_doProcessBlock:function(words,offset){this._mode.processBlock(words,offset)},_doFinalize:function(){var padding=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){padding.pad(this._data,this.blockSize);var finalProcessedBlocks=this._process(!!"flush")}else{var finalProcessedBlocks=this._process(!!"flush");padding.unpad(finalProcessedBlocks)}return finalProcessedBlocks},blockSize:128/32});var CipherParams=C_lib.CipherParams=Base.extend({init:function(cipherParams){this.mixIn(cipherParams)},toString:function(formatter){return(formatter||this.formatter).stringify(this)}});var C_format=C.format={};var OpenSSLFormatter=C_format.OpenSSL={stringify:function(cipherParams){var ciphertext=cipherParams.ciphertext;var salt=cipherParams.salt;if(salt){var wordArray=WordArray.create([1398893684,1701076831]).concat(salt).concat(ciphertext)}else{var wordArray=ciphertext}return wordArray.toString(Base64)},parse:function(openSSLStr){var ciphertext=Base64.parse(openSSLStr);var ciphertextWords=ciphertext.words;if(ciphertextWords[0]==1398893684&&ciphertextWords[1]==1701076831){var salt=WordArray.create(ciphertextWords.slice(2,4));ciphertextWords.splice(0,4);ciphertext.sigBytes-=16}return CipherParams.create({ciphertext:ciphertext,salt:salt})}};var SerializableCipher=C_lib.SerializableCipher=Base.extend({cfg:Base.extend({format:OpenSSLFormatter}),encrypt:function(cipher,message,key,cfg){cfg=this.cfg.extend(cfg);var encryptor=cipher.createEncryptor(key,cfg);var ciphertext=encryptor.finalize(message);var cipherCfg=encryptor.cfg;return CipherParams.create({ciphertext:ciphertext,key:key,iv:cipherCfg.iv,algorithm:cipher,mode:cipherCfg.mode,padding:cipherCfg.padding,blockSize:cipher.blockSize,formatter:cfg.format})},decrypt:function(cipher,ciphertext,key,cfg){cfg=this.cfg.extend(cfg);ciphertext=this._parse(ciphertext,cfg.format);var plaintext=cipher.createDecryptor(key,cfg).finalize(ciphertext.ciphertext);return plaintext},_parse:function(ciphertext,format){if(typeof ciphertext=="string"){return format.parse(ciphertext,this)}else{return ciphertext}}});var C_kdf=C.kdf={};var OpenSSLKdf=C_kdf.OpenSSL={execute:function(password,keySize,ivSize,salt){if(!salt){salt=WordArray.random(64/8)}var key=EvpKDF.create({keySize:keySize+ivSize}).compute(password,salt);var iv=WordArray.create(key.words.slice(keySize),ivSize*4);key.sigBytes=keySize*4;return CipherParams.create({key:key,iv:iv,salt:salt})}};var PasswordBasedCipher=C_lib.PasswordBasedCipher=SerializableCipher.extend({cfg:SerializableCipher.cfg.extend({kdf:OpenSSLKdf}),encrypt:function(cipher,message,password,cfg){cfg=this.cfg.extend(cfg);var derivedParams=cfg.kdf.execute(password,cipher.keySize,cipher.ivSize);cfg.iv=derivedParams.iv;var ciphertext=SerializableCipher.encrypt.call(this,cipher,message,derivedParams.key,cfg);
ciphertext.mixIn(derivedParams);return ciphertext},decrypt:function(cipher,ciphertext,password,cfg){cfg=this.cfg.extend(cfg);ciphertext=this._parse(ciphertext,cfg.format);var derivedParams=cfg.kdf.execute(password,cipher.keySize,cipher.ivSize,ciphertext.salt);cfg.iv=derivedParams.iv;var plaintext=SerializableCipher.decrypt.call(this,cipher,ciphertext,derivedParams.key,cfg);return plaintext}})}()})},{"./core":20}],20:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory()}else if(typeof define==="function"&&define.amd){define([],factory)}else{root.CryptoJS=factory()}})(this,function(){var CryptoJS=CryptoJS||function(Math,undefined){var C={};var C_lib=C.lib={};var Base=C_lib.Base=function(){function F(){}return{extend:function(overrides){F.prototype=this;var subtype=new F;if(overrides){subtype.mixIn(overrides)}if(!subtype.hasOwnProperty("init")){subtype.init=function(){subtype.$super.init.apply(this,arguments)}}subtype.init.prototype=subtype;subtype.$super=this;return subtype},create:function(){var instance=this.extend();instance.init.apply(instance,arguments);return instance},init:function(){},mixIn:function(properties){for(var propertyName in properties){if(properties.hasOwnProperty(propertyName)){this[propertyName]=properties[propertyName]}}if(properties.hasOwnProperty("toString")){this.toString=properties.toString}},clone:function(){return this.init.prototype.extend(this)}}}();var WordArray=C_lib.WordArray=Base.extend({init:function(words,sigBytes){words=this.words=words||[];if(sigBytes!=undefined){this.sigBytes=sigBytes}else{this.sigBytes=words.length*4}},toString:function(encoder){return(encoder||Hex).stringify(this)},concat:function(wordArray){var thisWords=this.words;var thatWords=wordArray.words;var thisSigBytes=this.sigBytes;var thatSigBytes=wordArray.sigBytes;this.clamp();if(thisSigBytes%4){for(var i=0;i<thatSigBytes;i++){var thatByte=thatWords[i>>>2]>>>24-i%4*8&255;thisWords[thisSigBytes+i>>>2]|=thatByte<<24-(thisSigBytes+i)%4*8}}else if(thatWords.length>256){for(var i=0;i<thatSigBytes;i+=4){thisWords[thisSigBytes+i>>>2]=thatWords[i>>>2]}}else{thisWords.push.apply(thisWords,thatWords)}this.sigBytes+=thatSigBytes;return this},clamp:function(){var words=this.words;var sigBytes=this.sigBytes;words[sigBytes>>>2]&=4294967295<<32-sigBytes%4*8;words.length=Math.ceil(sigBytes/4)},clone:function(){var clone=Base.clone.call(this);clone.words=this.words.slice(0);return clone},random:function(nBytes){var words=[];for(var i=0;i<nBytes;i+=4){words.push(Math.random()*4294967296|0)}return new WordArray.init(words,nBytes)}});var C_enc=C.enc={};var Hex=C_enc.Hex={stringify:function(wordArray){var words=wordArray.words;var sigBytes=wordArray.sigBytes;var hexChars=[];for(var i=0;i<sigBytes;i++){var bite=words[i>>>2]>>>24-i%4*8&255;hexChars.push((bite>>>4).toString(16));hexChars.push((bite&15).toString(16))}return hexChars.join("")},parse:function(hexStr){var hexStrLength=hexStr.length;var words=[];for(var i=0;i<hexStrLength;i+=2){words[i>>>3]|=parseInt(hexStr.substr(i,2),16)<<24-i%8*4}return new WordArray.init(words,hexStrLength/2)}};var Latin1=C_enc.Latin1={stringify:function(wordArray){var words=wordArray.words;var sigBytes=wordArray.sigBytes;var latin1Chars=[];for(var i=0;i<sigBytes;i++){var bite=words[i>>>2]>>>24-i%4*8&255;latin1Chars.push(String.fromCharCode(bite))}return latin1Chars.join("")},parse:function(latin1Str){var latin1StrLength=latin1Str.length;var words=[];for(var i=0;i<latin1StrLength;i++){words[i>>>2]|=(latin1Str.charCodeAt(i)&255)<<24-i%4*8}return new WordArray.init(words,latin1StrLength)}};var Utf8=C_enc.Utf8={stringify:function(wordArray){try{return decodeURIComponent(escape(Latin1.stringify(wordArray)))}catch(e){throw new Error("Malformed UTF-8 data")}},parse:function(utf8Str){return Latin1.parse(unescape(encodeURIComponent(utf8Str)))}};var BufferedBlockAlgorithm=C_lib.BufferedBlockAlgorithm=Base.extend({reset:function(){this._data=new WordArray.init;this._nDataBytes=0},_append:function(data){if(typeof data=="string"){data=Utf8.parse(data)}this._data.concat(data);this._nDataBytes+=data.sigBytes},_process:function(doFlush){var data=this._data;var dataWords=data.words;var dataSigBytes=data.sigBytes;var blockSize=this.blockSize;var blockSizeBytes=blockSize*4;var nBlocksReady=dataSigBytes/blockSizeBytes;if(doFlush){nBlocksReady=Math.ceil(nBlocksReady)}else{nBlocksReady=Math.max((nBlocksReady|0)-this._minBufferSize,0)}var nWordsReady=nBlocksReady*blockSize;var nBytesReady=Math.min(nWordsReady*4,dataSigBytes);if(nWordsReady){for(var offset=0;offset<nWordsReady;offset+=blockSize){this._doProcessBlock(dataWords,offset)}var processedWords=dataWords.splice(0,nWordsReady);data.sigBytes-=nBytesReady}return new WordArray.init(processedWords,nBytesReady)},clone:function(){var clone=Base.clone.call(this);clone._data=this._data.clone();return clone},_minBufferSize:0});var Hasher=C_lib.Hasher=BufferedBlockAlgorithm.extend({cfg:Base.extend(),init:function(cfg){this.cfg=this.cfg.extend(cfg);this.reset()},reset:function(){BufferedBlockAlgorithm.reset.call(this);this._doReset()},update:function(messageUpdate){this._append(messageUpdate);this._process();return this},finalize:function(messageUpdate){if(messageUpdate){this._append(messageUpdate)}var hash=this._doFinalize();return hash},blockSize:512/32,_createHelper:function(hasher){return function(message,cfg){return new hasher.init(cfg).finalize(message)}},_createHmacHelper:function(hasher){return function(message,key){return new C_algo.HMAC.init(hasher,key).finalize(message)}}});var C_algo=C.algo={};return C}(Math);return CryptoJS})},{}],21:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var C_enc=C.enc;var Base64=C_enc.Base64={stringify:function(wordArray){var words=wordArray.words;var sigBytes=wordArray.sigBytes;var map=this._map;wordArray.clamp();var base64Chars=[];for(var i=0;i<sigBytes;i+=3){var byte1=words[i>>>2]>>>24-i%4*8&255;var byte2=words[i+1>>>2]>>>24-(i+1)%4*8&255;var byte3=words[i+2>>>2]>>>24-(i+2)%4*8&255;var triplet=byte1<<16|byte2<<8|byte3;for(var j=0;j<4&&i+j*.75<sigBytes;j++){base64Chars.push(map.charAt(triplet>>>6*(3-j)&63))}}var paddingChar=map.charAt(64);if(paddingChar){while(base64Chars.length%4){base64Chars.push(paddingChar)}}return base64Chars.join("")},parse:function(base64Str){var base64StrLength=base64Str.length;var map=this._map;var paddingChar=map.charAt(64);if(paddingChar){var paddingIndex=base64Str.indexOf(paddingChar);if(paddingIndex!=-1){base64StrLength=paddingIndex}}var words=[];var nBytes=0;for(var i=0;i<base64StrLength;i++){if(i%4){var bits1=map.indexOf(base64Str.charAt(i-1))<<i%4*2;var bits2=map.indexOf(base64Str.charAt(i))>>>6-i%4*2;words[nBytes>>>2]|=(bits1|bits2)<<24-nBytes%4*8;nBytes++}}return WordArray.create(words,nBytes)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();return CryptoJS.enc.Base64})},{"./core":20}],22:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var C_enc=C.enc;var Utf16BE=C_enc.Utf16=C_enc.Utf16BE={stringify:function(wordArray){var words=wordArray.words;var sigBytes=wordArray.sigBytes;var utf16Chars=[];for(var i=0;i<sigBytes;i+=2){var codePoint=words[i>>>2]>>>16-i%4*8&65535;utf16Chars.push(String.fromCharCode(codePoint))}return utf16Chars.join("")},parse:function(utf16Str){var utf16StrLength=utf16Str.length;var words=[];for(var i=0;i<utf16StrLength;i++){words[i>>>1]|=utf16Str.charCodeAt(i)<<16-i%2*16}return WordArray.create(words,utf16StrLength*2)}};C_enc.Utf16LE={stringify:function(wordArray){var words=wordArray.words;var sigBytes=wordArray.sigBytes;var utf16Chars=[];for(var i=0;i<sigBytes;i+=2){var codePoint=swapEndian(words[i>>>2]>>>16-i%4*8&65535);utf16Chars.push(String.fromCharCode(codePoint))}return utf16Chars.join("")},parse:function(utf16Str){var utf16StrLength=utf16Str.length;var words=[];for(var i=0;i<utf16StrLength;i++){words[i>>>1]|=swapEndian(utf16Str.charCodeAt(i)<<16-i%2*16)}return WordArray.create(words,utf16StrLength*2)}};function swapEndian(word){return word<<8&4278255360|word>>>8&16711935}})();return CryptoJS.enc.Utf16})},{"./core":20}],23:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./sha1"),_dereq_("./hmac"))}else if(typeof define==="function"&&define.amd){define(["./core","./sha1","./hmac"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var Base=C_lib.Base;var WordArray=C_lib.WordArray;var C_algo=C.algo;var MD5=C_algo.MD5;var EvpKDF=C_algo.EvpKDF=Base.extend({cfg:Base.extend({keySize:128/32,hasher:MD5,iterations:1}),init:function(cfg){this.cfg=this.cfg.extend(cfg)},compute:function(password,salt){var cfg=this.cfg;var hasher=cfg.hasher.create();var derivedKey=WordArray.create();var derivedKeyWords=derivedKey.words;var keySize=cfg.keySize;var iterations=cfg.iterations;while(derivedKeyWords.length<keySize){if(block){hasher.update(block)}var block=hasher.update(password).finalize(salt);hasher.reset();for(var i=1;i<iterations;i++){block=hasher.finalize(block);hasher.reset()}derivedKey.concat(block)}derivedKey.sigBytes=keySize*4;return derivedKey}});C.EvpKDF=function(password,salt,cfg){return EvpKDF.create(cfg).compute(password,salt)}})();return CryptoJS.EvpKDF})},{"./core":20,"./hmac":26,"./sha1":45}],24:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(undefined){var C=CryptoJS;var C_lib=C.lib;var CipherParams=C_lib.CipherParams;var C_enc=C.enc;var Hex=C_enc.Hex;var C_format=C.format;var HexFormatter=C_format.Hex={stringify:function(cipherParams){return cipherParams.ciphertext.toString(Hex)},parse:function(input){var ciphertext=Hex.parse(input);return CipherParams.create({ciphertext:ciphertext})}}})();return CryptoJS.format.Hex})},{"./cipher-core":19,"./core":20}],25:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./sha256"),_dereq_("./hmac"))}else if(typeof define==="function"&&define.amd){define(["./core","./sha256","./hmac"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){return CryptoJS.HmacSHA256})},{"./core":20,"./hmac":26,"./sha256":47}],26:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var Base=C_lib.Base;var C_enc=C.enc;var Utf8=C_enc.Utf8;var C_algo=C.algo;var HMAC=C_algo.HMAC=Base.extend({init:function(hasher,key){hasher=this._hasher=new hasher.init;if(typeof key=="string"){key=Utf8.parse(key)}var hasherBlockSize=hasher.blockSize;var hasherBlockSizeBytes=hasherBlockSize*4;if(key.sigBytes>hasherBlockSizeBytes){key=hasher.finalize(key)}key.clamp();var oKey=this._oKey=key.clone();var iKey=this._iKey=key.clone();var oKeyWords=oKey.words;var iKeyWords=iKey.words;for(var i=0;i<hasherBlockSize;i++){oKeyWords[i]^=1549556828;iKeyWords[i]^=909522486}oKey.sigBytes=iKey.sigBytes=hasherBlockSizeBytes;this.reset()},reset:function(){var hasher=this._hasher;hasher.reset();hasher.update(this._iKey)},update:function(messageUpdate){this._hasher.update(messageUpdate);return this},finalize:function(messageUpdate){var hasher=this._hasher;var innerHash=hasher.finalize(messageUpdate);hasher.reset();var hmac=hasher.finalize(this._oKey.clone().concat(innerHash));return hmac}})})()})},{"./core":20}],27:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./x64-core"),_dereq_("./lib-typedarrays"),_dereq_("./enc-utf16"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./sha1"),_dereq_("./sha256"),_dereq_("./sha224"),_dereq_("./sha512"),_dereq_("./sha384"),_dereq_("./sha3"),_dereq_("./ripemd160"),_dereq_("./hmac"),_dereq_("./pbkdf2"),_dereq_("./evpkdf"),_dereq_("./cipher-core"),_dereq_("./mode-cfb"),_dereq_("./mode-ctr"),_dereq_("./mode-ctr-gladman"),_dereq_("./mode-ofb"),_dereq_("./mode-ecb"),_dereq_("./pad-ansix923"),_dereq_("./pad-iso10126"),_dereq_("./pad-iso97971"),_dereq_("./pad-zeropadding"),_dereq_("./pad-nopadding"),_dereq_("./format-hex"),_dereq_("./aes"),_dereq_("./tripledes"),_dereq_("./rc4"),_dereq_("./rabbit"),_dereq_("./rabbit-legacy"))}else if(typeof define==="function"&&define.amd){define(["./core","./x64-core","./lib-typedarrays","./enc-utf16","./enc-base64","./md5","./sha1","./sha256","./sha224","./sha512","./sha384","./sha3","./ripemd160","./hmac","./pbkdf2","./evpkdf","./cipher-core","./mode-cfb","./mode-ctr","./mode-ctr-gladman","./mode-ofb","./mode-ecb","./pad-ansix923","./pad-iso10126","./pad-iso97971","./pad-zeropadding","./pad-nopadding","./format-hex","./aes","./tripledes","./rc4","./rabbit","./rabbit-legacy"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){return CryptoJS})},{"./aes":18,"./cipher-core":19,"./core":20,"./enc-base64":21,"./enc-utf16":22,"./evpkdf":23,"./format-hex":24,"./hmac":26,"./lib-typedarrays":28,"./md5":29,"./mode-cfb":30,"./mode-ctr":32,"./mode-ctr-gladman":31,"./mode-ecb":33,"./mode-ofb":34,"./pad-ansix923":35,"./pad-iso10126":36,"./pad-iso97971":37,"./pad-nopadding":38,"./pad-zeropadding":39,"./pbkdf2":40,"./rabbit":42,"./rabbit-legacy":41,"./rc4":43,"./ripemd160":44,"./sha1":45,"./sha224":46,"./sha256":47,"./sha3":48,"./sha384":49,"./sha512":50,"./tripledes":51,"./x64-core":52}],28:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){if(typeof ArrayBuffer!="function"){return}var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var superInit=WordArray.init;var subInit=WordArray.init=function(typedArray){if(typedArray instanceof ArrayBuffer){typedArray=new Uint8Array(typedArray)}if(typedArray instanceof Int8Array||typedArray instanceof Uint8ClampedArray||typedArray instanceof Int16Array||typedArray instanceof Uint16Array||typedArray instanceof Int32Array||typedArray instanceof Uint32Array||typedArray instanceof Float32Array||typedArray instanceof Float64Array){typedArray=new Uint8Array(typedArray.buffer,typedArray.byteOffset,typedArray.byteLength)}if(typedArray instanceof Uint8Array){var typedArrayByteLength=typedArray.byteLength;var words=[];for(var i=0;i<typedArrayByteLength;i++){words[i>>>2]|=typedArray[i]<<24-i%4*8}superInit.call(this,words,typedArrayByteLength)}else{superInit.apply(this,arguments)}};subInit.prototype=WordArray})();return CryptoJS.lib.WordArray})},{"./core":20}],29:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(Math){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var Hasher=C_lib.Hasher;var C_algo=C.algo;var T=[];(function(){for(var i=0;i<64;i++){T[i]=Math.abs(Math.sin(i+1))*4294967296|0}})();var MD5=C_algo.MD5=Hasher.extend({_doReset:function(){this._hash=new WordArray.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(M,offset){for(var i=0;i<16;i++){var offset_i=offset+i;var M_offset_i=M[offset_i];M[offset_i]=(M_offset_i<<8|M_offset_i>>>24)&16711935|(M_offset_i<<24|M_offset_i>>>8)&4278255360}var H=this._hash.words;var M_offset_0=M[offset+0];var M_offset_1=M[offset+1];var M_offset_2=M[offset+2];var M_offset_3=M[offset+3];var M_offset_4=M[offset+4];var M_offset_5=M[offset+5];var M_offset_6=M[offset+6];var M_offset_7=M[offset+7];var M_offset_8=M[offset+8];var M_offset_9=M[offset+9];var M_offset_10=M[offset+10];var M_offset_11=M[offset+11];var M_offset_12=M[offset+12];var M_offset_13=M[offset+13];var M_offset_14=M[offset+14];var M_offset_15=M[offset+15];var a=H[0];var b=H[1];var c=H[2];var d=H[3];a=FF(a,b,c,d,M_offset_0,7,T[0]);d=FF(d,a,b,c,M_offset_1,12,T[1]);c=FF(c,d,a,b,M_offset_2,17,T[2]);b=FF(b,c,d,a,M_offset_3,22,T[3]);a=FF(a,b,c,d,M_offset_4,7,T[4]);d=FF(d,a,b,c,M_offset_5,12,T[5]);c=FF(c,d,a,b,M_offset_6,17,T[6]);b=FF(b,c,d,a,M_offset_7,22,T[7]);a=FF(a,b,c,d,M_offset_8,7,T[8]);d=FF(d,a,b,c,M_offset_9,12,T[9]);c=FF(c,d,a,b,M_offset_10,17,T[10]);b=FF(b,c,d,a,M_offset_11,22,T[11]);a=FF(a,b,c,d,M_offset_12,7,T[12]);d=FF(d,a,b,c,M_offset_13,12,T[13]);c=FF(c,d,a,b,M_offset_14,17,T[14]);b=FF(b,c,d,a,M_offset_15,22,T[15]);a=GG(a,b,c,d,M_offset_1,5,T[16]);d=GG(d,a,b,c,M_offset_6,9,T[17]);c=GG(c,d,a,b,M_offset_11,14,T[18]);b=GG(b,c,d,a,M_offset_0,20,T[19]);a=GG(a,b,c,d,M_offset_5,5,T[20]);d=GG(d,a,b,c,M_offset_10,9,T[21]);c=GG(c,d,a,b,M_offset_15,14,T[22]);b=GG(b,c,d,a,M_offset_4,20,T[23]);a=GG(a,b,c,d,M_offset_9,5,T[24]);d=GG(d,a,b,c,M_offset_14,9,T[25]);c=GG(c,d,a,b,M_offset_3,14,T[26]);b=GG(b,c,d,a,M_offset_8,20,T[27]);a=GG(a,b,c,d,M_offset_13,5,T[28]);d=GG(d,a,b,c,M_offset_2,9,T[29]);c=GG(c,d,a,b,M_offset_7,14,T[30]);b=GG(b,c,d,a,M_offset_12,20,T[31]);a=HH(a,b,c,d,M_offset_5,4,T[32]);d=HH(d,a,b,c,M_offset_8,11,T[33]);c=HH(c,d,a,b,M_offset_11,16,T[34]);b=HH(b,c,d,a,M_offset_14,23,T[35]);a=HH(a,b,c,d,M_offset_1,4,T[36]);d=HH(d,a,b,c,M_offset_4,11,T[37]);c=HH(c,d,a,b,M_offset_7,16,T[38]);b=HH(b,c,d,a,M_offset_10,23,T[39]);a=HH(a,b,c,d,M_offset_13,4,T[40]);d=HH(d,a,b,c,M_offset_0,11,T[41]);c=HH(c,d,a,b,M_offset_3,16,T[42]);b=HH(b,c,d,a,M_offset_6,23,T[43]);a=HH(a,b,c,d,M_offset_9,4,T[44]);d=HH(d,a,b,c,M_offset_12,11,T[45]);c=HH(c,d,a,b,M_offset_15,16,T[46]);b=HH(b,c,d,a,M_offset_2,23,T[47]);a=II(a,b,c,d,M_offset_0,6,T[48]);d=II(d,a,b,c,M_offset_7,10,T[49]);c=II(c,d,a,b,M_offset_14,15,T[50]);b=II(b,c,d,a,M_offset_5,21,T[51]);a=II(a,b,c,d,M_offset_12,6,T[52]);d=II(d,a,b,c,M_offset_3,10,T[53]);c=II(c,d,a,b,M_offset_10,15,T[54]);b=II(b,c,d,a,M_offset_1,21,T[55]);a=II(a,b,c,d,M_offset_8,6,T[56]);d=II(d,a,b,c,M_offset_15,10,T[57]);c=II(c,d,a,b,M_offset_6,15,T[58]);b=II(b,c,d,a,M_offset_13,21,T[59]);a=II(a,b,c,d,M_offset_4,6,T[60]);d=II(d,a,b,c,M_offset_11,10,T[61]);c=II(c,d,a,b,M_offset_2,15,T[62]);b=II(b,c,d,a,M_offset_9,21,T[63]);H[0]=H[0]+a|0;H[1]=H[1]+b|0;H[2]=H[2]+c|0;H[3]=H[3]+d|0},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;var nBitsTotalH=Math.floor(nBitsTotal/4294967296);var nBitsTotalL=nBitsTotal;dataWords[(nBitsLeft+64>>>9<<4)+15]=(nBitsTotalH<<8|nBitsTotalH>>>24)&16711935|(nBitsTotalH<<24|nBitsTotalH>>>8)&4278255360;dataWords[(nBitsLeft+64>>>9<<4)+14]=(nBitsTotalL<<8|nBitsTotalL>>>24)&16711935|(nBitsTotalL<<24|nBitsTotalL>>>8)&4278255360;data.sigBytes=(dataWords.length+1)*4;this._process();var hash=this._hash;var H=hash.words;for(var i=0;i<4;i++){var H_i=H[i];H[i]=(H_i<<8|H_i>>>24)&16711935|(H_i<<24|H_i>>>8)&4278255360}return hash},clone:function(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone}});function FF(a,b,c,d,x,s,t){var n=a+(b&c|~b&d)+x+t;return(n<<s|n>>>32-s)+b}function GG(a,b,c,d,x,s,t){var n=a+(b&d|c&~d)+x+t;return(n<<s|n>>>32-s)+b}function HH(a,b,c,d,x,s,t){var n=a+(b^c^d)+x+t;return(n<<s|n>>>32-s)+b}function II(a,b,c,d,x,s,t){var n=a+(c^(b|~d))+x+t;return(n<<s|n>>>32-s)+b}C.MD5=Hasher._createHelper(MD5);C.HmacMD5=Hasher._createHmacHelper(MD5)})(Math);return CryptoJS.MD5})},{"./core":20}],30:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.mode.CFB=function(){var CFB=CryptoJS.lib.BlockCipherMode.extend();CFB.Encryptor=CFB.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;generateKeystreamAndEncrypt.call(this,words,offset,blockSize,cipher);this._prevBlock=words.slice(offset,offset+blockSize)}});CFB.Decryptor=CFB.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;var thisBlock=words.slice(offset,offset+blockSize);generateKeystreamAndEncrypt.call(this,words,offset,blockSize,cipher);this._prevBlock=thisBlock}});function generateKeystreamAndEncrypt(words,offset,blockSize,cipher){var iv=this._iv;if(iv){var keystream=iv.slice(0);this._iv=undefined}else{var keystream=this._prevBlock}cipher.encryptBlock(keystream,0);for(var i=0;i<blockSize;i++){words[offset+i]^=keystream[i]}}return CFB}();return CryptoJS.mode.CFB})},{"./cipher-core":19,"./core":20}],31:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.mode.CTRGladman=function(){var CTRGladman=CryptoJS.lib.BlockCipherMode.extend();function incWord(word){if((word>>24&255)===255){var b1=word>>16&255;var b2=word>>8&255;var b3=word&255;if(b1===255){b1=0;if(b2===255){b2=0;if(b3===255){b3=0}else{++b3}}else{++b2}}else{++b1}word=0;word+=b1<<16;word+=b2<<8;word+=b3}else{word+=1<<24}return word}function incCounter(counter){if((counter[0]=incWord(counter[0]))===0){counter[1]=incWord(counter[1])}return counter}var Encryptor=CTRGladman.Encryptor=CTRGladman.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;var iv=this._iv;var counter=this._counter;if(iv){counter=this._counter=iv.slice(0);this._iv=undefined}incCounter(counter);var keystream=counter.slice(0);cipher.encryptBlock(keystream,0);for(var i=0;i<blockSize;i++){words[offset+i]^=keystream[i]}}});CTRGladman.Decryptor=Encryptor;return CTRGladman}();return CryptoJS.mode.CTRGladman})},{"./cipher-core":19,"./core":20}],32:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.mode.CTR=function(){var CTR=CryptoJS.lib.BlockCipherMode.extend();var Encryptor=CTR.Encryptor=CTR.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;var iv=this._iv;var counter=this._counter;if(iv){counter=this._counter=iv.slice(0);this._iv=undefined}var keystream=counter.slice(0);cipher.encryptBlock(keystream,0);counter[blockSize-1]=counter[blockSize-1]+1|0;for(var i=0;i<blockSize;i++){words[offset+i]^=keystream[i]}}});CTR.Decryptor=Encryptor;return CTR}();return CryptoJS.mode.CTR})},{"./cipher-core":19,"./core":20}],33:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.mode.ECB=function(){var ECB=CryptoJS.lib.BlockCipherMode.extend();ECB.Encryptor=ECB.extend({processBlock:function(words,offset){this._cipher.encryptBlock(words,offset)}});ECB.Decryptor=ECB.extend({processBlock:function(words,offset){this._cipher.decryptBlock(words,offset)}});return ECB}();return CryptoJS.mode.ECB})},{"./cipher-core":19,"./core":20}],34:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.mode.OFB=function(){var OFB=CryptoJS.lib.BlockCipherMode.extend();var Encryptor=OFB.Encryptor=OFB.extend({processBlock:function(words,offset){var cipher=this._cipher;var blockSize=cipher.blockSize;var iv=this._iv;var keystream=this._keystream;if(iv){keystream=this._keystream=iv.slice(0);this._iv=undefined}cipher.encryptBlock(keystream,0);for(var i=0;i<blockSize;i++){words[offset+i]^=keystream[i]}}});OFB.Decryptor=Encryptor;return OFB}();return CryptoJS.mode.OFB})},{"./cipher-core":19,"./core":20}],35:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.pad.AnsiX923={pad:function(data,blockSize){var dataSigBytes=data.sigBytes;var blockSizeBytes=blockSize*4;var nPaddingBytes=blockSizeBytes-dataSigBytes%blockSizeBytes;var lastBytePos=dataSigBytes+nPaddingBytes-1;data.clamp();data.words[lastBytePos>>>2]|=nPaddingBytes<<24-lastBytePos%4*8;data.sigBytes+=nPaddingBytes},unpad:function(data){var nPaddingBytes=data.words[data.sigBytes-1>>>2]&255;data.sigBytes-=nPaddingBytes}};return CryptoJS.pad.Ansix923})},{"./cipher-core":19,"./core":20}],36:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.pad.Iso10126={pad:function(data,blockSize){var blockSizeBytes=blockSize*4;var nPaddingBytes=blockSizeBytes-data.sigBytes%blockSizeBytes;data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes-1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes<<24],1))},unpad:function(data){var nPaddingBytes=data.words[data.sigBytes-1>>>2]&255;data.sigBytes-=nPaddingBytes}};return CryptoJS.pad.Iso10126})},{"./cipher-core":19,"./core":20}],37:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.pad.Iso97971={pad:function(data,blockSize){data.concat(CryptoJS.lib.WordArray.create([2147483648],1));CryptoJS.pad.ZeroPadding.pad(data,blockSize)},unpad:function(data){CryptoJS.pad.ZeroPadding.unpad(data);data.sigBytes--}};return CryptoJS.pad.Iso97971})},{"./cipher-core":19,"./core":20}],38:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.pad.NoPadding={pad:function(){},unpad:function(){}};return CryptoJS.pad.NoPadding})},{"./cipher-core":19,"./core":20}],39:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){CryptoJS.pad.ZeroPadding={pad:function(data,blockSize){var blockSizeBytes=blockSize*4;data.clamp();data.sigBytes+=blockSizeBytes-(data.sigBytes%blockSizeBytes||blockSizeBytes)},unpad:function(data){var dataWords=data.words;var i=data.sigBytes-1;while(!(dataWords[i>>>2]>>>24-i%4*8&255)){i--}data.sigBytes=i+1}};return CryptoJS.pad.ZeroPadding})},{"./cipher-core":19,"./core":20}],40:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./sha1"),_dereq_("./hmac"))}else if(typeof define==="function"&&define.amd){define(["./core","./sha1","./hmac"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var Base=C_lib.Base;var WordArray=C_lib.WordArray;var C_algo=C.algo;var SHA1=C_algo.SHA1;var HMAC=C_algo.HMAC;var PBKDF2=C_algo.PBKDF2=Base.extend({cfg:Base.extend({keySize:128/32,hasher:SHA1,iterations:1}),init:function(cfg){this.cfg=this.cfg.extend(cfg)},compute:function(password,salt){var cfg=this.cfg;var hmac=HMAC.create(cfg.hasher,password);var derivedKey=WordArray.create();var blockIndex=WordArray.create([1]);var derivedKeyWords=derivedKey.words;var blockIndexWords=blockIndex.words;var keySize=cfg.keySize;var iterations=cfg.iterations;while(derivedKeyWords.length<keySize){var block=hmac.update(salt).finalize(blockIndex);hmac.reset();var blockWords=block.words;var blockWordsLength=blockWords.length;var intermediate=block;for(var i=1;i<iterations;i++){intermediate=hmac.finalize(intermediate);hmac.reset();var intermediateWords=intermediate.words;for(var j=0;j<blockWordsLength;j++){blockWords[j]^=intermediateWords[j]}}derivedKey.concat(block);blockIndexWords[0]++}derivedKey.sigBytes=keySize*4;return derivedKey}});C.PBKDF2=function(password,salt,cfg){return PBKDF2.create(cfg).compute(password,salt)}})();return CryptoJS.PBKDF2})},{"./core":20,"./hmac":26,"./sha1":45}],41:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./evpkdf"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var StreamCipher=C_lib.StreamCipher;var C_algo=C.algo;var S=[];var C_=[];var G=[];var RabbitLegacy=C_algo.RabbitLegacy=StreamCipher.extend({_doReset:function(){var K=this._key.words;var iv=this.cfg.iv;var X=this._X=[K[0],K[3]<<16|K[2]>>>16,K[1],K[0]<<16|K[3]>>>16,K[2],K[1]<<16|K[0]>>>16,K[3],K[2]<<16|K[1]>>>16];var C=this._C=[K[2]<<16|K[2]>>>16,K[0]&4294901760|K[1]&65535,K[3]<<16|K[3]>>>16,K[1]&4294901760|K[2]&65535,K[0]<<16|K[0]>>>16,K[2]&4294901760|K[3]&65535,K[1]<<16|K[1]>>>16,K[3]&4294901760|K[0]&65535];this._b=0;for(var i=0;i<4;i++){nextState.call(this)}for(var i=0;i<8;i++){C[i]^=X[i+4&7]}if(iv){var IV=iv.words;var IV_0=IV[0];var IV_1=IV[1];var i0=(IV_0<<8|IV_0>>>24)&16711935|(IV_0<<24|IV_0>>>8)&4278255360;var i2=(IV_1<<8|IV_1>>>24)&16711935|(IV_1<<24|IV_1>>>8)&4278255360;var i1=i0>>>16|i2&4294901760;var i3=i2<<16|i0&65535;C[0]^=i0;C[1]^=i1;C[2]^=i2;C[3]^=i3;C[4]^=i0;C[5]^=i1;C[6]^=i2;C[7]^=i3;for(var i=0;i<4;i++){nextState.call(this)}}},_doProcessBlock:function(M,offset){var X=this._X;nextState.call(this);S[0]=X[0]^X[5]>>>16^X[3]<<16;S[1]=X[2]^X[7]>>>16^X[5]<<16;S[2]=X[4]^X[1]>>>16^X[7]<<16;S[3]=X[6]^X[3]>>>16^X[1]<<16;for(var i=0;i<4;i++){S[i]=(S[i]<<8|S[i]>>>24)&16711935|(S[i]<<24|S[i]>>>8)&4278255360;M[offset+i]^=S[i]}},blockSize:128/32,ivSize:64/32});
function nextState(){var X=this._X;var C=this._C;for(var i=0;i<8;i++){C_[i]=C[i]}C[0]=C[0]+1295307597+this._b|0;C[1]=C[1]+3545052371+(C[0]>>>0<C_[0]>>>0?1:0)|0;C[2]=C[2]+886263092+(C[1]>>>0<C_[1]>>>0?1:0)|0;C[3]=C[3]+1295307597+(C[2]>>>0<C_[2]>>>0?1:0)|0;C[4]=C[4]+3545052371+(C[3]>>>0<C_[3]>>>0?1:0)|0;C[5]=C[5]+886263092+(C[4]>>>0<C_[4]>>>0?1:0)|0;C[6]=C[6]+1295307597+(C[5]>>>0<C_[5]>>>0?1:0)|0;C[7]=C[7]+3545052371+(C[6]>>>0<C_[6]>>>0?1:0)|0;this._b=C[7]>>>0<C_[7]>>>0?1:0;for(var i=0;i<8;i++){var gx=X[i]+C[i];var ga=gx&65535;var gb=gx>>>16;var gh=((ga*ga>>>17)+ga*gb>>>15)+gb*gb;var gl=((gx&4294901760)*gx|0)+((gx&65535)*gx|0);G[i]=gh^gl}X[0]=G[0]+(G[7]<<16|G[7]>>>16)+(G[6]<<16|G[6]>>>16)|0;X[1]=G[1]+(G[0]<<8|G[0]>>>24)+G[7]|0;X[2]=G[2]+(G[1]<<16|G[1]>>>16)+(G[0]<<16|G[0]>>>16)|0;X[3]=G[3]+(G[2]<<8|G[2]>>>24)+G[1]|0;X[4]=G[4]+(G[3]<<16|G[3]>>>16)+(G[2]<<16|G[2]>>>16)|0;X[5]=G[5]+(G[4]<<8|G[4]>>>24)+G[3]|0;X[6]=G[6]+(G[5]<<16|G[5]>>>16)+(G[4]<<16|G[4]>>>16)|0;X[7]=G[7]+(G[6]<<8|G[6]>>>24)+G[5]|0}C.RabbitLegacy=StreamCipher._createHelper(RabbitLegacy)})();return CryptoJS.RabbitLegacy})},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":29}],42:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./evpkdf"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var StreamCipher=C_lib.StreamCipher;var C_algo=C.algo;var S=[];var C_=[];var G=[];var Rabbit=C_algo.Rabbit=StreamCipher.extend({_doReset:function(){var K=this._key.words;var iv=this.cfg.iv;for(var i=0;i<4;i++){K[i]=(K[i]<<8|K[i]>>>24)&16711935|(K[i]<<24|K[i]>>>8)&4278255360}var X=this._X=[K[0],K[3]<<16|K[2]>>>16,K[1],K[0]<<16|K[3]>>>16,K[2],K[1]<<16|K[0]>>>16,K[3],K[2]<<16|K[1]>>>16];var C=this._C=[K[2]<<16|K[2]>>>16,K[0]&4294901760|K[1]&65535,K[3]<<16|K[3]>>>16,K[1]&4294901760|K[2]&65535,K[0]<<16|K[0]>>>16,K[2]&4294901760|K[3]&65535,K[1]<<16|K[1]>>>16,K[3]&4294901760|K[0]&65535];this._b=0;for(var i=0;i<4;i++){nextState.call(this)}for(var i=0;i<8;i++){C[i]^=X[i+4&7]}if(iv){var IV=iv.words;var IV_0=IV[0];var IV_1=IV[1];var i0=(IV_0<<8|IV_0>>>24)&16711935|(IV_0<<24|IV_0>>>8)&4278255360;var i2=(IV_1<<8|IV_1>>>24)&16711935|(IV_1<<24|IV_1>>>8)&4278255360;var i1=i0>>>16|i2&4294901760;var i3=i2<<16|i0&65535;C[0]^=i0;C[1]^=i1;C[2]^=i2;C[3]^=i3;C[4]^=i0;C[5]^=i1;C[6]^=i2;C[7]^=i3;for(var i=0;i<4;i++){nextState.call(this)}}},_doProcessBlock:function(M,offset){var X=this._X;nextState.call(this);S[0]=X[0]^X[5]>>>16^X[3]<<16;S[1]=X[2]^X[7]>>>16^X[5]<<16;S[2]=X[4]^X[1]>>>16^X[7]<<16;S[3]=X[6]^X[3]>>>16^X[1]<<16;for(var i=0;i<4;i++){S[i]=(S[i]<<8|S[i]>>>24)&16711935|(S[i]<<24|S[i]>>>8)&4278255360;M[offset+i]^=S[i]}},blockSize:128/32,ivSize:64/32});function nextState(){var X=this._X;var C=this._C;for(var i=0;i<8;i++){C_[i]=C[i]}C[0]=C[0]+1295307597+this._b|0;C[1]=C[1]+3545052371+(C[0]>>>0<C_[0]>>>0?1:0)|0;C[2]=C[2]+886263092+(C[1]>>>0<C_[1]>>>0?1:0)|0;C[3]=C[3]+1295307597+(C[2]>>>0<C_[2]>>>0?1:0)|0;C[4]=C[4]+3545052371+(C[3]>>>0<C_[3]>>>0?1:0)|0;C[5]=C[5]+886263092+(C[4]>>>0<C_[4]>>>0?1:0)|0;C[6]=C[6]+1295307597+(C[5]>>>0<C_[5]>>>0?1:0)|0;C[7]=C[7]+3545052371+(C[6]>>>0<C_[6]>>>0?1:0)|0;this._b=C[7]>>>0<C_[7]>>>0?1:0;for(var i=0;i<8;i++){var gx=X[i]+C[i];var ga=gx&65535;var gb=gx>>>16;var gh=((ga*ga>>>17)+ga*gb>>>15)+gb*gb;var gl=((gx&4294901760)*gx|0)+((gx&65535)*gx|0);G[i]=gh^gl}X[0]=G[0]+(G[7]<<16|G[7]>>>16)+(G[6]<<16|G[6]>>>16)|0;X[1]=G[1]+(G[0]<<8|G[0]>>>24)+G[7]|0;X[2]=G[2]+(G[1]<<16|G[1]>>>16)+(G[0]<<16|G[0]>>>16)|0;X[3]=G[3]+(G[2]<<8|G[2]>>>24)+G[1]|0;X[4]=G[4]+(G[3]<<16|G[3]>>>16)+(G[2]<<16|G[2]>>>16)|0;X[5]=G[5]+(G[4]<<8|G[4]>>>24)+G[3]|0;X[6]=G[6]+(G[5]<<16|G[5]>>>16)+(G[4]<<16|G[4]>>>16)|0;X[7]=G[7]+(G[6]<<8|G[6]>>>24)+G[5]|0}C.Rabbit=StreamCipher._createHelper(Rabbit)})();return CryptoJS.Rabbit})},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":29}],43:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./evpkdf"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var StreamCipher=C_lib.StreamCipher;var C_algo=C.algo;var RC4=C_algo.RC4=StreamCipher.extend({_doReset:function(){var key=this._key;var keyWords=key.words;var keySigBytes=key.sigBytes;var S=this._S=[];for(var i=0;i<256;i++){S[i]=i}for(var i=0,j=0;i<256;i++){var keyByteIndex=i%keySigBytes;var keyByte=keyWords[keyByteIndex>>>2]>>>24-keyByteIndex%4*8&255;j=(j+S[i]+keyByte)%256;var t=S[i];S[i]=S[j];S[j]=t}this._i=this._j=0},_doProcessBlock:function(M,offset){M[offset]^=generateKeystreamWord.call(this)},keySize:256/32,ivSize:0});function generateKeystreamWord(){var S=this._S;var i=this._i;var j=this._j;var keystreamWord=0;for(var n=0;n<4;n++){i=(i+1)%256;j=(j+S[i])%256;var t=S[i];S[i]=S[j];S[j]=t;keystreamWord|=S[(S[i]+S[j])%256]<<24-n*8}this._i=i;this._j=j;return keystreamWord}C.RC4=StreamCipher._createHelper(RC4);var RC4Drop=C_algo.RC4Drop=RC4.extend({cfg:RC4.cfg.extend({drop:192}),_doReset:function(){RC4._doReset.call(this);for(var i=this.cfg.drop;i>0;i--){generateKeystreamWord.call(this)}}});C.RC4Drop=StreamCipher._createHelper(RC4Drop)})();return CryptoJS.RC4})},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":29}],44:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(Math){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var Hasher=C_lib.Hasher;var C_algo=C.algo;var _zl=WordArray.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]);var _zr=WordArray.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]);var _sl=WordArray.create([11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]);var _sr=WordArray.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]);var _hl=WordArray.create([0,1518500249,1859775393,2400959708,2840853838]);var _hr=WordArray.create([1352829926,1548603684,1836072691,2053994217,0]);var RIPEMD160=C_algo.RIPEMD160=Hasher.extend({_doReset:function(){this._hash=WordArray.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(M,offset){for(var i=0;i<16;i++){var offset_i=offset+i;var M_offset_i=M[offset_i];M[offset_i]=(M_offset_i<<8|M_offset_i>>>24)&16711935|(M_offset_i<<24|M_offset_i>>>8)&4278255360}var H=this._hash.words;var hl=_hl.words;var hr=_hr.words;var zl=_zl.words;var zr=_zr.words;var sl=_sl.words;var sr=_sr.words;var al,bl,cl,dl,el;var ar,br,cr,dr,er;ar=al=H[0];br=bl=H[1];cr=cl=H[2];dr=dl=H[3];er=el=H[4];var t;for(var i=0;i<80;i+=1){t=al+M[offset+zl[i]]|0;if(i<16){t+=f1(bl,cl,dl)+hl[0]}else if(i<32){t+=f2(bl,cl,dl)+hl[1]}else if(i<48){t+=f3(bl,cl,dl)+hl[2]}else if(i<64){t+=f4(bl,cl,dl)+hl[3]}else{t+=f5(bl,cl,dl)+hl[4]}t=t|0;t=rotl(t,sl[i]);t=t+el|0;al=el;el=dl;dl=rotl(cl,10);cl=bl;bl=t;t=ar+M[offset+zr[i]]|0;if(i<16){t+=f5(br,cr,dr)+hr[0]}else if(i<32){t+=f4(br,cr,dr)+hr[1]}else if(i<48){t+=f3(br,cr,dr)+hr[2]}else if(i<64){t+=f2(br,cr,dr)+hr[3]}else{t+=f1(br,cr,dr)+hr[4]}t=t|0;t=rotl(t,sr[i]);t=t+er|0;ar=er;er=dr;dr=rotl(cr,10);cr=br;br=t}t=H[1]+cl+dr|0;H[1]=H[2]+dl+er|0;H[2]=H[3]+el+ar|0;H[3]=H[4]+al+br|0;H[4]=H[0]+bl+cr|0;H[0]=t},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;dataWords[(nBitsLeft+64>>>9<<4)+14]=(nBitsTotal<<8|nBitsTotal>>>24)&16711935|(nBitsTotal<<24|nBitsTotal>>>8)&4278255360;data.sigBytes=(dataWords.length+1)*4;this._process();var hash=this._hash;var H=hash.words;for(var i=0;i<5;i++){var H_i=H[i];H[i]=(H_i<<8|H_i>>>24)&16711935|(H_i<<24|H_i>>>8)&4278255360}return hash},clone:function(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone}});function f1(x,y,z){return x^y^z}function f2(x,y,z){return x&y|~x&z}function f3(x,y,z){return(x|~y)^z}function f4(x,y,z){return x&z|y&~z}function f5(x,y,z){return x^(y|~z)}function rotl(x,n){return x<<n|x>>>32-n}C.RIPEMD160=Hasher._createHelper(RIPEMD160);C.HmacRIPEMD160=Hasher._createHmacHelper(RIPEMD160)})(Math);return CryptoJS.RIPEMD160})},{"./core":20}],45:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var Hasher=C_lib.Hasher;var C_algo=C.algo;var W=[];var SHA1=C_algo.SHA1=Hasher.extend({_doReset:function(){this._hash=new WordArray.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(M,offset){var H=this._hash.words;var a=H[0];var b=H[1];var c=H[2];var d=H[3];var e=H[4];for(var i=0;i<80;i++){if(i<16){W[i]=M[offset+i]|0}else{var n=W[i-3]^W[i-8]^W[i-14]^W[i-16];W[i]=n<<1|n>>>31}var t=(a<<5|a>>>27)+e+W[i];if(i<20){t+=(b&c|~b&d)+1518500249}else if(i<40){t+=(b^c^d)+1859775393}else if(i<60){t+=(b&c|b&d|c&d)-1894007588}else{t+=(b^c^d)-899497514}e=d;d=c;c=b<<30|b>>>2;b=a;a=t}H[0]=H[0]+a|0;H[1]=H[1]+b|0;H[2]=H[2]+c|0;H[3]=H[3]+d|0;H[4]=H[4]+e|0},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;dataWords[(nBitsLeft+64>>>9<<4)+14]=Math.floor(nBitsTotal/4294967296);dataWords[(nBitsLeft+64>>>9<<4)+15]=nBitsTotal;data.sigBytes=dataWords.length*4;this._process();return this._hash},clone:function(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone}});C.SHA1=Hasher._createHelper(SHA1);C.HmacSHA1=Hasher._createHmacHelper(SHA1)})();return CryptoJS.SHA1})},{"./core":20}],46:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./sha256"))}else if(typeof define==="function"&&define.amd){define(["./core","./sha256"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var C_algo=C.algo;var SHA256=C_algo.SHA256;var SHA224=C_algo.SHA224=SHA256.extend({_doReset:function(){this._hash=new WordArray.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var hash=SHA256._doFinalize.call(this);hash.sigBytes-=4;return hash}});C.SHA224=SHA256._createHelper(SHA224);C.HmacSHA224=SHA256._createHmacHelper(SHA224)})();return CryptoJS.SHA224})},{"./core":20,"./sha256":47}],47:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(Math){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var Hasher=C_lib.Hasher;var C_algo=C.algo;var H=[];var K=[];(function(){function isPrime(n){var sqrtN=Math.sqrt(n);for(var factor=2;factor<=sqrtN;factor++){if(!(n%factor)){return false}}return true}function getFractionalBits(n){return(n-(n|0))*4294967296|0}var n=2;var nPrime=0;while(nPrime<64){if(isPrime(n)){if(nPrime<8){H[nPrime]=getFractionalBits(Math.pow(n,1/2))}K[nPrime]=getFractionalBits(Math.pow(n,1/3));nPrime++}n++}})();var W=[];var SHA256=C_algo.SHA256=Hasher.extend({_doReset:function(){this._hash=new WordArray.init(H.slice(0))},_doProcessBlock:function(M,offset){var H=this._hash.words;var a=H[0];var b=H[1];var c=H[2];var d=H[3];var e=H[4];var f=H[5];var g=H[6];var h=H[7];for(var i=0;i<64;i++){if(i<16){W[i]=M[offset+i]|0}else{var gamma0x=W[i-15];var gamma0=(gamma0x<<25|gamma0x>>>7)^(gamma0x<<14|gamma0x>>>18)^gamma0x>>>3;var gamma1x=W[i-2];var gamma1=(gamma1x<<15|gamma1x>>>17)^(gamma1x<<13|gamma1x>>>19)^gamma1x>>>10;W[i]=gamma0+W[i-7]+gamma1+W[i-16]}var ch=e&f^~e&g;var maj=a&b^a&c^b&c;var sigma0=(a<<30|a>>>2)^(a<<19|a>>>13)^(a<<10|a>>>22);var sigma1=(e<<26|e>>>6)^(e<<21|e>>>11)^(e<<7|e>>>25);var t1=h+sigma1+ch+K[i]+W[i];var t2=sigma0+maj;h=g;g=f;f=e;e=d+t1|0;d=c;c=b;b=a;a=t1+t2|0}H[0]=H[0]+a|0;H[1]=H[1]+b|0;H[2]=H[2]+c|0;H[3]=H[3]+d|0;H[4]=H[4]+e|0;H[5]=H[5]+f|0;H[6]=H[6]+g|0;H[7]=H[7]+h|0},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;dataWords[(nBitsLeft+64>>>9<<4)+14]=Math.floor(nBitsTotal/4294967296);dataWords[(nBitsLeft+64>>>9<<4)+15]=nBitsTotal;data.sigBytes=dataWords.length*4;this._process();return this._hash},clone:function(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone}});C.SHA256=Hasher._createHelper(SHA256);C.HmacSHA256=Hasher._createHmacHelper(SHA256)})(Math);return CryptoJS.SHA256})},{"./core":20}],48:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./x64-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./x64-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(Math){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var Hasher=C_lib.Hasher;var C_x64=C.x64;var X64Word=C_x64.Word;var C_algo=C.algo;var RHO_OFFSETS=[];var PI_INDEXES=[];var ROUND_CONSTANTS=[];(function(){var x=1,y=0;for(var t=0;t<24;t++){RHO_OFFSETS[x+5*y]=(t+1)*(t+2)/2%64;var newX=y%5;var newY=(2*x+3*y)%5;x=newX;y=newY}for(var x=0;x<5;x++){for(var y=0;y<5;y++){PI_INDEXES[x+5*y]=y+(2*x+3*y)%5*5}}var LFSR=1;for(var i=0;i<24;i++){var roundConstantMsw=0;var roundConstantLsw=0;for(var j=0;j<7;j++){if(LFSR&1){var bitPosition=(1<<j)-1;if(bitPosition<32){roundConstantLsw^=1<<bitPosition}else{roundConstantMsw^=1<<bitPosition-32}}if(LFSR&128){LFSR=LFSR<<1^113}else{LFSR<<=1}}ROUND_CONSTANTS[i]=X64Word.create(roundConstantMsw,roundConstantLsw)}})();var T=[];(function(){for(var i=0;i<25;i++){T[i]=X64Word.create()}})();var SHA3=C_algo.SHA3=Hasher.extend({cfg:Hasher.cfg.extend({outputLength:512}),_doReset:function(){var state=this._state=[];for(var i=0;i<25;i++){state[i]=new X64Word.init}this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(M,offset){var state=this._state;var nBlockSizeLanes=this.blockSize/2;for(var i=0;i<nBlockSizeLanes;i++){var M2i=M[offset+2*i];var M2i1=M[offset+2*i+1];M2i=(M2i<<8|M2i>>>24)&16711935|(M2i<<24|M2i>>>8)&4278255360;M2i1=(M2i1<<8|M2i1>>>24)&16711935|(M2i1<<24|M2i1>>>8)&4278255360;var lane=state[i];lane.high^=M2i1;lane.low^=M2i}for(var round=0;round<24;round++){for(var x=0;x<5;x++){var tMsw=0,tLsw=0;for(var y=0;y<5;y++){var lane=state[x+5*y];tMsw^=lane.high;tLsw^=lane.low}var Tx=T[x];Tx.high=tMsw;Tx.low=tLsw}for(var x=0;x<5;x++){var Tx4=T[(x+4)%5];var Tx1=T[(x+1)%5];var Tx1Msw=Tx1.high;var Tx1Lsw=Tx1.low;var tMsw=Tx4.high^(Tx1Msw<<1|Tx1Lsw>>>31);var tLsw=Tx4.low^(Tx1Lsw<<1|Tx1Msw>>>31);for(var y=0;y<5;y++){var lane=state[x+5*y];lane.high^=tMsw;lane.low^=tLsw}}for(var laneIndex=1;laneIndex<25;laneIndex++){var lane=state[laneIndex];var laneMsw=lane.high;var laneLsw=lane.low;var rhoOffset=RHO_OFFSETS[laneIndex];if(rhoOffset<32){var tMsw=laneMsw<<rhoOffset|laneLsw>>>32-rhoOffset;var tLsw=laneLsw<<rhoOffset|laneMsw>>>32-rhoOffset}else{var tMsw=laneLsw<<rhoOffset-32|laneMsw>>>64-rhoOffset;var tLsw=laneMsw<<rhoOffset-32|laneLsw>>>64-rhoOffset}var TPiLane=T[PI_INDEXES[laneIndex]];TPiLane.high=tMsw;TPiLane.low=tLsw}var T0=T[0];var state0=state[0];T0.high=state0.high;T0.low=state0.low;for(var x=0;x<5;x++){for(var y=0;y<5;y++){var laneIndex=x+5*y;var lane=state[laneIndex];var TLane=T[laneIndex];var Tx1Lane=T[(x+1)%5+5*y];var Tx2Lane=T[(x+2)%5+5*y];lane.high=TLane.high^~Tx1Lane.high&Tx2Lane.high;lane.low=TLane.low^~Tx1Lane.low&Tx2Lane.low}}var lane=state[0];var roundConstant=ROUND_CONSTANTS[round];lane.high^=roundConstant.high;lane.low^=roundConstant.low}},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;var blockSizeBits=this.blockSize*32;dataWords[nBitsLeft>>>5]|=1<<24-nBitsLeft%32;dataWords[(Math.ceil((nBitsLeft+1)/blockSizeBits)*blockSizeBits>>>5)-1]|=128;data.sigBytes=dataWords.length*4;this._process();var state=this._state;var outputLengthBytes=this.cfg.outputLength/8;var outputLengthLanes=outputLengthBytes/8;var hashWords=[];for(var i=0;i<outputLengthLanes;i++){var lane=state[i];var laneMsw=lane.high;var laneLsw=lane.low;laneMsw=(laneMsw<<8|laneMsw>>>24)&16711935|(laneMsw<<24|laneMsw>>>8)&4278255360;laneLsw=(laneLsw<<8|laneLsw>>>24)&16711935|(laneLsw<<24|laneLsw>>>8)&4278255360;hashWords.push(laneLsw);hashWords.push(laneMsw)}return new WordArray.init(hashWords,outputLengthBytes)},clone:function(){var clone=Hasher.clone.call(this);var state=clone._state=this._state.slice(0);for(var i=0;i<25;i++){state[i]=state[i].clone()}return clone}});C.SHA3=Hasher._createHelper(SHA3);C.HmacSHA3=Hasher._createHmacHelper(SHA3)})(Math);return CryptoJS.SHA3})},{"./core":20,"./x64-core":52}],49:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./x64-core"),_dereq_("./sha512"))}else if(typeof define==="function"&&define.amd){define(["./core","./x64-core","./sha512"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_x64=C.x64;var X64Word=C_x64.Word;var X64WordArray=C_x64.WordArray;var C_algo=C.algo;var SHA512=C_algo.SHA512;var SHA384=C_algo.SHA384=SHA512.extend({_doReset:function(){this._hash=new X64WordArray.init([new X64Word.init(3418070365,3238371032),new X64Word.init(1654270250,914150663),new X64Word.init(2438529370,812702999),new X64Word.init(355462360,4144912697),new X64Word.init(1731405415,4290775857),new X64Word.init(2394180231,1750603025),new X64Word.init(3675008525,1694076839),new X64Word.init(1203062813,3204075428)])},_doFinalize:function(){var hash=SHA512._doFinalize.call(this);hash.sigBytes-=16;return hash}});C.SHA384=SHA512._createHelper(SHA384);C.HmacSHA384=SHA512._createHmacHelper(SHA384)})();return CryptoJS.SHA384})},{"./core":20,"./sha512":50,"./x64-core":52}],50:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./x64-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./x64-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var Hasher=C_lib.Hasher;var C_x64=C.x64;var X64Word=C_x64.Word;var X64WordArray=C_x64.WordArray;var C_algo=C.algo;function X64Word_create(){return X64Word.create.apply(X64Word,arguments)}var K=[X64Word_create(1116352408,3609767458),X64Word_create(1899447441,602891725),X64Word_create(3049323471,3964484399),X64Word_create(3921009573,2173295548),X64Word_create(961987163,4081628472),X64Word_create(1508970993,3053834265),X64Word_create(2453635748,2937671579),X64Word_create(2870763221,3664609560),X64Word_create(3624381080,2734883394),X64Word_create(310598401,1164996542),X64Word_create(607225278,1323610764),X64Word_create(1426881987,3590304994),X64Word_create(1925078388,4068182383),X64Word_create(2162078206,991336113),X64Word_create(2614888103,633803317),X64Word_create(3248222580,3479774868),X64Word_create(3835390401,2666613458),X64Word_create(4022224774,944711139),X64Word_create(264347078,2341262773),X64Word_create(604807628,2007800933),X64Word_create(770255983,1495990901),X64Word_create(1249150122,1856431235),X64Word_create(1555081692,3175218132),X64Word_create(1996064986,2198950837),X64Word_create(2554220882,3999719339),X64Word_create(2821834349,766784016),X64Word_create(2952996808,2566594879),X64Word_create(3210313671,3203337956),X64Word_create(3336571891,1034457026),X64Word_create(3584528711,2466948901),X64Word_create(113926993,3758326383),X64Word_create(338241895,168717936),X64Word_create(666307205,1188179964),X64Word_create(773529912,1546045734),X64Word_create(1294757372,1522805485),X64Word_create(1396182291,2643833823),X64Word_create(1695183700,2343527390),X64Word_create(1986661051,1014477480),X64Word_create(2177026350,1206759142),X64Word_create(2456956037,344077627),X64Word_create(2730485921,1290863460),X64Word_create(2820302411,3158454273),X64Word_create(3259730800,3505952657),X64Word_create(3345764771,106217008),X64Word_create(3516065817,3606008344),X64Word_create(3600352804,1432725776),X64Word_create(4094571909,1467031594),X64Word_create(275423344,851169720),X64Word_create(430227734,3100823752),X64Word_create(506948616,1363258195),X64Word_create(659060556,3750685593),X64Word_create(883997877,3785050280),X64Word_create(958139571,3318307427),X64Word_create(1322822218,3812723403),X64Word_create(1537002063,2003034995),X64Word_create(1747873779,3602036899),X64Word_create(1955562222,1575990012),X64Word_create(2024104815,1125592928),X64Word_create(2227730452,2716904306),X64Word_create(2361852424,442776044),X64Word_create(2428436474,593698344),X64Word_create(2756734187,3733110249),X64Word_create(3204031479,2999351573),X64Word_create(3329325298,3815920427),X64Word_create(3391569614,3928383900),X64Word_create(3515267271,566280711),X64Word_create(3940187606,3454069534),X64Word_create(4118630271,4000239992),X64Word_create(116418474,1914138554),X64Word_create(174292421,2731055270),X64Word_create(289380356,3203993006),X64Word_create(460393269,320620315),X64Word_create(685471733,587496836),X64Word_create(852142971,1086792851),X64Word_create(1017036298,365543100),X64Word_create(1126000580,2618297676),X64Word_create(1288033470,3409855158),X64Word_create(1501505948,4234509866),X64Word_create(1607167915,987167468),X64Word_create(1816402316,1246189591)];var W=[];(function(){for(var i=0;i<80;i++){W[i]=X64Word_create()}})();var SHA512=C_algo.SHA512=Hasher.extend({_doReset:function(){this._hash=new X64WordArray.init([new X64Word.init(1779033703,4089235720),new X64Word.init(3144134277,2227873595),new X64Word.init(1013904242,4271175723),new X64Word.init(2773480762,1595750129),new X64Word.init(1359893119,2917565137),new X64Word.init(2600822924,725511199),new X64Word.init(528734635,4215389547),new X64Word.init(1541459225,327033209)])},_doProcessBlock:function(M,offset){var H=this._hash.words;var H0=H[0];var H1=H[1];var H2=H[2];var H3=H[3];var H4=H[4];var H5=H[5];var H6=H[6];var H7=H[7];var H0h=H0.high;var H0l=H0.low;var H1h=H1.high;var H1l=H1.low;var H2h=H2.high;var H2l=H2.low;var H3h=H3.high;var H3l=H3.low;var H4h=H4.high;var H4l=H4.low;var H5h=H5.high;var H5l=H5.low;var H6h=H6.high;var H6l=H6.low;var H7h=H7.high;var H7l=H7.low;var ah=H0h;var al=H0l;var bh=H1h;var bl=H1l;var ch=H2h;var cl=H2l;var dh=H3h;var dl=H3l;var eh=H4h;var el=H4l;var fh=H5h;var fl=H5l;var gh=H6h;var gl=H6l;var hh=H7h;var hl=H7l;for(var i=0;i<80;i++){var Wi=W[i];if(i<16){var Wih=Wi.high=M[offset+i*2]|0;var Wil=Wi.low=M[offset+i*2+1]|0}else{var gamma0x=W[i-15];var gamma0xh=gamma0x.high;var gamma0xl=gamma0x.low;var gamma0h=(gamma0xh>>>1|gamma0xl<<31)^(gamma0xh>>>8|gamma0xl<<24)^gamma0xh>>>7;var gamma0l=(gamma0xl>>>1|gamma0xh<<31)^(gamma0xl>>>8|gamma0xh<<24)^(gamma0xl>>>7|gamma0xh<<25);var gamma1x=W[i-2];var gamma1xh=gamma1x.high;var gamma1xl=gamma1x.low;var gamma1h=(gamma1xh>>>19|gamma1xl<<13)^(gamma1xh<<3|gamma1xl>>>29)^gamma1xh>>>6;var gamma1l=(gamma1xl>>>19|gamma1xh<<13)^(gamma1xl<<3|gamma1xh>>>29)^(gamma1xl>>>6|gamma1xh<<26);var Wi7=W[i-7];var Wi7h=Wi7.high;var Wi7l=Wi7.low;var Wi16=W[i-16];var Wi16h=Wi16.high;var Wi16l=Wi16.low;var Wil=gamma0l+Wi7l;var Wih=gamma0h+Wi7h+(Wil>>>0<gamma0l>>>0?1:0);var Wil=Wil+gamma1l;var Wih=Wih+gamma1h+(Wil>>>0<gamma1l>>>0?1:0);var Wil=Wil+Wi16l;var Wih=Wih+Wi16h+(Wil>>>0<Wi16l>>>0?1:0);Wi.high=Wih;Wi.low=Wil}var chh=eh&fh^~eh&gh;var chl=el&fl^~el&gl;var majh=ah&bh^ah&ch^bh&ch;var majl=al&bl^al&cl^bl&cl;var sigma0h=(ah>>>28|al<<4)^(ah<<30|al>>>2)^(ah<<25|al>>>7);var sigma0l=(al>>>28|ah<<4)^(al<<30|ah>>>2)^(al<<25|ah>>>7);var sigma1h=(eh>>>14|el<<18)^(eh>>>18|el<<14)^(eh<<23|el>>>9);var sigma1l=(el>>>14|eh<<18)^(el>>>18|eh<<14)^(el<<23|eh>>>9);var Ki=K[i];var Kih=Ki.high;var Kil=Ki.low;var t1l=hl+sigma1l;var t1h=hh+sigma1h+(t1l>>>0<hl>>>0?1:0);var t1l=t1l+chl;var t1h=t1h+chh+(t1l>>>0<chl>>>0?1:0);var t1l=t1l+Kil;var t1h=t1h+Kih+(t1l>>>0<Kil>>>0?1:0);var t1l=t1l+Wil;var t1h=t1h+Wih+(t1l>>>0<Wil>>>0?1:0);var t2l=sigma0l+majl;var t2h=sigma0h+majh+(t2l>>>0<sigma0l>>>0?1:0);hh=gh;hl=gl;gh=fh;gl=fl;fh=eh;fl=el;el=dl+t1l|0;eh=dh+t1h+(el>>>0<dl>>>0?1:0)|0;dh=ch;dl=cl;ch=bh;cl=bl;bh=ah;bl=al;al=t1l+t2l|0;ah=t1h+t2h+(al>>>0<t1l>>>0?1:0)|0}H0l=H0.low=H0l+al;H0.high=H0h+ah+(H0l>>>0<al>>>0?1:0);H1l=H1.low=H1l+bl;H1.high=H1h+bh+(H1l>>>0<bl>>>0?1:0);H2l=H2.low=H2l+cl;H2.high=H2h+ch+(H2l>>>0<cl>>>0?1:0);H3l=H3.low=H3l+dl;H3.high=H3h+dh+(H3l>>>0<dl>>>0?1:0);H4l=H4.low=H4l+el;H4.high=H4h+eh+(H4l>>>0<el>>>0?1:0);H5l=H5.low=H5l+fl;H5.high=H5h+fh+(H5l>>>0<fl>>>0?1:0);H6l=H6.low=H6l+gl;H6.high=H6h+gh+(H6l>>>0<gl>>>0?1:0);H7l=H7.low=H7l+hl;H7.high=H7h+hh+(H7l>>>0<hl>>>0?1:0)},_doFinalize:function(){var data=this._data;var dataWords=data.words;var nBitsTotal=this._nDataBytes*8;var nBitsLeft=data.sigBytes*8;dataWords[nBitsLeft>>>5]|=128<<24-nBitsLeft%32;dataWords[(nBitsLeft+128>>>10<<5)+30]=Math.floor(nBitsTotal/4294967296);dataWords[(nBitsLeft+128>>>10<<5)+31]=nBitsTotal;data.sigBytes=dataWords.length*4;this._process();var hash=this._hash.toX32();return hash},clone:function(){var clone=Hasher.clone.call(this);clone._hash=this._hash.clone();return clone},blockSize:1024/32});C.SHA512=Hasher._createHelper(SHA512);C.HmacSHA512=Hasher._createHmacHelper(SHA512)})();return CryptoJS.SHA512})},{"./core":20,"./x64-core":52}],51:[function(_dereq_,module,exports){(function(root,factory,undef){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"),_dereq_("./enc-base64"),_dereq_("./md5"),_dereq_("./evpkdf"),_dereq_("./cipher-core"))}else if(typeof define==="function"&&define.amd){define(["./core","./enc-base64","./md5","./evpkdf","./cipher-core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(){var C=CryptoJS;var C_lib=C.lib;var WordArray=C_lib.WordArray;var BlockCipher=C_lib.BlockCipher;var C_algo=C.algo;var PC1=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4];var PC2=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32];var BIT_SHIFTS=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28];var SBOX_P=[{0:8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{0:1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{0:260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{0:2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{0:128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{0:268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{0:1048576,16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{0:134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}];
var SBOX_MASK=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679];var DES=C_algo.DES=BlockCipher.extend({_doReset:function(){var key=this._key;var keyWords=key.words;var keyBits=[];for(var i=0;i<56;i++){var keyBitPos=PC1[i]-1;keyBits[i]=keyWords[keyBitPos>>>5]>>>31-keyBitPos%32&1}var subKeys=this._subKeys=[];for(var nSubKey=0;nSubKey<16;nSubKey++){var subKey=subKeys[nSubKey]=[];var bitShift=BIT_SHIFTS[nSubKey];for(var i=0;i<24;i++){subKey[i/6|0]|=keyBits[(PC2[i]-1+bitShift)%28]<<31-i%6;subKey[4+(i/6|0)]|=keyBits[28+(PC2[i+24]-1+bitShift)%28]<<31-i%6}subKey[0]=subKey[0]<<1|subKey[0]>>>31;for(var i=1;i<7;i++){subKey[i]=subKey[i]>>>(i-1)*4+3}subKey[7]=subKey[7]<<5|subKey[7]>>>27}var invSubKeys=this._invSubKeys=[];for(var i=0;i<16;i++){invSubKeys[i]=subKeys[15-i]}},encryptBlock:function(M,offset){this._doCryptBlock(M,offset,this._subKeys)},decryptBlock:function(M,offset){this._doCryptBlock(M,offset,this._invSubKeys)},_doCryptBlock:function(M,offset,subKeys){this._lBlock=M[offset];this._rBlock=M[offset+1];exchangeLR.call(this,4,252645135);exchangeLR.call(this,16,65535);exchangeRL.call(this,2,858993459);exchangeRL.call(this,8,16711935);exchangeLR.call(this,1,1431655765);for(var round=0;round<16;round++){var subKey=subKeys[round];var lBlock=this._lBlock;var rBlock=this._rBlock;var f=0;for(var i=0;i<8;i++){f|=SBOX_P[i][((rBlock^subKey[i])&SBOX_MASK[i])>>>0]}this._lBlock=rBlock;this._rBlock=lBlock^f}var t=this._lBlock;this._lBlock=this._rBlock;this._rBlock=t;exchangeLR.call(this,1,1431655765);exchangeRL.call(this,8,16711935);exchangeRL.call(this,2,858993459);exchangeLR.call(this,16,65535);exchangeLR.call(this,4,252645135);M[offset]=this._lBlock;M[offset+1]=this._rBlock},keySize:64/32,ivSize:64/32,blockSize:64/32});function exchangeLR(offset,mask){var t=(this._lBlock>>>offset^this._rBlock)&mask;this._rBlock^=t;this._lBlock^=t<<offset}function exchangeRL(offset,mask){var t=(this._rBlock>>>offset^this._lBlock)&mask;this._lBlock^=t;this._rBlock^=t<<offset}C.DES=BlockCipher._createHelper(DES);var TripleDES=C_algo.TripleDES=BlockCipher.extend({_doReset:function(){var key=this._key;var keyWords=key.words;this._des1=DES.createEncryptor(WordArray.create(keyWords.slice(0,2)));this._des2=DES.createEncryptor(WordArray.create(keyWords.slice(2,4)));this._des3=DES.createEncryptor(WordArray.create(keyWords.slice(4,6)))},encryptBlock:function(M,offset){this._des1.encryptBlock(M,offset);this._des2.decryptBlock(M,offset);this._des3.encryptBlock(M,offset)},decryptBlock:function(M,offset){this._des3.decryptBlock(M,offset);this._des2.encryptBlock(M,offset);this._des1.decryptBlock(M,offset)},keySize:192/32,ivSize:64/32,blockSize:64/32});C.TripleDES=BlockCipher._createHelper(TripleDES)})();return CryptoJS.TripleDES})},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":29}],52:[function(_dereq_,module,exports){(function(root,factory){if(typeof exports==="object"){module.exports=exports=factory(_dereq_("./core"))}else if(typeof define==="function"&&define.amd){define(["./core"],factory)}else{factory(root.CryptoJS)}})(this,function(CryptoJS){(function(undefined){var C=CryptoJS;var C_lib=C.lib;var Base=C_lib.Base;var X32WordArray=C_lib.WordArray;var C_x64=C.x64={};var X64Word=C_x64.Word=Base.extend({init:function(high,low){this.high=high;this.low=low}});var X64WordArray=C_x64.WordArray=Base.extend({init:function(words,sigBytes){words=this.words=words||[];if(sigBytes!=undefined){this.sigBytes=sigBytes}else{this.sigBytes=words.length*8}},toX32:function(){var x64Words=this.words;var x64WordsLength=x64Words.length;var x32Words=[];for(var i=0;i<x64WordsLength;i++){var x64Word=x64Words[i];x32Words.push(x64Word.high);x32Words.push(x64Word.low)}return X32WordArray.create(x32Words,this.sigBytes)},clone:function(){var clone=Base.clone.call(this);var words=clone.words=this.words.slice(0);var wordsLength=words.length;for(var i=0;i<wordsLength;i++){words[i]=words[i].clone()}return clone}})})();return CryptoJS})},{"./core":20}],53:[function(_dereq_,module,exports){(function(process){!function(globals){"use strict";if(typeof define!=="undefined"&&define.amd){define([],function(){return secureRandom})}else if(typeof module!=="undefined"&&module.exports){module.exports=secureRandom}else{globals.secureRandom=secureRandom}function secureRandom(count,options){options=options||{};if(typeof process!="undefined"&&typeof process.pid=="number"){return nodeRandom(count,options)}else{if(!window.crypto)throw new Error("Your browser does not support window.crypto.");return browserRandom(count,options)}}function nodeRandom(count,options){var crypto=_dereq_("crypto");var buf=crypto.randomBytes(count);if(options.array)var ret=[];else var ret=new Uint8Array(count);for(var i=0;i<count;++i){ret[i]=buf.readUInt8(i)}return ret}function browserRandom(count,options){var nativeArr=new Uint8Array(count);window.crypto.getRandomValues(nativeArr);if(options.array){var ret=[];for(var i=0;i<nativeArr.length;++i){ret[i]=nativeArr[i]}}else{ret=nativeArr}return ret}}(this)}).call(this,_dereq_("FWaASH"))},{FWaASH:15,crypto:4}],54:[function(_dereq_,module,exports){var base58=_dereq_("./base58");var base58check=_dereq_("./base58check");var convert=_dereq_("./convert");var error=_dereq_("./util").error;var mainnet=_dereq_("./network").mainnet.addressVersion;function Address(bytes,version){if(!(this instanceof Address)){return new Address(bytes,version)}if(bytes instanceof Address){this.hash=bytes.hash;this.version=bytes.version}else if(typeof bytes==="string"){if(bytes.length<=35){var decode=base58check.decode(bytes);this.hash=decode.payload;this.version=decode.version}else if(bytes.length<=40){this.hash=convert.hexToBytes(bytes);this.version=version||mainnet}else{error("invalid or unrecognized input")}}else{this.hash=bytes;this.version=version||mainnet}}Address.prototype.toString=function(){return base58check.encode(this.hash.slice(0),this.version)};Address.getVersion=function(address){return base58.decode(address)[0]};Address.validate=function(address){try{base58check.decode(address);return true}catch(e){return false}};module.exports=Address},{"./base58":55,"./base58check":56,"./convert":57,"./network":66,"./util":70}],55:[function(_dereq_,module,exports){(function(Buffer){var BigInteger=_dereq_("./jsbn/jsbn");var alphabet="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";var base=BigInteger.valueOf(58);var alphabetMap={};for(var i=0;i<alphabet.length;++i){var chr=alphabet[i];alphabetMap[chr]=BigInteger.valueOf(i)}function encode(buffer){var bi=BigInteger.fromByteArrayUnsigned(buffer);var chars=[];while(bi.compareTo(base)>=0){var mod=bi.mod(base);bi=bi.subtract(mod).divide(base);chars.push(alphabet[mod.intValue()])}chars.push(alphabet[bi.intValue()]);for(var i=0;i<buffer.length;i++){if(buffer[i]!==0)break;chars.push(alphabet[0])}return chars.reverse().join("")}function decode(str){var num=BigInteger.valueOf(0);var leading_zero=0;var seen_other=false;for(var i=0;i<str.length;++i){var chr=str[i];var bi=alphabetMap[chr];if(bi===undefined){throw new Error("invalid base58 string: "+str)}num=num.multiply(base).add(bi);if(chr==="1"&&!seen_other){++leading_zero}else{seen_other=true}}var bytes=num.toByteArrayUnsigned();while(leading_zero-->0){bytes.unshift(0)}return new Buffer(bytes)}module.exports={encode:encode,decode:decode}}).call(this,_dereq_("buffer").Buffer)},{"./jsbn/jsbn":63,buffer:5}],56:[function(_dereq_,module,exports){(function(Buffer){var assert=_dereq_("assert");var base58=_dereq_("./base58");var crypto=_dereq_("crypto");function sha256(buf){var hash=crypto.createHash("sha256");hash.update(buf);return hash.digest()}function encode(buffer,version){version=version||0;var version=new Buffer([version]);var payload=new Buffer(buffer);var message=Buffer.concat([version,payload]);var checksum=sha256(sha256(message)).slice(0,4);return base58.encode(Buffer.concat([message,checksum]))}function decode(string){var buffer=base58.decode(string);var message=buffer.slice(0,-4);var checksum=buffer.slice(-4);var newChecksum=sha256(sha256(message)).slice(0,4);assert.deepEqual(newChecksum,checksum);var version=message.readUInt8(0);var payload=message.slice(1);return{version:version,payload:payload,checksum:checksum}}module.exports={encode:encode,decode:decode}}).call(this,_dereq_("buffer").Buffer)},{"./base58":55,assert:1,buffer:5,crypto:9}],57:[function(_dereq_,module,exports){(function(Buffer){var Crypto=_dereq_("crypto-js");var WordArray=Crypto.lib.WordArray;var base64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";function lpad(str,padString,length){while(str.length<length)str=padString+str;return str}function bytesToHex(bytes){if(Buffer.isBuffer(bytes)){return bytes.toString("hex")}return bytes.map(function(x){return lpad(x.toString(16),"0",2)}).join("")}function hexToBytes(hex){return hex.match(/../g).map(function(x){return parseInt(x,16)})}function bytesToBase64(bytes){var base64=[];for(var i=0;i<bytes.length;i+=3){var triplet=bytes[i]<<16|bytes[i+1]<<8|bytes[i+2];for(var j=0;j<4;j++){if(i*8+j*6<=bytes.length*8){base64.push(base64map.charAt(triplet>>>6*(3-j)&63))}else{base64.push("=")}}}return base64.join("")}function base64ToBytes(base64){base64=base64.replace(/[^A-Z0-9+\/]/gi,"");var bytes=[];var imod4=0;for(var i=0;i<base64.length;imod4=++i%4){if(!imod4)continue;bytes.push((base64map.indexOf(base64.charAt(i-1))&Math.pow(2,-2*imod4+8)-1)<<imod4*2|base64map.indexOf(base64.charAt(i))>>>6-imod4*2)}return bytes}function coerceToBytes(input){if(typeof input!="string")return input;return hexToBytes(input)}function binToBytes(bin){return bin.match(/......../g).map(function(x){return parseInt(x,2)})}function bytesToBin(bytes){return bytes.map(function(x){return lpad(x.toString(2),"0",8)}).join("")}function bytesToString(bytes){return bytes.map(function(x){return String.fromCharCode(x)}).join("")}function stringToBytes(string){return string.split("").map(function(x){return x.charCodeAt(0)})}function numToBytes(num,bytes){if(bytes===undefined)bytes=8;if(bytes===0)return[];return[num%256].concat(numToBytes(Math.floor(num/256),bytes-1))}function bytesToNum(bytes){if(bytes.length===0)return 0;return bytes[0]+256*bytesToNum(bytes.slice(1))}function numToVarInt(num){if(num<253)return[num];if(num<65536)return[253].concat(numToBytes(num,2));if(num<4294967296)return[254].concat(numToBytes(num,4));return[255].concat(numToBytes(num,8))}function varIntToNum(bytes){var prefix=bytes[0];var viBytes=prefix<253?bytes.slice(0,1):prefix===253?bytes.slice(1,3):prefix===254?bytes.slice(1,5):bytes.slice(1,9);return{bytes:prefix<253?viBytes:bytes.slice(0,viBytes.length+1),number:bytesToNum(viBytes)}}function bytesToWords(bytes){var words=[];for(var i=0,b=0;i<bytes.length;i++,b+=8){words[b>>>5]|=bytes[i]<<24-b%32}return words}function wordsToBytes(words){var bytes=[];for(var b=0;b<words.length*32;b+=8){bytes.push(words[b>>>5]>>>24-b%32&255)}return bytes}function bytesToWordArray(bytes){return new WordArray.init(bytesToWords(bytes),bytes.length)}function wordArrayToBytes(wordArray){return wordsToBytes(wordArray.words)}function reverseEndian(hex){return bytesToHex(hexToBytes(hex).reverse())}module.exports={lpad:lpad,bytesToHex:bytesToHex,hexToBytes:hexToBytes,bytesToBase64:bytesToBase64,base64ToBytes:base64ToBytes,coerceToBytes:coerceToBytes,binToBytes:binToBytes,bytesToBin:bytesToBin,bytesToString:bytesToString,stringToBytes:stringToBytes,numToBytes:numToBytes,bytesToNum:bytesToNum,numToVarInt:numToVarInt,varIntToNum:varIntToNum,bytesToWords:bytesToWords,wordsToBytes:wordsToBytes,bytesToWordArray:bytesToWordArray,wordArrayToBytes:wordArrayToBytes,reverseEndian:reverseEndian}}).call(this,_dereq_("buffer").Buffer)},{buffer:5,"crypto-js":27}],58:[function(_dereq_,module,exports){var sec=_dereq_("./jsbn/sec");var rng=_dereq_("secure-random");var BigInteger=_dereq_("./jsbn/jsbn");var convert=_dereq_("./convert");var HmacSHA256=_dereq_("crypto-js/hmac-sha256");var ECPointFp=_dereq_("./jsbn/ec").ECPointFp;var ecparams=sec("secp256k1");var P_OVER_FOUR=null;function implShamirsTrick(P,k,Q,l){var m=Math.max(k.bitLength(),l.bitLength());var Z=P.add2D(Q);var R=P.curve.getInfinity();for(var i=m-1;i>=0;--i){R=R.twice2D();R.z=BigInteger.ONE;if(k.testBit(i)){if(l.testBit(i)){R=R.add2D(Z)}else{R=R.add2D(P)}}else{if(l.testBit(i)){R=R.add2D(Q)}}}return R}function deterministicGenerateK(hash,key){var vArr=[];var kArr=[];for(var i=0;i<32;i++)vArr.push(1);for(var i=0;i<32;i++)kArr.push(0);var v=convert.bytesToWordArray(vArr);var k=convert.bytesToWordArray(kArr);k=HmacSHA256(convert.bytesToWordArray(vArr.concat([0]).concat(key).concat(hash)),k);v=HmacSHA256(v,k);vArr=convert.wordArrayToBytes(v);k=HmacSHA256(convert.bytesToWordArray(vArr.concat([1]).concat(key).concat(hash)),k);v=HmacSHA256(v,k);v=HmacSHA256(v,k);vArr=convert.wordArrayToBytes(v);return BigInteger.fromByteArrayUnsigned(vArr)}var ECDSA={getBigRandom:function(limit){return new BigInteger(limit.bitLength(),rng).mod(limit.subtract(BigInteger.ONE)).add(BigInteger.ONE)},sign:function(hash,priv){var d=priv;var n=ecparams.getN();var e=BigInteger.fromByteArrayUnsigned(hash);var k=deterministicGenerateK(hash,priv.toByteArrayUnsigned());var G=ecparams.getG();var Q=G.multiply(k);var r=Q.getX().toBigInteger().mod(n);var s=k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);return ECDSA.serializeSig(r,s)},verify:function(hash,sig,pubkey){var r,s;if(Array.isArray(sig)){var obj=ECDSA.parseSig(sig);r=obj.r;s=obj.s}else if("object"===typeof sig&&sig.r&&sig.s){r=sig.r;s=sig.s}else{throw new Error("Invalid value for signature")}var Q;if(pubkey instanceof ECPointFp){Q=pubkey}else if(Array.isArray(pubkey)){Q=ECPointFp.decodeFrom(ecparams.getCurve(),pubkey)}else{throw new Error("Invalid format for pubkey value, must be byte array or ECPointFp")}var e=BigInteger.fromByteArrayUnsigned(hash);return ECDSA.verifyRaw(e,r,s,Q)},verifyRaw:function(e,r,s,Q){var n=ecparams.getN();var G=ecparams.getG();if(r.compareTo(BigInteger.ONE)<0||r.compareTo(n)>=0){return false}if(s.compareTo(BigInteger.ONE)<0||s.compareTo(n)>=0){return false}var c=s.modInverse(n);var u1=e.multiply(c).mod(n);var u2=r.multiply(c).mod(n);var point=G.multiply(u1).add(Q.multiply(u2));var v=point.getX().toBigInteger().mod(n);return v.equals(r)},serializeSig:function(r,s){var rBa=r.toByteArraySigned();var sBa=s.toByteArraySigned();var sequence=[];sequence.push(2);sequence.push(rBa.length);sequence=sequence.concat(rBa);sequence.push(2);sequence.push(sBa.length);sequence=sequence.concat(sBa);sequence.unshift(sequence.length);sequence.unshift(48);return sequence},parseSig:function(sig){var cursor;if(sig[0]!=48){throw new Error("Signature not a valid DERSequence")}cursor=2;if(sig[cursor]!=2){throw new Error("First element in signature must be a DERInteger")}var rBa=sig.slice(cursor+2,cursor+2+sig[cursor+1]);cursor+=2+sig[cursor+1];if(sig[cursor]!=2){throw new Error("Second element in signature must be a DERInteger")}var sBa=sig.slice(cursor+2,cursor+2+sig[cursor+1]);cursor+=2+sig[cursor+1];var r=BigInteger.fromByteArrayUnsigned(rBa);var s=BigInteger.fromByteArrayUnsigned(sBa);return{r:r,s:s}},parseSigCompact:function(sig){if(sig.length!==65){throw new Error("Signature has the wrong length")}var i=sig[0]-27;if(i<0||i>7){throw new Error("Invalid signature type")}var n=ecparams.getN();var r=BigInteger.fromByteArrayUnsigned(sig.slice(1,33)).mod(n);var s=BigInteger.fromByteArrayUnsigned(sig.slice(33,65)).mod(n);return{r:r,s:s,i:i}},recoverPubKey:function(r,s,hash,i){i=i&3;var isYEven=i&1;var isSecondKey=i>>1;var n=ecparams.getN();var G=ecparams.getG();var curve=ecparams.getCurve();var p=curve.getQ();var a=curve.getA().toBigInteger();var b=curve.getB().toBigInteger();if(!P_OVER_FOUR){P_OVER_FOUR=p.add(BigInteger.ONE).divide(BigInteger.valueOf(4))}var x=isSecondKey?r.add(n):r;var alpha=x.multiply(x).multiply(x).add(a.multiply(x)).add(b).mod(p);var beta=alpha.modPow(P_OVER_FOUR,p);var y=(beta.isEven()?!isYEven:isYEven)?beta:p.subtract(beta);var R=new ECPointFp(curve,curve.fromBigInteger(x),curve.fromBigInteger(y));R.validate();var e=BigInteger.fromByteArrayUnsigned(hash);var eNeg=BigInteger.ZERO.subtract(e).mod(n);var rInv=r.modInverse(n);var Q=implShamirsTrick(R,s,G,eNeg).multiply(rInv);Q.validate();if(!ECDSA.verifyRaw(e,r,s,Q)){throw new Error("Pubkey recovery unsuccessful")}return Q},calcPubKeyRecoveryParam:function(origPubKey,r,s,hash){for(var i=0;i<4;i++){var pubKey=ECDSA.recoverPubKey(r,s,hash,i);if(pubKey.equals(origPubKey)){return i}}throw new Error("Unable to find valid recovery factor")}};module.exports=ECDSA},{"./convert":57,"./jsbn/ec":62,"./jsbn/jsbn":63,"./jsbn/sec":64,"crypto-js/hmac-sha256":25,"secure-random":53}],59:[function(_dereq_,module,exports){var Address=_dereq_("./address");var assert=_dereq_("assert");var convert=_dereq_("./convert");var base58check=_dereq_("./base58check");var BigInteger=_dereq_("./jsbn/jsbn");var ecdsa=_dereq_("./ecdsa");var ECPointFp=_dereq_("./jsbn/ec").ECPointFp;var sec=_dereq_("./jsbn/sec");var Network=_dereq_("./network");var util=_dereq_("./util");var ecparams=sec("secp256k1");var ECKey=function(input,compressed){if(!(this instanceof ECKey)){return new ECKey(input,compressed)}if(!input){var n=ecparams.getN();this.priv=ecdsa.getBigRandom(n);this.compressed=compressed||false}else this.import(input,compressed)};ECKey.prototype.import=function(input,compressed){function has(li,v){return li.indexOf(v)>=0}function fromBin(x){return BigInteger.fromByteArrayUnsigned(x)}this.priv=input instanceof ECKey?input.priv:input instanceof BigInteger?input.mod(ecparams.getN()):Array.isArray(input)?fromBin(input.slice(0,32)):typeof input!="string"?null:input.length==44?fromBin(convert.base64ToBytes(input)):input.length==51&&input[0]=="5"?fromBin(base58check.decode(input).payload):input.length==51&&input[0]=="9"?fromBin(base58check.decode(input).payload):input.length==52&&has("LK",input[0])?fromBin(base58check.decode(input).payload.slice(0,32)):input.length==52&&input[0]=="c"?fromBin(base58check.decode(input).payload.slice(0,32)):has([64,65],input.length)?fromBin(convert.hexToBytes(input.slice(0,64))):null;assert(this.priv!==null);this.compressed=compressed!==undefined?compressed:input instanceof ECKey?input.compressed:input instanceof BigInteger?false:Array.isArray(input)?false:typeof input!="string"?null:input.length==44?false:input.length==51&&input[0]=="5"?false:input.length==51&&input[0]=="9"?false:input.length==52&&has("LK",input[0])?true:input.length==52&&input[0]=="c"?true:input.length==64?false:input.length==65?true:null;assert(this.compressed!==null)};ECKey.prototype.getPub=function(compressed){if(compressed===undefined)compressed=this.compressed;return ECPubKey(ecparams.getG().multiply(this.priv),compressed)};ECKey.prototype.toBin=function(){return convert.bytesToString(this.toBytes())};ECKey.version_bytes={0:128,111:239};ECKey.prototype.toWif=function(version){version=version||Network.mainnet.addressVersion;return base58check.encode(this.toBytes(),ECKey.version_bytes[version])};ECKey.prototype.toHex=function(){return convert.bytesToHex(this.toBytes())};ECKey.prototype.toBytes=function(){var bytes=this.priv.toByteArrayUnsigned();if(this.compressed)bytes.push(1);return bytes};ECKey.prototype.toBase64=function(){return convert.bytesToBase64(this.toBytes())};ECKey.prototype.toString=ECKey.prototype.toHex;ECKey.prototype.getAddress=function(version){return this.getPub().getAddress(version)};ECKey.prototype.add=function(key){return ECKey(this.priv.add(ECKey(key).priv),this.compressed)};ECKey.prototype.multiply=function(key){return ECKey(this.priv.multiply(ECKey(key).priv),this.compressed)};ECKey.prototype.sign=function(hash){return ecdsa.sign(hash,this.priv)};ECKey.prototype.verify=function(hash,sig){return this.getPub().verify(hash,sig)};var ECPubKey=function(input,compressed){if(!(this instanceof ECPubKey)){return new ECPubKey(input,compressed)}this.import(input,compressed)};ECPubKey.prototype.import=function(input,compressed){var decode=function(x){return ECPointFp.decodeFrom(ecparams.getCurve(),x)};this.pub=input instanceof ECPointFp?input:input instanceof ECKey?ecparams.getG().multiply(input.priv):input instanceof ECPubKey?input.pub:typeof input=="string"?decode(convert.hexToBytes(input)):Array.isArray(input)?decode(input):null;assert(this.pub!==null);this.compressed=compressed?compressed:input instanceof ECPointFp?input.compressed:input instanceof ECPubKey?input.compressed:this.pub[0]<4};ECPubKey.prototype.add=function(key){return ECPubKey(this.pub.add(ECPubKey(key).pub),this.compressed)};ECPubKey.prototype.multiply=function(key){return ECPubKey(this.pub.multiply(ECKey(key).priv),this.compressed)};ECPubKey.prototype.toBytes=function(compressed){if(compressed===undefined)compressed=this.compressed;return this.pub.getEncoded(compressed)};ECPubKey.prototype.toHex=function(compressed){return convert.bytesToHex(this.toBytes(compressed))};ECPubKey.prototype.toBin=function(compressed){return convert.bytesToString(this.toBytes(compressed))};ECPubKey.prototype.toWif=function(version){version=version||Network.mainnet.addressVersion;return base58check.encode(this.toBytes(),version)};ECPubKey.prototype.toString=ECPubKey.prototype.toHex;ECPubKey.prototype.getAddress=function(version){version=version||Network.mainnet.addressVersion;return new Address(util.sha256ripe160(this.toBytes()),version)};ECPubKey.prototype.verify=function(hash,sig){return ecdsa.verify(hash,sig,this.toBytes())};module.exports={ECKey:ECKey,ECPubKey:ECPubKey}},{"./address":54,"./base58check":56,"./convert":57,"./ecdsa":58,"./jsbn/ec":62,"./jsbn/jsbn":63,"./jsbn/sec":64,"./network":66,"./util":70,assert:1}],60:[function(_dereq_,module,exports){(function(Buffer){var convert=_dereq_("./convert.js");var base58=_dereq_("./base58.js");var assert=_dereq_("assert");var format=_dereq_("util").format;var util=_dereq_("./util.js");var Crypto=_dereq_("crypto-js");var HmacSHA512=Crypto.HmacSHA512;var HMAC=Crypto.algo.HMAC;var ECKey=_dereq_("./eckey.js").ECKey;var ECPubKey=_dereq_("./eckey.js").ECPubKey;var Address=_dereq_("./address.js");var Network=_dereq_("./network");var crypto=_dereq_("crypto");function sha256(buf){var hash=crypto.createHash("sha256");hash.update(buf);return hash.digest()}function HDWallet(seed,network){if(seed===undefined)return;var seedWords=convert.bytesToWordArray(seed);var I=convert.wordArrayToBytes(HmacSHA512(seedWords,"Bitcoin seed"));this.chaincode=I.slice(32);this.network=network||"mainnet";if(!Network.hasOwnProperty(this.network)){throw new Error("Unknown network: "+this.network)}this.priv=new ECKey(I.slice(0,32).concat([1]),true);this.pub=this.priv.getPub();this.index=0;this.depth=0}HDWallet.HIGHEST_BIT=2147483648;HDWallet.LENGTH=78;function arrayEqual(a,b){return!(a<b||a>b)}HDWallet.fromSeedHex=function(hex,network){return new HDWallet(convert.hexToBytes(hex),network)};HDWallet.fromSeedString=function(string,network){return new HDWallet(convert.stringToBytes(string),network)};HDWallet.fromBase58=function(string){var buffer=base58.decode(string);var payload=buffer.slice(0,-4);var checksum=buffer.slice(-4);var newChecksum=sha256(sha256(payload)).slice(0,4);assert.deepEqual(newChecksum,checksum);assert.equal(payload.length,HDWallet.LENGTH);return HDWallet.fromBytes(payload)};HDWallet.fromHex=function(input){return HDWallet.fromBytes(convert.hexToBytes(input))};HDWallet.fromBytes=function(input){if(input.length!=HDWallet.LENGTH){throw new Error(format("Invalid input length, %s. Expected %s.",input.length,HDWallet.LENGTH))}if(Buffer.isBuffer(input)){input=Array.prototype.map.bind(input,function(x){return x})()}var hd=new HDWallet;var versionBytes=input.slice(0,4);var versionWord=convert.bytesToWords(versionBytes)[0];var type;for(var name in Network){var network=Network[name];for(var t in network.hdVersions){if(versionWord!=network.hdVersions[t])continue;type=t;hd.network=name}}if(!hd.network){throw new Error(format("Could not find version %s",convert.bytesToHex(versionBytes)))}hd.depth=input[4];hd.parentFingerprint=input.slice(5,9);assert(hd.depth===0==arrayEqual(hd.parentFingerprint,[0,0,0,0]));hd.index=convert.bytesToNum(input.slice(9,13).reverse());assert(hd.depth>0||hd.index===0);hd.chaincode=input.slice(13,45);if(type=="priv"){hd.priv=new ECKey(input.slice(46,78).concat([1]),true);hd.pub=hd.priv.getPub()}else{hd.pub=new ECPubKey(input.slice(45,78),true)}return hd};HDWallet.prototype.getIdentifier=function(){return util.sha256ripe160(this.pub.toBytes())};HDWallet.prototype.getFingerprint=function(){return this.getIdentifier().slice(0,4)};HDWallet.prototype.getAddress=function(){return new Address(util.sha256ripe160(this.pub.toBytes()),this.getKeyVersion())};HDWallet.prototype.toBytes=function(priv){var buffer=[];var version=Network[this.network].hdVersions[priv?"priv":"pub"];var vBytes=convert.wordsToBytes([version]);buffer=buffer.concat(vBytes);assert.equal(buffer.length,4);buffer.push(this.depth);assert.equal(buffer.length,4+1);buffer=buffer.concat(this.depth?this.parentFingerprint:[0,0,0,0]);assert.equal(buffer.length,4+1+4);buffer=buffer.concat(convert.numToBytes(this.index,4).reverse());assert.equal(buffer.length,4+1+4+4);buffer=buffer.concat(this.chaincode);assert.equal(buffer.length,4+1+4+4+32);if(priv){assert(this.priv,"Cannot serialize to private without private key");buffer.push(0);buffer=buffer.concat(this.priv.toBytes().slice(0,32))}else{buffer=buffer.concat(this.pub.toBytes(true))}return buffer};HDWallet.prototype.toHex=function(priv){var bytes=this.toBytes(priv);return convert.bytesToHex(bytes)};HDWallet.prototype.toBase58=function(priv){var buffer=new Buffer(this.toBytes(priv));var checksum=sha256(sha256(buffer)).slice(0,4);return base58.encode(Buffer.concat([buffer,checksum]))};HDWallet.prototype.derive=function(i){var I,iBytes=convert.numToBytes(i,4).reverse(),cPar=this.chaincode,usePriv=i>=HDWallet.HIGHEST_BIT,SHA512=Crypto.algo.SHA512;if(usePriv){assert(this.priv,"Private derive on public key");var kPar=this.priv.toBytes().slice(0,32);I=HmacFromBytesToBytes(SHA512,[0].concat(kPar,iBytes),cPar)}else{var KPar=this.pub.toBytes(true);I=HmacFromBytesToBytes(SHA512,KPar.concat(iBytes),cPar)}var IL=I.slice(0,32),IR=I.slice(32);var hd=new HDWallet;hd.network=this.network;if(this.priv){hd.priv=this.priv.add(new ECKey(IL.concat([1])));hd.priv.compressed=true;hd.priv.version=this.getKeyVersion();hd.pub=hd.priv.getPub()}else{hd.pub=this.pub.add(new ECKey(IL.concat([1]),true).getPub())}hd.chaincode=IR;hd.parentFingerprint=this.getFingerprint();hd.depth=this.depth+1;hd.index=i;hd.pub.compressed=true;return hd};HDWallet.prototype.derivePrivate=function(index){return this.derive(index+HDWallet.HIGHEST_BIT)};HDWallet.prototype.getKeyVersion=function(){return Network[this.network].addressVersion};HDWallet.prototype.toString=HDWallet.prototype.toBase58;function HmacFromBytesToBytes(hasher,message,key){var hmac=HMAC.create(hasher,convert.bytesToWordArray(key));hmac.update(convert.bytesToWordArray(message));return convert.wordArrayToBytes(hmac.finalize())}module.exports=HDWallet}).call(this,_dereq_("buffer").Buffer)},{"./address.js":54,"./base58.js":55,"./convert.js":57,"./eckey.js":59,"./network":66,"./util.js":70,assert:1,buffer:5,crypto:9,"crypto-js":27,util:17}],61:[function(_dereq_,module,exports){var Key=_dereq_("./eckey");var T=_dereq_("./transaction");module.exports={Address:_dereq_("./address"),Key:Key.ECKey,ECKey:Key.ECKey,ECPubKey:Key.ECPubKey,Message:_dereq_("./message"),BigInteger:_dereq_("./jsbn/jsbn"),Crypto:_dereq_("crypto-js"),Script:_dereq_("./script"),Opcode:_dereq_("./opcode"),Transaction:T.Transaction,Util:_dereq_("./util"),TransactionIn:T.TransactionIn,TransactionOut:T.TransactionOut,ECPointFp:_dereq_("./jsbn/ec").ECPointFp,Wallet:_dereq_("./wallet"),network:_dereq_("./network"),ecdsa:_dereq_("./ecdsa"),HDWallet:_dereq_("./hdwallet.js"),base58:_dereq_("./base58"),base58check:_dereq_("./base58check"),convert:_dereq_("./convert")}},{"./address":54,"./base58":55,"./base58check":56,"./convert":57,"./ecdsa":58,"./eckey":59,"./hdwallet.js":60,"./jsbn/ec":62,"./jsbn/jsbn":63,"./message":65,"./network":66,"./opcode":67,"./script":68,"./transaction":69,"./util":70,"./wallet":71,"crypto-js":27}],62:[function(_dereq_,module,exports){var BigInteger=_dereq_("./jsbn"),sec=_dereq_("./sec");function ECFieldElementFp(q,x){this.x=x;this.q=q}function feFpEquals(other){if(other==this)return true;return this.q.equals(other.q)&&this.x.equals(other.x)}function feFpToBigInteger(){return this.x}function feFpNegate(){return new ECFieldElementFp(this.q,this.x.negate().mod(this.q))}function feFpAdd(b){return new ECFieldElementFp(this.q,this.x.add(b.toBigInteger()).mod(this.q))}function feFpSubtract(b){return new ECFieldElementFp(this.q,this.x.subtract(b.toBigInteger()).mod(this.q))}function feFpMultiply(b){return new ECFieldElementFp(this.q,this.x.multiply(b.toBigInteger()).mod(this.q))}function feFpSquare(){return new ECFieldElementFp(this.q,this.x.square().mod(this.q))}function feFpDivide(b){return new ECFieldElementFp(this.q,this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q))}ECFieldElementFp.prototype.equals=feFpEquals;ECFieldElementFp.prototype.toBigInteger=feFpToBigInteger;ECFieldElementFp.prototype.negate=feFpNegate;ECFieldElementFp.prototype.add=feFpAdd;ECFieldElementFp.prototype.subtract=feFpSubtract;ECFieldElementFp.prototype.multiply=feFpMultiply;ECFieldElementFp.prototype.square=feFpSquare;ECFieldElementFp.prototype.divide=feFpDivide;function ECPointFp(curve,x,y,z){this.curve=curve;this.x=x;this.y=y;if(z==null){this.z=BigInteger.ONE}else{this.z=z}this.zinv=null}function pointFpGetX(){if(this.zinv==null){this.zinv=this.z.modInverse(this.curve.q)}return this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q))}function pointFpGetY(){if(this.zinv==null){this.zinv=this.z.modInverse(this.curve.q)}return this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q))}function pointFpEquals(other){if(other==this)return true;if(this.isInfinity())return other.isInfinity();if(other.isInfinity())return this.isInfinity();var u,v;u=other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);if(!u.equals(BigInteger.ZERO))return false;v=other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);return v.equals(BigInteger.ZERO)}function pointFpIsInfinity(){if(this.x==null&&this.y==null)return true;return this.z.equals(BigInteger.ZERO)&&!this.y.toBigInteger().equals(BigInteger.ZERO)}function pointFpNegate(){return new ECPointFp(this.curve,this.x,this.y.negate(),this.z)}function pointFpAdd(b){if(this.isInfinity())return b;if(b.isInfinity())return this;var u=b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);var v=b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);if(BigInteger.ZERO.equals(v)){if(BigInteger.ZERO.equals(u)){return this.twice()}return this.curve.getInfinity()}var THREE=new BigInteger("3");var x1=this.x.toBigInteger();var y1=this.y.toBigInteger();var x2=b.x.toBigInteger();var y2=b.y.toBigInteger();var v2=v.square();var v3=v2.multiply(v);var x1v2=x1.multiply(v2);var zu2=u.square().multiply(this.z);var x3=zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);var y3=x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);var z3=v3.multiply(this.z).multiply(b.z).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(x3),this.curve.fromBigInteger(y3),z3)}function pointFpTwice(){if(this.isInfinity())return this;if(this.y.toBigInteger().signum()==0)return this.curve.getInfinity();var THREE=new BigInteger("3");var x1=this.x.toBigInteger();var y1=this.y.toBigInteger();var y1z1=y1.multiply(this.z);var y1sqz1=y1z1.multiply(y1).mod(this.curve.q);var a=this.curve.a.toBigInteger();
var w=x1.square().multiply(THREE);if(!BigInteger.ZERO.equals(a)){w=w.add(this.z.square().multiply(a))}w=w.mod(this.curve.q);var x3=w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);var y3=w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);var z3=y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(x3),this.curve.fromBigInteger(y3),z3)}function pointFpMultiply(k){if(this.isInfinity())return this;if(k.signum()==0)return this.curve.getInfinity();var e=k;var h=e.multiply(new BigInteger("3"));var neg=this.negate();var R=this;var i;for(i=h.bitLength()-2;i>0;--i){R=R.twice();var hBit=h.testBit(i);var eBit=e.testBit(i);if(hBit!=eBit){R=R.add(hBit?this:neg)}}return R}function pointFpMultiplyTwo(j,x,k){var i;if(j.bitLength()>k.bitLength())i=j.bitLength()-1;else i=k.bitLength()-1;var R=this.curve.getInfinity();var both=this.add(x);while(i>=0){R=R.twice();if(j.testBit(i)){if(k.testBit(i)){R=R.add(both)}else{R=R.add(this)}}else{if(k.testBit(i)){R=R.add(x)}}--i}return R}ECPointFp.prototype.getX=pointFpGetX;ECPointFp.prototype.getY=pointFpGetY;ECPointFp.prototype.equals=pointFpEquals;ECPointFp.prototype.isInfinity=pointFpIsInfinity;ECPointFp.prototype.negate=pointFpNegate;ECPointFp.prototype.add=pointFpAdd;ECPointFp.prototype.twice=pointFpTwice;ECPointFp.prototype.multiply=pointFpMultiply;ECPointFp.prototype.multiplyTwo=pointFpMultiplyTwo;function ECCurveFp(q,a,b){this.q=q;this.a=this.fromBigInteger(a);this.b=this.fromBigInteger(b);this.infinity=new ECPointFp(this,null,null)}function curveFpGetQ(){return this.q}function curveFpGetA(){return this.a}function curveFpGetB(){return this.b}function curveFpEquals(other){if(other==this)return true;return this.q.equals(other.q)&&this.a.equals(other.a)&&this.b.equals(other.b)}function curveFpGetInfinity(){return this.infinity}function curveFpFromBigInteger(x){return new ECFieldElementFp(this.q,x)}function curveFpDecodePointHex(s){switch(parseInt(s.substr(0,2),16)){case 0:return this.infinity;case 2:case 3:return null;case 4:case 6:case 7:var len=(s.length-2)/2;var xHex=s.substr(2,len);var yHex=s.substr(len+2,len);return new ECPointFp(this,this.fromBigInteger(new BigInteger(xHex,16)),this.fromBigInteger(new BigInteger(yHex,16)));default:return null}}ECCurveFp.prototype.getQ=curveFpGetQ;ECCurveFp.prototype.getA=curveFpGetA;ECCurveFp.prototype.getB=curveFpGetB;ECCurveFp.prototype.equals=curveFpEquals;ECCurveFp.prototype.getInfinity=curveFpGetInfinity;ECCurveFp.prototype.fromBigInteger=curveFpFromBigInteger;ECCurveFp.prototype.decodePointHex=curveFpDecodePointHex;function integerToBytes(i,len){var bytes=i.toByteArrayUnsigned();if(len<bytes.length){bytes=bytes.slice(bytes.length-len)}else while(len>bytes.length){bytes.unshift(0)}return bytes}ECFieldElementFp.prototype.getByteLength=function(){return Math.floor((this.toBigInteger().bitLength()+7)/8)};ECPointFp.prototype.getEncoded=function(compressed){var x=this.getX().toBigInteger();var y=this.getY().toBigInteger();var enc=integerToBytes(x,32);if(compressed){if(y.isEven()){enc.unshift(2)}else{enc.unshift(3)}}else{enc.unshift(4);enc=enc.concat(integerToBytes(y,32))}return enc};ECPointFp.decodeFrom=function(ecparams,enc){var type=enc[0];var dataLen=enc.length-1;if(type==4){var xBa=enc.slice(1,1+dataLen/2),yBa=enc.slice(1+dataLen/2,1+dataLen),x=BigInteger.fromByteArrayUnsigned(xBa),y=BigInteger.fromByteArrayUnsigned(yBa)}else{var xBa=enc.slice(1),x=BigInteger.fromByteArrayUnsigned(xBa),p=ecparams.getQ(),xCubedPlus7=x.multiply(x).multiply(x).add(new BigInteger("7")).mod(p),pPlus1Over4=p.add(new BigInteger("1")).divide(new BigInteger("4")),y=xCubedPlus7.modPow(pPlus1Over4,p);if(y.mod(new BigInteger("2")).toString()!=""+type%2){y=p.subtract(y)}}return new ECPointFp(ecparams,ecparams.fromBigInteger(x),ecparams.fromBigInteger(y))};ECPointFp.prototype.add2D=function(b){if(this.isInfinity())return b;if(b.isInfinity())return this;if(this.x.equals(b.x)){if(this.y.equals(b.y)){return this.twice()}return this.curve.getInfinity()}var x_x=b.x.subtract(this.x);var y_y=b.y.subtract(this.y);var gamma=y_y.divide(x_x);var x3=gamma.square().subtract(this.x).subtract(b.x);var y3=gamma.multiply(this.x.subtract(x3)).subtract(this.y);return new ECPointFp(this.curve,x3,y3)};ECPointFp.prototype.twice2D=function(){if(this.isInfinity())return this;if(this.y.toBigInteger().signum()==0){return this.curve.getInfinity()}var TWO=this.curve.fromBigInteger(BigInteger.valueOf(2));var THREE=this.curve.fromBigInteger(BigInteger.valueOf(3));var gamma=this.x.square().multiply(THREE).add(this.curve.a).divide(this.y.multiply(TWO));var x3=gamma.square().subtract(this.x.multiply(TWO));var y3=gamma.multiply(this.x.subtract(x3)).subtract(this.y);return new ECPointFp(this.curve,x3,y3)};ECPointFp.prototype.multiply2D=function(k){if(this.isInfinity())return this;if(k.signum()==0)return this.curve.getInfinity();var e=k;var h=e.multiply(new BigInteger("3"));var neg=this.negate();var R=this;var i;for(i=h.bitLength()-2;i>0;--i){R=R.twice();var hBit=h.testBit(i);var eBit=e.testBit(i);if(hBit!=eBit){R=R.add2D(hBit?this:neg)}}return R};ECPointFp.prototype.isOnCurve=function(){var x=this.getX().toBigInteger();var y=this.getY().toBigInteger();var a=this.curve.getA().toBigInteger();var b=this.curve.getB().toBigInteger();var n=this.curve.getQ();var lhs=y.multiply(y).mod(n);var rhs=x.multiply(x).multiply(x).add(a.multiply(x)).add(b).mod(n);return lhs.equals(rhs)};ECPointFp.prototype.toString=function(){return"("+this.getX().toBigInteger().toString()+","+this.getY().toBigInteger().toString()+")"};ECPointFp.prototype.validate=function(){var n=this.curve.getQ();if(this.isInfinity()){throw new Error("Point is at infinity.")}var x=this.getX().toBigInteger();var y=this.getY().toBigInteger();if(x.compareTo(BigInteger.ONE)<0||x.compareTo(n.subtract(BigInteger.ONE))>0){throw new Error("x coordinate out of bounds")}if(y.compareTo(BigInteger.ONE)<0||y.compareTo(n.subtract(BigInteger.ONE))>0){throw new Error("y coordinate out of bounds")}if(!this.isOnCurve()){throw new Error("Point is not on the curve.")}if(this.multiply(n).isInfinity()){throw new Error("Point is not a scalar multiple of G.")}return true};module.exports=ECCurveFp;module.exports.ECPointFp=ECPointFp},{"./jsbn":63,"./sec":64}],63:[function(_dereq_,module,exports){(function(Buffer){var dbits;var canary=0xdeadbeefcafe;var j_lm=(canary&16777215)==15715070;function BigInteger(a,b,c){if(!(this instanceof BigInteger)){return new BigInteger(a,b,c)}if(a!=null){if("number"==typeof a)this.fromNumber(a,b,c);else if(b==null&&"string"!=typeof a)this.fromString(a,256);else this.fromString(a,b)}}var proto=BigInteger.prototype;function nbi(){return new BigInteger(null)}function am1(i,x,w,j,c,n){while(--n>=0){var v=x*this[i++]+w[j]+c;c=Math.floor(v/67108864);w[j++]=v&67108863}return c}function am2(i,x,w,j,c,n){var xl=x&32767,xh=x>>15;while(--n>=0){var l=this[i]&32767;var h=this[i++]>>15;var m=xh*l+h*xl;l=xl*l+((m&32767)<<15)+w[j]+(c&1073741823);c=(l>>>30)+(m>>>15)+xh*h+(c>>>30);w[j++]=l&1073741823}return c}function am3(i,x,w,j,c,n){var xl=x&16383,xh=x>>14;while(--n>=0){var l=this[i]&16383;var h=this[i++]>>14;var m=xh*l+h*xl;l=xl*l+((m&16383)<<14)+w[j]+c;c=(l>>28)+(m>>14)+xh*h;w[j++]=l&268435455}return c}BigInteger.prototype.am=am1;dbits=26;BigInteger.prototype.DB=dbits;BigInteger.prototype.DM=(1<<dbits)-1;var DV=BigInteger.prototype.DV=1<<dbits;var BI_FP=52;BigInteger.prototype.FV=Math.pow(2,BI_FP);BigInteger.prototype.F1=BI_FP-dbits;BigInteger.prototype.F2=2*dbits-BI_FP;var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz";var BI_RC=new Array;var rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv)BI_RC[rr++]=vv;rr="a".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;rr="A".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;function int2char(n){return BI_RM.charAt(n)}function intAt(s,i){var c=BI_RC[s.charCodeAt(i)];return c==null?-1:c}function bnpCopyTo(r){for(var i=this.t-1;i>=0;--i)r[i]=this[i];r.t=this.t;r.s=this.s}function bnpFromInt(x){this.t=1;this.s=x<0?-1:0;if(x>0)this[0]=x;else if(x<-1)this[0]=x+DV;else this.t=0}function nbv(i){var r=nbi();r.fromInt(i);return r}function bnpFromString(s,b){var self=this;var k;if(b==16)k=4;else if(b==8)k=3;else if(b==256)k=8;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else{self.fromRadix(s,b);return}self.t=0;self.s=0;var i=s.length,mi=false,sh=0;while(--i>=0){var x=k==8?s[i]&255:intAt(s,i);if(x<0){if(s.charAt(i)=="-")mi=true;continue}mi=false;if(sh==0)self[self.t++]=x;else if(sh+k>self.DB){self[self.t-1]|=(x&(1<<self.DB-sh)-1)<<sh;self[self.t++]=x>>self.DB-sh}else self[self.t-1]|=x<<sh;sh+=k;if(sh>=self.DB)sh-=self.DB}if(k==8&&(s[0]&128)!=0){self.s=-1;if(sh>0)self[self.t-1]|=(1<<self.DB-sh)-1<<sh}self.clamp();if(mi)BigInteger.ZERO.subTo(self,self)}function bnpClamp(){var c=this.s&this.DM;while(this.t>0&&this[this.t-1]==c)--this.t}function bnToString(b){var self=this;if(self.s<0)return"-"+self.negate().toString(b);var k;if(b==16)k=4;else if(b==8)k=3;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else return self.toRadix(b);var km=(1<<k)-1,d,m=false,r="",i=self.t;var p=self.DB-i*self.DB%k;if(i-->0){if(p<self.DB&&(d=self[i]>>p)>0){m=true;r=int2char(d)}while(i>=0){if(p<k){d=(self[i]&(1<<p)-1)<<k-p;d|=self[--i]>>(p+=self.DB-k)}else{d=self[i]>>(p-=k)&km;if(p<=0){p+=self.DB;--i}}if(d>0)m=true;if(m)r+=int2char(d)}}return m?r:"0"}function bnNegate(){var r=nbi();BigInteger.ZERO.subTo(this,r);return r}function bnAbs(){return this.s<0?this.negate():this}function bnCompareTo(a){var r=this.s-a.s;if(r!=0)return r;var i=this.t;r=i-a.t;if(r!=0)return this.s<0?-r:r;while(--i>=0)if((r=this[i]-a[i])!=0)return r;return 0}function nbits(x){var r=1,t;if((t=x>>>16)!=0){x=t;r+=16}if((t=x>>8)!=0){x=t;r+=8}if((t=x>>4)!=0){x=t;r+=4}if((t=x>>2)!=0){x=t;r+=2}if((t=x>>1)!=0){x=t;r+=1}return r}function bnBitLength(){if(this.t<=0)return 0;return this.DB*(this.t-1)+nbits(this[this.t-1]^this.s&this.DM)}function bnpDLShiftTo(n,r){var i;for(i=this.t-1;i>=0;--i)r[i+n]=this[i];for(i=n-1;i>=0;--i)r[i]=0;r.t=this.t+n;r.s=this.s}function bnpDRShiftTo(n,r){for(var i=n;i<this.t;++i)r[i-n]=this[i];r.t=Math.max(this.t-n,0);r.s=this.s}function bnpLShiftTo(n,r){var self=this;var bs=n%self.DB;var cbs=self.DB-bs;var bm=(1<<cbs)-1;var ds=Math.floor(n/self.DB),c=self.s<<bs&self.DM,i;for(i=self.t-1;i>=0;--i){r[i+ds+1]=self[i]>>cbs|c;c=(self[i]&bm)<<bs}for(i=ds-1;i>=0;--i)r[i]=0;r[ds]=c;r.t=self.t+ds+1;r.s=self.s;r.clamp()}function bnpRShiftTo(n,r){var self=this;r.s=self.s;var ds=Math.floor(n/self.DB);if(ds>=self.t){r.t=0;return}var bs=n%self.DB;var cbs=self.DB-bs;var bm=(1<<bs)-1;r[0]=self[ds]>>bs;for(var i=ds+1;i<self.t;++i){r[i-ds-1]|=(self[i]&bm)<<cbs;r[i-ds]=self[i]>>bs}if(bs>0)r[self.t-ds-1]|=(self.s&bm)<<cbs;r.t=self.t-ds;r.clamp()}function bnpSubTo(a,r){var self=this;var i=0,c=0,m=Math.min(a.t,self.t);while(i<m){c+=self[i]-a[i];r[i++]=c&self.DM;c>>=self.DB}if(a.t<self.t){c-=a.s;while(i<self.t){c+=self[i];r[i++]=c&self.DM;c>>=self.DB}c+=self.s}else{c+=self.s;while(i<a.t){c-=a[i];r[i++]=c&self.DM;c>>=self.DB}c-=a.s}r.s=c<0?-1:0;if(c<-1)r[i++]=self.DV+c;else if(c>0)r[i++]=c;r.t=i;r.clamp()}function bnpMultiplyTo(a,r){var x=this.abs(),y=a.abs();var i=x.t;r.t=i+y.t;while(--i>=0)r[i]=0;for(i=0;i<y.t;++i)r[i+x.t]=x.am(0,y[i],r,i,0,x.t);r.s=0;r.clamp();if(this.s!=a.s)BigInteger.ZERO.subTo(r,r)}function bnpSquareTo(r){var x=this.abs();var i=r.t=2*x.t;while(--i>=0)r[i]=0;for(i=0;i<x.t-1;++i){var c=x.am(i,x[i],r,2*i,0,1);if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1))>=x.DV){r[i+x.t]-=x.DV;r[i+x.t+1]=1}}if(r.t>0)r[r.t-1]+=x.am(i,x[i],r,2*i,0,1);r.s=0;r.clamp()}function bnpDivRemTo(m,q,r){var self=this;var pm=m.abs();if(pm.t<=0)return;var pt=self.abs();if(pt.t<pm.t){if(q!=null)q.fromInt(0);if(r!=null)self.copyTo(r);return}if(r==null)r=nbi();var y=nbi(),ts=self.s,ms=m.s;var nsh=self.DB-nbits(pm[pm.t-1]);if(nsh>0){pm.lShiftTo(nsh,y);pt.lShiftTo(nsh,r)}else{pm.copyTo(y);pt.copyTo(r)}var ys=y.t;var y0=y[ys-1];if(y0==0)return;var yt=y0*(1<<self.F1)+(ys>1?y[ys-2]>>self.F2:0);var d1=self.FV/yt,d2=(1<<self.F1)/yt,e=1<<self.F2;var i=r.t,j=i-ys,t=q==null?nbi():q;y.dlShiftTo(j,t);if(r.compareTo(t)>=0){r[r.t++]=1;r.subTo(t,r)}BigInteger.ONE.dlShiftTo(ys,t);t.subTo(y,y);while(y.t<ys)y[y.t++]=0;while(--j>=0){var qd=r[--i]==y0?self.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);if((r[i]+=y.am(0,qd,r,j,0,ys))<qd){y.dlShiftTo(j,t);r.subTo(t,r);while(r[i]<--qd)r.subTo(t,r)}}if(q!=null){r.drShiftTo(ys,q);if(ts!=ms)BigInteger.ZERO.subTo(q,q)}r.t=ys;r.clamp();if(nsh>0)r.rShiftTo(nsh,r);if(ts<0)BigInteger.ZERO.subTo(r,r)}function bnMod(a){var r=nbi();this.abs().divRemTo(a,null,r);if(this.s<0&&r.compareTo(BigInteger.ZERO)>0)a.subTo(r,r);return r}function Classic(m){this.m=m}function cConvert(x){if(x.s<0||x.compareTo(this.m)>=0)return x.mod(this.m);else return x}function cRevert(x){return x}function cReduce(x){x.divRemTo(this.m,null,x)}function cMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r)}function cSqrTo(x,r){x.squareTo(r);this.reduce(r)}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;function bnpInvDigit(){if(this.t<1)return 0;var x=this[0];if((x&1)==0)return 0;var y=x&3;y=y*(2-(x&15)*y)&15;y=y*(2-(x&255)*y)&255;y=y*(2-((x&65535)*y&65535))&65535;y=y*(2-x*y%this.DV)%this.DV;return y>0?this.DV-y:-y}function Montgomery(m){this.m=m;this.mp=m.invDigit();this.mpl=this.mp&32767;this.mph=this.mp>>15;this.um=(1<<m.DB-15)-1;this.mt2=2*m.t}function montConvert(x){var r=nbi();x.abs().dlShiftTo(this.m.t,r);r.divRemTo(this.m,null,r);if(x.s<0&&r.compareTo(BigInteger.ZERO)>0)this.m.subTo(r,r);return r}function montRevert(x){var r=nbi();x.copyTo(r);this.reduce(r);return r}function montReduce(x){while(x.t<=this.mt2)x[x.t++]=0;for(var i=0;i<this.m.t;++i){var j=x[i]&32767;var u0=j*this.mpl+((j*this.mph+(x[i]>>15)*this.mpl&this.um)<<15)&x.DM;j=i+this.m.t;x[j]+=this.m.am(0,u0,x,i,0,this.m.t);while(x[j]>=x.DV){x[j]-=x.DV;x[++j]++}}x.clamp();x.drShiftTo(this.m.t,x);if(x.compareTo(this.m)>=0)x.subTo(this.m,x)}function montSqrTo(x,r){x.squareTo(r);this.reduce(r)}function montMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r)}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;function bnpIsEven(){return(this.t>0?this[0]&1:this.s)==0}function bnpExp(e,z){if(e>4294967295||e<1)return BigInteger.ONE;var r=nbi(),r2=nbi(),g=z.convert(this),i=nbits(e)-1;g.copyTo(r);while(--i>=0){z.sqrTo(r,r2);if((e&1<<i)>0)z.mulTo(r2,g,r);else{var t=r;r=r2;r2=t}}return z.revert(r)}function bnModPowInt(e,m){var z;if(e<256||m.isEven())z=new Classic(m);else z=new Montgomery(m);return this.exp(e,z)}proto.copyTo=bnpCopyTo;proto.fromInt=bnpFromInt;proto.fromString=bnpFromString;proto.clamp=bnpClamp;proto.dlShiftTo=bnpDLShiftTo;proto.drShiftTo=bnpDRShiftTo;proto.lShiftTo=bnpLShiftTo;proto.rShiftTo=bnpRShiftTo;proto.subTo=bnpSubTo;proto.multiplyTo=bnpMultiplyTo;proto.squareTo=bnpSquareTo;proto.divRemTo=bnpDivRemTo;proto.invDigit=bnpInvDigit;proto.isEven=bnpIsEven;proto.exp=bnpExp;proto.toString=bnToString;proto.negate=bnNegate;proto.abs=bnAbs;proto.compareTo=bnCompareTo;proto.bitLength=bnBitLength;proto.mod=bnMod;proto.modPowInt=bnModPowInt;function nbi(){return new BigInteger(null)}function bnClone(){var r=nbi();this.copyTo(r);return r}function bnIntValue(){if(this.s<0){if(this.t==1)return this[0]-this.DV;else if(this.t==0)return-1}else if(this.t==1)return this[0];else if(this.t==0)return 0;return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]}function bnByteValue(){return this.t==0?this.s:this[0]<<24>>24}function bnShortValue(){return this.t==0?this.s:this[0]<<16>>16}function bnpChunkSize(r){return Math.floor(Math.LN2*this.DB/Math.log(r))}function bnSigNum(){if(this.s<0)return-1;else if(this.t<=0||this.t==1&&this[0]<=0)return 0;else return 1}function bnpToRadix(b){if(b==null)b=10;if(this.signum()==0||b<2||b>36)return"0";var cs=this.chunkSize(b);var a=Math.pow(b,cs);var d=nbv(a),y=nbi(),z=nbi(),r="";this.divRemTo(d,y,z);while(y.signum()>0){r=(a+z.intValue()).toString(b).substr(1)+r;y.divRemTo(d,y,z)}return z.intValue().toString(b)+r}function bnpFromRadix(s,b){var self=this;self.fromInt(0);if(b==null)b=10;var cs=self.chunkSize(b);var d=Math.pow(b,cs),mi=false,j=0,w=0;for(var i=0;i<s.length;++i){var x=intAt(s,i);if(x<0){if(s.charAt(i)=="-"&&self.signum()==0)mi=true;continue}w=b*w+x;if(++j>=cs){self.dMultiply(d);self.dAddOffset(w,0);j=0;w=0}}if(j>0){self.dMultiply(Math.pow(b,j));self.dAddOffset(w,0)}if(mi)BigInteger.ZERO.subTo(self,self)}function bnpFromNumber(a,b,c){var self=this;if("number"==typeof b){if(a<2)self.fromInt(1);else{self.fromNumber(a,c);if(!self.testBit(a-1))self.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,self);if(self.isEven())self.dAddOffset(1,0);while(!self.isProbablePrime(b)){self.dAddOffset(2,0);if(self.bitLength()>a)self.subTo(BigInteger.ONE.shiftLeft(a-1),self)}}}else{var t=a&7;var length=(a>>3)+1;var x=b(length,{array:true});if(t>0)x[0]&=(1<<t)-1;else x[0]=0;self.fromString(x,256)}}function bnToByteArray(){var self=this;var i=self.t,r=new Array;r[0]=self.s;var p=self.DB-i*self.DB%8,d,k=0;if(i-->0){if(p<self.DB&&(d=self[i]>>p)!=(self.s&self.DM)>>p)r[k++]=d|self.s<<self.DB-p;while(i>=0){if(p<8){d=(self[i]&(1<<p)-1)<<8-p;d|=self[--i]>>(p+=self.DB-8)}else{d=self[i]>>(p-=8)&255;if(p<=0){p+=self.DB;--i}}if((d&128)!=0)d|=-256;if(k===0&&(self.s&128)!=(d&128))++k;if(k>0||d!=self.s)r[k++]=d}}return r}function bnEquals(a){return this.compareTo(a)==0}function bnMin(a){return this.compareTo(a)<0?this:a}function bnMax(a){return this.compareTo(a)>0?this:a}function bnpBitwiseTo(a,op,r){var self=this;var i,f,m=Math.min(a.t,self.t);for(i=0;i<m;++i)r[i]=op(self[i],a[i]);if(a.t<self.t){f=a.s&self.DM;for(i=m;i<self.t;++i)r[i]=op(self[i],f);r.t=self.t}else{f=self.s&self.DM;for(i=m;i<a.t;++i)r[i]=op(f,a[i]);r.t=a.t}r.s=op(self.s,a.s);r.clamp()}function op_and(x,y){return x&y}function bnAnd(a){var r=nbi();this.bitwiseTo(a,op_and,r);return r}function op_or(x,y){return x|y}function bnOr(a){var r=nbi();this.bitwiseTo(a,op_or,r);return r}function op_xor(x,y){return x^y}function bnXor(a){var r=nbi();this.bitwiseTo(a,op_xor,r);return r}function op_andnot(x,y){return x&~y}function bnAndNot(a){var r=nbi();this.bitwiseTo(a,op_andnot,r);return r}function bnNot(){var r=nbi();for(var i=0;i<this.t;++i)r[i]=this.DM&~this[i];r.t=this.t;r.s=~this.s;return r}function bnShiftLeft(n){var r=nbi();if(n<0)this.rShiftTo(-n,r);else this.lShiftTo(n,r);return r}function bnShiftRight(n){var r=nbi();if(n<0)this.lShiftTo(-n,r);else this.rShiftTo(n,r);return r}function lbit(x){if(x==0)return-1;var r=0;if((x&65535)==0){x>>=16;r+=16}if((x&255)==0){x>>=8;r+=8}if((x&15)==0){x>>=4;r+=4}if((x&3)==0){x>>=2;r+=2}if((x&1)==0)++r;return r}function bnGetLowestSetBit(){for(var i=0;i<this.t;++i)if(this[i]!=0)return i*this.DB+lbit(this[i]);if(this.s<0)return this.t*this.DB;return-1}function cbit(x){var r=0;while(x!=0){x&=x-1;++r}return r}function bnBitCount(){var r=0,x=this.s&this.DM;for(var i=0;i<this.t;++i)r+=cbit(this[i]^x);return r}function bnTestBit(n){var j=Math.floor(n/this.DB);if(j>=this.t)return this.s!=0;return(this[j]&1<<n%this.DB)!=0}function bnpChangeBit(n,op){var r=BigInteger.ONE.shiftLeft(n);this.bitwiseTo(r,op,r);return r}function bnSetBit(n){return this.changeBit(n,op_or)}function bnClearBit(n){return this.changeBit(n,op_andnot)}function bnFlipBit(n){return this.changeBit(n,op_xor)}function bnpAddTo(a,r){var self=this;var i=0,c=0,m=Math.min(a.t,self.t);while(i<m){c+=self[i]+a[i];r[i++]=c&self.DM;c>>=self.DB}if(a.t<self.t){c+=a.s;while(i<self.t){c+=self[i];r[i++]=c&self.DM;c>>=self.DB}c+=self.s}else{c+=self.s;while(i<a.t){c+=a[i];r[i++]=c&self.DM;c>>=self.DB}c+=a.s}r.s=c<0?-1:0;if(c>0)r[i++]=c;else if(c<-1)r[i++]=self.DV+c;r.t=i;r.clamp()}function bnAdd(a){var r=nbi();this.addTo(a,r);return r}function bnSubtract(a){var r=nbi();this.subTo(a,r);return r}function bnMultiply(a){var r=nbi();this.multiplyTo(a,r);return r}function bnSquare(){var r=nbi();this.squareTo(r);return r}function bnDivide(a){var r=nbi();this.divRemTo(a,r,null);return r}function bnRemainder(a){var r=nbi();this.divRemTo(a,null,r);return r}function bnDivideAndRemainder(a){var q=nbi(),r=nbi();this.divRemTo(a,q,r);return new Array(q,r)}function bnpDMultiply(n){this[this.t]=this.am(0,n-1,this,0,0,this.t);++this.t;this.clamp()}function bnpDAddOffset(n,w){if(n==0)return;while(this.t<=w)this[this.t++]=0;this[w]+=n;while(this[w]>=this.DV){this[w]-=this.DV;if(++w>=this.t)this[this.t++]=0;++this[w]}}function NullExp(){}function nNop(x){return x}function nMulTo(x,y,r){x.multiplyTo(y,r)}function nSqrTo(x,r){x.squareTo(r)}NullExp.prototype.convert=nNop;NullExp.prototype.revert=nNop;NullExp.prototype.mulTo=nMulTo;NullExp.prototype.sqrTo=nSqrTo;function bnPow(e){return this.exp(e,new NullExp)}function bnpMultiplyLowerTo(a,n,r){var i=Math.min(this.t+a.t,n);r.s=0;r.t=i;while(i>0)r[--i]=0;var j;for(j=r.t-this.t;i<j;++i)r[i+this.t]=this.am(0,a[i],r,i,0,this.t);for(j=Math.min(a.t,n);i<j;++i)this.am(0,a[i],r,i,0,n-i);r.clamp()}function bnpMultiplyUpperTo(a,n,r){--n;var i=r.t=this.t+a.t-n;r.s=0;while(--i>=0)r[i]=0;for(i=Math.max(n-this.t,0);i<a.t;++i)r[this.t+i-n]=this.am(n-i,a[i],r,0,0,this.t+i-n);r.clamp();r.drShiftTo(1,r)}function Barrett(m){this.r2=nbi();this.q3=nbi();BigInteger.ONE.dlShiftTo(2*m.t,this.r2);this.mu=this.r2.divide(m);this.m=m}function barrettConvert(x){if(x.s<0||x.t>2*this.m.t)return x.mod(this.m);else if(x.compareTo(this.m)<0)return x;else{var r=nbi();x.copyTo(r);this.reduce(r);return r}}function barrettRevert(x){return x}function barrettReduce(x){var self=this;x.drShiftTo(self.m.t-1,self.r2);if(x.t>self.m.t+1){x.t=self.m.t+1;x.clamp()}self.mu.multiplyUpperTo(self.r2,self.m.t+1,self.q3);self.m.multiplyLowerTo(self.q3,self.m.t+1,self.r2);while(x.compareTo(self.r2)<0)x.dAddOffset(1,self.m.t+1);x.subTo(self.r2,x);while(x.compareTo(self.m)>=0)x.subTo(self.m,x)}function barrettSqrTo(x,r){x.squareTo(r);this.reduce(r)}function barrettMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r)}Barrett.prototype.convert=barrettConvert;Barrett.prototype.revert=barrettRevert;Barrett.prototype.reduce=barrettReduce;Barrett.prototype.mulTo=barrettMulTo;Barrett.prototype.sqrTo=barrettSqrTo;function bnModPow(e,m){var i=e.bitLength(),k,r=nbv(1),z;if(i<=0)return r;else if(i<18)k=1;else if(i<48)k=3;else if(i<144)k=4;else if(i<768)k=5;else k=6;if(i<8)z=new Classic(m);else if(m.isEven())z=new Barrett(m);else z=new Montgomery(m);var g=new Array,n=3,k1=k-1,km=(1<<k)-1;g[1]=z.convert(this);if(k>1){var g2=nbi();z.sqrTo(g[1],g2);while(n<=km){g[n]=nbi();z.mulTo(g2,g[n-2],g[n]);n+=2}}var j=e.t-1,w,is1=true,r2=nbi(),t;i=nbits(e[j])-1;while(j>=0){if(i>=k1)w=e[j]>>i-k1&km;else{w=(e[j]&(1<<i+1)-1)<<k1-i;if(j>0)w|=e[j-1]>>this.DB+i-k1}n=k;while((w&1)==0){w>>=1;--n}if((i-=n)<0){i+=this.DB;--j}if(is1){g[w].copyTo(r);is1=false}else{while(n>1){z.sqrTo(r,r2);z.sqrTo(r2,r);n-=2}if(n>0)z.sqrTo(r,r2);else{t=r;r=r2;r2=t}z.mulTo(r2,g[w],r)}while(j>=0&&(e[j]&1<<i)==0){z.sqrTo(r,r2);t=r;r=r2;r2=t;if(--i<0){i=this.DB-1;--j}}}return z.revert(r)}function bnGCD(a){var x=this.s<0?this.negate():this.clone();var y=a.s<0?a.negate():a.clone();if(x.compareTo(y)<0){var t=x;x=y;y=t}var i=x.getLowestSetBit(),g=y.getLowestSetBit();if(g<0)return x;if(i<g)g=i;if(g>0){x.rShiftTo(g,x);y.rShiftTo(g,y)}while(x.signum()>0){if((i=x.getLowestSetBit())>0)x.rShiftTo(i,x);if((i=y.getLowestSetBit())>0)y.rShiftTo(i,y);if(x.compareTo(y)>=0){x.subTo(y,x);x.rShiftTo(1,x)}else{y.subTo(x,y);y.rShiftTo(1,y)}}if(g>0)y.lShiftTo(g,y);return y}function bnpModInt(n){if(n<=0)return 0;var d=this.DV%n,r=this.s<0?n-1:0;if(this.t>0)if(d==0)r=this[0]%n;else for(var i=this.t-1;i>=0;--i)r=(d*r+this[i])%n;return r}function bnModInverse(m){var ac=m.isEven();if(this.isEven()&&ac||m.signum()==0)return BigInteger.ZERO;var u=m.clone(),v=this.clone();var a=nbv(1),b=nbv(0),c=nbv(0),d=nbv(1);while(u.signum()!=0){while(u.isEven()){u.rShiftTo(1,u);if(ac){if(!a.isEven()||!b.isEven()){a.addTo(this,a);b.subTo(m,b)}a.rShiftTo(1,a)}else if(!b.isEven())b.subTo(m,b);b.rShiftTo(1,b)}while(v.isEven()){v.rShiftTo(1,v);if(ac){if(!c.isEven()||!d.isEven()){c.addTo(this,c);d.subTo(m,d)}c.rShiftTo(1,c)}else if(!d.isEven())d.subTo(m,d);d.rShiftTo(1,d)}if(u.compareTo(v)>=0){u.subTo(v,u);if(ac)a.subTo(c,a);b.subTo(d,b)}else{v.subTo(u,v);if(ac)c.subTo(a,c);d.subTo(b,d)}}if(v.compareTo(BigInteger.ONE)!=0)return BigInteger.ZERO;if(d.compareTo(m)>=0)return d.subtract(m);if(d.signum()<0)d.addTo(m,d);else return d;if(d.signum()<0)return d.add(m);else return d}proto.chunkSize=bnpChunkSize;proto.toRadix=bnpToRadix;proto.fromRadix=bnpFromRadix;proto.fromNumber=bnpFromNumber;proto.bitwiseTo=bnpBitwiseTo;proto.changeBit=bnpChangeBit;proto.addTo=bnpAddTo;proto.dMultiply=bnpDMultiply;proto.dAddOffset=bnpDAddOffset;proto.multiplyLowerTo=bnpMultiplyLowerTo;proto.multiplyUpperTo=bnpMultiplyUpperTo;proto.modInt=bnpModInt;proto.clone=bnClone;proto.intValue=bnIntValue;proto.byteValue=bnByteValue;proto.shortValue=bnShortValue;proto.signum=bnSigNum;proto.toByteArray=bnToByteArray;proto.equals=bnEquals;proto.min=bnMin;proto.max=bnMax;proto.and=bnAnd;proto.or=bnOr;proto.xor=bnXor;proto.andNot=bnAndNot;proto.not=bnNot;proto.shiftLeft=bnShiftLeft;proto.shiftRight=bnShiftRight;proto.getLowestSetBit=bnGetLowestSetBit;proto.bitCount=bnBitCount;proto.testBit=bnTestBit;proto.setBit=bnSetBit;proto.clearBit=bnClearBit;proto.flipBit=bnFlipBit;proto.add=bnAdd;proto.subtract=bnSubtract;proto.multiply=bnMultiply;proto.divide=bnDivide;proto.remainder=bnRemainder;proto.divideAndRemainder=bnDivideAndRemainder;proto.modPow=bnModPow;proto.modInverse=bnModInverse;proto.pow=bnPow;proto.gcd=bnGCD;proto.square=bnSquare;BigInteger.ZERO=nbv(0);BigInteger.ONE=nbv(1);BigInteger.valueOf=nbv;BigInteger.fromByteArrayUnsigned=function(ba){if(Buffer.isBuffer(ba)){ba=Array.prototype.map.bind(ba,function(x){return x})()}if(!ba.length){return new BigInteger.valueOf(0)}else if(ba[0]&128){return new BigInteger([0].concat(ba))}else{return new BigInteger(ba)}};BigInteger.fromByteArraySigned=function(ba){if(ba[0]&128){ba[0]&=127;return BigInteger.fromByteArrayUnsigned(ba).negate()}else{return BigInteger.fromByteArrayUnsigned(ba)}};BigInteger.prototype.toByteArrayUnsigned=function(){var ba=this.abs().toByteArray();if(!ba.length){return ba}if(ba[0]===0){ba=ba.slice(1)}for(var i=0;i<ba.length;++i){ba[i]=ba[i]<0?ba[i]+256:ba[i]}return ba};BigInteger.prototype.toByteArraySigned=function(){var val=this.toByteArrayUnsigned();var neg=this.s<0;if(val[0]&128){val.unshift(neg?128:0)}else if(neg){val[0]|=128}return val};module.exports=BigInteger}).call(this,_dereq_("buffer").Buffer)},{buffer:5}],64:[function(_dereq_,module,exports){var ECCurveFp=_dereq_("./ec");var BigInteger=_dereq_("./jsbn");function X9ECParameters(curve,g,n,h){this.curve=curve;this.g=g;this.n=n;this.h=h}function x9getCurve(){return this.curve}function x9getG(){return this.g}function x9getN(){return this.n}function x9getH(){return this.h}X9ECParameters.prototype.getCurve=x9getCurve;X9ECParameters.prototype.getG=x9getG;X9ECParameters.prototype.getN=x9getN;X9ECParameters.prototype.getH=x9getH;function fromHex(s){return new BigInteger(s,16)}function secp128r1(){var p=fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");var a=fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");var b=fromHex("E87579C11079F43DD824993C2CEE5ED3");var n=fromHex("FFFFFFFE0000000075A30D1B9038A115");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"161FF7528B899B2D0C28607CA52C5B86"+"CF5AC8395BAFEB13C02DA292DDED7A83");return new X9ECParameters(curve,G,n,h)}function secp160k1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");var a=BigInteger.ZERO;var b=fromHex("7");var n=fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"3B4C382CE37AA192A4019E763036F4F5DD4D7EBB"+"938CF935318FDCED6BC28286531733C3F03C4FEE");return new X9ECParameters(curve,G,n,h)}function secp160r1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");var a=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");var b=fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");var n=fromHex("0100000000000000000001F4C8F927AED3CA752257");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"4A96B5688EF573284664698968C38BB913CBFC82"+"23A628553168947D59DCC912042351377AC5FB32");return new X9ECParameters(curve,G,n,h)}function secp192k1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");var a=BigInteger.ZERO;var b=fromHex("3");var n=fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D"+"9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");return new X9ECParameters(curve,G,n,h)}function secp192r1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");var a=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");var b=fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");var n=fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012"+"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811");return new X9ECParameters(curve,G,n,h)}function secp224r1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");var a=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");var b=fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");var n=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21"+"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");return new X9ECParameters(curve,G,n,h)}function secp256k1(){var p=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F");var a=BigInteger.ZERO;var b=fromHex("7");var n=fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798"+"483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8");return new X9ECParameters(curve,G,n,h)}function secp256r1(){var p=fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");var a=fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");var b=fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");var n=fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");var h=BigInteger.ONE;var curve=new ECCurveFp(p,a,b);var G=curve.decodePointHex("04"+"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296"+"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");return new X9ECParameters(curve,G,n,h)}function getSECCurveByName(name){if(name=="secp128r1")return secp128r1();if(name=="secp160k1")return secp160k1();if(name=="secp160r1")return secp160r1();if(name=="secp192k1")return secp192k1();if(name=="secp192r1")return secp192r1();if(name=="secp224r1")return secp224r1();if(name=="secp256k1")return secp256k1();if(name=="secp256r1")return secp256r1();return null}module.exports=getSECCurveByName},{"./ec":62,"./jsbn":63}],65:[function(_dereq_,module,exports){var Address=_dereq_("./address");var convert=_dereq_("./convert");var ecdsa=_dereq_("./ecdsa");var ECPubKey=_dereq_("./eckey").ECPubKey;var SHA256=_dereq_("crypto-js/sha256");var magicBytes=convert.stringToBytes("Bitcoin Signed Message:\n");function magicHash(message){var messageBytes=convert.stringToBytes(message);var buffer=[].concat(convert.numToVarInt(magicBytes.length),magicBytes,convert.numToVarInt(messageBytes.length),messageBytes);
return convert.wordArrayToBytes(SHA256(SHA256(convert.bytesToWordArray(buffer))))}function sign(key,message){var hash=magicHash(message);var sig=key.sign(hash);var obj=ecdsa.parseSig(sig);var i=ecdsa.calcPubKeyRecoveryParam(key.getPub().pub,obj.r,obj.s,hash);i+=27;if(key.compressed){i+=4}var rBa=obj.r.toByteArrayUnsigned();var sBa=obj.s.toByteArrayUnsigned();while(rBa.length<32)rBa.unshift(0);while(sBa.length<32)sBa.unshift(0);sig=[i].concat(rBa,sBa);return sig}function verify(address,sig,message){sig=ecdsa.parseSigCompact(sig);var pubKey=new ECPubKey(ecdsa.recoverPubKey(sig.r,sig.s,magicHash(message),sig.i));var isCompressed=!!(sig.i&4);pubKey.compressed=isCompressed;address=new Address(address);return pubKey.getAddress(address.version).toString()===address.toString()}module.exports={magicHash:magicHash,sign:sign,verify:verify}},{"./address":54,"./convert":57,"./ecdsa":58,"./eckey":59,"crypto-js/sha256":47}],66:[function(_dereq_,module,exports){module.exports={mainnet:{addressVersion:0,p2shVersion:5,hdVersions:{pub:76067358,priv:76066276}},testnet:{addressVersion:111,p2shVersion:196,hdVersions:{pub:70617039,priv:70615956}}}},{}],67:[function(_dereq_,module,exports){var Opcode={map:{OP_0:0,OP_FALSE:0,OP_PUSHDATA1:76,OP_PUSHDATA2:77,OP_PUSHDATA4:78,OP_1NEGATE:79,OP_RESERVED:80,OP_1:81,OP_TRUE:81,OP_2:82,OP_3:83,OP_4:84,OP_5:85,OP_6:86,OP_7:87,OP_8:88,OP_9:89,OP_10:90,OP_11:91,OP_12:92,OP_13:93,OP_14:94,OP_15:95,OP_16:96,OP_NOP:97,OP_VER:98,OP_IF:99,OP_NOTIF:100,OP_VERIF:101,OP_VERNOTIF:102,OP_ELSE:103,OP_ENDIF:104,OP_VERIFY:105,OP_RETURN:106,OP_TOALTSTACK:107,OP_FROMALTSTACK:108,OP_2DROP:109,OP_2DUP:110,OP_3DUP:111,OP_2OVER:112,OP_2ROT:113,OP_2SWAP:114,OP_IFDUP:115,OP_DEPTH:116,OP_DROP:117,OP_DUP:118,OP_NIP:119,OP_OVER:120,OP_PICK:121,OP_ROLL:122,OP_ROT:123,OP_SWAP:124,OP_TUCK:125,OP_CAT:126,OP_SUBSTR:127,OP_LEFT:128,OP_RIGHT:129,OP_SIZE:130,OP_INVERT:131,OP_AND:132,OP_OR:133,OP_XOR:134,OP_EQUAL:135,OP_EQUALVERIFY:136,OP_RESERVED1:137,OP_RESERVED2:138,OP_1ADD:139,OP_1SUB:140,OP_2MUL:141,OP_2DIV:142,OP_NEGATE:143,OP_ABS:144,OP_NOT:145,OP_0NOTEQUAL:146,OP_ADD:147,OP_SUB:148,OP_MUL:149,OP_DIV:150,OP_MOD:151,OP_LSHIFT:152,OP_RSHIFT:153,OP_BOOLAND:154,OP_BOOLOR:155,OP_NUMEQUAL:156,OP_NUMEQUALVERIFY:157,OP_NUMNOTEQUAL:158,OP_LESSTHAN:159,OP_GREATERTHAN:160,OP_LESSTHANOREQUAL:161,OP_GREATERTHANOREQUAL:162,OP_MIN:163,OP_MAX:164,OP_WITHIN:165,OP_RIPEMD160:166,OP_SHA1:167,OP_SHA256:168,OP_HASH160:169,OP_HASH256:170,OP_CODESEPARATOR:171,OP_CHECKSIG:172,OP_CHECKSIGVERIFY:173,OP_CHECKMULTISIG:174,OP_CHECKMULTISIGVERIFY:175,OP_NOP1:176,OP_NOP2:177,OP_NOP3:178,OP_NOP4:179,OP_NOP5:180,OP_NOP6:181,OP_NOP7:182,OP_NOP8:183,OP_NOP9:184,OP_NOP10:185,OP_PUBKEYHASH:253,OP_PUBKEY:254,OP_INVALIDOPCODE:255},reverseMap:[]};for(var i in Opcode.map){Opcode.reverseMap[Opcode.map[i]]=i}module.exports=Opcode},{}],68:[function(_dereq_,module,exports){(function(Buffer){var Opcode=_dereq_("./opcode");var util=_dereq_("./util");var convert=_dereq_("./convert");var Address=_dereq_("./address");var network=_dereq_("./network");var Script=function(data){this.buffer=data||[];if(!Array.isArray(this.buffer)){throw new Error("expect Script to be initialized with Array, but got "+data)}this.parse()};Script.fromHex=function(data){return new Script(convert.hexToBytes(data))};Script.fromPubKey=function(str){var script=new Script;var s=str.split(" ");for(var i in s){if(Opcode.map.hasOwnProperty(s[i])){script.writeOp(Opcode.map[s[i]])}else{script.writeBytes(convert.hexToBytes(s[i]))}}return script};Script.fromScriptSig=function(str){var script=new Script;var s=str.split(" ");for(var i in s){if(Opcode.map.hasOwnProperty(s[i])){script.writeOp(Opcode.map[s[i]])}else{script.writeBytes(convert.hexToBytes(s[i]))}}return script};Script.prototype.parse=function(){var self=this;this.chunks=[];var i=0;function readChunk(n){self.chunks.push(self.buffer.slice(i,i+n));i+=n}while(i<this.buffer.length){var opcode=this.buffer[i++];if(opcode>=240){opcode=opcode<<8|this.buffer[i++]}var len;if(opcode>0&&opcode<Opcode.map.OP_PUSHDATA1){readChunk(opcode)}else if(opcode==Opcode.map.OP_PUSHDATA1){len=this.buffer[i++];readChunk(len)}else if(opcode==Opcode.map.OP_PUSHDATA2){len=this.buffer[i++]<<8|this.buffer[i++];readChunk(len)}else if(opcode==Opcode.map.OP_PUSHDATA4){len=this.buffer[i++]<<24|this.buffer[i++]<<16|this.buffer[i++]<<8|this.buffer[i++];readChunk(len)}else{this.chunks.push(opcode)}}};Script.prototype.getOutType=function(){if(this.chunks[this.chunks.length-1]==Opcode.map.OP_EQUAL&&this.chunks[0]==Opcode.map.OP_HASH160&&this.chunks.length==3){return"P2SH"}else if(this.chunks.length==5&&this.chunks[0]==Opcode.map.OP_DUP&&this.chunks[1]==Opcode.map.OP_HASH160&&this.chunks[3]==Opcode.map.OP_EQUALVERIFY&&this.chunks[4]==Opcode.map.OP_CHECKSIG){return"Pubkey"}else{return"Strange"}};Script.prototype.toScriptHash=function(){var outType=this.getOutType();if(outType=="Pubkey"){return this.chunks[2]}if(outType=="P2SH"){return util.sha256ripe160(this.buffer)}return util.sha256ripe160(this.buffer)};Script.prototype.getToAddress=function(){var outType=this.getOutType();if(outType=="Pubkey"){return new Address(this.chunks[2])}if(outType=="P2SH"){return new Address(this.chunks[1],5)}return new Address(this.chunks[1],5)};Script.prototype.getFromAddress=function(){return new Address(this.simpleInHash())};Script.prototype.getInType=function(){if(this.chunks.length==1&&Array.isArray(this.chunks[0])){return"Pubkey"}else if(this.chunks.length==2&&Array.isArray(this.chunks[0])&&Array.isArray(this.chunks[1])){return"Address"}else if(this.chunks[0]==Opcode.map.OP_0&&this.chunks.slice(1).reduce(function(t,chunk,i){return t&&Array.isArray(chunk)&&(chunk[0]==48||i==this.chunks.length-1)},true)){return"Multisig"}else{return"Strange"}};Script.prototype.simpleInPubKey=function(){switch(this.getInType()){case"Address":return this.chunks[1];case"Pubkey":throw new Error("Script does not contain pubkey");default:throw new Error("Encountered non-standard scriptSig")}};Script.prototype.simpleInHash=function(){return util.sha256ripe160(this.simpleInPubKey())};Script.prototype.simpleInPubKeyHash=Script.prototype.simpleInHash;Script.prototype.writeOp=function(opcode){this.buffer.push(opcode);this.chunks.push(opcode)};Script.prototype.writeBytes=function(data){if(Buffer.isBuffer(data)){data=Array.prototype.map.bind(data,function(x){return x})()}if(data.length<Opcode.map.OP_PUSHDATA1){this.buffer.push(data.length)}else if(data.length<=255){this.buffer.push(Opcode.map.OP_PUSHDATA1);this.buffer.push(data.length)}else if(data.length<=65535){this.buffer.push(Opcode.map.OP_PUSHDATA2);this.buffer.push(data.length&255);this.buffer.push(data.length>>>8&255)}else{this.buffer.push(Opcode.map.OP_PUSHDATA4);this.buffer.push(data.length&255);this.buffer.push(data.length>>>8&255);this.buffer.push(data.length>>>16&255);this.buffer.push(data.length>>>24&255)}this.buffer=this.buffer.concat(data);this.chunks.push(data)};Script.createOutputScript=function(address){var script=new Script;address=new Address(address);if(address.version==network.mainnet.p2shVersion||address.version==network.testnet.p2shVersion){script.writeOp(Opcode.map.OP_HASH160);script.writeBytes(address.hash);script.writeOp(Opcode.map.OP_EQUAL)}else{script.writeOp(Opcode.map.OP_DUP);script.writeOp(Opcode.map.OP_HASH160);script.writeBytes(address.hash);script.writeOp(Opcode.map.OP_EQUALVERIFY);script.writeOp(Opcode.map.OP_CHECKSIG)}return script};Script.prototype.extractPubkeys=function(){return this.chunks.filter(function(chunk){return chunk[0]==4&&chunk.length==65||chunk[0]<4&&chunk.length==33})};Script.createMultiSigOutputScript=function(m,pubkeys){var script=new Script;pubkeys=pubkeys.sort();script.writeOp(Opcode.map.OP_1+m-1);for(var i=0;i<pubkeys.length;++i){script.writeBytes(pubkeys[i])}script.writeOp(Opcode.map.OP_1+pubkeys.length-1);script.writeOp(Opcode.map.OP_CHECKMULTISIG);return script};Script.createInputScript=function(signature,pubKey){var script=new Script;script.writeBytes(signature);script.writeBytes(pubKey);return script};Script.createMultiSigInputScript=function(signatures,script){script=new Script(script);var k=script.chunks[0][0];if(signatures.length<k)return false;var inScript=new Script;inScript.writeOp(Opcode.map.OP_0);signatures.map(function(sig){inScript.writeBytes(sig)});inScript.writeBytes(script.buffer);return inScript};Script.prototype.clone=function(){return new Script(this.buffer)};module.exports=Script}).call(this,_dereq_("buffer").Buffer)},{"./address":54,"./convert":57,"./network":66,"./opcode":67,"./util":70,buffer:5}],69:[function(_dereq_,module,exports){var BigInteger=_dereq_("./jsbn/jsbn");var Script=_dereq_("./script");var util=_dereq_("./util");var convert=_dereq_("./convert");var ECKey=_dereq_("./eckey").ECKey;var ECDSA=_dereq_("./ecdsa");var Address=_dereq_("./address");var SHA256=_dereq_("crypto-js/sha256");var Transaction=function(doc){if(!(this instanceof Transaction)){return new Transaction(doc)}this.version=1;this.locktime=0;this.ins=[];this.outs=[];this.defaultSequence=[255,255,255,255];if(doc){if(typeof doc=="string"||Array.isArray(doc)){doc=Transaction.deserialize(doc)}if(doc.hash)this.hash=doc.hash;if(doc.version)this.version=doc.version;if(doc.locktime)this.locktime=doc.locktime;if(doc.ins&&doc.ins.length){doc.ins.forEach(function(input){this.addInput(new TransactionIn(input))},this)}if(doc.outs&&doc.outs.length){doc.outs.forEach(function(output){this.addOutput(new TransactionOut(output))},this)}this.hash=this.hash||this.getHash()}};Transaction.prototype.addInput=function(tx,outIndex){if(arguments[0]instanceof TransactionIn){this.ins.push(arguments[0])}else if(arguments[0].length>65){var args=arguments[0].split(":");return this.addInput(args[0],args[1])}else{var hash=typeof tx==="string"?tx:tx.hash;hash=Array.isArray(hash)?convert.bytesToHex(hash):hash;this.ins.push(new TransactionIn({outpoint:{hash:hash,index:outIndex},script:new Script,sequence:this.defaultSequence}))}};Transaction.prototype.addOutput=function(address,value){if(arguments[0]instanceof TransactionOut){this.outs.push(arguments[0]);return}if(arguments[0].indexOf(":")>=0){var args=arguments[0].split(":");address=args[0];value=parseInt(args[1])}this.outs.push(new TransactionOut({value:value,script:Script.createOutputScript(address)}))};Transaction.prototype.serialize=function(){var buffer=[];buffer=buffer.concat(convert.numToBytes(parseInt(this.version),4));buffer=buffer.concat(convert.numToVarInt(this.ins.length));this.ins.forEach(function(txin){buffer=buffer.concat(convert.hexToBytes(txin.outpoint.hash).reverse());buffer=buffer.concat(convert.numToBytes(parseInt(txin.outpoint.index),4));var scriptBytes=txin.script.buffer;buffer=buffer.concat(convert.numToVarInt(scriptBytes.length));buffer=buffer.concat(scriptBytes);buffer=buffer.concat(txin.sequence)});buffer=buffer.concat(convert.numToVarInt(this.outs.length));this.outs.forEach(function(txout){buffer=buffer.concat(convert.numToBytes(txout.value,8));var scriptBytes=txout.script.buffer;buffer=buffer.concat(convert.numToVarInt(scriptBytes.length));buffer=buffer.concat(scriptBytes)});buffer=buffer.concat(convert.numToBytes(parseInt(this.locktime),4));return buffer};Transaction.prototype.serializeHex=function(){return convert.bytesToHex(this.serialize())};var SIGHASH_ALL=1;var SIGHASH_NONE=2;var SIGHASH_SINGLE=3;var SIGHASH_ANYONECANPAY=80;Transaction.prototype.hashTransactionForSignature=function(connectedScript,inIndex,hashType){var txTmp=this.clone();txTmp.ins.forEach(function(txin){txin.script=new Script});txTmp.ins[inIndex].script=connectedScript;if((hashType&31)==SIGHASH_NONE){txTmp.outs=[];txTmp.ins.forEach(function(txin,i){if(i!=inIndex){txTmp.ins[i].sequence=0}})}else if((hashType&31)==SIGHASH_SINGLE){}if(hashType&SIGHASH_ANYONECANPAY){txTmp.ins=[txTmp.ins[inIndex]]}var buffer=txTmp.serialize();buffer=buffer.concat(convert.numToBytes(parseInt(hashType),4));buffer=convert.bytesToWordArray(buffer);return convert.wordArrayToBytes(SHA256(SHA256(buffer)))};Transaction.prototype.getHash=function(){var buffer=convert.bytesToWordArray(this.serialize());return convert.wordArrayToBytes(SHA256(SHA256(buffer))).reverse()};Transaction.prototype.clone=function(){var newTx=new Transaction;newTx.version=this.version;newTx.locktime=this.locktime;this.ins.forEach(function(txin){newTx.addInput(txin.clone())});this.outs.forEach(function(txout){newTx.addOutput(txout.clone())});return newTx};Transaction.deserialize=function(buffer){if(typeof buffer=="string"){buffer=convert.hexToBytes(buffer)}var pos=0;var readAsInt=function(bytes){if(bytes===0)return 0;pos++;return buffer[pos-1]+readAsInt(bytes-1)*256};var readVarInt=function(){var bytes=buffer.slice(pos,pos+9);var result=convert.varIntToNum(bytes);pos+=result.bytes.length;return result.number};var readBytes=function(bytes){pos+=bytes;return buffer.slice(pos-bytes,pos)};var readVarString=function(){var size=readVarInt();return readBytes(size)};var obj={ins:[],outs:[]};obj.version=readAsInt(4);var ins=readVarInt();var i;for(i=0;i<ins;i++){obj.ins.push({outpoint:{hash:convert.bytesToHex(readBytes(32).reverse()),index:readAsInt(4)},script:new Script(readVarString()),sequence:readBytes(4)})}var outs=readVarInt();for(i=0;i<outs;i++){obj.outs.push({value:convert.bytesToNum(readBytes(8)),script:new Script(readVarString())})}obj.locktime=readAsInt(4);return new Transaction(obj)};Transaction.prototype.sign=function(index,key,type){type=type||SIGHASH_ALL;key=new ECKey(key);var pub=key.getPub().toBytes(),hash160=util.sha256ripe160(pub),script=Script.createOutputScript(new Address(hash160)),hash=this.hashTransactionForSignature(script,index,type),sig=key.sign(hash).concat([type]);this.ins[index].script=Script.createInputScript(sig,pub)};Transaction.prototype.signWithKeys=function(keys,outputs,type){type=type||SIGHASH_ALL;var addrdata=keys.map(function(key){key=new ECKey(key);return{key:key,address:key.getAddress().toString()}});var hmap={};outputs.forEach(function(o){hmap[o.output]=o});for(var i=0;i<this.ins.length;i++){var outpoint=this.ins[i].outpoint.hash+":"+this.ins[i].outpoint.index;var histItem=hmap[outpoint];if(!histItem)continue;var thisInputAddrdata=addrdata.filter(function(a){return a.address==histItem.address});if(thisInputAddrdata.length===0)continue;this.sign(i,thisInputAddrdata[0].key)}};Transaction.prototype.p2shsign=function(index,script,key,type){script=new Script(script);key=new ECKey(key);type=type||SIGHASH_ALL;var hash=this.hashTransactionForSignature(script,index,type),sig=key.sign(hash).concat([type]);return sig};Transaction.prototype.multisign=Transaction.prototype.p2shsign;Transaction.prototype.applyMultisigs=function(index,script,sigs){this.ins[index].script=Script.createMultiSigInputScript(sigs,script)};Transaction.prototype.validateSig=function(index,script,sig,pub){script=new Script(script);var hash=this.hashTransactionForSignature(script,index,1);return ECDSA.verify(hash,convert.coerceToBytes(sig),convert.coerceToBytes(pub))};Transaction.feePerKb=2e4;Transaction.prototype.estimateFee=function(feePerKb){var uncompressedInSize=180;var outSize=34;var fixedPadding=34;if(feePerKb==undefined)feePerKb=Transaction.feePerKb;var size=this.ins.length*uncompressedInSize+this.outs.length*outSize+fixedPadding;return feePerKb*Math.ceil(size/1e3)};var TransactionIn=function(data){if(typeof data=="string"){this.outpoint={hash:data.split(":")[0],index:data.split(":")[1]}}else if(data.outpoint){this.outpoint=data.outpoint}else{this.outpoint={hash:data.hash,index:data.index}}if(data.scriptSig){this.script=Script.fromScriptSig(data.scriptSig)}else if(data.script){this.script=data.script}else{this.script=new Script(data.script)}this.sequence=data.sequence||this.defaultSequence};TransactionIn.prototype.clone=function(){return new TransactionIn({outpoint:{hash:this.outpoint.hash,index:this.outpoint.index},script:this.script.clone(),sequence:this.sequence})};var TransactionOut=function(data){this.script=data.script instanceof Script?data.script.clone():Array.isArray(data.script)?new Script(data.script):typeof data.script=="string"?new Script(convert.hexToBytes(data.script)):data.scriptPubKey?Script.fromScriptSig(data.scriptPubKey):data.address?Script.createOutputScript(data.address):new Script;if(this.script.buffer.length>0)this.address=this.script.getToAddress();this.value=Array.isArray(data.value)?convert.bytesToNum(data.value):"string"==typeof data.value?parseInt(data.value):data.value instanceof BigInteger?parseInt(data.value.toString()):data.value};TransactionOut.prototype.clone=function(){var newTxout=new TransactionOut({script:this.script.clone(),value:this.value});return newTxout};TransactionOut.prototype.scriptPubKey=function(){return convert.bytesToHex(this.script.buffer)};module.exports={Transaction:Transaction,TransactionIn:TransactionIn,TransactionOut:TransactionOut}},{"./address":54,"./convert":57,"./ecdsa":58,"./eckey":59,"./jsbn/jsbn":63,"./script":68,"./util":70,"crypto-js/sha256":47}],70:[function(_dereq_,module,exports){var convert=_dereq_("./convert.js");var Crypto=_dereq_("crypto-js");var RIPEMD160=Crypto.RIPEMD160;var SHA256=Crypto.SHA256;exports.sha256ripe160=function(data){var wordArray=RIPEMD160(SHA256(convert.bytesToWordArray(data)));return convert.wordArrayToBytes(wordArray)};exports.error=function(msg){throw new Error(msg)}},{"./convert.js":57,"crypto-js":27}],71:[function(_dereq_,module,exports){(function(process){var convert=_dereq_("./convert");var Transaction=_dereq_("./transaction").Transaction;var HDNode=_dereq_("./hdwallet.js");var rng=_dereq_("secure-random");function Wallet(seed,options){if(!(this instanceof Wallet)){return new Wallet(seed,options)}var options=options||{};var network=options.network||"mainnet";var masterkey=null;var me=this;var accountZero=null;var internalAccount=null;var externalAccount=null;this.addresses=[];this.changeAddresses=[];this.outputs={};this.newMasterKey=function(seed,network){if(!seed)seed=rng(32,{array:true});masterkey=new HDNode(seed,network);accountZero=masterkey.derivePrivate(0);externalAccount=accountZero.derive(0);internalAccount=accountZero.derive(1);me.addresses=[];me.changeAddresses=[];me.outputs={}};this.newMasterKey(seed,network);this.generateAddress=function(){var key=externalAccount.derive(this.addresses.length);this.addresses.push(key.getAddress().toString());return this.addresses[this.addresses.length-1]};this.generateChangeAddress=function(){var key=internalAccount.derive(this.changeAddresses.length);this.changeAddresses.push(key.getAddress().toString());return this.changeAddresses[this.changeAddresses.length-1]};this.getBalance=function(){return this.getUnspentOutputs().reduce(function(memo,output){return memo+output.value},0)};this.getUnspentOutputs=function(){var utxo=[];for(var key in this.outputs){var output=this.outputs[key];if(!output.spend)utxo.push(outputToUnspentOutput(output))}return utxo};this.setUnspentOutputs=function(utxo){var outputs={};utxo.forEach(function(uo){validateUnspentOutput(uo);var o=unspentOutputToOutput(uo);outputs[o.receive]=o});this.outputs=outputs};this.setUnspentOutputsAsync=function(utxo,callback){var error=null;try{this.setUnspentOutputs(utxo)}catch(err){error=err}finally{process.nextTick(function(){callback(error)})}};function outputToUnspentOutput(output){var hashAndIndex=output.receive.split(":");return{hash:hashAndIndex[0],hashLittleEndian:convert.reverseEndian(hashAndIndex[0]),outputIndex:parseInt(hashAndIndex[1]),address:output.address,value:output.value}}function unspentOutputToOutput(o){var hash=o.hash||convert.reverseEndian(o.hashLittleEndian);var key=hash+":"+o.outputIndex;return{receive:key,address:o.address,value:o.value}}function validateUnspentOutput(uo){var missingField;if(isNullOrUndefined(uo.hash)&&isNullOrUndefined(uo.hashLittleEndian)){missingField="hash(or hashLittleEndian)"}var requiredKeys=["outputIndex","address","value"];requiredKeys.forEach(function(key){if(isNullOrUndefined(uo[key])){missingField=key}});if(missingField){var message=["Invalid unspent output: key",missingField,"is missing.","A valid unspent output must contain"];message.push(requiredKeys.join(", "));message.push("and hash(or hashLittleEndian)");throw new Error(message.join(" "))}}function isNullOrUndefined(value){return value==undefined}this.processTx=function(tx){var txhash=convert.bytesToHex(tx.getHash());tx.outs.forEach(function(txOut,i){var address=txOut.address.toString();if(isMyAddress(address)){var output=txhash+":"+i;me.outputs[output]={receive:output,value:txOut.value,address:address}}});tx.ins.forEach(function(txIn,i){var op=txIn.outpoint;var o=me.outputs[op.hash+":"+op.index];if(o){o.spend=txhash+":"+i}})};this.createTx=function(to,value,fixedFee){checkDust(value);var tx=new Transaction;tx.addOutput(to,value);var utxo=getCandidateOutputs(value);var totalInValue=0;for(var i=0;i<utxo.length;i++){var output=utxo[i];tx.addInput(output.receive);totalInValue+=output.value;if(totalInValue<value)continue;var fee=fixedFee==undefined?estimateFeePadChangeOutput(tx):fixedFee;if(totalInValue<value+fee)continue;var change=totalInValue-value-fee;if(change>0&&!isDust(change)){tx.addOutput(getChangeAddress(),change)}break}checkInsufficientFund(totalInValue,value,fee);this.sign(tx);return tx};this.createTxAsync=function(to,value,fixedFee,callback){if(fixedFee instanceof Function){callback=fixedFee;fixedFee=undefined}var tx=null;var error=null;try{tx=this.createTx(to,value,fixedFee)}catch(err){error=err}finally{process.nextTick(function(){callback(error,tx)})}};this.dustThreshold=5430;function isDust(amount){return amount<=me.dustThreshold}function checkDust(value){if(isNullOrUndefined(value)||isDust(value)){throw new Error("Value must be above dust threshold")}}function getCandidateOutputs(value){var unspent=[];for(var key in me.outputs){var output=me.outputs[key];if(!output.spend)unspent.push(output)}var sortByValueDesc=unspent.sort(function(o1,o2){return o2.value-o1.value});return sortByValueDesc}function estimateFeePadChangeOutput(tx){var tmpTx=tx.clone();tmpTx.addOutput(getChangeAddress(),0);return tmpTx.estimateFee()}function getChangeAddress(){if(me.changeAddresses.length===0)me.generateChangeAddress();return me.changeAddresses[me.changeAddresses.length-1]}function checkInsufficientFund(totalInValue,value,fee){if(totalInValue<value+fee){throw new Error("Not enough money to send funds including transaction fee. Have: "+totalInValue+", needed: "+(value+fee))}}this.sign=function(tx){tx.ins.forEach(function(inp,i){var output=me.outputs[inp.outpoint.hash+":"+inp.outpoint.index];if(output){tx.sign(i,me.getPrivateKeyForAddress(output.address))}});return tx};this.getMasterKey=function(){return masterkey};this.getAccountZero=function(){return accountZero};this.getInternalAccount=function(){return internalAccount};this.getExternalAccount=function(){return externalAccount};this.getPrivateKey=function(index){return externalAccount.derive(index).priv};this.getInternalPrivateKey=function(index){return internalAccount.derive(index).priv};this.getPrivateKeyForAddress=function(address){var index;if((index=this.addresses.indexOf(address))>-1){return this.getPrivateKey(index)}else if((index=this.changeAddresses.indexOf(address))>-1){return this.getInternalPrivateKey(index)}else{throw new Error("Unknown address. Make sure the address is from the keychain and has been generated.")}};function isReceiveAddress(address){return me.addresses.indexOf(address)>-1}function isChangeAddress(address){return me.changeAddresses.indexOf(address)>-1}function isMyAddress(address){return isReceiveAddress(address)||isChangeAddress(address)}}module.exports=Wallet}).call(this,_dereq_("FWaASH"))},{"./convert":57,"./hdwallet.js":60,"./transaction":69,FWaASH:15,"secure-random":53}]},{},[61])(61)});
/*! peerjs build:0.3.13, development. Copyright(c) 2013 Michelle Bu <michelle@michellebu.com> */(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports.RTCSessionDescription = window.RTCSessionDescription ||
	window.mozRTCSessionDescription;
module.exports.RTCPeerConnection = window.RTCPeerConnection ||
	window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
module.exports.RTCIceCandidate = window.RTCIceCandidate ||
	window.mozRTCIceCandidate;

},{}],2:[function(require,module,exports){
var util = require('./util');
var EventEmitter = require('eventemitter3');
var Negotiator = require('./negotiator');
var Reliable = require('reliable');

/**
 * Wraps a DataChannel between two Peers.
 */
function DataConnection(peer, provider, options) {
  if (!(this instanceof DataConnection)) return new DataConnection(peer, provider, options);
  EventEmitter.call(this);

  this.options = util.extend({
    serialization: 'binary',
    reliable: false
  }, options);

  // Connection is not open yet.
  this.open = false;
  this.type = 'data';
  this.peer = peer;
  this.provider = provider;

  this.id = this.options.connectionId || DataConnection._idPrefix + util.randomToken();

  this.label = this.options.label || this.id;
  this.metadata = this.options.metadata;
  this.serialization = this.options.serialization;
  this.reliable = this.options.reliable;

  // Data channel buffering.
  this._buffer = [];
  this._buffering = false;
  this.bufferSize = 0;

  // For storing large data.
  this._chunkedData = {};

  if (this.options._payload) {
    this._peerBrowser = this.options._payload.browser;
  }

  Negotiator.startConnection(
    this,
    this.options._payload || {
      originator: true
    }
  );
}

util.inherits(DataConnection, EventEmitter);

DataConnection._idPrefix = 'dc_';

/** Called by the Negotiator when the DataChannel is ready. */
DataConnection.prototype.initialize = function(dc) {
  this._dc = this.dataChannel = dc;
  this._configureDataChannel();
}

DataConnection.prototype._configureDataChannel = function() {
  var self = this;
  if (util.supports.sctp) {
    this._dc.binaryType = 'arraybuffer';
  }
  this._dc.onopen = function() {
    util.log('Data channel connection success');
    self.open = true;
    self.emit('open');
  }

  // Use the Reliable shim for non Firefox browsers
  if (!util.supports.sctp && this.reliable) {
    this._reliable = new Reliable(this._dc, util.debug);
  }

  if (this._reliable) {
    this._reliable.onmessage = function(msg) {
      self.emit('data', msg);
    };
  } else {
    this._dc.onmessage = function(e) {
      self._handleDataMessage(e);
    };
  }
  this._dc.onclose = function(e) {
    util.log('DataChannel closed for:', self.peer);
    self.close();
  };
}

// Handles a DataChannel message.
DataConnection.prototype._handleDataMessage = function(e) {
  var self = this;
  var data = e.data;
  var datatype = data.constructor;
  if (this.serialization === 'binary' || this.serialization === 'binary-utf8') {
    if (datatype === Blob) {
      // Datatype should never be blob
      util.blobToArrayBuffer(data, function(ab) {
        data = util.unpack(ab);
        self.emit('data', data);
      });
      return;
    } else if (datatype === ArrayBuffer) {
      data = util.unpack(data);
    } else if (datatype === String) {
      // String fallback for binary data for browsers that don't support binary yet
      var ab = util.binaryStringToArrayBuffer(data);
      data = util.unpack(ab);
    }
  } else if (this.serialization === 'json') {
    data = JSON.parse(data);
  }

  // Check if we've chunked--if so, piece things back together.
  // We're guaranteed that this isn't 0.
  if (data.__peerData) {
    var id = data.__peerData;
    var chunkInfo = this._chunkedData[id] || {data: [], count: 0, total: data.total};

    chunkInfo.data[data.n] = data.data;
    chunkInfo.count += 1;

    if (chunkInfo.total === chunkInfo.count) {
      // Clean up before making the recursive call to `_handleDataMessage`.
      delete this._chunkedData[id];

      // We've received all the chunks--time to construct the complete data.
      data = new Blob(chunkInfo.data);
      this._handleDataMessage({data: data});
    }

    this._chunkedData[id] = chunkInfo;
    return;
  }

  this.emit('data', data);
}

/**
 * Exposed functionality for users.
 */

/** Allows user to close connection. */
DataConnection.prototype.close = function() {
  if (!this.open) {
    return;
  }
  this.open = false;
  Negotiator.cleanup(this);
  this.emit('close');
}

/** Allows user to send data. */
DataConnection.prototype.send = function(data, chunked) {
  if (!this.open) {
    this.emit('error', new Error('Connection is not open. You should listen for the `open` event before sending messages.'));
    return;
  }
  if (this._reliable) {
    // Note: reliable shim sending will make it so that you cannot customize
    // serialization.
    this._reliable.send(data);
    return;
  }
  var self = this;
  if (this.serialization === 'json') {
    this._bufferedSend(JSON.stringify(data));
  } else if (this.serialization === 'binary' || this.serialization === 'binary-utf8') {
    var blob = util.pack(data);

    // For Chrome-Firefox interoperability, we need to make Firefox "chunk"
    // the data it sends out.
    var needsChunking = util.chunkedBrowsers[this._peerBrowser] || util.chunkedBrowsers[util.browser];
    if (needsChunking && !chunked && blob.size > util.chunkedMTU) {
      this._sendChunks(blob);
      return;
    }

    // DataChannel currently only supports strings.
    if (!util.supports.sctp) {
      util.blobToBinaryString(blob, function(str) {
        self._bufferedSend(str);
      });
    } else if (!util.supports.binaryBlob) {
      // We only do this if we really need to (e.g. blobs are not supported),
      // because this conversion is costly.
      util.blobToArrayBuffer(blob, function(ab) {
        self._bufferedSend(ab);
      });
    } else {
      this._bufferedSend(blob);
    }
  } else {
    this._bufferedSend(data);
  }
}

DataConnection.prototype._bufferedSend = function(msg) {
  if (this._buffering || !this._trySend(msg)) {
    this._buffer.push(msg);
    this.bufferSize = this._buffer.length;
  }
}

// Returns true if the send succeeds.
DataConnection.prototype._trySend = function(msg) {
  try {
    this._dc.send(msg);
  } catch (e) {
    this._buffering = true;

    var self = this;
    setTimeout(function() {
      // Try again.
      self._buffering = false;
      self._tryBuffer();
    }, 100);
    return false;
  }
  return true;
}

// Try to send the first message in the buffer.
DataConnection.prototype._tryBuffer = function() {
  if (this._buffer.length === 0) {
    return;
  }

  var msg = this._buffer[0];

  if (this._trySend(msg)) {
    this._buffer.shift();
    this.bufferSize = this._buffer.length;
    this._tryBuffer();
  }
}

DataConnection.prototype._sendChunks = function(blob) {
  var blobs = util.chunk(blob);
  for (var i = 0, ii = blobs.length; i < ii; i += 1) {
    var blob = blobs[i];
    this.send(blob, true);
  }
}

DataConnection.prototype.handleMessage = function(message) {
  var payload = message.payload;

  switch (message.type) {
    case 'ANSWER':
      this._peerBrowser = payload.browser;

      // Forward to negotiator
      Negotiator.handleSDP(message.type, this, payload.sdp);
      break;
    case 'CANDIDATE':
      Negotiator.handleCandidate(this, payload.candidate);
      break;
    default:
      util.warn('Unrecognized message type:', message.type, 'from peer:', this.peer);
      break;
  }
}

module.exports = DataConnection;

},{"./negotiator":5,"./util":8,"eventemitter3":9,"reliable":12}],3:[function(require,module,exports){
  if(typeof window == 'undefined') return false;
window.Socket = require('./socket');
window.MediaConnection = require('./mediaconnection');
window.DataConnection = require('./dataconnection');
window.Peer = require('./peer');
window.RTCPeerConnection = require('./adapter').RTCPeerConnection;
window.RTCSessionDescription = require('./adapter').RTCSessionDescription;
window.RTCIceCandidate = require('./adapter').RTCIceCandidate;
window.Negotiator = require('./negotiator');
window.util = require('./util');
window.BinaryPack = require('js-binarypack');

},{"./adapter":1,"./dataconnection":2,"./mediaconnection":4,"./negotiator":5,"./peer":6,"./socket":7,"./util":8,"js-binarypack":10}],4:[function(require,module,exports){
var util = require('./util');
var EventEmitter = require('eventemitter3');
var Negotiator = require('./negotiator');

/**
 * Wraps the streaming interface between two Peers.
 */
function MediaConnection(peer, provider, options) {
  if (!(this instanceof MediaConnection)) return new MediaConnection(peer, provider, options);
  EventEmitter.call(this);

  this.options = util.extend({}, options);

  this.open = false;
  this.type = 'media';
  this.peer = peer;
  this.provider = provider;
  this.metadata = this.options.metadata;
  this.localStream = this.options._stream;

  this.id = this.options.connectionId || MediaConnection._idPrefix + util.randomToken();
  if (this.localStream) {
    Negotiator.startConnection(
      this,
      {_stream: this.localStream, originator: true}
    );
  }
};

util.inherits(MediaConnection, EventEmitter);

MediaConnection._idPrefix = 'mc_';

MediaConnection.prototype.addStream = function(remoteStream) {
  util.log('Receiving stream', remoteStream);

  this.remoteStream = remoteStream;
  this.emit('stream', remoteStream); // Should we call this `open`?

};

MediaConnection.prototype.handleMessage = function(message) {
  var payload = message.payload;

  switch (message.type) {
    case 'ANSWER':
      // Forward to negotiator
      Negotiator.handleSDP(message.type, this, payload.sdp);
      this.open = true;
      break;
    case 'CANDIDATE':
      Negotiator.handleCandidate(this, payload.candidate);
      break;
    default:
      util.warn('Unrecognized message type:', message.type, 'from peer:', this.peer);
      break;
  }
}

MediaConnection.prototype.answer = function(stream) {
  if (this.localStream) {
    util.warn('Local stream already exists on this MediaConnection. Are you answering a call twice?');
    return;
  }

  this.options._payload._stream = stream;

  this.localStream = stream;
  Negotiator.startConnection(
    this,
    this.options._payload
  )
  // Retrieve lost messages stored because PeerConnection not set up.
  var messages = this.provider._getMessages(this.id);
  for (var i = 0, ii = messages.length; i < ii; i += 1) {
    this.handleMessage(messages[i]);
  }
  this.open = true;
};

/**
 * Exposed functionality for users.
 */

/** Allows user to close connection. */
MediaConnection.prototype.close = function() {
  if (!this.open) {
    return;
  }
  this.open = false;
  Negotiator.cleanup(this);
  this.emit('close')
};

module.exports = MediaConnection;

},{"./negotiator":5,"./util":8,"eventemitter3":9}],5:[function(require,module,exports){
var util = require('./util');
var RTCPeerConnection = require('./adapter').RTCPeerConnection;
var RTCSessionDescription = require('./adapter').RTCSessionDescription;
var RTCIceCandidate = require('./adapter').RTCIceCandidate;

/**
 * Manages all negotiations between Peers.
 */
var Negotiator = {
  pcs: {
    data: {},
    media: {}
  }, // type => {peerId: {pc_id: pc}}.
  //providers: {}, // provider's id => providers (there may be multiple providers/client.
  queue: [] // connections that are delayed due to a PC being in use.
}

Negotiator._idPrefix = 'pc_';

/** Returns a PeerConnection object set up correctly (for data, media). */
Negotiator.startConnection = function(connection, options) {
  var pc = Negotiator._getPeerConnection(connection, options);

  if (connection.type === 'media' && options._stream) {
    // Add the stream.
    pc.addStream(options._stream);
  }

  // Set the connection's PC.
  connection.pc = connection.peerConnection = pc;
  // What do we need to do now?
  if (options.originator) {
    if (connection.type === 'data') {
      // Create the datachannel.
      var config = {};
      // Dropping reliable:false support, since it seems to be crashing
      // Chrome.
      /*if (util.supports.sctp && !options.reliable) {
        // If we have canonical reliable support...
        config = {maxRetransmits: 0};
      }*/
      // Fallback to ensure older browsers don't crash.
      if (!util.supports.sctp) {
        config = {reliable: options.reliable};
      }
      var dc = pc.createDataChannel(connection.label, config);
      connection.initialize(dc);
    }

    if (!util.supports.onnegotiationneeded) {
      Negotiator._makeOffer(connection);
    }
  } else {
    Negotiator.handleSDP('OFFER', connection, options.sdp);
  }
}

Negotiator._getPeerConnection = function(connection, options) {
  if (!Negotiator.pcs[connection.type]) {
    util.error(connection.type + ' is not a valid connection type. Maybe you overrode the `type` property somewhere.');
  }

  if (!Negotiator.pcs[connection.type][connection.peer]) {
    Negotiator.pcs[connection.type][connection.peer] = {};
  }
  var peerConnections = Negotiator.pcs[connection.type][connection.peer];

  var pc;
  // Not multiplexing while FF and Chrome have not-great support for it.
  /*if (options.multiplex) {
    ids = Object.keys(peerConnections);
    for (var i = 0, ii = ids.length; i < ii; i += 1) {
      pc = peerConnections[ids[i]];
      if (pc.signalingState === 'stable') {
        break; // We can go ahead and use this PC.
      }
    }
  } else */
  if (options.pc) { // Simplest case: PC id already provided for us.
    pc = Negotiator.pcs[connection.type][connection.peer][options.pc];
  }

  if (!pc || pc.signalingState !== 'stable') {
    pc = Negotiator._startPeerConnection(connection);
  }
  return pc;
}

/*
Negotiator._addProvider = function(provider) {
  if ((!provider.id && !provider.disconnected) || !provider.socket.open) {
    // Wait for provider to obtain an ID.
    provider.on('open', function(id) {
      Negotiator._addProvider(provider);
    });
  } else {
    Negotiator.providers[provider.id] = provider;
  }
}*/


/** Start a PC. */
Negotiator._startPeerConnection = function(connection) {
  util.log('Creating RTCPeerConnection.');

  var id = Negotiator._idPrefix + util.randomToken();
  var optional = {};

  if (connection.type === 'data' && !util.supports.sctp) {
    optional = {optional: [{RtpDataChannels: true}]};
  } else if (connection.type === 'media') {
    // Interop req for chrome.
    optional = {optional: [{DtlsSrtpKeyAgreement: true}]};
  }

  var pc = new RTCPeerConnection(connection.provider.options.config, optional);
  Negotiator.pcs[connection.type][connection.peer][id] = pc;

  Negotiator._setupListeners(connection, pc, id);

  return pc;
}

/** Set up various WebRTC listeners. */
Negotiator._setupListeners = function(connection, pc, pc_id) {
  var peerId = connection.peer;
  var connectionId = connection.id;
  var provider = connection.provider;

  // ICE CANDIDATES.
  util.log('Listening for ICE candidates.');
  pc.onicecandidate = function(evt) {
    if (evt.candidate) {
      util.log('Received ICE candidates for:', connection.peer);
      provider.socket.send({
        type: 'CANDIDATE',
        payload: {
          candidate: evt.candidate,
          type: connection.type,
          connectionId: connection.id
        },
        dst: peerId
      });
    }
  };

  pc.oniceconnectionstatechange = function() {
    switch (pc.iceConnectionState) {
      case 'disconnected':
      case 'failed':
        util.log('iceConnectionState is disconnected, closing connections to ' + peerId);
        connection.close();
        break;
      case 'completed':
        pc.onicecandidate = util.noop;
        break;
    }
  };

  // Fallback for older Chrome impls.
  pc.onicechange = pc.oniceconnectionstatechange;

  // ONNEGOTIATIONNEEDED (Chrome)
  util.log('Listening for `negotiationneeded`');
  pc.onnegotiationneeded = function() {
    util.log('`negotiationneeded` triggered');
    if (pc.signalingState == 'stable') {
      Negotiator._makeOffer(connection);
    } else {
      util.log('onnegotiationneeded triggered when not stable. Is another connection being established?');
    }
  };

  // DATACONNECTION.
  util.log('Listening for data channel');
  // Fired between offer and answer, so options should already be saved
  // in the options hash.
  pc.ondatachannel = function(evt) {
    util.log('Received data channel');
    var dc = evt.channel;
    var connection = provider.getConnection(peerId, connectionId);
    connection.initialize(dc);
  };

  // MEDIACONNECTION.
  util.log('Listening for remote stream');
  pc.onaddstream = function(evt) {
    util.log('Received remote stream');
    var stream = evt.stream;
    var connection = provider.getConnection(peerId, connectionId);
    // 10/10/2014: looks like in Chrome 38, onaddstream is triggered after
    // setting the remote description. Our connection object in these cases
    // is actually a DATA connection, so addStream fails.
    // TODO: This is hopefully just a temporary fix. We should try to
    // understand why this is happening.
    if (connection.type === 'media') {
      connection.addStream(stream);
    }
  };
}

Negotiator.cleanup = function(connection) {
  util.log('Cleaning up PeerConnection to ' + connection.peer);

  var pc = connection.pc;

  if (!!pc && (pc.readyState !== 'closed' || pc.signalingState !== 'closed')) {
    pc.close();
    connection.pc = null;
  }
}

Negotiator._makeOffer = function(connection) {
  var pc = connection.pc;
  pc.createOffer(function(offer) {
    util.log('Created offer.');

    if (!util.supports.sctp && connection.type === 'data' && connection.reliable) {
      offer.sdp = Reliable.higherBandwidthSDP(offer.sdp);
    }

    pc.setLocalDescription(offer, function() {
      util.log('Set localDescription: offer', 'for:', connection.peer);
      connection.provider.socket.send({
        type: 'OFFER',
        payload: {
          sdp: offer,
          type: connection.type,
          label: connection.label,
          connectionId: connection.id,
          reliable: connection.reliable,
          serialization: connection.serialization,
          metadata: connection.metadata,
          browser: util.browser
        },
        dst: connection.peer
      });
    }, function(err) {
      connection.provider.emitError('webrtc', err);
      util.log('Failed to setLocalDescription, ', err);
    });
  }, function(err) {
    connection.provider.emitError('webrtc', err);
    util.log('Failed to createOffer, ', err);
  }, connection.options.constraints);
}

Negotiator._makeAnswer = function(connection) {
  var pc = connection.pc;

  pc.createAnswer(function(answer) {
    util.log('Created answer.');

    if (!util.supports.sctp && connection.type === 'data' && connection.reliable) {
      answer.sdp = Reliable.higherBandwidthSDP(answer.sdp);
    }

    pc.setLocalDescription(answer, function() {
      util.log('Set localDescription: answer', 'for:', connection.peer);
      connection.provider.socket.send({
        type: 'ANSWER',
        payload: {
          sdp: answer,
          type: connection.type,
          connectionId: connection.id,
          browser: util.browser
        },
        dst: connection.peer
      });
    }, function(err) {
      connection.provider.emitError('webrtc', err);
      util.log('Failed to setLocalDescription, ', err);
    });
  }, function(err) {
    connection.provider.emitError('webrtc', err);
    util.log('Failed to create answer, ', err);
  });
}

/** Handle an SDP. */
Negotiator.handleSDP = function(type, connection, sdp) {
  sdp = new RTCSessionDescription(sdp);
  var pc = connection.pc;

  util.log('Setting remote description', sdp);
  pc.setRemoteDescription(sdp, function() {
    util.log('Set remoteDescription:', type, 'for:', connection.peer);

    if (type === 'OFFER') {
      Negotiator._makeAnswer(connection);
    }
  }, function(err) {
    connection.provider.emitError('webrtc', err);
    util.log('Failed to setRemoteDescription, ', err);
  });
}

/** Handle a candidate. */
Negotiator.handleCandidate = function(connection, ice) {
  var candidate = ice.candidate;
  var sdpMLineIndex = ice.sdpMLineIndex;
  connection.pc.addIceCandidate(new RTCIceCandidate({
    sdpMLineIndex: sdpMLineIndex,
    candidate: candidate
  }));
  util.log('Added ICE candidate for:', connection.peer);
}

module.exports = Negotiator;

},{"./adapter":1,"./util":8}],6:[function(require,module,exports){
var util = require('./util');
var EventEmitter = require('eventemitter3');
var Socket = require('./socket');
var MediaConnection = require('./mediaconnection');
var DataConnection = require('./dataconnection');

/**
 * A peer who can initiate connections with other peers.
 */
function Peer(id, options) {
  if (!(this instanceof Peer)) return new Peer(id, options);
  EventEmitter.call(this);

  // Deal with overloading
  if (id && id.constructor == Object) {
    options = id;
    id = undefined;
  } else if (id) {
    // Ensure id is a string
    id = id.toString();
  }
  //

  // Configurize options
  options = util.extend({
    debug: 0, // 1: Errors, 2: Warnings, 3: All logs
    host: util.CLOUD_HOST,
    port: util.CLOUD_PORT,
    key: 'peerjs',
    path: '/',
    token: util.randomToken(),
    config: util.defaultConfig
  }, options);
  this.options = options;
  // Detect relative URL host.
  if (options.host === '/') {
    options.host = window.location.hostname;
  }
  // Set path correctly.
  if (options.path[0] !== '/') {
    options.path = '/' + options.path;
  }
  if (options.path[options.path.length - 1] !== '/') {
    options.path += '/';
  }

  // Set whether we use SSL to same as current host
  if (options.secure === undefined && options.host !== util.CLOUD_HOST) {
    options.secure = util.isSecure();
  }
  // Set a custom log function if present
  if (options.logFunction) {
    util.setLogFunction(options.logFunction);
  }
  util.setLogLevel(options.debug);
  //

  // Sanity checks
  // Ensure WebRTC supported
  if (!util.supports.audioVideo && !util.supports.data ) {
    this._delayedAbort('browser-incompatible', 'The current browser does not support WebRTC');
    return;
  }
  // Ensure alphanumeric id
  if (!util.validateId(id)) {
    this._delayedAbort('invalid-id', 'ID "' + id + '" is invalid');
    return;
  }
  // Ensure valid key
  if (!util.validateKey(options.key)) {
    this._delayedAbort('invalid-key', 'API KEY "' + options.key + '" is invalid');
    return;
  }
  // Ensure not using unsecure cloud server on SSL page
  if (options.secure && options.host === '0.peerjs.com') {
    this._delayedAbort('ssl-unavailable',
      'The cloud server currently does not support HTTPS. Please run your own PeerServer to use HTTPS.');
    return;
  }
  //

  // States.
  this.destroyed = false; // Connections have been killed
  this.disconnected = false; // Connection to PeerServer killed but P2P connections still active
  this.open = false; // Sockets and such are not yet open.
  //

  // References
  this.connections = {}; // DataConnections for this peer.
  this._lostMessages = {}; // src => [list of messages]
  //

  // Start the server connection
  this._initializeServerConnection();
  if (id) {
    this._initialize(id);
  } else {
    this._retrieveId();
  }
  //
}

util.inherits(Peer, EventEmitter);

// Initialize the 'socket' (which is actually a mix of XHR streaming and
// websockets.)
Peer.prototype._initializeServerConnection = function() {
  var self = this;
  this.socket = new Socket(this.options.secure, this.options.host, this.options.port, this.options.path, this.options.key);
  this.socket.on('message', function(data) {
    self._handleMessage(data);
  });
  this.socket.on('error', function(error) {
    self._abort('socket-error', error);
  });
  this.socket.on('disconnected', function() {
    // If we haven't explicitly disconnected, emit error and disconnect.
    if (!self.disconnected) {
      self.emitError('network', 'Lost connection to server.');
      self.disconnect();
    }
  });
  this.socket.on('close', function() {
    // If we haven't explicitly disconnected, emit error.
    if (!self.disconnected) {
      self._abort('socket-closed', 'Underlying socket is already closed.');
    }
  });
};

/** Get a unique ID from the server via XHR. */
Peer.prototype._retrieveId = function(cb) {
  var self = this;
  var http = new XMLHttpRequest();
  var protocol = this.options.secure ? 'https://' : 'http://';
  var url = protocol + this.options.host + ':' + this.options.port +
    this.options.path + this.options.key + '/id';
  var queryString = '?ts=' + new Date().getTime() + '' + Math.random();
  url += queryString;

  // If there's no ID we need to wait for one before trying to init socket.
  http.open('get', url, true);
  http.onerror = function(e) {
    util.error('Error retrieving ID', e);
    var pathError = '';
    if (self.options.path === '/' && self.options.host !== util.CLOUD_HOST) {
      pathError = ' If you passed in a `path` to your self-hosted PeerServer, ' +
        'you\'ll also need to pass in that same path when creating a new ' +
        'Peer.';
    }
    self._abort('server-error', 'Could not get an ID from the server.' + pathError);
  };
  http.onreadystatechange = function() {
    if (http.readyState !== 4) {
      return;
    }
    if (http.status !== 200) {
      http.onerror();
      return;
    }
    self._initialize(http.responseText);
  };
  http.send(null);
};

/** Initialize a connection with the server. */
Peer.prototype._initialize = function(id) {
  this.id = id;
  this.socket.start(this.id, this.options.token);
};

/** Handles messages from the server. */
Peer.prototype._handleMessage = function(message) {
  var type = message.type;
  var payload = message.payload;
  var peer = message.src;
  var connection;

  switch (type) {
    case 'OPEN': // The connection to the server is open.
      this.emit('open', this.id);
      this.open = true;
      break;
    case 'ERROR': // Server error.
      this._abort('server-error', payload.msg);
      break;
    case 'ID-TAKEN': // The selected ID is taken.
      this._abort('unavailable-id', 'ID `' + this.id + '` is taken');
      break;
    case 'INVALID-KEY': // The given API key cannot be found.
      this._abort('invalid-key', 'API KEY "' + this.options.key + '" is invalid');
      break;

    //
    case 'LEAVE': // Another peer has closed its connection to this peer.
      util.log('Received leave message from', peer);
      this._cleanupPeer(peer);
      break;

    case 'EXPIRE': // The offer sent to a peer has expired without response.
      this.emitError('peer-unavailable', 'Could not connect to peer ' + peer);
      break;
    case 'OFFER': // we should consider switching this to CALL/CONNECT, but this is the least breaking option.
      var connectionId = payload.connectionId;
      connection = this.getConnection(peer, connectionId);

      if (connection) {
        util.warn('Offer received for existing Connection ID:', connectionId);
        //connection.handleMessage(message);
      } else {
        // Create a new connection.
        if (payload.type === 'media') {
          connection = new MediaConnection(peer, this, {
            connectionId: connectionId,
            _payload: payload,
            metadata: payload.metadata
          });
          this._addConnection(peer, connection);
          this.emit('call', connection);
        } else if (payload.type === 'data') {
          connection = new DataConnection(peer, this, {
            connectionId: connectionId,
            _payload: payload,
            metadata: payload.metadata,
            label: payload.label,
            serialization: payload.serialization,
            reliable: payload.reliable
          });
          this._addConnection(peer, connection);
          this.emit('connection', connection);
        } else {
          util.warn('Received malformed connection type:', payload.type);
          return;
        }
        // Find messages.
        var messages = this._getMessages(connectionId);
        for (var i = 0, ii = messages.length; i < ii; i += 1) {
          connection.handleMessage(messages[i]);
        }
      }
      break;
    default:
      if (!payload) {
        util.warn('You received a malformed message from ' + peer + ' of type ' + type);
        return;
      }

      var id = payload.connectionId;
      connection = this.getConnection(peer, id);

      if (connection && connection.pc) {
        // Pass it on.
        connection.handleMessage(message);
      } else if (id) {
        // Store for possible later use
        this._storeMessage(id, message);
      } else {
        util.warn('You received an unrecognized message:', message);
      }
      break;
  }
};

/** Stores messages without a set up connection, to be claimed later. */
Peer.prototype._storeMessage = function(connectionId, message) {
  if (!this._lostMessages[connectionId]) {
    this._lostMessages[connectionId] = [];
  }
  this._lostMessages[connectionId].push(message);
};

/** Retrieve messages from lost message store */
Peer.prototype._getMessages = function(connectionId) {
  var messages = this._lostMessages[connectionId];
  if (messages) {
    delete this._lostMessages[connectionId];
    return messages;
  } else {
    return [];
  }
};

/**
 * Returns a DataConnection to the specified peer. See documentation for a
 * complete list of options.
 */
Peer.prototype.connect = function(peer, options) {
  if (this.disconnected) {
    util.warn('You cannot connect to a new Peer because you called ' +
      '.disconnect() on this Peer and ended your connection with the ' +
      'server. You can create a new Peer to reconnect, or call reconnect ' +
      'on this peer if you believe its ID to still be available.');
    this.emitError('disconnected', 'Cannot connect to new Peer after disconnecting from server.');
    return;
  }
  var connection = new DataConnection(peer, this, options);
  this._addConnection(peer, connection);
  return connection;
};

/**
 * Returns a MediaConnection to the specified peer. See documentation for a
 * complete list of options.
 */
Peer.prototype.call = function(peer, stream, options) {
  if (this.disconnected) {
    util.warn('You cannot connect to a new Peer because you called ' +
      '.disconnect() on this Peer and ended your connection with the ' +
      'server. You can create a new Peer to reconnect.');
    this.emitError('disconnected', 'Cannot connect to new Peer after disconnecting from server.');
    return;
  }
  if (!stream) {
    util.error('To call a peer, you must provide a stream from your browser\'s `getUserMedia`.');
    return;
  }
  options = options || {};
  options._stream = stream;
  var call = new MediaConnection(peer, this, options);
  this._addConnection(peer, call);
  return call;
};

/** Add a data/media connection to this peer. */
Peer.prototype._addConnection = function(peer, connection) {
  if (!this.connections[peer]) {
    this.connections[peer] = [];
  }
  this.connections[peer].push(connection);
};

/** Retrieve a data/media connection for this peer. */
Peer.prototype.getConnection = function(peer, id) {
  var connections = this.connections[peer];
  if (!connections) {
    return null;
  }
  for (var i = 0, ii = connections.length; i < ii; i++) {
    if (connections[i].id === id) {
      return connections[i];
    }
  }
  return null;
};

Peer.prototype._delayedAbort = function(type, message) {
  var self = this;
  util.setZeroTimeout(function(){
    self._abort(type, message);
  });
};

/**
 * Destroys the Peer and emits an error message.
 * The Peer is not destroyed if it's in a disconnected state, in which case
 * it retains its disconnected state and its existing connections.
 */
Peer.prototype._abort = function(type, message) {
  util.error('Aborting!');
  if (!this._lastServerId) {
    this.destroy();
  } else {
    this.disconnect();
  }
  this.emitError(type, message);
};

/** Emits a typed error message. */
Peer.prototype.emitError = function(type, err) {
  util.error('Error:', err);
  if (typeof err === 'string') {
    err = new Error(err);
  }
  err.type = type;
  this.emit('error', err);
};

/**
 * Destroys the Peer: closes all active connections as well as the connection
 *  to the server.
 * Warning: The peer can no longer create or accept connections after being
 *  destroyed.
 */
Peer.prototype.destroy = function() {
  if (!this.destroyed) {
    this._cleanup();
    this.disconnect();
    this.destroyed = true;
  }
};


/** Disconnects every connection on this peer. */
Peer.prototype._cleanup = function() {
  if (this.connections) {
    var peers = Object.keys(this.connections);
    for (var i = 0, ii = peers.length; i < ii; i++) {
      this._cleanupPeer(peers[i]);
    }
  }
  this.emit('close');
};

/** Closes all connections to this peer. */
Peer.prototype._cleanupPeer = function(peer) {
  var connections = this.connections[peer];
  for (var j = 0, jj = connections.length; j < jj; j += 1) {
    connections[j].close();
  }
};

/**
 * Disconnects the Peer's connection to the PeerServer. Does not close any
 *  active connections.
 * Warning: The peer can no longer create or accept connections after being
 *  disconnected. It also cannot reconnect to the server.
 */
Peer.prototype.disconnect = function() {
  var self = this;
  util.setZeroTimeout(function(){
    if (!self.disconnected) {
      self.disconnected = true;
      self.open = false;
      if (self.socket) {
        self.socket.close();
      }
      self.emit('disconnected', self.id);
      self._lastServerId = self.id;
      self.id = null;
    }
  });
};

/** Attempts to reconnect with the same ID. */
Peer.prototype.reconnect = function() {
  if (this.disconnected && !this.destroyed) {
    util.log('Attempting reconnection to server with ID ' + this._lastServerId);
    this.disconnected = false;
    this._initializeServerConnection();
    this._initialize(this._lastServerId);
  } else if (this.destroyed) {
    throw new Error('This peer cannot reconnect to the server. It has already been destroyed.');
  } else if (!this.disconnected && !this.open) {
    // Do nothing. We're still connecting the first time.
    util.error('In a hurry? We\'re still trying to make the initial connection!');
  } else {
    throw new Error('Peer ' + this.id + ' cannot reconnect because it is not disconnected from the server!');
  }
};

/**
 * Get a list of available peer IDs. If you're running your own server, you'll
 * want to set allow_discovery: true in the PeerServer options. If you're using
 * the cloud server, email team@peerjs.com to get the functionality enabled for
 * your key.
 */
Peer.prototype.listAllPeers = function(cb) {
  cb = cb || function() {};
  var self = this;
  var http = new XMLHttpRequest();
  var protocol = this.options.secure ? 'https://' : 'http://';
  var url = protocol + this.options.host + ':' + this.options.port +
    this.options.path + this.options.key + '/peers';
  var queryString = '?ts=' + new Date().getTime() + '' + Math.random();
  url += queryString;

  // If there's no ID we need to wait for one before trying to init socket.
  http.open('get', url, true);
  http.onerror = function(e) {
    self._abort('server-error', 'Could not get peers from the server.');
    cb([]);
  };
  http.onreadystatechange = function() {
    if (http.readyState !== 4) {
      return;
    }
    if (http.status === 401) {
      var helpfulError = '';
      if (self.options.host !== util.CLOUD_HOST) {
        helpfulError = 'It looks like you\'re using the cloud server. You can email ' +
          'team@peerjs.com to enable peer listing for your API key.';
      } else {
        helpfulError = 'You need to enable `allow_discovery` on your self-hosted ' +
          'PeerServer to use this feature.';
      }
      cb([]);
      throw new Error('It doesn\'t look like you have permission to list peers IDs. ' + helpfulError);
    } else if (http.status !== 200) {
      cb([]);
    } else {
      cb(JSON.parse(http.responseText));
    }
  };
  http.send(null);
};

module.exports = Peer;

},{"./dataconnection":2,"./mediaconnection":4,"./socket":7,"./util":8,"eventemitter3":9}],7:[function(require,module,exports){
var util = require('./util');
var EventEmitter = require('eventemitter3');

/**
 * An abstraction on top of WebSockets and XHR streaming to provide fastest
 * possible connection for peers.
 */
function Socket(secure, host, port, path, key) {
  if (!(this instanceof Socket)) return new Socket(secure, host, port, path, key);

  EventEmitter.call(this);

  // Disconnected manually.
  this.disconnected = false;
  this._queue = [];

  var httpProtocol = secure ? 'https://' : 'http://';
  var wsProtocol = secure ? 'wss://' : 'ws://';
  this._httpUrl = httpProtocol + host + ':' + port + path + key;
  this._wsUrl = wsProtocol + host + ':' + port + path + 'peerjs?key=' + key;
}

util.inherits(Socket, EventEmitter);


/** Check in with ID or get one from server. */
Socket.prototype.start = function(id, token) {
  this.id = id;

  this._httpUrl += '/' + id + '/' + token;
  this._wsUrl += '&id=' + id + '&token=' + token;

  this._startXhrStream();
  this._startWebSocket();
}


/** Start up websocket communications. */
Socket.prototype._startWebSocket = function(id) {
  var self = this;

  if (this._socket) {
    return;
  }

  this._socket = new WebSocket(this._wsUrl);

  this._socket.onmessage = function(event) {
    try {
      var data = JSON.parse(event.data);
    } catch(e) {
      util.log('Invalid server message', event.data);
      return;
    }
    self.emit('message', data);
  };

  this._socket.onclose = function(event) {
    util.log('Socket closed.');
    self.disconnected = true;
    self.emit('disconnected');
  };

  // Take care of the queue of connections if necessary and make sure Peer knows
  // socket is open.
  this._socket.onopen = function() {
    if (self._timeout) {
      clearTimeout(self._timeout);
      setTimeout(function(){
        self._http.abort();
        self._http = null;
      }, 5000);
    }
    self._sendQueuedMessages();
    util.log('Socket open');
  };
}

/** Start XHR streaming. */
Socket.prototype._startXhrStream = function(n) {
  try {
    var self = this;
    this._http = new XMLHttpRequest();
    this._http._index = 1;
    this._http._streamIndex = n || 0;
    this._http.open('post', this._httpUrl + '/id?i=' + this._http._streamIndex, true);
    this._http.onerror = function() {
      // If we get an error, likely something went wrong.
      // Stop streaming.
      clearTimeout(self._timeout);
      self.emit('disconnected');
    }
    this._http.onreadystatechange = function() {
      if (this.readyState == 2 && this.old) {
        this.old.abort();
        delete this.old;
      } else if (this.readyState > 2 && this.status === 200 && this.responseText) {
        self._handleStream(this);
      }
    };
    this._http.send(null);
    this._setHTTPTimeout();
  } catch(e) {
    util.log('XMLHttpRequest not available; defaulting to WebSockets');
  }
}


/** Handles onreadystatechange response as a stream. */
Socket.prototype._handleStream = function(http) {
  // 3 and 4 are loading/done state. All others are not relevant.
  var messages = http.responseText.split('\n');

  // Check to see if anything needs to be processed on buffer.
  if (http._buffer) {
    while (http._buffer.length > 0) {
      var index = http._buffer.shift();
      var bufferedMessage = messages[index];
      try {
        bufferedMessage = JSON.parse(bufferedMessage);
      } catch(e) {
        http._buffer.shift(index);
        break;
      }
      this.emit('message', bufferedMessage);
    }
  }

  var message = messages[http._index];
  if (message) {
    http._index += 1;
    // Buffering--this message is incomplete and we'll get to it next time.
    // This checks if the httpResponse ended in a `\n`, in which case the last
    // element of messages should be the empty string.
    if (http._index === messages.length) {
      if (!http._buffer) {
        http._buffer = [];
      }
      http._buffer.push(http._index - 1);
    } else {
      try {
        message = JSON.parse(message);
      } catch(e) {
        util.log('Invalid server message', message);
        return;
      }
      this.emit('message', message);
    }
  }
}

Socket.prototype._setHTTPTimeout = function() {
  var self = this;
  this._timeout = setTimeout(function() {
    var old = self._http;
    if (!self._wsOpen()) {
      self._startXhrStream(old._streamIndex + 1);
      self._http.old = old;
    } else {
      old.abort();
    }
  }, 25000);
}

/** Is the websocket currently open? */
Socket.prototype._wsOpen = function() {
  return this._socket && this._socket.readyState == 1;
}

/** Send queued messages. */
Socket.prototype._sendQueuedMessages = function() {
  for (var i = 0, ii = this._queue.length; i < ii; i += 1) {
    this.send(this._queue[i]);
  }
}

/** Exposed send for DC & Peer. */
Socket.prototype.send = function(data) {
  if (this.disconnected) {
    return;
  }

  // If we didn't get an ID yet, we can't yet send anything so we should queue
  // up these messages.
  if (!this.id) {
    this._queue.push(data);
    return;
  }

  if (!data.type) {
    this.emit('error', 'Invalid message');
    return;
  }

  var message = JSON.stringify(data);
  if (this._wsOpen()) {
    this._socket.send(message);
  } else {
    var http = new XMLHttpRequest();
    var url = this._httpUrl + '/' + data.type.toLowerCase();
    http.open('post', url, true);
    http.setRequestHeader('Content-Type', 'application/json');
    http.send(message);
  }
}

Socket.prototype.close = function() {
  if (!this.disconnected && this._wsOpen()) {
    this._socket.close();
    this.disconnected = true;
  }
}

module.exports = Socket;

},{"./util":8,"eventemitter3":9}],8:[function(require,module,exports){
var defaultConfig = {'iceServers': [{ 'url': 'stun:stun.l.google.com:19302' }]};
var dataCount = 1;

var BinaryPack = require('js-binarypack');
var RTCPeerConnection = require('./adapter').RTCPeerConnection;

var util = {
  noop: function() {},

  CLOUD_HOST: '0.peerjs.com',
  CLOUD_PORT: 9000,

  // Browsers that need chunking:
  chunkedBrowsers: {'Chrome': 1},
  chunkedMTU: 16300, // The original 60000 bytes setting does not work when sending data from Firefox to Chrome, which is "cut off" after 16384 bytes and delivered individually.

  // Logging logic
  logLevel: 0,
  setLogLevel: function(level) {
    var debugLevel = parseInt(level, 10);
    if (!isNaN(parseInt(level, 10))) {
      util.logLevel = debugLevel;
    } else {
      // If they are using truthy/falsy values for debug
      util.logLevel = level ? 3 : 0;
    }
    util.log = util.warn = util.error = util.noop;
    if (util.logLevel > 0) {
      util.error = util._printWith('ERROR');
    }
    if (util.logLevel > 1) {
      util.warn = util._printWith('WARNING');
    }
    if (util.logLevel > 2) {
      util.log = util._print;
    }
  },
  setLogFunction: function(fn) {
    if (fn.constructor !== Function) {
      util.warn('The log function you passed in is not a function. Defaulting to regular logs.');
    } else {
      util._print = fn;
    }
  },

  _printWith: function(prefix) {
    return function() {
      var copy = Array.prototype.slice.call(arguments);
      copy.unshift(prefix);
      util._print.apply(util, copy);
    };
  },
  _print: function () {
    var err = false;
    var copy = Array.prototype.slice.call(arguments);
    copy.unshift('PeerJS: ');
    for (var i = 0, l = copy.length; i < l; i++){
      if (copy[i] instanceof Error) {
        copy[i] = '(' + copy[i].name + ') ' + copy[i].message;
        err = true;
      }
    }
    err ? console.error.apply(console, copy) : console.log.apply(console, copy);
  },
  //

  // Returns browser-agnostic default config
  defaultConfig: defaultConfig,
  //

  // Returns the current browser.
  browser: (function() {
    if (window.mozRTCPeerConnection) {
      return 'Firefox';
    } else if (window.webkitRTCPeerConnection) {
      return 'Chrome';
    } else if (window.RTCPeerConnection) {
      return 'Supported';
    } else {
      return 'Unsupported';
    }
  })(),
  //

  // Lists which features are supported
  supports: (function() {
    if (typeof RTCPeerConnection === 'undefined') {
      return {};
    }

    var data = true;
    var audioVideo = true;

    var binaryBlob = false;
    var sctp = false;
    var onnegotiationneeded = !!window.webkitRTCPeerConnection;

    var pc, dc;
    try {
      pc = new RTCPeerConnection(defaultConfig, {optional: [{RtpDataChannels: true}]});
    } catch (e) {
      data = false;
      audioVideo = false;
    }

    if (data) {
      try {
        dc = pc.createDataChannel('_PEERJSTEST');
      } catch (e) {
        data = false;
      }
    }

    if (data) {
      // Binary test
      try {
        dc.binaryType = 'blob';
        binaryBlob = true;
      } catch (e) {
      }

      // Reliable test.
      // Unfortunately Chrome is a bit unreliable about whether or not they
      // support reliable.
      var reliablePC = new RTCPeerConnection(defaultConfig, {});
      try {
        var reliableDC = reliablePC.createDataChannel('_PEERJSRELIABLETEST', {});
        sctp = reliableDC.reliable;
      } catch (e) {
      }
      reliablePC.close();
    }

    // FIXME: not really the best check...
    if (audioVideo) {
      audioVideo = !!pc.addStream;
    }

    // FIXME: this is not great because in theory it doesn't work for
    // av-only browsers (?).
    if (!onnegotiationneeded && data) {
      // sync default check.
      var negotiationPC = new RTCPeerConnection(defaultConfig, {optional: [{RtpDataChannels: true}]});
      negotiationPC.onnegotiationneeded = function() {
        onnegotiationneeded = true;
        // async check.
        if (util && util.supports) {
          util.supports.onnegotiationneeded = true;
        }
      };
      negotiationPC.createDataChannel('_PEERJSNEGOTIATIONTEST');

      setTimeout(function() {
        negotiationPC.close();
      }, 1000);
    }

    if (pc) {
      pc.close();
    }

    return {
      audioVideo: audioVideo,
      data: data,
      binaryBlob: binaryBlob,
      binary: sctp, // deprecated; sctp implies binary support.
      reliable: sctp, // deprecated; sctp implies reliable data.
      sctp: sctp,
      onnegotiationneeded: onnegotiationneeded
    };
  }()),
  //

  // Ensure alphanumeric ids
  validateId: function(id) {
    // Allow empty ids
    return !id || /^[A-Za-z0-9_-]+(?:[ _-][A-Za-z0-9]+)*$/.exec(id);
  },

  validateKey: function(key) {
    // Allow empty keys
    return !key || /^[A-Za-z0-9_-]+(?:[ _-][A-Za-z0-9]+)*$/.exec(key);
  },


  debug: false,

  inherits: function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  },
  extend: function(dest, source) {
    for(var key in source) {
      if(source.hasOwnProperty(key)) {
        dest[key] = source[key];
      }
    }
    return dest;
  },
  pack: BinaryPack.pack,
  unpack: BinaryPack.unpack,

  log: function () {
    if (util.debug) {
      var err = false;
      var copy = Array.prototype.slice.call(arguments);
      copy.unshift('PeerJS: ');
      for (var i = 0, l = copy.length; i < l; i++){
        if (copy[i] instanceof Error) {
          copy[i] = '(' + copy[i].name + ') ' + copy[i].message;
          err = true;
        }
      }
      err ? console.error.apply(console, copy) : console.log.apply(console, copy);
    }
  },

  setZeroTimeout: (function(global) {
    var timeouts = [];
    var messageName = 'zero-timeout-message';

    // Like setTimeout, but only takes a function argument.	 There's
    // no time argument (always zero) and no arguments (you have to
    // use a closure).
    function setZeroTimeoutPostMessage(fn) {
      timeouts.push(fn);
      global.postMessage(messageName, '*');
    }

    function handleMessage(event) {
      if (event.source == global && event.data == messageName) {
        if (event.stopPropagation) {
          event.stopPropagation();
        }
        if (timeouts.length) {
          timeouts.shift()();
        }
      }
    }
    if (global.addEventListener) {
      global.addEventListener('message', handleMessage, true);
    } else if (global.attachEvent) {
      global.attachEvent('onmessage', handleMessage);
    }
    return setZeroTimeoutPostMessage;
  }(window)),

  // Binary stuff

  // chunks a blob.
  chunk: function(bl) {
    var chunks = [];
    var size = bl.size;
    var start = index = 0;
    var total = Math.ceil(size / util.chunkedMTU);
    while (start < size) {
      var end = Math.min(size, start + util.chunkedMTU);
      var b = bl.slice(start, end);

      var chunk = {
        __peerData: dataCount,
        n: index,
        data: b,
        total: total
      };

      chunks.push(chunk);

      start = end;
      index += 1;
    }
    dataCount += 1;
    return chunks;
  },

  blobToArrayBuffer: function(blob, cb){
    var fr = new FileReader();
    fr.onload = function(evt) {
      cb(evt.target.result);
    };
    fr.readAsArrayBuffer(blob);
  },
  blobToBinaryString: function(blob, cb){
    var fr = new FileReader();
    fr.onload = function(evt) {
      cb(evt.target.result);
    };
    fr.readAsBinaryString(blob);
  },
  binaryStringToArrayBuffer: function(binary) {
    var byteArray = new Uint8Array(binary.length);
    for (var i = 0; i < binary.length; i++) {
      byteArray[i] = binary.charCodeAt(i) & 0xff;
    }
    return byteArray.buffer;
  },
  randomToken: function () {
    return Math.random().toString(36).substr(2);
  },
  //

  isSecure: function() {
    return location.protocol === 'https:';
  }
};

module.exports = util;

},{"./adapter":1,"js-binarypack":10}],9:[function(require,module,exports){
'use strict';

/**
 * Representation of a single EventEmitter function.
 *
 * @param {Function} fn Event handler to be called.
 * @param {Mixed} context Context for function execution.
 * @param {Boolean} once Only emit once
 * @api private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Minimal EventEmitter interface that is molded against the Node.js
 * EventEmitter interface.
 *
 * @constructor
 * @api public
 */
function EventEmitter() { /* Nothing to set */ }

/**
 * Holds the assigned EventEmitters by name.
 *
 * @type {Object}
 * @private
 */
EventEmitter.prototype._events = undefined;

/**
 * Return a list of assigned event listeners.
 *
 * @param {String} event The events that should be listed.
 * @returns {Array}
 * @api public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  if (!this._events || !this._events[event]) return [];

  for (var i = 0, l = this._events[event].length, ee = []; i < l; i++) {
    ee.push(this._events[event][i].fn);
  }

  return ee;
};

/**
 * Emit an event to all registered event listeners.
 *
 * @param {String} event The name of the event.
 * @returns {Boolean} Indication if we've emitted an event.
 * @api public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  if (!this._events || !this._events[event]) return false;

  var listeners = this._events[event]
    , length = listeners.length
    , len = arguments.length
    , ee = listeners[0]
    , args
    , i, j;

  if (1 === length) {
    if (ee.once) this.removeListener(event, ee.fn, true);

    switch (len) {
      case 1: return ee.fn.call(ee.context), true;
      case 2: return ee.fn.call(ee.context, a1), true;
      case 3: return ee.fn.call(ee.context, a1, a2), true;
      case 4: return ee.fn.call(ee.context, a1, a2, a3), true;
      case 5: return ee.fn.call(ee.context, a1, a2, a3, a4), true;
      case 6: return ee.fn.call(ee.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    ee.fn.apply(ee.context, args);
  } else {
    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Register a new EventListener for the given event.
 *
 * @param {String} event Name of the event.
 * @param {Functon} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  if (!this._events) this._events = {};
  if (!this._events[event]) this._events[event] = [];
  this._events[event].push(new EE( fn, context || this ));

  return this;
};

/**
 * Add an EventListener that's only called once.
 *
 * @param {String} event Name of the event.
 * @param {Function} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  if (!this._events) this._events = {};
  if (!this._events[event]) this._events[event] = [];
  this._events[event].push(new EE(fn, context || this, true ));

  return this;
};

/**
 * Remove event listeners.
 *
 * @param {String} event The event we want to remove.
 * @param {Function} fn The listener that we need to find.
 * @param {Boolean} once Only remove once listeners.
 * @api public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, once) {
  if (!this._events || !this._events[event]) return this;

  var listeners = this._events[event]
    , events = [];

  if (fn) for (var i = 0, length = listeners.length; i < length; i++) {
    if (listeners[i].fn !== fn && listeners[i].once !== once) {
      events.push(listeners[i]);
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) this._events[event] = events;
  else this._events[event] = null;

  return this;
};

/**
 * Remove all listeners or only the listeners for the specified event.
 *
 * @param {String} event The event want to remove all listeners for.
 * @api public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  if (!this._events) return this;

  if (event) this._events[event] = null;
  else this._events = {};

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// This function doesn't apply anymore.
//
EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
  return this;
};

//
// Expose the module.
//
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.EventEmitter2 = EventEmitter;
EventEmitter.EventEmitter3 = EventEmitter;

if ('object' === typeof module && module.exports) {
  module.exports = EventEmitter;
}

},{}],10:[function(require,module,exports){
var BufferBuilder = require('./bufferbuilder').BufferBuilder;
var binaryFeatures = require('./bufferbuilder').binaryFeatures;

var BinaryPack = {
  unpack: function(data){
    var unpacker = new Unpacker(data);
    return unpacker.unpack();
  },
  pack: function(data){
    var packer = new Packer();
    packer.pack(data);
    var buffer = packer.getBuffer();
    return buffer;
  }
};

module.exports = BinaryPack;

function Unpacker (data){
  // Data is ArrayBuffer
  this.index = 0;
  this.dataBuffer = data;
  this.dataView = new Uint8Array(this.dataBuffer);
  this.length = this.dataBuffer.byteLength;
}

Unpacker.prototype.unpack = function(){
  var type = this.unpack_uint8();
  if (type < 0x80){
    var positive_fixnum = type;
    return positive_fixnum;
  } else if ((type ^ 0xe0) < 0x20){
    var negative_fixnum = (type ^ 0xe0) - 0x20;
    return negative_fixnum;
  }
  var size;
  if ((size = type ^ 0xa0) <= 0x0f){
    return this.unpack_raw(size);
  } else if ((size = type ^ 0xb0) <= 0x0f){
    return this.unpack_string(size);
  } else if ((size = type ^ 0x90) <= 0x0f){
    return this.unpack_array(size);
  } else if ((size = type ^ 0x80) <= 0x0f){
    return this.unpack_map(size);
  }
  switch(type){
    case 0xc0:
      return null;
    case 0xc1:
      return undefined;
    case 0xc2:
      return false;
    case 0xc3:
      return true;
    case 0xca:
      return this.unpack_float();
    case 0xcb:
      return this.unpack_double();
    case 0xcc:
      return this.unpack_uint8();
    case 0xcd:
      return this.unpack_uint16();
    case 0xce:
      return this.unpack_uint32();
    case 0xcf:
      return this.unpack_uint64();
    case 0xd0:
      return this.unpack_int8();
    case 0xd1:
      return this.unpack_int16();
    case 0xd2:
      return this.unpack_int32();
    case 0xd3:
      return this.unpack_int64();
    case 0xd4:
      return undefined;
    case 0xd5:
      return undefined;
    case 0xd6:
      return undefined;
    case 0xd7:
      return undefined;
    case 0xd8:
      size = this.unpack_uint16();
      return this.unpack_string(size);
    case 0xd9:
      size = this.unpack_uint32();
      return this.unpack_string(size);
    case 0xda:
      size = this.unpack_uint16();
      return this.unpack_raw(size);
    case 0xdb:
      size = this.unpack_uint32();
      return this.unpack_raw(size);
    case 0xdc:
      size = this.unpack_uint16();
      return this.unpack_array(size);
    case 0xdd:
      size = this.unpack_uint32();
      return this.unpack_array(size);
    case 0xde:
      size = this.unpack_uint16();
      return this.unpack_map(size);
    case 0xdf:
      size = this.unpack_uint32();
      return this.unpack_map(size);
  }
}

Unpacker.prototype.unpack_uint8 = function(){
  var byte = this.dataView[this.index] & 0xff;
  this.index++;
  return byte;
};

Unpacker.prototype.unpack_uint16 = function(){
  var bytes = this.read(2);
  var uint16 =
    ((bytes[0] & 0xff) * 256) + (bytes[1] & 0xff);
  this.index += 2;
  return uint16;
}

Unpacker.prototype.unpack_uint32 = function(){
  var bytes = this.read(4);
  var uint32 =
     ((bytes[0]  * 256 +
       bytes[1]) * 256 +
       bytes[2]) * 256 +
       bytes[3];
  this.index += 4;
  return uint32;
}

Unpacker.prototype.unpack_uint64 = function(){
  var bytes = this.read(8);
  var uint64 =
   ((((((bytes[0]  * 256 +
       bytes[1]) * 256 +
       bytes[2]) * 256 +
       bytes[3]) * 256 +
       bytes[4]) * 256 +
       bytes[5]) * 256 +
       bytes[6]) * 256 +
       bytes[7];
  this.index += 8;
  return uint64;
}


Unpacker.prototype.unpack_int8 = function(){
  var uint8 = this.unpack_uint8();
  return (uint8 < 0x80 ) ? uint8 : uint8 - (1 << 8);
};

Unpacker.prototype.unpack_int16 = function(){
  var uint16 = this.unpack_uint16();
  return (uint16 < 0x8000 ) ? uint16 : uint16 - (1 << 16);
}

Unpacker.prototype.unpack_int32 = function(){
  var uint32 = this.unpack_uint32();
  return (uint32 < Math.pow(2, 31) ) ? uint32 :
    uint32 - Math.pow(2, 32);
}

Unpacker.prototype.unpack_int64 = function(){
  var uint64 = this.unpack_uint64();
  return (uint64 < Math.pow(2, 63) ) ? uint64 :
    uint64 - Math.pow(2, 64);
}

Unpacker.prototype.unpack_raw = function(size){
  if ( this.length < this.index + size){
    throw new Error('BinaryPackFailure: index is out of range'
      + ' ' + this.index + ' ' + size + ' ' + this.length);
  }
  var buf = this.dataBuffer.slice(this.index, this.index + size);
  this.index += size;

    //buf = util.bufferToString(buf);

  return buf;
}

Unpacker.prototype.unpack_string = function(size){
  var bytes = this.read(size);
  var i = 0, str = '', c, code;
  while(i < size){
    c = bytes[i];
    if ( c < 128){
      str += String.fromCharCode(c);
      i++;
    } else if ((c ^ 0xc0) < 32){
      code = ((c ^ 0xc0) << 6) | (bytes[i+1] & 63);
      str += String.fromCharCode(code);
      i += 2;
    } else {
      code = ((c & 15) << 12) | ((bytes[i+1] & 63) << 6) |
        (bytes[i+2] & 63);
      str += String.fromCharCode(code);
      i += 3;
    }
  }
  this.index += size;
  return str;
}

Unpacker.prototype.unpack_array = function(size){
  var objects = new Array(size);
  for(var i = 0; i < size ; i++){
    objects[i] = this.unpack();
  }
  return objects;
}

Unpacker.prototype.unpack_map = function(size){
  var map = {};
  for(var i = 0; i < size ; i++){
    var key  = this.unpack();
    var value = this.unpack();
    map[key] = value;
  }
  return map;
}

Unpacker.prototype.unpack_float = function(){
  var uint32 = this.unpack_uint32();
  var sign = uint32 >> 31;
  var exp  = ((uint32 >> 23) & 0xff) - 127;
  var fraction = ( uint32 & 0x7fffff ) | 0x800000;
  return (sign == 0 ? 1 : -1) *
    fraction * Math.pow(2, exp - 23);
}

Unpacker.prototype.unpack_double = function(){
  var h32 = this.unpack_uint32();
  var l32 = this.unpack_uint32();
  var sign = h32 >> 31;
  var exp  = ((h32 >> 20) & 0x7ff) - 1023;
  var hfrac = ( h32 & 0xfffff ) | 0x100000;
  var frac = hfrac * Math.pow(2, exp - 20) +
    l32   * Math.pow(2, exp - 52);
  return (sign == 0 ? 1 : -1) * frac;
}

Unpacker.prototype.read = function(length){
  var j = this.index;
  if (j + length <= this.length) {
    return this.dataView.subarray(j, j + length);
  } else {
    throw new Error('BinaryPackFailure: read index out of range');
  }
}

function Packer(){
  this.bufferBuilder = new BufferBuilder();
}

Packer.prototype.getBuffer = function(){
  return this.bufferBuilder.getBuffer();
}

Packer.prototype.pack = function(value){
  var type = typeof(value);
  if (type == 'string'){
    this.pack_string(value);
  } else if (type == 'number'){
    if (Math.floor(value) === value){
      this.pack_integer(value);
    } else{
      this.pack_double(value);
    }
  } else if (type == 'boolean'){
    if (value === true){
      this.bufferBuilder.append(0xc3);
    } else if (value === false){
      this.bufferBuilder.append(0xc2);
    }
  } else if (type == 'undefined'){
    this.bufferBuilder.append(0xc0);
  } else if (type == 'object'){
    if (value === null){
      this.bufferBuilder.append(0xc0);
    } else {
      var constructor = value.constructor;
      if (constructor == Array){
        this.pack_array(value);
      } else if (constructor == Blob || constructor == File) {
        this.pack_bin(value);
      } else if (constructor == ArrayBuffer) {
        if(binaryFeatures.useArrayBufferView) {
          this.pack_bin(new Uint8Array(value));
        } else {
          this.pack_bin(value);
        }
      } else if ('BYTES_PER_ELEMENT' in value){
        if(binaryFeatures.useArrayBufferView) {
          this.pack_bin(new Uint8Array(value.buffer));
        } else {
          this.pack_bin(value.buffer);
        }
      } else if (constructor == Object){
        this.pack_object(value);
      } else if (constructor == Date){
        this.pack_string(value.toString());
      } else if (typeof value.toBinaryPack == 'function'){
        this.bufferBuilder.append(value.toBinaryPack());
      } else {
        throw new Error('Type "' + constructor.toString() + '" not yet supported');
      }
    }
  } else {
    throw new Error('Type "' + type + '" not yet supported');
  }
  this.bufferBuilder.flush();
}


Packer.prototype.pack_bin = function(blob){
  var length = blob.length || blob.byteLength || blob.size;
  if (length <= 0x0f){
    this.pack_uint8(0xa0 + length);
  } else if (length <= 0xffff){
    this.bufferBuilder.append(0xda) ;
    this.pack_uint16(length);
  } else if (length <= 0xffffffff){
    this.bufferBuilder.append(0xdb);
    this.pack_uint32(length);
  } else{
    throw new Error('Invalid length');
  }
  this.bufferBuilder.append(blob);
}

Packer.prototype.pack_string = function(str){
  var length = utf8Length(str);

  if (length <= 0x0f){
    this.pack_uint8(0xb0 + length);
  } else if (length <= 0xffff){
    this.bufferBuilder.append(0xd8) ;
    this.pack_uint16(length);
  } else if (length <= 0xffffffff){
    this.bufferBuilder.append(0xd9);
    this.pack_uint32(length);
  } else{
    throw new Error('Invalid length');
  }
  this.bufferBuilder.append(str);
}

Packer.prototype.pack_array = function(ary){
  var length = ary.length;
  if (length <= 0x0f){
    this.pack_uint8(0x90 + length);
  } else if (length <= 0xffff){
    this.bufferBuilder.append(0xdc)
    this.pack_uint16(length);
  } else if (length <= 0xffffffff){
    this.bufferBuilder.append(0xdd);
    this.pack_uint32(length);
  } else{
    throw new Error('Invalid length');
  }
  for(var i = 0; i < length ; i++){
    this.pack(ary[i]);
  }
}

Packer.prototype.pack_integer = function(num){
  if ( -0x20 <= num && num <= 0x7f){
    this.bufferBuilder.append(num & 0xff);
  } else if (0x00 <= num && num <= 0xff){
    this.bufferBuilder.append(0xcc);
    this.pack_uint8(num);
  } else if (-0x80 <= num && num <= 0x7f){
    this.bufferBuilder.append(0xd0);
    this.pack_int8(num);
  } else if ( 0x0000 <= num && num <= 0xffff){
    this.bufferBuilder.append(0xcd);
    this.pack_uint16(num);
  } else if (-0x8000 <= num && num <= 0x7fff){
    this.bufferBuilder.append(0xd1);
    this.pack_int16(num);
  } else if ( 0x00000000 <= num && num <= 0xffffffff){
    this.bufferBuilder.append(0xce);
    this.pack_uint32(num);
  } else if (-0x80000000 <= num && num <= 0x7fffffff){
    this.bufferBuilder.append(0xd2);
    this.pack_int32(num);
  } else if (-0x8000000000000000 <= num && num <= 0x7FFFFFFFFFFFFFFF){
    this.bufferBuilder.append(0xd3);
    this.pack_int64(num);
  } else if (0x0000000000000000 <= num && num <= 0xFFFFFFFFFFFFFFFF){
    this.bufferBuilder.append(0xcf);
    this.pack_uint64(num);
  } else{
    throw new Error('Invalid integer');
  }
}

Packer.prototype.pack_double = function(num){
  var sign = 0;
  if (num < 0){
    sign = 1;
    num = -num;
  }
  var exp  = Math.floor(Math.log(num) / Math.LN2);
  var frac0 = num / Math.pow(2, exp) - 1;
  var frac1 = Math.floor(frac0 * Math.pow(2, 52));
  var b32   = Math.pow(2, 32);
  var h32 = (sign << 31) | ((exp+1023) << 20) |
      (frac1 / b32) & 0x0fffff;
  var l32 = frac1 % b32;
  this.bufferBuilder.append(0xcb);
  this.pack_int32(h32);
  this.pack_int32(l32);
}

Packer.prototype.pack_object = function(obj){
  var keys = Object.keys(obj);
  var length = keys.length;
  if (length <= 0x0f){
    this.pack_uint8(0x80 + length);
  } else if (length <= 0xffff){
    this.bufferBuilder.append(0xde);
    this.pack_uint16(length);
  } else if (length <= 0xffffffff){
    this.bufferBuilder.append(0xdf);
    this.pack_uint32(length);
  } else{
    throw new Error('Invalid length');
  }
  for(var prop in obj){
    if (obj.hasOwnProperty(prop)){
      this.pack(prop);
      this.pack(obj[prop]);
    }
  }
}

Packer.prototype.pack_uint8 = function(num){
  this.bufferBuilder.append(num);
}

Packer.prototype.pack_uint16 = function(num){
  this.bufferBuilder.append(num >> 8);
  this.bufferBuilder.append(num & 0xff);
}

Packer.prototype.pack_uint32 = function(num){
  var n = num & 0xffffffff;
  this.bufferBuilder.append((n & 0xff000000) >>> 24);
  this.bufferBuilder.append((n & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((n & 0x0000ff00) >>>  8);
  this.bufferBuilder.append((n & 0x000000ff));
}

Packer.prototype.pack_uint64 = function(num){
  var high = num / Math.pow(2, 32);
  var low  = num % Math.pow(2, 32);
  this.bufferBuilder.append((high & 0xff000000) >>> 24);
  this.bufferBuilder.append((high & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((high & 0x0000ff00) >>>  8);
  this.bufferBuilder.append((high & 0x000000ff));
  this.bufferBuilder.append((low  & 0xff000000) >>> 24);
  this.bufferBuilder.append((low  & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((low  & 0x0000ff00) >>>  8);
  this.bufferBuilder.append((low  & 0x000000ff));
}

Packer.prototype.pack_int8 = function(num){
  this.bufferBuilder.append(num & 0xff);
}

Packer.prototype.pack_int16 = function(num){
  this.bufferBuilder.append((num & 0xff00) >> 8);
  this.bufferBuilder.append(num & 0xff);
}

Packer.prototype.pack_int32 = function(num){
  this.bufferBuilder.append((num >>> 24) & 0xff);
  this.bufferBuilder.append((num & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((num & 0x0000ff00) >>> 8);
  this.bufferBuilder.append((num & 0x000000ff));
}

Packer.prototype.pack_int64 = function(num){
  var high = Math.floor(num / Math.pow(2, 32));
  var low  = num % Math.pow(2, 32);
  this.bufferBuilder.append((high & 0xff000000) >>> 24);
  this.bufferBuilder.append((high & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((high & 0x0000ff00) >>>  8);
  this.bufferBuilder.append((high & 0x000000ff));
  this.bufferBuilder.append((low  & 0xff000000) >>> 24);
  this.bufferBuilder.append((low  & 0x00ff0000) >>> 16);
  this.bufferBuilder.append((low  & 0x0000ff00) >>>  8);
  this.bufferBuilder.append((low  & 0x000000ff));
}

function _utf8Replace(m){
  var code = m.charCodeAt(0);

  if(code <= 0x7ff) return '00';
  if(code <= 0xffff) return '000';
  if(code <= 0x1fffff) return '0000';
  if(code <= 0x3ffffff) return '00000';
  return '000000';
}

function utf8Length(str){
  if (str.length > 600) {
    // Blob method faster for large strings
    return (new Blob([str])).size;
  } else {
    return str.replace(/[^\u0000-\u007F]/g, _utf8Replace).length;
  }
}

},{"./bufferbuilder":11}],11:[function(require,module,exports){
var binaryFeatures = {};
binaryFeatures.useBlobBuilder = (function(){
  try {
    new Blob([]);
    return false;
  } catch (e) {
    return true;
  }
})();

binaryFeatures.useArrayBufferView = !binaryFeatures.useBlobBuilder && (function(){
  try {
    return (new Blob([new Uint8Array([])])).size === 0;
  } catch (e) {
    return true;
  }
})();

module.exports.binaryFeatures = binaryFeatures;
var BlobBuilder = module.exports.BlobBuilder;
if (typeof window != 'undefined') {
  BlobBuilder = module.exports.BlobBuilder = window.WebKitBlobBuilder ||
    window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder;
}

function BufferBuilder(){
  this._pieces = [];
  this._parts = [];
}

BufferBuilder.prototype.append = function(data) {
  if(typeof data === 'number') {
    this._pieces.push(data);
  } else {
    this.flush();
    this._parts.push(data);
  }
};

BufferBuilder.prototype.flush = function() {
  if (this._pieces.length > 0) {
    var buf = new Uint8Array(this._pieces);
    if(!binaryFeatures.useArrayBufferView) {
      buf = buf.buffer;
    }
    this._parts.push(buf);
    this._pieces = [];
  }
};

BufferBuilder.prototype.getBuffer = function() {
  this.flush();
  if(binaryFeatures.useBlobBuilder) {
    var builder = new BlobBuilder();
    for(var i = 0, ii = this._parts.length; i < ii; i++) {
      builder.append(this._parts[i]);
    }
    return builder.getBlob();
  } else {
    return new Blob(this._parts);
  }
};

module.exports.BufferBuilder = BufferBuilder;

},{}],12:[function(require,module,exports){
var util = require('./util');

/**
 * Reliable transfer for Chrome Canary DataChannel impl.
 * Author: @michellebu
 */
function Reliable(dc, debug) {
  if (!(this instanceof Reliable)) return new Reliable(dc);
  this._dc = dc;

  util.debug = debug;

  // Messages sent/received so far.
  // id: { ack: n, chunks: [...] }
  this._outgoing = {};
  // id: { ack: ['ack', id, n], chunks: [...] }
  this._incoming = {};
  this._received = {};

  // Window size.
  this._window = 1000;
  // MTU.
  this._mtu = 500;
  // Interval for setInterval. In ms.
  this._interval = 0;

  // Messages sent.
  this._count = 0;

  // Outgoing message queue.
  this._queue = [];

  this._setupDC();
};

// Send a message reliably.
Reliable.prototype.send = function(msg) {
  // Determine if chunking is necessary.
  var bl = util.pack(msg);
  if (bl.size < this._mtu) {
    this._handleSend(['no', bl]);
    return;
  }

  this._outgoing[this._count] = {
    ack: 0,
    chunks: this._chunk(bl)
  };

  if (util.debug) {
    this._outgoing[this._count].timer = new Date();
  }

  // Send prelim window.
  this._sendWindowedChunks(this._count);
  this._count += 1;
};

// Set up interval for processing queue.
Reliable.prototype._setupInterval = function() {
  // TODO: fail gracefully.

  var self = this;
  this._timeout = setInterval(function() {
    // FIXME: String stuff makes things terribly async.
    var msg = self._queue.shift();
    if (msg._multiple) {
      for (var i = 0, ii = msg.length; i < ii; i += 1) {
        self._intervalSend(msg[i]);
      }
    } else {
      self._intervalSend(msg);
    }
  }, this._interval);
};

Reliable.prototype._intervalSend = function(msg) {
  var self = this;
  msg = util.pack(msg);
  util.blobToBinaryString(msg, function(str) {
    self._dc.send(str);
  });
  if (self._queue.length === 0) {
    clearTimeout(self._timeout);
    self._timeout = null;
    //self._processAcks();
  }
};

// Go through ACKs to send missing pieces.
Reliable.prototype._processAcks = function() {
  for (var id in this._outgoing) {
    if (this._outgoing.hasOwnProperty(id)) {
      this._sendWindowedChunks(id);
    }
  }
};

// Handle sending a message.
// FIXME: Don't wait for interval time for all messages...
Reliable.prototype._handleSend = function(msg) {
  var push = true;
  for (var i = 0, ii = this._queue.length; i < ii; i += 1) {
    var item = this._queue[i];
    if (item === msg) {
      push = false;
    } else if (item._multiple && item.indexOf(msg) !== -1) {
      push = false;
    }
  }
  if (push) {
    this._queue.push(msg);
    if (!this._timeout) {
      this._setupInterval();
    }
  }
};

// Set up DataChannel handlers.
Reliable.prototype._setupDC = function() {
  // Handle various message types.
  var self = this;
  this._dc.onmessage = function(e) {
    var msg = e.data;
    var datatype = msg.constructor;
    // FIXME: msg is String until binary is supported.
    // Once that happens, this will have to be smarter.
    if (datatype === String) {
      var ab = util.binaryStringToArrayBuffer(msg);
      msg = util.unpack(ab);
      self._handleMessage(msg);
    }
  };
};

// Handles an incoming message.
Reliable.prototype._handleMessage = function(msg) {
  var id = msg[1];
  var idata = this._incoming[id];
  var odata = this._outgoing[id];
  var data;
  switch (msg[0]) {
    // No chunking was done.
    case 'no':
      var message = id;
      if (!!message) {
        this.onmessage(util.unpack(message));
      }
      break;
    // Reached the end of the message.
    case 'end':
      data = idata;

      // In case end comes first.
      this._received[id] = msg[2];

      if (!data) {
        break;
      }

      this._ack(id);
      break;
    case 'ack':
      data = odata;
      if (!!data) {
        var ack = msg[2];
        // Take the larger ACK, for out of order messages.
        data.ack = Math.max(ack, data.ack);

        // Clean up when all chunks are ACKed.
        if (data.ack >= data.chunks.length) {
          util.log('Time: ', new Date() - data.timer);
          delete this._outgoing[id];
        } else {
          this._processAcks();
        }
      }
      // If !data, just ignore.
      break;
    // Received a chunk of data.
    case 'chunk':
      // Create a new entry if none exists.
      data = idata;
      if (!data) {
        var end = this._received[id];
        if (end === true) {
          break;
        }
        data = {
          ack: ['ack', id, 0],
          chunks: []
        };
        this._incoming[id] = data;
      }

      var n = msg[2];
      var chunk = msg[3];
      data.chunks[n] = new Uint8Array(chunk);

      // If we get the chunk we're looking for, ACK for next missing.
      // Otherwise, ACK the same N again.
      if (n === data.ack[2]) {
        this._calculateNextAck(id);
      }
      this._ack(id);
      break;
    default:
      // Shouldn't happen, but would make sense for message to just go
      // through as is.
      this._handleSend(msg);
      break;
  }
};

// Chunks BL into smaller messages.
Reliable.prototype._chunk = function(bl) {
  var chunks = [];
  var size = bl.size;
  var start = 0;
  while (start < size) {
    var end = Math.min(size, start + this._mtu);
    var b = bl.slice(start, end);
    var chunk = {
      payload: b
    }
    chunks.push(chunk);
    start = end;
  }
  util.log('Created', chunks.length, 'chunks.');
  return chunks;
};

// Sends ACK N, expecting Nth blob chunk for message ID.
Reliable.prototype._ack = function(id) {
  var ack = this._incoming[id].ack;

  // if ack is the end value, then call _complete.
  if (this._received[id] === ack[2]) {
    this._complete(id);
    this._received[id] = true;
  }

  this._handleSend(ack);
};

// Calculates the next ACK number, given chunks.
Reliable.prototype._calculateNextAck = function(id) {
  var data = this._incoming[id];
  var chunks = data.chunks;
  for (var i = 0, ii = chunks.length; i < ii; i += 1) {
    // This chunk is missing!!! Better ACK for it.
    if (chunks[i] === undefined) {
      data.ack[2] = i;
      return;
    }
  }
  data.ack[2] = chunks.length;
};

// Sends the next window of chunks.
Reliable.prototype._sendWindowedChunks = function(id) {
  util.log('sendWindowedChunks for: ', id);
  var data = this._outgoing[id];
  var ch = data.chunks;
  var chunks = [];
  var limit = Math.min(data.ack + this._window, ch.length);
  for (var i = data.ack; i < limit; i += 1) {
    if (!ch[i].sent || i === data.ack) {
      ch[i].sent = true;
      chunks.push(['chunk', id, i, ch[i].payload]);
    }
  }
  if (data.ack + this._window >= ch.length) {
    chunks.push(['end', id, ch.length])
  }
  chunks._multiple = true;
  this._handleSend(chunks);
};

// Puts together a message from chunks.
Reliable.prototype._complete = function(id) {
  util.log('Completed called for', id);
  var self = this;
  var chunks = this._incoming[id].chunks;
  var bl = new Blob(chunks);
  util.blobToArrayBuffer(bl, function(ab) {
    self.onmessage(util.unpack(ab));
  });
  delete this._incoming[id];
};

// Ups bandwidth limit on SDP. Meant to be called during offer/answer.
Reliable.higherBandwidthSDP = function(sdp) {
  // AS stands for Application-Specific Maximum.
  // Bandwidth number is in kilobits / sec.
  // See RFC for more info: http://www.ietf.org/rfc/rfc2327.txt

  // Chrome 31+ doesn't want us munging the SDP, so we'll let them have their
  // way.
  var version = navigator.appVersion.match(/Chrome\/(.*?) /);
  if (version) {
    version = parseInt(version[1].split('.').shift());
    if (version < 31) {
      var parts = sdp.split('b=AS:30');
      var replace = 'b=AS:102400'; // 100 Mbps
      if (parts.length > 1) {
        return parts[0] + replace + parts[1];
      }
    }
  }

  return sdp;
};

// Overwritten, typically.
Reliable.prototype.onmessage = function(msg) {};

module.exports.Reliable = Reliable;

},{"./util":13}],13:[function(require,module,exports){
var BinaryPack = require('js-binarypack');

var util = {
  debug: false,
  
  inherits: function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  },
  extend: function(dest, source) {
    for(var key in source) {
      if(source.hasOwnProperty(key)) {
        dest[key] = source[key];
      }
    }
    return dest;
  },
  pack: BinaryPack.pack,
  unpack: BinaryPack.unpack,
  
  log: function () {
    if (util.debug) {
      var copy = [];
      for (var i = 0; i < arguments.length; i++) {
        copy[i] = arguments[i];
      }
      copy.unshift('Reliable: ');
      console.log.apply(console, copy);
    }
  },

  setZeroTimeout: (function(global) {
    var timeouts = [];
    var messageName = 'zero-timeout-message';

    // Like setTimeout, but only takes a function argument.	 There's
    // no time argument (always zero) and no arguments (you have to
    // use a closure).
    function setZeroTimeoutPostMessage(fn) {
      timeouts.push(fn);
      global.postMessage(messageName, '*');
    }		

    function handleMessage(event) {
      if (event.source == global && event.data == messageName) {
        if (event.stopPropagation) {
          event.stopPropagation();
        }
        if (timeouts.length) {
          timeouts.shift()();
        }
      }
    }
    if (global.addEventListener) {
      global.addEventListener('message', handleMessage, true);
    } else if (global.attachEvent) {
      global.attachEvent('onmessage', handleMessage);
    }
    return setZeroTimeoutPostMessage;
  }(this)),
  
  blobToArrayBuffer: function(blob, cb){
    var fr = new FileReader();
    fr.onload = function(evt) {
      cb(evt.target.result);
    };
    fr.readAsArrayBuffer(blob);
  },
  blobToBinaryString: function(blob, cb){
    var fr = new FileReader();
    fr.onload = function(evt) {
      cb(evt.target.result);
    };
    fr.readAsBinaryString(blob);
  },
  binaryStringToArrayBuffer: function(binary) {
    var byteArray = new Uint8Array(binary.length);
    for (var i = 0; i < binary.length; i++) {
      byteArray[i] = binary.charCodeAt(i) & 0xff;
    }
    return byteArray.buffer;
  },
  randomToken: function () {
    return Math.random().toString(36).substr(2);
  }
};

module.exports = util;

},{"js-binarypack":10}]},{},[3]);
/* https://github.com/jakearchibald/es6-promise */
!function(){var a,b,c,d;!function(){var e={},f={};a=function(a,b,c){e[a]={deps:b,callback:c}},d=c=b=function(a){function c(b){if("."!==b.charAt(0))return b;for(var c=b.split("/"),d=a.split("/").slice(0,-1),e=0,f=c.length;f>e;e++){var g=c[e];if(".."===g)d.pop();else{if("."===g)continue;d.push(g)}}return d.join("/")}if(d._eak_seen=e,f[a])return f[a];if(f[a]={},!e[a])throw new Error("Could not find module "+a);for(var g,h=e[a],i=h.deps,j=h.callback,k=[],l=0,m=i.length;m>l;l++)"exports"===i[l]?k.push(g={}):k.push(b(c(i[l])));var n=j.apply(this,k);return f[a]=g||n}}(),a("promise/all",["./utils","exports"],function(a,b){"use strict";function c(a){var b=this;if(!d(a))throw new TypeError("You must pass an array to all.");return new b(function(b,c){function d(a){return function(b){f(a,b)}}function f(a,c){h[a]=c,0===--i&&b(h)}var g,h=[],i=a.length;0===i&&b([]);for(var j=0;j<a.length;j++)g=a[j],g&&e(g.then)?g.then(d(j),c):f(j,g)})}var d=a.isArray,e=a.isFunction;b.all=c}),a("promise/asap",["exports"],function(a){"use strict";function b(){return function(){process.nextTick(e)}}function c(){var a=0,b=new i(e),c=document.createTextNode("");return b.observe(c,{characterData:!0}),function(){c.data=a=++a%2}}function d(){return function(){j.setTimeout(e,1)}}function e(){for(var a=0;a<k.length;a++){var b=k[a],c=b[0],d=b[1];c(d)}k=[]}function f(a,b){var c=k.push([a,b]);1===c&&g()}var g,h="undefined"!=typeof window?window:{},i=h.MutationObserver||h.WebKitMutationObserver,j="undefined"!=typeof global?global:void 0===this?window:this,k=[];g="undefined"!=typeof process&&"[object process]"==={}.toString.call(process)?b():i?c():d(),a.asap=f}),a("promise/config",["exports"],function(a){"use strict";function b(a,b){return 2!==arguments.length?c[a]:(c[a]=b,void 0)}var c={instrument:!1};a.config=c,a.configure=b}),a("promise/polyfill",["./promise","./utils","exports"],function(a,b,c){"use strict";function d(){var a;a="undefined"!=typeof global?global:"undefined"!=typeof window&&window.document?window:self;var b="Promise"in a&&"resolve"in a.Promise&&"reject"in a.Promise&&"all"in a.Promise&&"race"in a.Promise&&function(){var b;return new a.Promise(function(a){b=a}),f(b)}();b||(a.Promise=e)}var e=a.Promise,f=b.isFunction;c.polyfill=d}),a("promise/promise",["./config","./utils","./all","./race","./resolve","./reject","./asap","exports"],function(a,b,c,d,e,f,g,h){"use strict";function i(a){if(!v(a))throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");if(!(this instanceof i))throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");this._subscribers=[],j(a,this)}function j(a,b){function c(a){o(b,a)}function d(a){q(b,a)}try{a(c,d)}catch(e){d(e)}}function k(a,b,c,d){var e,f,g,h,i=v(c);if(i)try{e=c(d),g=!0}catch(j){h=!0,f=j}else e=d,g=!0;n(b,e)||(i&&g?o(b,e):h?q(b,f):a===D?o(b,e):a===E&&q(b,e))}function l(a,b,c,d){var e=a._subscribers,f=e.length;e[f]=b,e[f+D]=c,e[f+E]=d}function m(a,b){for(var c,d,e=a._subscribers,f=a._detail,g=0;g<e.length;g+=3)c=e[g],d=e[g+b],k(b,c,d,f);a._subscribers=null}function n(a,b){var c,d=null;try{if(a===b)throw new TypeError("A promises callback cannot return that same promise.");if(u(b)&&(d=b.then,v(d)))return d.call(b,function(d){return c?!0:(c=!0,b!==d?o(a,d):p(a,d),void 0)},function(b){return c?!0:(c=!0,q(a,b),void 0)}),!0}catch(e){return c?!0:(q(a,e),!0)}return!1}function o(a,b){a===b?p(a,b):n(a,b)||p(a,b)}function p(a,b){a._state===B&&(a._state=C,a._detail=b,t.async(r,a))}function q(a,b){a._state===B&&(a._state=C,a._detail=b,t.async(s,a))}function r(a){m(a,a._state=D)}function s(a){m(a,a._state=E)}var t=a.config,u=(a.configure,b.objectOrFunction),v=b.isFunction,w=(b.now,c.all),x=d.race,y=e.resolve,z=f.reject,A=g.asap;t.async=A;var B=void 0,C=0,D=1,E=2;i.prototype={constructor:i,_state:void 0,_detail:void 0,_subscribers:void 0,then:function(a,b){var c=this,d=new this.constructor(function(){});if(this._state){var e=arguments;t.async(function(){k(c._state,d,e[c._state-1],c._detail)})}else l(this,d,a,b);return d},"catch":function(a){return this.then(null,a)}},i.all=w,i.race=x,i.resolve=y,i.reject=z,h.Promise=i}),a("promise/race",["./utils","exports"],function(a,b){"use strict";function c(a){var b=this;if(!d(a))throw new TypeError("You must pass an array to race.");return new b(function(b,c){for(var d,e=0;e<a.length;e++)d=a[e],d&&"function"==typeof d.then?d.then(b,c):b(d)})}var d=a.isArray;b.race=c}),a("promise/reject",["exports"],function(a){"use strict";function b(a){var b=this;return new b(function(b,c){c(a)})}a.reject=b}),a("promise/resolve",["exports"],function(a){"use strict";function b(a){if(a&&"object"==typeof a&&a.constructor===this)return a;var b=this;return new b(function(b){b(a)})}a.resolve=b}),a("promise/utils",["exports"],function(a){"use strict";function b(a){return c(a)||"object"==typeof a&&null!==a}function c(a){return"function"==typeof a}function d(a){return"[object Array]"===Object.prototype.toString.call(a)}var e=Date.now||function(){return(new Date).getTime()};a.objectOrFunction=b,a.isFunction=c,a.isArray=d,a.now=e}),b("promise/polyfill").polyfill()}();
/*
Copyright (C) 2011 Patrick Gillespie, http://patorjk.com/

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

/*
    Extendible BBCode Parser v1.0.0
    By Patrick Gillespie (patorjk@gmail.com)
    Website: http://patorjk.com/

    This module allows you to parse BBCode and to extend to the mark-up language
    to add in your own tags.
*/

"use strict";

var XBBCODE = (function() {

    // -----------------------------------------------------------------------------
    // Set up private variables
    // -----------------------------------------------------------------------------

    var me = {},
        urlPattern = /^(?:https?|file|c):(?:\/{1,3}|\\{1})[-a-zA-Z0-9:@#%&()~_?\+=\/\\\.]*$/,
        colorNamePattern = /^(?:red|green|blue|orange|yellow|black|white|brown|gray|silver|purple|maroon|fushsia|lime|olive|navy|teal|aqua)$/,
        colorCodePattern = /^#?[a-fA-F0-9]{6}$/,
        tags,
        tagList,
        tagsNoParseList = [],
        bbRegExp,
        pbbRegExp,
        pbbRegExp2,
        openTags,
        closeTags;
        
    /* -----------------------------------------------------------------------------
     * tags
     * This object contains a list of tags that your code will be able to understand.
     * Each tag object has the following properties:
     *
     *   openTag - A function that takes in the tag's parameters (if any) and its
     *             contents, and returns what its HTML open tag should be. 
     *             Example: [color=red]test[/color] would take in "=red" as a
     *             parameter input, and "test" as a content input.
     *             It should be noted that any BBCode inside of "content" will have 
     *             been processed by the time it enter the openTag function.
     *
     *   closeTag - A function that takes in the tag's parameters (if any) and its
     *              contents, and returns what its HTML close tag should be.
     *
     *   displayContent - Defaults to true. If false, the content for the tag will
     *                    not be displayed. This is useful for tags like IMG where
     *                    its contents are actually a parameter input.
     *
     *   restrictChildrenTo - A list of BBCode tags which are allowed to be nested
     *                        within this BBCode tag. If this property is omitted,
     *                        any BBCode tag may be nested within the tag.
     *
     *   restrictParentsTo - A list of BBCode tags which are allowed to be parents of
     *                       this BBCode tag. If this property is omitted, any BBCode 
     *                       tag may be a parent of the tag.
     *
     *   noParse - true or false. If true, none of the content WITHIN this tag will be
     *             parsed by the XBBCode parser.
     *       
     *
     *
     * LIMITIONS on adding NEW TAGS:
     *  - Tag names should be alphanumeric (including underscores) and all tags should have an opening tag
     *    and a closing tag. 
     *    The [*] tag is an exception because it was already a standard
     *    bbcode tag. Technecially tags don't *have* to be alphanumeric, but since 
     *    regular expressions are used to parse the text, if you use a non-alphanumeric 
     *    tag names, just make sure the tag name gets escaped properly (if needed).
     * --------------------------------------------------------------------------- */
        
    tags = {
        "b": {
            openTag: function(params,content) {
                return '<span class="xbbcode-b">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        /*
            This tag does nothing and is here mostly to be used as a classification for
            the bbcode input when evaluating parent-child tag relationships
        */
        "bbcode": {
            openTag: function(params,content) {
                return '';
            },
            closeTag: function(params,content) {
                return '';
            }
        },
        "code": {
            openTag: function(params,content) {
                return '<span class="xbbcode-code">';
            },
            closeTag: function(params,content) {
                return '</span>';
            },
            noParse: true
        },
        "color": {
            openTag: function(params,content) {
            
                var colorCode = params.substr(1) || "black";
                colorNamePattern.lastIndex = 0;
                colorCodePattern.lastIndex = 0;
                if ( !colorNamePattern.test( colorCode ) ) {
                    if ( !colorCodePattern.test( colorCode ) ) {
                        colorCode = "black";
                    } else {
                        if (colorCode.substr(0,1) !== "#") {
                            colorCode = "#" + colorCode;
                        }
                    }
                }
            
                return '<span style="color:' + colorCode + '">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        "i": {
            openTag: function(params,content) {
                return '<span class="xbbcode-i">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        "img": {
            openTag: function(params,content) {
            
                var myUrl = content;
                
                urlPattern.lastIndex = 0;
                if ( !urlPattern.test( myUrl ) ) {
                    myUrl = "";
                }
            
                return '<img src="' + myUrl + '" />';
            },
            closeTag: function(params,content) {
                return '';
            },
            displayContent: false
        },
        "list": {
            openTag: function(params,content) {
                return '<ul>';
            },
            closeTag: function(params,content) {
                return '</ul>';
            },
            restrictChildrenTo: ["*", "li"]
        },
        "noparse": {
            openTag: function(params,content) {
                return '';
            },
            closeTag: function(params,content) {
                return '';
            },
            noParse: true
        },
        "php": {
            openTag: function(params,content) {
                return '<span class="xbbcode-code">';
            },
            closeTag: function(params,content) {
                return '</span>';
            },
            noParse: true
        },
        "quote": {
            openTag: function(params,content) {
                return '<blockquote class="xbbcode-blockquote">';
            },
            closeTag: function(params,content) {
                return '</blockquote>';
            }
        },
        "s": {
            openTag: function(params,content) {
                return '<span class="xbbcode-s">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        "size": {
            openTag: function(params,content) {
            
                var mySize = parseInt(params.substr(1),10) || 0;
                if (mySize < 4 || mySize > 40) {
                    mySize = 14;
                }
            
                return '<span class="xbbcode-size-' + mySize + '">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        "table": {
            openTag: function(params,content) {
                return '<table class="xbbcode-table">';
            },
            closeTag: function(params,content) {
                return '</table>';
            },
            restrictChildrenTo: ["tbody","thead", "tfoot", "tr"]
        },
        "tbody": {
            openTag: function(params,content) {
                return '<tbody>';
            },
            closeTag: function(params,content) {
                return '</tbody>';
            },
            restrictChildrenTo: ["tr"],
            restrictParentsTo: ["table"]
        },
        "tfoot": {
            openTag: function(params,content) {
                return '<tfoot>';
            },
            closeTag: function(params,content) {
                return '</tfoot>';
            },
            restrictChildrenTo: ["tr"],
            restrictParentsTo: ["table"]
        },
        "thead": {
            openTag: function(params,content) {
                return '<thead class="xbbcode-thead">';
            },
            closeTag: function(params,content) {
                return '</thead>';
            },
            restrictChildrenTo: ["tr"],
            restrictParentsTo: ["table"]
        },
        "td": {
            openTag: function(params,content) {
                return '<td class="xbbcode-td">';
            },
            closeTag: function(params,content) {
                return '</td>';
            },
            restrictParentsTo: ["tr"]
        },
        "th": {
            openTag: function(params,content) {
                return '<td class="xbbcode-th">';
            },
            closeTag: function(params,content) {
                return '</td>';
            },
            restrictParentsTo: ["tr"]
        },
        "tr": {
            openTag: function(params,content) {
                return '<tr class="xbbcode-tr">';
            },
            closeTag: function(params,content) {
                return '</tr>';
            },
            restrictChildrenTo: ["td","th"],
            restrictParentsTo: ["table","tbody","tfoot","thead"]
        },
        "u": {
            openTag: function(params,content) {
                return '<span class="xbbcode-u">';
            },
            closeTag: function(params,content) {
                return '</span>';
            }
        },
        "url": {
            openTag: function(params,content) {
            
                var myUrl;
            
                if (!params) {
                    myUrl = content.replace(/<.*?>/g,"");
                } else {
                    myUrl = params.substr(1);
                }
                
                urlPattern.lastIndex = 0;
                if ( !urlPattern.test( myUrl ) ) {
                    myUrl = "#";
                }
            
                return '<a href="' + myUrl + '">';
            },
            closeTag: function(params,content) {
                return '</a>';
            }
        },
        /*
            The [*] tag is special since the user does not define a closing [/*] tag when writing their bbcode.
            Instead this module parses the code and adds the closing [/*] tag in for them. None of the tags you
            add will act like this and this tag is an exception to the others.
        */
        "*": {
            openTag: function(params,content) {
                return "<li>";
            },
            closeTag: function(params,content) {
                return "</li>";
            },
            restrictParentsTo: ["list"]
        }
    };
    
    // create tag list and lookup fields
    tagList = [];
    (function() {
        var prop,
            ii,
            len;
        for (prop in tags) {
            if (tags.hasOwnProperty(prop)) {
                if (prop === "*") {
                    tagList.push("\\" + prop);
                } else {
                    tagList.push(prop);
                    if ( tags[prop].noParse ) {
                        tagsNoParseList.push(prop);
                    }
                }
                
                tags[prop].validChildLookup = {};
                tags[prop].validParentLookup = {};
                tags[prop].restrictParentsTo = tags[prop].restrictParentsTo || [];
                tags[prop].restrictChildrenTo = tags[prop].restrictChildrenTo || [];
                
                len = tags[prop].restrictChildrenTo.length;
                for (ii = 0; ii < len; ii++) {
                    tags[prop].validChildLookup[ tags[prop].restrictChildrenTo[ii] ] = true;
                }
                len = tags[prop].restrictParentsTo.length;
                for (ii = 0; ii < len; ii++) {
                    tags[prop].validParentLookup[ tags[prop].restrictParentsTo[ii] ] = true;
                }
            }
        }
    })();
    
    bbRegExp = new RegExp("<bbcl=([0-9]+) (" + tagList.join("|") + ")([ =][^>]*?)?>((?:.|[\\r\\n])*?)<bbcl=\\1 /\\2>", "gi"); 
    pbbRegExp = new RegExp("\\[(" + tagList.join("|") + ")([ =][^\\]]*?)?\\]([^\\[]*?)\\[/\\1\\]", "gi"); 
    pbbRegExp2 = new RegExp("\\[(" + tagsNoParseList.join("|") + ")([ =][^\\]]*?)?\\]([\\s\\S]*?)\\[/\\1\\]", "gi");    

    // create the regex for escaping ['s that aren't apart of tags
    (function() {
        var closeTagList = [];
        for (var ii = 0; ii < tagList.length; ii++) {
            if ( tagList[ii] !== "\\*" ) { // the * tag doesn't have an offical closing tag
                closeTagList.push ( "/" + tagList[ii] );
            }
        }

        openTags = new RegExp("(\\[)((?:" + tagList.join("|") + ")(?:[ =][^\\]]*?)?)(\\])", "gi"); 
        closeTags = new RegExp("(\\[)(" + closeTagList.join("|") + ")(\\])", "gi"); 
    })();
    
    // -----------------------------------------------------------------------------
    // private functions
    // -----------------------------------------------------------------------------
    
    function checkParentChildRestrictions(parentTag, bbcode, bbcodeLevel, tagName, tagParams, tagContents, errQueue) {
        
        errQueue = errQueue || [];
        bbcodeLevel++;
        
        // get a list of all of the child tags to this tag
        var reTagNames = new RegExp("(<bbcl=" + bbcodeLevel + " )(" + tagList.join("|") + ")([ =>])","gi"),
            reTagNamesParts = new RegExp("(<bbcl=" + bbcodeLevel + " )(" + tagList.join("|") + ")([ =>])","i"),
            matchingTags = tagContents.match(reTagNames) || [],
            cInfo,
            errStr,
            ii,
            childTag,
            pInfo = tags[parentTag] || {};
        
        reTagNames.lastIndex = 0;
        
        if (!matchingTags) {
            tagContents = "";
        }
        
        for (ii = 0; ii < matchingTags.length; ii++) {
            reTagNamesParts.lastIndex = 0;
            childTag = (matchingTags[ii].match(reTagNamesParts))[2].toLowerCase();
            
            if ( pInfo.restrictChildrenTo.length > 0 ) {
                if ( !pInfo.validChildLookup[childTag] ) {
                    errStr = "The tag \"" + childTag + "\" is not allowed as a child of the tag \"" + parentTag + "\".";
                    errQueue.push(errStr);
                }
            }
            cInfo = tags[childTag] || {};
            if ( cInfo.restrictParentsTo.length > 0 ) {
                if ( !cInfo.validParentLookup[parentTag] ) {
                    errStr = "The tag \"" + parentTag + "\" is not allowed as a parent of the tag \"" + childTag + "\".";
                    errQueue.push(errStr);
                }
            }
            
        }
        
        tagContents = tagContents.replace(bbRegExp, function(matchStr, bbcodeLevel, tagName, tagParams, tagContents ) {
            errQueue = checkParentChildRestrictions(tagName, matchStr, bbcodeLevel, tagName, tagParams, tagContents, errQueue);
            return matchStr;
        });
        return errQueue;
    }
    
    /*
        This function updates or adds a piece of metadata to each tag called "bbcl" which 
        indicates how deeply nested a particular tag was in the bbcode. This property is removed
        from the HTML code tags at the end of the processing.
    */
    function updateTagDepths(tagContents) {
        tagContents = tagContents.replace(/\<([^\>][^\>]*?)\>/gi, function(matchStr, subMatchStr) {
            var bbCodeLevel = subMatchStr.match(/^bbcl=([0-9]+) /);
            if (bbCodeLevel === null) {
                return "<bbcl=0 " + subMatchStr + ">";
            } else {
                return "<" + subMatchStr.replace(/^(bbcl=)([0-9]+)/, function(matchStr, m1, m2) {
                    return m1 + (parseInt(m2, 10) + 1);
                }) + ">";
            }
        });
        return tagContents;
    }
    
    /*
        This function removes the metadata added by the updateTagDepths function
    */
    function unprocess(tagContent) {
        return tagContent.replace(/<bbcl=[0-9]+ \/\*>/gi,"").replace(/<bbcl=[0-9]+ /gi,"&#91;").replace(/>/gi,"&#93;");
    }
    
    var replaceFunct = function(matchStr, bbcodeLevel, tagName, tagParams, tagContents) {
    
        tagName = tagName.toLowerCase();

        var processedContent = tags[tagName].noParse ? unprocess(tagContents) : tagContents.replace(bbRegExp, replaceFunct),
            openTag = tags[tagName].openTag(tagParams,processedContent),
            closeTag = tags[tagName].closeTag(tagParams,processedContent);
            
        if ( tags[tagName].displayContent === false) {
            processedContent = "";
        }
        
        return openTag + processedContent + closeTag;
    };

    function parse(config) {
        var output = config.text;
        output = output.replace(bbRegExp, replaceFunct);
        return output;
    }
    
    /*
        The star tag [*] is special in that it does not use a closing tag. Since this parser requires that tags to have a closing
        tag, we must pre-process the input and add in closing tags [/*] for the star tag.
        We have a little levaridge in that we know the text we're processing wont contain the <> characters (they have been
        changed into their HTML entity form to prevent XSS and code injection), so we can use those characters as markers to
        help us define boundaries and figure out where to place the [/*] tags.
    */
    function fixStarTag(text) {
        text = text.replace(/\[(?!\*[ =\]]|list([ =][^\]]*)?\]|\/list[\]])/ig, "<");
        text = text.replace(/\[(?=list([ =][^\]]*)?\]|\/list[\]])/ig, ">");

        while (text !== (text = text.replace(/>list([ =][^\]]*)?\]([^>]*?)(>\/list])/gi, function(matchStr,contents,endTag) {
            
            var innerListTxt = matchStr;
            while (innerListTxt !== (innerListTxt = innerListTxt.replace(/\[\*\]([^\[]*?)(\[\*\]|>\/list])/i, function(matchStr,contents,endTag) {
                if (endTag === ">/list]") {
                    endTag = "</*]</list]";
                } else {
                    endTag = "</*][*]";
                }
                var tmp = "<*]" + contents + endTag;
                return tmp;
            })));
            
            innerListTxt = innerListTxt.replace(/>/g, "<");            
            return innerListTxt;
        })));
        
        // add ['s for our tags back in
        text = text.replace(/</g, "[");
        return text;
    };
    
    function addBbcodeLevels(text) {
        while ( text !== (text = text.replace(pbbRegExp, function(matchStr, tagName, tagParams, tagContents) {
            matchStr = matchStr.replace(/\[/g, "<");
            matchStr = matchStr.replace(/\]/g, ">");
            return updateTagDepths(matchStr);
        })) );
        return text;
    }
    
    // -----------------------------------------------------------------------------
    // public functions
    // -----------------------------------------------------------------------------
    
    me.process = function(config) {
    
        var ret = {html: "", error: false},
            errQueue = [];

        config.text = config.text.replace(/</g, "&lt;"); // escape HTML tag brackets
        config.text = config.text.replace(/>/g, "&gt;"); // escape HTML tag brackets
        
        config.text = config.text.replace(openTags, function(matchStr, openB, contents, closeB) {
            return "<" + contents + ">";
        });
        config.text = config.text.replace(closeTags, function(matchStr, openB, contents, closeB) {
            return "<" + contents + ">";
        });
        
        config.text = config.text.replace(/\[/g, "&#91;"); // escape ['s that aren't apart of tags
        config.text = config.text.replace(/\]/g, "&#93;"); // escape ['s that aren't apart of tags
        config.text = config.text.replace(/</g, "["); // escape ['s that aren't apart of tags
        config.text = config.text.replace(/>/g, "]"); // escape ['s that aren't apart of tags

        // process tags that don't have their content parsed
        while ( config.text !== (config.text = config.text.replace(pbbRegExp2, function(matchStr, tagName, tagParams, tagContents) {
            tagContents = tagContents.replace(/\[/g, "&#91;");
            tagContents = tagContents.replace(/\]/g, "&#93;");
            tagParams = tagParams || "";
            tagContents = tagContents || "";
            return "[" + tagName + tagParams + "]" + tagContents + "[/" + tagName + "]";
        })) );

        config.text = fixStarTag(config.text); // add in closing tags for the [*] tag
        config.text = addBbcodeLevels(config.text); // add in level metadata

        errQueue = checkParentChildRestrictions("bbcode", config.text, -1, "", "", config.text);
        
        ret.html = parse(config);

        if ( ret.html.indexOf("[") !== -1 || ret.html.indexOf("]") !== -1) {
            errQueue.push("Some tags appear to be misaligned.");
        }
    
        if (config.removeMisalignedTags) {
            ret.html = ret.html.replace(/\[.*?\]/g,"");
        }
        if (config.addInLineBreaks) {
            ret.html = ret.html.replace(/\r\n/g, "\n");
            ret.html = ret.html.replace(/(\r|\n)/g, "$1<br/>");
        }
    
        ret.html = ret.html.replace("&#91;", "["); // put ['s back in
        ret.html = ret.html.replace("&#93;", "]"); // put ['s back in
        
        ret.error = (errQueue.length === 0) ? false : true;
        ret.errorQueue = errQueue;
        
        return ret;
    }
    
    return me;
})();
/*
    boron: some utilities for immutability
*/


Boron = {}

Boron.persistent_merge = function(props, data) {
    /// merges a 'flattened' data array into props in a persistent fashion
    /// the new object reuses old data where possible, so requires ~log N additional space
    
    /// given props {fun: {yay:123, ok:123}, cat:{dog:123}}    
    ///   and  data {'fun.yay':0, 'cat.ant.bear':0}}          
    ///     returns {fun: {yay:0, ok:123}, cat:{ant:{bear:0}}}
    
    data = data || []
    
    if(Array.isArray(data) || Array.isArray(data)) {
        // THINK: what do we do with arrays?
        if(Array.isArray(data) !== Array.isArray(props)) {
            // THINK: how to deal with array / object mismatch?
        }
    }
    
    // THINK: what about when data is {cat:{'ant.bear':0}} ?
    
    return Object.keys(data).reduce(function(props, key) {              // OPT: combine these instead of doing them separately
        return Boron.set_deep_value(props, key, data[key])
    }, props)
}

Boron.set_deep_value = function(props, path, value) {
    /// set a value from a flattened path
    
    /// given props {fun: {yay:123, ok:123}, cat:{dog:123}}
    ///   and  path 'fun.ok' 
    ///   and value 456
    ///     returns {fun: {yay:123, ok:456}, cat:{dog:123}}
    
    // var segs = path.split('.')
    // THINK: this is vaguely awful, but without lookbehind it's hard to say "only split on dots that aren't slashed"
    // var segs = path.split('').reverse().join('')
    //                .split(/\.(?!\\)/).reverse()
    //                .map(function(chunk) {return chunk.split('').reverse().join('')})
    //                .map(function(chunk) {return chunk.replace(/[\\]$/, '')})
    
    // THINK: this is vaguely awfuller, but works and is fairly fast and readable. 
    var magic = "___MAGIC___"
    var magic_regex = new RegExp(magic, 'g');
    var path = path.replace(/\\\./g, magic)
    var segs = path.split('.').map(function(chunk) {return chunk.replace(magic_regex, '.')})
    
    var last = segs.pop()
    var next
    var final = next = Boron.shallow_copy(props)

    segs.forEach(function(seg) {
        next[seg] = Boron.shallow_copy(next[seg])
        next = next[seg]
    })

    next[last] = value
    return final
}

Boron.shallow_copy = function(obj) {
    if(Array.isArray(obj)) return obj.slice()
    return Object.keys(obj || {}).reduce(function(acc, key) {acc[key] = obj[key]; return acc}, {})
}

Boron.shallow_diff = function(oldObj, newObj) {                         // results come from newObj
    return Object.keys(oldObj).reduce(function(acc, key) {
        if(JSON.stringify(oldObj[key]) != JSON.stringify(newObj[key]))
            acc[key] = newObj[key]                                      // this pointer copies deep data
        return acc
    }, oldObj.constructor())
}

Boron.deep_diff = function(oldObj, newObj) {                            // results come from newObj
    return Object.keys(newObj).reduce(function(acc, key) {
        var oldtype = typeof oldObj[key]
        var newtype = typeof newObj[key]
        
        if(oldtype != newtype) {
            acc[key] = newObj[key]                                      // this pointer copies deep data
            return acc
        }
        
        if(oldtype == 'object') {
            var diff = Boron.deep_diff(oldObj[key], newObj[key])
            if(Object.keys(diff).length)
                acc[key] = diff
            return acc
        }
        
        if(oldObj[key] !== newObj[key])
            acc[key] = newObj[key]
        return acc
    }, newObj.constructor())
}

Boron.flatten = function(obj, prefix) {
    /// convert {fun: {yay: 123}} into {'fun.yay': 123}
    
    if(!Boron.proper_object(obj)) return {}
    
    var newobj = {}
    prefix = prefix ? prefix + '.' : ''
    
    for(var key in obj) {
        if(!Boron.proper_object(obj[key])) {
            newobj[prefix+key] = obj[key]
        } else {
            newobj = Boron.extend(newobj, Boron.flatten(obj[key], prefix+key)) // OPT: lotsa GC here
        }
    }
    
    return newobj
}

Boron.unflatten = function(obj) {
    /// convert {'fun.yay': 123} into {fun: {yay: 123}}
    
    return Boron.persistent_merge({}, obj) // OPT: GC
    // return Object.keys(obj||{}).reduce(function(acc, key) {return Boron.set_deep_value(acc, key, obj[key])}, {}) // OPT: GC
}

Boron.proper_object = function(obj) { return typeof obj == 'object' && !Array.isArray(obj) && !!obj} 

Boron.extend = function() {
    /// given ({fun:123, yay:123}, {yay:456, ok:789}) as args, returns a new object {fun:123, yay:456, ok:789}
    
    var newobj = {}
    Array.prototype.slice.call(arguments).forEach(function(arg) {
        for(var prop in arg) {
            newobj[prop] = arg[prop] } })
    return newobj
}


Boron.memoize = function(f) {
    var table = {}
    return function() {
        var args = Array.prototype.slice.call(arguments)
        var key = args.toString()
        return table[key] ? table[key] : (table[key] = f.apply(null, args))
    } 
}

FileFile = {}

FileFile.oldFile = null

FileFile.prepBlob = function(str, type) {
    if (typeof str != 'string')
        str = JSON.stringify(str)

    var blob

    if (type == 'file')
        blob = FileFile.dataURItoBlob(str)
    else
        blob = new Blob([str], {type: 'text/plain'})

    if (navigator.appVersion.toString().indexOf('.NET') > 0)            // IE needs to directly save the blob object
        return blob

    if(FileFile.oldFile)                                                // prevents old blobs from causing mem leaks
       window.URL.revokeObjectURL(FileFile.oldFile)

    FileFile.oldFile = window.URL.createObjectURL(blob)

    return FileFile.oldFile
}

FileFile.openPuffFile = function(element) {                
    return FileFile.handleFileOpen(element)
}

FileFile.openTextFile = function(element) {                
    return FileFile.handleFileOpen(element)
}

FileFile.openBinaryFile = function(element) {                
    return FileFile.handleFileOpen(element, 'asDataURI')
}

FileFile.handleFileOpen = function(element, asDataURI) {                
    return new Promise(function(resolve, reject) {
        var reader = new FileReader()

        reader.onload = function(event) {
            // console.log(reader)
            var dataURIContent = event.target.result
            // var blob = FileFile.dataURItoBlob(dataURIContent)
            resolve(dataURIContent)
        }
        
        if(!element.files[0]) // THINK: is false the right response?
            return reject('No file selected')
            
        if(asDataURI)
            reader.readAsDataURL(element.files[0])
        else
            reader.readAsText(element.files[0])
    })
}

FileFile.dataURItoBlob = function(dataURI) {
    // convert base64/URLEncoded data component to raw binary data held in a Blob
    // via http://stackoverflow.com/questions/4998908/convert-data-uri-to-file-then-append-to-formdata
    var byteString
    
    if (dataURI.split(',')[0].indexOf('base64') >= 0)
        byteString = atob(dataURI.split(',')[1])
    else
        byteString = unescape(dataURI.split(',')[1])

    // separate out the mime component
    var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]

    // write the bytes of the string to a typed array
    var ia = new Uint8Array(byteString.length)
    for (var i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i)
    }

    return new Blob([ia], {type:mimeString})
}

/*
    events: a pub/sub system with wildcard paths
*/


Events = {}
Events.subs = {}

Events.pub = function(path, data) {
    return setImmediate(function() {Events.start_pub(path, data)})              // do it next tick
}

Events.sub = function(path, handler) {
    path = Events.scrub_path(path).join('/')
    if(!Events.subs[path]) Events.subs[path] = []
    Events.subs[path].push(handler)
}

Events.unsub = function(path, handler) {
    path = Events.scrub_path(path).join('/')

    var subs = Events.subs[path]
    if(!subs) return false

    var index = subs.indexOf(handler)
    if(index == -1) return false

    subs.splice(index, 1)
}

Events.start_pub = function(path, data) {
    //// pub to * at each level and then to path itself
    var pathlist = Events.scrub_path(path)
    var realpath = pathlist.join('/')

    Events.try_pub('*', data, realpath)                                         // global catchall

    pathlist.reduce(function(acc, seg) {                                        // channel catchalls
        var newacc = acc + seg + '/'
        Events.try_pub(newacc + '*', data, realpath)
        return newacc
    }, '')

    Events.try_pub(realpath, data, realpath)                                    // actual channel
}

Events.try_pub = function(path, data, realpath) {
    var handlers = Events.subs[path]
    if(!handlers || !handlers.length) return false
    handlers.forEach(function(handler) {handler(data, realpath)})
    // THINK: use setImmediate here?
}


Events.scrub_path = function(path) {
    return path.replace(/^[^\w*-]+/, '')                                        // trim leading slashes etc
        .replace(/[^\w*-]+$/, '')                                               // trim trailing gunk
        .split('/')                                                             // break out the path segments
        .map(function(item) {return item.replace(/[^\w*-]/g, '')})              // scrub each segment
}


// maybe later
// eventlog = []
// Events.sub('*', function(data, path) {
//     eventlog.push([path, data])
// })


/*
    gridbox: a simple system for putting things in places
*/

Gridbox = {}

Gridbox.getGridCoordBox = function(rows, cols, outerwidth, outerheight, verticalPadding) {
    var min = function(a, b) {return Math.min(a, b)}
    var max = function(a, b) {return Math.max(a, b)}
    var gridwidth  = outerwidth  / cols
    var gridheight = outerheight / rows
    var eq = function(a, b) {return a == b}
    var grid = Array.apply(0, Array(rows))
        .map(function() {return Array.apply(0, Array(cols))
            .map(function() {return 0})}) // build 2D array

    return { get: function() {return grid}
        , set_eq: function(new_eq) {eq = new_eq}
        , add: function(width, height, miny, minx, maxy, maxx, pointer) {
            maxy = min(maxy||rows-height, rows-height), maxx = min(maxx||cols-width, cols-width)
            miny = min(miny||0, maxy), minx = min(minx||0, maxx)
            if(maxx<0 || maxy<0) return PB.onError('Block is too big for the grid')

            top: for(var y = miny; y <= maxy; y++) {
                bot: for(var x = minx; x <= maxx;  x++) {
                    for(var dy = 0; dy < height; dy++) {
                        for(var dx = 0; dx < width; dx++) {
                            if(grid[y+dy][x+dx]) continue bot }}
                    break top }}
            if(x == maxx+1 && y == maxy+1) return PB.onError('No room in the grid')
            if(x == null || y == null) return PB.onError('Block too big for the grid')
            for(var dy = 0; dy < height; dy++) {
                for(var dx = 0; dx < width; dx++) {
                    grid[y+dy][x+dx] = pointer || 1 } }
            return {width: width*gridwidth, height: height*gridheight, x: x*gridwidth, y: y*gridheight+(verticalPadding/1.5)} // THINK: generalize verticalPadding 
        }
    }
}

Gridbox.findNeighbor = function(grid, pointer, dir) {
    var boxCoords = Gridbox.findBoxInGrid(grid, pointer)
    if(!boxCoords) return false

    // TODO: need to indicate if dirBox is outside of grid, versus pointer not found

    var dirBox = Gridbox.makeDirBox(boxCoords, dir)
    if(!dirBox) return false

    return Gridbox.firstThingInBox(grid, dirBox[0], dirBox[1])
}

Gridbox.findBoxInGrid = function(grid, target, eq) {
    /// find something in a grid box and return coords
    /// NOTE: this assumes rectilinear shapes
    eq = eq || function(a, b) {return a === b}
    eq = function(a, b) {return a.sig === b.sig} // TODO: encapsulate eq in gridBox // OPT: don't look inside

    top: for(var y = 0, ly = grid.length; y < ly; y++)
        for(var x = 0, lx = grid[y].length; x < lx; x++)
            if(eq(grid[y][x], target)) break top                        // find top and left coords

    if(y == grid.length && x == grid[0].length) return false            // target not in box

    for(var dy = 0, ly = grid.length-y; dy < ly; dy++)
        if(!eq(grid[y+dy][x], target)) break                            // find bottom coord

    for(var dx = 0, lx = grid[y].length-x; dx < lx; dx++)
        if(!eq(grid[y][x+dx], target)) break                            // find right coord

    return [[x, y], [x+dx-1, y+dy-1]]                                   // minus one because deltas always overshoot
}

Gridbox.firstThingInBox = function(grid, topleft, botright) {
    for(var y = Math.max(topleft[1], 0), ly = Math.min(botright[1], grid.length-1); y <= ly; y++)
        for(var x = Math.max(topleft[0], 0), lx = Math.min(botright[0], grid[0].length-1); x <= lx; x++)
            if(grid[y][x]) return grid[y][x]                            // lteq because our boxes are inclusive;
}                                                                       // boundaries are built in.

Gridbox.makeDirBox = function(boxCoords, dir) {
    var top   = boxCoords[0][1]
    var left  = boxCoords[0][0]
    var bot   = boxCoords[1][1]
    var right = boxCoords[1][0]

    if(dir == 'up')    return [[left, top-1],  [right, top-1]]
    if(dir == 'down')  return [[left, bot+1],  [right, bot+1]]
    if(dir == 'left')  return [[left-1, top],  [left-1, bot]]
    if(dir == 'right') return [[right+1, top], [right+1, bot]]
}

/*
     ____  _____ _____ _____ _____ _____ 
    |    \|  _  |   __|     | __  |  _  |
    |  |  |     |  |  |  |  | __ -|     |
    |____/|__|__|_____|_____|_____|__|__|
    
    dagoba: a tiny in-memory graph database

    ex: 
    V = [ {name: 'alice'}                                         // alice gets auto-_id (prolly 1)
        , {_id: 10, name: 'bob', hobbies: ['asdf', {x:3}]}] 
    E = [ {_out: 1, _in: 10, _label: 'knows'} ]
    g = Dagoba.graph(V, E)
    
    g.addVertex({name: 'charlie', _id: 'charlie'})                // string ids are fine
    g.addVertex({name: 'delta', _id: '30'})                       // actually they're all strings

    g.addEdge({_out: 10, _in: 30, _label: 'parent'})
    g.addEdge({_out: 10, _in: 'charlie', _label: 'knows'})

    g.v(1).out('knows').out().run()                               // returns [charlie, delta]
    
    q = g.v(1).out('knows').out().take(1)
    q.run()                                                       // returns [charlie]
    q.run()                                                       // returns [delta]    (but don't rely on result order!)
    q.run()                                                       // returns []
*/


Dagoba = {}                                                       // the namespace

Dagoba.G = {}                                                     // the prototype

Dagoba.graph = function(V, E) {                                   // the factory
  var graph = Object.create( Dagoba.G )
  graph.vertices = []                                             // fresh copies so they're not shared
  graph.edges = []
  graph.vertexIndex = {}
  if(V && Array.isArray(V)) graph.addVertices(V)                  // arrays only, because you wouldn't
  if(E && Array.isArray(E)) graph.addEdges(E)                     // call this with singular V and E
  return graph
}

Dagoba.G.v = function() {                                         // a query initializer: g.v() -> query
  var query = Dagoba.query(this)
  query.add(['vertex'].concat( [].slice.call(arguments) ))
  return query
}

Dagoba.G.addVertex = function(vertex) {
  if(!vertex._id) 
    vertex._id = this.vertices.length+1
  // TODO: ensure unique _id
  this.vertices.push(vertex) // THINK: the user may retain a pointer to vertex, which they might mutate later >.<
  // can take away user's ability to set _id and lose the index cache hash, because building it causes big rebalancing slowdowns and runs the GC hard. (or does it?) [this was with a million items, indexed by consecutive ints. generally we need settable _id because we need to grab vertices quickly by external key]
  this.vertexIndex[vertex._id] = vertex
  vertex._out = []; vertex._in = []
}

Dagoba.G.addEdge = function(edge) {
  if(!edge._label) return false
  edge._in  = this.findVertexById(edge._in)
  edge._out = this.findVertexById(edge._out)
  if(!(edge._in && edge._out)) return false
  edge._out._out.push(edge)
  edge._in._in.push(edge)
  this.edges.push(edge)
}

Dagoba.G.addVertices = function(vertices) { vertices.forEach(this.addVertex.bind(this)) }
Dagoba.G.addEdges    = function(edges)    { edges   .forEach(this.addEdge  .bind(this)) }

Dagoba.G.findVertexById = function(vertex_id) {
  return this.vertexIndex[vertex_id] }

Dagoba.G.findVerticesByIds = function(ids) {
  return ids.length == 1 ? [].concat( this.findVertexById(ids[0]) || [] )
       : ids.map( this.findVertexById.bind(this) ).filter(Boolean) }

Dagoba.G.findVertices = function(ids) {
  return typeof ids[0] == 'object' ? this.searchVertices(ids[0])
       : ids.length == 0 ? this.vertices.slice()                  // OPT: do we need the slice?
       : this.findVerticesByIds(ids) }

Dagoba.G.searchVertices = function(obj) {
  return this.vertices.filter(
    function(vertex) {
      return Object.keys(obj).reduce(
        function(acc, key) {
          return acc && obj[key] == vertex[key] }, true ) } ) }

Dagoba.G.findEdgeById = function(edge_id) {
  return Dagoba.find(this.edges, function(edge) {return edge._id == edge_id} ) }

Dagoba.G.findOutEdges = function(vertex) { return vertex._out; }
Dagoba.G.findInEdges  = function(vertex) { return vertex._in;  }

Dagoba.G.toString = function() {                                  // kids, don't hand code JSON
  return '{"V":' + JSON.stringify(this.vertices, Dagoba.cleanvertex)
       + ',"E":' + JSON.stringify(this.edges,    Dagoba.cleanedge) 
       + '}' }

Dagoba.fromString = function(str) {                               // another graph constructor
  var obj = JSON.parse(str)
  return Dagoba.graph(obj.V, obj.E) 
}



Dagoba.Q = {}                                                     // prototype

Dagoba.query = function(graph) {                                  // factory (only called by a graph's query initializers)
  var query = Object.create( Dagoba.Q )
  
  query.   graph = graph                                          // the graph itself
  query.   state = []                                             // state for each step
  query. program = []                                             // list of steps to take  
  query.gremlins = []                                             // gremlins for each step
  
  return query
}

Dagoba.Q.run = function() {                                       // the magic lives here
  
  var graph = this.graph                                          // these are closed over in the helpers
  var state = this.state                                          // so we give them a spot in the frame
  var program  = this.program
  var gremlins = this.gremlins

  var max = program.length-1                                      // work backwards
  var pc = max                                                    // program counter
  var done = -1                                                   // behindwhich things have finished
  var results = []                                                // results for this run
  var maybe_gremlin = false                                       // a mythical beast

  if(!program.length) return []                                   // don't bother
  
  
  // driver loop
  while(done < max) {
    maybe_gremlin = try_step(pc, maybe_gremlin)                   // maybe_gremlin is a gremlin or (string | false)
    
    if(maybe_gremlin == 'pull') {
      maybe_gremlin = false
      if(pc-1 > done) {
        pc--
        continue
      } else {
        done = pc
      }
    }
    
    if(maybe_gremlin == 'done') {
      done = pc
      maybe_gremlin = false
    }
    
    pc++
    
    if(pc > max) {                                                // a gremlin is popping out of the pipeline. catch it!
      if(maybe_gremlin)
        results.push(maybe_gremlin)
      maybe_gremlin = false
      pc--
    }
  }

  // TODO: deal with gremlin paths / history and gremlin "collisions"
  
  results = results.map(function(gremlin) {                       // make this a query component (or posthook)
    return gremlin.result ? gremlin.result : gremlin.vertex } )

  results = Dagoba.firehooks('postquery', this, results)[0] 
  
  return results
  
  // NAMED HELPERS
  
  function try_step(pc, maybe_gremlin) {
    var step = program[pc]
    var my_state = (state[pc] = state[pc] || {})
    if(!Dagoba.QFuns[step[0]]) return Dagoba.onError('Unrecognized function call: ' + step[0]) || maybe_gremlin || 'pull'
    return Dagoba.QFuns[step[0]](graph, step.slice(1) || {}, maybe_gremlin, my_state)
  }
    
  function gremlin_boxer(step_index) { return function(gremlin) { return [step_index, gremlin] } }
  
  function stepper(step_index, gremlin) {
    var step = program[step_index]
    if(!Dagoba.QFuns[step[0]]) return Dagoba.onError('Unrecognized function call: ' + step[0]) || {}
    return Dagoba.QFuns[step[0]](graph, step.slice(1) || {}, gremlin || {}, state[step_index] || {})
  }
  
  function eat_gremlins(gremlins, step_index, result) {
    return gremlins.concat( (result.stay || []).map(gremlin_boxer(step_index))   )
                   .concat( (result.go   || []).map(gremlin_boxer(step_index+1)) ) }
  
  function setbang_gremlins(step_index, result) {gremlins = eat_gremlins(gremlins, step_index, result)}
}


Dagoba.Q.add = function(list) {                                  // add a new traversal to the query
  this.program.push(list)
  return this
}

Dagoba.addQFun = function(name, fun) {                            // add a new traversal type
  Dagoba.QFuns[name] = fun
  Dagoba.Q[name] = function() { return this.add([name].concat([].slice.apply(arguments))) } 
  // TODO: accept string fun and allow extra params, for building quick aliases like
  //       Dagoba.addQFun('children', 'out') <-- if all out edges are kids
  //       Dagoba.addQFun('nthGGP', 'inN', 'parent')
  // var methods = ['out', 'in', 'take', 'property', 'outAllN', 'inAllN', 'unique', 'filter', 'outV', 'outE', 'inV', 'inE', 'both', 'bothV', 'bothE']
}


Dagoba.QFuns = {}                                                 // all traversal types

Dagoba.addQFun('vertex', function(graph, args, gremlin, state) {
  if(!state.vertices) state.vertices = graph.findVertices(args)
  if(!state.vertices.length) return 'done'
  var vertex = state.vertices.pop() 
  return Dagoba.make_gremlin(vertex)
})
  
Dagoba.addQFun('out', function(graph, args, gremlin, state) {
  if(!gremlin && (!state.edges || !state.edges.length)) return 'pull'
  if(!state.edges || !state.edges.length) 
    state.edges = graph.findOutEdges(gremlin.vertex).filter(Dagoba.filterThings(args[0]))
  if(!state.edges.length) return 'pull'
  var vertex = state.edges.pop()._in // what?
  var clone = Dagoba.make_gremlin(vertex) // we lose history here: use clone_gremlin(gremlin).goto(vertex) instead
  return clone
})

Dagoba.addQFun('outAllN', function(graph, args, gremlin, state) {
  var filter = args[0]
  var limit = args[1]-1
  
  if(!state.edgeList) { // initialize
    if(!gremlin) return 'pull'
    state.edgeList = []
    state.current = 0
    state.edgeList[0] = graph.findOutEdges(gremlin.vertex).filter(Dagoba.filterThings(filter))
  }
  
  if(!state.edgeList[state.current].length) { // finished this round
    if(state.current >= limit || !state.edgeList[state.current+1]   // totally done, or the next round has no items
                              || !state.edgeList[state.current+1].length) {
      state.edgeList = false
      return 'pull'
    }
    state.current++ // go to next round
    state.edgeList[state.current+1] = [] 
  }
  
  var vertex = state.edgeList[state.current].pop()._in
  
  if(state.current < limit) { // add all our matching edges to the next level
    if(!state.edgeList[state.current+1]) state.edgeList[state.current+1] = []
    state.edgeList[state.current+1] = state.edgeList[state.current+1].concat(
      graph.findOutEdges(vertex).filter(Dagoba.filterThings(filter))
    )
  }
  
  var clone = Dagoba.make_gremlin(vertex) // we lose history here: use clone_gremlin(gremlin).goto(vertex) instead
  return clone
})
  
Dagoba.addQFun('inAllN', function(graph, args, gremlin, state) {
  var filter = args[0]
  var limit = args[1]-1
  
  if(!state.edgeList) {                                           // initialize
    if(!gremlin) return 'pull'
    state.edgeList = []
    state.current = 0
    state.edgeList[0] = graph.findInEdges(gremlin.vertex).filter(Dagoba.filterThings(filter))
  }
  
  if(!state.edgeList[state.current].length) {                     // finished this round
    if(state.current >= limit || !state.edgeList[state.current+1] // totally done, or the next round has no items
                              || !state.edgeList[state.current+1].length) {
      state.edgeList = false
      return 'pull'
    }
    state.current++                                               // go to next round
    state.edgeList[state.current+1] = [] 
  }
  
  var vertex = state.edgeList[state.current].pop()._out
  
  if(state.current < limit) {                                     // add all our matching edges to the next level
    if(!state.edgeList[state.current+1]) state.edgeList[state.current+1] = []
    state.edgeList[state.current+1] = state.edgeList[state.current+1].concat(
      graph.findInEdges(vertex).filter(Dagoba.filterThings(filter))
    )
  }
  
  var clone = Dagoba.make_gremlin(vertex) // we lose history here: use clone_gremlin(gremlin).goto(vertex) instead
  return clone
})
  
Dagoba.addQFun('in', function(graph, args, gremlin, state) {
  if(!gremlin && (!state.edges || !state.edges.length)) return 'pull'
  if(!state.edges || !state.edges.length) 
    state.edges = graph.findInEdges(gremlin.vertex).filter(Dagoba.filterThings(args[0]))
  if(!state.edges.length) return 'pull'
  var vertex = state.edges.pop()._out // what? // also, abstract this...
  var clone = Dagoba.make_gremlin(vertex) // we lose history here: use clone_gremlin(gremlin).goto(vertex) instead
  return clone
})
  
Dagoba.addQFun('property', function(graph, args, gremlin, state) {
  if(!gremlin) return 'pull'
  gremlin.result = gremlin.vertex[args[0]]
  return gremlin
})
  
Dagoba.addQFun('unique', function(graph, args, gremlin, state) {
  if(!gremlin) return 'pull'
  if(state[gremlin.vertex._id]) return 'pull'                     // we've seen this gremlin, so get another instead
  state[gremlin.vertex._id] = true
  return gremlin
})
  
Dagoba.addQFun('filter', function(graph, args, gremlin, state) {
  if(!gremlin) return 'pull'
  if(typeof args[0] != 'function') return Dagoba.onError('Filter arg is not a function: ' + args[0]) || gremlin
  if(!args[0](gremlin.vertex)) return 'pull'                      // gremlin fails filter function 
  // THINK: would we ever want to filter by other parts of the gremlin?
  return gremlin
})
  
Dagoba.addQFun('take', function(graph, args, gremlin, state) {
  state.taken = state.taken ? state.taken : 0
  if(state.taken == args[0]) {
    state.taken = 0
    return 'done'
  }
  if(!gremlin) return 'pull'
  state.taken++ // THINK: mutating state
  return gremlin
})



// hi! 
// - tune gremlins (collisions, history, etc)
// - interface: show query pieces and params,
// - interface: resumable queries
// - generational queries
// - intersections
// - adverbs
// - you are great!



Dagoba.hooks = {}

Dagoba.addhook = function(type, callback) {
  if(!Dagoba.hooks[type]) Dagoba.hooks[type] = []
  Dagoba.hooks[type].push(callback)
}

Dagoba.firehooks = function(type, query) {
  var args = [].slice.call(arguments, 2)
  return ((Dagoba.hooks || {})[type] || []).reduce(function(acc, callback) {return callback.apply(query, acc)}, args)
}

Dagoba.make_gremlin = function(vertex, state) { return {vertex: vertex, state: state} }

Dagoba.filterThings = function(arg) {
  return function(thing) {
    return !arg ? true                                                                           // nothing is true
         : arg+'' === arg ? thing._label == arg                                                  // check the label
         : Array.isArray(arg) ? !!~arg.indexOf(thing._label) : Dagoba.objFilter(thing, arg) } }  // or a list of labels

Dagoba.objFilter = function(thing, obj) {
  for(var key in obj)
    if(thing[key] != obj[key])
      return false; return true }

Dagoba.find = function(arr, fun) {
  for (var i = 0, len = arr.length; i < len; i++)
    if(fun(arr[i], i, arr))
      return arr[i] }

Dagoba.cleanvertex = function(key, value) {return (key == '_in' || key == '_out') ? undefined : value} // for JSON.stringify
Dagoba.cleanedge   = function(key, value) {return key == '_in' ? value._id : key == '_out' ? value._id : value}

Dagoba.uniqueify = function (results) { // OPT: do this in the query via gremlin collision counting
  return [results.filter(function(item, index, array) {return array.indexOf(item) == index})]}

Dagoba.cleanclone = function (results) { // remove all _-prefixed properties
 return [results.map(function(item) {return JSON.parse(JSON.stringify(item, function(key, value) {return key[0]=='_' ? undefined : value}))})]}

// NOTE: add these hooks if you need them. (our vertex payloads are immutable, and we uniqueify prior to taking.)

// Dagoba.addhook('postquery', Dagoba.uniqueify)
// Dagoba.addhook('postquery', Dagoba.cleanclone)

// THINK: the uniquify hook happens after the take component so it smushes results down, possibly returning fewer than you wanted...
  
Dagoba.onError = function(msg) {
  console.log(msg)
  return false 
}
/*
       _______  __   __  _______  _______  _______  _______  ___      ___     
      |       ||  | |  ||       ||       ||  _    ||   _   ||   |    |   |    
      |    _  ||  | |  ||    ___||    ___|| |_|   ||  |_|  ||   |    |   |    
      |   |_| ||  |_|  ||   |___ |   |___ |       ||       ||   |    |   |    
      |    ___||       ||    ___||    ___||  _   | |       ||   |___ |   |___ 
      |   |    |       ||   |    |   |    | |_|   ||   _   ||       ||       |
      |___|    |_______||___|    |___|    |_______||__| |__||_______||_______|


    The main interface for the EveryBit platform.

    Most calls to the platform should go through here,
    rather than accessing core systems like PB.Data and PB.Crypto directly.

    In addition to the public-facing API many general helper functions
    are established here for use by the deeper layers.

    Copyright 2014 EveryBit. See README for license information.

*/

if(typeof PB === 'undefined') PB = {}                   // we might load config.js first
if(!PB.CONFIG) PB.CONFIG = {}                           // or we might not

PB.Modules = {}                                         // supplementary extensions live here
PB.M = PB.Modules

PB.version = '0.7.3'

////////////// STANDARD API FUNCTIONS //////////////////


PB.init = function(options) {
    //// initializes all available modules and the platform subsystems.
    //// options is an object of configuration options that is passed to each module and subsystem.
    
    options = options || {}
    
    // BEGIN CONFIG AND OPTIONS //
    
    setDefault('zone', '')
    setDefault('puffApi', 'https://i.cx/api/puffs/api.php')
    setDefault('userApi', 'https://i.cx/api/users/api.php')
    setDefault('eventsApi', 'https://i.cx/api/puffs/api.php')
    setDefault('enableP2P', false)
    setDefault('pageBatchSize', 10)
    setDefault('initLoadGiveup', 200)
    setDefault('networkTimeout', 20000)         // twenty second timeout
    setDefault('noLocalStorage', false)
    setDefault('netblockSuffix', 'local')
    setDefault('cryptoworkerURL', '')           // point to cryptoworker.js to enable worker thread
    setDefault('ephemeralKeychain', false)      // prevents keychain from being saved to localStorage
    setDefault('initLoadBatchSize', 20)
    setDefault('inMemoryShellLimit', 10000)     // shells are removed to compensate
    setDefault('globalBigBatchLimit', 2000)     // maximum number of shells to receive at once // TODO: align with API
    setDefault('inMemoryMemoryLimit', 300E6)    // ~300MB
    setDefault('anonPrivateAdminKey', '5KdVjQwjhMchrZudFVfeRiiPMdrN6rc4CouNh7KPZmh8iHEiWMx') // for registering anon users
    setDefault('disableSendToServer', false)    // so you can work locally
    setDefault('disableReceivePublic', false)   // no public puffs except profiles
    setDefault('disableCloudIdentity', false)   // don't store encrypted identity in the cloud
    setDefault('supportedContentTypes', false)  // whitelist of context types; false loads all
    setDefault('shellContentThreshold', 1000)   // size of uncompacted content
    setDefault('localStorageShellLimit', 1000)  // maximum number of shells
    setDefault('localStorageMemoryLimit', 3E6)  // ~3MB
    
    function setDefault(key, val) {
        PB.CONFIG[key] = options[key] || PB.CONFIG[key] || val
    }
    
    // END CONFIG AND OPTIONS //
        
    PB.Users.init(options)                              // initialize the user record subsystem
    PB.Data.init(options)                               // initialize the data subsystem
    PB.Net.init(options)                                // initialize the network subsystem
    
    var moduleKeys = Object.keys(PB.M)
    moduleKeys.forEach(function(key) {                  // call all module initializers
        if(PB.M[key].init) 
            PB.M[key].init(options)
    })
    
    popMods()                                           // deflate any machine prefs
    function popMods() {                                // THINK: maybe move this to PB.Persist.init
        var mods = PB.Persist.get('CONFIG')
        if(!mods) return false
    
        PB.CONFIG.mods = mods
        Object.keys(PB.CONFIG.mods).forEach(function(key) { PB.CONFIG[key] = mods[key] })
    }
    
    PB.buildCryptoworker(options)
}


PB.getPuffBySig = function(sig) {
    //// get a particular puff
    var shell = PB.Data.getCachedShellBySig(sig)        // check in regular cache
    
    if(!shell)
        shell = PB.Data.getDecryptedLetterBySig(sig)    // check in private cache
    
    if(shell)
        return PB.Data.getPuffFromShell(shell)          // get a puff from the shell
        
    return PB.Data.getPuffBySig(sig)                    // get the puff
}

PB.postPublicMessage = function(content, type) {
    //// post a public puff. type is optional and defaults to 'text'
    type = type || 'text'
    
    var myUsername = PB.getCurrentUsername()
    if(!myUsername)
        return PB.emptyPromise('You must have a current identity to post a public message')
    
    var puff = PB.simpleBuildPuff(type, content)
    return PB.addPuffToSystem(puff)
}

PB.postPrivateMessage = function(content, usernames, type) {
    //// post an encrypted puff. type is optional and defaults to 'text'. usernames is an array of usernames.
    type = type || 'text'

    var myUsername = PB.getCurrentUsername()
    if(!myUsername)
        return PB.emptyPromise('You must have a current identity to post a private message')
    
    usernames = usernames || []
    if(!Array.isArray(usernames))
        usernames = [usernames]
    
    usernames.push(myUsername)
    usernames = PB.uniquify(usernames)
    var prom = PB.Users.usernamesToUserRecordsPromise(usernames)
    
    return prom.then(function(userRecords) {        
        var puff = PB.simpleBuildPuff(type, content, null, usernames, userRecords)
        return PB.addPuffToSystem(puff)
    })
    
    return prom
}

PB.postAnonymousPrivateMessage = function(content, usernames, type) {}
PB.postParanoidPrivateMessage = function(content, usernames, type) {}


PB.createPrivatePuff = function(content, type) {
    var payload = {}
    
    var type   = type || 'file'
    var routes = ['local']

    var userRecord = PB.getCurrentUserRecord()
    var userRecordsForWhomToEncrypt = [userRecord]
    var previous, puff
    
    puff = PB.simpleBuildPuff(type, content, payload, routes, userRecordsForWhomToEncrypt)
    
    return puff
}


PB.getMyMessages = true

PB.createIdentity = function(username, passphrase) {
    // TODO: validations and error handling (lots of it)
    
    var prependedPassphrase = username + passphrase
        var privateKey = PB.Crypto.passphraseToPrivateKeyWif(prependedPassphrase)
    
    var prom = PB.registerTopLevelUser(username, privateKey, privateKey, privateKey)
    
    prom.then(function(userRecord) {
        var capa = 1 // THINK: does capa always start at 1? where should that knowledge live?
        PB.addAlias(username, username, capa, privateKey, privateKey, privateKey, {passphrase: passphrase})
        PB.switchIdentityTo(username)
    })
    
    // TODO: on switchIdentityTo false change undefined to ''
    
    return prom
}

PB.registerTopLevelUser = function(username, privateRootKey, privateAdminKey, privateDefaultKey) {
    //// create a brand new top-level user

    // OPT: privateToPublic is expensive -- we could reduce the number of calls if the private keys are identical
    var rootKeyPublic    = PB.Crypto.privateToPublic(privateRootKey)
    var adminKeyPublic   = PB.Crypto.privateToPublic(privateAdminKey)
    var defaultKeyPublic = PB.Crypto.privateToPublic(privateDefaultKey)

    var payload = { requestedUsername: username
                  ,           rootKey: rootKeyPublic
                  ,          adminKey: adminKeyPublic
                  ,        defaultKey: defaultKeyPublic
                  }

    var routes  = []
    var content = 'requestUsername'
    var type    = 'updateUserRecord'

    var puff = PB.buildPuff(username, privateAdminKey, routes, type, content, payload)
    
    var prom = PB.Net.updateUserRecord(puff)
    
    return prom
}

/**
 * register a subuser for the currently active identity
 * @param  {string} newUsername     desired new subuser name
 * @param  {string} rootKey         public root key for the new subuser
 * @param  {string} adminKey        public admin key for the new subuser
 * @param  {string} defaultKey      public default key for the new subuser
 * @return {object}                 user record for the newly created subuser
 */
PB.registerSubuser = function(newUsername, rootKey, adminKey, defaultKey) {
    //// registers a subuser for the currently active identity
    
    var signingUsername = PB.getCurrentUsername()
    var prom
    
    PB.useSecureInfo(function(_, _, _, privateAdminKey, _) {
        prom = PB.registerSubuserForUser(signingUsername, privateAdminKey, newUsername, rootKey, adminKey, defaultKey)
    })
    
    return prom
}


PB.updatePrivateKey = function(keyToModify, newPrivateKey, secrets) {
    //// attempts to update a private key for the current user. 
    //// if successful it adds the new alias to the current identity.
    //// returns a promise for the new userRecord.
    
    var username = PB.getCurrentUsername()
    var newPublicKey = PB.Crypto.privateToPublic(newPrivateKey)

    if(['defaultKey', 'adminKey', 'rootKey'].indexOf(keyToModify) == -1)
        return PB.emptyPromise('That is not a valid key to modify')

    var payload = {}
    var routes  = []
    var content = 'modifyUserKey'
    var type    = 'updateUserRecord'

    payload.keyToModify = keyToModify
    payload.newKey = newPublicKey
    payload.time = Date.now()

    var prom = new Promise(function(resolve, reject) {
        var puff

        PB.useSecureInfo(function(_, _, privateRootKey, privateAdminKey, privateDefaultKey) {
            // NOTE: puff leaks, but only contains publicly accessible data
        
            var signingUserKey = 'privateRootKey'       // changing admin or root keys requires root privileges
            var privateKey = privateRootKey

            if (keyToModify == 'defaultKey') { 
                signingUserKey = 'privateAdminKey'      // changing the default key only requires admin privileges
                privateKey = privateAdminKey
            }

            if(!privateKey) {
                return reject(PB.makeError("You need the " + signingUserKey + " to change the " + keyToModify + " key."))
            } else {
                puff = PB.buildPuff(username, privateKey, routes, type, content, payload)
            }
        })

        var userRecordPromise = PB.Net.updateUserRecord(puff)

        userRecordPromise.then(function(userRecord) {
            if(keyToModify == 'defaultKey') {
                PB.useSecureInfo(function(_, username, privateRootKey, privateAdminKey, _) {
                    PB.addAlias(username, username, userRecord.capa, privateRootKey, privateAdminKey, newPrivateKey, secrets)
                })
            }

            if(keyToModify == 'adminKey') {
                PB.useSecureInfo(function(_, username, privateRootKey, _, privateDefaultKey) {
                    PB.addAlias(username, username, userRecord.capa, privateRootKey, newPrivateKey, privateDefaultKey, secrets)
                })
            }

            if(keyToModify == 'rootKey') {
                PB.useSecureInfo(function(_, username, _, privateAdminKey, privateDefaultKey) {
                    PB.addAlias(username, username, userRecord.capa, newPrivateKey, privateAdminKey,  privateDefaultKey, secrets)
                })
            }

            return resolve(userRecord)
        })
        .catch(function(err) {
            return reject(PB.makeError(err))
        })
    })

    return prom
}

PB.getProfilePuff = function(username) {
    var cached_profile = PB.Data.profiles[username]
    
    if(cached_profile)
        return Promise.resolve(cached_profile)

    var prom = PB.Net.getProfilePuff(username)

    prom = prom.then(function(puffs) {
        var puff = puffs[0]
    
        // NOTE: Setting this prevents us from re-trying to collect profiles from users who don't have them.
        //       This is good, because it prevents network noise, but requires a refresh to see new profile info.
        if(!puff)
            puff = {payload:{}} // TODO: get a proper empty puff from somewhere
        
        PB.Data.profiles[PB.Users.justUsername(puff.username || username)] = puff
    
        return puff
    })

    return prom
}


////////////// END STANDARD API //////////////////


////////////// Handler Handlers //////////////////

PB.handlers = {}

PB.addHandler = function(type, callback) {
  if(!PB.handlers[type]) PB.handlers[type] = []
  PB.handlers[type].push(callback)
}

PB.runHandlers = function(type) {
  var args = [].slice.call(arguments, 1)
  return (PB.handlers[type] || []).reduce(
      function(acc, callback) {
          return callback.apply(null, acc == null ? args : Array.isArray(acc) ? acc : [acc])}, args)
}

PB.makeHandlerHandler = function(type) {
    return function(callback) {return PB.addHandler(type, callback)}
}

// USEFUL HANDLERS:

PB.addErrorHandler           = PB.makeHandlerHandler('error')           // receives all error messages

PB.addNewPuffHandler         = PB.makeHandlerHandler('newPuffs')        // called when new puffs are available

PB.addDHTErrorHandler        = PB.makeHandlerHandler('DHTError')        // receives DHT error messages

PB.addRelationshipHandler    = PB.makeHandlerHandler('relationship')    // manage relationships between puffs

PB.addTimeoutErrorHandler    = PB.makeHandlerHandler('timeoutError')    // receives timeout error messages

PB.addNetworkErrorHandler    = PB.makeHandlerHandler('networkError')    // receives network error messages

PB.addNewPuffReportHandler   = PB.makeHandlerHandler('newPuffReport')   // handles reports on incoming puffs

PB.addIdentityUpdateHandler  = PB.makeHandlerHandler('identityUpdate')  // general GUI update trigger

PB.addNetworkResponseHandler = PB.makeHandlerHandler('networkresponse') // receives all network response

PB.addPayloadModifierHandler = PB.makeHandlerHandler('payloadModifier') // decorate puff payloads 

// PB.addClearPuffCacheHandler = PB.makeHandlerHandler('clearpuffcache')

// beforeSwitchIdentity is called prior to switchIdentity and removeIdentity, while the old identity is active
// afterSwitchIdentity  is called after switchIdentity, once the new identity is active
PB.addBeforeSwitchIdentityHandler = PB.makeHandlerHandler('beforeSwitchIdentity')
PB.addAfterSwitchIdentityHandler  = PB.makeHandlerHandler('afterSwitchIdentity')

////////////// End Handler Handlers //////////////




//// PUFF HELPERS ////


PB.simpleBuildPuff = function(type, content, payload, routes, userRecordsForWhomToEncrypt, privateEnvelopeAlias) {
    //// build a puff for the 'current user', as determined by the key manager (by default PB.M.Wardrobe)
    var puff 

    payload = PB.runHandlers('payloadModifier', payload)

    PB.useSecureInfo(function(identities, currentUsername, privateRootKey, privateAdminKey, privateDefaultKey) {
        // THINK: should we confirm that our local capa matches the DHT's latest capa for the current user here? it turns the output into a promise...
        var previous = false // TODO: get the sig of this user's latest puff
        var versionedUsername = PB.getCurrentVersionedUsername()
        
        puff = PB.buildPuff(versionedUsername, privateDefaultKey, routes, type, content, payload, previous, userRecordsForWhomToEncrypt, privateEnvelopeAlias)
    })
    
    return puff
}


/**
 * build a new puff object based on the parameters  
 * does not hit the network, hence does no real verification whatsoever
 * @param  {string} username                    user who sign the puff
 * @param  {string} privateKey                  private default key for the user
 * @param  {string} routes                      routes of the puff
 * @param  {string} type                        type of the puff
 * @param  {string} content                     content of the puff
 * @param  {object} payload                     other payload information for the puff
 * @param  {string} previous                    most recently published content by the user
 * @param  {object} userRecordsForWhomToEncrypt
 * @param  {object} privateEnvelopeAlias
 * @return {object}                             the new puff object
 */
PB.buildPuff = function(versionedUsername, privateKey, routes, type, content, payload, previous, userRecordsForWhomToEncrypt, privateEnvelopeAlias) {
    var puff = PB.Data.packagePuffStructure(versionedUsername, routes, type, content, payload, previous)

    puff.sig = PB.Crypto.signPuff(puff, privateKey)
    
    if(userRecordsForWhomToEncrypt) {
        puff = PB.Data.encryptPuff(puff, privateKey, userRecordsForWhomToEncrypt, privateEnvelopeAlias)
    }
    
    return puff
}


/**
 * handle a newly created puff: add to our local cache and fire new content callbacks
 * @param {object} puff
 */
PB.addPuffToSystem = function(puff) {
    if(PB.Data.getCachedShellBySig(puff.sig)) return false
    
    PB.Data.addShellsThenMakeAvailable(puff)

    PB.Net.distributePuff(puff)
    
    return puff
}


PB.decryptPuffForReals = function(envelope, yourPublicWif, myVersionedUsername, myPrivateWif) {
    //// interface with PB.Crypto for decrypting a message
    // TODO: this should be in PB.Data, but is in PB for cryptoworker's sake
    if(!envelope.keys) return false
    var keyForMe = envelope.keys[myVersionedUsername]
    var puffkey  = PB.Crypto.decryptPrivateMessage(keyForMe, yourPublicWif, myPrivateWif)
    var letterCipher = envelope.payload.content
    var letterString = PB.Crypto.decryptWithAES(letterCipher, puffkey)
    var betterString = PB.tryDecodeURIComponent(escape(letterString))   // try decoding
    return PB.parseJSON(betterString)                                   // try parsing
}



//// ID FILE (LOGIN + FORMAT) ////


PB.login = function(username, privateKey) {
    //// privateKey is the key for your identity file
    
    // TODO: handle offline case...
    // TODO: encrypted localStorage identity files
    // TODO: cache encrypted puffs in localStorage
    // TODO: grab the user record from PB.loginWithPassphrase
    
    userprom = PB.Users.getUserRecordNoCache(username)
    
    return userprom.then(function(userRecord) {
        if(!userRecord)
            return PB.onError('Could not access user record')
        
        var identitySig = userRecord.identity
        
        if(identitySig) {
            var decryptprom = PB.Users.getIdentityPuff(userRecord, privateKey)
            
            return decryptprom.then(function(letter) {
                if(letter && letter.payload && letter.payload.content)
                    return PB.loginWithIdentityFile(letter.payload.content)
                else
                    return PB.throwError('Invalid password') // THINK: this could happen for other reasons
            }, function(err) {
                return PB.catchError('Could not access identity file')
            })
        }
        
        // no identity puff, so try it the old fashioned way
        // TODO: move this in to a helper function
        var publicKey = PB.Crypto.privateToPublic(privateKey)
        
        if( (userRecord.defaultKey != publicKey) 
         && (userRecord.adminKey   != publicKey) 
         && (userRecord.rootKey    != publicKey) )
            return PB.onError('That user record has no identity file, and the public key provided does not match')
    
        var secrets = {} // {passphrase: passphrase} // THINK: maybe move this up a level to loginWithPassphrase
        PB.addAlias(username, username, userRecord.capa, privateKey, privateKey, privateKey, secrets)

        PB.switchIdentityTo(username)
        
        PB.storeIdentityFileInCloud()
        
        return true
    })
}

PB.loginWithIdentityFile = function(object) {
    //// takes a canonical identity file object, adds it to the wardrobe, and signs you in
    
    var username = object.username
    var aliases  = object.aliases
    var preferences = object.preferences
    
    if(!username || !aliases || !preferences)
        return PB.onError('That is not a valid identity object')
    
    PB.currentIdentityHash = PB.Crypto.createMessageHash(JSON.stringify(object))
    
    PB.addIdentity(username, aliases, preferences)
    
    return PB.switchIdentityTo(username)
}

PB.loginWithPassphrase = function(username, passphrase, legacy) {
    // First attempt to prepend username to passphrase
    // If fails, then try just using the passphrase
    var pass = legacy ? passphrase : username + passphrase

    var privateKey = PB.Crypto.passphraseToPrivateKeyWif(pass)
    var publicKey = PB.Crypto.privateToPublic(privateKey)

    var userprom = PB.Users.getUserRecordNoCache(username)

    return userprom.then(function(userRecord) {
        if(!userRecord)
            return PB.onError('Could not access user record')
        
        if( (userRecord.defaultKey != publicKey) 
         && (userRecord.adminKey   != publicKey) 
         && (userRecord.rootKey    != publicKey) )
            return (legacy) ? false : PB.loginWithPassphrase(username, passphrase, true)

        return PB.login(username, privateKey)
    })
}


PB.storeIdentityFileInCloud = function() {
    if(!PB.currentIdentityHash) {
        // THINK: user did not log in with identity file... so what should we do here?
    }

    // get identity file
    var content = PB.formatIdentityFile()
    if(!content) return false
    
    // check against latest
    var newIdentityHash = PB.Crypto.createMessageHash(JSON.stringify(content))
    if(PB.currentIdentityHash == newIdentityHash) return false
    PB.currentIdentityHash = newIdentityHash
    
    // package as encrypted puff
    var payload = {}
    var routes  = []
    var type    = 'identity'
        
    var userRecord = PB.getCurrentUserRecord()
    var userRecordsForWhomToEncrypt = [userRecord]

    if(!userRecord) return false

    // THINK: using simpleBuildPuff puts a timestamp in the identity file...
    var puff = PB.simpleBuildPuff(type, content, payload, routes, userRecordsForWhomToEncrypt)
    
    if(!puff) return false
        
    // if(puff.sig == userRecord.identity) return false // always false, because of the timestamp -- if you remove it, add this back
    
    PB.Net.distributePuff(puff)                         // send it to the server
    
    // update user record
    var payload = {}                                    // NOTE: the double "var"s don't hurt, and help keep us focused
    var routes  = []
    var type    = 'updateUserRecord'
    var content = 'setIdentity'
    var update_puff

    payload.identity = puff.sig

    PB.useSecureInfo(function(_, currentUsername, _, privateAdminKey, _) {
        if(!privateAdminKey)
            return PB.onError('You must have an administrative key to upload your identity file')
        
        update_puff = PB.buildPuff(currentUsername, privateAdminKey, routes, type, content, payload)
    })
    
    if(!update_puff)
        return false
    
    var update_prom = PB.Net.updateUserRecord(update_puff)
        
    return update_prom
}

PB.formatIdentityFile = function(username) {
    // THINK: consider passphrase protecting the identity file by default
    // TODO: add authFromIdFile -- need consistency both ways
    
    username = username || PB.getCurrentUsername()
    
    if(!username) return false

    var idFile = {}

    PB.useSecureInfo(function(identities, currentUsername, privateRootKey, privateAdminKey, privateDefaultKey) {
        // this leaks all of the identity information back to the caller
        // if we passphrase protect the file, do it here to prevent that leakage

        var identity = identities[username]

        // assemble idFile manually to keep everything in the right order
        // idFile.comment = "This file contains your private passphrase. It was generated at i.cx. The information here can be used to login to websites on the puffball.io platform. Keep this file safe and secure!"

        idFile.username = username
        // idFile.primary  = identity.primary // NOTE: primary is automatically gathered from aliases
        idFile.aliases  = identity.aliases
        idFile.preferences = identity.preferences
        idFile.version  = "1.1"
    })

    return idFile
}



//// USER CREATION ////

/**
 * register a subuser
 * @param  {string} signingUsername username of existed user
 * @param  {string} privateAdminKey private admin key for existed user
 * @param  {string} newUsername     desired new subuser name
 * @param  {string} rootKey         public root key for the new subuser
 * @param  {string} adminKey        public admin key for the new subuser
 * @param  {string} defaultKey      public default key for the new subuser
 * @return {object}                user record for the newly created subuser
 */
PB.registerSubuserForUser = function(signingUsername, privateAdminKey, newUsername, rootKey, adminKey, defaultKey) {

    // build our DHT update puff
    var payload = { requestedUsername: newUsername
                  ,        defaultKey: defaultKey
                  ,          adminKey: adminKey
                  ,           rootKey: rootKey
                  ,              time: Date.now()
                  }

    var routing = [] // THINK: DHT?
    var content = 'requestUsername'
    var type    = 'updateUserRecord'

    var puff = PB.buildPuff(signingUsername, privateAdminKey, routing, type, content, payload)
    // NOTE: we're skipping previous, because requestUsername-style puffs don't use it.

    return PB.Net.updateUserRecord(puff)
}




//// BUILD CRYPTO WORKER ////

PB.buildCryptoworker = function(options) {
    var cryptoworkerURL = options.cryptoworkerURL || PB.CONFIG.cryptoworkerURL // || 'cryptoworker.js'
    
    if(!cryptoworkerURL) return false
    
    PB.cryptoworker = new Worker(cryptoworkerURL)
    PB.cryptoworker.addEventListener("message", PB.workerreceive)
}

PB.workerqueue = []
PB.workerautoid = 0

PB.workerreceive = function(msg) {
    var id = msg.data.id
    if(!id) return false // TODO: add onError here

    var fun = PB.workerqueue[id]
    if(!fun) return false // TODO: add onError here

    fun(msg.data.evaluated)

    delete PB.workerqueue[id] // THINK: this leaves a sparse array, but is probably faster than splicing
}

PB.workersend = function(funstr, args, resolve, reject) {
    PB.workerautoid += 1
    PB.workerqueue[PB.workerautoid] = resolve
    if(!Array.isArray(args))
        args = [args]
    PB.cryptoworker.postMessage({fun: funstr, args: args, id: PB.workerautoid})
}

//// END BUILD CRYPTO WORKER ////




////////////// SECURE INFORMATION INTERFACE ////////////////////

PB.implementSecureInterface = function(useSecureInfo, addIdentity, addAlias, setPrimaryAlias, setPreference, switchIdentityTo, removeIdentity) {
    // useSecureInfo    = function( function(identities, username, privateRootKey, privateAdminKey, privateDefaultKey) )
    // addIdentity      = function(username, aliases, preferences)
    // addAlias         = function(identityUsername, aliasUsername, capa, privateRootKey, privateAdminKey, privateDefaultKey, secrets)
    // setPrimaryAlias  = function(identityUsername, aliasUsername)
    // removeIdentity   = function(username)
    // setPreference    = function(key, value) // for current identity
    // switchIdentityTo = function(username)

    // THINK: consider ensuring all functions are present first, so it's harder to mix and match wardrobe implementations
    
    if(typeof useSecureInfo == 'function') {
        PB.useSecureInfo = function(callback) {
            // NOTE: useSecureInfo returns true if there is a current identity, and false otherwise
            return useSecureInfo( function(identities, username, privateRootKey, privateAdminKey, privateDefaultKey) {
                var clonedIdentities = JSON.parse(JSON.stringify(identities)) // prevent accidental mutation
                callback(clonedIdentities, username, privateRootKey, privateAdminKey, privateDefaultKey)
            })
        }
    }
    
    if(typeof addIdentity == 'function')
        PB.addIdentity = addIdentity
        
    if(typeof addAlias == 'function')
        PB.addAlias = addAlias
        
    if(typeof setPrimaryAlias == 'function')
        PB.setPrimaryAlias = setPrimaryAlias
        
    if(typeof setPreference == 'function')
        PB.setPreference = setPreference
        
    if(typeof switchIdentityTo == 'function')
        PB.switchIdentityTo = function(username) {
            PB.runHandlers('beforeSwitchIdentity', username)
            var output = switchIdentityTo(username)
            PB.runHandlers('afterSwitchIdentity', username)
            return output
        }
        
    if(typeof removeIdentity == 'function')
        PB.removeIdentity = removeIdentity
        
    PB.getCurrentUsername = function() {
        // yes, this technique allows you to leak data out of useSecureInfo. no, you should not use it.
        var output
        PB.useSecureInfo(function(identities, username) { output = username })
        return output
    }
    
    PB.getCurrentCapa = function() {
        // yes, this technique allows you to leak data out of useSecureInfo. no, you should not use it.
        var output
        PB.useSecureInfo(function(identities, username) { output = ((identities[username]||{}).primary||{}).capa||0 })
        return output
    }
    
    PB.getCurrentVersionedUsername = function() {
        var username = PB.getCurrentUsername()
        if(!username)
            return PB.onError('No current user in wardrobe')
        
        return PB.Users.makeVersioned(username, PB.getCurrentCapa())
    }
    
    PB.getCurrentUserRecord = function() {
        var versionedUsername = PB.getCurrentVersionedUsername()
        if(!versionedUsername)
            return false
        
        // THINK: it's weird to hit the cache directly from here, but if we don't then we always get a promise,
        //        even if we hit the cache, and this should return a proper userRecord, not a promise, 
        //        since after all we have stored the userRecord in our wardrobe, haven't we?
    
        var userRecord = PB.Users.records[versionedUsername]
        if(!userRecord)
            return PB.onError('That user does not exist in our records')
    
        return userRecord
    }

    PB.getAllIdentityUsernames = function() {
        // yes, this technique allows you to leak data out of useSecureInfo. no, you should not use it.
        var output
        PB.useSecureInfo(function(identities, username) { output = Object.keys(identities) })
        return output
    }
    
}

////////////// END SECURE INFORMATION ZONE ////////////////////






//// VALIDATIONS

// TODO: merge these into PB.Spec

/**
 * check if a username is valid
 *     a username must be shorter than 256 characters, all lowercase and contains only alphanumeric and . sign
 * @param  {string} username the string to be check
 * @return {boolean}          return true if  the parameter string is a valid username, otherwise throw error
 */
PB.validateUsername = function(username) {
    if(!username) 
        return PB.onError('Username is required', username)

    if(username.length > 256) 
        return PB.onError('Usernames must be shorter than 256 characters', username)

    if(username != username.toLowerCase()) 
        return PB.onError('Usernames must be lowercase', username)
    
    if(!/^[0-9a-z.]+$/.test(username))
        return PB.onError('Usernames must be alphanumeric', username)
    
    return true
}


/**
 * determine if it is a good shell, checks for the existence of required fields
 * @param {Shell[]}
 * @returns {boolean}
 */
PB.isValidShell = function(shell) {
    //// this just checks for the existence of required fields
    if(!shell.sig) return false
    if(!shell.routes) return false
    if(!shell.username) return false
    if(typeof shell.payload != 'object') return false
    if(!shell.payload.type) return false
        
    return true
}

/**
 * to verify a puff
 * @param  {object} puff
 * @return {(string|boolean)}
 */
PB.isGoodPuff = function(puff) {
    // CURRENTLY UNUSED
    // TODO: check previous sig, maybe
    // TODO: check for well-formed-ness
    // TODO: use this to verify incoming puffs
    // TODO: if prom doesn't match, try again with getUserRecordNoCache
    
    // TODO: rewrite this function to give a consistent return value
    
    if (!PB.M.Forum.contentTypes[shell.payload.type]) {
        // TODO: this needs to include 'encryptedpuff' as a valid type
        Events.pub('track/unsupported-content-type', {type: shell.payload.type, sig: shell.sig})
        return false
    }
    
    var prom = PB.Users.getUserRecordPromise(puff.username) // NOTE: versionedUsername
    
    return prom.then(function(user) {
        return PB.Crypto.verifyPuffSig(puff, user.defaultKey)
    })
}



//// ERROR HELPERS

// TODO: build a more general error handling system for GUI integration

PB.onError = function(msg, obj, trigger) {
    //// override this for custom error behavior
    
    var composite = {msg: msg, obj: obj}

    PB.runHandlers('error', composite)
    
    if(trigger)
        PB.runHandlers(trigger, composite)
        
    // for debugging help, run this in the console:
    // PB.addErrorHandler(function(composite) {console.log(composite)})

    return false
}

PB.catchError = function(msg) {
    //// ex: prom.catch( PB.catchError('invalid foo') ).then(function(foo) {...})
    return function(err) {
        PB.onError(msg, err)
        throw err
    }
}

PB.throwError = function(msg, errmsg) {
    //// ex: prom.then(function(foo) {if(!foo) PB.throwError('no foo'); ...})
    var err = errmsg ? Error(errmsg) : ''
    throw PB.makeError(msg, err)
}

PB.makeError = function(msg, err, trigger) {
    //// ex: new Promise(function(resolve, reject) { if(!foo) reject( PB.makeError('no foo') ) ... })
    PB.onError(msg, err, trigger)
    return Error(msg)
}

PB.emptyPromise = function(msg) {
    //// ex: function(foo) { if(!foo) return PB.emptyPromise('no foo'); return getFooPromise(foo) }
    if(msg) PB.onError(msg)
    return Promise.reject(msg)
}

PB.throwNetError = function(msg, errmsg) {
    //// like throw error but triggers the networkError handler
    var trigger = 'networkError'
    var err = errmsg ? Error(errmsg) : ''
    throw PB.makeError(msg, err, trigger)
}

PB.throwDHTError = function(msg, errmsg) {
    //// like throw error but triggers the DHTError handler
    var trigger = 'DHTError'
    var err = errmsg ? Error(errmsg) : ''
    throw PB.makeError(msg, err, trigger)
}


//// Exceptional API wrappers

PB.parseJSON = function(str) {
    //// JSON.parse throws, so we catch it. throw/catch borks the JS VM optimizer, so we box it.
    try {
        return JSON.parse(str)
    } catch(err) {
        return PB.onError('Invalid JSON string', err)
    }
}

PB.stringifyJSON = function(obj) {
    //// JSON.stringify throws on dumb DOM objects, so we catch it. throw/catch borks the JS VM optimizer, so we box it.
    try {
        return JSON.stringify(obj)
    } catch(err) {
        return PB.onError('Invalid object', err)
    }
}

PB.tryDecodeURIComponent = function(str) {
    //// decodeURIComponent throws, so we wrap it. try/catch kills the optimizer, so we isolate it.
    try {
        return decodeURIComponent(str)
    } catch(err) {
        return PB.onError('Invalid URI string', err)
    }
}


//// something different

PB.promisesPending = {}

// Major jujitsu here
PB.promiseMemoize = function(fun, ohboy) {
    if(!ohboy) ohboy = PB.removePromisePending
    
    return function() {
        var key = JSON.stringify([fun.toString(),arguments])
        
        if(PB.promisesPending[key])
            return PB.promisesPending[key]
        
        var prom = fun.apply(fun, arguments)
        prom = prom.then(function(value) {
            ohboy(key, value)
            return value                                        // deliver successes
        }, function(value) {
            ohboy(key, value)
            throw value                                         // propagate failures
        })
        
        PB.promisesPending[key] = prom
        return prom
    }
}

PB.removePromisePending = function(key) {
    delete PB.promisesPending[key]
}

//// TIMING HELPERS


// TODO: move these into a library

~function() {
    //// postpone until next tick
    // inspired by http://dbaron.org/log/20100309-faster-timeouts
    var later = []
    var messageName = 12345
    var gimme_a_tick = true

    function setImmediate(fun) {
        later.push(fun)
        
        if(gimme_a_tick) {
            gimme_a_tick = false
            window.postMessage(messageName, "*")
        }
        
        return false
    }

    function handleMessage(event) {
        if(event.data != messageName) return false

        event.stopPropagation()
        gimme_a_tick = true

        var now = later
        later = []

        for(var i=0, l=now.length; i < l; i++)
            now[i]()
    }
  
    if(typeof window != 'undefined') {
        window.addEventListener('message', handleMessage, true)
        window.setImmediate = setImmediate
    }
}()

PB.queuer = function() {
    //// do something after some other things
    var queue = []
    
    var nexttime = function(invoker) {
        invoker(function() {
            if(!queue.length) return false
            queue.shift()()
            nexttime(invoker)
        })
    }
            
    var queuer = function(invoker, fun) {
        queue.push(fun)
        if(queue.length > 1) return false // THINK: possible race condition
        nexttime(invoker) 
    }
    
    return queuer
}

PB.once = function() {
    //// do something later, but only once
    var later = []

    var step = function() {
        var now = later
        later = []
        for(var i=0, l=now.length; i < l; i++)
            now[i]()
    }
            
    var once = function(invoker, fun) {
        if(~later.indexOf(fun)) return false
        later.push(fun)
        if(later.length > 1) return false // THINK: possible race condition
        invoker(step) 
    }
    
    return once
}

~function() {
    if(typeof window != 'undefined') {
        window.queueImmediate = PB.queuer().bind(null, setImmediate)
        window.onceImmediate  = PB.once().bind(null, setImmediate)
        window.queueRAF = PB.queuer().bind(null, requestAnimationFrame)
        window.onceRAF  = PB.once().bind(null, requestAnimationFrame)
    
        var timefunbind = {}
        window.onceInAwhile = function(fun, time) {
            //// NOTE: don't use the same fun with different times
            if(timefunbind[fun]) return false
            timefunbind[fun] = setTimeout(function() {fun(); timefunbind[fun] = false}, time)
        }
    }
}()




////////////// A few small helpers for building functional pipelines ///////////////

PB.prop = function(p, obj) { // THINK: consider importing all of Rambda.js
    return arguments.length < 2 ? function (obj) { return obj[p]; } : obj[p]
}

PB.uniquify = function(list) {
    return list.filter(PB.unique)
}

PB.unique = function(item, index, array) {return array.indexOf(item) == index}

/*

    Network library for the EveryBit platform.

    Contains a peer.js-based p2p layer, a promise-based XHR implementation, 
    helper functions for accessing various server-based APIs, 
    and helper functions for handling puff distribution and acquisition.

    Copyright 2014 EveryBit. See README for license information.

 */

PB.Net = {}

/**
 * Fire up networks (currently just the peer connections)
 */
PB.Net.init = function() {
    PB.Net.P2P.init()
}

/**
 * Given a signature, return puff with that signature
 * @param  {string} sig signature of a puff
 * @return {object}     puff corresponds to the specified signature
 */
PB.Net.getPuffBySig = function(sig) {
    var url  = PB.CONFIG.puffApi
    var data = {type: 'getPuffBySig', sig: sig}
    
    return PB.Net.PBgetJSON(url, data)
}

PB.Net.getKidSigs = function(sig) {
    var url  = PB.CONFIG.puffApi
    var data = {type: 'getChildrenBySig', sig: sig}
    
    return PB.Net.PBgetJSON(url, data)
}

PB.Net.getKidSigs = Boron.memoize(PB.Net.getKidSigs) // THINK: this assumes we'll get all new things over the P2P network, which won't always be true.



PB.Net.getStarShells = function() {
    var url  = PB.CONFIG.puffApi
    var data = {type: 'getPuffs', contentType: 'star', numb: PB.CONFIG.globalBigBatchLimit}
    
    return PB.Net.PBgetJSON(url, data)
}

PB.Net.getConversationPuffs = function(convoId, batchsize, offset, fullOrShell) {
    convoId  = convoId.replace('&',',')

    var url  = PB.CONFIG.puffApi
    var data = { type: 'getPuffs', contentType: 'encryptedpuff'
               , conversationPartners: convoId
               , numb: batchsize
               , offset: offset
               }
    
    return PB.Net.PBgetJSON(url, data)
}

PB.Net.getMyPrivatePuffs = function(username, batchsize, offset, fullOrShell) {
    if(!username) return PB.emptyPromise()
    batchsize = batchsize || PB.CONFIG.globalBigBatchLimit
    
    var url  = PB.CONFIG.puffApi
    var data = { route: username, username: username, fromAndTo: 1
               , type: 'getPuffs', contentType: 'encryptedpuff'
               , fullOrShell: fullOrShell || 'full'
               , numb: batchsize
               , offset: offset
               }
    
    return PB.Net.PBgetJSON(url, data)
    
/*

    So something like:

    PB.getSomePuffs(query, limit, etc)

    helper.js:
    tryGettingMorePuffs(visibleLimit) {
        // figure out how many we've requested already (ICX.currentOffset)
        // figure out how many we actually have (PB.Data.getDecryptedPuffs)
        var delta = visibleLimit - PB.Data.getDecryptedPuffs().length
        ICX.currentOffset += delta
        return PB.getSomePuffs(query, ICX.currentOffset)
    }


*/ 

    // TODO: chain this in to the table view
    
}


PB.Net.getProfilePuff = function(username) {
    var url  = PB.CONFIG.puffApi
    var data = { username: username
               , fullOrShell: 'full'
               , contentType: 'profile'
               , type: 'getPuffs'
               , sort: 'DESC'
               , numb: 1
               }
    
    return PB.Net.PBgetJSON(url, data)
}
PB.Net.getProfilePuff = PB.promiseMemoize(PB.Net.getProfilePuff)

/**
 * to get some shells
 * @param {string} query
 * @param {string} filters
 * @param {number} limit
 * @param {number} offset
 * @returns {Shell[]}
 */
PB.Net.getSomeShells = function(query, filters, limit, offset) {
    // TODO: switching by query 'mode' will need to be changed when the network api matches our local api (i.e. once we use browser p2p & headless clients to service requests)
    
    var mode = query.mode
    if(mode == 'ancestors')   return PB.Net.getAncestors  ([query.focus], limit)
    if(mode == 'descendants') return PB.Net.getDescendants([query.focus], limit)
    // if(mode == 'siblings')    return PB.Net.getSiblings   ([query.focus], limit)

    // "normal" mode (just ask for shells from lists or something)
    var url  = PB.CONFIG.puffApi

    //  if(filters.types)   data.type       = filters.types      // filter by types

    var data = {type: 'getPuffs', contentType: 'plain'}
    // var data = {type: 'getPuffs', contentType: '["image"]'}


    if(limit)  data.numb    = limit                         // defaults to 20 on the server
    if(offset) data.offset  = offset                        // defaults to 0, which is latest
    
    if(query.sort)      data.sort        = query.sort       // ASC or DESC
    if(filters.users)   data.username    = filters.users    // filter by username
    if(filters.routes)  data.route       = filters.routes   // filter by route
    if(filters.tags)    data.tags        = filters.tags     // filter by tags
    if(filters.types)   data.contentType = filters.types    // filter by types
    if(query.ancestors) data.maxParents  = query.ancestors  // defaults to all shells 
                                                            // 0 is roots, 1 is single parent, etc
    // data.flagged = false
    
    // data.focus
    // data.ancestors
    // data.descendants
    
    var filterstring = JSON.stringify(filters.types)
    var profile_request = (filterstring == '["profile"]')
    
    if(PB.CONFIG.disableReceivePublic && !profile_request)
        return PB.emptyPromise()
                 .then(function() {return []})
    
    return PB.Net.PBgetJSON(url, data)                      // always returns a valid array
                 .then(function(x) {return x || []}, function() {return []})
}


PB.Net.getAncestors = function(start, limit) {
    getEm(start, [], limit)
    return PB.emptyPromise()
    
    function getEm(todo, done, remaining) {
        if(!todo.length) return false                       // all done
        if(!remaining) return false                         // all done
    
        var sig = todo[0]
    
        if(~done.indexOf(sig)) {
            return getEm(todo.slice(1), done, remaining)    // we've already done this one
        }
        
        // TODO: set a callback in PB.Net instead of calling PB.Data directly
        var puff = PB.Data.getPuffBySig(sig)                // effectful
    
        if(puff) 
            return getEm(todo.slice(1).concat(puff.payload.parents), done.concat(sig), remaining)

        // no puff? that's ok. attach a then clause to its pending promise.
        // TODO: find better method to do this
        remaining-- // because we're adding a new puff, or at least new content
        var prom = PB.Data.pendingPuffPromises[sig]
        prom.then(function(puffs) {
            getEm(todo.slice(1).concat(((puffs[0]||{}).payload||{}).parents), done.concat(sig), remaining)
        })
    }
    
    //
    // if(!todo.length)
    //     return Promise.resolve(results)             // all done
    // if(results.length >= limit)
    //     return Promise.resolve(results)             // all done
    //
    // var sig = todo[0]
    // var shell = PB.Data.getCachedShellBySig(sig)   // TODO: set a callback in PB.Net instead of calling this directly
    //          || results.filter(function(result) {return result.sig == sig})[0]
    //
    // // if we already have a puff for sig, then we just need to put its parents on the todo stack
    // if(shell) {
    //     todo.shift() // take off the shell we just worked on
    //     return PB.Net.getAncestors(todo.concat(shell.payload.parents), limit, results)
    // }
    //
    // // otherwise, get a promise for the shell, then add it to results
    // var prom = PB.Net.getPuffBySig(sig)
    // return prom.then(function(puffs) {
    //     return PB.Net.getAncestors(todo, limit, results.concat(puffs))
    // })
}

PB.Net.getDescendants = function(start, limit) {
    getEm(start, [], limit)
    return PB.emptyPromise()
    
    function getEm(todo, done, remaining) {
        if(!todo.length) return false                       // all done
        if(!remaining) return false                         // all done
        
        var sig = todo[0]
        
        if(~done.indexOf(sig)) {
            return getEm(todo.slice(1), done, remaining)    // we've already done this one
        }
        
        // TODO: set a callback in PB.Net instead of calling PB.Data directly
        var haveShell = PB.Data.getCachedShellBySig(sig) 
        
        if(!haveShell) {                                    // we don't have the shell yet, so go get it
            // TODO: use above callback to PB.Data
            PB.Data.getPuffBySig(sig)                       // effectful
            remaining--
        }
        
        var kidsigprom = PB.Net.getKidSigs(sig)             // get all its children
        return kidsigprom.then(function(kidsigs) {
            getEm(todo.slice(1).concat(kidsigs), done.concat(sig), remaining)
        })
    }
}

PB.Net.getSiblings = function() {
    // this case is ugly, so we're leaving it until the client api can answer questions for us
    return PB.emptyPromise() 
}

/**
 * add puff to the server and broadcast to peers
 * @param  {object} puff the puff to be added to the server
 */
PB.Net.distributePuff = function(puff) {
    //// distribute a puff to the network

    if(PB.CONFIG.disableSendToServer) return false          // so you can work locally

    if(PB.CONFIG.netblockSuffix) {                          // block distribution of local puffs
        var usernames = [puff.username]
        if(puff.keys)
            usernames = usernames.concat(Object.keys(puff.keys))

        usernames = usernames.map(PB.Users.justUsername)
        var suffixes = usernames.map(function(username) {
            var chunks = username.split('.')
            return chunks[chunks.length-1]
        })
        
        if(suffixes.indexOf(PB.CONFIG.netblockSuffix) > -1)
            return false
    }

    PB.Net.sendPuffToServer(puff)                           // add it to the server's pufflist

    PB.Net.P2P.sendPuffToPeers(puff)                        // broadcast it to peers
}

/**
 * add a puff to the server's pufflist
 * @param  {object} puff
 * @return {object}
 */
PB.Net.sendPuffToServer = function(puff) {
    // THINK: this is fire-and-forget, but we should do something smart if the network is offline or it otherwise fails. 
    //        on the other hand, we'll probably want to do this with sockets instead of ajax ultimately...
    //        or manage it entirely with routing, even for server-sent puffs?
    
    var data = { type: 'addPuff'
               , puff: JSON.stringify(puff) }
               
    return PB.Net.PBpost(PB.CONFIG.puffApi, data)
                 .catch(PB.catchError('Could not send puff to server'))
}

/**
 * fetch a particular userRecord
 * @param  {string}  username 
 * @param  {string}  capa 
 * @return {promise} on fulfilled passes the user record as object, otherwise re-throw error
 */
PB.Net.getUserRecord = function(username, capa) {
    var url   = PB.CONFIG.userApi
    
    var versionedUsername = PB.Users.makeVersioned(username, capa)
    username = PB.Users.justUsername(versionedUsername)
    
    if(capa !== 0) // 0 signals that we need to fetch the latest userRecord
        capa = PB.Users.justCapa(versionedUsername)
    
    var data  = { type: 'getUser'
                , username: username
                }

    if(capa)
        data.capa = capa

    return PB.Net.PBgetJSON(url, data)
}


/**
 * modify a user record
 * @param  {puff}   puff a signed puff containing information of modified user record
 * @return {object} promise for new userRecord or error when the update fails
 */
PB.Net.updateUserRecord = function(puff) {
    var data = { type: 'updateUsingPuff'
               , puff: puff
               }

    var prom = PB.Net.PBpost(PB.CONFIG.userApi, data)
    
    return prom.catch(PB.catchError('Sending user record modification puff failed'))
               .then(JSON.parse) // THINK: this throws on invalid JSON
               .then(function(userRecord) {
                   return PB.Users.process(userRecord)
                       || PB.throwError('Invalid user record', JSON.stringify(userRecord))
               })
}



/**
 * PB.Net promise-based XHR layer
 * 
 * We use promises as our default concurrency construct, 
 * because ultimately this platform is composed of a 
 * huge set of interdependent async calls which mostly 
 * each resolve to a single immutable entity 
 * -- aka the promise sweet spot.
 * 
 * @param  {string} url     requested url
 * @param  {object} options 
 * @param  {object} data    
 * @return {object}
 */
PB.Net.xhr = function(url, options, data) {
    //// very simple promise-based XHR implementation
    
    return new Promise(function(resolve, reject) {
        var req = new XMLHttpRequest()
        req.open(options.method || 'GET', url)
        
        Object.keys(options.headers || {}).forEach(function (key) {
            req.setRequestHeader(key, options.headers[key])
        })
        
        var formdata = new FormData()
        Object.keys(data || {}).forEach(function (key) {
            var datum = typeof data[key] == 'object' ? PB.stringifyJSON(data[key]) : data[key]
            formdata.append(key, datum)
        })
        
        if(options && options.type)
            req.responseType = options.type
                
        req.onload = function() {
            if(req.status != 200) // silly safari
                return reject(PB.makeError(req.statusText))
            
            if(req.responseType == 'json' && req.response === null) // NOTE: traps JSONified 'null' responses also: use empty string or [] to indicate an empty result
                return reject(PB.makeError("Invalid JSON in response", req.response))
            
            resolve( (req.responseType != options.type) // manually convert json for old browsers
                  && options.type == 'json' ? PB.parseJSON(req.response) : req.response)
        }

        req.onerror = function(event) {
            reject(PB.makeError("Network Error", event, 'networkError'))
        }
        
        req.ontimeout = function(event) {
            reject(PB.makeError("Timeout Error", event, 'timeoutError'))
        }
        
        req.timeout = PB.CONFIG.networkTimeout

        req.send(formdata)
    })
}

/**
 * request an url, get result in JSON
 * @param  {string} url    
 * @param  {object} params 
 * @return {object}
 */
PB.Net.getJSON = function(url, params) {
    var options = { headers: { 'Accept': 'application/json' }
                  ,  method: 'GET'
                  ,    type: 'json'
                  }

    var params = params || {}
    var enc = function(param) {return !param && param!==0 ? '' : encodeURIComponent(param)}
    var qstring = Object.keys(params).reduce(function(acc, key) {return acc + enc(key) +'='+ enc(params[key]) +'&'}, '?')

    return PB.Net.xhr(url + qstring, options) 
}


/**
 * send a post request
 * @param  {string} url  requested url
 * @param  {object} data 
 * @return {object}
 */
PB.Net.post = function(url, data) {
    var options = { headers: {   
//         'Content-type': 'application/x-www-form-urlencoded' 
//                           , 'Content-length': params.length
//                           ,     'Connection': 'close'  
                             }
                  ,  method: 'POST'
                  }

    return PB.Net.xhr(url, options, data)
}



/**
 * A customized wrapper for the EveryBit server over the base XHR promise wrapper
 * @param  {string} url    
 * @param  {object} params 
 * @return {object}
 */
PB.Net.PBxhr = function(url, options, data) {
    var prom = PB.Net.xhr(url, options, data)
        
    return prom.then(function(response) {
        if(response.FAIL)
            return PB.throwDHTError(response.FAIL)

        if(typeof response == 'string' && response.slice(0,6) == '{"FAIL')
            return PB.throwDHTError((PB.parseJSON(response)||{}).FAIL)

        PB.runHandlers('networkresponse', response)
        
        return response
    })
}

PB.Net.PBpost = function(url, data) {
    //// This is the EveryBit server version of PB.Net.getJSON -- use that function if you're not accessing the EveryBit server
    // THINK: should we parametrize over the dispatch function?
    var options = { headers: {}
                  ,  method: 'POST'
                  }
                  
    return PB.Net.PBxhr(url, options, data)
}

PB.Net.PBgetJSON = function(url, params) {
    //// This is the EveryBit server version of PB.Net.getJSON -- use that function if you're not accessing the EveryBit server
    // THINK: should we parametrize over the dispatch function?
    var options = { headers: { 'Accept': 'application/json' }
                  ,  method: 'GET'
                  ,    type: 'json'
                  }

    var params = params || {}
    var enc = function(param) {return !param && param!==0 ? '' : encodeURIComponent(param)}
    var qstring = Object.keys(params).reduce(function(acc, key) {return acc + enc(key) +'='+ enc(params[key]) +'&'}, '?')

    return PB.Net.PBxhr(url + qstring, options) 
}








/*

    PB.Net Peer-to-Peer layer

    We're currently using peer.js to negotiate the WebRTC connection. There's a lot of work left to be done here.

*/


PB.Net.P2P = {}
PB.Net.P2P.peers = {}

/**
 * initialize the peer-to-peer layer
 */
PB.Net.P2P.init = function() {
    // NOTE: you have to manually enable the P2P layer via config or init options
    // e.g. PB.init({enableP2P: true})
    // or   PB.CONFIG.enableP2P = true
    if(!PB.CONFIG.enableP2P) return false
    
    PB.Net.P2P.Peer = new Peer({ host:  '162.219.162.56'
                               , port:  9000
                               , path:  '/'
                               , debug: 1
                               })
    
    PB.Net.P2P.Peer.on('open', PB.Net.P2P.openPeerConnection)
    PB.Net.P2P.Peer.on('connection', PB.Net.P2P.connection)
}

/**
 * to reload peers
 * @return {object} 
 */
PB.Net.P2P.reloadPeers = function() {
    return PB.Net.P2P.Peer.listAllPeers(PB.Net.P2P.handlePeers)
}

/**
 * open peer connection
 * @param  {string} id 
 * @return {object[]}
 */
PB.Net.P2P.openPeerConnection = function(id) {
    // OPT: do we really need this? 
    // THINK: why not just call PB.Net.P2P.reloadPeers?
    return PB.Net.P2P.Peer.listAllPeers(PB.Net.P2P.handlePeers)
}

/**
 * connection
 * @param connection
 * @returns {*}
 */
PB.Net.P2P.connection = function(connection) {
    PB.Net.P2P.reloadPeers() // OPT: do we really need this? 

    return connection.on('data', function(data) {
        PB.Data.addShellsThenMakeAvailable(data) // TODO: pass a callback in to PB.Net instead of calling this directly
    })
}

/**
 * to handle peers
 * @param  {object} peers 
 * @return {boolean}   
 */
PB.Net.P2P.handlePeers = function(peers) {
    peers.forEach(function(peer) {
        if(PB.Net.P2P.peers[peer]) 
            return false
        PB.Net.P2P.peers[peer] = PB.Net.P2P.Peer.connect(peer)
    })
}

/**
 * to send puff to peers
 * @param  {object} puff
 */
PB.Net.P2P.sendPuffToPeers = function(puff) {
    for(var peer in PB.Net.P2P.peers) {
        PB.Net.P2P.peers[peer].send(puff)
    }
}
/*

    Data management for the EveryBit platform.
    
    All puff-related data flows through here:
    caching, persistence, optimizations and network access are managed through this module.

    Copyright 2014 EveryBit. See README for license information.

 */

PB.Data = {}
// PB.Data.puffs = []
PB.Data.bonii = {}
PB.Data.shells = []
PB.Data.shellSort = {}
// PB.Data.shelf = []
PB.Data.pendingPuffPromises = {}

PB.Data.profiles = {}

PB.Data.init = function(options) {
    // THINK: disabling preloading may affect older EB example code
    // if(!options.disablePublicPuffs)
    //     PB.Data.importShells()                                          // preload relevant shells
    PB.addBeforeSwitchIdentityHandler(PB.Data.removeAllPrivateShells)   // clear private caches
}


///////////////// new graph stuff ////////////////////

PB.Data.addSigAsVertex = function(sig) {
    var matches = PB.Data.graph.v(sig).run()
    
    if(matches.length) return false         // returns false if nothing happens
    
    return PB.Data.graph.addVertex({_id: sig, name: sig, type: 'shell'}) || true
}

PB.Data.addShellAsVertex = function(shell) {
    var matches = PB.Data.graph.v(shell.sig).run()
    
    if(!matches.length)
        return PB.Data.graph.addVertex({ _id: shell.sig, name: shell.sig, shell: shell, type: 'shell' }) || true
    
    var vertex = matches[0]
    if(vertex.shell) return false           // NOTE: returns false if it does nothing
    
    return vertex.shell = shell             // NOTE: mutation & pointer setting
}

PB.Data.addShellUsernameAsVertex = function(shell) {
    //// add shell.username to graph and connect them up
    
    var username = shell.username
    var matches = PB.Data.graph.v(username).run()
    var vertex = matches[0]
    
    if(!vertex)                             // THINK: make usernames unique like USERNAME::<username> or something
        vertex = PB.Data.graph.addVertex({ _id: username, name: username, type: 'username' })
    else
        if(PB.Data.graph.v(shell.sig).out('author').property('name').run()[0] == username)
            return false
        
    // TODO: add easy filtering by vertex type for both 'v' and also outV etc
    PB.Data.graph.addEdge({ _out: shell.sig, _in: shell.username, _label: 'author'})
}

PB.Data.graph = Dagoba.graph()

PB.Data.addToGraph = function(shells) {
    shells.forEach(PB.Data.addShellAsVertex)
    shells.forEach(PB.Data.addShellUsernameAsVertex)
    PB.runHandlers('relationship', shells)
}

// TODO: alias children() as .in('parent') and parents() as .out('parent') and use those instead (halves # of edges)

///////////////// end new graph stuff ////////////////////



PB.Data.getAllMyShells = function() {
    var publicShells = PB.Data.getPublicShells()
    var privateShells = PB.Data.getCurrentDecryptedLetters()
    return publicShells.concat(privateShells)
}


/**
 * get all currently known shells
 * @return {Shell[]}
 */
PB.Data.getShells = function() {
    //// Get all currently known shells
    // NOTE: always use this accessor instead of referencing PB.Data.shells directly, as what this function does will change.
    return PB.Data.shells
}

/**
 * get all public shells
 * @returns {Shell[]}
 */
PB.Data.getPublicShells = function() {
    //// Get all public shells
    var shells = PB.Data.getShells()
    return shells.filter(function(shell) {return !shell.keys})
}

/**
 * Get cached shells by sig
 * @param {string} sig
 * @returns {shell[]}
 */
PB.Data.getCachedShellBySig = function(sig) {
    return PB.Data.shellSort[sig]
    // return PB.Data.getShells().filter(function(shell) { return sig === shell.sig })[0]
}

/**
 * adds bonus
 * @param {object} puff
 * @param {string} key
 * @param {string} value
 */
PB.Data.addBonus = function(puff, key, value) {
    //// this simulates a WeakMap
    // THINK: we'll need to provide some GC here
    var id = puff.sig
    
    if(!PB.Data.bonii[id])
        PB.Data.bonii[id] = {}
    
    PB.Data.bonii[id][key] = value
}

/**
 * gets bonus
 * @param puff
 * @param key
 * @returns {object}
 */
PB.Data.getBonus = function(puff, key) {
    //// pull from our FauxWeakMap
    var id = puff.sig
    var puffBonii = PB.Data.bonii[id]
    return puffBonii && puffBonii[key]
}








PB.Data.addStar = function(sig, username, starsig) {
    // TODO: consider moving this to a module
    
    var fauxshell = {sig: sig} // THINK: can we formalize this?
    var starStats = PB.Data.getBonus(fauxshell, 'starStats') || {score: 0, from: {}}
    
    starStats.from[username] = starsig                                  // admittedly strange, but helpful when unstarring
    starStats.score = PB.Data.scoreStars(Object.keys(starStats.from))  // OPT: O(n^2) in stars-per-puff
    
    PB.Data.addBonus(fauxshell, 'starStats', starStats)
}

PB.Data.removeStar = function(sig, username) {
    // TODO: consider moving this to a module
    
    var fauxshell = {sig: sig} // THINK: ye gads is this ugly
    var starStats = PB.Data.getBonus(fauxshell, 'starStats') || {score: 0, from: {}}
    
    delete starStats.from[username]
    
    starStats.score = PB.Data.scoreStars(Object.keys(starStats.from))  // OPT: O(n^2) in stars-per-puff
    
    PB.Data.addBonus(fauxshell, 'starStats', starStats)
}

PB.Data.scoreStars = function(usernames) {
    
    return 0
    
    // TODO: move this into a module
    /*
    var tluScore = 0;
    var suScore = 0;
    var scorePref = Boron.shallow_copy(puffworldprops.view.score);
    for (var k in scorePref) {
        if (scorePref[k]) {
            var s = parseFloat(scorePref[k]);
            if (isNaN(s))
                s = parseFloat(puffworlddefaults.view.score[k]);
            scorePref[k] = s;
        }
    }
    
    usernames.forEach(function(username) {
        if (username.indexOf('.') == -1) {
            tluScore += scorePref.tluValue;
        } else {
            suScore += scorePref.suValue;
        }
    })
    
    var score = tluScore + Math.min(scorePref.maxSuValue, suScore);
    score = score.toFixed(1);
    if (score == parseInt(score)) score = parseInt(score);
    return score
    */
}








/*
    Some new shell handling equipment. Need to integrate this more deeply and clean and test.
*/

PB.Data.addShellsThenMakeAvailable = function(shells) {
    //// adds shells to the system, then returns a report on its progress
    
    // report.delivered: 10
    // report.valid: 8
    // report.new_shells: 7
    // report.new_puffs: 5
    // report.GC: 0
    
    // report.public: 2
    // report.stars: 0
    
    // report.private_promise: {sigs:[], failed: }
    
    // report.public_puff_sigs: []
    
    function not(fun) {return function(x) {return !fun(x)}}
    
    var report = {counts: {}}
    
    shells = Array.isArray(shells) ? shells : [shells]
    report.counts.delivered = shells.length
    
    shells = shells.filter(PB.isValidShell)
    report.counts.valid = shells.length
    
    report.meta = PB.Data.handleMetaPuffs(shells)
    
    shells = shells.filter(not(PB.Data.isMetaPuff))
    report.counts.nonmeta = shells.length
    
    report.private_promise = PB.Data.handlePrivatePuffs(shells)
    
    shells = shells.filter(not(PB.Data.isPrivatePuff))
    report.counts.public = shells.length
    
    shells = PB.Data.handleAndFilterExistingShells(shells)
    report.counts.new_public = report.counts.public - shells.length
    
    PB.Data.handleNewPublicShells(shells)
    
    shells = PB.Data.handleAndFilterByGC(shells)
    report.counts.gc = report.counts.new_public - shells.length

    report.public_puff_sigs = shells.map(PB.prop('sig'))
    
    PB.runHandlers('newPuffs', shells)
    PB.runHandlers('newPuffReport', report)
    
    return report
}


PB.Data.handleMetaPuffs = function(shells) {
    // TODO: move this to a module
    var metapuffs = shells.filter(PB.Data.isMetaPuff)
    
    metapuffs.forEach(function(shell) {
        var sig = shell.payload.content
        PB.Data.addStar(sig, shell.username, shell.sig)
    })
    
    return {stars: metapuffs.length}
}

PB.Data.isMetaPuff = function(shell) {
    // TODO: move this to a module
    return shell.payload.type == 'star'    
}


PB.Data.handlePrivatePuffs = function(shells) {
    var privatepuffs = shells.filter(PB.Data.isPrivatePuff)    
    return PB.Data.ingestEncryptedShells(privatepuffs) // TODO: this returns our promise report
}


PB.Data.isPrivatePuff = function(shell) {
    return shell.payload.type == 'encryptedpuff'
}


PB.Data.handleAndFilterExistingShells = function(shells) {
    // THINK: this can't answer the question of "did we updated an existing shell with content"?
    return shells.filter(function(shell) {
        var existing = PB.Data.getCachedShellBySig(shell.sig)

        if(!existing) return true                               // it's new
        if(existing.payload.content) return false               // it's known

        if(shell.payload.content === undefined) return false    // it's an empty shell,
        existing.payload.content = shell.payload.content        // so add the missing content
        return true                                             // true because we changed it
    })
}


PB.Data.handleNewPublicShells = function(shells) {
    shells.forEach(function(shell) {
        PB.Data.shells.push(shell)
        PB.Data.shellSort[shell.sig] = shell
    })

    PB.Data.addToGraph(shells)
    PB.Data.rateSomePuffs(shells)
    PB.Data.persistShells()                                     // drop new stuff into localStorage
}


PB.Data.handleAndFilterByGC = function(shells) {
    var compacted = PB.Data.garbageCompactor()                  // OPT: call this earlier
    if(!compacted) return shells
    
    return shells.map(PB.prop('sig'))                            // if GC eats puffs this spits them out
                 .map(PB.Data.getCachedShellBySig)
                 .filter(Boolean)
}


/**
 * to persist shells
 * @param {Shell[]}
 * @returns {(boolean|*)}
 */
PB.Data.persistShells = function(shells) {
    if(PB.CONFIG.noLocalStorage) return false                      // THINK: this is only for debugging and development
    
    // THINK: when we receive shells directly we should compact them too
    if(!shells) 
        shells = function() {return PB.Data.getShellsForLocalStorage()} // thunked for perf
    
    // when you save shells, GC older "uninteresting" shells and just save the latest ones
    // THINK: is this my puff? then save it. otherwise, if the content is >1k strip it down.
    // THINK: we need knowledge of our user records here... how do we get that? 
    // PB.Data.interesting_usernames?
    
    // shells = shells.filter(function(shell) { return !shell.payload.content || (shell.payload.content.length < 1000) })
    
    PB.Persist.save('shells', shells)
}



PB.Data.getConversationPuffs = function(convoId, offset, batchsize) {
    offset = offset || 0
    batchsize = batchsize || PB.CONFIG.pageBatchSize || 10
    
    var prom
    prom = PB.Net.getConversationPuffs(convoId, batchsize, offset)
    prom = prom.then(PB.Data.addShellsThenMakeAvailable)
    return prom
}

PB.Data.getConversationPuffs = PB.promiseMemoize(PB.Data.getConversationPuffs, function(key, report) {
    report.private_promise.then(function() {
        PB.removePromisePending(key)
    })
})


/**
 * to import shells from local and remote sources
 */
PB.Data.importShells = function() {
    //// fetch shells from local and remote sources
    
    // THINK: this should take a set of routes so we can pass them to importRemoteShells
    
    // grab the local shells and add them to the system
    // then grab some remote shells (latest 100) and compare them
    // go back until we fill in the gaps, or hit the threshold (500?)
    
    // when you want to look at shells that don't exist, like when scrolling, grab them as a batch
    
    PB.Data.importLocalShells()
    // PB.Data.getMoreShells()
    PB.Data.importRemoteShells()
    // PB.Data.importAllStars()
}

/**
 * to import local shells
 */
PB.Data.importLocalShells = function() {   // callback) {
    // PB.Data.shells = PB.Persist.get('shells') || []
    var localShells = PB.Persist.get('shells') || []
    
    PB.Data.addShellsThenMakeAvailable(localShells)
}


PB.Data.importAllStars = function() {
    // TODO: consider moving this to a module
    var prom = PB.Net.getStarShells()
    prom.then(PB.Data.addShellsThenMakeAvailable)
}


PB.Data.horridStash = {}

PB.Data.isBadEnvelope = function(sig) {
    return PB.Data.horridStash[sig]
}

PB.Data.addBadEnvelope = function(sig) {
    PB.Data.horridStash[sig] = true
}


PB.Data.currentDecryptedLetters = []
PB.Data.currentDecryptedLetterMap = {}

PB.Data.getCurrentDecryptedLetters = function() {
    //// NOTE: always use this instead of hitting currentDecryptedLetters directly, as this function may change
    return PB.Data.currentDecryptedLetters
}

PB.Data.getDecryptedLetterBySig = function(sig) {
    if(PB.Data.currentDecryptedLetterMap[sig])
        return PB.Data.currentDecryptedLetterMap[sig]
}


PB.Data.addDecryptedLetter = function(letter, envelope) {
    // THINK: how can we avoid doing this 'existing letter' check twice?
    var maybeLetter = PB.Data.getDecryptedLetterBySig(envelope.sig)
    if(maybeLetter) return false
    
    if(letter.payload.type == 'identity') return false             // THINK: where should this live?
    
    PB.Data.currentDecryptedLetters.push(letter)
    
    PB.Data.currentDecryptedLetterMap[envelope.sig] = letter       // letter is a puff too
    PB.Data.currentDecryptedLetterMap[letter.sig] = letter         // stash it both ways
    PB.Data.addBonus(letter, 'envelope', envelope)                 // mark it for later
    
    PB.Data.addToGraph([letter])

    return true
}

PB.Data.removeAllPrivateShells = function() {
    PB.Data.currentDecryptedLetters.forEach(function(shell) {
        PB.Data.removeShellFromCache(shell.sig)
    })
    
    PB.Data.currentDecryptedLetterMap = {}
    PB.Data.currentDecryptedLetters = [] 
}



PB.Data.encryptPuff = function(letter, myPrivateWif, userRecords, privateEnvelopeAlias) {
    //// stick a letter in an envelope. userRecords must be fully instantiated.
    var puffkey = PB.Crypto.getRandomKey()                                        // get a new random key
    
    var letterCipher = PB.Crypto.encryptWithAES(JSON.stringify(letter), puffkey)  // encrypt the letter
    var versionedUsername = letter.username
    
    if(privateEnvelopeAlias) {
        myPrivateWif = privateEnvelopeAlias.default
        versionedUsername = PB.Users.makeVersioned(privateEnvelopeAlias.username, privateEnvelopeAlias.capa)
    }
    
    var envelope = PB.Data.packagePuffStructure(versionedUsername, letter.routes  // envelope is also a puff
                           , 'encryptedpuff', letterCipher, {}, letter.previous)  // it includes the letter
    
    envelope.keys = PB.Crypto.createKeyPairs(puffkey, myPrivateWif, userRecords)  // add decryption keys
    envelope.sig = PB.Crypto.signPuff(envelope, myPrivateWif)                     // sign the envelope
    
    return envelope
}

PB.Data.extractLetterFromEnvelope = function(envelope) {                // the envelope is a puff
    if(PB.Data.isBadEnvelope(envelope.sig)) 
        return Promise.reject('Bad envelope')                           // flagged as invalid envelope

    var maybeLetter = PB.Data.getDecryptedLetterBySig(envelope.sig)     // have we already opened it?
    
    if(maybeLetter)
        return Promise.resolve(maybeLetter)                             // resolve to existing letter
    
    var prom = PB.Data.getDecryptedPuffPromise(envelope)                // do the decryption
    
    return prom.catch(function(err) { return false })
               .then(function(letter) {
                   if(!letter) {
                       PB.Data.addBadEnvelope(envelope.sig)             // decryption failed: flag envelope
                       return PB.throwError('Invalid envelope')         // then bail out
                   }

                   return letter
               })
    
}

PB.Data.getDecryptedPuffPromise = function(envelope) {
    //// pull a letter out of the envelope -- returns a promise!

    if(!envelope || !envelope.keys) 
        return PB.emptyPromise('Envelope does not contain an encrypted letter')
    
    var senderVersionedUsername = envelope.username
    var userProm = PB.Users.getUserRecordPromise(senderVersionedUsername)
    
    var puffprom = userProm
    .catch(PB.catchError('User record acquisition failed'))
    .then(function(senderVersionedUserRecord) {
        var prom // used for leaking secure promise

        PB.useSecureInfo(function(identities, currentUsername) {
            // NOTE: leaks a promise which resolves to unencrypted puff
        
            var identity = identities[currentUsername]
            var aliases  = identity.aliases
            var matchingUsername = ''
                
            top: for(var keykey in envelope.keys) {             // match our aliases against all recipients
                for (var i = 0; i < aliases.length; i++) {
                    var alias = aliases[i]
                    
                    if(alias.username == keykey) {              // only for old, unversioned usernames
                        matchingUsername = alias.username
                        break top
                    }
                    
                    var versionUsername = PB.Users.makeVersioned(alias.username, alias.capa)
                    if(versionUsername == keykey) {
                        matchingUsername = versionUsername
                        break top
                    }
                }
            }

            if(!matchingUsername)
                return PB.throwError('No key found for current user')

            var recipientPrivateKey = alias.privateDefaultKey
            var senderPublicKey = senderVersionedUserRecord.defaultKey
            
            prom = PB.Data.decryptPuffAlmostForReals(envelope, senderPublicKey, matchingUsername, recipientPrivateKey)
        })

        return prom
    })
    
    return puffprom
}

PB.Data.decryptPuffAlmostForReals = function(envelope, senderPublicKey, recipientUsername, recipientPrivateKey) {
    return new Promise(function(resolve, reject) {
        return PB.cryptoworker
             ? PB.workersend( 'decryptPuffForReals'
                            , [ envelope
                              , senderPublicKey
                              , recipientUsername
                              , recipientPrivateKey ]
                            , resolve, reject )
             : resolve( PB.decryptPuffForReals( envelope
                                              , senderPublicKey
                                              , recipientUsername
                                              , recipientPrivateKey ) )
    })
}


PB.Data.packagePuffStructure = function(versionedUsername, routes, type, content, payload, previous) {
    //// pack all the parameters into an object with puff structure (without signature)
    
    payload = payload || {}                     // TODO: check all of these values more carefully
    payload.content = content
    payload.type = type

    routes = routes || []
    previous = previous || false                // false for DHT requests and beginning of blockchain, else valid sig

    var puff = { username: versionedUsername
               ,   routes: routes
               , previous: previous
               ,  version: '0.1.0'              // version accounts for crypto type and puff shape
               ,  payload: payload              // early versions will be aggressively deprecated and unsupported
               }
    
    return puff
}











PB.Data.getMorePrivatePuffs = function(username, offset, batchsize) {
    // THINK: race condition while toggling identities? username isn't used below.
    if(!username) username = PB.getCurrentUsername()
    
    offset = offset || 0
    // offset = offset || PB.CONFIG.initLoadBatchSize || 20
    batchsize = batchsize || PB.CONFIG.pageBatchSize || 10
    
    var prom
    prom = PB.Net.getMyPrivatePuffs(PB.getCurrentUsername(), batchsize, offset) // THINK: why switched param order?
    prom = prom.then(PB.Data.addShellsThenMakeAvailable)
    return prom
}


PB.Data.updatePrivateShells = function(offset) {
    var username = PB.getCurrentUsername()
    var batchsize = 1
    var fullOrShell = 'full' // OPT: just gather the shell (or sig) here when checking latest
    offset = offset || 0     //      actually... we need a list of all sigs we've encountered (not just good ones)
                             //      otherwise bad envelopes (etc) could block prior good content.

    PB.Net.getMyPrivatePuffs(username, batchsize, offset, fullOrShell)
          .then(function(shells) {
              var shell = shells[0]
              if(!shell) return false
              
              var prom = PB.Data.ingestAnEncryptedShell(shell) // manual because we need the decryption promise
              
              prom.then(function(fresh) {
                  if(fresh)
                      PB.Data.updatePrivateShells(1+offset)
              })
          })
}


PB.Data.ingestEncryptedShells = function(shells) {
    var proms = shells.map(PB.Data.ingestAnEncryptedShell)
    
    // NOTE: Promise.all rejects immediately upon any rejection, so we have to do this manually
    
    return new Promise(function(resolve, reject) {
        var remaining = proms.length
        var report = {good: 0, bad: 0, goodsigs: []}
        
        // TODO: add more information about what went wrong to the report
        
        function unhappy_path() {
            report.bad++
            if(!--remaining) resolve(report)
        }
        
        proms.forEach(function(prom) {
            prom.then(function(letter) {
                if(!letter) return unhappy_path()                       // catches old or weird puffs 
                report.good++                                           // TODO: differentiate above cases
                report.goodsigs.push(letter.sig)
                if(!--remaining) resolve(report)
            }, unhappy_path )                                           // catches decryption errors
        })
    })
}


PB.Data.ingestAnEncryptedShell = function(envelope) {
    var prom = PB.Data.extractLetterFromEnvelope(envelope)

    prom = prom.then(function(letter) {
        if(!letter) return false
        
        var fresh = PB.Data.addDecryptedLetter(letter, envelope)        // add the letter to our system
        if(!fresh) return false
        
        PB.runHandlers('newPuffs', [letter])                            // always receives an array of puffs
        return letter
    })
    
    return prom
    
    // NOTE: this doesn't appear to do much, mostly because extractLetterFromEnvelope is quite effectful.
    //       it calls PB.Data.addDecryptedLetter as part of its processing, which does all the real work.
    
    // THINK: consider adding this back in, though remember that each decryption pushes its own errors...
    // if (letters.length != privateShells.length) {
    //     Events.pub('track/decrypt/some-decrypt-fails',
    //                 {letters: letters.map(function(p){return p.sig}),
    //                  privateShells: privateShells.map(function(p){return p.sig})})
    // }
}




// the slot locker contains information on queries made to fill slots. 
// in particular it holds the offset, which will be -1 when [] is returned.
// it keeps queries from re-requesting the same shells over and over, 
// and provides some concurrency / flow control by allowing a query
// to set it to -1 when it is running and then replace it when done.
PB.Data.slotLocker = {}

// THINK: we're calling this from the 'refresh' button now...


PB.Data.importRemoteShells = function() {
    //// only called during initial application bootup. handles both cold loads and hot loads.
    
    var offset = 0
    var giveup = PB.CONFIG.initLoadGiveup
    var limit  = PB.CONFIG.initLoadBatchSize
    var new_shells = []
    var keep_going = true
    
    var key = '[{"sort":"DESC"},{"tags":[],"types":[],"users":[],"routes":[]}]' // TODO: upgrade this default query
    PB.Data.slotLocker[key] = -1
    
    // TODO: index by username
    // TODO: if duplicate check update times for latest
    // TODO: persist to LS (maybe only sometimes? onunload? probabilistic?)
         
    function getMeSomeShells(puffs) {
        if(puffs) {
            var delta = PB.Data.addShellsThenMakeAvailable(puffs)
            // new_shells = new_shells.concat(my_new_shells)
            // var delta = my_new_shells.length
            
            if(delta != limit) // some shells were already in our cache
                keep_going = false
        }
        
        if(offset > giveup)
            keep_going = false

        if(!keep_going) {
            PB.Data.slotLocker[key] = 1
            // PB.Data.stupidHorribleGlobalThing = true
            // PB.Data.makeShellsAvailable(new_shells)
            return false
        }
        
        var prom = PB.Net.getSomeShells({}, {}, limit, offset)
        prom.then(getMeSomeShells)

        offset += limit
    }
    
    getMeSomeShells()
}


/**
 * to fill some slots
 * @param {number} need
 * @param {number} have
 * @param {string} query
 * @param {string} filters
 * @returns {boolean}
 */
PB.Data.fillSomeSlotsPlease = function(need, have, query, filters) {
    //// we have empty slots on screen. fill them with puffs.
    
    if(have >= need) return false
    
    // -- redraw screen on new puffs being ingested (w/o looping)
    // -- cycle all new puffs through graph stuff
    // -- call fillSomeSlotsPlease every time we have slots to fill
    // -- get focused puff immediately
    
    // - perform GC on in-memory puffs (can remove content also)
    // - use GC funs for persisting shells
    // - store size of each shell/puff for GC
    // - manage empty vertices better (different type?)

    var args = [query, filters]
    // var args = [query, filters, need]
    // if(!query.mode) args.push(have) // hack for alternate query modes

    var key = JSON.stringify(args)
    var my_offset = PB.Data.slotLocker[key] || 0
    
    if(my_offset < 0)
        return false // slot is locked, go elsewhere
    
    PB.Data.slotLocker[key] = -1 // prevent concurrent versions of the same request
    
    //////

    // var limit = need - have + 3 // 3 for luck
    
    var limit = need // so... if we only do this once, and we have half the puffs already, we might only grab that half again. this is true even if we send an offset of 'have' to the server, because what we have might map to that slice (or to anything else -- our offsets are totally different than the servers). so we have to grab enough to cover the difference, which means grabbing the same shells multiple times... (but only empty shells, fortunately. but still.)
    
    // var received_shells = 0
    
    var prom = PB.Net.getSomeShells(query, filters, limit, query.offset)
    // prom.then(function(shells) {received_shells = shells.length; return shells})
    prom.then(PB.Data.addShellsThenMakeAvailable)
        .then(function(delta) { 
            PB.Data.slotLocker[key] = delta ? 1 : -1}) 
            // if the request is fruitful, unlock it (but be careful of offsets here).
            // also, this locks when we received data but chose not to keep it (either dups or GC),
            // so we could have an issue with locked queries that would be fruitful w/ different offset / limits...
    
    
    // TODO: the slotLocker really should keep track of what 'slices' of the server you've seen, so we know not to re-request those over and over. this is... complicated. 
    //       so send query.offset+have to getSomeShells, and store that same offset as part of the slotLocker.
    //       then you can track how much of some type of stuff is on the server... except that doesn't work for the P2P network.
    
    return true
    
    //////


    // OLD STUFF SAVE FOR REFERENCE

    // var batchSize = PB.CONFIG.fillSlotsBatchSize
    // var giveup = PB.CONFIG.fillSlotsGiveup
    // var new_shells = []
    //
    // giveup = giveup + my_offset
    //
    // function getMeSomeShells(puffs) {
    //     if(puffs) {
    //         var my_new_shells = PB.Data.hereHaveSomeNewShells(puffs)
    //         new_shells = new_shells.concat(my_new_shells)
    //         var delta = my_new_shells.length
    //         // THINK: but do they pass the filter?
    //         // TODO: can we make available here now that we're locking?
    //         have += delta || 0
    //     }
    //
    //     if(have >= need || my_offset > giveup || (query.mode && (my_offset - giveup < 0))) {
    //         PB.Data.makeShellsAvailable(new_shells)
    //         PB.Data.slotLocker[key] = my_offset-limit
    //         return false
    //     }
    //
    //     var limit = need - have
    //     // if(!query.mode) limit += 50 // grab a few extras to help work through bare patches
    //
    //     var prom = PB.Net.getSomeShells(query, filters, limit, my_offset)
    //     prom.then(getMeSomeShells)
    //
    //     my_offset += limit
    // }
    //
    // getMeSomeShells()
}


/*
    End shell collection intake equipment
*/


/**
 * returns a puff from a shell
 * @param  {(string|object)} shell 
 * @return {object} returns a puff based on the shell; returns false if the shell is empty
 */
PB.Data.getPuffFromShell = function(shell) {
    if(!shell)
        return false // so we can filter empty shells out easily, while still loading them on demand
    
    if(shell.payload && shell.payload.content !== undefined)
        return shell // it's actually a full blown puff
    
    return PB.Data.getPuffBySig(shell.sig) // returns a puff, or asks the network and returns false
}

/**
 * to get puff by its sig
 * @param {string} sig
 * @returns {(object|false)}
 */
PB.Data.getPuffBySig = function(sig) {
    var shell = PB.Data.getCachedShellBySig(sig) // OPT: this happens twice almost always
    
    if(shell && shell.payload && typeof shell.payload.content != 'undefined')
        return shell
    
    if(PB.Data.pendingPuffPromises[sig])
        return false
        
    // locally cached shells that are missing content on the network prevent slotfills from resolving,
    // so we clear it from our cache if we can't find it.
    function badShellClearCache(shells) {
        if(!shells.length) {
            var fauxshell = {sig: sig}
            if(!PB.Data.getBonus(fauxshell, 'envelope')) {
                PB.Data.removeShellFromCache(sig)
                return PB.onError("Content can not be found for shell '" + sig + "'") // THINK: why was this throwError?
                // THINK: unlock PB.Data.pendingPuffPromises[sig]? probably not, but it might re-appear later...
            }
        }
        return shells
    }
    
    PB.Data.pendingPuffPromises[sig] = PB.Net.getPuffBySig(sig)      // TODO: drop this down in to PB.Net instead
    PB.Data.pendingPuffPromises[sig].then(badShellClearCache)
                        .then(PB.Data.addShellsThenMakeAvailable)
                        .then(function() {                           // delay GC to stop runaway network requests
                            setTimeout(function() { delete PB.Data.pendingPuffPromises[sig] }, 10000) })
    
    return false
}

PB.Data.removeShellFromCache = function(sig) {
    // remove from PB.Data.shells
    var shell = PB.Data.getCachedShellBySig(sig)
    PB.Data.shells.splice( PB.Data.shells.indexOf(shell), 1 )
    
    // remove from PB.Data.shellSort
    delete PB.Data.shellSort[sig]
    
    // remove shell's bonii
    delete PB.Data.bonii[sig]
    
    PB.Data.purgeShellFromGraph(sig)
    
    PB.Data.removeCachedPuffScore(shell)
}

PB.Data.purgeShellFromGraph = function(sig) {
    // change graph vertex to 'pseudo-shell' type (or 'purged' type?)
    //   and remove the content of the 'shell' property
    // TODO: this is icky make it better
    var vertex = PB.Data.graph.v(sig).run()[0]
    if(vertex) {
        vertex.type = 'purged'
        vertex.shell = undefined
    }
}


/**
 * to get my puff chain
 * @param  {string} username 
 * @return {object}
 */
PB.Data.getMyPuffChain = function(username) {
    // CURRENTLY UNUSED
    // TODO: this should grab my puffs from a file or localStorage or wherever my identity's puffs get stored
    // TODO: that collection should be updated automatically with new puffs created through other devices
    // TODO: the puffchain should also be sorted in chain order, not general collection order
    
    var shells = PB.Data.getShells()
    
    return shells.filter(function(puff) { return puff && puff.username == username }) // TODO: use the graph
    // return PB.M.Forum.getByUser(username) // TODO: test this 
}



///////////////////////////////////////////
//                                       //
//       Garbage Collector Thing         //
//                                       //
///////////////////////////////////////////



PB.Data.runningSizeTally = 0
PB.Data.scoreSort = {}

PB.Data.heuristics = []
PB.Data.addHeuristics = function(fun) {
    PB.Data.heuristics.push(fun)
}

PB.Data.addHeuristics(function(shell) {
    return parseFloat( (PB.Data.getBonus(shell, 'starStats') || {}).score || 0 ) * 100
})

// TODO: add heuristics for: my puffs (which go elsewhere, ultimately), replies to my puffs, my puff's parents, 
//       friend's puffs (whatever that means), puff freshness, last seen, etc


PB.Data.rateMyPuff = function(puff) {
    var scores = PB.Data.heuristics.map(function(h) {return h(puff)})           // apply heuristics
    var total  = scores.reduce(function(acc, score) {return acc+(score||0)}, 0) // get total // TODO: improve algo
    return total
}

PB.Data.rateSomePuffs = function(puffs) {
    puffs.forEach(function(puff) {                                              // rate each puff
        var score = PB.Data.rateMyPuff(puff)
        PB.Data.doStuffWithScore(puff, score)
        PB.Data.doStuffWithPuff (puff)
    })
    // THINK: some heuristics rely on scores of related puffs... possible feedback loop? topological ordering?
    //        a toposort is easy-ish w/ graph db...
}

// TODO: when you switch identities, rescore the puffs


PB.Data.doStuffWithScore = function(puff, score) {
    PB.Data.removeCachedPuffScore(puff)                                         // NOTE: has to come before bonii
    PB.Data.addBonus(puff, 'rating', score)                                     // add rating to bonii
    PB.Data.cachePuffScore(puff, score)    
    // OPT: cache sorted version
    // maybe bins[score.floor].push(puff) or something...
}

PB.Data.doStuffWithPuff = function(puff) {
    var puffsize = JSON.stringify(puff).length
    PB.Data.addBonus(puff, 'size', puffsize)
    PB.Data.runningSizeTally += puffsize || 0                                  // block NaNs
}

PB.Data.cachePuffScore = function(puff, score) {
    var key = PB.Data.convertScoreToKey(score)
    PB.Data.scoreSort[key] = PB.Data.scoreSort[key] || []
    PB.Data.scoreSort[key].push(puff)
}

PB.Data.removeCachedPuffScore = function(puff) {
    if(!puff) return false
    
    var score = PB.Data.getBonus(puff, 'score')
    var key = PB.Data.convertScoreToKey(score)
    var bin = PB.Data.scoreSort[key]
    if(!bin) return false
    if(!bin.length) return false
    
    for(var i = bin.length - 1; i >= 0; i--) {
        if(bin[i].sig == puff.sig) {
            bin.splice(i, 1)
            var puffsize = PB.Data.getBonus(puff, 'size')
            PB.Data.runningSizeTally -= puffsize || 0                          // block NaNs
            return false
        }
    }
}

PB.Data.getCachedPuffs = function(limit, bottom) {
    var seen = 0
    var result = []
    var keys = Object.keys(PB.Data.scoreSort).map(parseFloat).sort()
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i]
        var puffs = PB.Data.scoreSort[key] // OPT: short-circuit on !bottom
        
        puffs.reduce(function(seen, puff) {
            if(seen > limit == !!bottom) result.push(puff)
            return seen+1
        }, 0)
    }
    
    return result
}

PB.Data.convertScoreToKey = function(score) {
    return Math.floor(score / 10) || 0 // TODO: make this smarter
}


PB.Data.getTopPuffs = function(limit) {
    return PB.Data.getCachedPuffs(limit)
}

PB.Data.getNotTopPuffs = function(limit) {
    // grab the puffs below the limit threshold (w/ 300 puffs and limit=100 this returns the 200 worst puffs)
    return PB.Data.getCachedPuffs(limit, 'bottom')
}

// PB.Data.getTopPuffs = function(options) {
//     var numberLimit =  options.number || 0
//     var sizeLimit   =    options.size || 0
//     var compact     = options.compact || false  // whether to allow compaction of returned puffs
//     var reverse     = options.reverse || false  // return bottom puffs instead of top puffs
// }

PB.Data.garbageCompactor = function() {
    // are we over the limits?
    var limit     = PB.CONFIG.inMemoryShellLimit
    var memlimit  = PB.CONFIG.inMemoryMemoryLimit
    var sizelimit = PB.CONFIG.shellContentThreshold
    var didStuff  = false

    if(PB.Data.shells.length > limit) {
        didStuff = true
        PB.Data.shells.slice(limit).map(PB.prop('sig')).forEach(PB.Data.removeShellFromCache)
    }
    
    if(PB.Data.runningSizeTally > memlimit) {
        didStuff = true
        for (var i = PB.Data.shells.length - 1; i >= 0; i--) {
            var shell = PB.Data.shells[i]
            var content_size = (shell.payload.content||"").toString().length // THINK: non-flat content borks this
            if (content_size > sizelimit) {
                delete shell.payload.content // THINK: this is hardcore
                total -= content_size + 13 // NOTE: magic number == '"content":"",'.length
                if(total <= memlimit) break
            }
        }
    }
    
    return didStuff
}


PB.Data.getShellsForLocalStorage = function() {
    var limit     = PB.CONFIG.localStorageShellLimit
    var memlimit  = PB.CONFIG.localStorageMemoryLimit
    var sizelimit = PB.CONFIG.shellContentThreshold
    
    var shells = PB.Data.getTopPuffs(limit)
    var total = shells.reduce(function(size, shell) {
        return size + (PB.Data.getBonus(shell, 'size') || 0)
    }, 0)
    
    if (total <= memlimit) return shells
    
    // compact the puffs
    for (var i = shells.length - 1; i >= 0; i--) {
        var shell = shells[i]
        var content_size = (shell.payload.content||"").toString().length // THINK: non-flat content borks this
        if (content_size > sizelimit) {
            var new_shell = PB.Data.compactPuff(shell)
            shells[i] = new_shell
            total -= content_size + 13 // NOTE: magic number == '"content":"",'.length
            if(total <= memlimit) break
        }
    }
    
    if (total <= memlimit) return shells
    
    // remove shells until under memlimit
    for (var i = shells.length - 1; i >= 0; i--) {
        var content_size = JSON.stringify(shell).length
        total -= content_size
        if(total <= memlimit) break
    }
    
    shells = shells.slice(0, Math.max(i, 1)) // prevent -1 
    
    return shells
}


PB.Data.compactPuff = function(puff) {
    // THINK: instead of rebuilding the puff, use a JSON.stringify reducer that strips out the content
    var new_shell = Boron.extend(puff)
    var new_payload = {}
    for(var prop in puff.payload)
        if(prop != 'content')
            new_payload[prop] = puff.payload[prop] 

    new_shell.payload = new_payload
    return new_shell
}

/*

    User management for the EveryBit platform.

    Most functions related to userRecords live here.
    Note that userRecords are entirely public;
    private key identities are handled elsewhere.

    Copyright 2014 EveryBit. See README for license information.

 */

PB.Users = {}

PB.Users.records  = {}                              // maps versioned username to an array of DHT userRecords
PB.Users.promises = {}                              // pending userRecord requests


PB.Users.init = function(options) {
    PB.Users.depersist()                            // pop userRecords out of localStorage
}


PB.Users.process = function(userRecord) {
    //// Processes all incoming userRecords
    
    userRecord = PB.Users.build( userRecord.username, userRecord.defaultKey, userRecord.adminKey
                               , userRecord.rootKey,  userRecord.latest,     userRecord.created
                               , userRecord.updated,  userRecord.profile,    userRecord.identity
                               , userRecord.capa )
    
    if(!userRecord)
        return PB.onError('That is not an acceptable user record', userRecord)
    
    PB.Users.cache(userRecord)
    
    return userRecord
}


PB.Users.getCachedUserRecord = function(username) {
    if(PB.Users.makeVersioned(username) == username)    // username is versioned
        return PB.Users.records[username]
    
    return PB.Users.findFreshest(username)              // username isn't versioned
}


/**
 * Checks the cache, and always returns a promise
 * @param {string} username
 * @param {int} capa is the version of the username keys
 * @returns {object} Promise for a user record
 * Looks first in the cache, then grabs from the network
 */
PB.Users.getUserRecordPromise = function(username, capa) {
    //// This always checks the cache, and always returns a promise
    
    var versionedUsername = PB.Users.makeVersioned(username, capa)
    
    var userRecord = PB.Users.getCachedUserRecord(versionedUsername)
    
    if(userRecord)
        return Promise.resolve(userRecord)
    
    var userPromise = PB.Users.promises[versionedUsername]
    
    if(userPromise)
        return userPromise
    
    return PB.Users.getUserRecordNoCache(versionedUsername)
}


/**
 * Forces a request to the network, ignores cached
 * @param {string} username
 * @param {int} capa is the version of the username keys
 * @returns {object} Promise for a user record
 */
PB.Users.getUserRecordNoCache = function(username, capa) {
    //// This never checks the cache
    
    capa = capa || 0 // 0 signals PB.Net.getUserRecord to get the latest userRecord
    
    var prom = PB.Net.getUserRecord(username, capa) 
    
    prom = prom.then(
                function(userRecord) {
                    var userRecord = PB.Users.process(userRecord)
                    if(!userRecord)  PB.throwError('Invalid user record returned')
                    return userRecord
                }
                , PB.catchError('Unable to access user information from the DHT'))
    
    var versionedUsername = PB.Users.makeVersioned(username, capa)
    PB.Users.promises[versionedUsername] = prom
    
    return prom
}

PB.Users.doesUserExist = function(username) {
    return PB.Net.getUserRecord(username).then(
                function(userRecord) {
                    if(!userRecord || userRecord.FAIL) 
                        throw 'User does not exist'
                    return true
                }
                , PB.catchError('Unable to access user information from the DHT'))
}


//
// USERNAME HELPERS
//

PB.Users.userRecordToVersionedUsername = function(userRecord) {
    return PB.Users.makeVersioned(userRecord.username, userRecord.capa)
}

PB.Users.justUsername = function(versionedUsername) {
    var uc = PB.Users.breakVersionedUsername(versionedUsername)
    return uc.username
}

PB.Users.justCapa = function(versionedUsername) {
    var uc = PB.Users.breakVersionedUsername(versionedUsername)
    return uc.capa
}

PB.Users.makeVersioned = function(username, capa) {
    if(!username || !username.indexOf)
        return ''
    
    if(capa)
        return actuallyVersionThisUsernameOkay(username, capa)
    
    if(username.indexOf(':') > 0)
        return username
    
    return actuallyVersionThisUsernameOkay(username)
    
    function actuallyVersionThisUsernameOkay(username, capa) {
        capa = capa || 1 // NOTE: default capa
        return username + ':' + capa
    }
}

PB.Users.breakVersionedUsername = function(versionedUsername) {
    var list = (versionedUsername||'').split(':')

    return { username: list[0]
           , capa:     list[1] || 1 // NOTE: default capa
           }
}


//
// GENERAL HELPERS
//


PB.Users.build = function(username, defaultKey, adminKey, rootKey, latest, created, updated, profile, identity, capa) {
    //// returns a canonical user object: use this everywhere user objects are needed (DHT, identities, etc)

    latest   = latest   || ""                       // signature of the most recent puff published by the user
    updated  = updated  || ""                       // date of the most recent update to the username
    profile  = profile  || ""                       // profile puff signature
    identity = identity || ""                       // identity puff signature
    capa     = capa     || 1                        // version of the username
    
    // THINK: should we check for valid keys? valid timestamp for updated? what if you want a partially invalid user like anon?
    
    // THINK: split username and capa if it's a versionedUsername?

    if(!PB.validateUsername(username))
        return false                                // error is logged inside PB.validateUsername
    
    return {   username: username                   // unversioned username
           ,       capa: capa
           ,    rootKey: rootKey                    // public root key
           ,   adminKey: adminKey                   // public admin key
           , defaultKey: defaultKey                 // public default key
           ,    created: created                    // Date the record was created
           ,     latest: latest
           ,    updated: updated
           ,    profile: profile
           ,   identity: identity
           }
}


PB.Users.usernamesToUserRecordsPromise = function(usernames) {
    //// returns a promise of userRecords. thanks to capa we usually don't need the latest and can use cached versions.
    if(!usernames || !usernames.length)
        return Promise.resolve([])
    
    if(!Array.isArray(usernames))
        usernames = [usernames]
        
    var userRecords = usernames.map(PB.Users.getCachedUserRecord).filter(Boolean)
    
    if (userRecords.length == usernames.length)
        return Promise.resolve(userRecords) // got 'em all!
    
    var prom = Promise.resolve() // a promise we use to string everything along

    var userRecordUsernames = userRecords.map(function (userRecord) {
        return userRecord.username
    })
    
    usernames.forEach(function (username) {
        if (!~userRecordUsernames.indexOf(username)) { // we need this one
            prom = prom.then(function() {
                return PB.Users.getUserRecordNoCache(username).then(function (userRecord) {
                    userRecords.push(userRecord)
                })
            })
        }
    })
    
    return prom.then(function() { return userRecords }) // when it's all done, give back the userRecords
}

PB.Users.cache = function(userRecord) {
    //// This caches with no validation: use PB.Users.process instead
    
    var versionedUsername = PB.Users.userRecordToVersionedUsername(userRecord)
    
    PB.Users.records[versionedUsername] = userRecord
    
    delete PB.Users.promises[versionedUsername]
    
    PB.Persist.save('userRecords', PB.Users.records)
    
    return userRecord
}

PB.Users.depersist = function() {
    //// grab userRecords from local storage. this smashes the current userRecords in memory, so don't call it after init!
    PB.Users.records = PB.Persist.get('userRecords') || {}
}


PB.Users.findFreshest = function(username) {
    username = PB.Users.justUsername(username)
    
    var keys = Object.keys(PB.Users.records)
    var capa = 0
    
    keys.filter(function(versionedUsername) {
        return PB.Users.justUsername(versionedUsername) == username
    }).forEach( function(versionedUsername) {
        var this_capa = +PB.Users.justCapa(versionedUsername)
        if(this_capa > capa)
            capa = this_capa
    })
    
    var versionedUsername = PB.Users.makeVersioned(username, capa)
    return PB.Users.records[versionedUsername]
}


PB.Users.getIdentityPuff = function(userRecord, privateKey) {
    //// userRecord is the user's canonical user record
    //// privateKey is the user's private default key
    
    if(!userRecord || !userRecord.defaultKey || !userRecord.username)
        return PB.emptyPromise('Invalid user record')
    
    if(!userRecord.identity)
        return PB.emptyPromise('User record has no identity')
    
    puffprom = PB.Net.getPuffBySig(userRecord.identity)

    return puffprom.then(function(puffs) {
        var envelope = puffs[0]
        if(!envelope || !envelope.sig)
            return PB.throwError('Invalid identity puff')
        
        var senderPublicKey = userRecord.defaultKey
        var recipientUsername = PB.Users.makeVersioned(userRecord.username, userRecord.capa)
        var recipientPrivateKey = privateKey

        return PB.Data.decryptPuffAlmostForReals(envelope, senderPublicKey, recipientUsername, recipientPrivateKey)
    })        
}




//
// CLEANUP REQUIRED
//


/**
 * Get the current user's DHT record, or create a new anon user, or die trying
 * @return {string}
 */
PB.Users.getUpToDateUserAtAnyCost = function() {
    //// Either get the current user's DHT record, or create a new anon user, or die trying

    var username = PB.getCurrentUsername()

    if(username)
        return PB.Users.getUserRecordNoCache(username, 0) // 0 tells PB.Net.getUserRecord to fetch the latest
    
    var prom = PB.Users.addNewAnonUser()
    
    return prom.then(function(userRecord) {
        PB.switchIdentityTo(userRecord.username)
        console.log("Setting current user to " + userRecord.username)
        return userRecord
    })
}


/**
 * Generate a random username
 * @return {string}
 */
PB.Users.generateRandomUsername = function(len) {

    // Set a default value for length
    if(!len || len != Math.round(len))
        len=10

    var generatedName = ''
    var alphabet = 'abcdefghijklmnopqrstuvwxyz0123456789'
    for(var i=0; i<10; i++) {
        generatedName += PB.Crypto.getRandomItem(alphabet)
    }
    return generatedName
}

/**
 *
 * Register a new anonymous user
 * @param {string} passphrase optional if included then used
 * @param {string} attachToUsername
 * @returns {Promise} a promise that resolves to the user record or fails
 */
PB.Users.addNewAnonUser = function(passphrase, attachToUsername) {
    //// create a new anonymous alias. if attachToUsername is provided it becomes an alias for that identity.
    //// if attachToUsername is false the alias becomes primary for its own identity.
    // TODO: make attachToUsername work
    // THINK: Don't want to switch to this user, but what about alias issue and saving bonus info?
    // TODO: Split this into two functions, one that registers an anon user based on given info
    // another that registers anon user AND switches current to that user. Or flag in function to switch to that user.

    var newUsername = 'anon.' + PB.Users.generateRandomUsername(12)

    if(typeof passphrase !== undefined && passphrase) {
        var prependedPassphrase = newUsername + passphrase
        var privateKey = PB.Crypto.passphraseToPrivateKeyWif(prependedPassphrase)
    } else {
        var privateKey = PB.Crypto.generatePrivateKey()
    }

    // Set private keys
    var privateRootKey =    privateKey
    var privateAdminKey =   privateKey
    var privateDefaultKey = privateKey

    // Generate public keys
    var rootKey    = PB.Crypto.privateToPublic(privateKey)
    var adminKey   = PB.Crypto.privateToPublic(privateKey)
    var defaultKey = PB.Crypto.privateToPublic(privateKey)

    // build our DHT update puff
    var payload = {
        requestedUsername: newUsername,
        defaultKey: defaultKey,
        adminKey: adminKey,
        rootKey: rootKey,
        time: Date.now()
    }

    var routing = [] // THINK: DHT?
    var content = 'requestUsername'
    var type    = 'updateUserRecord'

    var puff = PB.buildPuff('anon', PB.CONFIG.anonPrivateAdminKey, routing, type, content, payload)

    return PB.Net.updateUserRecord(puff)

}

PB.Users.createAnonUserAndMakeCurrent = function() {
    var newUsername = 'anon.' + PB.Users.generateRandomUsername(12)
    var passphrase = PB.Crypto.generatePrivateKey().slice(-12)
    var prependedPassphrase = newUsername + passphrase
    var privateKey = PB.Crypto.passphraseToPrivateKeyWif(prependedPassphrase)
    var publicKey = PB.Crypto.privateToPublic(privateKey)

    // Build puff to register this user
    var payload = {
        requestedUsername: newUsername,
        defaultKey: publicKey,
        adminKey: publicKey,
        rootKey: publicKey,
        time: Date.now()
    }

    var routing = [] // THINK: DHT?
    var content = 'requestUsername'
    var type    = 'updateUserRecord'

    var puff = PB.buildPuff('anon', PB.CONFIG.anonPrivateAdminKey, routing, type, content, payload)

    var prom = PB.Net.updateUserRecord(puff)

    // Works?
    return prom.then(function(userRecord) {
        // Switch to this user
        PB.addAlias(userRecord.username, userRecord.username, 1, privateKey, privateKey, privateKey, {passphrase: passphrase})

        PB.switchIdentityTo(userRecord.username)

        return userRecord
    })
}


/*
    Cryptographic management for the EveryBit platform.

    Contains various functions that rely on bitcoin-lib.js for their cryptographic functionality,
    an ECDH implementation, a random number shim for older browsers, and random helper functions.

    Copyright 2014 EveryBit. See README for license information.

*/

PB.Crypto = {};

/**
 * Generate private key
 * @return {string} 
 */
PB.Crypto.generatePrivateKey = function() {
    // OPT: remove this test once Bitcoin.ECKey no longer generates invalid keys (about 1 in 1,000 right now)
    var prikey = new Bitcoin.ECKey().toWif()
    if(PB.Crypto.wifToPriKey(prikey))
        return prikey
    else
        return PB.Crypto.generatePrivateKey()  // THINK: this could generate an eternal error explosion
}


/**
 * Convert public key from private key
 * @param  {string} privateKeyWIF
 * @return {string}
 */
PB.Crypto.privateToPublic = function(privateKeyWIF) {
    // TODO: This should return false if string is empty
    if(!privateKeyWIF)
        return PB.onError('That private key contained no data')
        
    try {
        return PB.Crypto.wifToPriKey(privateKeyWIF).getPub(true).toWif()
    } catch(err) {
        return PB.onError('Invalid private key: could not convert to public key', [privateKeyWIF, err])
    }
}


/**
 * Sign the hash of some data with a private key and return the sig in base 58
 * @param  {object} unsignedPuff
 * @param  {string} privateKeyWIF
 * @return {(boolean|error)}
 */
PB.Crypto.signPuff = function(unsignedPuff, privateKeyWIF) {
    //// sign the hash of some data with a private key and return the sig in base 58

    var prikey = PB.Crypto.wifToPriKey(privateKeyWIF)
    var message = PB.Crypto.puffToSiglessString(unsignedPuff)
    var messageHash = PB.Crypto.createMessageHash(message)
    
    try {
        return Bitcoin.base58.encode(prikey.sign(messageHash))
    } catch(err) {
        return PB.onError('Could not properly encode signature', [prikey, messageHash, err])
    }
}


/**
 * to verify puff sig
 * @param  {object} puff
 * @param  {string} defaultKey
 * @return {boolean}
 */
PB.Crypto.verifyPuffSig = function(puff, defaultKey) {
    var puffString = PB.Crypto.puffToSiglessString(puff);
    return PB.Crypto.verifyMessage(puffString, puff.sig, defaultKey);
}

/**
 * accept a base 58 sig, a message (must be a string) and a base 58 public key. returns true if they match, false otherwise
 * @param  {string} message
 * @param  {string} sig
 * @param  {string} publicKeyWIF
 * @return {boolean}
 */
PB.Crypto.verifyMessage = function(message, sig, publicKeyWIF) {
    //// accept a base 58 sig, a message (must be a string) and a base 58 public key. returns true if they match, false otherwise
  
    try {
        var pubkey = PB.Crypto.wifToPubKey(publicKeyWIF)
        
        var sigBytes = Bitcoin.base58.decode(sig).toJSON()
        sigBytes = sigBytes.data || sigBytes
        
        var messageHash = PB.Crypto.createMessageHash(message)
        
        return pubkey.verify(messageHash, sigBytes)
    } catch(err) {
        return PB.onError('Invalid key or sig: could not verify message', [messageHash, sig, publicKeyWIF, err])
    }
}

/**
 * to create message hash
 * @param  {string} message
 * @return {string}
 */
PB.Crypto.createMessageHash = function(message) {
    return Bitcoin.Crypto.SHA256(message).toString()
}

/**
 * crypt wif to private key
 * @param  {string} privateKeyWIF
 * @return {boolean}
 */
PB.Crypto.wifToPriKey = function(privateKeyWIF) {
    if(!privateKeyWIF)
        return PB.onError('That private key wif contains no data')

    try {
        return new Bitcoin.ECKey(privateKeyWIF, true)
    } catch(err) {
        return PB.onError('Invalid private key: are you sure it is properly WIFfed?', [privateKeyWIF, err])
    }
}

/**
 * crypt wif to public try
 * @param  {string} publicKeyWIF
 * @return {boolean}
 */
PB.Crypto.wifToPubKey = function(publicKeyWIF) {
    if(!publicKeyWIF)
        return PB.onError('That public key wif contains no data')

    try {
        var pubkeyBytes = Bitcoin.base58check.decode(publicKeyWIF).payload.toJSON()
        pubkeyBytes = pubkeyBytes.data || pubkeyBytes
        return new Bitcoin.ECPubKey(pubkeyBytes, true)
    } catch(err) {
        return PB.onError('Invalid public key: are you sure it is properly WIFfed?', [publicKeyWIF, err])
    }
}

/**
 * crypt puff to string without sig
 * @param  {object} puff
 * @return {string}
 */
PB.Crypto.puffToSiglessString = function(puff) {
    return JSON.stringify(puff, function(key, value) {if(key == 'sig') return undefined; return value})
}


PB.Crypto.passphraseToPrivateKeyWif = function(passphrase) {
    var hashStr = Bitcoin.Crypto.SHA256(passphrase).toString()
    var hash = Bitcoin.convert.hexToBytes(hashStr)
    return Bitcoin.ECKey(hash).toWif()
}


/**
 * to encrypt with AES
 * @param  {string} message
 * @param  {string} key
 * @return {string}
 */
PB.Crypto.encryptWithAES = function(message, key) {
    var enc = Bitcoin.Crypto.AES.encrypt(message, key)
    return Bitcoin.Crypto.format.OpenSSL.stringify(enc)
}

/**
 * to decrypt with AES
 * @param  {string} message
 * @param  {string} key
 * @return {string}
 */
PB.Crypto.decryptWithAES = function(enc, key) {
    if(!key || !enc) return false
    var message = Bitcoin.Crypto.format.OpenSSL.parse(enc)
    var words = Bitcoin.Crypto.AES.decrypt(message, key)
    var bytes = Bitcoin.convert.wordsToBytes(words.words) 
    // var uglyRegex = /[\u0002\u0004\u0007\u000e]+$/g
    var uglyRegex = /[\u0000-\u0010]+$/g // TODO: contain AES padding
    return bytes.map(function(x) {return String.fromCharCode(x)}).join('').replace(uglyRegex, '')
}

/**
 * Get the shared secret of two users
 * @param  {string} yourPublicWif
 * @param  {string} myPrivateWif
 * @return {string}
 */
PB.Crypto.getOurSharedSecret = function(yourPublicWif, myPrivateWif) {
    // TODO: unit testing for ECDH maths
    var pubkey = PB.Crypto.wifToPubKey(yourPublicWif)
    var prikey = PB.Crypto.wifToPriKey(myPrivateWif)
    if(!pubkey || !prikey) return false  
    var secret = pubkey.multiply(prikey).toWif()
    var key = Bitcoin.Crypto.SHA256(secret).toString()
    
    return key
}

/**
 * Encode private message
 * @param  {string} plaintext
 * @param  {string} yourPublicWif
 * @param  {string} myPrivateWif
 * @return {string}
 */
PB.Crypto.encryptPrivateMessage = function(plaintext, yourPublicWif, myPrivateWif) {
    var key = PB.Crypto.getOurSharedSecret(yourPublicWif, myPrivateWif)
    if(!key) return false
    var ciphertext = PB.Crypto.encryptWithAES(plaintext, key)
    return ciphertext
}

/**
 * to decode private message
 * @param  {string} plaintext
 * @param  {string} yourPublicWif
 * @param  {string} myPrivateWif
 * @return {string}
 */
PB.Crypto.decryptPrivateMessage = function(ciphertext, yourPublicWif, myPrivateWif) {
    var key = PB.Crypto.getOurSharedSecret(yourPublicWif, myPrivateWif)
    if(!key || !ciphertext) return false
    var plaintext = PB.Crypto.decryptWithAES(ciphertext, key)
    return plaintext // .replace(/\n+$/g, '')
}


PB.Crypto.random = function() { // just like Math.random, but better
    // via http://stackoverflow.com/questions/13694626/generating-random-numbers-0-to-1-with-crypto-generatevalues

    var list = PB.Crypto.getRandomValues(2, 32)

    // keep all 32 bits of the the first, top 20 of the second for 52 random bits
    var mantissa = (list[0] * Math.pow(2,20)) + (list[1] >> 12)

    // shift all 52 bits to the right of the decimal point
    var result = mantissa * Math.pow(2,-52)
    
    return result
    
    // var log2 = Math.log(max) / Math.LN2
    // var size = Math.ceil(log2) + 1 // NOTE: this is about 8 times higher than necessary
}

PB.Crypto.getRandomInteger = function(max, min) { // NOTE: min is inclusive, max is exclusive
    // TODO: error if max and min are not proper (non-NaN) numbers
    min = Math.floor(min || 0)
    max = Math.floor(max || 0x7fffffff) // 0x7fffffff == Math.pow(2, 31) - 1 // the largest bitop safe int
    var range = max - min
    var randFloat = PB.Crypto.random()
    return Math.floor(randFloat*range + min)
}

PB.Crypto.getRandomItem = function(list) {
    // TODO: error if list is not an array or string
    var index = PB.Crypto.getRandomInteger(list.length)
    return list[index]
}

/**
 * Get a new AES key
 * @param  {number} len Length in bytes (defaults to 256 bits)
 * @return {string} AES key
 */
PB.Crypto.getRandomKey = function(len) {
    len = len || 256/8                                      // AES key size is 256 bits
    var bytes = PB.Crypto.getRandomValues(len, 8)
    // var bytes = new Uint8Array(size)
    // crypto.getRandomValues(bytes)
    return Bitcoin.convert.bytesToBase64(bytes)
}

PB.Crypto.getRandomValues = function(number, size) {
    if(window.crypto && window.crypto.getRandomValues) {
        var bytes
        if(size == 32)
            bytes = new Uint32Array(size)
        else
            bytes = new Uint8Array(size)
    
        return window.crypto.getRandomValues(bytes)
    }

    return PB.Crypto.getRandomValuesShim(number, size)
}

PB.Crypto.getRandomValuesShim = function(number, size) {
    // via https://github.com/evanvosberg/crypto-js/issues/7
    // fallback for old browsers that don't support crypto.getRandomValues
    // better than plain Math.random(), worse than crypto.getRandomValues()
    var words = [];

    var r = (function (m_w) {
        var m_w = m_w;
        var m_z = 0x3ade68b1;
        var mask = 0xffffffff;

        return function () {
            m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
            m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
            var result = ((m_z << 0x10) + m_w) & mask;
            result /= 0x100000000;
            result += 0.5;
            return result * (Math.random() > .5 ? 1 : -1);
        }
    });

    for (var i = 0, rcache; i < number; i += 4) {
        var _r = r((rcache || Math.random()) * 0x100000000);

        rcache = _r() * 0x3ade67b7;

        if(size == 32) {
            words.push(Math.abs( (_r() * 0x100000000) | 0 ));
        } else {
            // in case we want bytes instead of 32-bit chunks
            var int32 = (_r() * 0x100000000) | 0;
            words.push(Math.abs(int32 & 0xFF000000) >> 24);
            words.push(Math.abs(int32 & 0x00FF0000) >> 16);
            words.push(Math.abs(int32 & 0x0000FF00) >> 8);
            words.push(Math.abs(int32 & 0x000000FF));
        }
    }

    return words;
}


/**
 * to create key pairs
 * @param  {string} puffkey
 * @param  {string} myPrivateWif
 * @param  {object} userRecords
 * @return {object}
 */
PB.Crypto.createKeyPairs = function(puffkey, myPrivateWif, userRecords) {
    if(!Array.isArray(userRecords))
        return PB.throwError('Invalid userRecords')
    
    return userRecords.reduce(function(acc, userRecord) {
        var versionedUsername = PB.Users.userRecordToVersionedUsername(userRecord)
        acc[versionedUsername] = PB.Crypto.encryptPrivateMessage(puffkey, userRecord.defaultKey, myPrivateWif)
        return acc
    }, {})
}


// PB.Crypto.verifyBlock = function(block, publicKeyBase58) {
//     return PB.Crypto.verifyMessage(block.blockPayload, block.blockSig.replace(/\*/g, ""), publicKeyBase58);
// }

// PB.Crypto.signBlock = function(blockPayload, privateKeyWIF) {
//     return PB.Crypto.signPayload(blockPayload, privateKeyWIF);
// }

/*

    Persistence layer for the EveryBit platform.

    It's like a network on your hard drive... which means this could be part of PB.Net.

    Copyright 2014 EveryBit. See README for license information.

 */

PB.Persist = {};
PB.Persist.todo = {}
PB.Persist.todoflag = false

/**
 * to save key/value
 * @param  {string} key
 * @param  {string} value
 */
PB.Persist.save = function(key, value) {
    if(value == null)
        value = false
    PB.Persist.todo[key] = value
    if(!PB.Persist.todoflag) {
        onceInAwhile(function() {
            for(var key in PB.Persist.todo) {
                var realkey = 'PUFF::' + key;                           // prepend PUFF:: so we're good neighbors
                var value = PB.Persist.todo[key];
                if(typeof value == 'function')                          // in case we're passed a thunk
                    value = value();
                var str = JSON.stringify(value);                
                localStorage.setItem(realkey, str);
            }
            PB.Persist.todo = {};
            PB.Persist.todoflag = false;
        }, 100);                                                        // call at most every 100ms
    }
    PB.Persist.todoflag = true
}

/**
 * get the parsed JSON info from the given key
 * @param  {string} key
 * @return {anything}
 */
PB.Persist.get = function(key) {
    // TODO: return empty string instead of false

    var realkey = 'PUFF::' + key;
    var str = localStorage.getItem(realkey);
    if(!str) return false;
    return PB.parseJSON(str);
}

/**
 * to remove the item according to the given key
 * @param  {string} key
 */
PB.Persist.remove = function(key) {
    var realkey = 'PUFF::' + key;
    localStorage.removeItem(realkey);
}

/*
    Comprehensive (in progress!), canonical set of functions defining and validating a puff.

    All of these are STRICTLY FORMAL validations: they don't depend on the state of the universe.

    Copyright 2014 EveryBit. See README for license information.

 */


PB.Spec = {}


/**
 * Validate the username
 * @param  {string} username
 */
PB.Spec.isValidUsername = function(username) {
    /*
    RULES:
    - Minimum length is 1
    - Maximum length of full username (including subusers and .) is 255 characters
    - Only alphanumeric
    - Only lowercase
    - Cannot begin or end with a .
     */

    PB.Spec.isValidUsername.rulesStatement = 'Usernames can only contain lowercase letters, numbers, and periods. They cannot ' +
        'be longer than 255 characters, or begin or end with a period.'

    if(!username)
        return false

    if(username.length > 255)
        return false

    if(!username.match(/^[a-z0-9.]+$/))
        return false

    if(username.slice(0, 1) == '.')
        return false

    if(username.slice(-1) == '.')
        return false

    return true
}


/**
 * Does everything possible to make a username valid
 * Note: This may have unintended consequences for the user
 */
PB.Spec.sanitizeUsername = function(username) {
    /*
     TRANSFORMATIONS:
     - Remove leading and trailing space
     - Convert to lowercase
     - Remove all illegal characters, including leading and trailing .
     */
    username = username.trim()

    username = username.toLowerCase()

    if(username.slice(0, 1) == '.')
        username = username.slice(1)

    if(username.slice(-1) == '.')
        username = username.slice(0,-1)

    username = username.replace(/[^a-z0-9.]+/g, '')

    return username
}


/**
 * check if it is a valid public key
 * @param {string} publicKey
 * @returns {boolean}
 */
PB.Spec.isValidPublicKey = function(publicKey) {
    // TODO: do "checksum" validation

    if(!isset(publicKey)) {
        return false;
    } else {
        return true;
    }

}

/**
 * check if it is a valid private key
 * @param {string} privateKey
 * @returns {boolean}
 */
PB.Spec.isValidPrivateKey = function(privateKey) {
    // TODO: Validate by testing if can be converted to public key

    if(!isset(privateKey)) {
        return false;
    } else {
        return true;
    }
}

/**
 * Check if this is a valid capa
 * @param capa
 * @returns {boolean}
 */
PB.Spec.isValidCapa = function(capa) {

    /*
     RULES:
     - Must be a natural number (1 or greater)
     */

    PB.Spec.isValidCapa.rulesStatement = 'capa must be a natural number.';


    capa = capa.toString(); // Convert to string
    var n1 = Math.abs(n);
    var n2 = parseInt(n, 10);

    if(n2 < 1)
        return false

    return !isNaN(n1) && n2 === n1 && n1.toString() === n;
}
/* 
                   _____  _____  _____                           
    ______  __ ___/ ____\/ ____\/ ____\___________ __ __  _____  
    \____ \|  |  \   __\\   __\\   __\/  _ \_  __ \  |  \/     \ 
    |  |_> >  |  /|  |   |  |   |  | (  <_> )  | \/  |  /  Y Y  \
    |   __/|____/ |__|   |__|   |__|  \____/|__|  |____/|__|_|  /
    |__|                                                      \/ 
  
  
  A Puffball module for managing forum-style puffs. Wraps the core Puffball API in a fluffy layer of syntactic spun sugar.

  Usage example:
  PB.M.Forum.init()
  ...

*/

PB.M.Forum = {};

PB.M.Forum.contentTypes = {}


/**
 * Bootstrap the forum module
 */
PB.M.Forum.init = function() {
    PB.addRelationshipHandler(PB.M.Forum.addFamilialEdges)              // manages parent-child relationships
    PB.addBeforeSwitchIdentityHandler(PB.M.Forum.clearPuffContentStash)    // clear private caches 
    PB.addPayloadModifierHandler(PB.M.Forum.addTimestamp)               // add timestamp to all new puffs
}


/**
 * Inject a timestamp into the payload
 * the "time" field is optional for puffs, but mandatory for "forum style" puffs
 *
 * @param {Object} payload
 * @returns {Object|{}}
 */
PB.M.Forum.addTimestamp = function(payload) {
    payload = payload || {}
    payload.time = Date.now()
    return payload
}


/**
 * Filter puffs by prop filters
 * @param  {string} filters
 * @return {boolean}
 */
PB.M.Forum.filterByFilters = function(filters) {

    if(!filters) return function() {return true}
    
    //// get a filtering function
    return function(shell) {

        // ROUTES
        if (filters.routes && filters.routes.length > 0) {
            var routeMatch = false;
            for (var i = 0; i < filters.routes.length; i++) {
                if (shell.routes.indexOf(filters.routes[i]) > -1) routeMatch = true;
            }
            if (!routeMatch) return false;
        }

        // TAGS
        if (filters.tags && filters.tags.length > 0) {
            if (!shell.payload.tags || !shell.payload.tags.length) {
                return false;
            }
            var tagMatch = false;
            for (var i = 0; i < filters.tags.length; i++) {
                if (shell.payload.tags.indexOf(filters.tags[i]) > -1) tagMatch = true;
            }
            if (!tagMatch) return false;
        }

        // TYPES
        if (filters.types && filters.types.length > 0) {
            if (!~filters.types.indexOf(shell.payload.type)) {
                // console.log(shell.type)
                return false
            }
        }

        // USERS
        if(filters.users && filters.users.length > 0)
            if(!~filters.users.indexOf(PB.Users.justUsername(shell.username))) return false


        if(filters.roots)
            if((shell.payload.parents||[]).length) return false

        if(filters.ancestors && filters.focus) {
            var focus = PB.getPuffBySig(filters.focus) // TODO: find better way to do this
            if(focus.payload && !~focus.payload.parents.indexOf(shell.sig)) return false
        }

        if(filters.descendants && filters.focus)
            if(!~shell.payload.parents.indexOf(filters.focus)) return false

        // TODO: deprecate this, as it's handled above:
        if (filters.type && filters.type.length)
            if (!~filters.type.indexOf(shell.payload.type)) return false

        return true
    }
}



/**
 * Helper for sorting by payload.time
 * @param  {Object} a
 * @param  {object} b
 * @return {number} based on desired sorting order
 */
PB.M.Forum.sortByPayload = function(a,b) {
    //// helper for sorting by payload.time
    if(puffworldprops.view.query.sort == 'DESC')
        return b.payload.time - a.payload.time;
    else
        return a.payload.time - b.payload.time;
}



/**
 * Get the current puff's parents
 * @param  {Object} puff
 * @param  {Object} props
 * @return {number} The number of parents
 */
PB.M.Forum.getParentCount = function(puff, props) {
    if(!puff) return 0
    
    var sig = puff.sig || puff
    
    return PB.Data.graph.v(sig).out('parent').run().length
}


/**
 * Get a count of the current puff's children
 * @param  {Object} puff
 * @return {number} The number of children
 */
PB.M.Forum.getChildCount = function(puff) {
    if(!puff) return 0
    
    var sig = puff.sig || puff
    
    return PB.Data.graph.v(sig).out('child').run().length
}


/**
 * Filter puffs according to criteria
 * @param  {string} query
 * @param  {string} filters
 * @param  {number} limit
 * @return {array} An array of puffs
 */
PB.M.Forum.getPuffList = function(query, filters, limit) {
    //// returns a list of puffs

    // THINK: the graph can help us here, but only if we're more clever about forming relationships and using those in our filters.

    limit = limit || Infinity
    var offset = +query.offset||0

    // var shells = PB.M.Forum.getShells(query, filters)
    var shells = PB.Data.getAllMyShells()
    
    var filtered_shells = shells.filter(PB.M.Forum.filterByFilters(Boron.extend({}, query, filters)))
                                .sort(PB.M.Forum.sortByPayload) // TODO: sort by query

    var sliced_shells = filtered_shells.slice(offset, offset+limit)
    
    var puffs = sliced_shells.map(PB.Data.getPuffFromShell)
                             .filter(Boolean)

    var have = sliced_shells.length
    // var have = puffs.length
    if(have >= limit)
        return puffs  // as long as we have enough filtered shells the puffs will eventually fill in empty spots

    PB.Data.fillSomeSlotsPlease(limit, have, query, filters)
    
    return puffs;
}


/**
 * Takes a string of content, create a puff and push it into the system
 * @param {string} type
 * @param {string} content
 * @param {array} parents
 * @param {Object} metadata
 * @param {string[]} userRecordsForWhomToEncrypt
 * @param {string[]} privateEnvelopeAlias
 * @returns {promise}
 */
PB.M.Forum.addPost = function(type, content, parents, metadata, userRecordsForWhomToEncrypt, privateEnvelopeAlias) {
    //// Given a string of content, create a puff and push it into the system
    
    // ensure parents is an array
    if(!parents) parents = []
    if(!Array.isArray(parents)) parents = [parents]
    
    // ensure parents contains only puff ids
    if(parents.map(PB.getPuffBySig).filter(function(x) { return x != null }).length != parents.length)
        return PB.emptyPromise('Those are not good parents')
    
    // ensure parents are unique
    parents = PB.uniquify(parents)

    // find the routes using parents
    var routes = parents.map(function(id) {
        return PB.getPuffBySig(id).username
    });
    if (metadata.routes) {
        routes = metadata.routes // THINK: this should probably merge with above instead of replacing it...
        delete metadata['routes']
    }
    
    // ensure all routes are unique
    routes = PB.uniquify(routes)
    
    var takeUserMakePuff = PB.M.Forum.partiallyApplyPuffMaker(type, content, parents, metadata, routes, userRecordsForWhomToEncrypt, privateEnvelopeAlias)
    
    // get a user promise
    var userprom = PB.Users.getUpToDateUserAtAnyCost()
    
    var prom = userprom.catch(PB.catchError('Failed to add post: could not access or create a valid user'))
                       .then(takeUserMakePuff)
                       .catch(PB.catchError('Posting failed'))
    
    return prom
    
    // NOTE: any puff that has 'time' and 'parents' fields fulfills the forum interface
    // TODO: make an official interface fulfillment thing
}


/**
 * Make a puff... except the parts that require a user
 * @param {string} type
 * @param {string} content
 * @param {array} parents
 * @param {object} metadata
 * @param {array} routes
 * @param {array} userRecordsForWhomToEncrypt
 * @param {array} privateEnvelopeAlias
 * @returns {Function}
 */
PB.M.Forum.partiallyApplyPuffMaker = function(type, content, parents, metadata, routes, userRecordsForWhomToEncrypt, privateEnvelopeAlias) {
    //// Make a puff... except the parts that require a user
    
    // THINK: if you use the same metadata object for multiple puffs your cached version of the older puffs will get messed up
    
    var payload = metadata || {}                            // metadata becomes the basis of payload
    payload.parents = payload.parents || parents            // ids of the parent puffs
    payload.time = metadata.time || Date.now()              // time is always a unix timestamp
    payload.tags = metadata.tags || []                      // an array of tags // TODO: make these work

    var type  = type || 'text'
    var routes = routes ? routes : [];
    routes = routes.concat(PB.CONFIG.zone);
    
    return function(userRecord) {
        // userRecord is always an up-to-date record from the DHT, so we can use its 'latest' value here 

        var previous = userRecord.latest
        var puff = PB.simpleBuildPuff(type, content, payload, routes, userRecordsForWhomToEncrypt, privateEnvelopeAlias)

        return PB.addPuffToSystem(puff) // THINK: this fails silently if the sig exists already
    }
}

/// graph relationships ///

PB.M.Forum.addFamilialEdges = function(shells) {
    shells.forEach(PB.M.Forum.addFamilialEdgesForShell)
}

PB.M.Forum.addFamilialEdgesForShell = function(child) {
    var addParentEdges = PB.M.Forum.addFamilialEdgesForParent(child);
    (child.payload.parents||[]).forEach(addParentEdges);
}

PB.M.Forum.addFamilialEdgesForParent = function(child) {
    var existingParents = PB.Data.graph.v(child.sig).out('parent').property('shell').run().map(PB.prop('sig'))
    
    return function(parentSig) {
        if(~existingParents.indexOf(parentSig)) return false                       // done?
        PB.Data.addSigAsVertex(parentSig)                                          // idempotent
        PB.Data.graph.addEdge({_label: 'parent', _in: parentSig, _out: child.sig}) // not idempotent
        PB.Data.graph.addEdge({_label: 'child', _out: parentSig,  _in: child.sig})
    }
}

/// end graph relationships ///


/**
 * to process the content
 * @param  {string} type
 * @param  {string} content
 * @param  {puff} puff
 * @return {string}
 */
PB.M.Forum.processContent = function(type, content, puff) {
    var typeObj = PB.M.Forum.contentTypes[type]
    
    if(!typeObj)
        typeObj = PB.M.Forum.contentTypes['text']

    return typeObj.toHtml(content, puff)
}


// TODO: this might get big, need some GC here
PB.M.Forum.puffContentStash = {}

PB.M.Forum.clearPuffContentStash = function() {
    PB.M.Forum.puffContentStash = {}
}

/**
 * Get the content of a puff
 * @param  {puff} puff
 * @return {string}
 */
PB.M.Forum.getProcessedPuffContent = function(puff) {
    // THINK: we've already ensured these are proper puffs, so we don't have to check for payload... right?
    if(PB.M.Forum.puffContentStash[puff.sig])
        return PB.M.Forum.puffContentStash[puff.sig]
    
    var content = PB.M.Forum.processContent(puff.payload.type, puff.payload.content, puff)
    PB.M.Forum.puffContentStash[puff.sig] = content
    
    return content
}

/**
 * Add support for types of content to the system
 * @param {string} name
 * @param {string} type
 */
PB.M.Forum.addContentType = function(name, type) {
    // THINK: move this down into PB?
    
    if(!name) 
        return PB.onError('Invalid content type name')
    if(PB.CONFIG.supportedContentTypes && PB.CONFIG.supportedContentTypes.indexOf(name) == -1)
        return PB.onError('Unsupported content type: ' + name)
    if(!type.toHtml) 
        return PB.onError('Invalid content type: object is missing toHtml method', name)
    
    PB.M.Forum.contentTypes[name] = type
}


// DEFAULT CONTENT TYPES

PB.M.Forum.addContentType('text', {
    toHtml: function(content) {
        var safe_content = XBBCODE.process({ text: content })   // not ideal, but it does seem to strip out raw html
        safe_content.html = safe_content.html.replace(/\n/g, '</br>');  // Set line breaks
        return '<span>' + safe_content.html + '</span>'
    }
})

PB.M.Forum.addContentType('bbcode', {
    toHtml: function(content) {
        var bbcodeParse = XBBCODE.process({ text: content });
        var parsedText  = bbcodeParse.html.replace(/\n/g, '<br />'); 
        return parsedText;
    }
})

PB.M.Forum.addContentType('image', {
    toHtml: function(content) {
        if(puffworldprops.view.mode == "tableView")
            return '<img src=' + content + ' />';
        else
            return '<img class="imgInBox" src=' + content + ' />';
    }
})

PB.M.Forum.addContentType('markdown', {
    toHtml: function(content) {
        var converter = new Markdown.Converter();
        return '<span>'+converter.makeHtml(content)+'</span>';
    }
})

// Used to display chess boards
PB.M.Forum.addContentType('PGN', {
    toHtml: function(content) {
        return chessBoard(content);
    }
})

PB.M.Forum.addContentType('identity', {
    toHtml: function() {
        return ''
    }
})

PB.M.Forum.addContentType('profile', {
    toHtml: function(content, puff) {
        if(puffworldprops.view.mode == "tableView")
            return '<img src=' + content + ' />';
        else
            return '<img class="imgInBox" src=' + content + ' />';
        /*var keysNotShow = ['content', 'type'];
        for (var key in puff.payload) {
            var value = puff.payload[key];
            if (keysNotShow.indexOf(key)==-1 && value && value.length) {
                toRet += '<div><span class="profileKey">' + key + ': </span><span class="profileValue">' + value + '</span></div>';
            }
        }*/
    }
})

PB.M.Forum.addContentType('file', {
    toHtml: function(content, puff) {
        return (
            puff.payload.filename
            )
    }

})

// TODO: Add support for LaTex
/*PB.M.Forum.addContentType('LaTex', {
    toHtml: function(content) {
        var safe_content = XBBCODE.process({ text: content }) 
        return '<p>' + safe_content.html + '</p>'
    }
}) */


// Flag a puff
PB.M.Forum.flagPuff = function (sig) {

    var payload = {};
    var routes = [];
    var type = 'flagPuff';
    var content = sig;
    var puff; // variable for leaking the signed puff out of the secure zone
    
    payload.time = Date.now();

    PB.useSecureInfo(function(identities, currentUsername, privateRootKey, privateAdminKey, privateDefaultKey) {    

        if(!currentUsername) {
            alert("You must first set your username before you can flag content");
            return false;
        }
        /*if(!currentUsername == PB.getPuffBySig(sig).username) {
            alert("You must set your identity to the author of the puff you want to flag");
        }*/
        if(!privateAdminKey) {
            alert("You must first set your private admin key before you can flag content");
            return false;
        }
    
        puff = PB.buildPuff(currentUsername, privateAdminKey, routes, type, content, payload);
    })

    var data = { type: 'flagPuff'
               , puff: puff
               };

    var prom = PB.Net.PBpost(PB.CONFIG.puffApi, data);
    
    prom = prom.then(function(result){
        // var storedShells = PB.Persist.get('shells');
        // var filteredShells = storedShells.filter(function(s){return s.sig != content && s.content != content});
        var flaggedSig = PB.Persist.get('flagged') || [];
        flaggedSig.push(content);

        // PB.Persist.save('shells', filteredShells);
        PB.Persist.save('flagged', flaggedSig);
        // reload?
        // document.location.reload();
        Events.pub('ui/flag', {});
        return result;
    })
    return prom;
}


// Adding default metafields to included in a puff
PB.M.Forum.metaFields = []
PB.M.Forum.context = {};
PB.M.Forum.addMetaFields = function(fieldInfo, context, excludeContext) {
    // NOTE: this isn't used outside of publishEmbed.js, but it might provide a good basis for generic/required metadata
    
    if (!fieldInfo.name) return console.log('Invalid meta field name.');

    // supported type: text, textarea, pulldown, array
    if (!fieldInfo.type) return console.log('Invalid meta field type.');

    if (!fieldInfo.validator || typeof fieldInfo.validator != 'function') {
        fieldInfo.validator = false;
    }

    context = context || Object.keys(PB.M.Forum.contentTypes);
    if (typeof context == 'string') {
        context = [context];
    } else if (!Array.isArray(context)) {
        return PB.onError('Invalid context.')
    }

    excludeContext = excludeContext || [];
    if (typeof excludeContext == 'string') {
        excludeContext = [excludeContext];
    }else if (!Array.isArray(excludeContext)) {
        return PB.onError('Invalid context.')
    }

    PB.M.Forum.metaFields.push(fieldInfo);
    for (var i=0; i<context.length; i++) {
        if (excludeContext.indexOf(context[i]) != -1)
            continue;
        var contextFields = PB.M.Forum.context[context[i]] || [];
        contextFields.push(fieldInfo.name);
        PB.M.Forum.context[context[i]] = contextFields;
    }
}

PB.M.Forum.addMetaFields(
    {name: 'reply privacy',
     type: 'pulldown',
     enum: ['', 'public', 'private', 'anonymous', 'invisible'],
     defaultValue: ''});

PB.M.Forum.addMetaFields(
    {name: 'content license',
     type: 'pulldown',
     enum: ['', 'CreativeCommonsAttribution', 'GNUPublicLicense', 'Publicdomain', 'Rights-managed', 'Royalty-free'],
     defaultValue: ''});

PB.M.Forum.addMetaFields(
    {name: 'tags',
     type: 'array',
     validator: function(v){return /^[a-z0-9]+$/i.test(v)}
     },
    false, 'profile');

PB.M.Forum.addMetaFields(
    {name: 'language',
     type: 'text',
     defaultValue: function(){return puffworldprops.view.language}});

PB.M.Forum.addMetaFields(
    {name: 'name',
     type: 'text'},
    'profile');
/* 
                   _____  _____                          .___            ___.           
    ______  __ ___/ ____\/ ____\_  _  _______ _______  __| _/______  ____\_ |__   ____  
    \____ \|  |  \   __\\   __\\ \/ \/ /\__  \\_  __ \/ __ |\_  __ \/  _ \| __ \_/ __ \ 
    |  |_> >  |  /|  |   |  |   \     /  / __ \|  | \/ /_/ | |  | \(  <_> ) \_\ \  ___/ 
    |   __/|____/ |__|   |__|    \/\_/  (____  /__|  \____ | |__|   \____/|___  /\___  >
    |__|                                     \/           \/                  \/     \/ 
  
  A Puffball module for managing identities and private data locally.
  ==================================================

  The Wardrobe manages identities, aliases, and private data.

  An identity is a username and a list of all known aliases. The identity also lists the last known primary alias, if there is one, and the identity's private preferences. 

  An alias is a username, a 'capa', and a set of private keys. Additional private information (like a passphrase) may be stored in the alias's 'secrets' field.

  Aliases generally correspond either to previous versions of the identity's username (previous primaries), or to anonymous usernames created for one-time encrypted transfer. 

  Username and capa define a unique alias. The capa field references a specific moment in the username's lifecycle, and correlates to the userRecord with the same username and capa whose public keys match the alias's private keys. In other words, capa == version.

  Currently capa counts by consecutive integers. This may change in the future. Any set deriving Eq and Ord will work.

  An identity file can be exported to the local filesystem and imported back in to the system.

  Private data is a black box for 

  Usage examples:
      PB.switchIdentityTo(username)

*/

/*
  THINK:
    - register callback handlers for user record creation and modification
    - PB.M.Wardrobe.init registers those with PB.onUserCreation and PB.onUserModification
    - identity file encryption using a passphrase
*/


PB.M.Wardrobe = {}

~function() { // begin the closure

    var identities = {}
    var aliases = {}
    // {asdf: { username: 'asdf', primary: asdf-12, aliases: [asdf-11, asdf-10], preferences: {} } }

    // an alias: { username: 'asdf', capa: 12, privateRootKey: '123', privateAdminKey: '333', privateDefaultKey: '444', secrets: {} }

    var currentUsername = false


    // TODO: integrate capa with userRecords and puffs everywhere
    // TODO: use capa returned from server on update passphrase
    // TODO: get anon creation working


    PB.M.Wardrobe.init = init
    
    function init() {
        PB.implementSecureInterface(useSecureInfo, addIdentity, addAlias, setPrimaryAlias, setPreference, switchIdentityTo, removeIdentity)
        
        PB.addIdentityUpdateHandler(function() { // THINK: where should this live?
            if(!PB.CONFIG.disableCloudIdentity)
                PB.storeIdentityFileInCloud()
        })
        
        // TODO: find a better way to do this
        var oldConfigValue = PB.CONFIG.disableCloudIdentity
        PB.CONFIG.disableCloudIdentity = true
        
        var storedIdentities = PB.Persist.get('identities') || {}
    
        Object.keys(storedIdentities).forEach(function(username) {
            var identity = storedIdentities[username]
            addIdentity(username, identity.aliases, identity.preferences, true)
        })
        
        PB.CONFIG.disableCloudIdentity = oldConfigValue
        
        var lastUsername = PB.Persist.get('currentUsername')
        
        if (lastUsername)
            PB.switchIdentityTo(lastUsername) // NOTE: call wrapped version to get handlers
    }
    
    
    //// exported via implementSecureInterface

    var useSecureInfo = function(callback) {
        var identity = getCurrentIdentity() || {}
        var primary = identity.primary || {}

        // we have to return all the identities because the user might be trying to list them
        callback(identities, currentUsername, primary.privateRootKey, primary.privateAdminKey, primary.privateDefaultKey)
        
        return true
    }

    var addIdentity = function(username, aliases, preferences, nosave) { // TODO: check if nosave is needed
        // TODO: validation on all available values
        // TODO: check for existing identity
        // TODO: add any unknown aliases
        // THINK: what about aliases that belong to other identities?
        // THINK: ensure primary alias exists?
        // TODO: remove primary (use username+maxcapa instead)

        var identity = { username: username
                       , primary: {}
                       , aliases: []
                       , preferences: preferences || {}
                       }

        identities[username] = identity
        
        if(!Array.isArray(aliases))
            aliases = aliases ? [aliases] : []
        
        aliases.forEach(
            function(alias) {
                addAlias(username, alias.username, alias.capa, alias.privateRootKey, alias.privateAdminKey, alias.privateDefaultKey, alias.secrets)})
        
        // TODO: handle prefs
        
        if(!nosave) // TODO: change processUpdates so it only saves if we're not busy opening all identities? or just let the 100ms throttle handle it...
            processUpdates()
            
        return true
    }

    var addAlias = function(identityUsername, aliasUsername, capa, privateRootKey, privateAdminKey, privateDefaultKey, secrets) {
        // TODO: validation on all available values
        // TODO: check for existing username/capa
        // THINK: hit network for confirmation?
        // THINK: maybe only include viable values?

        var alias = { username: aliasUsername
                    , capa: capa || 1 // NOTE: default capa
                    , privateRootKey: privateRootKey || false
                    , privateAdminKey: privateAdminKey || false
                    , privateDefaultKey: privateDefaultKey || false
                    , secrets: secrets || {}
                    }

        var identity = getIdentity(identityUsername)
        
        if(!identity) {
            addIdentity(identityUsername)                   // creates an empty identity
            identity = getIdentity(identityUsername)
        }
        
        // merge alias
        var old_alias = getOldAlias(identity, alias)
        if(old_alias) {
            alias.secrets = Boron.extend(old_alias.secrets, alias.secrets)
            for(var key in alias) 
                if(alias[key])
                    old_alias[key] = alias[key]
        } else {
            identity.aliases.push(alias)
        }
        
        if(aliasUsername == identityUsername && alias.capa >= (identity.capa||0)) {
            identity.primary = alias                        // set primary for identity (which may have been empty)
        }
        
        aliases[aliasUsername] = identity                   // add this to the alias-identity mapping

        processUpdates()

        return true
    }

    var setPrimaryAlias = function(identityUsername, aliasUsername) {
        var identity = getIdentity(identityUsername)
        
        if(!identity)
            return PB.onError('Primary alias can only be set for known identities')
            
        var alias = getLatestAlias(identity, aliasUsername)
        
        if(!alias)
            return PB.onError('That alias is not associated with that identity')
    
        // all clear!
        
        identity.username = aliasUsername
        identity.primary = alias

        delete identities[identityUsername]
        identities[aliasUsername] = identity
        
        if(identityUsername == currentUsername)
            switchIdentityTo(aliasUsername)
        
        return true
    }
     
    var setPreference = function(key, value) {
        // NOTE: this only works for the current identity
        var identity = getCurrentIdentity()
    
        if(!identity)
            return PB.onError('Preferences can only be set for an active identity')
    
        identity.preferences[key] = value

        processUpdates()
    }
    
    var switchIdentityTo = function(username) {
        if(username) {
            var identity = getIdentity(username)

            if(!identity)
                return PB.onError('No identity found with username "' + username + '"')
        }
        
        currentUsername = username || false

        if(!PB.currentIdentityHash) // THINK: what are the cases?
            PB.currentIdentityHash = PB.Crypto.createMessageHash(JSON.stringify(PB.formatIdentityFile()))
        
        processUpdates()
        
        if(username && identity && identity.primary)
            PB.Users.getUserRecordPromise(username, identity.primary.capa) // fetch our userRecord 

        return true
    }
    
    var removeIdentity = function(username) {
        var identity = getIdentity(username)

        if(!identity)
            return PB.onError('Could not find that identity for removal')

        delete identities[username]

        if(currentUsername == username)
            currentUsername = false

        processUpdates()
    }

    ////
    //// internal helper functions. not exported.
    ////

    function getLatestAlias(identity, aliasUsername) {
        var maxcapa = 0
        var alias = false
        
        for(var i=0, l=identity.aliases.length; i<l; i++) {
            var test = identity.aliases[i]
            if(test.username == aliasUsername && test.capa > maxcapa) {
                alias = test
                maxcapa = test.capa
            }
        }
        
        return alias
    }

    function getOldAlias(identity, alias) {
        for(var i=0, l=identity.aliases.length; i<l; i++) {
            var test = identity.aliases[i]
            if(alias.username == test.username && alias.capa == test.capa)
                return test
        }
    }

    function validatePrivateKeys(username, capa, privateRootKey, privateAdminKey, privateDefaultKey) {
        // CURRENTLY UNUSED
        //// Ensure keys match the userRecord
    
        var prom = PB.Users.getUserRecordPromise(username, capa)
    
        return prom
            .then(function(userRecord) {
                // validate any provided private keys against the userRecord's public keys
                if(   privateRootKey && PB.Crypto.privateToPublic(privateRootKey) != userRecord.rootKey)
                    PB.throwError('That private root key does not match the public root key on record')
                if(  privateAdminKey && PB.Crypto.privateToPublic(privateAdminKey) != userRecord.adminKey)
                    PB.throwError('That private admin key does not match the public admin key on record')
                if(privateDefaultKey && PB.Crypto.privateToPublic(privateDefaultKey) != userRecord.defaultKey)
                    PB.throwError('That private default key does not match the public default key on record')
        
                return userRecord
            }
            , PB.catchError('Could not store private keys due to faulty user record'))
    }

    function processUpdates() {
        if(!PB.CONFIG.ephemeralKeychain)
            PB.Persist.save('identities', identities)

        // THINK: consider zipping identities in localStorage to prevent shoulder-surfing and save space (same for puffs)
        // THINK: consider passphrase protecting identities and private puffs in localStorage
        // TODO: don't persist primary -- regenerate it at load time, so we don't duplicate the alias
        PB.Persist.save('currentUsername', currentUsername)

        PB.runHandlers('identityUpdate')
    }

    function getCurrentIdentity() {
        return getIdentity(currentUsername)
    }

    function getIdentity(username) {
        if(!username) 
            return false

        var identity = identities[username]

        // THINK: we could check the aliases map here in case the username isn't primary

        if(!identity) 
            return false

        return identity
    }

}() // end the closure
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImJpdGNvaW5qcy1taW4uanMiLCJwZWVyLmpzIiwicHJvbWlzZS5taW4uanMiLCJ4YmJjb2RlLmpzIiwiYm9yb24uanMiLCJmaWxlc3R1ZmYuanMiLCJldmVudHMuanMiLCJncmlkYm94LmpzIiwiZGFnb2JhLmpzIiwiUEIuanMiLCJQQi5OZXQuanMiLCJQQi5EYXRhLmpzIiwiUEIuVXNlcnMuanMiLCJQQi5DcnlwdG8uanMiLCJQQi5QZXJzaXN0LmpzIiwiUEIuU3BlYy5qcyIsIlBCLk0uRm9ydW0uanMiLCJQQi5NLldhcmRyb2JlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDMzNGQTtBQUNBO0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdlpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZtQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZXZlcnliaXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxlKTtlbHNle3ZhciBmO1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/Zj13aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9mPWdsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmKGY9c2VsZiksZi5CaXRjb2luPWUoKX19KGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgdXRpbD1fZGVyZXFfKFwidXRpbC9cIik7dmFyIHBTbGljZT1BcnJheS5wcm90b3R5cGUuc2xpY2U7dmFyIGhhc093bj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBhc3NlcnQ9bW9kdWxlLmV4cG9ydHM9b2s7YXNzZXJ0LkFzc2VydGlvbkVycm9yPWZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpe3RoaXMubmFtZT1cIkFzc2VydGlvbkVycm9yXCI7dGhpcy5hY3R1YWw9b3B0aW9ucy5hY3R1YWw7dGhpcy5leHBlY3RlZD1vcHRpb25zLmV4cGVjdGVkO3RoaXMub3BlcmF0b3I9b3B0aW9ucy5vcGVyYXRvcjtpZihvcHRpb25zLm1lc3NhZ2Upe3RoaXMubWVzc2FnZT1vcHRpb25zLm1lc3NhZ2U7dGhpcy5nZW5lcmF0ZWRNZXNzYWdlPWZhbHNlfWVsc2V7dGhpcy5tZXNzYWdlPWdldE1lc3NhZ2UodGhpcyk7dGhpcy5nZW5lcmF0ZWRNZXNzYWdlPXRydWV9dmFyIHN0YWNrU3RhcnRGdW5jdGlvbj1vcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbnx8ZmFpbDtpZihFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSl7RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcyxzdGFja1N0YXJ0RnVuY3Rpb24pfWVsc2V7dmFyIGVycj1uZXcgRXJyb3I7aWYoZXJyLnN0YWNrKXt2YXIgb3V0PWVyci5zdGFjazt2YXIgZm5fbmFtZT1zdGFja1N0YXJ0RnVuY3Rpb24ubmFtZTt2YXIgaWR4PW91dC5pbmRleE9mKFwiXFxuXCIrZm5fbmFtZSk7aWYoaWR4Pj0wKXt2YXIgbmV4dF9saW5lPW91dC5pbmRleE9mKFwiXFxuXCIsaWR4KzEpO291dD1vdXQuc3Vic3RyaW5nKG5leHRfbGluZSsxKX10aGlzLnN0YWNrPW91dH19fTt1dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvcixFcnJvcik7ZnVuY3Rpb24gcmVwbGFjZXIoa2V5LHZhbHVlKXtpZih1dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSl7cmV0dXJuXCJcIit2YWx1ZX1pZih1dGlsLmlzTnVtYmVyKHZhbHVlKSYmKGlzTmFOKHZhbHVlKXx8IWlzRmluaXRlKHZhbHVlKSkpe3JldHVybiB2YWx1ZS50b1N0cmluZygpfWlmKHV0aWwuaXNGdW5jdGlvbih2YWx1ZSl8fHV0aWwuaXNSZWdFeHAodmFsdWUpKXtyZXR1cm4gdmFsdWUudG9TdHJpbmcoKX1yZXR1cm4gdmFsdWV9ZnVuY3Rpb24gdHJ1bmNhdGUocyxuKXtpZih1dGlsLmlzU3RyaW5nKHMpKXtyZXR1cm4gcy5sZW5ndGg8bj9zOnMuc2xpY2UoMCxuKX1lbHNle3JldHVybiBzfX1mdW5jdGlvbiBnZXRNZXNzYWdlKHNlbGYpe3JldHVybiB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmFjdHVhbCxyZXBsYWNlciksMTI4KStcIiBcIitzZWxmLm9wZXJhdG9yK1wiIFwiK3RydW5jYXRlKEpTT04uc3RyaW5naWZ5KHNlbGYuZXhwZWN0ZWQscmVwbGFjZXIpLDEyOCl9ZnVuY3Rpb24gZmFpbChhY3R1YWwsZXhwZWN0ZWQsbWVzc2FnZSxvcGVyYXRvcixzdGFja1N0YXJ0RnVuY3Rpb24pe3Rocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe21lc3NhZ2U6bWVzc2FnZSxhY3R1YWw6YWN0dWFsLGV4cGVjdGVkOmV4cGVjdGVkLG9wZXJhdG9yOm9wZXJhdG9yLHN0YWNrU3RhcnRGdW5jdGlvbjpzdGFja1N0YXJ0RnVuY3Rpb259KX1hc3NlcnQuZmFpbD1mYWlsO2Z1bmN0aW9uIG9rKHZhbHVlLG1lc3NhZ2Upe2lmKCF2YWx1ZSlmYWlsKHZhbHVlLHRydWUsbWVzc2FnZSxcIj09XCIsYXNzZXJ0Lm9rKX1hc3NlcnQub2s9b2s7YXNzZXJ0LmVxdWFsPWZ1bmN0aW9uIGVxdWFsKGFjdHVhbCxleHBlY3RlZCxtZXNzYWdlKXtpZihhY3R1YWwhPWV4cGVjdGVkKWZhaWwoYWN0dWFsLGV4cGVjdGVkLG1lc3NhZ2UsXCI9PVwiLGFzc2VydC5lcXVhbCl9O2Fzc2VydC5ub3RFcXVhbD1mdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsZXhwZWN0ZWQsbWVzc2FnZSl7aWYoYWN0dWFsPT1leHBlY3RlZCl7ZmFpbChhY3R1YWwsZXhwZWN0ZWQsbWVzc2FnZSxcIiE9XCIsYXNzZXJ0Lm5vdEVxdWFsKX19O2Fzc2VydC5kZWVwRXF1YWw9ZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCxleHBlY3RlZCxtZXNzYWdlKXtpZighX2RlZXBFcXVhbChhY3R1YWwsZXhwZWN0ZWQpKXtmYWlsKGFjdHVhbCxleHBlY3RlZCxtZXNzYWdlLFwiZGVlcEVxdWFsXCIsYXNzZXJ0LmRlZXBFcXVhbCl9fTtmdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCxleHBlY3RlZCl7aWYoYWN0dWFsPT09ZXhwZWN0ZWQpe3JldHVybiB0cnVlfWVsc2UgaWYodXRpbC5pc0J1ZmZlcihhY3R1YWwpJiZ1dGlsLmlzQnVmZmVyKGV4cGVjdGVkKSl7aWYoYWN0dWFsLmxlbmd0aCE9ZXhwZWN0ZWQubGVuZ3RoKXJldHVybiBmYWxzZTtmb3IodmFyIGk9MDtpPGFjdHVhbC5sZW5ndGg7aSsrKXtpZihhY3R1YWxbaV0hPT1leHBlY3RlZFtpXSlyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZWxzZSBpZih1dGlsLmlzRGF0ZShhY3R1YWwpJiZ1dGlsLmlzRGF0ZShleHBlY3RlZCkpe3JldHVybiBhY3R1YWwuZ2V0VGltZSgpPT09ZXhwZWN0ZWQuZ2V0VGltZSgpfWVsc2UgaWYodXRpbC5pc1JlZ0V4cChhY3R1YWwpJiZ1dGlsLmlzUmVnRXhwKGV4cGVjdGVkKSl7cmV0dXJuIGFjdHVhbC5zb3VyY2U9PT1leHBlY3RlZC5zb3VyY2UmJmFjdHVhbC5nbG9iYWw9PT1leHBlY3RlZC5nbG9iYWwmJmFjdHVhbC5tdWx0aWxpbmU9PT1leHBlY3RlZC5tdWx0aWxpbmUmJmFjdHVhbC5sYXN0SW5kZXg9PT1leHBlY3RlZC5sYXN0SW5kZXgmJmFjdHVhbC5pZ25vcmVDYXNlPT09ZXhwZWN0ZWQuaWdub3JlQ2FzZX1lbHNlIGlmKCF1dGlsLmlzT2JqZWN0KGFjdHVhbCkmJiF1dGlsLmlzT2JqZWN0KGV4cGVjdGVkKSl7cmV0dXJuIGFjdHVhbD09ZXhwZWN0ZWR9ZWxzZXtyZXR1cm4gb2JqRXF1aXYoYWN0dWFsLGV4cGVjdGVkKX19ZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCk9PVwiW29iamVjdCBBcmd1bWVudHNdXCJ9ZnVuY3Rpb24gb2JqRXF1aXYoYSxiKXtpZih1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGEpfHx1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGIpKXJldHVybiBmYWxzZTtpZihhLnByb3RvdHlwZSE9PWIucHJvdG90eXBlKXJldHVybiBmYWxzZTtpZihpc0FyZ3VtZW50cyhhKSl7aWYoIWlzQXJndW1lbnRzKGIpKXtyZXR1cm4gZmFsc2V9YT1wU2xpY2UuY2FsbChhKTtiPXBTbGljZS5jYWxsKGIpO3JldHVybiBfZGVlcEVxdWFsKGEsYil9dHJ5e3ZhciBrYT1vYmplY3RLZXlzKGEpLGtiPW9iamVjdEtleXMoYiksa2V5LGl9Y2F0Y2goZSl7cmV0dXJuIGZhbHNlfWlmKGthLmxlbmd0aCE9a2IubGVuZ3RoKXJldHVybiBmYWxzZTtrYS5zb3J0KCk7a2Iuc29ydCgpO2ZvcihpPWthLmxlbmd0aC0xO2k+PTA7aS0tKXtpZihrYVtpXSE9a2JbaV0pcmV0dXJuIGZhbHNlfWZvcihpPWthLmxlbmd0aC0xO2k+PTA7aS0tKXtrZXk9a2FbaV07aWYoIV9kZWVwRXF1YWwoYVtrZXldLGJba2V5XSkpcmV0dXJuIGZhbHNlfXJldHVybiB0cnVlfWFzc2VydC5ub3REZWVwRXF1YWw9ZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCxleHBlY3RlZCxtZXNzYWdlKXtpZihfZGVlcEVxdWFsKGFjdHVhbCxleHBlY3RlZCkpe2ZhaWwoYWN0dWFsLGV4cGVjdGVkLG1lc3NhZ2UsXCJub3REZWVwRXF1YWxcIixhc3NlcnQubm90RGVlcEVxdWFsKX19O2Fzc2VydC5zdHJpY3RFcXVhbD1mdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsZXhwZWN0ZWQsbWVzc2FnZSl7aWYoYWN0dWFsIT09ZXhwZWN0ZWQpe2ZhaWwoYWN0dWFsLGV4cGVjdGVkLG1lc3NhZ2UsXCI9PT1cIixhc3NlcnQuc3RyaWN0RXF1YWwpfX07YXNzZXJ0Lm5vdFN0cmljdEVxdWFsPWZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCxleHBlY3RlZCxtZXNzYWdlKXtpZihhY3R1YWw9PT1leHBlY3RlZCl7ZmFpbChhY3R1YWwsZXhwZWN0ZWQsbWVzc2FnZSxcIiE9PVwiLGFzc2VydC5ub3RTdHJpY3RFcXVhbCl9fTtmdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsZXhwZWN0ZWQpe2lmKCFhY3R1YWx8fCFleHBlY3RlZCl7cmV0dXJuIGZhbHNlfWlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCk9PVwiW29iamVjdCBSZWdFeHBdXCIpe3JldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCl9ZWxzZSBpZihhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCl7cmV0dXJuIHRydWV9ZWxzZSBpZihleHBlY3RlZC5jYWxsKHt9LGFjdHVhbCk9PT10cnVlKXtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9ZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdyxibG9jayxleHBlY3RlZCxtZXNzYWdlKXt2YXIgYWN0dWFsO2lmKHV0aWwuaXNTdHJpbmcoZXhwZWN0ZWQpKXttZXNzYWdlPWV4cGVjdGVkO2V4cGVjdGVkPW51bGx9dHJ5e2Jsb2NrKCl9Y2F0Y2goZSl7YWN0dWFsPWV9bWVzc2FnZT0oZXhwZWN0ZWQmJmV4cGVjdGVkLm5hbWU/XCIgKFwiK2V4cGVjdGVkLm5hbWUrXCIpLlwiOlwiLlwiKSsobWVzc2FnZT9cIiBcIittZXNzYWdlOlwiLlwiKTtpZihzaG91bGRUaHJvdyYmIWFjdHVhbCl7ZmFpbChhY3R1YWwsZXhwZWN0ZWQsXCJNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvblwiK21lc3NhZ2UpfWlmKCFzaG91bGRUaHJvdyYmZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLGV4cGVjdGVkKSl7ZmFpbChhY3R1YWwsZXhwZWN0ZWQsXCJHb3QgdW53YW50ZWQgZXhjZXB0aW9uXCIrbWVzc2FnZSl9aWYoc2hvdWxkVGhyb3cmJmFjdHVhbCYmZXhwZWN0ZWQmJiFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsZXhwZWN0ZWQpfHwhc2hvdWxkVGhyb3cmJmFjdHVhbCl7dGhyb3cgYWN0dWFsfX1hc3NlcnQudGhyb3dzPWZ1bmN0aW9uKGJsb2NrLGVycm9yLG1lc3NhZ2Upe190aHJvd3MuYXBwbHkodGhpcyxbdHJ1ZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKX07YXNzZXJ0LmRvZXNOb3RUaHJvdz1mdW5jdGlvbihibG9jayxtZXNzYWdlKXtfdGhyb3dzLmFwcGx5KHRoaXMsW2ZhbHNlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpfTthc3NlcnQuaWZFcnJvcj1mdW5jdGlvbihlcnIpe2lmKGVycil7dGhyb3cgZXJyfX07dmFyIG9iamVjdEtleXM9T2JqZWN0LmtleXN8fGZ1bmN0aW9uKG9iail7dmFyIGtleXM9W107Zm9yKHZhciBrZXkgaW4gb2JqKXtpZihoYXNPd24uY2FsbChvYmosa2V5KSlrZXlzLnB1c2goa2V5KX1yZXR1cm4ga2V5c319LHtcInV0aWwvXCI6M31dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uIGlzQnVmZmVyKGFyZyl7cmV0dXJuIGFyZyYmdHlwZW9mIGFyZz09PVwib2JqZWN0XCImJnR5cGVvZiBhcmcuY29weT09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIGFyZy5maWxsPT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgYXJnLnJlYWRVSW50OD09PVwiZnVuY3Rpb25cIn19LHt9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocHJvY2VzcyxnbG9iYWwpe3ZhciBmb3JtYXRSZWdFeHA9LyVbc2RqJV0vZztleHBvcnRzLmZvcm1hdD1mdW5jdGlvbihmKXtpZighaXNTdHJpbmcoZikpe3ZhciBvYmplY3RzPVtdO2Zvcih2YXIgaT0wO2k8YXJndW1lbnRzLmxlbmd0aDtpKyspe29iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpfXJldHVybiBvYmplY3RzLmpvaW4oXCIgXCIpfXZhciBpPTE7dmFyIGFyZ3M9YXJndW1lbnRzO3ZhciBsZW49YXJncy5sZW5ndGg7dmFyIHN0cj1TdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsZnVuY3Rpb24oeCl7aWYoeD09PVwiJSVcIilyZXR1cm5cIiVcIjtpZihpPj1sZW4pcmV0dXJuIHg7c3dpdGNoKHgpe2Nhc2VcIiVzXCI6cmV0dXJuIFN0cmluZyhhcmdzW2krK10pO2Nhc2VcIiVkXCI6cmV0dXJuIE51bWJlcihhcmdzW2krK10pO2Nhc2VcIiVqXCI6dHJ5e3JldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pfWNhdGNoKF8pe3JldHVyblwiW0NpcmN1bGFyXVwifWRlZmF1bHQ6cmV0dXJuIHh9fSk7Zm9yKHZhciB4PWFyZ3NbaV07aTxsZW47eD1hcmdzWysraV0pe2lmKGlzTnVsbCh4KXx8IWlzT2JqZWN0KHgpKXtzdHIrPVwiIFwiK3h9ZWxzZXtzdHIrPVwiIFwiK2luc3BlY3QoeCl9fXJldHVybiBzdHJ9O2V4cG9ydHMuZGVwcmVjYXRlPWZ1bmN0aW9uKGZuLG1zZyl7aWYoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sbXNnKS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fWlmKHByb2Nlc3Mubm9EZXByZWNhdGlvbj09PXRydWUpe3JldHVybiBmbn12YXIgd2FybmVkPWZhbHNlO2Z1bmN0aW9uIGRlcHJlY2F0ZWQoKXtpZighd2FybmVkKXtpZihwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pe3Rocm93IG5ldyBFcnJvcihtc2cpfWVsc2UgaWYocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKXtjb25zb2xlLnRyYWNlKG1zZyl9ZWxzZXtjb25zb2xlLmVycm9yKG1zZyl9d2FybmVkPXRydWV9cmV0dXJuIGZuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gZGVwcmVjYXRlZH07dmFyIGRlYnVncz17fTt2YXIgZGVidWdFbnZpcm9uO2V4cG9ydHMuZGVidWdsb2c9ZnVuY3Rpb24oc2V0KXtpZihpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKWRlYnVnRW52aXJvbj1wcm9jZXNzLmVudi5OT0RFX0RFQlVHfHxcIlwiO3NldD1zZXQudG9VcHBlckNhc2UoKTtpZighZGVidWdzW3NldF0pe2lmKG5ldyBSZWdFeHAoXCJcXFxcYlwiK3NldCtcIlxcXFxiXCIsXCJpXCIpLnRlc3QoZGVidWdFbnZpcm9uKSl7dmFyIHBpZD1wcm9jZXNzLnBpZDtkZWJ1Z3Nbc2V0XT1mdW5jdGlvbigpe3ZhciBtc2c9ZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpO2NvbnNvbGUuZXJyb3IoXCIlcyAlZDogJXNcIixzZXQscGlkLG1zZyl9fWVsc2V7ZGVidWdzW3NldF09ZnVuY3Rpb24oKXt9fX1yZXR1cm4gZGVidWdzW3NldF19O2Z1bmN0aW9uIGluc3BlY3Qob2JqLG9wdHMpe3ZhciBjdHg9e3NlZW46W10sc3R5bGl6ZTpzdHlsaXplTm9Db2xvcn07aWYoYXJndW1lbnRzLmxlbmd0aD49MyljdHguZGVwdGg9YXJndW1lbnRzWzJdO2lmKGFyZ3VtZW50cy5sZW5ndGg+PTQpY3R4LmNvbG9ycz1hcmd1bWVudHNbM107aWYoaXNCb29sZWFuKG9wdHMpKXtjdHguc2hvd0hpZGRlbj1vcHRzfWVsc2UgaWYob3B0cyl7ZXhwb3J0cy5fZXh0ZW5kKGN0eCxvcHRzKX1pZihpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpY3R4LnNob3dIaWRkZW49ZmFsc2U7aWYoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSljdHguZGVwdGg9MjtpZihpc1VuZGVmaW5lZChjdHguY29sb3JzKSljdHguY29sb3JzPWZhbHNlO2lmKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSljdHguY3VzdG9tSW5zcGVjdD10cnVlO2lmKGN0eC5jb2xvcnMpY3R4LnN0eWxpemU9c3R5bGl6ZVdpdGhDb2xvcjtyZXR1cm4gZm9ybWF0VmFsdWUoY3R4LG9iaixjdHguZGVwdGgpfWV4cG9ydHMuaW5zcGVjdD1pbnNwZWN0O2luc3BlY3QuY29sb3JzPXtib2xkOlsxLDIyXSxpdGFsaWM6WzMsMjNdLHVuZGVybGluZTpbNCwyNF0saW52ZXJzZTpbNywyN10sd2hpdGU6WzM3LDM5XSxncmV5Ols5MCwzOV0sYmxhY2s6WzMwLDM5XSxibHVlOlszNCwzOV0sY3lhbjpbMzYsMzldLGdyZWVuOlszMiwzOV0sbWFnZW50YTpbMzUsMzldLHJlZDpbMzEsMzldLHllbGxvdzpbMzMsMzldfTtpbnNwZWN0LnN0eWxlcz17c3BlY2lhbDpcImN5YW5cIixudW1iZXI6XCJ5ZWxsb3dcIixcImJvb2xlYW5cIjpcInllbGxvd1wiLHVuZGVmaW5lZDpcImdyZXlcIixcIm51bGxcIjpcImJvbGRcIixzdHJpbmc6XCJncmVlblwiLGRhdGU6XCJtYWdlbnRhXCIscmVnZXhwOlwicmVkXCJ9O2Z1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLHN0eWxlVHlwZSl7dmFyIHN0eWxlPWluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07aWYoc3R5bGUpe3JldHVyblwiXHUwMDFiW1wiK2luc3BlY3QuY29sb3JzW3N0eWxlXVswXStcIm1cIitzdHIrXCJcdTAwMWJbXCIraW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdK1wibVwifWVsc2V7cmV0dXJuIHN0cn19ZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLHN0eWxlVHlwZSl7cmV0dXJuIHN0cn1mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSl7dmFyIGhhc2g9e307YXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsaWR4KXtoYXNoW3ZhbF09dHJ1ZX0pO3JldHVybiBoYXNofWZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCx2YWx1ZSxyZWN1cnNlVGltZXMpe2lmKGN0eC5jdXN0b21JbnNwZWN0JiZ2YWx1ZSYmaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSYmdmFsdWUuaW5zcGVjdCE9PWV4cG9ydHMuaW5zcGVjdCYmISh2YWx1ZS5jb25zdHJ1Y3RvciYmdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlPT09dmFsdWUpKXt2YXIgcmV0PXZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLGN0eCk7aWYoIWlzU3RyaW5nKHJldCkpe3JldD1mb3JtYXRWYWx1ZShjdHgscmV0LHJlY3Vyc2VUaW1lcyl9cmV0dXJuIHJldH12YXIgcHJpbWl0aXZlPWZvcm1hdFByaW1pdGl2ZShjdHgsdmFsdWUpO2lmKHByaW1pdGl2ZSl7cmV0dXJuIHByaW1pdGl2ZX12YXIga2V5cz1PYmplY3Qua2V5cyh2YWx1ZSk7dmFyIHZpc2libGVLZXlzPWFycmF5VG9IYXNoKGtleXMpO2lmKGN0eC5zaG93SGlkZGVuKXtrZXlzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKX1pZihpc0Vycm9yKHZhbHVlKSYmKGtleXMuaW5kZXhPZihcIm1lc3NhZ2VcIik+PTB8fGtleXMuaW5kZXhPZihcImRlc2NyaXB0aW9uXCIpPj0wKSl7cmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKX1pZihrZXlzLmxlbmd0aD09PTApe2lmKGlzRnVuY3Rpb24odmFsdWUpKXt2YXIgbmFtZT12YWx1ZS5uYW1lP1wiOiBcIit2YWx1ZS5uYW1lOlwiXCI7cmV0dXJuIGN0eC5zdHlsaXplKFwiW0Z1bmN0aW9uXCIrbmFtZStcIl1cIixcInNwZWNpYWxcIil9aWYoaXNSZWdFeHAodmFsdWUpKXtyZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSxcInJlZ2V4cFwiKX1pZihpc0RhdGUodmFsdWUpKXtyZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksXCJkYXRlXCIpfWlmKGlzRXJyb3IodmFsdWUpKXtyZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpfX12YXIgYmFzZT1cIlwiLGFycmF5PWZhbHNlLGJyYWNlcz1bXCJ7XCIsXCJ9XCJdO2lmKGlzQXJyYXkodmFsdWUpKXthcnJheT10cnVlO2JyYWNlcz1bXCJbXCIsXCJdXCJdfWlmKGlzRnVuY3Rpb24odmFsdWUpKXt2YXIgbj12YWx1ZS5uYW1lP1wiOiBcIit2YWx1ZS5uYW1lOlwiXCI7YmFzZT1cIiBbRnVuY3Rpb25cIituK1wiXVwifWlmKGlzUmVnRXhwKHZhbHVlKSl7YmFzZT1cIiBcIitSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpfWlmKGlzRGF0ZSh2YWx1ZSkpe2Jhc2U9XCIgXCIrRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSl9aWYoaXNFcnJvcih2YWx1ZSkpe2Jhc2U9XCIgXCIrZm9ybWF0RXJyb3IodmFsdWUpfWlmKGtleXMubGVuZ3RoPT09MCYmKCFhcnJheXx8dmFsdWUubGVuZ3RoPT0wKSl7cmV0dXJuIGJyYWNlc1swXStiYXNlK2JyYWNlc1sxXX1pZihyZWN1cnNlVGltZXM8MCl7aWYoaXNSZWdFeHAodmFsdWUpKXtyZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSxcInJlZ2V4cFwiKX1lbHNle3JldHVybiBjdHguc3R5bGl6ZShcIltPYmplY3RdXCIsXCJzcGVjaWFsXCIpfX1jdHguc2Vlbi5wdXNoKHZhbHVlKTt2YXIgb3V0cHV0O2lmKGFycmF5KXtvdXRwdXQ9Zm9ybWF0QXJyYXkoY3R4LHZhbHVlLHJlY3Vyc2VUaW1lcyx2aXNpYmxlS2V5cyxrZXlzKX1lbHNle291dHB1dD1rZXlzLm1hcChmdW5jdGlvbihrZXkpe3JldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsdmFsdWUscmVjdXJzZVRpbWVzLHZpc2libGVLZXlzLGtleSxhcnJheSl9KX1jdHguc2Vlbi5wb3AoKTtyZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LGJhc2UsYnJhY2VzKX1mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LHZhbHVlKXtpZihpc1VuZGVmaW5lZCh2YWx1ZSkpcmV0dXJuIGN0eC5zdHlsaXplKFwidW5kZWZpbmVkXCIsXCJ1bmRlZmluZWRcIik7aWYoaXNTdHJpbmcodmFsdWUpKXt2YXIgc2ltcGxlPVwiJ1wiK0pTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csXCJcIikucmVwbGFjZSgvJy9nLFwiXFxcXCdcIikucmVwbGFjZSgvXFxcXFwiL2csJ1wiJykrXCInXCI7cmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSxcInN0cmluZ1wiKX1pZihpc051bWJlcih2YWx1ZSkpcmV0dXJuIGN0eC5zdHlsaXplKFwiXCIrdmFsdWUsXCJudW1iZXJcIik7aWYoaXNCb29sZWFuKHZhbHVlKSlyZXR1cm4gY3R4LnN0eWxpemUoXCJcIit2YWx1ZSxcImJvb2xlYW5cIik7aWYoaXNOdWxsKHZhbHVlKSlyZXR1cm4gY3R4LnN0eWxpemUoXCJudWxsXCIsXCJudWxsXCIpfWZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKXtyZXR1cm5cIltcIitFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkrXCJdXCJ9ZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LHZhbHVlLHJlY3Vyc2VUaW1lcyx2aXNpYmxlS2V5cyxrZXlzKXt2YXIgb3V0cHV0PVtdO2Zvcih2YXIgaT0wLGw9dmFsdWUubGVuZ3RoO2k8bDsrK2kpe2lmKGhhc093blByb3BlcnR5KHZhbHVlLFN0cmluZyhpKSkpe291dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCx2YWx1ZSxyZWN1cnNlVGltZXMsdmlzaWJsZUtleXMsU3RyaW5nKGkpLHRydWUpKX1lbHNle291dHB1dC5wdXNoKFwiXCIpfX1rZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KXtpZigha2V5Lm1hdGNoKC9eXFxkKyQvKSl7b3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LHZhbHVlLHJlY3Vyc2VUaW1lcyx2aXNpYmxlS2V5cyxrZXksdHJ1ZSkpfX0pO3JldHVybiBvdXRwdXR9ZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LHZhbHVlLHJlY3Vyc2VUaW1lcyx2aXNpYmxlS2V5cyxrZXksYXJyYXkpe3ZhciBuYW1lLHN0cixkZXNjO2Rlc2M9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSxrZXkpfHx7dmFsdWU6dmFsdWVba2V5XX07aWYoZGVzYy5nZXQpe2lmKGRlc2Muc2V0KXtzdHI9Y3R4LnN0eWxpemUoXCJbR2V0dGVyL1NldHRlcl1cIixcInNwZWNpYWxcIil9ZWxzZXtzdHI9Y3R4LnN0eWxpemUoXCJbR2V0dGVyXVwiLFwic3BlY2lhbFwiKX19ZWxzZXtpZihkZXNjLnNldCl7c3RyPWN0eC5zdHlsaXplKFwiW1NldHRlcl1cIixcInNwZWNpYWxcIil9fWlmKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cyxrZXkpKXtuYW1lPVwiW1wiK2tleStcIl1cIn1pZighc3RyKXtpZihjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpPDApe2lmKGlzTnVsbChyZWN1cnNlVGltZXMpKXtzdHI9Zm9ybWF0VmFsdWUoY3R4LGRlc2MudmFsdWUsbnVsbCl9ZWxzZXtzdHI9Zm9ybWF0VmFsdWUoY3R4LGRlc2MudmFsdWUscmVjdXJzZVRpbWVzLTEpfWlmKHN0ci5pbmRleE9mKFwiXFxuXCIpPi0xKXtpZihhcnJheSl7c3RyPXN0ci5zcGxpdChcIlxcblwiKS5tYXAoZnVuY3Rpb24obGluZSl7cmV0dXJuXCIgIFwiK2xpbmV9KS5qb2luKFwiXFxuXCIpLnN1YnN0cigyKX1lbHNle3N0cj1cIlxcblwiK3N0ci5zcGxpdChcIlxcblwiKS5tYXAoZnVuY3Rpb24obGluZSl7cmV0dXJuXCIgICBcIitsaW5lfSkuam9pbihcIlxcblwiKX19fWVsc2V7c3RyPWN0eC5zdHlsaXplKFwiW0NpcmN1bGFyXVwiLFwic3BlY2lhbFwiKX19aWYoaXNVbmRlZmluZWQobmFtZSkpe2lmKGFycmF5JiZrZXkubWF0Y2goL15cXGQrJC8pKXtyZXR1cm4gc3RyfW5hbWU9SlNPTi5zdHJpbmdpZnkoXCJcIitrZXkpO2lmKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKXtuYW1lPW5hbWUuc3Vic3RyKDEsbmFtZS5sZW5ndGgtMik7bmFtZT1jdHguc3R5bGl6ZShuYW1lLFwibmFtZVwiKX1lbHNle25hbWU9bmFtZS5yZXBsYWNlKC8nL2csXCJcXFxcJ1wiKS5yZXBsYWNlKC9cXFxcXCIvZywnXCInKS5yZXBsYWNlKC8oXlwifFwiJCkvZyxcIidcIik7bmFtZT1jdHguc3R5bGl6ZShuYW1lLFwic3RyaW5nXCIpfX1yZXR1cm4gbmFtZStcIjogXCIrc3RyfWZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCxiYXNlLGJyYWNlcyl7dmFyIG51bUxpbmVzRXN0PTA7dmFyIGxlbmd0aD1vdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsY3VyKXtudW1MaW5lc0VzdCsrO2lmKGN1ci5pbmRleE9mKFwiXFxuXCIpPj0wKW51bUxpbmVzRXN0Kys7cmV0dXJuIHByZXYrY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLFwiXCIpLmxlbmd0aCsxfSwwKTtpZihsZW5ndGg+NjApe3JldHVybiBicmFjZXNbMF0rKGJhc2U9PT1cIlwiP1wiXCI6YmFzZStcIlxcbiBcIikrXCIgXCIrb3V0cHV0LmpvaW4oXCIsXFxuICBcIikrXCIgXCIrYnJhY2VzWzFdfXJldHVybiBicmFjZXNbMF0rYmFzZStcIiBcIitvdXRwdXQuam9pbihcIiwgXCIpK1wiIFwiK2JyYWNlc1sxXX1mdW5jdGlvbiBpc0FycmF5KGFyKXtyZXR1cm4gQXJyYXkuaXNBcnJheShhcil9ZXhwb3J0cy5pc0FycmF5PWlzQXJyYXk7ZnVuY3Rpb24gaXNCb29sZWFuKGFyZyl7cmV0dXJuIHR5cGVvZiBhcmc9PT1cImJvb2xlYW5cIn1leHBvcnRzLmlzQm9vbGVhbj1pc0Jvb2xlYW47ZnVuY3Rpb24gaXNOdWxsKGFyZyl7cmV0dXJuIGFyZz09PW51bGx9ZXhwb3J0cy5pc051bGw9aXNOdWxsO2Z1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZyl7cmV0dXJuIGFyZz09bnVsbH1leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkPWlzTnVsbE9yVW5kZWZpbmVkO2Z1bmN0aW9uIGlzTnVtYmVyKGFyZyl7cmV0dXJuIHR5cGVvZiBhcmc9PT1cIm51bWJlclwifWV4cG9ydHMuaXNOdW1iZXI9aXNOdW1iZXI7ZnVuY3Rpb24gaXNTdHJpbmcoYXJnKXtyZXR1cm4gdHlwZW9mIGFyZz09PVwic3RyaW5nXCJ9ZXhwb3J0cy5pc1N0cmluZz1pc1N0cmluZztmdW5jdGlvbiBpc1N5bWJvbChhcmcpe3JldHVybiB0eXBlb2YgYXJnPT09XCJzeW1ib2xcIn1leHBvcnRzLmlzU3ltYm9sPWlzU3ltYm9sO2Z1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZyl7cmV0dXJuIGFyZz09PXZvaWQgMH1leHBvcnRzLmlzVW5kZWZpbmVkPWlzVW5kZWZpbmVkO2Z1bmN0aW9uIGlzUmVnRXhwKHJlKXtyZXR1cm4gaXNPYmplY3QocmUpJiZvYmplY3RUb1N0cmluZyhyZSk9PT1cIltvYmplY3QgUmVnRXhwXVwifWV4cG9ydHMuaXNSZWdFeHA9aXNSZWdFeHA7ZnVuY3Rpb24gaXNPYmplY3QoYXJnKXtyZXR1cm4gdHlwZW9mIGFyZz09PVwib2JqZWN0XCImJmFyZyE9PW51bGx9ZXhwb3J0cy5pc09iamVjdD1pc09iamVjdDtmdW5jdGlvbiBpc0RhdGUoZCl7cmV0dXJuIGlzT2JqZWN0KGQpJiZvYmplY3RUb1N0cmluZyhkKT09PVwiW29iamVjdCBEYXRlXVwifWV4cG9ydHMuaXNEYXRlPWlzRGF0ZTtmdW5jdGlvbiBpc0Vycm9yKGUpe3JldHVybiBpc09iamVjdChlKSYmKG9iamVjdFRvU3RyaW5nKGUpPT09XCJbb2JqZWN0IEVycm9yXVwifHxlIGluc3RhbmNlb2YgRXJyb3IpfWV4cG9ydHMuaXNFcnJvcj1pc0Vycm9yO2Z1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKXtyZXR1cm4gdHlwZW9mIGFyZz09PVwiZnVuY3Rpb25cIn1leHBvcnRzLmlzRnVuY3Rpb249aXNGdW5jdGlvbjtmdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpe3JldHVybiBhcmc9PT1udWxsfHx0eXBlb2YgYXJnPT09XCJib29sZWFuXCJ8fHR5cGVvZiBhcmc9PT1cIm51bWJlclwifHx0eXBlb2YgYXJnPT09XCJzdHJpbmdcInx8dHlwZW9mIGFyZz09PVwic3ltYm9sXCJ8fHR5cGVvZiBhcmc9PT1cInVuZGVmaW5lZFwifWV4cG9ydHMuaXNQcmltaXRpdmU9aXNQcmltaXRpdmU7ZXhwb3J0cy5pc0J1ZmZlcj1fZGVyZXFfKFwiLi9zdXBwb3J0L2lzQnVmZmVyXCIpO2Z1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyl9ZnVuY3Rpb24gcGFkKG4pe3JldHVybiBuPDEwP1wiMFwiK24udG9TdHJpbmcoMTApOm4udG9TdHJpbmcoMTApfXZhciBtb250aHM9W1wiSmFuXCIsXCJGZWJcIixcIk1hclwiLFwiQXByXCIsXCJNYXlcIixcIkp1blwiLFwiSnVsXCIsXCJBdWdcIixcIlNlcFwiLFwiT2N0XCIsXCJOb3ZcIixcIkRlY1wiXTtmdW5jdGlvbiB0aW1lc3RhbXAoKXt2YXIgZD1uZXcgRGF0ZTt2YXIgdGltZT1bcGFkKGQuZ2V0SG91cnMoKSkscGFkKGQuZ2V0TWludXRlcygpKSxwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKFwiOlwiKTtyZXR1cm5bZC5nZXREYXRlKCksbW9udGhzW2QuZ2V0TW9udGgoKV0sdGltZV0uam9pbihcIiBcIil9ZXhwb3J0cy5sb2c9ZnVuY3Rpb24oKXtjb25zb2xlLmxvZyhcIiVzIC0gJXNcIix0aW1lc3RhbXAoKSxleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLGFyZ3VtZW50cykpfTtleHBvcnRzLmluaGVyaXRzPV9kZXJlcV8oXCJpbmhlcml0c1wiKTtleHBvcnRzLl9leHRlbmQ9ZnVuY3Rpb24ob3JpZ2luLGFkZCl7aWYoIWFkZHx8IWlzT2JqZWN0KGFkZCkpcmV0dXJuIG9yaWdpbjt2YXIga2V5cz1PYmplY3Qua2V5cyhhZGQpO3ZhciBpPWtleXMubGVuZ3RoO3doaWxlKGktLSl7b3JpZ2luW2tleXNbaV1dPWFkZFtrZXlzW2ldXX1yZXR1cm4gb3JpZ2lufTtmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmoscHJvcCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmoscHJvcCl9fSkuY2FsbCh0aGlzLF9kZXJlcV8oXCJGV2FBU0hcIiksdHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93Ont9KX0se1wiLi9zdXBwb3J0L2lzQnVmZmVyXCI6MixGV2FBU0g6MTUsaW5oZXJpdHM6MTR9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt9LHt9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgYmFzZTY0PV9kZXJlcV8oXCJiYXNlNjQtanNcIik7dmFyIGllZWU3NTQ9X2RlcmVxXyhcImllZWU3NTRcIik7ZXhwb3J0cy5CdWZmZXI9QnVmZmVyO2V4cG9ydHMuU2xvd0J1ZmZlcj1CdWZmZXI7ZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUz01MDtCdWZmZXIucG9vbFNpemU9ODE5MjtCdWZmZXIuX3VzZVR5cGVkQXJyYXlzPWZ1bmN0aW9uKCl7dHJ5e3ZhciBidWY9bmV3IEFycmF5QnVmZmVyKDApO3ZhciBhcnI9bmV3IFVpbnQ4QXJyYXkoYnVmKTthcnIuZm9vPWZ1bmN0aW9uKCl7cmV0dXJuIDQyfTtyZXR1cm4gNDI9PT1hcnIuZm9vKCkmJnR5cGVvZiBhcnIuc3ViYXJyYXk9PT1cImZ1bmN0aW9uXCJ9Y2F0Y2goZSl7cmV0dXJuIGZhbHNlfX0oKTtmdW5jdGlvbiBCdWZmZXIoc3ViamVjdCxlbmNvZGluZyxub1plcm8pe2lmKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCxlbmNvZGluZyxub1plcm8pO3ZhciB0eXBlPXR5cGVvZiBzdWJqZWN0O2lmKGVuY29kaW5nPT09XCJiYXNlNjRcIiYmdHlwZT09PVwic3RyaW5nXCIpe3N1YmplY3Q9c3RyaW5ndHJpbShzdWJqZWN0KTt3aGlsZShzdWJqZWN0Lmxlbmd0aCU0IT09MCl7c3ViamVjdD1zdWJqZWN0K1wiPVwifX12YXIgbGVuZ3RoO2lmKHR5cGU9PT1cIm51bWJlclwiKWxlbmd0aD1jb2VyY2Uoc3ViamVjdCk7ZWxzZSBpZih0eXBlPT09XCJzdHJpbmdcIilsZW5ndGg9QnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCxlbmNvZGluZyk7ZWxzZSBpZih0eXBlPT09XCJvYmplY3RcIilsZW5ndGg9Y29lcmNlKHN1YmplY3QubGVuZ3RoKTtlbHNlIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCBhcnJheSBvciBzdHJpbmcuXCIpO3ZhciBidWY7aWYoQnVmZmVyLl91c2VUeXBlZEFycmF5cyl7YnVmPUJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKX1lbHNle2J1Zj10aGlzO2J1Zi5sZW5ndGg9bGVuZ3RoO2J1Zi5faXNCdWZmZXI9dHJ1ZX12YXIgaTtpZihCdWZmZXIuX3VzZVR5cGVkQXJyYXlzJiZ0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoPT09XCJudW1iZXJcIil7YnVmLl9zZXQoc3ViamVjdCl9ZWxzZSBpZihpc0FycmF5aXNoKHN1YmplY3QpKXtpZihCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpe2ZvcihpPTA7aTxsZW5ndGg7aSsrKWJ1ZltpXT1zdWJqZWN0LnJlYWRVSW50OChpKX1lbHNle2ZvcihpPTA7aTxsZW5ndGg7aSsrKWJ1ZltpXT0oc3ViamVjdFtpXSUyNTYrMjU2KSUyNTZ9fWVsc2UgaWYodHlwZT09PVwic3RyaW5nXCIpe2J1Zi53cml0ZShzdWJqZWN0LDAsZW5jb2RpbmcpfWVsc2UgaWYodHlwZT09PVwibnVtYmVyXCImJiFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzJiYhbm9aZXJvKXtmb3IoaT0wO2k8bGVuZ3RoO2krKyl7YnVmW2ldPTB9fXJldHVybiBidWZ9QnVmZmVyLmlzRW5jb2Rpbmc9ZnVuY3Rpb24oZW5jb2Rpbmcpe3N3aXRjaChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpe2Nhc2VcImhleFwiOmNhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwiYmFzZTY0XCI6Y2FzZVwicmF3XCI6Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHRydWU7ZGVmYXVsdDpyZXR1cm4gZmFsc2V9fTtCdWZmZXIuaXNCdWZmZXI9ZnVuY3Rpb24oYil7cmV0dXJuISEoYiE9PW51bGwmJmIhPT11bmRlZmluZWQmJmIuX2lzQnVmZmVyKX07QnVmZmVyLmJ5dGVMZW5ndGg9ZnVuY3Rpb24oc3RyLGVuY29kaW5nKXt2YXIgcmV0O3N0cj1zdHIudG9TdHJpbmcoKTtzd2l0Y2goZW5jb2Rpbmd8fFwidXRmOFwiKXtjYXNlXCJoZXhcIjpyZXQ9c3RyLmxlbmd0aC8yO2JyZWFrO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldD11dGY4VG9CeXRlcyhzdHIpLmxlbmd0aDticmVhaztjYXNlXCJhc2NpaVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcInJhd1wiOnJldD1zdHIubGVuZ3RoO2JyZWFrO2Nhc2VcImJhc2U2NFwiOnJldD1iYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoO2JyZWFrO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldD1zdHIubGVuZ3RoKjI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVuY29kaW5nXCIpfXJldHVybiByZXR9O0J1ZmZlci5jb25jYXQ9ZnVuY3Rpb24obGlzdCx0b3RhbExlbmd0aCl7YXNzZXJ0KGlzQXJyYXkobGlzdCksXCJVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0WywgbGVuZ3RoXSlcIik7aWYobGlzdC5sZW5ndGg9PT0wKXtyZXR1cm4gbmV3IEJ1ZmZlcigwKX1lbHNlIGlmKGxpc3QubGVuZ3RoPT09MSl7cmV0dXJuIGxpc3RbMF19dmFyIGk7aWYodG90YWxMZW5ndGg9PT11bmRlZmluZWQpe3RvdGFsTGVuZ3RoPTA7Zm9yKGk9MDtpPGxpc3QubGVuZ3RoO2krKyl7dG90YWxMZW5ndGgrPWxpc3RbaV0ubGVuZ3RofX12YXIgYnVmPW5ldyBCdWZmZXIodG90YWxMZW5ndGgpO3ZhciBwb3M9MDtmb3IoaT0wO2k8bGlzdC5sZW5ndGg7aSsrKXt2YXIgaXRlbT1saXN0W2ldO2l0ZW0uY29weShidWYscG9zKTtwb3MrPWl0ZW0ubGVuZ3RofXJldHVybiBidWZ9O0J1ZmZlci5jb21wYXJlPWZ1bmN0aW9uKGEsYil7YXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihhKSYmQnVmZmVyLmlzQnVmZmVyKGIpLFwiQXJndW1lbnRzIG11c3QgYmUgQnVmZmVyc1wiKTt2YXIgeD1hLmxlbmd0aDt2YXIgeT1iLmxlbmd0aDtmb3IodmFyIGk9MCxsZW49TWF0aC5taW4oeCx5KTtpPGxlbiYmYVtpXT09PWJbaV07aSsrKXt9aWYoaSE9PWxlbil7eD1hW2ldO3k9YltpXX1pZih4PHkpe3JldHVybi0xfWlmKHk8eCl7cmV0dXJuIDF9cmV0dXJuIDB9O2Z1bmN0aW9uIGhleFdyaXRlKGJ1ZixzdHJpbmcsb2Zmc2V0LGxlbmd0aCl7b2Zmc2V0PU51bWJlcihvZmZzZXQpfHwwO3ZhciByZW1haW5pbmc9YnVmLmxlbmd0aC1vZmZzZXQ7aWYoIWxlbmd0aCl7bGVuZ3RoPXJlbWFpbmluZ31lbHNle2xlbmd0aD1OdW1iZXIobGVuZ3RoKTtpZihsZW5ndGg+cmVtYWluaW5nKXtsZW5ndGg9cmVtYWluaW5nfX12YXIgc3RyTGVuPXN0cmluZy5sZW5ndGg7YXNzZXJ0KHN0ckxlbiUyPT09MCxcIkludmFsaWQgaGV4IHN0cmluZ1wiKTtpZihsZW5ndGg+c3RyTGVuLzIpe2xlbmd0aD1zdHJMZW4vMn1mb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe3ZhciBieXRlPXBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSoyLDIpLDE2KTthc3NlcnQoIWlzTmFOKGJ5dGUpLFwiSW52YWxpZCBoZXggc3RyaW5nXCIpO2J1ZltvZmZzZXQraV09Ynl0ZX1yZXR1cm4gaX1mdW5jdGlvbiB1dGY4V3JpdGUoYnVmLHN0cmluZyxvZmZzZXQsbGVuZ3RoKXt2YXIgY2hhcnNXcml0dGVuPWJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSxidWYsb2Zmc2V0LGxlbmd0aCk7cmV0dXJuIGNoYXJzV3JpdHRlbn1mdW5jdGlvbiBhc2NpaVdyaXRlKGJ1ZixzdHJpbmcsb2Zmc2V0LGxlbmd0aCl7dmFyIGNoYXJzV3JpdHRlbj1ibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLGJ1ZixvZmZzZXQsbGVuZ3RoKTtyZXR1cm4gY2hhcnNXcml0dGVufWZ1bmN0aW9uIGJpbmFyeVdyaXRlKGJ1ZixzdHJpbmcsb2Zmc2V0LGxlbmd0aCl7cmV0dXJuIGFzY2lpV3JpdGUoYnVmLHN0cmluZyxvZmZzZXQsbGVuZ3RoKX1mdW5jdGlvbiBiYXNlNjRXcml0ZShidWYsc3RyaW5nLG9mZnNldCxsZW5ndGgpe3ZhciBjaGFyc1dyaXR0ZW49YmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksYnVmLG9mZnNldCxsZW5ndGgpO3JldHVybiBjaGFyc1dyaXR0ZW59ZnVuY3Rpb24gdXRmMTZsZVdyaXRlKGJ1ZixzdHJpbmcsb2Zmc2V0LGxlbmd0aCl7dmFyIGNoYXJzV3JpdHRlbj1ibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZyksYnVmLG9mZnNldCxsZW5ndGgpO3JldHVybiBjaGFyc1dyaXR0ZW59QnVmZmVyLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihzdHJpbmcsb2Zmc2V0LGxlbmd0aCxlbmNvZGluZyl7aWYoaXNGaW5pdGUob2Zmc2V0KSl7aWYoIWlzRmluaXRlKGxlbmd0aCkpe2VuY29kaW5nPWxlbmd0aDtsZW5ndGg9dW5kZWZpbmVkfX1lbHNle3ZhciBzd2FwPWVuY29kaW5nO2VuY29kaW5nPW9mZnNldDtvZmZzZXQ9bGVuZ3RoO2xlbmd0aD1zd2FwfW9mZnNldD1OdW1iZXIob2Zmc2V0KXx8MDt2YXIgcmVtYWluaW5nPXRoaXMubGVuZ3RoLW9mZnNldDtpZighbGVuZ3RoKXtsZW5ndGg9cmVtYWluaW5nfWVsc2V7bGVuZ3RoPU51bWJlcihsZW5ndGgpO2lmKGxlbmd0aD5yZW1haW5pbmcpe2xlbmd0aD1yZW1haW5pbmd9fWVuY29kaW5nPVN0cmluZyhlbmNvZGluZ3x8XCJ1dGY4XCIpLnRvTG93ZXJDYXNlKCk7dmFyIHJldDtzd2l0Y2goZW5jb2Rpbmcpe2Nhc2VcImhleFwiOnJldD1oZXhXcml0ZSh0aGlzLHN0cmluZyxvZmZzZXQsbGVuZ3RoKTticmVhaztjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXQ9dXRmOFdyaXRlKHRoaXMsc3RyaW5nLG9mZnNldCxsZW5ndGgpO2JyZWFrO2Nhc2VcImFzY2lpXCI6cmV0PWFzY2lpV3JpdGUodGhpcyxzdHJpbmcsb2Zmc2V0LGxlbmd0aCk7YnJlYWs7Y2FzZVwiYmluYXJ5XCI6cmV0PWJpbmFyeVdyaXRlKHRoaXMsc3RyaW5nLG9mZnNldCxsZW5ndGgpO2JyZWFrO2Nhc2VcImJhc2U2NFwiOnJldD1iYXNlNjRXcml0ZSh0aGlzLHN0cmluZyxvZmZzZXQsbGVuZ3RoKTticmVhaztjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXQ9dXRmMTZsZVdyaXRlKHRoaXMsc3RyaW5nLG9mZnNldCxsZW5ndGgpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBlbmNvZGluZ1wiKX1yZXR1cm4gcmV0fTtCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKGVuY29kaW5nLHN0YXJ0LGVuZCl7dmFyIHNlbGY9dGhpcztlbmNvZGluZz1TdHJpbmcoZW5jb2Rpbmd8fFwidXRmOFwiKS50b0xvd2VyQ2FzZSgpO3N0YXJ0PU51bWJlcihzdGFydCl8fDA7ZW5kPWVuZD09PXVuZGVmaW5lZD9zZWxmLmxlbmd0aDpOdW1iZXIoZW5kKTtpZihlbmQ9PT1zdGFydClyZXR1cm5cIlwiO3ZhciByZXQ7c3dpdGNoKGVuY29kaW5nKXtjYXNlXCJoZXhcIjpyZXQ9aGV4U2xpY2Uoc2VsZixzdGFydCxlbmQpO2JyZWFrO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldD11dGY4U2xpY2Uoc2VsZixzdGFydCxlbmQpO2JyZWFrO2Nhc2VcImFzY2lpXCI6cmV0PWFzY2lpU2xpY2Uoc2VsZixzdGFydCxlbmQpO2JyZWFrO2Nhc2VcImJpbmFyeVwiOnJldD1iaW5hcnlTbGljZShzZWxmLHN0YXJ0LGVuZCk7YnJlYWs7Y2FzZVwiYmFzZTY0XCI6cmV0PWJhc2U2NFNsaWNlKHNlbGYsc3RhcnQsZW5kKTticmVhaztjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXQ9dXRmMTZsZVNsaWNlKHNlbGYsc3RhcnQsZW5kKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVua25vd24gZW5jb2RpbmdcIil9cmV0dXJuIHJldH07QnVmZmVyLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpcIkJ1ZmZlclwiLGRhdGE6QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyfHx0aGlzLDApfX07QnVmZmVyLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24oYil7YXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihiKSxcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7cmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsYik9PT0wfTtCdWZmZXIucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24oYil7YXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihiKSxcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7cmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsYil9O0J1ZmZlci5wcm90b3R5cGUuY29weT1mdW5jdGlvbih0YXJnZXQsdGFyZ2V0X3N0YXJ0LHN0YXJ0LGVuZCl7dmFyIHNvdXJjZT10aGlzO2lmKCFzdGFydClzdGFydD0wO2lmKCFlbmQmJmVuZCE9PTApZW5kPXRoaXMubGVuZ3RoO2lmKCF0YXJnZXRfc3RhcnQpdGFyZ2V0X3N0YXJ0PTA7aWYoZW5kPT09c3RhcnQpcmV0dXJuO2lmKHRhcmdldC5sZW5ndGg9PT0wfHxzb3VyY2UubGVuZ3RoPT09MClyZXR1cm47YXNzZXJ0KGVuZD49c3RhcnQsXCJzb3VyY2VFbmQgPCBzb3VyY2VTdGFydFwiKTthc3NlcnQodGFyZ2V0X3N0YXJ0Pj0wJiZ0YXJnZXRfc3RhcnQ8dGFyZ2V0Lmxlbmd0aCxcInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHNcIik7YXNzZXJ0KHN0YXJ0Pj0wJiZzdGFydDxzb3VyY2UubGVuZ3RoLFwic291cmNlU3RhcnQgb3V0IG9mIGJvdW5kc1wiKTthc3NlcnQoZW5kPj0wJiZlbmQ8PXNvdXJjZS5sZW5ndGgsXCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kc1wiKTtpZihlbmQ+dGhpcy5sZW5ndGgpZW5kPXRoaXMubGVuZ3RoO2lmKHRhcmdldC5sZW5ndGgtdGFyZ2V0X3N0YXJ0PGVuZC1zdGFydCllbmQ9dGFyZ2V0Lmxlbmd0aC10YXJnZXRfc3RhcnQrc3RhcnQ7dmFyIGxlbj1lbmQtc3RhcnQ7aWYobGVuPDEwMHx8IUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpe2Zvcih2YXIgaT0wO2k8bGVuO2krKyl7dGFyZ2V0W2krdGFyZ2V0X3N0YXJ0XT10aGlzW2krc3RhcnRdfX1lbHNle3RhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsc3RhcnQrbGVuKSx0YXJnZXRfc3RhcnQpfX07ZnVuY3Rpb24gYmFzZTY0U2xpY2UoYnVmLHN0YXJ0LGVuZCl7aWYoc3RhcnQ9PT0wJiZlbmQ9PT1idWYubGVuZ3RoKXtyZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKX1lbHNle3JldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsZW5kKSl9fWZ1bmN0aW9uIHV0ZjhTbGljZShidWYsc3RhcnQsZW5kKXt2YXIgcmVzPVwiXCI7dmFyIHRtcD1cIlwiO2VuZD1NYXRoLm1pbihidWYubGVuZ3RoLGVuZCk7Zm9yKHZhciBpPXN0YXJ0O2k8ZW5kO2krKyl7aWYoYnVmW2ldPD0xMjcpe3Jlcys9ZGVjb2RlVXRmOENoYXIodG1wKStTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7dG1wPVwiXCJ9ZWxzZXt0bXArPVwiJVwiK2J1ZltpXS50b1N0cmluZygxNil9fXJldHVybiByZXMrZGVjb2RlVXRmOENoYXIodG1wKX1mdW5jdGlvbiBhc2NpaVNsaWNlKGJ1ZixzdGFydCxlbmQpe3ZhciByZXQ9XCJcIjtlbmQ9TWF0aC5taW4oYnVmLmxlbmd0aCxlbmQpO2Zvcih2YXIgaT1zdGFydDtpPGVuZDtpKyspe3JldCs9U3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pfXJldHVybiByZXR9ZnVuY3Rpb24gYmluYXJ5U2xpY2UoYnVmLHN0YXJ0LGVuZCl7cmV0dXJuIGFzY2lpU2xpY2UoYnVmLHN0YXJ0LGVuZCl9ZnVuY3Rpb24gaGV4U2xpY2UoYnVmLHN0YXJ0LGVuZCl7dmFyIGxlbj1idWYubGVuZ3RoO2lmKCFzdGFydHx8c3RhcnQ8MClzdGFydD0wO2lmKCFlbmR8fGVuZDwwfHxlbmQ+bGVuKWVuZD1sZW47dmFyIG91dD1cIlwiO2Zvcih2YXIgaT1zdGFydDtpPGVuZDtpKyspe291dCs9dG9IZXgoYnVmW2ldKX1yZXR1cm4gb3V0fWZ1bmN0aW9uIHV0ZjE2bGVTbGljZShidWYsc3RhcnQsZW5kKXt2YXIgYnl0ZXM9YnVmLnNsaWNlKHN0YXJ0LGVuZCk7dmFyIHJlcz1cIlwiO2Zvcih2YXIgaT0wO2k8Ynl0ZXMubGVuZ3RoO2krPTIpe3Jlcys9U3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXStieXRlc1tpKzFdKjI1Nil9cmV0dXJuIHJlc31CdWZmZXIucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKHN0YXJ0LGVuZCl7dmFyIGxlbj10aGlzLmxlbmd0aDtzdGFydD1jbGFtcChzdGFydCxsZW4sMCk7ZW5kPWNsYW1wKGVuZCxsZW4sbGVuKTtpZihCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKXtyZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsZW5kKSl9ZWxzZXt2YXIgc2xpY2VMZW49ZW5kLXN0YXJ0O3ZhciBuZXdCdWY9bmV3IEJ1ZmZlcihzbGljZUxlbix1bmRlZmluZWQsdHJ1ZSk7Zm9yKHZhciBpPTA7aTxzbGljZUxlbjtpKyspe25ld0J1ZltpXT10aGlzW2krc3RhcnRdfXJldHVybiBuZXdCdWZ9fTtCdWZmZXIucHJvdG90eXBlLmdldD1mdW5jdGlvbihvZmZzZXQpe2NvbnNvbGUubG9nKFwiLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuXCIpO3JldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpfTtCdWZmZXIucHJvdG90eXBlLnNldD1mdW5jdGlvbih2LG9mZnNldCl7Y29uc29sZS5sb2coXCIuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC5cIik7cmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LG9mZnNldCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uKG9mZnNldCxub0Fzc2VydCl7aWYoIW5vQXNzZXJ0KXthc3NlcnQob2Zmc2V0IT09dW5kZWZpbmVkJiZvZmZzZXQhPT1udWxsLFwibWlzc2luZyBvZmZzZXRcIik7YXNzZXJ0KG9mZnNldDx0aGlzLmxlbmd0aCxcIlRyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfWlmKG9mZnNldD49dGhpcy5sZW5ndGgpcmV0dXJuO3JldHVybiB0aGlzW29mZnNldF19O2Z1bmN0aW9uIHJlYWRVSW50MTYoYnVmLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpe2lmKCFub0Fzc2VydCl7YXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW49PT1cImJvb2xlYW5cIixcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cIik7YXNzZXJ0KG9mZnNldCE9PXVuZGVmaW5lZCYmb2Zmc2V0IT09bnVsbCxcIm1pc3Npbmcgb2Zmc2V0XCIpO2Fzc2VydChvZmZzZXQrMTxidWYubGVuZ3RoLFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIil9dmFyIGxlbj1idWYubGVuZ3RoO2lmKG9mZnNldD49bGVuKXJldHVybjt2YXIgdmFsO2lmKGxpdHRsZUVuZGlhbil7dmFsPWJ1ZltvZmZzZXRdO2lmKG9mZnNldCsxPGxlbil2YWx8PWJ1ZltvZmZzZXQrMV08PDh9ZWxzZXt2YWw9YnVmW29mZnNldF08PDg7aWYob2Zmc2V0KzE8bGVuKXZhbHw9YnVmW29mZnNldCsxXX1yZXR1cm4gdmFsfUJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFPWZ1bmN0aW9uKG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHJlYWRVSW50MTYodGhpcyxvZmZzZXQsdHJ1ZSxub0Fzc2VydCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFPWZ1bmN0aW9uKG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHJlYWRVSW50MTYodGhpcyxvZmZzZXQsZmFsc2Usbm9Bc3NlcnQpfTtmdW5jdGlvbiByZWFkVUludDMyKGJ1ZixvZmZzZXQsbGl0dGxlRW5kaWFuLG5vQXNzZXJ0KXtpZighbm9Bc3NlcnQpe2Fzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuPT09XCJib29sZWFuXCIsXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXCIpO2Fzc2VydChvZmZzZXQhPT11bmRlZmluZWQmJm9mZnNldCE9PW51bGwsXCJtaXNzaW5nIG9mZnNldFwiKTthc3NlcnQob2Zmc2V0KzM8YnVmLmxlbmd0aCxcIlRyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfXZhciBsZW49YnVmLmxlbmd0aDtpZihvZmZzZXQ+PWxlbilyZXR1cm47dmFyIHZhbDtpZihsaXR0bGVFbmRpYW4pe2lmKG9mZnNldCsyPGxlbil2YWw9YnVmW29mZnNldCsyXTw8MTY7aWYob2Zmc2V0KzE8bGVuKXZhbHw9YnVmW29mZnNldCsxXTw8ODt2YWx8PWJ1ZltvZmZzZXRdO2lmKG9mZnNldCszPGxlbil2YWw9dmFsKyhidWZbb2Zmc2V0KzNdPDwyND4+PjApfWVsc2V7aWYob2Zmc2V0KzE8bGVuKXZhbD1idWZbb2Zmc2V0KzFdPDwxNjtpZihvZmZzZXQrMjxsZW4pdmFsfD1idWZbb2Zmc2V0KzJdPDw4O2lmKG9mZnNldCszPGxlbil2YWx8PWJ1ZltvZmZzZXQrM107dmFsPXZhbCsoYnVmW29mZnNldF08PDI0Pj4+MCl9cmV0dXJuIHZhbH1CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRT1mdW5jdGlvbihvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiByZWFkVUludDMyKHRoaXMsb2Zmc2V0LHRydWUsbm9Bc3NlcnQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRT1mdW5jdGlvbihvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiByZWFkVUludDMyKHRoaXMsb2Zmc2V0LGZhbHNlLG5vQXNzZXJ0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OD1mdW5jdGlvbihvZmZzZXQsbm9Bc3NlcnQpe2lmKCFub0Fzc2VydCl7YXNzZXJ0KG9mZnNldCE9PXVuZGVmaW5lZCYmb2Zmc2V0IT09bnVsbCxcIm1pc3Npbmcgb2Zmc2V0XCIpO2Fzc2VydChvZmZzZXQ8dGhpcy5sZW5ndGgsXCJUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1pZihvZmZzZXQ+PXRoaXMubGVuZ3RoKXJldHVybjt2YXIgbmVnPXRoaXNbb2Zmc2V0XSYxMjg7aWYobmVnKXJldHVybigyNTUtdGhpc1tvZmZzZXRdKzEpKi0xO2Vsc2UgcmV0dXJuIHRoaXNbb2Zmc2V0XX07ZnVuY3Rpb24gcmVhZEludDE2KGJ1ZixvZmZzZXQsbGl0dGxlRW5kaWFuLG5vQXNzZXJ0KXtpZighbm9Bc3NlcnQpe2Fzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuPT09XCJib29sZWFuXCIsXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXCIpO2Fzc2VydChvZmZzZXQhPT11bmRlZmluZWQmJm9mZnNldCE9PW51bGwsXCJtaXNzaW5nIG9mZnNldFwiKTthc3NlcnQob2Zmc2V0KzE8YnVmLmxlbmd0aCxcIlRyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfXZhciBsZW49YnVmLmxlbmd0aDtpZihvZmZzZXQ+PWxlbilyZXR1cm47dmFyIHZhbD1yZWFkVUludDE2KGJ1ZixvZmZzZXQsbGl0dGxlRW5kaWFuLHRydWUpO3ZhciBuZWc9dmFsJjMyNzY4O2lmKG5lZylyZXR1cm4oNjU1MzUtdmFsKzEpKi0xO2Vsc2UgcmV0dXJuIHZhbH1CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFPWZ1bmN0aW9uKG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHJlYWRJbnQxNih0aGlzLG9mZnNldCx0cnVlLG5vQXNzZXJ0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRT1mdW5jdGlvbihvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiByZWFkSW50MTYodGhpcyxvZmZzZXQsZmFsc2Usbm9Bc3NlcnQpfTtmdW5jdGlvbiByZWFkSW50MzIoYnVmLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpe2lmKCFub0Fzc2VydCl7YXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW49PT1cImJvb2xlYW5cIixcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cIik7YXNzZXJ0KG9mZnNldCE9PXVuZGVmaW5lZCYmb2Zmc2V0IT09bnVsbCxcIm1pc3Npbmcgb2Zmc2V0XCIpO2Fzc2VydChvZmZzZXQrMzxidWYubGVuZ3RoLFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIil9dmFyIGxlbj1idWYubGVuZ3RoO2lmKG9mZnNldD49bGVuKXJldHVybjt2YXIgdmFsPXJlYWRVSW50MzIoYnVmLG9mZnNldCxsaXR0bGVFbmRpYW4sdHJ1ZSk7dmFyIG5lZz12YWwmMjE0NzQ4MzY0ODtpZihuZWcpcmV0dXJuKDQyOTQ5NjcyOTUtdmFsKzEpKi0xO2Vsc2UgcmV0dXJuIHZhbH1CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uKG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHJlYWRJbnQzMih0aGlzLG9mZnNldCx0cnVlLG5vQXNzZXJ0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRT1mdW5jdGlvbihvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiByZWFkSW50MzIodGhpcyxvZmZzZXQsZmFsc2Usbm9Bc3NlcnQpfTtmdW5jdGlvbiByZWFkRmxvYXQoYnVmLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpe2lmKCFub0Fzc2VydCl7YXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW49PT1cImJvb2xlYW5cIixcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cIik7YXNzZXJ0KG9mZnNldCszPGJ1Zi5sZW5ndGgsXCJUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1yZXR1cm4gaWVlZTc1NC5yZWFkKGJ1ZixvZmZzZXQsbGl0dGxlRW5kaWFuLDIzLDQpfUJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEU9ZnVuY3Rpb24ob2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gcmVhZEZsb2F0KHRoaXMsb2Zmc2V0LHRydWUsbm9Bc3NlcnQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFPWZ1bmN0aW9uKG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHJlYWRGbG9hdCh0aGlzLG9mZnNldCxmYWxzZSxub0Fzc2VydCl9O2Z1bmN0aW9uIHJlYWREb3VibGUoYnVmLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpe2lmKCFub0Fzc2VydCl7YXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW49PT1cImJvb2xlYW5cIixcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cIik7YXNzZXJ0KG9mZnNldCs3PGJ1Zi5sZW5ndGgsXCJUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1yZXR1cm4gaWVlZTc1NC5yZWFkKGJ1ZixvZmZzZXQsbGl0dGxlRW5kaWFuLDUyLDgpfUJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFPWZ1bmN0aW9uKG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHJlYWREb3VibGUodGhpcyxvZmZzZXQsdHJ1ZSxub0Fzc2VydCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFPWZ1bmN0aW9uKG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHJlYWREb3VibGUodGhpcyxvZmZzZXQsZmFsc2Usbm9Bc3NlcnQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24odmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXtpZighbm9Bc3NlcnQpe2Fzc2VydCh2YWx1ZSE9PXVuZGVmaW5lZCYmdmFsdWUhPT1udWxsLFwibWlzc2luZyB2YWx1ZVwiKTthc3NlcnQob2Zmc2V0IT09dW5kZWZpbmVkJiZvZmZzZXQhPT1udWxsLFwibWlzc2luZyBvZmZzZXRcIik7YXNzZXJ0KG9mZnNldDx0aGlzLmxlbmd0aCxcInRyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKTt2ZXJpZnVpbnQodmFsdWUsMjU1KX1pZihvZmZzZXQ+PXRoaXMubGVuZ3RoKXJldHVybjt0aGlzW29mZnNldF09dmFsdWU7cmV0dXJuIG9mZnNldCsxfTtmdW5jdGlvbiB3cml0ZVVJbnQxNihidWYsdmFsdWUsb2Zmc2V0LGxpdHRsZUVuZGlhbixub0Fzc2VydCl7aWYoIW5vQXNzZXJ0KXthc3NlcnQodmFsdWUhPT11bmRlZmluZWQmJnZhbHVlIT09bnVsbCxcIm1pc3NpbmcgdmFsdWVcIik7YXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW49PT1cImJvb2xlYW5cIixcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cIik7YXNzZXJ0KG9mZnNldCE9PXVuZGVmaW5lZCYmb2Zmc2V0IT09bnVsbCxcIm1pc3Npbmcgb2Zmc2V0XCIpO2Fzc2VydChvZmZzZXQrMTxidWYubGVuZ3RoLFwidHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpO3ZlcmlmdWludCh2YWx1ZSw2NTUzNSl9dmFyIGxlbj1idWYubGVuZ3RoO2lmKG9mZnNldD49bGVuKXJldHVybjtmb3IodmFyIGk9MCxqPU1hdGgubWluKGxlbi1vZmZzZXQsMik7aTxqO2krKyl7YnVmW29mZnNldCtpXT0odmFsdWUmMjU1PDw4KihsaXR0bGVFbmRpYW4/aToxLWkpKT4+PihsaXR0bGVFbmRpYW4/aToxLWkpKjh9cmV0dXJuIG9mZnNldCsyfUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRT1mdW5jdGlvbih2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiB3cml0ZVVJbnQxNih0aGlzLHZhbHVlLG9mZnNldCx0cnVlLG5vQXNzZXJ0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFPWZ1bmN0aW9uKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHdyaXRlVUludDE2KHRoaXMsdmFsdWUsb2Zmc2V0LGZhbHNlLG5vQXNzZXJ0KX07ZnVuY3Rpb24gd3JpdGVVSW50MzIoYnVmLHZhbHVlLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpe2lmKCFub0Fzc2VydCl7YXNzZXJ0KHZhbHVlIT09dW5kZWZpbmVkJiZ2YWx1ZSE9PW51bGwsXCJtaXNzaW5nIHZhbHVlXCIpO2Fzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuPT09XCJib29sZWFuXCIsXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXCIpO2Fzc2VydChvZmZzZXQhPT11bmRlZmluZWQmJm9mZnNldCE9PW51bGwsXCJtaXNzaW5nIG9mZnNldFwiKTthc3NlcnQob2Zmc2V0KzM8YnVmLmxlbmd0aCxcInRyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKTt2ZXJpZnVpbnQodmFsdWUsNDI5NDk2NzI5NSl9dmFyIGxlbj1idWYubGVuZ3RoO2lmKG9mZnNldD49bGVuKXJldHVybjtmb3IodmFyIGk9MCxqPU1hdGgubWluKGxlbi1vZmZzZXQsNCk7aTxqO2krKyl7YnVmW29mZnNldCtpXT12YWx1ZT4+PihsaXR0bGVFbmRpYW4/aTozLWkpKjgmMjU1fXJldHVybiBvZmZzZXQrNH1CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU9ZnVuY3Rpb24odmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gd3JpdGVVSW50MzIodGhpcyx2YWx1ZSxvZmZzZXQsdHJ1ZSxub0Fzc2VydCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRT1mdW5jdGlvbih2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiB3cml0ZVVJbnQzMih0aGlzLHZhbHVlLG9mZnNldCxmYWxzZSxub0Fzc2VydCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7aWYoIW5vQXNzZXJ0KXthc3NlcnQodmFsdWUhPT11bmRlZmluZWQmJnZhbHVlIT09bnVsbCxcIm1pc3NpbmcgdmFsdWVcIik7YXNzZXJ0KG9mZnNldCE9PXVuZGVmaW5lZCYmb2Zmc2V0IT09bnVsbCxcIm1pc3Npbmcgb2Zmc2V0XCIpO2Fzc2VydChvZmZzZXQ8dGhpcy5sZW5ndGgsXCJUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIik7dmVyaWZzaW50KHZhbHVlLDEyNywtMTI4KX1pZihvZmZzZXQ+PXRoaXMubGVuZ3RoKXJldHVybjtpZih2YWx1ZT49MCl0aGlzLndyaXRlVUludDgodmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KTtlbHNlIHRoaXMud3JpdGVVSW50OCgyNTUrdmFsdWUrMSxvZmZzZXQsbm9Bc3NlcnQpO3JldHVybiBvZmZzZXQrMX07ZnVuY3Rpb24gd3JpdGVJbnQxNihidWYsdmFsdWUsb2Zmc2V0LGxpdHRsZUVuZGlhbixub0Fzc2VydCl7aWYoIW5vQXNzZXJ0KXthc3NlcnQodmFsdWUhPT11bmRlZmluZWQmJnZhbHVlIT09bnVsbCxcIm1pc3NpbmcgdmFsdWVcIik7YXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW49PT1cImJvb2xlYW5cIixcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cIik7YXNzZXJ0KG9mZnNldCE9PXVuZGVmaW5lZCYmb2Zmc2V0IT09bnVsbCxcIm1pc3Npbmcgb2Zmc2V0XCIpO2Fzc2VydChvZmZzZXQrMTxidWYubGVuZ3RoLFwiVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpO3Zlcmlmc2ludCh2YWx1ZSwzMjc2NywtMzI3NjgpfXZhciBsZW49YnVmLmxlbmd0aDtpZihvZmZzZXQ+PWxlbilyZXR1cm47aWYodmFsdWU+PTApd3JpdGVVSW50MTYoYnVmLHZhbHVlLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpO2Vsc2Ugd3JpdGVVSW50MTYoYnVmLDY1NTM1K3ZhbHVlKzEsb2Zmc2V0LGxpdHRsZUVuZGlhbixub0Fzc2VydCk7cmV0dXJuIG9mZnNldCsyfUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFPWZ1bmN0aW9uKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHdyaXRlSW50MTYodGhpcyx2YWx1ZSxvZmZzZXQsdHJ1ZSxub0Fzc2VydCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFPWZ1bmN0aW9uKHZhbHVlLG9mZnNldCxub0Fzc2VydCl7cmV0dXJuIHdyaXRlSW50MTYodGhpcyx2YWx1ZSxvZmZzZXQsZmFsc2Usbm9Bc3NlcnQpfTtmdW5jdGlvbiB3cml0ZUludDMyKGJ1Zix2YWx1ZSxvZmZzZXQsbGl0dGxlRW5kaWFuLG5vQXNzZXJ0KXtpZighbm9Bc3NlcnQpe2Fzc2VydCh2YWx1ZSE9PXVuZGVmaW5lZCYmdmFsdWUhPT1udWxsLFwibWlzc2luZyB2YWx1ZVwiKTthc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbj09PVwiYm9vbGVhblwiLFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblwiKTthc3NlcnQob2Zmc2V0IT09dW5kZWZpbmVkJiZvZmZzZXQhPT1udWxsLFwibWlzc2luZyBvZmZzZXRcIik7YXNzZXJ0KG9mZnNldCszPGJ1Zi5sZW5ndGgsXCJUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIik7dmVyaWZzaW50KHZhbHVlLDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpfXZhciBsZW49YnVmLmxlbmd0aDtpZihvZmZzZXQ+PWxlbilyZXR1cm47aWYodmFsdWU+PTApd3JpdGVVSW50MzIoYnVmLHZhbHVlLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpO2Vsc2Ugd3JpdGVVSW50MzIoYnVmLDQyOTQ5NjcyOTUrdmFsdWUrMSxvZmZzZXQsbGl0dGxlRW5kaWFuLG5vQXNzZXJ0KTtyZXR1cm4gb2Zmc2V0KzR9QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEU9ZnVuY3Rpb24odmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gd3JpdGVJbnQzMih0aGlzLHZhbHVlLG9mZnNldCx0cnVlLG5vQXNzZXJ0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkU9ZnVuY3Rpb24odmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gd3JpdGVJbnQzMih0aGlzLHZhbHVlLG9mZnNldCxmYWxzZSxub0Fzc2VydCl9O2Z1bmN0aW9uIHdyaXRlRmxvYXQoYnVmLHZhbHVlLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpe2lmKCFub0Fzc2VydCl7YXNzZXJ0KHZhbHVlIT09dW5kZWZpbmVkJiZ2YWx1ZSE9PW51bGwsXCJtaXNzaW5nIHZhbHVlXCIpO2Fzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuPT09XCJib29sZWFuXCIsXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXCIpO2Fzc2VydChvZmZzZXQhPT11bmRlZmluZWQmJm9mZnNldCE9PW51bGwsXCJtaXNzaW5nIG9mZnNldFwiKTthc3NlcnQob2Zmc2V0KzM8YnVmLmxlbmd0aCxcIlRyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKTt2ZXJpZklFRUU3NTQodmFsdWUsMy40MDI4MjM0NjYzODUyODg2ZTM4LC0zLjQwMjgyMzQ2NjM4NTI4ODZlMzgpfXZhciBsZW49YnVmLmxlbmd0aDtpZihvZmZzZXQ+PWxlbilyZXR1cm47aWVlZTc1NC53cml0ZShidWYsdmFsdWUsb2Zmc2V0LGxpdHRsZUVuZGlhbiwyMyw0KTtyZXR1cm4gb2Zmc2V0KzRcbn1CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRT1mdW5jdGlvbih2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiB3cml0ZUZsb2F0KHRoaXMsdmFsdWUsb2Zmc2V0LHRydWUsbm9Bc3NlcnQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRT1mdW5jdGlvbih2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiB3cml0ZUZsb2F0KHRoaXMsdmFsdWUsb2Zmc2V0LGZhbHNlLG5vQXNzZXJ0KX07ZnVuY3Rpb24gd3JpdGVEb3VibGUoYnVmLHZhbHVlLG9mZnNldCxsaXR0bGVFbmRpYW4sbm9Bc3NlcnQpe2lmKCFub0Fzc2VydCl7YXNzZXJ0KHZhbHVlIT09dW5kZWZpbmVkJiZ2YWx1ZSE9PW51bGwsXCJtaXNzaW5nIHZhbHVlXCIpO2Fzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuPT09XCJib29sZWFuXCIsXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXCIpO2Fzc2VydChvZmZzZXQhPT11bmRlZmluZWQmJm9mZnNldCE9PW51bGwsXCJtaXNzaW5nIG9mZnNldFwiKTthc3NlcnQob2Zmc2V0Kzc8YnVmLmxlbmd0aCxcIlRyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKTt2ZXJpZklFRUU3NTQodmFsdWUsMS43OTc2OTMxMzQ4NjIzMTU3ZTMwOCwtMS43OTc2OTMxMzQ4NjIzMTU3ZTMwOCl9dmFyIGxlbj1idWYubGVuZ3RoO2lmKG9mZnNldD49bGVuKXJldHVybjtpZWVlNzU0LndyaXRlKGJ1Zix2YWx1ZSxvZmZzZXQsbGl0dGxlRW5kaWFuLDUyLDgpO3JldHVybiBvZmZzZXQrOH1CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24odmFsdWUsb2Zmc2V0LG5vQXNzZXJ0KXtyZXR1cm4gd3JpdGVEb3VibGUodGhpcyx2YWx1ZSxvZmZzZXQsdHJ1ZSxub0Fzc2VydCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbih2YWx1ZSxvZmZzZXQsbm9Bc3NlcnQpe3JldHVybiB3cml0ZURvdWJsZSh0aGlzLHZhbHVlLG9mZnNldCxmYWxzZSxub0Fzc2VydCl9O0J1ZmZlci5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbih2YWx1ZSxzdGFydCxlbmQpe2lmKCF2YWx1ZSl2YWx1ZT0wO2lmKCFzdGFydClzdGFydD0wO2lmKCFlbmQpZW5kPXRoaXMubGVuZ3RoO2Fzc2VydChlbmQ+PXN0YXJ0LFwiZW5kIDwgc3RhcnRcIik7aWYoZW5kPT09c3RhcnQpcmV0dXJuO2lmKHRoaXMubGVuZ3RoPT09MClyZXR1cm47YXNzZXJ0KHN0YXJ0Pj0wJiZzdGFydDx0aGlzLmxlbmd0aCxcInN0YXJ0IG91dCBvZiBib3VuZHNcIik7YXNzZXJ0KGVuZD49MCYmZW5kPD10aGlzLmxlbmd0aCxcImVuZCBvdXQgb2YgYm91bmRzXCIpO3ZhciBpO2lmKHR5cGVvZiB2YWx1ZT09PVwibnVtYmVyXCIpe2ZvcihpPXN0YXJ0O2k8ZW5kO2krKyl7dGhpc1tpXT12YWx1ZX19ZWxzZXt2YXIgYnl0ZXM9dXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSk7dmFyIGxlbj1ieXRlcy5sZW5ndGg7Zm9yKGk9c3RhcnQ7aTxlbmQ7aSsrKXt0aGlzW2ldPWJ5dGVzW2klbGVuXX19cmV0dXJuIHRoaXN9O0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbigpe3ZhciBvdXQ9W107dmFyIGxlbj10aGlzLmxlbmd0aDtmb3IodmFyIGk9MDtpPGxlbjtpKyspe291dFtpXT10b0hleCh0aGlzW2ldKTtpZihpPT09ZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyl7b3V0W2krMV09XCIuLi5cIjticmVha319cmV0dXJuXCI8QnVmZmVyIFwiK291dC5qb2luKFwiIFwiKStcIj5cIn07QnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyPWZ1bmN0aW9uKCl7aWYodHlwZW9mIFVpbnQ4QXJyYXkhPT1cInVuZGVmaW5lZFwiKXtpZihCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKXtyZXR1cm4gbmV3IEJ1ZmZlcih0aGlzKS5idWZmZXJ9ZWxzZXt2YXIgYnVmPW5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKTtmb3IodmFyIGk9MCxsZW49YnVmLmxlbmd0aDtpPGxlbjtpKz0xKXtidWZbaV09dGhpc1tpXX1yZXR1cm4gYnVmLmJ1ZmZlcn19ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKX19O3ZhciBCUD1CdWZmZXIucHJvdG90eXBlO0J1ZmZlci5fYXVnbWVudD1mdW5jdGlvbihhcnIpe2Fyci5faXNCdWZmZXI9dHJ1ZTthcnIuX2dldD1hcnIuZ2V0O2Fyci5fc2V0PWFyci5zZXQ7YXJyLmdldD1CUC5nZXQ7YXJyLnNldD1CUC5zZXQ7YXJyLndyaXRlPUJQLndyaXRlO2Fyci50b1N0cmluZz1CUC50b1N0cmluZzthcnIudG9Mb2NhbGVTdHJpbmc9QlAudG9TdHJpbmc7YXJyLnRvSlNPTj1CUC50b0pTT047YXJyLmVxdWFscz1CUC5lcXVhbHM7YXJyLmNvbXBhcmU9QlAuY29tcGFyZTthcnIuY29weT1CUC5jb3B5O2Fyci5zbGljZT1CUC5zbGljZTthcnIucmVhZFVJbnQ4PUJQLnJlYWRVSW50ODthcnIucmVhZFVJbnQxNkxFPUJQLnJlYWRVSW50MTZMRTthcnIucmVhZFVJbnQxNkJFPUJQLnJlYWRVSW50MTZCRTthcnIucmVhZFVJbnQzMkxFPUJQLnJlYWRVSW50MzJMRTthcnIucmVhZFVJbnQzMkJFPUJQLnJlYWRVSW50MzJCRTthcnIucmVhZEludDg9QlAucmVhZEludDg7YXJyLnJlYWRJbnQxNkxFPUJQLnJlYWRJbnQxNkxFO2Fyci5yZWFkSW50MTZCRT1CUC5yZWFkSW50MTZCRTthcnIucmVhZEludDMyTEU9QlAucmVhZEludDMyTEU7YXJyLnJlYWRJbnQzMkJFPUJQLnJlYWRJbnQzMkJFO2Fyci5yZWFkRmxvYXRMRT1CUC5yZWFkRmxvYXRMRTthcnIucmVhZEZsb2F0QkU9QlAucmVhZEZsb2F0QkU7YXJyLnJlYWREb3VibGVMRT1CUC5yZWFkRG91YmxlTEU7YXJyLnJlYWREb3VibGVCRT1CUC5yZWFkRG91YmxlQkU7YXJyLndyaXRlVUludDg9QlAud3JpdGVVSW50ODthcnIud3JpdGVVSW50MTZMRT1CUC53cml0ZVVJbnQxNkxFO2Fyci53cml0ZVVJbnQxNkJFPUJQLndyaXRlVUludDE2QkU7YXJyLndyaXRlVUludDMyTEU9QlAud3JpdGVVSW50MzJMRTthcnIud3JpdGVVSW50MzJCRT1CUC53cml0ZVVJbnQzMkJFO2Fyci53cml0ZUludDg9QlAud3JpdGVJbnQ4O2Fyci53cml0ZUludDE2TEU9QlAud3JpdGVJbnQxNkxFO2Fyci53cml0ZUludDE2QkU9QlAud3JpdGVJbnQxNkJFO2Fyci53cml0ZUludDMyTEU9QlAud3JpdGVJbnQzMkxFO2Fyci53cml0ZUludDMyQkU9QlAud3JpdGVJbnQzMkJFO2Fyci53cml0ZUZsb2F0TEU9QlAud3JpdGVGbG9hdExFO2Fyci53cml0ZUZsb2F0QkU9QlAud3JpdGVGbG9hdEJFO2Fyci53cml0ZURvdWJsZUxFPUJQLndyaXRlRG91YmxlTEU7YXJyLndyaXRlRG91YmxlQkU9QlAud3JpdGVEb3VibGVCRTthcnIuZmlsbD1CUC5maWxsO2Fyci5pbnNwZWN0PUJQLmluc3BlY3Q7YXJyLnRvQXJyYXlCdWZmZXI9QlAudG9BcnJheUJ1ZmZlcjtyZXR1cm4gYXJyfTtmdW5jdGlvbiBzdHJpbmd0cmltKHN0cil7aWYoc3RyLnRyaW0pcmV0dXJuIHN0ci50cmltKCk7cmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLFwiXCIpfWZ1bmN0aW9uIGNsYW1wKGluZGV4LGxlbixkZWZhdWx0VmFsdWUpe2lmKHR5cGVvZiBpbmRleCE9PVwibnVtYmVyXCIpcmV0dXJuIGRlZmF1bHRWYWx1ZTtpbmRleD1+fmluZGV4O2lmKGluZGV4Pj1sZW4pcmV0dXJuIGxlbjtpZihpbmRleD49MClyZXR1cm4gaW5kZXg7aW5kZXgrPWxlbjtpZihpbmRleD49MClyZXR1cm4gaW5kZXg7cmV0dXJuIDB9ZnVuY3Rpb24gY29lcmNlKGxlbmd0aCl7bGVuZ3RoPX5+TWF0aC5jZWlsKCtsZW5ndGgpO3JldHVybiBsZW5ndGg8MD8wOmxlbmd0aH1mdW5jdGlvbiBpc0FycmF5KHN1YmplY3Qpe3JldHVybihBcnJheS5pc0FycmF5fHxmdW5jdGlvbihzdWJqZWN0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpPT09XCJbb2JqZWN0IEFycmF5XVwifSkoc3ViamVjdCl9ZnVuY3Rpb24gaXNBcnJheWlzaChzdWJqZWN0KXtyZXR1cm4gaXNBcnJheShzdWJqZWN0KXx8QnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpfHxzdWJqZWN0JiZ0eXBlb2Ygc3ViamVjdD09PVwib2JqZWN0XCImJnR5cGVvZiBzdWJqZWN0Lmxlbmd0aD09PVwibnVtYmVyXCJ9ZnVuY3Rpb24gdG9IZXgobil7aWYobjwxNilyZXR1cm5cIjBcIituLnRvU3RyaW5nKDE2KTtyZXR1cm4gbi50b1N0cmluZygxNil9ZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKXt2YXIgYnl0ZUFycmF5PVtdO2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDtpKyspe3ZhciBiPXN0ci5jaGFyQ29kZUF0KGkpO2lmKGI8PTEyNyl7Ynl0ZUFycmF5LnB1c2goYil9ZWxzZXt2YXIgc3RhcnQ9aTtpZihiPj01NTI5NiYmYjw9NTczNDMpaSsrO3ZhciBoPWVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsaSsxKSkuc3Vic3RyKDEpLnNwbGl0KFwiJVwiKTtmb3IodmFyIGo9MDtqPGgubGVuZ3RoO2orKyl7Ynl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwxNikpfX19cmV0dXJuIGJ5dGVBcnJheX1mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoc3RyKXt2YXIgYnl0ZUFycmF5PVtdO2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDtpKyspe2J5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpJjI1NSl9cmV0dXJuIGJ5dGVBcnJheX1mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyhzdHIpe3ZhciBjLGhpLGxvO3ZhciBieXRlQXJyYXk9W107Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoO2krKyl7Yz1zdHIuY2hhckNvZGVBdChpKTtoaT1jPj44O2xvPWMlMjU2O2J5dGVBcnJheS5wdXNoKGxvKTtieXRlQXJyYXkucHVzaChoaSl9cmV0dXJuIGJ5dGVBcnJheX1mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cil7cmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpfWZ1bmN0aW9uIGJsaXRCdWZmZXIoc3JjLGRzdCxvZmZzZXQsbGVuZ3RoKXtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe2lmKGkrb2Zmc2V0Pj1kc3QubGVuZ3RofHxpPj1zcmMubGVuZ3RoKWJyZWFrO2RzdFtpK29mZnNldF09c3JjW2ldfXJldHVybiBpfWZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyKHN0cil7dHJ5e3JldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKX1jYXRjaChlcnIpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1NTMzKX19ZnVuY3Rpb24gdmVyaWZ1aW50KHZhbHVlLG1heCl7YXNzZXJ0KHR5cGVvZiB2YWx1ZT09PVwibnVtYmVyXCIsXCJjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyXCIpO2Fzc2VydCh2YWx1ZT49MCxcInNwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlXCIpO2Fzc2VydCh2YWx1ZTw9bWF4LFwidmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZVwiKTthc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSk9PT12YWx1ZSxcInZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50XCIpfWZ1bmN0aW9uIHZlcmlmc2ludCh2YWx1ZSxtYXgsbWluKXthc3NlcnQodHlwZW9mIHZhbHVlPT09XCJudW1iZXJcIixcImNhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXJcIik7YXNzZXJ0KHZhbHVlPD1tYXgsXCJ2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWVcIik7YXNzZXJ0KHZhbHVlPj1taW4sXCJ2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlXCIpO2Fzc2VydChNYXRoLmZsb29yKHZhbHVlKT09PXZhbHVlLFwidmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnRcIil9ZnVuY3Rpb24gdmVyaWZJRUVFNzU0KHZhbHVlLG1heCxtaW4pe2Fzc2VydCh0eXBlb2YgdmFsdWU9PT1cIm51bWJlclwiLFwiY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlclwiKTthc3NlcnQodmFsdWU8PW1heCxcInZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZVwiKTthc3NlcnQodmFsdWU+PW1pbixcInZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWVcIil9ZnVuY3Rpb24gYXNzZXJ0KHRlc3QsbWVzc2FnZSl7aWYoIXRlc3QpdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2V8fFwiRmFpbGVkIGFzc2VydGlvblwiKX19LHtcImJhc2U2NC1qc1wiOjYsaWVlZTc1NDo3fV0sNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIGxvb2t1cD1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjsoZnVuY3Rpb24oZXhwb3J0cyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIEFycj10eXBlb2YgVWludDhBcnJheSE9PVwidW5kZWZpbmVkXCI/VWludDhBcnJheTpBcnJheTt2YXIgWkVSTz1cIjBcIi5jaGFyQ29kZUF0KDApO3ZhciBQTFVTPVwiK1wiLmNoYXJDb2RlQXQoMCk7dmFyIFNMQVNIPVwiL1wiLmNoYXJDb2RlQXQoMCk7dmFyIE5VTUJFUj1cIjBcIi5jaGFyQ29kZUF0KDApO3ZhciBMT1dFUj1cImFcIi5jaGFyQ29kZUF0KDApO3ZhciBVUFBFUj1cIkFcIi5jaGFyQ29kZUF0KDApO2Z1bmN0aW9uIGRlY29kZShlbHQpe3ZhciBjb2RlPWVsdC5jaGFyQ29kZUF0KDApO2lmKGNvZGU9PT1QTFVTKXJldHVybiA2MjtpZihjb2RlPT09U0xBU0gpcmV0dXJuIDYzO2lmKGNvZGU8TlVNQkVSKXJldHVybi0xO2lmKGNvZGU8TlVNQkVSKzEwKXJldHVybiBjb2RlLU5VTUJFUisyNisyNjtpZihjb2RlPFVQUEVSKzI2KXJldHVybiBjb2RlLVVQUEVSO2lmKGNvZGU8TE9XRVIrMjYpcmV0dXJuIGNvZGUtTE9XRVIrMjZ9ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkoYjY0KXt2YXIgaSxqLGwsdG1wLHBsYWNlSG9sZGVycyxhcnI7aWYoYjY0Lmxlbmd0aCU0PjApe3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDRcIil9dmFyIGxlbj1iNjQubGVuZ3RoO3BsYWNlSG9sZGVycz1cIj1cIj09PWI2NC5jaGFyQXQobGVuLTIpPzI6XCI9XCI9PT1iNjQuY2hhckF0KGxlbi0xKT8xOjA7YXJyPW5ldyBBcnIoYjY0Lmxlbmd0aCozLzQtcGxhY2VIb2xkZXJzKTtsPXBsYWNlSG9sZGVycz4wP2I2NC5sZW5ndGgtNDpiNjQubGVuZ3RoO3ZhciBMPTA7ZnVuY3Rpb24gcHVzaCh2KXthcnJbTCsrXT12fWZvcihpPTAsaj0wO2k8bDtpKz00LGorPTMpe3RtcD1kZWNvZGUoYjY0LmNoYXJBdChpKSk8PDE4fGRlY29kZShiNjQuY2hhckF0KGkrMSkpPDwxMnxkZWNvZGUoYjY0LmNoYXJBdChpKzIpKTw8NnxkZWNvZGUoYjY0LmNoYXJBdChpKzMpKTtwdXNoKCh0bXAmMTY3MTE2ODApPj4xNik7cHVzaCgodG1wJjY1MjgwKT4+OCk7cHVzaCh0bXAmMjU1KX1pZihwbGFjZUhvbGRlcnM9PT0yKXt0bXA9ZGVjb2RlKGI2NC5jaGFyQXQoaSkpPDwyfGRlY29kZShiNjQuY2hhckF0KGkrMSkpPj40O3B1c2godG1wJjI1NSl9ZWxzZSBpZihwbGFjZUhvbGRlcnM9PT0xKXt0bXA9ZGVjb2RlKGI2NC5jaGFyQXQoaSkpPDwxMHxkZWNvZGUoYjY0LmNoYXJBdChpKzEpKTw8NHxkZWNvZGUoYjY0LmNoYXJBdChpKzIpKT4+MjtwdXNoKHRtcD4+OCYyNTUpO3B1c2godG1wJjI1NSl9cmV0dXJuIGFycn1mdW5jdGlvbiB1aW50OFRvQmFzZTY0KHVpbnQ4KXt2YXIgaSxleHRyYUJ5dGVzPXVpbnQ4Lmxlbmd0aCUzLG91dHB1dD1cIlwiLHRlbXAsbGVuZ3RoO2Z1bmN0aW9uIGVuY29kZShudW0pe3JldHVybiBsb29rdXAuY2hhckF0KG51bSl9ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KG51bSl7cmV0dXJuIGVuY29kZShudW0+PjE4JjYzKStlbmNvZGUobnVtPj4xMiY2MykrZW5jb2RlKG51bT4+NiY2MykrZW5jb2RlKG51bSY2Myl9Zm9yKGk9MCxsZW5ndGg9dWludDgubGVuZ3RoLWV4dHJhQnl0ZXM7aTxsZW5ndGg7aSs9Myl7dGVtcD0odWludDhbaV08PDE2KSsodWludDhbaSsxXTw8OCkrdWludDhbaSsyXTtvdXRwdXQrPXRyaXBsZXRUb0Jhc2U2NCh0ZW1wKX1zd2l0Y2goZXh0cmFCeXRlcyl7Y2FzZSAxOnRlbXA9dWludDhbdWludDgubGVuZ3RoLTFdO291dHB1dCs9ZW5jb2RlKHRlbXA+PjIpO291dHB1dCs9ZW5jb2RlKHRlbXA8PDQmNjMpO291dHB1dCs9XCI9PVwiO2JyZWFrO2Nhc2UgMjp0ZW1wPSh1aW50OFt1aW50OC5sZW5ndGgtMl08PDgpK3VpbnQ4W3VpbnQ4Lmxlbmd0aC0xXTtvdXRwdXQrPWVuY29kZSh0ZW1wPj4xMCk7b3V0cHV0Kz1lbmNvZGUodGVtcD4+NCY2Myk7b3V0cHV0Kz1lbmNvZGUodGVtcDw8MiY2Myk7b3V0cHV0Kz1cIj1cIjticmVha31yZXR1cm4gb3V0cHV0fW1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5PWI2NFRvQnl0ZUFycmF5O21vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXk9dWludDhUb0Jhc2U2NH0pKCl9LHt9XSw3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtleHBvcnRzLnJlYWQ9ZnVuY3Rpb24oYnVmZmVyLG9mZnNldCxpc0xFLG1MZW4sbkJ5dGVzKXt2YXIgZSxtLGVMZW49bkJ5dGVzKjgtbUxlbi0xLGVNYXg9KDE8PGVMZW4pLTEsZUJpYXM9ZU1heD4+MSxuQml0cz0tNyxpPWlzTEU/bkJ5dGVzLTE6MCxkPWlzTEU/LTE6MSxzPWJ1ZmZlcltvZmZzZXQraV07aSs9ZDtlPXMmKDE8PC1uQml0cyktMTtzPj49LW5CaXRzO25CaXRzKz1lTGVuO2Zvcig7bkJpdHM+MDtlPWUqMjU2K2J1ZmZlcltvZmZzZXQraV0saSs9ZCxuQml0cy09OCk7bT1lJigxPDwtbkJpdHMpLTE7ZT4+PS1uQml0cztuQml0cys9bUxlbjtmb3IoO25CaXRzPjA7bT1tKjI1NitidWZmZXJbb2Zmc2V0K2ldLGkrPWQsbkJpdHMtPTgpO2lmKGU9PT0wKXtlPTEtZUJpYXN9ZWxzZSBpZihlPT09ZU1heCl7cmV0dXJuIG0/TmFOOihzPy0xOjEpKkluZmluaXR5fWVsc2V7bT1tK01hdGgucG93KDIsbUxlbik7ZT1lLWVCaWFzfXJldHVybihzPy0xOjEpKm0qTWF0aC5wb3coMixlLW1MZW4pfTtleHBvcnRzLndyaXRlPWZ1bmN0aW9uKGJ1ZmZlcix2YWx1ZSxvZmZzZXQsaXNMRSxtTGVuLG5CeXRlcyl7dmFyIGUsbSxjLGVMZW49bkJ5dGVzKjgtbUxlbi0xLGVNYXg9KDE8PGVMZW4pLTEsZUJpYXM9ZU1heD4+MSxydD1tTGVuPT09MjM/TWF0aC5wb3coMiwtMjQpLU1hdGgucG93KDIsLTc3KTowLGk9aXNMRT8wOm5CeXRlcy0xLGQ9aXNMRT8xOi0xLHM9dmFsdWU8MHx8dmFsdWU9PT0wJiYxL3ZhbHVlPDA/MTowO3ZhbHVlPU1hdGguYWJzKHZhbHVlKTtpZihpc05hTih2YWx1ZSl8fHZhbHVlPT09SW5maW5pdHkpe209aXNOYU4odmFsdWUpPzE6MDtlPWVNYXh9ZWxzZXtlPU1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpL01hdGguTE4yKTtpZih2YWx1ZSooYz1NYXRoLnBvdygyLC1lKSk8MSl7ZS0tO2MqPTJ9aWYoZStlQmlhcz49MSl7dmFsdWUrPXJ0L2N9ZWxzZXt2YWx1ZSs9cnQqTWF0aC5wb3coMiwxLWVCaWFzKX1pZih2YWx1ZSpjPj0yKXtlKys7Yy89Mn1pZihlK2VCaWFzPj1lTWF4KXttPTA7ZT1lTWF4fWVsc2UgaWYoZStlQmlhcz49MSl7bT0odmFsdWUqYy0xKSpNYXRoLnBvdygyLG1MZW4pO2U9ZStlQmlhc31lbHNle209dmFsdWUqTWF0aC5wb3coMixlQmlhcy0xKSpNYXRoLnBvdygyLG1MZW4pO2U9MH19Zm9yKDttTGVuPj04O2J1ZmZlcltvZmZzZXQraV09bSYyNTUsaSs9ZCxtLz0yNTYsbUxlbi09OCk7ZT1lPDxtTGVufG07ZUxlbis9bUxlbjtmb3IoO2VMZW4+MDtidWZmZXJbb2Zmc2V0K2ldPWUmMjU1LGkrPWQsZS89MjU2LGVMZW4tPTgpO2J1ZmZlcltvZmZzZXQraS1kXXw9cyoxMjh9fSx7fV0sODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIEJ1ZmZlcj1fZGVyZXFfKFwiYnVmZmVyXCIpLkJ1ZmZlcjt2YXIgaW50U2l6ZT00O3ZhciB6ZXJvQnVmZmVyPW5ldyBCdWZmZXIoaW50U2l6ZSk7emVyb0J1ZmZlci5maWxsKDApO3ZhciBjaHJzej04O2Z1bmN0aW9uIHRvQXJyYXkoYnVmLGJpZ0VuZGlhbil7aWYoYnVmLmxlbmd0aCVpbnRTaXplIT09MCl7dmFyIGxlbj1idWYubGVuZ3RoKyhpbnRTaXplLWJ1Zi5sZW5ndGglaW50U2l6ZSk7YnVmPUJ1ZmZlci5jb25jYXQoW2J1Zix6ZXJvQnVmZmVyXSxsZW4pfXZhciBhcnI9W107dmFyIGZuPWJpZ0VuZGlhbj9idWYucmVhZEludDMyQkU6YnVmLnJlYWRJbnQzMkxFO2Zvcih2YXIgaT0wO2k8YnVmLmxlbmd0aDtpKz1pbnRTaXplKXthcnIucHVzaChmbi5jYWxsKGJ1ZixpKSl9cmV0dXJuIGFycn1mdW5jdGlvbiB0b0J1ZmZlcihhcnIsc2l6ZSxiaWdFbmRpYW4pe3ZhciBidWY9bmV3IEJ1ZmZlcihzaXplKTt2YXIgZm49YmlnRW5kaWFuP2J1Zi53cml0ZUludDMyQkU6YnVmLndyaXRlSW50MzJMRTtmb3IodmFyIGk9MDtpPGFyci5sZW5ndGg7aSsrKXtmbi5jYWxsKGJ1ZixhcnJbaV0saSo0LHRydWUpfXJldHVybiBidWZ9ZnVuY3Rpb24gaGFzaChidWYsZm4saGFzaFNpemUsYmlnRW5kaWFuKXtpZighQnVmZmVyLmlzQnVmZmVyKGJ1ZikpYnVmPW5ldyBCdWZmZXIoYnVmKTt2YXIgYXJyPWZuKHRvQXJyYXkoYnVmLGJpZ0VuZGlhbiksYnVmLmxlbmd0aCpjaHJzeik7cmV0dXJuIHRvQnVmZmVyKGFycixoYXNoU2l6ZSxiaWdFbmRpYW4pfW1vZHVsZS5leHBvcnRzPXtoYXNoOmhhc2h9fSx7YnVmZmVyOjV9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgQnVmZmVyPV9kZXJlcV8oXCJidWZmZXJcIikuQnVmZmVyO3ZhciBzaGE9X2RlcmVxXyhcIi4vc2hhXCIpO3ZhciBzaGEyNTY9X2RlcmVxXyhcIi4vc2hhMjU2XCIpO3ZhciBybmc9X2RlcmVxXyhcIi4vcm5nXCIpO3ZhciBtZDU9X2RlcmVxXyhcIi4vbWQ1XCIpO3ZhciBhbGdvcml0aG1zPXtzaGExOnNoYSxzaGEyNTY6c2hhMjU2LG1kNTptZDV9O3ZhciBibG9ja3NpemU9NjQ7dmFyIHplcm9CdWZmZXI9bmV3IEJ1ZmZlcihibG9ja3NpemUpO3plcm9CdWZmZXIuZmlsbCgwKTtmdW5jdGlvbiBobWFjKGZuLGtleSxkYXRhKXtpZighQnVmZmVyLmlzQnVmZmVyKGtleSkpa2V5PW5ldyBCdWZmZXIoa2V5KTtpZighQnVmZmVyLmlzQnVmZmVyKGRhdGEpKWRhdGE9bmV3IEJ1ZmZlcihkYXRhKTtpZihrZXkubGVuZ3RoPmJsb2Nrc2l6ZSl7a2V5PWZuKGtleSl9ZWxzZSBpZihrZXkubGVuZ3RoPGJsb2Nrc2l6ZSl7a2V5PUJ1ZmZlci5jb25jYXQoW2tleSx6ZXJvQnVmZmVyXSxibG9ja3NpemUpfXZhciBpcGFkPW5ldyBCdWZmZXIoYmxvY2tzaXplKSxvcGFkPW5ldyBCdWZmZXIoYmxvY2tzaXplKTtmb3IodmFyIGk9MDtpPGJsb2Nrc2l6ZTtpKyspe2lwYWRbaV09a2V5W2ldXjU0O29wYWRbaV09a2V5W2ldXjkyfXZhciBoYXNoPWZuKEJ1ZmZlci5jb25jYXQoW2lwYWQsZGF0YV0pKTtyZXR1cm4gZm4oQnVmZmVyLmNvbmNhdChbb3BhZCxoYXNoXSkpfWZ1bmN0aW9uIGhhc2goYWxnLGtleSl7YWxnPWFsZ3x8XCJzaGExXCI7dmFyIGZuPWFsZ29yaXRobXNbYWxnXTt2YXIgYnVmcz1bXTt2YXIgbGVuZ3RoPTA7aWYoIWZuKWVycm9yKFwiYWxnb3JpdGhtOlwiLGFsZyxcImlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO3JldHVybnt1cGRhdGU6ZnVuY3Rpb24oZGF0YSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSlkYXRhPW5ldyBCdWZmZXIoZGF0YSk7YnVmcy5wdXNoKGRhdGEpO2xlbmd0aCs9ZGF0YS5sZW5ndGg7cmV0dXJuIHRoaXN9LGRpZ2VzdDpmdW5jdGlvbihlbmMpe3ZhciBidWY9QnVmZmVyLmNvbmNhdChidWZzKTt2YXIgcj1rZXk/aG1hYyhmbixrZXksYnVmKTpmbihidWYpO2J1ZnM9bnVsbDtyZXR1cm4gZW5jP3IudG9TdHJpbmcoZW5jKTpyfX19ZnVuY3Rpb24gZXJyb3IoKXt2YXIgbT1bXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIiBcIik7dGhyb3cgbmV3IEVycm9yKFttLFwid2UgYWNjZXB0IHB1bGwgcmVxdWVzdHNcIixcImh0dHA6Ly9naXRodWIuY29tL2RvbWluaWN0YXJyL2NyeXB0by1icm93c2VyaWZ5XCJdLmpvaW4oXCJcXG5cIikpfWV4cG9ydHMuY3JlYXRlSGFzaD1mdW5jdGlvbihhbGcpe3JldHVybiBoYXNoKGFsZyl9O2V4cG9ydHMuY3JlYXRlSG1hYz1mdW5jdGlvbihhbGcsa2V5KXtyZXR1cm4gaGFzaChhbGcsa2V5KX07ZXhwb3J0cy5yYW5kb21CeXRlcz1mdW5jdGlvbihzaXplLGNhbGxiYWNrKXtpZihjYWxsYmFjayYmY2FsbGJhY2suY2FsbCl7dHJ5e2NhbGxiYWNrLmNhbGwodGhpcyx1bmRlZmluZWQsbmV3IEJ1ZmZlcihybmcoc2l6ZSkpKX1jYXRjaChlcnIpe2NhbGxiYWNrKGVycil9fWVsc2V7cmV0dXJuIG5ldyBCdWZmZXIocm5nKHNpemUpKX19O2Z1bmN0aW9uIGVhY2goYSxmKXtmb3IodmFyIGkgaW4gYSlmKGFbaV0saSl9ZWFjaChbXCJjcmVhdGVDcmVkZW50aWFsc1wiLFwiY3JlYXRlQ2lwaGVyXCIsXCJjcmVhdGVDaXBoZXJpdlwiLFwiY3JlYXRlRGVjaXBoZXJcIixcImNyZWF0ZURlY2lwaGVyaXZcIixcImNyZWF0ZVNpZ25cIixcImNyZWF0ZVZlcmlmeVwiLFwiY3JlYXRlRGlmZmllSGVsbG1hblwiLFwicGJrZGYyXCJdLGZ1bmN0aW9uKG5hbWUpe2V4cG9ydHNbbmFtZV09ZnVuY3Rpb24oKXtlcnJvcihcInNvcnJ5LFwiLG5hbWUsXCJpcyBub3QgaW1wbGVtZW50ZWQgeWV0XCIpfX0pfSx7XCIuL21kNVwiOjEwLFwiLi9ybmdcIjoxMSxcIi4vc2hhXCI6MTIsXCIuL3NoYTI1NlwiOjEzLGJ1ZmZlcjo1fV0sMTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBoZWxwZXJzPV9kZXJlcV8oXCIuL2hlbHBlcnNcIik7ZnVuY3Rpb24gbWQ1X3ZtX3Rlc3QoKXtyZXR1cm4gaGV4X21kNShcImFiY1wiKT09XCI5MDAxNTA5ODNjZDI0ZmIwZDY5NjNmN2QyOGUxN2Y3MlwifWZ1bmN0aW9uIGNvcmVfbWQ1KHgsbGVuKXt4W2xlbj4+NV18PTEyODw8bGVuJTMyO3hbKGxlbis2ND4+Pjk8PDQpKzE0XT1sZW47dmFyIGE9MTczMjU4NDE5Mzt2YXIgYj0tMjcxNzMzODc5O3ZhciBjPS0xNzMyNTg0MTk0O3ZhciBkPTI3MTczMzg3ODtmb3IodmFyIGk9MDtpPHgubGVuZ3RoO2krPTE2KXt2YXIgb2xkYT1hO3ZhciBvbGRiPWI7dmFyIG9sZGM9Yzt2YXIgb2xkZD1kO2E9bWQ1X2ZmKGEsYixjLGQseFtpKzBdLDcsLTY4MDg3NjkzNik7ZD1tZDVfZmYoZCxhLGIsYyx4W2krMV0sMTIsLTM4OTU2NDU4Nik7Yz1tZDVfZmYoYyxkLGEsYix4W2krMl0sMTcsNjA2MTA1ODE5KTtiPW1kNV9mZihiLGMsZCxhLHhbaSszXSwyMiwtMTA0NDUyNTMzMCk7YT1tZDVfZmYoYSxiLGMsZCx4W2krNF0sNywtMTc2NDE4ODk3KTtkPW1kNV9mZihkLGEsYixjLHhbaSs1XSwxMiwxMjAwMDgwNDI2KTtjPW1kNV9mZihjLGQsYSxiLHhbaSs2XSwxNywtMTQ3MzIzMTM0MSk7Yj1tZDVfZmYoYixjLGQsYSx4W2krN10sMjIsLTQ1NzA1OTgzKTthPW1kNV9mZihhLGIsYyxkLHhbaSs4XSw3LDE3NzAwMzU0MTYpO2Q9bWQ1X2ZmKGQsYSxiLGMseFtpKzldLDEyLC0xOTU4NDE0NDE3KTtjPW1kNV9mZihjLGQsYSxiLHhbaSsxMF0sMTcsLTQyMDYzKTtiPW1kNV9mZihiLGMsZCxhLHhbaSsxMV0sMjIsLTE5OTA0MDQxNjIpO2E9bWQ1X2ZmKGEsYixjLGQseFtpKzEyXSw3LDE4MDQ2MDM2ODIpO2Q9bWQ1X2ZmKGQsYSxiLGMseFtpKzEzXSwxMiwtNDAzNDExMDEpO2M9bWQ1X2ZmKGMsZCxhLGIseFtpKzE0XSwxNywtMTUwMjAwMjI5MCk7Yj1tZDVfZmYoYixjLGQsYSx4W2krMTVdLDIyLDEyMzY1MzUzMjkpO2E9bWQ1X2dnKGEsYixjLGQseFtpKzFdLDUsLTE2NTc5NjUxMCk7ZD1tZDVfZ2coZCxhLGIsYyx4W2krNl0sOSwtMTA2OTUwMTYzMik7Yz1tZDVfZ2coYyxkLGEsYix4W2krMTFdLDE0LDY0MzcxNzcxMyk7Yj1tZDVfZ2coYixjLGQsYSx4W2krMF0sMjAsLTM3Mzg5NzMwMik7YT1tZDVfZ2coYSxiLGMsZCx4W2krNV0sNSwtNzAxNTU4NjkxKTtkPW1kNV9nZyhkLGEsYixjLHhbaSsxMF0sOSwzODAxNjA4Myk7Yz1tZDVfZ2coYyxkLGEsYix4W2krMTVdLDE0LC02NjA0NzgzMzUpO2I9bWQ1X2dnKGIsYyxkLGEseFtpKzRdLDIwLC00MDU1Mzc4NDgpO2E9bWQ1X2dnKGEsYixjLGQseFtpKzldLDUsNTY4NDQ2NDM4KTtkPW1kNV9nZyhkLGEsYixjLHhbaSsxNF0sOSwtMTAxOTgwMzY5MCk7Yz1tZDVfZ2coYyxkLGEsYix4W2krM10sMTQsLTE4NzM2Mzk2MSk7Yj1tZDVfZ2coYixjLGQsYSx4W2krOF0sMjAsMTE2MzUzMTUwMSk7YT1tZDVfZ2coYSxiLGMsZCx4W2krMTNdLDUsLTE0NDQ2ODE0NjcpO2Q9bWQ1X2dnKGQsYSxiLGMseFtpKzJdLDksLTUxNDAzNzg0KTtjPW1kNV9nZyhjLGQsYSxiLHhbaSs3XSwxNCwxNzM1MzI4NDczKTtiPW1kNV9nZyhiLGMsZCxhLHhbaSsxMl0sMjAsLTE5MjY2MDc3MzQpO2E9bWQ1X2hoKGEsYixjLGQseFtpKzVdLDQsLTM3ODU1OCk7ZD1tZDVfaGgoZCxhLGIsYyx4W2krOF0sMTEsLTIwMjI1NzQ0NjMpO2M9bWQ1X2hoKGMsZCxhLGIseFtpKzExXSwxNiwxODM5MDMwNTYyKTtiPW1kNV9oaChiLGMsZCxhLHhbaSsxNF0sMjMsLTM1MzA5NTU2KTthPW1kNV9oaChhLGIsYyxkLHhbaSsxXSw0LC0xNTMwOTkyMDYwKTtkPW1kNV9oaChkLGEsYixjLHhbaSs0XSwxMSwxMjcyODkzMzUzKTtjPW1kNV9oaChjLGQsYSxiLHhbaSs3XSwxNiwtMTU1NDk3NjMyKTtiPW1kNV9oaChiLGMsZCxhLHhbaSsxMF0sMjMsLTEwOTQ3MzA2NDApO2E9bWQ1X2hoKGEsYixjLGQseFtpKzEzXSw0LDY4MTI3OTE3NCk7ZD1tZDVfaGgoZCxhLGIsYyx4W2krMF0sMTEsLTM1ODUzNzIyMik7Yz1tZDVfaGgoYyxkLGEsYix4W2krM10sMTYsLTcyMjUyMTk3OSk7Yj1tZDVfaGgoYixjLGQsYSx4W2krNl0sMjMsNzYwMjkxODkpO2E9bWQ1X2hoKGEsYixjLGQseFtpKzldLDQsLTY0MDM2NDQ4Nyk7ZD1tZDVfaGgoZCxhLGIsYyx4W2krMTJdLDExLC00MjE4MTU4MzUpO2M9bWQ1X2hoKGMsZCxhLGIseFtpKzE1XSwxNiw1MzA3NDI1MjApO2I9bWQ1X2hoKGIsYyxkLGEseFtpKzJdLDIzLC05OTUzMzg2NTEpO2E9bWQ1X2lpKGEsYixjLGQseFtpKzBdLDYsLTE5ODYzMDg0NCk7ZD1tZDVfaWkoZCxhLGIsYyx4W2krN10sMTAsMTEyNjg5MTQxNSk7Yz1tZDVfaWkoYyxkLGEsYix4W2krMTRdLDE1LC0xNDE2MzU0OTA1KTtiPW1kNV9paShiLGMsZCxhLHhbaSs1XSwyMSwtNTc0MzQwNTUpO2E9bWQ1X2lpKGEsYixjLGQseFtpKzEyXSw2LDE3MDA0ODU1NzEpO2Q9bWQ1X2lpKGQsYSxiLGMseFtpKzNdLDEwLC0xODk0OTg2NjA2KTtjPW1kNV9paShjLGQsYSxiLHhbaSsxMF0sMTUsLTEwNTE1MjMpO2I9bWQ1X2lpKGIsYyxkLGEseFtpKzFdLDIxLC0yMDU0OTIyNzk5KTthPW1kNV9paShhLGIsYyxkLHhbaSs4XSw2LDE4NzMzMTMzNTkpO2Q9bWQ1X2lpKGQsYSxiLGMseFtpKzE1XSwxMCwtMzA2MTE3NDQpO2M9bWQ1X2lpKGMsZCxhLGIseFtpKzZdLDE1LC0xNTYwMTk4MzgwKTtiPW1kNV9paShiLGMsZCxhLHhbaSsxM10sMjEsMTMwOTE1MTY0OSk7YT1tZDVfaWkoYSxiLGMsZCx4W2krNF0sNiwtMTQ1NTIzMDcwKTtkPW1kNV9paShkLGEsYixjLHhbaSsxMV0sMTAsLTExMjAyMTAzNzkpO2M9bWQ1X2lpKGMsZCxhLGIseFtpKzJdLDE1LDcxODc4NzI1OSk7Yj1tZDVfaWkoYixjLGQsYSx4W2krOV0sMjEsLTM0MzQ4NTU1MSk7YT1zYWZlX2FkZChhLG9sZGEpO2I9c2FmZV9hZGQoYixvbGRiKTtjPXNhZmVfYWRkKGMsb2xkYyk7ZD1zYWZlX2FkZChkLG9sZGQpfXJldHVybiBBcnJheShhLGIsYyxkKX1mdW5jdGlvbiBtZDVfY21uKHEsYSxiLHgscyx0KXtyZXR1cm4gc2FmZV9hZGQoYml0X3JvbChzYWZlX2FkZChzYWZlX2FkZChhLHEpLHNhZmVfYWRkKHgsdCkpLHMpLGIpfWZ1bmN0aW9uIG1kNV9mZihhLGIsYyxkLHgscyx0KXtyZXR1cm4gbWQ1X2NtbihiJmN8fmImZCxhLGIseCxzLHQpfWZ1bmN0aW9uIG1kNV9nZyhhLGIsYyxkLHgscyx0KXtyZXR1cm4gbWQ1X2NtbihiJmR8YyZ+ZCxhLGIseCxzLHQpfWZ1bmN0aW9uIG1kNV9oaChhLGIsYyxkLHgscyx0KXtyZXR1cm4gbWQ1X2NtbihiXmNeZCxhLGIseCxzLHQpfWZ1bmN0aW9uIG1kNV9paShhLGIsYyxkLHgscyx0KXtyZXR1cm4gbWQ1X2NtbihjXihifH5kKSxhLGIseCxzLHQpfWZ1bmN0aW9uIHNhZmVfYWRkKHgseSl7dmFyIGxzdz0oeCY2NTUzNSkrKHkmNjU1MzUpO3ZhciBtc3c9KHg+PjE2KSsoeT4+MTYpKyhsc3c+PjE2KTtyZXR1cm4gbXN3PDwxNnxsc3cmNjU1MzV9ZnVuY3Rpb24gYml0X3JvbChudW0sY250KXtyZXR1cm4gbnVtPDxjbnR8bnVtPj4+MzItY250fW1vZHVsZS5leHBvcnRzPWZ1bmN0aW9uIG1kNShidWYpe3JldHVybiBoZWxwZXJzLmhhc2goYnVmLGNvcmVfbWQ1LDE2KX19LHtcIi4vaGVscGVyc1wiOjh9XSwxMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKCl7dmFyIF9nbG9iYWw9dGhpczt2YXIgbWF0aFJORyx3aGF0d2dSTkc7bWF0aFJORz1mdW5jdGlvbihzaXplKXt2YXIgYnl0ZXM9bmV3IEFycmF5KHNpemUpO3ZhciByO2Zvcih2YXIgaT0wLHI7aTxzaXplO2krKyl7aWYoKGkmMyk9PTApcj1NYXRoLnJhbmRvbSgpKjQyOTQ5NjcyOTY7Ynl0ZXNbaV09cj4+PigoaSYzKTw8MykmMjU1fXJldHVybiBieXRlc307aWYoX2dsb2JhbC5jcnlwdG8mJmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpe3doYXR3Z1JORz1mdW5jdGlvbihzaXplKXt2YXIgYnl0ZXM9bmV3IFVpbnQ4QXJyYXkoc2l6ZSk7Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7cmV0dXJuIGJ5dGVzfX1tb2R1bGUuZXhwb3J0cz13aGF0d2dSTkd8fG1hdGhSTkd9KSgpfSx7fV0sMTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBoZWxwZXJzPV9kZXJlcV8oXCIuL2hlbHBlcnNcIik7ZnVuY3Rpb24gY29yZV9zaGExKHgsbGVuKXt4W2xlbj4+NV18PTEyODw8MjQtbGVuJTMyO3hbKGxlbis2ND4+OTw8NCkrMTVdPWxlbjt2YXIgdz1BcnJheSg4MCk7dmFyIGE9MTczMjU4NDE5Mzt2YXIgYj0tMjcxNzMzODc5O3ZhciBjPS0xNzMyNTg0MTk0O3ZhciBkPTI3MTczMzg3ODt2YXIgZT0tMTAwOTU4OTc3Njtmb3IodmFyIGk9MDtpPHgubGVuZ3RoO2krPTE2KXt2YXIgb2xkYT1hO3ZhciBvbGRiPWI7dmFyIG9sZGM9Yzt2YXIgb2xkZD1kO3ZhciBvbGRlPWU7Zm9yKHZhciBqPTA7ajw4MDtqKyspe2lmKGo8MTYpd1tqXT14W2kral07ZWxzZSB3W2pdPXJvbCh3W2otM11ed1tqLThdXndbai0xNF1ed1tqLTE2XSwxKTt2YXIgdD1zYWZlX2FkZChzYWZlX2FkZChyb2woYSw1KSxzaGExX2Z0KGosYixjLGQpKSxzYWZlX2FkZChzYWZlX2FkZChlLHdbal0pLHNoYTFfa3QoaikpKTtlPWQ7ZD1jO2M9cm9sKGIsMzApO2I9YTthPXR9YT1zYWZlX2FkZChhLG9sZGEpO2I9c2FmZV9hZGQoYixvbGRiKTtjPXNhZmVfYWRkKGMsb2xkYyk7ZD1zYWZlX2FkZChkLG9sZGQpO2U9c2FmZV9hZGQoZSxvbGRlKX1yZXR1cm4gQXJyYXkoYSxiLGMsZCxlKX1mdW5jdGlvbiBzaGExX2Z0KHQsYixjLGQpe2lmKHQ8MjApcmV0dXJuIGImY3x+YiZkO2lmKHQ8NDApcmV0dXJuIGJeY15kO2lmKHQ8NjApcmV0dXJuIGImY3xiJmR8YyZkO3JldHVybiBiXmNeZH1mdW5jdGlvbiBzaGExX2t0KHQpe3JldHVybiB0PDIwPzE1MTg1MDAyNDk6dDw0MD8xODU5Nzc1MzkzOnQ8NjA/LTE4OTQwMDc1ODg6LTg5OTQ5NzUxNH1mdW5jdGlvbiBzYWZlX2FkZCh4LHkpe3ZhciBsc3c9KHgmNjU1MzUpKyh5JjY1NTM1KTt2YXIgbXN3PSh4Pj4xNikrKHk+PjE2KSsobHN3Pj4xNik7cmV0dXJuIG1zdzw8MTZ8bHN3JjY1NTM1fWZ1bmN0aW9uIHJvbChudW0sY250KXtyZXR1cm4gbnVtPDxjbnR8bnVtPj4+MzItY250fW1vZHVsZS5leHBvcnRzPWZ1bmN0aW9uIHNoYTEoYnVmKXtyZXR1cm4gaGVscGVycy5oYXNoKGJ1Zixjb3JlX3NoYTEsMjAsdHJ1ZSl9fSx7XCIuL2hlbHBlcnNcIjo4fV0sMTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBoZWxwZXJzPV9kZXJlcV8oXCIuL2hlbHBlcnNcIik7dmFyIHNhZmVfYWRkPWZ1bmN0aW9uKHgseSl7dmFyIGxzdz0oeCY2NTUzNSkrKHkmNjU1MzUpO3ZhciBtc3c9KHg+PjE2KSsoeT4+MTYpKyhsc3c+PjE2KTtyZXR1cm4gbXN3PDwxNnxsc3cmNjU1MzV9O3ZhciBTPWZ1bmN0aW9uKFgsbil7cmV0dXJuIFg+Pj5ufFg8PDMyLW59O3ZhciBSPWZ1bmN0aW9uKFgsbil7cmV0dXJuIFg+Pj5ufTt2YXIgQ2g9ZnVuY3Rpb24oeCx5LHope3JldHVybiB4Jnlefngmen07dmFyIE1haj1mdW5jdGlvbih4LHkseil7cmV0dXJuIHgmeV54JnpeeSZ6fTt2YXIgU2lnbWEwMjU2PWZ1bmN0aW9uKHgpe3JldHVybiBTKHgsMileUyh4LDEzKV5TKHgsMjIpfTt2YXIgU2lnbWExMjU2PWZ1bmN0aW9uKHgpe3JldHVybiBTKHgsNileUyh4LDExKV5TKHgsMjUpfTt2YXIgR2FtbWEwMjU2PWZ1bmN0aW9uKHgpe3JldHVybiBTKHgsNyleUyh4LDE4KV5SKHgsMyl9O3ZhciBHYW1tYTEyNTY9ZnVuY3Rpb24oeCl7cmV0dXJuIFMoeCwxNyleUyh4LDE5KV5SKHgsMTApfTt2YXIgY29yZV9zaGEyNTY9ZnVuY3Rpb24obSxsKXt2YXIgSz1uZXcgQXJyYXkoMTExNjM1MjQwOCwxODk5NDQ3NDQxLDMwNDkzMjM0NzEsMzkyMTAwOTU3Myw5NjE5ODcxNjMsMTUwODk3MDk5MywyNDUzNjM1NzQ4LDI4NzA3NjMyMjEsMzYyNDM4MTA4MCwzMTA1OTg0MDEsNjA3MjI1Mjc4LDE0MjY4ODE5ODcsMTkyNTA3ODM4OCwyMTYyMDc4MjA2LDI2MTQ4ODgxMDMsMzI0ODIyMjU4MCwzODM1MzkwNDAxLDQwMjIyMjQ3NzQsMjY0MzQ3MDc4LDYwNDgwNzYyOCw3NzAyNTU5ODMsMTI0OTE1MDEyMiwxNTU1MDgxNjkyLDE5OTYwNjQ5ODYsMjU1NDIyMDg4MiwyODIxODM0MzQ5LDI5NTI5OTY4MDgsMzIxMDMxMzY3MSwzMzM2NTcxODkxLDM1ODQ1Mjg3MTEsMTEzOTI2OTkzLDMzODI0MTg5NSw2NjYzMDcyMDUsNzczNTI5OTEyLDEyOTQ3NTczNzIsMTM5NjE4MjI5MSwxNjk1MTgzNzAwLDE5ODY2NjEwNTEsMjE3NzAyNjM1MCwyNDU2OTU2MDM3LDI3MzA0ODU5MjEsMjgyMDMwMjQxMSwzMjU5NzMwODAwLDMzNDU3NjQ3NzEsMzUxNjA2NTgxNywzNjAwMzUyODA0LDQwOTQ1NzE5MDksMjc1NDIzMzQ0LDQzMDIyNzczNCw1MDY5NDg2MTYsNjU5MDYwNTU2LDg4Mzk5Nzg3Nyw5NTgxMzk1NzEsMTMyMjgyMjIxOCwxNTM3MDAyMDYzLDE3NDc4NzM3NzksMTk1NTU2MjIyMiwyMDI0MTA0ODE1LDIyMjc3MzA0NTIsMjM2MTg1MjQyNCwyNDI4NDM2NDc0LDI3NTY3MzQxODcsMzIwNDAzMTQ3OSwzMzI5MzI1Mjk4KTt2YXIgSEFTSD1uZXcgQXJyYXkoMTc3OTAzMzcwMywzMTQ0MTM0Mjc3LDEwMTM5MDQyNDIsMjc3MzQ4MDc2MiwxMzU5ODkzMTE5LDI2MDA4MjI5MjQsNTI4NzM0NjM1LDE1NDE0NTkyMjUpO3ZhciBXPW5ldyBBcnJheSg2NCk7dmFyIGEsYixjLGQsZSxmLGcsaCxpLGo7dmFyIFQxLFQyO21bbD4+NV18PTEyODw8MjQtbCUzMjttWyhsKzY0Pj45PDw0KSsxNV09bDtmb3IodmFyIGk9MDtpPG0ubGVuZ3RoO2krPTE2KXthPUhBU0hbMF07Yj1IQVNIWzFdO2M9SEFTSFsyXTtkPUhBU0hbM107ZT1IQVNIWzRdO2Y9SEFTSFs1XTtnPUhBU0hbNl07aD1IQVNIWzddO2Zvcih2YXIgaj0wO2o8NjQ7aisrKXtpZihqPDE2KXtXW2pdPW1baitpXX1lbHNle1dbal09c2FmZV9hZGQoc2FmZV9hZGQoc2FmZV9hZGQoR2FtbWExMjU2KFdbai0yXSksV1tqLTddKSxHYW1tYTAyNTYoV1tqLTE1XSkpLFdbai0xNl0pfVQxPXNhZmVfYWRkKHNhZmVfYWRkKHNhZmVfYWRkKHNhZmVfYWRkKGgsU2lnbWExMjU2KGUpKSxDaChlLGYsZykpLEtbal0pLFdbal0pO1QyPXNhZmVfYWRkKFNpZ21hMDI1NihhKSxNYWooYSxiLGMpKTtoPWc7Zz1mO2Y9ZTtlPXNhZmVfYWRkKGQsVDEpO2Q9YztjPWI7Yj1hO2E9c2FmZV9hZGQoVDEsVDIpfUhBU0hbMF09c2FmZV9hZGQoYSxIQVNIWzBdKTtIQVNIWzFdPXNhZmVfYWRkKGIsSEFTSFsxXSk7SEFTSFsyXT1zYWZlX2FkZChjLEhBU0hbMl0pO0hBU0hbM109c2FmZV9hZGQoZCxIQVNIWzNdKTtIQVNIWzRdPXNhZmVfYWRkKGUsSEFTSFs0XSk7SEFTSFs1XT1zYWZlX2FkZChmLEhBU0hbNV0pO0hBU0hbNl09c2FmZV9hZGQoZyxIQVNIWzZdKTtIQVNIWzddPXNhZmVfYWRkKGgsSEFTSFs3XSl9cmV0dXJuIEhBU0h9O21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uIHNoYTI1NihidWYpe3JldHVybiBoZWxwZXJzLmhhc2goYnVmLGNvcmVfc2hhMjU2LDMyLHRydWUpfX0se1wiLi9oZWxwZXJzXCI6OH1dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtpZih0eXBlb2YgT2JqZWN0LmNyZWF0ZT09PVwiZnVuY3Rpb25cIil7bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24gaW5oZXJpdHMoY3RvcixzdXBlckN0b3Ipe2N0b3Iuc3VwZXJfPXN1cGVyQ3RvcjtjdG9yLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpjdG9yLGVudW1lcmFibGU6ZmFsc2Usd3JpdGFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZX19KX19ZWxzZXttb2R1bGUuZXhwb3J0cz1mdW5jdGlvbiBpbmhlcml0cyhjdG9yLHN1cGVyQ3Rvcil7Y3Rvci5zdXBlcl89c3VwZXJDdG9yO3ZhciBUZW1wQ3Rvcj1mdW5jdGlvbigpe307VGVtcEN0b3IucHJvdG90eXBlPXN1cGVyQ3Rvci5wcm90b3R5cGU7Y3Rvci5wcm90b3R5cGU9bmV3IFRlbXBDdG9yO2N0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yPWN0b3J9fX0se31dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgcHJvY2Vzcz1tb2R1bGUuZXhwb3J0cz17fTtwcm9jZXNzLm5leHRUaWNrPWZ1bmN0aW9uKCl7dmFyIGNhblNldEltbWVkaWF0ZT10eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIiYmd2luZG93LnNldEltbWVkaWF0ZTt2YXIgY2FuUG9zdD10eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIiYmd2luZG93LnBvc3RNZXNzYWdlJiZ3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcjtpZihjYW5TZXRJbW1lZGlhdGUpe3JldHVybiBmdW5jdGlvbihmKXtyZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKX19aWYoY2FuUG9zdCl7dmFyIHF1ZXVlPVtdO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGZ1bmN0aW9uKGV2KXt2YXIgc291cmNlPWV2LnNvdXJjZTtpZigoc291cmNlPT09d2luZG93fHxzb3VyY2U9PT1udWxsKSYmZXYuZGF0YT09PVwicHJvY2Vzcy10aWNrXCIpe2V2LnN0b3BQcm9wYWdhdGlvbigpO2lmKHF1ZXVlLmxlbmd0aD4wKXt2YXIgZm49cXVldWUuc2hpZnQoKTtmbigpfX19LHRydWUpO3JldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbil7cXVldWUucHVzaChmbik7d2luZG93LnBvc3RNZXNzYWdlKFwicHJvY2Vzcy10aWNrXCIsXCIqXCIpfX1yZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pe3NldFRpbWVvdXQoZm4sMCl9fSgpO3Byb2Nlc3MudGl0bGU9XCJicm93c2VyXCI7cHJvY2Vzcy5icm93c2VyPXRydWU7cHJvY2Vzcy5lbnY9e307cHJvY2Vzcy5hcmd2PVtdO2Z1bmN0aW9uIG5vb3AoKXt9cHJvY2Vzcy5vbj1ub29wO3Byb2Nlc3MuYWRkTGlzdGVuZXI9bm9vcDtwcm9jZXNzLm9uY2U9bm9vcDtwcm9jZXNzLm9mZj1ub29wO3Byb2Nlc3MucmVtb3ZlTGlzdGVuZXI9bm9vcDtwcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3Byb2Nlc3MuZW1pdD1ub29wO3Byb2Nlc3MuYmluZGluZz1mdW5jdGlvbihuYW1lKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07cHJvY2Vzcy5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07cHJvY2Vzcy5jaGRpcj1mdW5jdGlvbihkaXIpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX19LHt9XSwxNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9X2RlcmVxXygyKX0se31dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1fZGVyZXFfKDMpfSx7XCIuL3N1cHBvcnQvaXNCdWZmZXJcIjoxNixGV2FBU0g6MTUsaW5oZXJpdHM6MTR9XSwxODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9lbmMtYmFzZTY0XCIpLF9kZXJlcV8oXCIuL21kNVwiKSxfZGVyZXFfKFwiLi9ldnBrZGZcIiksX2RlcmVxXyhcIi4vY2lwaGVyLWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9lbmMtYmFzZTY0XCIsXCIuL21kNVwiLFwiLi9ldnBrZGZcIixcIi4vY2lwaGVyLWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbigpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgQmxvY2tDaXBoZXI9Q19saWIuQmxvY2tDaXBoZXI7dmFyIENfYWxnbz1DLmFsZ287dmFyIFNCT1g9W107dmFyIElOVl9TQk9YPVtdO3ZhciBTVUJfTUlYXzA9W107dmFyIFNVQl9NSVhfMT1bXTt2YXIgU1VCX01JWF8yPVtdO3ZhciBTVUJfTUlYXzM9W107dmFyIElOVl9TVUJfTUlYXzA9W107dmFyIElOVl9TVUJfTUlYXzE9W107dmFyIElOVl9TVUJfTUlYXzI9W107dmFyIElOVl9TVUJfTUlYXzM9W107KGZ1bmN0aW9uKCl7dmFyIGQ9W107Zm9yKHZhciBpPTA7aTwyNTY7aSsrKXtpZihpPDEyOCl7ZFtpXT1pPDwxfWVsc2V7ZFtpXT1pPDwxXjI4M319dmFyIHg9MDt2YXIgeGk9MDtmb3IodmFyIGk9MDtpPDI1NjtpKyspe3ZhciBzeD14aV54aTw8MV54aTw8Ml54aTw8M154aTw8NDtzeD1zeD4+Pjhec3gmMjU1Xjk5O1NCT1hbeF09c3g7SU5WX1NCT1hbc3hdPXg7dmFyIHgyPWRbeF07dmFyIHg0PWRbeDJdO3ZhciB4OD1kW3g0XTt2YXIgdD1kW3N4XSoyNTdec3gqMTY4NDMwMDg7U1VCX01JWF8wW3hdPXQ8PDI0fHQ+Pj44O1NVQl9NSVhfMVt4XT10PDwxNnx0Pj4+MTY7U1VCX01JWF8yW3hdPXQ8PDh8dD4+PjI0O1NVQl9NSVhfM1t4XT10O3ZhciB0PXg4KjE2ODQzMDA5Xng0KjY1NTM3XngyKjI1N154KjE2ODQzMDA4O0lOVl9TVUJfTUlYXzBbc3hdPXQ8PDI0fHQ+Pj44O0lOVl9TVUJfTUlYXzFbc3hdPXQ8PDE2fHQ+Pj4xNjtJTlZfU1VCX01JWF8yW3N4XT10PDw4fHQ+Pj4yNDtJTlZfU1VCX01JWF8zW3N4XT10O2lmKCF4KXt4PXhpPTF9ZWxzZXt4PXgyXmRbZFtkW3g4XngyXV1dO3hpXj1kW2RbeGldXX19fSkoKTt2YXIgUkNPTj1bMCwxLDIsNCw4LDE2LDMyLDY0LDEyOCwyNyw1NF07dmFyIEFFUz1DX2FsZ28uQUVTPUJsb2NrQ2lwaGVyLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt2YXIga2V5PXRoaXMuX2tleTt2YXIga2V5V29yZHM9a2V5LndvcmRzO3ZhciBrZXlTaXplPWtleS5zaWdCeXRlcy80O3ZhciBuUm91bmRzPXRoaXMuX25Sb3VuZHM9a2V5U2l6ZSs2O3ZhciBrc1Jvd3M9KG5Sb3VuZHMrMSkqNDt2YXIga2V5U2NoZWR1bGU9dGhpcy5fa2V5U2NoZWR1bGU9W107Zm9yKHZhciBrc1Jvdz0wO2tzUm93PGtzUm93cztrc1JvdysrKXtpZihrc1JvdzxrZXlTaXplKXtrZXlTY2hlZHVsZVtrc1Jvd109a2V5V29yZHNba3NSb3ddfWVsc2V7dmFyIHQ9a2V5U2NoZWR1bGVba3NSb3ctMV07aWYoIShrc1JvdyVrZXlTaXplKSl7dD10PDw4fHQ+Pj4yNDt0PVNCT1hbdD4+PjI0XTw8MjR8U0JPWFt0Pj4+MTYmMjU1XTw8MTZ8U0JPWFt0Pj4+OCYyNTVdPDw4fFNCT1hbdCYyNTVdO3RePVJDT05ba3NSb3cva2V5U2l6ZXwwXTw8MjR9ZWxzZSBpZihrZXlTaXplPjYmJmtzUm93JWtleVNpemU9PTQpe3Q9U0JPWFt0Pj4+MjRdPDwyNHxTQk9YW3Q+Pj4xNiYyNTVdPDwxNnxTQk9YW3Q+Pj44JjI1NV08PDh8U0JPWFt0JjI1NV19a2V5U2NoZWR1bGVba3NSb3ddPWtleVNjaGVkdWxlW2tzUm93LWtleVNpemVdXnR9fXZhciBpbnZLZXlTY2hlZHVsZT10aGlzLl9pbnZLZXlTY2hlZHVsZT1bXTtmb3IodmFyIGludktzUm93PTA7aW52S3NSb3c8a3NSb3dzO2ludktzUm93Kyspe3ZhciBrc1Jvdz1rc1Jvd3MtaW52S3NSb3c7aWYoaW52S3NSb3clNCl7dmFyIHQ9a2V5U2NoZWR1bGVba3NSb3ddfWVsc2V7dmFyIHQ9a2V5U2NoZWR1bGVba3NSb3ctNF19aWYoaW52S3NSb3c8NHx8a3NSb3c8PTQpe2ludktleVNjaGVkdWxlW2ludktzUm93XT10fWVsc2V7aW52S2V5U2NoZWR1bGVbaW52S3NSb3ddPUlOVl9TVUJfTUlYXzBbU0JPWFt0Pj4+MjRdXV5JTlZfU1VCX01JWF8xW1NCT1hbdD4+PjE2JjI1NV1dXklOVl9TVUJfTUlYXzJbU0JPWFt0Pj4+OCYyNTVdXV5JTlZfU1VCX01JWF8zW1NCT1hbdCYyNTVdXX19fSxlbmNyeXB0QmxvY2s6ZnVuY3Rpb24oTSxvZmZzZXQpe3RoaXMuX2RvQ3J5cHRCbG9jayhNLG9mZnNldCx0aGlzLl9rZXlTY2hlZHVsZSxTVUJfTUlYXzAsU1VCX01JWF8xLFNVQl9NSVhfMixTVUJfTUlYXzMsU0JPWCl9LGRlY3J5cHRCbG9jazpmdW5jdGlvbihNLG9mZnNldCl7dmFyIHQ9TVtvZmZzZXQrMV07TVtvZmZzZXQrMV09TVtvZmZzZXQrM107TVtvZmZzZXQrM109dDt0aGlzLl9kb0NyeXB0QmxvY2soTSxvZmZzZXQsdGhpcy5faW52S2V5U2NoZWR1bGUsSU5WX1NVQl9NSVhfMCxJTlZfU1VCX01JWF8xLElOVl9TVUJfTUlYXzIsSU5WX1NVQl9NSVhfMyxJTlZfU0JPWCk7dmFyIHQ9TVtvZmZzZXQrMV07TVtvZmZzZXQrMV09TVtvZmZzZXQrM107TVtvZmZzZXQrM109dH0sX2RvQ3J5cHRCbG9jazpmdW5jdGlvbihNLG9mZnNldCxrZXlTY2hlZHVsZSxTVUJfTUlYXzAsU1VCX01JWF8xLFNVQl9NSVhfMixTVUJfTUlYXzMsU0JPWCl7dmFyIG5Sb3VuZHM9dGhpcy5fblJvdW5kczt2YXIgczA9TVtvZmZzZXRdXmtleVNjaGVkdWxlWzBdO3ZhciBzMT1NW29mZnNldCsxXV5rZXlTY2hlZHVsZVsxXTt2YXIgczI9TVtvZmZzZXQrMl1ea2V5U2NoZWR1bGVbMl07dmFyIHMzPU1bb2Zmc2V0KzNdXmtleVNjaGVkdWxlWzNdO3ZhciBrc1Jvdz00O2Zvcih2YXIgcm91bmQ9MTtyb3VuZDxuUm91bmRzO3JvdW5kKyspe3ZhciB0MD1TVUJfTUlYXzBbczA+Pj4yNF1eU1VCX01JWF8xW3MxPj4+MTYmMjU1XV5TVUJfTUlYXzJbczI+Pj44JjI1NV1eU1VCX01JWF8zW3MzJjI1NV1ea2V5U2NoZWR1bGVba3NSb3crK107dmFyIHQxPVNVQl9NSVhfMFtzMT4+PjI0XV5TVUJfTUlYXzFbczI+Pj4xNiYyNTVdXlNVQl9NSVhfMltzMz4+PjgmMjU1XV5TVUJfTUlYXzNbczAmMjU1XV5rZXlTY2hlZHVsZVtrc1JvdysrXTt2YXIgdDI9U1VCX01JWF8wW3MyPj4+MjRdXlNVQl9NSVhfMVtzMz4+PjE2JjI1NV1eU1VCX01JWF8yW3MwPj4+OCYyNTVdXlNVQl9NSVhfM1tzMSYyNTVdXmtleVNjaGVkdWxlW2tzUm93KytdO3ZhciB0Mz1TVUJfTUlYXzBbczM+Pj4yNF1eU1VCX01JWF8xW3MwPj4+MTYmMjU1XV5TVUJfTUlYXzJbczE+Pj44JjI1NV1eU1VCX01JWF8zW3MyJjI1NV1ea2V5U2NoZWR1bGVba3NSb3crK107czA9dDA7czE9dDE7czI9dDI7czM9dDN9dmFyIHQwPShTQk9YW3MwPj4+MjRdPDwyNHxTQk9YW3MxPj4+MTYmMjU1XTw8MTZ8U0JPWFtzMj4+PjgmMjU1XTw8OHxTQk9YW3MzJjI1NV0pXmtleVNjaGVkdWxlW2tzUm93KytdO3ZhciB0MT0oU0JPWFtzMT4+PjI0XTw8MjR8U0JPWFtzMj4+PjE2JjI1NV08PDE2fFNCT1hbczM+Pj44JjI1NV08PDh8U0JPWFtzMCYyNTVdKV5rZXlTY2hlZHVsZVtrc1JvdysrXTt2YXIgdDI9KFNCT1hbczI+Pj4yNF08PDI0fFNCT1hbczM+Pj4xNiYyNTVdPDwxNnxTQk9YW3MwPj4+OCYyNTVdPDw4fFNCT1hbczEmMjU1XSlea2V5U2NoZWR1bGVba3NSb3crK107dmFyIHQzPShTQk9YW3MzPj4+MjRdPDwyNHxTQk9YW3MwPj4+MTYmMjU1XTw8MTZ8U0JPWFtzMT4+PjgmMjU1XTw8OHxTQk9YW3MyJjI1NV0pXmtleVNjaGVkdWxlW2tzUm93KytdO01bb2Zmc2V0XT10MDtNW29mZnNldCsxXT10MTtNW29mZnNldCsyXT10MjtNW29mZnNldCszXT10M30sa2V5U2l6ZToyNTYvMzJ9KTtDLkFFUz1CbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKEFFUyl9KSgpO3JldHVybiBDcnlwdG9KUy5BRVN9KX0se1wiLi9jaXBoZXItY29yZVwiOjE5LFwiLi9jb3JlXCI6MjAsXCIuL2VuYy1iYXNlNjRcIjoyMSxcIi4vZXZwa2RmXCI6MjMsXCIuL21kNVwiOjI5fV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3Rvcnkpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7Q3J5cHRvSlMubGliLkNpcGhlcnx8ZnVuY3Rpb24odW5kZWZpbmVkKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIEJhc2U9Q19saWIuQmFzZTt2YXIgV29yZEFycmF5PUNfbGliLldvcmRBcnJheTt2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobT1DX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtO3ZhciBDX2VuYz1DLmVuYzt2YXIgVXRmOD1DX2VuYy5VdGY4O3ZhciBCYXNlNjQ9Q19lbmMuQmFzZTY0O3ZhciBDX2FsZ289Qy5hbGdvO3ZhciBFdnBLREY9Q19hbGdvLkV2cEtERjt2YXIgQ2lwaGVyPUNfbGliLkNpcGhlcj1CdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7Y2ZnOkJhc2UuZXh0ZW5kKCksY3JlYXRlRW5jcnlwdG9yOmZ1bmN0aW9uKGtleSxjZmcpe3JldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9FTkNfWEZPUk1fTU9ERSxrZXksY2ZnKX0sY3JlYXRlRGVjcnlwdG9yOmZ1bmN0aW9uKGtleSxjZmcpe3JldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9ERUNfWEZPUk1fTU9ERSxrZXksY2ZnKX0saW5pdDpmdW5jdGlvbih4Zm9ybU1vZGUsa2V5LGNmZyl7dGhpcy5jZmc9dGhpcy5jZmcuZXh0ZW5kKGNmZyk7dGhpcy5feGZvcm1Nb2RlPXhmb3JtTW9kZTt0aGlzLl9rZXk9a2V5O3RoaXMucmVzZXQoKX0scmVzZXQ6ZnVuY3Rpb24oKXtCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7dGhpcy5fZG9SZXNldCgpfSxwcm9jZXNzOmZ1bmN0aW9uKGRhdGFVcGRhdGUpe3RoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtyZXR1cm4gdGhpcy5fcHJvY2VzcygpfSxmaW5hbGl6ZTpmdW5jdGlvbihkYXRhVXBkYXRlKXtpZihkYXRhVXBkYXRlKXt0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSl9dmFyIGZpbmFsUHJvY2Vzc2VkRGF0YT10aGlzLl9kb0ZpbmFsaXplKCk7cmV0dXJuIGZpbmFsUHJvY2Vzc2VkRGF0YX0sa2V5U2l6ZToxMjgvMzIsaXZTaXplOjEyOC8zMixfRU5DX1hGT1JNX01PREU6MSxfREVDX1hGT1JNX01PREU6MixfY3JlYXRlSGVscGVyOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KXtpZih0eXBlb2Yga2V5PT1cInN0cmluZ1wiKXtyZXR1cm4gUGFzc3dvcmRCYXNlZENpcGhlcn1lbHNle3JldHVybiBTZXJpYWxpemFibGVDaXBoZXJ9fXJldHVybiBmdW5jdGlvbihjaXBoZXIpe3JldHVybntlbmNyeXB0OmZ1bmN0aW9uKG1lc3NhZ2Usa2V5LGNmZyl7cmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZW5jcnlwdChjaXBoZXIsbWVzc2FnZSxrZXksY2ZnKX0sZGVjcnlwdDpmdW5jdGlvbihjaXBoZXJ0ZXh0LGtleSxjZmcpe3JldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmRlY3J5cHQoY2lwaGVyLGNpcGhlcnRleHQsa2V5LGNmZyl9fX19KCl9KTt2YXIgU3RyZWFtQ2lwaGVyPUNfbGliLlN0cmVhbUNpcGhlcj1DaXBoZXIuZXh0ZW5kKHtfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciBmaW5hbFByb2Nlc3NlZEJsb2Nrcz10aGlzLl9wcm9jZXNzKCEhXCJmbHVzaFwiKTtyZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3N9LGJsb2NrU2l6ZToxfSk7dmFyIENfbW9kZT1DLm1vZGU9e307dmFyIEJsb2NrQ2lwaGVyTW9kZT1DX2xpYi5CbG9ja0NpcGhlck1vZGU9QmFzZS5leHRlbmQoe2NyZWF0ZUVuY3J5cHRvcjpmdW5jdGlvbihjaXBoZXIsaXYpe3JldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLGl2KX0sY3JlYXRlRGVjcnlwdG9yOmZ1bmN0aW9uKGNpcGhlcixpdil7cmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZShjaXBoZXIsaXYpfSxpbml0OmZ1bmN0aW9uKGNpcGhlcixpdil7dGhpcy5fY2lwaGVyPWNpcGhlcjt0aGlzLl9pdj1pdn19KTt2YXIgQ0JDPUNfbW9kZS5DQkM9ZnVuY3Rpb24oKXt2YXIgQ0JDPUJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtDQkMuRW5jcnlwdG9yPUNCQy5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih3b3JkcyxvZmZzZXQpe3ZhciBjaXBoZXI9dGhpcy5fY2lwaGVyO3ZhciBibG9ja1NpemU9Y2lwaGVyLmJsb2NrU2l6ZTt4b3JCbG9jay5jYWxsKHRoaXMsd29yZHMsb2Zmc2V0LGJsb2NrU2l6ZSk7Y2lwaGVyLmVuY3J5cHRCbG9jayh3b3JkcyxvZmZzZXQpO3RoaXMuX3ByZXZCbG9jaz13b3Jkcy5zbGljZShvZmZzZXQsb2Zmc2V0K2Jsb2NrU2l6ZSl9fSk7Q0JDLkRlY3J5cHRvcj1DQkMuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24od29yZHMsb2Zmc2V0KXt2YXIgY2lwaGVyPXRoaXMuX2NpcGhlcjt2YXIgYmxvY2tTaXplPWNpcGhlci5ibG9ja1NpemU7dmFyIHRoaXNCbG9jaz13b3Jkcy5zbGljZShvZmZzZXQsb2Zmc2V0K2Jsb2NrU2l6ZSk7Y2lwaGVyLmRlY3J5cHRCbG9jayh3b3JkcyxvZmZzZXQpO3hvckJsb2NrLmNhbGwodGhpcyx3b3JkcyxvZmZzZXQsYmxvY2tTaXplKTt0aGlzLl9wcmV2QmxvY2s9dGhpc0Jsb2NrfX0pO2Z1bmN0aW9uIHhvckJsb2NrKHdvcmRzLG9mZnNldCxibG9ja1NpemUpe3ZhciBpdj10aGlzLl9pdjtpZihpdil7dmFyIGJsb2NrPWl2O3RoaXMuX2l2PXVuZGVmaW5lZH1lbHNle3ZhciBibG9jaz10aGlzLl9wcmV2QmxvY2t9Zm9yKHZhciBpPTA7aTxibG9ja1NpemU7aSsrKXt3b3Jkc1tvZmZzZXQraV1ePWJsb2NrW2ldfX1yZXR1cm4gQ0JDfSgpO3ZhciBDX3BhZD1DLnBhZD17fTt2YXIgUGtjczc9Q19wYWQuUGtjczc9e3BhZDpmdW5jdGlvbihkYXRhLGJsb2NrU2l6ZSl7dmFyIGJsb2NrU2l6ZUJ5dGVzPWJsb2NrU2l6ZSo0O3ZhciBuUGFkZGluZ0J5dGVzPWJsb2NrU2l6ZUJ5dGVzLWRhdGEuc2lnQnl0ZXMlYmxvY2tTaXplQnl0ZXM7dmFyIHBhZGRpbmdXb3JkPW5QYWRkaW5nQnl0ZXM8PDI0fG5QYWRkaW5nQnl0ZXM8PDE2fG5QYWRkaW5nQnl0ZXM8PDh8blBhZGRpbmdCeXRlczt2YXIgcGFkZGluZ1dvcmRzPVtdO2Zvcih2YXIgaT0wO2k8blBhZGRpbmdCeXRlcztpKz00KXtwYWRkaW5nV29yZHMucHVzaChwYWRkaW5nV29yZCl9dmFyIHBhZGRpbmc9V29yZEFycmF5LmNyZWF0ZShwYWRkaW5nV29yZHMsblBhZGRpbmdCeXRlcyk7ZGF0YS5jb25jYXQocGFkZGluZyl9LHVucGFkOmZ1bmN0aW9uKGRhdGEpe3ZhciBuUGFkZGluZ0J5dGVzPWRhdGEud29yZHNbZGF0YS5zaWdCeXRlcy0xPj4+Ml0mMjU1O2RhdGEuc2lnQnl0ZXMtPW5QYWRkaW5nQnl0ZXN9fTt2YXIgQmxvY2tDaXBoZXI9Q19saWIuQmxvY2tDaXBoZXI9Q2lwaGVyLmV4dGVuZCh7Y2ZnOkNpcGhlci5jZmcuZXh0ZW5kKHttb2RlOkNCQyxwYWRkaW5nOlBrY3M3fSkscmVzZXQ6ZnVuY3Rpb24oKXtDaXBoZXIucmVzZXQuY2FsbCh0aGlzKTt2YXIgY2ZnPXRoaXMuY2ZnO3ZhciBpdj1jZmcuaXY7dmFyIG1vZGU9Y2ZnLm1vZGU7aWYodGhpcy5feGZvcm1Nb2RlPT10aGlzLl9FTkNfWEZPUk1fTU9ERSl7dmFyIG1vZGVDcmVhdG9yPW1vZGUuY3JlYXRlRW5jcnlwdG9yfWVsc2V7dmFyIG1vZGVDcmVhdG9yPW1vZGUuY3JlYXRlRGVjcnlwdG9yO3RoaXMuX21pbkJ1ZmZlclNpemU9MX10aGlzLl9tb2RlPW1vZGVDcmVhdG9yLmNhbGwobW9kZSx0aGlzLGl2JiZpdi53b3Jkcyl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbih3b3JkcyxvZmZzZXQpe3RoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKHdvcmRzLG9mZnNldCl9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIHBhZGRpbmc9dGhpcy5jZmcucGFkZGluZztpZih0aGlzLl94Zm9ybU1vZGU9PXRoaXMuX0VOQ19YRk9STV9NT0RFKXtwYWRkaW5nLnBhZCh0aGlzLl9kYXRhLHRoaXMuYmxvY2tTaXplKTt2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3M9dGhpcy5fcHJvY2VzcyghIVwiZmx1c2hcIil9ZWxzZXt2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3M9dGhpcy5fcHJvY2VzcyghIVwiZmx1c2hcIik7cGFkZGluZy51bnBhZChmaW5hbFByb2Nlc3NlZEJsb2Nrcyl9cmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzfSxibG9ja1NpemU6MTI4LzMyfSk7dmFyIENpcGhlclBhcmFtcz1DX2xpYi5DaXBoZXJQYXJhbXM9QmFzZS5leHRlbmQoe2luaXQ6ZnVuY3Rpb24oY2lwaGVyUGFyYW1zKXt0aGlzLm1peEluKGNpcGhlclBhcmFtcyl9LHRvU3RyaW5nOmZ1bmN0aW9uKGZvcm1hdHRlcil7cmV0dXJuKGZvcm1hdHRlcnx8dGhpcy5mb3JtYXR0ZXIpLnN0cmluZ2lmeSh0aGlzKX19KTt2YXIgQ19mb3JtYXQ9Qy5mb3JtYXQ9e307dmFyIE9wZW5TU0xGb3JtYXR0ZXI9Q19mb3JtYXQuT3BlblNTTD17c3RyaW5naWZ5OmZ1bmN0aW9uKGNpcGhlclBhcmFtcyl7dmFyIGNpcGhlcnRleHQ9Y2lwaGVyUGFyYW1zLmNpcGhlcnRleHQ7dmFyIHNhbHQ9Y2lwaGVyUGFyYW1zLnNhbHQ7aWYoc2FsdCl7dmFyIHdvcmRBcnJheT1Xb3JkQXJyYXkuY3JlYXRlKFsxMzk4ODkzNjg0LDE3MDEwNzY4MzFdKS5jb25jYXQoc2FsdCkuY29uY2F0KGNpcGhlcnRleHQpfWVsc2V7dmFyIHdvcmRBcnJheT1jaXBoZXJ0ZXh0fXJldHVybiB3b3JkQXJyYXkudG9TdHJpbmcoQmFzZTY0KX0scGFyc2U6ZnVuY3Rpb24ob3BlblNTTFN0cil7dmFyIGNpcGhlcnRleHQ9QmFzZTY0LnBhcnNlKG9wZW5TU0xTdHIpO3ZhciBjaXBoZXJ0ZXh0V29yZHM9Y2lwaGVydGV4dC53b3JkcztpZihjaXBoZXJ0ZXh0V29yZHNbMF09PTEzOTg4OTM2ODQmJmNpcGhlcnRleHRXb3Jkc1sxXT09MTcwMTA3NjgzMSl7dmFyIHNhbHQ9V29yZEFycmF5LmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoMiw0KSk7Y2lwaGVydGV4dFdvcmRzLnNwbGljZSgwLDQpO2NpcGhlcnRleHQuc2lnQnl0ZXMtPTE2fXJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHtjaXBoZXJ0ZXh0OmNpcGhlcnRleHQsc2FsdDpzYWx0fSl9fTt2YXIgU2VyaWFsaXphYmxlQ2lwaGVyPUNfbGliLlNlcmlhbGl6YWJsZUNpcGhlcj1CYXNlLmV4dGVuZCh7Y2ZnOkJhc2UuZXh0ZW5kKHtmb3JtYXQ6T3BlblNTTEZvcm1hdHRlcn0pLGVuY3J5cHQ6ZnVuY3Rpb24oY2lwaGVyLG1lc3NhZ2Usa2V5LGNmZyl7Y2ZnPXRoaXMuY2ZnLmV4dGVuZChjZmcpO3ZhciBlbmNyeXB0b3I9Y2lwaGVyLmNyZWF0ZUVuY3J5cHRvcihrZXksY2ZnKTt2YXIgY2lwaGVydGV4dD1lbmNyeXB0b3IuZmluYWxpemUobWVzc2FnZSk7dmFyIGNpcGhlckNmZz1lbmNyeXB0b3IuY2ZnO3JldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHtjaXBoZXJ0ZXh0OmNpcGhlcnRleHQsa2V5OmtleSxpdjpjaXBoZXJDZmcuaXYsYWxnb3JpdGhtOmNpcGhlcixtb2RlOmNpcGhlckNmZy5tb2RlLHBhZGRpbmc6Y2lwaGVyQ2ZnLnBhZGRpbmcsYmxvY2tTaXplOmNpcGhlci5ibG9ja1NpemUsZm9ybWF0dGVyOmNmZy5mb3JtYXR9KX0sZGVjcnlwdDpmdW5jdGlvbihjaXBoZXIsY2lwaGVydGV4dCxrZXksY2ZnKXtjZmc9dGhpcy5jZmcuZXh0ZW5kKGNmZyk7Y2lwaGVydGV4dD10aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LGNmZy5mb3JtYXQpO3ZhciBwbGFpbnRleHQ9Y2lwaGVyLmNyZWF0ZURlY3J5cHRvcihrZXksY2ZnKS5maW5hbGl6ZShjaXBoZXJ0ZXh0LmNpcGhlcnRleHQpO3JldHVybiBwbGFpbnRleHR9LF9wYXJzZTpmdW5jdGlvbihjaXBoZXJ0ZXh0LGZvcm1hdCl7aWYodHlwZW9mIGNpcGhlcnRleHQ9PVwic3RyaW5nXCIpe3JldHVybiBmb3JtYXQucGFyc2UoY2lwaGVydGV4dCx0aGlzKX1lbHNle3JldHVybiBjaXBoZXJ0ZXh0fX19KTt2YXIgQ19rZGY9Qy5rZGY9e307dmFyIE9wZW5TU0xLZGY9Q19rZGYuT3BlblNTTD17ZXhlY3V0ZTpmdW5jdGlvbihwYXNzd29yZCxrZXlTaXplLGl2U2l6ZSxzYWx0KXtpZighc2FsdCl7c2FsdD1Xb3JkQXJyYXkucmFuZG9tKDY0LzgpfXZhciBrZXk9RXZwS0RGLmNyZWF0ZSh7a2V5U2l6ZTprZXlTaXplK2l2U2l6ZX0pLmNvbXB1dGUocGFzc3dvcmQsc2FsdCk7dmFyIGl2PVdvcmRBcnJheS5jcmVhdGUoa2V5LndvcmRzLnNsaWNlKGtleVNpemUpLGl2U2l6ZSo0KTtrZXkuc2lnQnl0ZXM9a2V5U2l6ZSo0O3JldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHtrZXk6a2V5LGl2Oml2LHNhbHQ6c2FsdH0pfX07dmFyIFBhc3N3b3JkQmFzZWRDaXBoZXI9Q19saWIuUGFzc3dvcmRCYXNlZENpcGhlcj1TZXJpYWxpemFibGVDaXBoZXIuZXh0ZW5kKHtjZmc6U2VyaWFsaXphYmxlQ2lwaGVyLmNmZy5leHRlbmQoe2tkZjpPcGVuU1NMS2RmfSksZW5jcnlwdDpmdW5jdGlvbihjaXBoZXIsbWVzc2FnZSxwYXNzd29yZCxjZmcpe2NmZz10aGlzLmNmZy5leHRlbmQoY2ZnKTt2YXIgZGVyaXZlZFBhcmFtcz1jZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsY2lwaGVyLmtleVNpemUsY2lwaGVyLml2U2l6ZSk7Y2ZnLml2PWRlcml2ZWRQYXJhbXMuaXY7dmFyIGNpcGhlcnRleHQ9U2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQuY2FsbCh0aGlzLGNpcGhlcixtZXNzYWdlLGRlcml2ZWRQYXJhbXMua2V5LGNmZyk7XG5jaXBoZXJ0ZXh0Lm1peEluKGRlcml2ZWRQYXJhbXMpO3JldHVybiBjaXBoZXJ0ZXh0fSxkZWNyeXB0OmZ1bmN0aW9uKGNpcGhlcixjaXBoZXJ0ZXh0LHBhc3N3b3JkLGNmZyl7Y2ZnPXRoaXMuY2ZnLmV4dGVuZChjZmcpO2NpcGhlcnRleHQ9dGhpcy5fcGFyc2UoY2lwaGVydGV4dCxjZmcuZm9ybWF0KTt2YXIgZGVyaXZlZFBhcmFtcz1jZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsY2lwaGVyLmtleVNpemUsY2lwaGVyLml2U2l6ZSxjaXBoZXJ0ZXh0LnNhbHQpO2NmZy5pdj1kZXJpdmVkUGFyYW1zLml2O3ZhciBwbGFpbnRleHQ9U2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQuY2FsbCh0aGlzLGNpcGhlcixjaXBoZXJ0ZXh0LGRlcml2ZWRQYXJhbXMua2V5LGNmZyk7cmV0dXJuIHBsYWludGV4dH19KX0oKX0pfSx7XCIuL2NvcmVcIjoyMH1dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5KXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeSgpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGZhY3RvcnkpfWVsc2V7cm9vdC5DcnlwdG9KUz1mYWN0b3J5KCl9fSkodGhpcyxmdW5jdGlvbigpe3ZhciBDcnlwdG9KUz1DcnlwdG9KU3x8ZnVuY3Rpb24oTWF0aCx1bmRlZmluZWQpe3ZhciBDPXt9O3ZhciBDX2xpYj1DLmxpYj17fTt2YXIgQmFzZT1DX2xpYi5CYXNlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gRigpe31yZXR1cm57ZXh0ZW5kOmZ1bmN0aW9uKG92ZXJyaWRlcyl7Ri5wcm90b3R5cGU9dGhpczt2YXIgc3VidHlwZT1uZXcgRjtpZihvdmVycmlkZXMpe3N1YnR5cGUubWl4SW4ob3ZlcnJpZGVzKX1pZighc3VidHlwZS5oYXNPd25Qcm9wZXJ0eShcImluaXRcIikpe3N1YnR5cGUuaW5pdD1mdW5jdGlvbigpe3N1YnR5cGUuJHN1cGVyLmluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfX1zdWJ0eXBlLmluaXQucHJvdG90eXBlPXN1YnR5cGU7c3VidHlwZS4kc3VwZXI9dGhpcztyZXR1cm4gc3VidHlwZX0sY3JlYXRlOmZ1bmN0aW9uKCl7dmFyIGluc3RhbmNlPXRoaXMuZXh0ZW5kKCk7aW5zdGFuY2UuaW5pdC5hcHBseShpbnN0YW5jZSxhcmd1bWVudHMpO3JldHVybiBpbnN0YW5jZX0saW5pdDpmdW5jdGlvbigpe30sbWl4SW46ZnVuY3Rpb24ocHJvcGVydGllcyl7Zm9yKHZhciBwcm9wZXJ0eU5hbWUgaW4gcHJvcGVydGllcyl7aWYocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKXt0aGlzW3Byb3BlcnR5TmFtZV09cHJvcGVydGllc1twcm9wZXJ0eU5hbWVdfX1pZihwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFwidG9TdHJpbmdcIikpe3RoaXMudG9TdHJpbmc9cHJvcGVydGllcy50b1N0cmluZ319LGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpfX19KCk7dmFyIFdvcmRBcnJheT1DX2xpYi5Xb3JkQXJyYXk9QmFzZS5leHRlbmQoe2luaXQ6ZnVuY3Rpb24od29yZHMsc2lnQnl0ZXMpe3dvcmRzPXRoaXMud29yZHM9d29yZHN8fFtdO2lmKHNpZ0J5dGVzIT11bmRlZmluZWQpe3RoaXMuc2lnQnl0ZXM9c2lnQnl0ZXN9ZWxzZXt0aGlzLnNpZ0J5dGVzPXdvcmRzLmxlbmd0aCo0fX0sdG9TdHJpbmc6ZnVuY3Rpb24oZW5jb2Rlcil7cmV0dXJuKGVuY29kZXJ8fEhleCkuc3RyaW5naWZ5KHRoaXMpfSxjb25jYXQ6ZnVuY3Rpb24od29yZEFycmF5KXt2YXIgdGhpc1dvcmRzPXRoaXMud29yZHM7dmFyIHRoYXRXb3Jkcz13b3JkQXJyYXkud29yZHM7dmFyIHRoaXNTaWdCeXRlcz10aGlzLnNpZ0J5dGVzO3ZhciB0aGF0U2lnQnl0ZXM9d29yZEFycmF5LnNpZ0J5dGVzO3RoaXMuY2xhbXAoKTtpZih0aGlzU2lnQnl0ZXMlNCl7Zm9yKHZhciBpPTA7aTx0aGF0U2lnQnl0ZXM7aSsrKXt2YXIgdGhhdEJ5dGU9dGhhdFdvcmRzW2k+Pj4yXT4+PjI0LWklNCo4JjI1NTt0aGlzV29yZHNbdGhpc1NpZ0J5dGVzK2k+Pj4yXXw9dGhhdEJ5dGU8PDI0LSh0aGlzU2lnQnl0ZXMraSklNCo4fX1lbHNlIGlmKHRoYXRXb3Jkcy5sZW5ndGg+MjU2KXtmb3IodmFyIGk9MDtpPHRoYXRTaWdCeXRlcztpKz00KXt0aGlzV29yZHNbdGhpc1NpZ0J5dGVzK2k+Pj4yXT10aGF0V29yZHNbaT4+PjJdfX1lbHNle3RoaXNXb3Jkcy5wdXNoLmFwcGx5KHRoaXNXb3Jkcyx0aGF0V29yZHMpfXRoaXMuc2lnQnl0ZXMrPXRoYXRTaWdCeXRlcztyZXR1cm4gdGhpc30sY2xhbXA6ZnVuY3Rpb24oKXt2YXIgd29yZHM9dGhpcy53b3Jkczt2YXIgc2lnQnl0ZXM9dGhpcy5zaWdCeXRlczt3b3Jkc1tzaWdCeXRlcz4+PjJdJj00Mjk0OTY3Mjk1PDwzMi1zaWdCeXRlcyU0Kjg7d29yZHMubGVuZ3RoPU1hdGguY2VpbChzaWdCeXRlcy80KX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgY2xvbmU9QmFzZS5jbG9uZS5jYWxsKHRoaXMpO2Nsb25lLndvcmRzPXRoaXMud29yZHMuc2xpY2UoMCk7cmV0dXJuIGNsb25lfSxyYW5kb206ZnVuY3Rpb24obkJ5dGVzKXt2YXIgd29yZHM9W107Zm9yKHZhciBpPTA7aTxuQnl0ZXM7aSs9NCl7d29yZHMucHVzaChNYXRoLnJhbmRvbSgpKjQyOTQ5NjcyOTZ8MCl9cmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcyxuQnl0ZXMpfX0pO3ZhciBDX2VuYz1DLmVuYz17fTt2YXIgSGV4PUNfZW5jLkhleD17c3RyaW5naWZ5OmZ1bmN0aW9uKHdvcmRBcnJheSl7dmFyIHdvcmRzPXdvcmRBcnJheS53b3Jkczt2YXIgc2lnQnl0ZXM9d29yZEFycmF5LnNpZ0J5dGVzO3ZhciBoZXhDaGFycz1bXTtmb3IodmFyIGk9MDtpPHNpZ0J5dGVzO2krKyl7dmFyIGJpdGU9d29yZHNbaT4+PjJdPj4+MjQtaSU0KjgmMjU1O2hleENoYXJzLnB1c2goKGJpdGU+Pj40KS50b1N0cmluZygxNikpO2hleENoYXJzLnB1c2goKGJpdGUmMTUpLnRvU3RyaW5nKDE2KSl9cmV0dXJuIGhleENoYXJzLmpvaW4oXCJcIil9LHBhcnNlOmZ1bmN0aW9uKGhleFN0cil7dmFyIGhleFN0ckxlbmd0aD1oZXhTdHIubGVuZ3RoO3ZhciB3b3Jkcz1bXTtmb3IodmFyIGk9MDtpPGhleFN0ckxlbmd0aDtpKz0yKXt3b3Jkc1tpPj4+M118PXBhcnNlSW50KGhleFN0ci5zdWJzdHIoaSwyKSwxNik8PDI0LWklOCo0fXJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsaGV4U3RyTGVuZ3RoLzIpfX07dmFyIExhdGluMT1DX2VuYy5MYXRpbjE9e3N0cmluZ2lmeTpmdW5jdGlvbih3b3JkQXJyYXkpe3ZhciB3b3Jkcz13b3JkQXJyYXkud29yZHM7dmFyIHNpZ0J5dGVzPXdvcmRBcnJheS5zaWdCeXRlczt2YXIgbGF0aW4xQ2hhcnM9W107Zm9yKHZhciBpPTA7aTxzaWdCeXRlcztpKyspe3ZhciBiaXRlPXdvcmRzW2k+Pj4yXT4+PjI0LWklNCo4JjI1NTtsYXRpbjFDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYml0ZSkpfXJldHVybiBsYXRpbjFDaGFycy5qb2luKFwiXCIpfSxwYXJzZTpmdW5jdGlvbihsYXRpbjFTdHIpe3ZhciBsYXRpbjFTdHJMZW5ndGg9bGF0aW4xU3RyLmxlbmd0aDt2YXIgd29yZHM9W107Zm9yKHZhciBpPTA7aTxsYXRpbjFTdHJMZW5ndGg7aSsrKXt3b3Jkc1tpPj4+Ml18PShsYXRpbjFTdHIuY2hhckNvZGVBdChpKSYyNTUpPDwyNC1pJTQqOH1yZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLGxhdGluMVN0ckxlbmd0aCl9fTt2YXIgVXRmOD1DX2VuYy5VdGY4PXtzdHJpbmdpZnk6ZnVuY3Rpb24od29yZEFycmF5KXt0cnl7cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpKSl9Y2F0Y2goZSl7dGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIFVURi04IGRhdGFcIil9fSxwYXJzZTpmdW5jdGlvbih1dGY4U3RyKXtyZXR1cm4gTGF0aW4xLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1dGY4U3RyKSkpfX07dmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG09Q19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobT1CYXNlLmV4dGVuZCh7cmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9kYXRhPW5ldyBXb3JkQXJyYXkuaW5pdDt0aGlzLl9uRGF0YUJ5dGVzPTB9LF9hcHBlbmQ6ZnVuY3Rpb24oZGF0YSl7aWYodHlwZW9mIGRhdGE9PVwic3RyaW5nXCIpe2RhdGE9VXRmOC5wYXJzZShkYXRhKX10aGlzLl9kYXRhLmNvbmNhdChkYXRhKTt0aGlzLl9uRGF0YUJ5dGVzKz1kYXRhLnNpZ0J5dGVzfSxfcHJvY2VzczpmdW5jdGlvbihkb0ZsdXNoKXt2YXIgZGF0YT10aGlzLl9kYXRhO3ZhciBkYXRhV29yZHM9ZGF0YS53b3Jkczt2YXIgZGF0YVNpZ0J5dGVzPWRhdGEuc2lnQnl0ZXM7dmFyIGJsb2NrU2l6ZT10aGlzLmJsb2NrU2l6ZTt2YXIgYmxvY2tTaXplQnl0ZXM9YmxvY2tTaXplKjQ7dmFyIG5CbG9ja3NSZWFkeT1kYXRhU2lnQnl0ZXMvYmxvY2tTaXplQnl0ZXM7aWYoZG9GbHVzaCl7bkJsb2Nrc1JlYWR5PU1hdGguY2VpbChuQmxvY2tzUmVhZHkpfWVsc2V7bkJsb2Nrc1JlYWR5PU1hdGgubWF4KChuQmxvY2tzUmVhZHl8MCktdGhpcy5fbWluQnVmZmVyU2l6ZSwwKX12YXIgbldvcmRzUmVhZHk9bkJsb2Nrc1JlYWR5KmJsb2NrU2l6ZTt2YXIgbkJ5dGVzUmVhZHk9TWF0aC5taW4obldvcmRzUmVhZHkqNCxkYXRhU2lnQnl0ZXMpO2lmKG5Xb3Jkc1JlYWR5KXtmb3IodmFyIG9mZnNldD0wO29mZnNldDxuV29yZHNSZWFkeTtvZmZzZXQrPWJsb2NrU2l6ZSl7dGhpcy5fZG9Qcm9jZXNzQmxvY2soZGF0YVdvcmRzLG9mZnNldCl9dmFyIHByb2Nlc3NlZFdvcmRzPWRhdGFXb3Jkcy5zcGxpY2UoMCxuV29yZHNSZWFkeSk7ZGF0YS5zaWdCeXRlcy09bkJ5dGVzUmVhZHl9cmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdChwcm9jZXNzZWRXb3JkcyxuQnl0ZXNSZWFkeSl9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGNsb25lPUJhc2UuY2xvbmUuY2FsbCh0aGlzKTtjbG9uZS5fZGF0YT10aGlzLl9kYXRhLmNsb25lKCk7cmV0dXJuIGNsb25lfSxfbWluQnVmZmVyU2l6ZTowfSk7dmFyIEhhc2hlcj1DX2xpYi5IYXNoZXI9QnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe2NmZzpCYXNlLmV4dGVuZCgpLGluaXQ6ZnVuY3Rpb24oY2ZnKXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQoY2ZnKTt0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7QnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO3RoaXMuX2RvUmVzZXQoKX0sdXBkYXRlOmZ1bmN0aW9uKG1lc3NhZ2VVcGRhdGUpe3RoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTt0aGlzLl9wcm9jZXNzKCk7cmV0dXJuIHRoaXN9LGZpbmFsaXplOmZ1bmN0aW9uKG1lc3NhZ2VVcGRhdGUpe2lmKG1lc3NhZ2VVcGRhdGUpe3RoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKX12YXIgaGFzaD10aGlzLl9kb0ZpbmFsaXplKCk7cmV0dXJuIGhhc2h9LGJsb2NrU2l6ZTo1MTIvMzIsX2NyZWF0ZUhlbHBlcjpmdW5jdGlvbihoYXNoZXIpe3JldHVybiBmdW5jdGlvbihtZXNzYWdlLGNmZyl7cmV0dXJuIG5ldyBoYXNoZXIuaW5pdChjZmcpLmZpbmFsaXplKG1lc3NhZ2UpfX0sX2NyZWF0ZUhtYWNIZWxwZXI6ZnVuY3Rpb24oaGFzaGVyKXtyZXR1cm4gZnVuY3Rpb24obWVzc2FnZSxrZXkpe3JldHVybiBuZXcgQ19hbGdvLkhNQUMuaW5pdChoYXNoZXIsa2V5KS5maW5hbGl6ZShtZXNzYWdlKX19fSk7dmFyIENfYWxnbz1DLmFsZ289e307cmV0dXJuIEN9KE1hdGgpO3JldHVybiBDcnlwdG9KU30pfSx7fV0sMjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3Rvcnkpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBXb3JkQXJyYXk9Q19saWIuV29yZEFycmF5O3ZhciBDX2VuYz1DLmVuYzt2YXIgQmFzZTY0PUNfZW5jLkJhc2U2ND17c3RyaW5naWZ5OmZ1bmN0aW9uKHdvcmRBcnJheSl7dmFyIHdvcmRzPXdvcmRBcnJheS53b3Jkczt2YXIgc2lnQnl0ZXM9d29yZEFycmF5LnNpZ0J5dGVzO3ZhciBtYXA9dGhpcy5fbWFwO3dvcmRBcnJheS5jbGFtcCgpO3ZhciBiYXNlNjRDaGFycz1bXTtmb3IodmFyIGk9MDtpPHNpZ0J5dGVzO2krPTMpe3ZhciBieXRlMT13b3Jkc1tpPj4+Ml0+Pj4yNC1pJTQqOCYyNTU7dmFyIGJ5dGUyPXdvcmRzW2krMT4+PjJdPj4+MjQtKGkrMSklNCo4JjI1NTt2YXIgYnl0ZTM9d29yZHNbaSsyPj4+Ml0+Pj4yNC0oaSsyKSU0KjgmMjU1O3ZhciB0cmlwbGV0PWJ5dGUxPDwxNnxieXRlMjw8OHxieXRlMztmb3IodmFyIGo9MDtqPDQmJmkraiouNzU8c2lnQnl0ZXM7aisrKXtiYXNlNjRDaGFycy5wdXNoKG1hcC5jaGFyQXQodHJpcGxldD4+PjYqKDMtaikmNjMpKX19dmFyIHBhZGRpbmdDaGFyPW1hcC5jaGFyQXQoNjQpO2lmKHBhZGRpbmdDaGFyKXt3aGlsZShiYXNlNjRDaGFycy5sZW5ndGglNCl7YmFzZTY0Q2hhcnMucHVzaChwYWRkaW5nQ2hhcil9fXJldHVybiBiYXNlNjRDaGFycy5qb2luKFwiXCIpfSxwYXJzZTpmdW5jdGlvbihiYXNlNjRTdHIpe3ZhciBiYXNlNjRTdHJMZW5ndGg9YmFzZTY0U3RyLmxlbmd0aDt2YXIgbWFwPXRoaXMuX21hcDt2YXIgcGFkZGluZ0NoYXI9bWFwLmNoYXJBdCg2NCk7aWYocGFkZGluZ0NoYXIpe3ZhciBwYWRkaW5nSW5kZXg9YmFzZTY0U3RyLmluZGV4T2YocGFkZGluZ0NoYXIpO2lmKHBhZGRpbmdJbmRleCE9LTEpe2Jhc2U2NFN0ckxlbmd0aD1wYWRkaW5nSW5kZXh9fXZhciB3b3Jkcz1bXTt2YXIgbkJ5dGVzPTA7Zm9yKHZhciBpPTA7aTxiYXNlNjRTdHJMZW5ndGg7aSsrKXtpZihpJTQpe3ZhciBiaXRzMT1tYXAuaW5kZXhPZihiYXNlNjRTdHIuY2hhckF0KGktMSkpPDxpJTQqMjt2YXIgYml0czI9bWFwLmluZGV4T2YoYmFzZTY0U3RyLmNoYXJBdChpKSk+Pj42LWklNCoyO3dvcmRzW25CeXRlcz4+PjJdfD0oYml0czF8Yml0czIpPDwyNC1uQnl0ZXMlNCo4O25CeXRlcysrfX1yZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcyxuQnl0ZXMpfSxfbWFwOlwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIn19KSgpO3JldHVybiBDcnlwdG9KUy5lbmMuQmFzZTY0fSl9LHtcIi4vY29yZVwiOjIwfV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3Rvcnkpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBXb3JkQXJyYXk9Q19saWIuV29yZEFycmF5O3ZhciBDX2VuYz1DLmVuYzt2YXIgVXRmMTZCRT1DX2VuYy5VdGYxNj1DX2VuYy5VdGYxNkJFPXtzdHJpbmdpZnk6ZnVuY3Rpb24od29yZEFycmF5KXt2YXIgd29yZHM9d29yZEFycmF5LndvcmRzO3ZhciBzaWdCeXRlcz13b3JkQXJyYXkuc2lnQnl0ZXM7dmFyIHV0ZjE2Q2hhcnM9W107Zm9yKHZhciBpPTA7aTxzaWdCeXRlcztpKz0yKXt2YXIgY29kZVBvaW50PXdvcmRzW2k+Pj4yXT4+PjE2LWklNCo4JjY1NTM1O3V0ZjE2Q2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCkpfXJldHVybiB1dGYxNkNoYXJzLmpvaW4oXCJcIil9LHBhcnNlOmZ1bmN0aW9uKHV0ZjE2U3RyKXt2YXIgdXRmMTZTdHJMZW5ndGg9dXRmMTZTdHIubGVuZ3RoO3ZhciB3b3Jkcz1bXTtmb3IodmFyIGk9MDtpPHV0ZjE2U3RyTGVuZ3RoO2krKyl7d29yZHNbaT4+PjFdfD11dGYxNlN0ci5jaGFyQ29kZUF0KGkpPDwxNi1pJTIqMTZ9cmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsdXRmMTZTdHJMZW5ndGgqMil9fTtDX2VuYy5VdGYxNkxFPXtzdHJpbmdpZnk6ZnVuY3Rpb24od29yZEFycmF5KXt2YXIgd29yZHM9d29yZEFycmF5LndvcmRzO3ZhciBzaWdCeXRlcz13b3JkQXJyYXkuc2lnQnl0ZXM7dmFyIHV0ZjE2Q2hhcnM9W107Zm9yKHZhciBpPTA7aTxzaWdCeXRlcztpKz0yKXt2YXIgY29kZVBvaW50PXN3YXBFbmRpYW4od29yZHNbaT4+PjJdPj4+MTYtaSU0KjgmNjU1MzUpO3V0ZjE2Q2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCkpfXJldHVybiB1dGYxNkNoYXJzLmpvaW4oXCJcIil9LHBhcnNlOmZ1bmN0aW9uKHV0ZjE2U3RyKXt2YXIgdXRmMTZTdHJMZW5ndGg9dXRmMTZTdHIubGVuZ3RoO3ZhciB3b3Jkcz1bXTtmb3IodmFyIGk9MDtpPHV0ZjE2U3RyTGVuZ3RoO2krKyl7d29yZHNbaT4+PjFdfD1zd2FwRW5kaWFuKHV0ZjE2U3RyLmNoYXJDb2RlQXQoaSk8PDE2LWklMioxNil9cmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsdXRmMTZTdHJMZW5ndGgqMil9fTtmdW5jdGlvbiBzd2FwRW5kaWFuKHdvcmQpe3JldHVybiB3b3JkPDw4JjQyNzgyNTUzNjB8d29yZD4+PjgmMTY3MTE5MzV9fSkoKTtyZXR1cm4gQ3J5cHRvSlMuZW5jLlV0ZjE2fSl9LHtcIi4vY29yZVwiOjIwfV0sMjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vc2hhMVwiKSxfZGVyZXFfKFwiLi9obWFjXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vc2hhMVwiLFwiLi9obWFjXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIEJhc2U9Q19saWIuQmFzZTt2YXIgV29yZEFycmF5PUNfbGliLldvcmRBcnJheTt2YXIgQ19hbGdvPUMuYWxnbzt2YXIgTUQ1PUNfYWxnby5NRDU7dmFyIEV2cEtERj1DX2FsZ28uRXZwS0RGPUJhc2UuZXh0ZW5kKHtjZmc6QmFzZS5leHRlbmQoe2tleVNpemU6MTI4LzMyLGhhc2hlcjpNRDUsaXRlcmF0aW9uczoxfSksaW5pdDpmdW5jdGlvbihjZmcpe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZChjZmcpfSxjb21wdXRlOmZ1bmN0aW9uKHBhc3N3b3JkLHNhbHQpe3ZhciBjZmc9dGhpcy5jZmc7dmFyIGhhc2hlcj1jZmcuaGFzaGVyLmNyZWF0ZSgpO3ZhciBkZXJpdmVkS2V5PVdvcmRBcnJheS5jcmVhdGUoKTt2YXIgZGVyaXZlZEtleVdvcmRzPWRlcml2ZWRLZXkud29yZHM7dmFyIGtleVNpemU9Y2ZnLmtleVNpemU7dmFyIGl0ZXJhdGlvbnM9Y2ZnLml0ZXJhdGlvbnM7d2hpbGUoZGVyaXZlZEtleVdvcmRzLmxlbmd0aDxrZXlTaXplKXtpZihibG9jayl7aGFzaGVyLnVwZGF0ZShibG9jayl9dmFyIGJsb2NrPWhhc2hlci51cGRhdGUocGFzc3dvcmQpLmZpbmFsaXplKHNhbHQpO2hhc2hlci5yZXNldCgpO2Zvcih2YXIgaT0xO2k8aXRlcmF0aW9ucztpKyspe2Jsb2NrPWhhc2hlci5maW5hbGl6ZShibG9jayk7aGFzaGVyLnJlc2V0KCl9ZGVyaXZlZEtleS5jb25jYXQoYmxvY2spfWRlcml2ZWRLZXkuc2lnQnl0ZXM9a2V5U2l6ZSo0O3JldHVybiBkZXJpdmVkS2V5fX0pO0MuRXZwS0RGPWZ1bmN0aW9uKHBhc3N3b3JkLHNhbHQsY2ZnKXtyZXR1cm4gRXZwS0RGLmNyZWF0ZShjZmcpLmNvbXB1dGUocGFzc3dvcmQsc2FsdCl9fSkoKTtyZXR1cm4gQ3J5cHRvSlMuRXZwS0RGfSl9LHtcIi4vY29yZVwiOjIwLFwiLi9obWFjXCI6MjYsXCIuL3NoYTFcIjo0NX1dLDI0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL2NpcGhlci1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vY2lwaGVyLWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbih1bmRlZmluZWQpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgQ2lwaGVyUGFyYW1zPUNfbGliLkNpcGhlclBhcmFtczt2YXIgQ19lbmM9Qy5lbmM7dmFyIEhleD1DX2VuYy5IZXg7dmFyIENfZm9ybWF0PUMuZm9ybWF0O3ZhciBIZXhGb3JtYXR0ZXI9Q19mb3JtYXQuSGV4PXtzdHJpbmdpZnk6ZnVuY3Rpb24oY2lwaGVyUGFyYW1zKXtyZXR1cm4gY2lwaGVyUGFyYW1zLmNpcGhlcnRleHQudG9TdHJpbmcoSGV4KX0scGFyc2U6ZnVuY3Rpb24oaW5wdXQpe3ZhciBjaXBoZXJ0ZXh0PUhleC5wYXJzZShpbnB1dCk7cmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoe2NpcGhlcnRleHQ6Y2lwaGVydGV4dH0pfX19KSgpO3JldHVybiBDcnlwdG9KUy5mb3JtYXQuSGV4fSl9LHtcIi4vY2lwaGVyLWNvcmVcIjoxOSxcIi4vY29yZVwiOjIwfV0sMjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vc2hhMjU2XCIpLF9kZXJlcV8oXCIuL2htYWNcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9zaGEyNTZcIixcIi4vaG1hY1wiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7cmV0dXJuIENyeXB0b0pTLkhtYWNTSEEyNTZ9KX0se1wiLi9jb3JlXCI6MjAsXCIuL2htYWNcIjoyNixcIi4vc2hhMjU2XCI6NDd9XSwyNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSl7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIEJhc2U9Q19saWIuQmFzZTt2YXIgQ19lbmM9Qy5lbmM7dmFyIFV0Zjg9Q19lbmMuVXRmODt2YXIgQ19hbGdvPUMuYWxnbzt2YXIgSE1BQz1DX2FsZ28uSE1BQz1CYXNlLmV4dGVuZCh7aW5pdDpmdW5jdGlvbihoYXNoZXIsa2V5KXtoYXNoZXI9dGhpcy5faGFzaGVyPW5ldyBoYXNoZXIuaW5pdDtpZih0eXBlb2Yga2V5PT1cInN0cmluZ1wiKXtrZXk9VXRmOC5wYXJzZShrZXkpfXZhciBoYXNoZXJCbG9ja1NpemU9aGFzaGVyLmJsb2NrU2l6ZTt2YXIgaGFzaGVyQmxvY2tTaXplQnl0ZXM9aGFzaGVyQmxvY2tTaXplKjQ7aWYoa2V5LnNpZ0J5dGVzPmhhc2hlckJsb2NrU2l6ZUJ5dGVzKXtrZXk9aGFzaGVyLmZpbmFsaXplKGtleSl9a2V5LmNsYW1wKCk7dmFyIG9LZXk9dGhpcy5fb0tleT1rZXkuY2xvbmUoKTt2YXIgaUtleT10aGlzLl9pS2V5PWtleS5jbG9uZSgpO3ZhciBvS2V5V29yZHM9b0tleS53b3Jkczt2YXIgaUtleVdvcmRzPWlLZXkud29yZHM7Zm9yKHZhciBpPTA7aTxoYXNoZXJCbG9ja1NpemU7aSsrKXtvS2V5V29yZHNbaV1ePTE1NDk1NTY4Mjg7aUtleVdvcmRzW2ldXj05MDk1MjI0ODZ9b0tleS5zaWdCeXRlcz1pS2V5LnNpZ0J5dGVzPWhhc2hlckJsb2NrU2l6ZUJ5dGVzO3RoaXMucmVzZXQoKX0scmVzZXQ6ZnVuY3Rpb24oKXt2YXIgaGFzaGVyPXRoaXMuX2hhc2hlcjtoYXNoZXIucmVzZXQoKTtoYXNoZXIudXBkYXRlKHRoaXMuX2lLZXkpfSx1cGRhdGU6ZnVuY3Rpb24obWVzc2FnZVVwZGF0ZSl7dGhpcy5faGFzaGVyLnVwZGF0ZShtZXNzYWdlVXBkYXRlKTtyZXR1cm4gdGhpc30sZmluYWxpemU6ZnVuY3Rpb24obWVzc2FnZVVwZGF0ZSl7dmFyIGhhc2hlcj10aGlzLl9oYXNoZXI7dmFyIGlubmVySGFzaD1oYXNoZXIuZmluYWxpemUobWVzc2FnZVVwZGF0ZSk7aGFzaGVyLnJlc2V0KCk7dmFyIGhtYWM9aGFzaGVyLmZpbmFsaXplKHRoaXMuX29LZXkuY2xvbmUoKS5jb25jYXQoaW5uZXJIYXNoKSk7cmV0dXJuIGhtYWN9fSl9KSgpfSl9LHtcIi4vY29yZVwiOjIwfV0sMjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4veDY0LWNvcmVcIiksX2RlcmVxXyhcIi4vbGliLXR5cGVkYXJyYXlzXCIpLF9kZXJlcV8oXCIuL2VuYy11dGYxNlwiKSxfZGVyZXFfKFwiLi9lbmMtYmFzZTY0XCIpLF9kZXJlcV8oXCIuL21kNVwiKSxfZGVyZXFfKFwiLi9zaGExXCIpLF9kZXJlcV8oXCIuL3NoYTI1NlwiKSxfZGVyZXFfKFwiLi9zaGEyMjRcIiksX2RlcmVxXyhcIi4vc2hhNTEyXCIpLF9kZXJlcV8oXCIuL3NoYTM4NFwiKSxfZGVyZXFfKFwiLi9zaGEzXCIpLF9kZXJlcV8oXCIuL3JpcGVtZDE2MFwiKSxfZGVyZXFfKFwiLi9obWFjXCIpLF9kZXJlcV8oXCIuL3Bia2RmMlwiKSxfZGVyZXFfKFwiLi9ldnBrZGZcIiksX2RlcmVxXyhcIi4vY2lwaGVyLWNvcmVcIiksX2RlcmVxXyhcIi4vbW9kZS1jZmJcIiksX2RlcmVxXyhcIi4vbW9kZS1jdHJcIiksX2RlcmVxXyhcIi4vbW9kZS1jdHItZ2xhZG1hblwiKSxfZGVyZXFfKFwiLi9tb2RlLW9mYlwiKSxfZGVyZXFfKFwiLi9tb2RlLWVjYlwiKSxfZGVyZXFfKFwiLi9wYWQtYW5zaXg5MjNcIiksX2RlcmVxXyhcIi4vcGFkLWlzbzEwMTI2XCIpLF9kZXJlcV8oXCIuL3BhZC1pc285Nzk3MVwiKSxfZGVyZXFfKFwiLi9wYWQtemVyb3BhZGRpbmdcIiksX2RlcmVxXyhcIi4vcGFkLW5vcGFkZGluZ1wiKSxfZGVyZXFfKFwiLi9mb3JtYXQtaGV4XCIpLF9kZXJlcV8oXCIuL2Flc1wiKSxfZGVyZXFfKFwiLi90cmlwbGVkZXNcIiksX2RlcmVxXyhcIi4vcmM0XCIpLF9kZXJlcV8oXCIuL3JhYmJpdFwiKSxfZGVyZXFfKFwiLi9yYWJiaXQtbGVnYWN5XCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4veDY0LWNvcmVcIixcIi4vbGliLXR5cGVkYXJyYXlzXCIsXCIuL2VuYy11dGYxNlwiLFwiLi9lbmMtYmFzZTY0XCIsXCIuL21kNVwiLFwiLi9zaGExXCIsXCIuL3NoYTI1NlwiLFwiLi9zaGEyMjRcIixcIi4vc2hhNTEyXCIsXCIuL3NoYTM4NFwiLFwiLi9zaGEzXCIsXCIuL3JpcGVtZDE2MFwiLFwiLi9obWFjXCIsXCIuL3Bia2RmMlwiLFwiLi9ldnBrZGZcIixcIi4vY2lwaGVyLWNvcmVcIixcIi4vbW9kZS1jZmJcIixcIi4vbW9kZS1jdHJcIixcIi4vbW9kZS1jdHItZ2xhZG1hblwiLFwiLi9tb2RlLW9mYlwiLFwiLi9tb2RlLWVjYlwiLFwiLi9wYWQtYW5zaXg5MjNcIixcIi4vcGFkLWlzbzEwMTI2XCIsXCIuL3BhZC1pc285Nzk3MVwiLFwiLi9wYWQtemVyb3BhZGRpbmdcIixcIi4vcGFkLW5vcGFkZGluZ1wiLFwiLi9mb3JtYXQtaGV4XCIsXCIuL2Flc1wiLFwiLi90cmlwbGVkZXNcIixcIi4vcmM0XCIsXCIuL3JhYmJpdFwiLFwiLi9yYWJiaXQtbGVnYWN5XCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXtyZXR1cm4gQ3J5cHRvSlN9KX0se1wiLi9hZXNcIjoxOCxcIi4vY2lwaGVyLWNvcmVcIjoxOSxcIi4vY29yZVwiOjIwLFwiLi9lbmMtYmFzZTY0XCI6MjEsXCIuL2VuYy11dGYxNlwiOjIyLFwiLi9ldnBrZGZcIjoyMyxcIi4vZm9ybWF0LWhleFwiOjI0LFwiLi9obWFjXCI6MjYsXCIuL2xpYi10eXBlZGFycmF5c1wiOjI4LFwiLi9tZDVcIjoyOSxcIi4vbW9kZS1jZmJcIjozMCxcIi4vbW9kZS1jdHJcIjozMixcIi4vbW9kZS1jdHItZ2xhZG1hblwiOjMxLFwiLi9tb2RlLWVjYlwiOjMzLFwiLi9tb2RlLW9mYlwiOjM0LFwiLi9wYWQtYW5zaXg5MjNcIjozNSxcIi4vcGFkLWlzbzEwMTI2XCI6MzYsXCIuL3BhZC1pc285Nzk3MVwiOjM3LFwiLi9wYWQtbm9wYWRkaW5nXCI6MzgsXCIuL3BhZC16ZXJvcGFkZGluZ1wiOjM5LFwiLi9wYmtkZjJcIjo0MCxcIi4vcmFiYml0XCI6NDIsXCIuL3JhYmJpdC1sZWdhY3lcIjo0MSxcIi4vcmM0XCI6NDMsXCIuL3JpcGVtZDE2MFwiOjQ0LFwiLi9zaGExXCI6NDUsXCIuL3NoYTIyNFwiOjQ2LFwiLi9zaGEyNTZcIjo0NyxcIi4vc2hhM1wiOjQ4LFwiLi9zaGEzODRcIjo0OSxcIi4vc2hhNTEyXCI6NTAsXCIuL3RyaXBsZWRlc1wiOjUxLFwiLi94NjQtY29yZVwiOjUyfV0sMjg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3Rvcnkpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKCl7aWYodHlwZW9mIEFycmF5QnVmZmVyIT1cImZ1bmN0aW9uXCIpe3JldHVybn12YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIFdvcmRBcnJheT1DX2xpYi5Xb3JkQXJyYXk7dmFyIHN1cGVySW5pdD1Xb3JkQXJyYXkuaW5pdDt2YXIgc3ViSW5pdD1Xb3JkQXJyYXkuaW5pdD1mdW5jdGlvbih0eXBlZEFycmF5KXtpZih0eXBlZEFycmF5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe3R5cGVkQXJyYXk9bmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheSl9aWYodHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDhBcnJheXx8dHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5fHx0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50MTZBcnJheXx8dHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5fHx0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50MzJBcnJheXx8dHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5fHx0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHx0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KXt0eXBlZEFycmF5PW5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkuYnVmZmVyLHR5cGVkQXJyYXkuYnl0ZU9mZnNldCx0eXBlZEFycmF5LmJ5dGVMZW5ndGgpfWlmKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KXt2YXIgdHlwZWRBcnJheUJ5dGVMZW5ndGg9dHlwZWRBcnJheS5ieXRlTGVuZ3RoO3ZhciB3b3Jkcz1bXTtmb3IodmFyIGk9MDtpPHR5cGVkQXJyYXlCeXRlTGVuZ3RoO2krKyl7d29yZHNbaT4+PjJdfD10eXBlZEFycmF5W2ldPDwyNC1pJTQqOH1zdXBlckluaXQuY2FsbCh0aGlzLHdvcmRzLHR5cGVkQXJyYXlCeXRlTGVuZ3RoKX1lbHNle3N1cGVySW5pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fTtzdWJJbml0LnByb3RvdHlwZT1Xb3JkQXJyYXl9KSgpO3JldHVybiBDcnlwdG9KUy5saWIuV29yZEFycmF5fSl9LHtcIi4vY29yZVwiOjIwfV0sMjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3Rvcnkpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKE1hdGgpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgV29yZEFycmF5PUNfbGliLldvcmRBcnJheTt2YXIgSGFzaGVyPUNfbGliLkhhc2hlcjt2YXIgQ19hbGdvPUMuYWxnbzt2YXIgVD1bXTsoZnVuY3Rpb24oKXtmb3IodmFyIGk9MDtpPDY0O2krKyl7VFtpXT1NYXRoLmFicyhNYXRoLnNpbihpKzEpKSo0Mjk0OTY3Mjk2fDB9fSkoKTt2YXIgTUQ1PUNfYWxnby5NRDU9SGFzaGVyLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyBXb3JkQXJyYXkuaW5pdChbMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4XSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihNLG9mZnNldCl7Zm9yKHZhciBpPTA7aTwxNjtpKyspe3ZhciBvZmZzZXRfaT1vZmZzZXQraTt2YXIgTV9vZmZzZXRfaT1NW29mZnNldF9pXTtNW29mZnNldF9pXT0oTV9vZmZzZXRfaTw8OHxNX29mZnNldF9pPj4+MjQpJjE2NzExOTM1fChNX29mZnNldF9pPDwyNHxNX29mZnNldF9pPj4+OCkmNDI3ODI1NTM2MH12YXIgSD10aGlzLl9oYXNoLndvcmRzO3ZhciBNX29mZnNldF8wPU1bb2Zmc2V0KzBdO3ZhciBNX29mZnNldF8xPU1bb2Zmc2V0KzFdO3ZhciBNX29mZnNldF8yPU1bb2Zmc2V0KzJdO3ZhciBNX29mZnNldF8zPU1bb2Zmc2V0KzNdO3ZhciBNX29mZnNldF80PU1bb2Zmc2V0KzRdO3ZhciBNX29mZnNldF81PU1bb2Zmc2V0KzVdO3ZhciBNX29mZnNldF82PU1bb2Zmc2V0KzZdO3ZhciBNX29mZnNldF83PU1bb2Zmc2V0KzddO3ZhciBNX29mZnNldF84PU1bb2Zmc2V0KzhdO3ZhciBNX29mZnNldF85PU1bb2Zmc2V0KzldO3ZhciBNX29mZnNldF8xMD1NW29mZnNldCsxMF07dmFyIE1fb2Zmc2V0XzExPU1bb2Zmc2V0KzExXTt2YXIgTV9vZmZzZXRfMTI9TVtvZmZzZXQrMTJdO3ZhciBNX29mZnNldF8xMz1NW29mZnNldCsxM107dmFyIE1fb2Zmc2V0XzE0PU1bb2Zmc2V0KzE0XTt2YXIgTV9vZmZzZXRfMTU9TVtvZmZzZXQrMTVdO3ZhciBhPUhbMF07dmFyIGI9SFsxXTt2YXIgYz1IWzJdO3ZhciBkPUhbM107YT1GRihhLGIsYyxkLE1fb2Zmc2V0XzAsNyxUWzBdKTtkPUZGKGQsYSxiLGMsTV9vZmZzZXRfMSwxMixUWzFdKTtjPUZGKGMsZCxhLGIsTV9vZmZzZXRfMiwxNyxUWzJdKTtiPUZGKGIsYyxkLGEsTV9vZmZzZXRfMywyMixUWzNdKTthPUZGKGEsYixjLGQsTV9vZmZzZXRfNCw3LFRbNF0pO2Q9RkYoZCxhLGIsYyxNX29mZnNldF81LDEyLFRbNV0pO2M9RkYoYyxkLGEsYixNX29mZnNldF82LDE3LFRbNl0pO2I9RkYoYixjLGQsYSxNX29mZnNldF83LDIyLFRbN10pO2E9RkYoYSxiLGMsZCxNX29mZnNldF84LDcsVFs4XSk7ZD1GRihkLGEsYixjLE1fb2Zmc2V0XzksMTIsVFs5XSk7Yz1GRihjLGQsYSxiLE1fb2Zmc2V0XzEwLDE3LFRbMTBdKTtiPUZGKGIsYyxkLGEsTV9vZmZzZXRfMTEsMjIsVFsxMV0pO2E9RkYoYSxiLGMsZCxNX29mZnNldF8xMiw3LFRbMTJdKTtkPUZGKGQsYSxiLGMsTV9vZmZzZXRfMTMsMTIsVFsxM10pO2M9RkYoYyxkLGEsYixNX29mZnNldF8xNCwxNyxUWzE0XSk7Yj1GRihiLGMsZCxhLE1fb2Zmc2V0XzE1LDIyLFRbMTVdKTthPUdHKGEsYixjLGQsTV9vZmZzZXRfMSw1LFRbMTZdKTtkPUdHKGQsYSxiLGMsTV9vZmZzZXRfNiw5LFRbMTddKTtjPUdHKGMsZCxhLGIsTV9vZmZzZXRfMTEsMTQsVFsxOF0pO2I9R0coYixjLGQsYSxNX29mZnNldF8wLDIwLFRbMTldKTthPUdHKGEsYixjLGQsTV9vZmZzZXRfNSw1LFRbMjBdKTtkPUdHKGQsYSxiLGMsTV9vZmZzZXRfMTAsOSxUWzIxXSk7Yz1HRyhjLGQsYSxiLE1fb2Zmc2V0XzE1LDE0LFRbMjJdKTtiPUdHKGIsYyxkLGEsTV9vZmZzZXRfNCwyMCxUWzIzXSk7YT1HRyhhLGIsYyxkLE1fb2Zmc2V0XzksNSxUWzI0XSk7ZD1HRyhkLGEsYixjLE1fb2Zmc2V0XzE0LDksVFsyNV0pO2M9R0coYyxkLGEsYixNX29mZnNldF8zLDE0LFRbMjZdKTtiPUdHKGIsYyxkLGEsTV9vZmZzZXRfOCwyMCxUWzI3XSk7YT1HRyhhLGIsYyxkLE1fb2Zmc2V0XzEzLDUsVFsyOF0pO2Q9R0coZCxhLGIsYyxNX29mZnNldF8yLDksVFsyOV0pO2M9R0coYyxkLGEsYixNX29mZnNldF83LDE0LFRbMzBdKTtiPUdHKGIsYyxkLGEsTV9vZmZzZXRfMTIsMjAsVFszMV0pO2E9SEgoYSxiLGMsZCxNX29mZnNldF81LDQsVFszMl0pO2Q9SEgoZCxhLGIsYyxNX29mZnNldF84LDExLFRbMzNdKTtjPUhIKGMsZCxhLGIsTV9vZmZzZXRfMTEsMTYsVFszNF0pO2I9SEgoYixjLGQsYSxNX29mZnNldF8xNCwyMyxUWzM1XSk7YT1ISChhLGIsYyxkLE1fb2Zmc2V0XzEsNCxUWzM2XSk7ZD1ISChkLGEsYixjLE1fb2Zmc2V0XzQsMTEsVFszN10pO2M9SEgoYyxkLGEsYixNX29mZnNldF83LDE2LFRbMzhdKTtiPUhIKGIsYyxkLGEsTV9vZmZzZXRfMTAsMjMsVFszOV0pO2E9SEgoYSxiLGMsZCxNX29mZnNldF8xMyw0LFRbNDBdKTtkPUhIKGQsYSxiLGMsTV9vZmZzZXRfMCwxMSxUWzQxXSk7Yz1ISChjLGQsYSxiLE1fb2Zmc2V0XzMsMTYsVFs0Ml0pO2I9SEgoYixjLGQsYSxNX29mZnNldF82LDIzLFRbNDNdKTthPUhIKGEsYixjLGQsTV9vZmZzZXRfOSw0LFRbNDRdKTtkPUhIKGQsYSxiLGMsTV9vZmZzZXRfMTIsMTEsVFs0NV0pO2M9SEgoYyxkLGEsYixNX29mZnNldF8xNSwxNixUWzQ2XSk7Yj1ISChiLGMsZCxhLE1fb2Zmc2V0XzIsMjMsVFs0N10pO2E9SUkoYSxiLGMsZCxNX29mZnNldF8wLDYsVFs0OF0pO2Q9SUkoZCxhLGIsYyxNX29mZnNldF83LDEwLFRbNDldKTtjPUlJKGMsZCxhLGIsTV9vZmZzZXRfMTQsMTUsVFs1MF0pO2I9SUkoYixjLGQsYSxNX29mZnNldF81LDIxLFRbNTFdKTthPUlJKGEsYixjLGQsTV9vZmZzZXRfMTIsNixUWzUyXSk7ZD1JSShkLGEsYixjLE1fb2Zmc2V0XzMsMTAsVFs1M10pO2M9SUkoYyxkLGEsYixNX29mZnNldF8xMCwxNSxUWzU0XSk7Yj1JSShiLGMsZCxhLE1fb2Zmc2V0XzEsMjEsVFs1NV0pO2E9SUkoYSxiLGMsZCxNX29mZnNldF84LDYsVFs1Nl0pO2Q9SUkoZCxhLGIsYyxNX29mZnNldF8xNSwxMCxUWzU3XSk7Yz1JSShjLGQsYSxiLE1fb2Zmc2V0XzYsMTUsVFs1OF0pO2I9SUkoYixjLGQsYSxNX29mZnNldF8xMywyMSxUWzU5XSk7YT1JSShhLGIsYyxkLE1fb2Zmc2V0XzQsNixUWzYwXSk7ZD1JSShkLGEsYixjLE1fb2Zmc2V0XzExLDEwLFRbNjFdKTtjPUlJKGMsZCxhLGIsTV9vZmZzZXRfMiwxNSxUWzYyXSk7Yj1JSShiLGMsZCxhLE1fb2Zmc2V0XzksMjEsVFs2M10pO0hbMF09SFswXSthfDA7SFsxXT1IWzFdK2J8MDtIWzJdPUhbMl0rY3wwO0hbM109SFszXStkfDB9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGRhdGE9dGhpcy5fZGF0YTt2YXIgZGF0YVdvcmRzPWRhdGEud29yZHM7dmFyIG5CaXRzVG90YWw9dGhpcy5fbkRhdGFCeXRlcyo4O3ZhciBuQml0c0xlZnQ9ZGF0YS5zaWdCeXRlcyo4O2RhdGFXb3Jkc1tuQml0c0xlZnQ+Pj41XXw9MTI4PDwyNC1uQml0c0xlZnQlMzI7dmFyIG5CaXRzVG90YWxIPU1hdGguZmxvb3IobkJpdHNUb3RhbC80Mjk0OTY3Mjk2KTt2YXIgbkJpdHNUb3RhbEw9bkJpdHNUb3RhbDtkYXRhV29yZHNbKG5CaXRzTGVmdCs2ND4+Pjk8PDQpKzE1XT0obkJpdHNUb3RhbEg8PDh8bkJpdHNUb3RhbEg+Pj4yNCkmMTY3MTE5MzV8KG5CaXRzVG90YWxIPDwyNHxuQml0c1RvdGFsSD4+PjgpJjQyNzgyNTUzNjA7ZGF0YVdvcmRzWyhuQml0c0xlZnQrNjQ+Pj45PDw0KSsxNF09KG5CaXRzVG90YWxMPDw4fG5CaXRzVG90YWxMPj4+MjQpJjE2NzExOTM1fChuQml0c1RvdGFsTDw8MjR8bkJpdHNUb3RhbEw+Pj44KSY0Mjc4MjU1MzYwO2RhdGEuc2lnQnl0ZXM9KGRhdGFXb3Jkcy5sZW5ndGgrMSkqNDt0aGlzLl9wcm9jZXNzKCk7dmFyIGhhc2g9dGhpcy5faGFzaDt2YXIgSD1oYXNoLndvcmRzO2Zvcih2YXIgaT0wO2k8NDtpKyspe3ZhciBIX2k9SFtpXTtIW2ldPShIX2k8PDh8SF9pPj4+MjQpJjE2NzExOTM1fChIX2k8PDI0fEhfaT4+PjgpJjQyNzgyNTUzNjB9cmV0dXJuIGhhc2h9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGNsb25lPUhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO2Nsb25lLl9oYXNoPXRoaXMuX2hhc2guY2xvbmUoKTtyZXR1cm4gY2xvbmV9fSk7ZnVuY3Rpb24gRkYoYSxiLGMsZCx4LHMsdCl7dmFyIG49YSsoYiZjfH5iJmQpK3grdDtyZXR1cm4objw8c3xuPj4+MzItcykrYn1mdW5jdGlvbiBHRyhhLGIsYyxkLHgscyx0KXt2YXIgbj1hKyhiJmR8YyZ+ZCkreCt0O3JldHVybihuPDxzfG4+Pj4zMi1zKStifWZ1bmN0aW9uIEhIKGEsYixjLGQseCxzLHQpe3ZhciBuPWErKGJeY15kKSt4K3Q7cmV0dXJuKG48PHN8bj4+PjMyLXMpK2J9ZnVuY3Rpb24gSUkoYSxiLGMsZCx4LHMsdCl7dmFyIG49YSsoY14oYnx+ZCkpK3grdDtyZXR1cm4objw8c3xuPj4+MzItcykrYn1DLk1ENT1IYXNoZXIuX2NyZWF0ZUhlbHBlcihNRDUpO0MuSG1hY01ENT1IYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoTUQ1KX0pKE1hdGgpO3JldHVybiBDcnlwdG9KUy5NRDV9KX0se1wiLi9jb3JlXCI6MjB9XSwzMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9jaXBoZXItY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL2NpcGhlci1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXtDcnlwdG9KUy5tb2RlLkNGQj1mdW5jdGlvbigpe3ZhciBDRkI9Q3J5cHRvSlMubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtDRkIuRW5jcnlwdG9yPUNGQi5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih3b3JkcyxvZmZzZXQpe3ZhciBjaXBoZXI9dGhpcy5fY2lwaGVyO3ZhciBibG9ja1NpemU9Y2lwaGVyLmJsb2NrU2l6ZTtnZW5lcmF0ZUtleXN0cmVhbUFuZEVuY3J5cHQuY2FsbCh0aGlzLHdvcmRzLG9mZnNldCxibG9ja1NpemUsY2lwaGVyKTt0aGlzLl9wcmV2QmxvY2s9d29yZHMuc2xpY2Uob2Zmc2V0LG9mZnNldCtibG9ja1NpemUpfX0pO0NGQi5EZWNyeXB0b3I9Q0ZCLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHdvcmRzLG9mZnNldCl7dmFyIGNpcGhlcj10aGlzLl9jaXBoZXI7dmFyIGJsb2NrU2l6ZT1jaXBoZXIuYmxvY2tTaXplO3ZhciB0aGlzQmxvY2s9d29yZHMuc2xpY2Uob2Zmc2V0LG9mZnNldCtibG9ja1NpemUpO2dlbmVyYXRlS2V5c3RyZWFtQW5kRW5jcnlwdC5jYWxsKHRoaXMsd29yZHMsb2Zmc2V0LGJsb2NrU2l6ZSxjaXBoZXIpO3RoaXMuX3ByZXZCbG9jaz10aGlzQmxvY2t9fSk7ZnVuY3Rpb24gZ2VuZXJhdGVLZXlzdHJlYW1BbmRFbmNyeXB0KHdvcmRzLG9mZnNldCxibG9ja1NpemUsY2lwaGVyKXt2YXIgaXY9dGhpcy5faXY7aWYoaXYpe3ZhciBrZXlzdHJlYW09aXYuc2xpY2UoMCk7dGhpcy5faXY9dW5kZWZpbmVkfWVsc2V7dmFyIGtleXN0cmVhbT10aGlzLl9wcmV2QmxvY2t9Y2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sMCk7Zm9yKHZhciBpPTA7aTxibG9ja1NpemU7aSsrKXt3b3Jkc1tvZmZzZXQraV1ePWtleXN0cmVhbVtpXX19cmV0dXJuIENGQn0oKTtyZXR1cm4gQ3J5cHRvSlMubW9kZS5DRkJ9KX0se1wiLi9jaXBoZXItY29yZVwiOjE5LFwiLi9jb3JlXCI6MjB9XSwzMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9jaXBoZXItY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL2NpcGhlci1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXtDcnlwdG9KUy5tb2RlLkNUUkdsYWRtYW49ZnVuY3Rpb24oKXt2YXIgQ1RSR2xhZG1hbj1DcnlwdG9KUy5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO2Z1bmN0aW9uIGluY1dvcmQod29yZCl7aWYoKHdvcmQ+PjI0JjI1NSk9PT0yNTUpe3ZhciBiMT13b3JkPj4xNiYyNTU7dmFyIGIyPXdvcmQ+PjgmMjU1O3ZhciBiMz13b3JkJjI1NTtpZihiMT09PTI1NSl7YjE9MDtpZihiMj09PTI1NSl7YjI9MDtpZihiMz09PTI1NSl7YjM9MH1lbHNleysrYjN9fWVsc2V7KytiMn19ZWxzZXsrK2IxfXdvcmQ9MDt3b3JkKz1iMTw8MTY7d29yZCs9YjI8PDg7d29yZCs9YjN9ZWxzZXt3b3JkKz0xPDwyNH1yZXR1cm4gd29yZH1mdW5jdGlvbiBpbmNDb3VudGVyKGNvdW50ZXIpe2lmKChjb3VudGVyWzBdPWluY1dvcmQoY291bnRlclswXSkpPT09MCl7Y291bnRlclsxXT1pbmNXb3JkKGNvdW50ZXJbMV0pfXJldHVybiBjb3VudGVyfXZhciBFbmNyeXB0b3I9Q1RSR2xhZG1hbi5FbmNyeXB0b3I9Q1RSR2xhZG1hbi5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih3b3JkcyxvZmZzZXQpe3ZhciBjaXBoZXI9dGhpcy5fY2lwaGVyO3ZhciBibG9ja1NpemU9Y2lwaGVyLmJsb2NrU2l6ZTt2YXIgaXY9dGhpcy5faXY7dmFyIGNvdW50ZXI9dGhpcy5fY291bnRlcjtpZihpdil7Y291bnRlcj10aGlzLl9jb3VudGVyPWl2LnNsaWNlKDApO3RoaXMuX2l2PXVuZGVmaW5lZH1pbmNDb3VudGVyKGNvdW50ZXIpO3ZhciBrZXlzdHJlYW09Y291bnRlci5zbGljZSgwKTtjaXBoZXIuZW5jcnlwdEJsb2NrKGtleXN0cmVhbSwwKTtmb3IodmFyIGk9MDtpPGJsb2NrU2l6ZTtpKyspe3dvcmRzW29mZnNldCtpXV49a2V5c3RyZWFtW2ldfX19KTtDVFJHbGFkbWFuLkRlY3J5cHRvcj1FbmNyeXB0b3I7cmV0dXJuIENUUkdsYWRtYW59KCk7cmV0dXJuIENyeXB0b0pTLm1vZGUuQ1RSR2xhZG1hbn0pfSx7XCIuL2NpcGhlci1jb3JlXCI6MTksXCIuL2NvcmVcIjoyMH1dLDMyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL2NpcGhlci1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vY2lwaGVyLWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpe0NyeXB0b0pTLm1vZGUuQ1RSPWZ1bmN0aW9uKCl7dmFyIENUUj1DcnlwdG9KUy5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO3ZhciBFbmNyeXB0b3I9Q1RSLkVuY3J5cHRvcj1DVFIuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24od29yZHMsb2Zmc2V0KXt2YXIgY2lwaGVyPXRoaXMuX2NpcGhlcjt2YXIgYmxvY2tTaXplPWNpcGhlci5ibG9ja1NpemU7dmFyIGl2PXRoaXMuX2l2O3ZhciBjb3VudGVyPXRoaXMuX2NvdW50ZXI7aWYoaXYpe2NvdW50ZXI9dGhpcy5fY291bnRlcj1pdi5zbGljZSgwKTt0aGlzLl9pdj11bmRlZmluZWR9dmFyIGtleXN0cmVhbT1jb3VudGVyLnNsaWNlKDApO2NpcGhlci5lbmNyeXB0QmxvY2soa2V5c3RyZWFtLDApO2NvdW50ZXJbYmxvY2tTaXplLTFdPWNvdW50ZXJbYmxvY2tTaXplLTFdKzF8MDtmb3IodmFyIGk9MDtpPGJsb2NrU2l6ZTtpKyspe3dvcmRzW29mZnNldCtpXV49a2V5c3RyZWFtW2ldfX19KTtDVFIuRGVjcnlwdG9yPUVuY3J5cHRvcjtyZXR1cm4gQ1RSfSgpO3JldHVybiBDcnlwdG9KUy5tb2RlLkNUUn0pfSx7XCIuL2NpcGhlci1jb3JlXCI6MTksXCIuL2NvcmVcIjoyMH1dLDMzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL2NpcGhlci1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vY2lwaGVyLWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpe0NyeXB0b0pTLm1vZGUuRUNCPWZ1bmN0aW9uKCl7dmFyIEVDQj1DcnlwdG9KUy5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO0VDQi5FbmNyeXB0b3I9RUNCLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHdvcmRzLG9mZnNldCl7dGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayh3b3JkcyxvZmZzZXQpfX0pO0VDQi5EZWNyeXB0b3I9RUNCLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHdvcmRzLG9mZnNldCl7dGhpcy5fY2lwaGVyLmRlY3J5cHRCbG9jayh3b3JkcyxvZmZzZXQpfX0pO3JldHVybiBFQ0J9KCk7cmV0dXJuIENyeXB0b0pTLm1vZGUuRUNCfSl9LHtcIi4vY2lwaGVyLWNvcmVcIjoxOSxcIi4vY29yZVwiOjIwfV0sMzQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vY2lwaGVyLWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9jaXBoZXItY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7Q3J5cHRvSlMubW9kZS5PRkI9ZnVuY3Rpb24oKXt2YXIgT0ZCPUNyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7dmFyIEVuY3J5cHRvcj1PRkIuRW5jcnlwdG9yPU9GQi5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih3b3JkcyxvZmZzZXQpe3ZhciBjaXBoZXI9dGhpcy5fY2lwaGVyO3ZhciBibG9ja1NpemU9Y2lwaGVyLmJsb2NrU2l6ZTt2YXIgaXY9dGhpcy5faXY7dmFyIGtleXN0cmVhbT10aGlzLl9rZXlzdHJlYW07aWYoaXYpe2tleXN0cmVhbT10aGlzLl9rZXlzdHJlYW09aXYuc2xpY2UoMCk7dGhpcy5faXY9dW5kZWZpbmVkfWNpcGhlci5lbmNyeXB0QmxvY2soa2V5c3RyZWFtLDApO2Zvcih2YXIgaT0wO2k8YmxvY2tTaXplO2krKyl7d29yZHNbb2Zmc2V0K2ldXj1rZXlzdHJlYW1baV19fX0pO09GQi5EZWNyeXB0b3I9RW5jcnlwdG9yO3JldHVybiBPRkJ9KCk7cmV0dXJuIENyeXB0b0pTLm1vZGUuT0ZCfSl9LHtcIi4vY2lwaGVyLWNvcmVcIjoxOSxcIi4vY29yZVwiOjIwfV0sMzU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vY2lwaGVyLWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9jaXBoZXItY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7Q3J5cHRvSlMucGFkLkFuc2lYOTIzPXtwYWQ6ZnVuY3Rpb24oZGF0YSxibG9ja1NpemUpe3ZhciBkYXRhU2lnQnl0ZXM9ZGF0YS5zaWdCeXRlczt2YXIgYmxvY2tTaXplQnl0ZXM9YmxvY2tTaXplKjQ7dmFyIG5QYWRkaW5nQnl0ZXM9YmxvY2tTaXplQnl0ZXMtZGF0YVNpZ0J5dGVzJWJsb2NrU2l6ZUJ5dGVzO3ZhciBsYXN0Qnl0ZVBvcz1kYXRhU2lnQnl0ZXMrblBhZGRpbmdCeXRlcy0xO2RhdGEuY2xhbXAoKTtkYXRhLndvcmRzW2xhc3RCeXRlUG9zPj4+Ml18PW5QYWRkaW5nQnl0ZXM8PDI0LWxhc3RCeXRlUG9zJTQqODtkYXRhLnNpZ0J5dGVzKz1uUGFkZGluZ0J5dGVzfSx1bnBhZDpmdW5jdGlvbihkYXRhKXt2YXIgblBhZGRpbmdCeXRlcz1kYXRhLndvcmRzW2RhdGEuc2lnQnl0ZXMtMT4+PjJdJjI1NTtkYXRhLnNpZ0J5dGVzLT1uUGFkZGluZ0J5dGVzfX07cmV0dXJuIENyeXB0b0pTLnBhZC5BbnNpeDkyM30pfSx7XCIuL2NpcGhlci1jb3JlXCI6MTksXCIuL2NvcmVcIjoyMH1dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL2NpcGhlci1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vY2lwaGVyLWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpe0NyeXB0b0pTLnBhZC5Jc28xMDEyNj17cGFkOmZ1bmN0aW9uKGRhdGEsYmxvY2tTaXplKXt2YXIgYmxvY2tTaXplQnl0ZXM9YmxvY2tTaXplKjQ7dmFyIG5QYWRkaW5nQnl0ZXM9YmxvY2tTaXplQnl0ZXMtZGF0YS5zaWdCeXRlcyVibG9ja1NpemVCeXRlcztkYXRhLmNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbShuUGFkZGluZ0J5dGVzLTEpKS5jb25jYXQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoW25QYWRkaW5nQnl0ZXM8PDI0XSwxKSl9LHVucGFkOmZ1bmN0aW9uKGRhdGEpe3ZhciBuUGFkZGluZ0J5dGVzPWRhdGEud29yZHNbZGF0YS5zaWdCeXRlcy0xPj4+Ml0mMjU1O2RhdGEuc2lnQnl0ZXMtPW5QYWRkaW5nQnl0ZXN9fTtyZXR1cm4gQ3J5cHRvSlMucGFkLklzbzEwMTI2fSl9LHtcIi4vY2lwaGVyLWNvcmVcIjoxOSxcIi4vY29yZVwiOjIwfV0sMzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vY2lwaGVyLWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9jaXBoZXItY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7Q3J5cHRvSlMucGFkLklzbzk3OTcxPXtwYWQ6ZnVuY3Rpb24oZGF0YSxibG9ja1NpemUpe2RhdGEuY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsyMTQ3NDgzNjQ4XSwxKSk7Q3J5cHRvSlMucGFkLlplcm9QYWRkaW5nLnBhZChkYXRhLGJsb2NrU2l6ZSl9LHVucGFkOmZ1bmN0aW9uKGRhdGEpe0NyeXB0b0pTLnBhZC5aZXJvUGFkZGluZy51bnBhZChkYXRhKTtkYXRhLnNpZ0J5dGVzLS19fTtyZXR1cm4gQ3J5cHRvSlMucGFkLklzbzk3OTcxfSl9LHtcIi4vY2lwaGVyLWNvcmVcIjoxOSxcIi4vY29yZVwiOjIwfV0sMzg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vY2lwaGVyLWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9jaXBoZXItY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7Q3J5cHRvSlMucGFkLk5vUGFkZGluZz17cGFkOmZ1bmN0aW9uKCl7fSx1bnBhZDpmdW5jdGlvbigpe319O3JldHVybiBDcnlwdG9KUy5wYWQuTm9QYWRkaW5nfSl9LHtcIi4vY2lwaGVyLWNvcmVcIjoxOSxcIi4vY29yZVwiOjIwfV0sMzk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vY2lwaGVyLWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9jaXBoZXItY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7Q3J5cHRvSlMucGFkLlplcm9QYWRkaW5nPXtwYWQ6ZnVuY3Rpb24oZGF0YSxibG9ja1NpemUpe3ZhciBibG9ja1NpemVCeXRlcz1ibG9ja1NpemUqNDtkYXRhLmNsYW1wKCk7ZGF0YS5zaWdCeXRlcys9YmxvY2tTaXplQnl0ZXMtKGRhdGEuc2lnQnl0ZXMlYmxvY2tTaXplQnl0ZXN8fGJsb2NrU2l6ZUJ5dGVzKX0sdW5wYWQ6ZnVuY3Rpb24oZGF0YSl7dmFyIGRhdGFXb3Jkcz1kYXRhLndvcmRzO3ZhciBpPWRhdGEuc2lnQnl0ZXMtMTt3aGlsZSghKGRhdGFXb3Jkc1tpPj4+Ml0+Pj4yNC1pJTQqOCYyNTUpKXtpLS19ZGF0YS5zaWdCeXRlcz1pKzF9fTtyZXR1cm4gQ3J5cHRvSlMucGFkLlplcm9QYWRkaW5nfSl9LHtcIi4vY2lwaGVyLWNvcmVcIjoxOSxcIi4vY29yZVwiOjIwfV0sNDA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vc2hhMVwiKSxfZGVyZXFfKFwiLi9obWFjXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vc2hhMVwiLFwiLi9obWFjXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIEJhc2U9Q19saWIuQmFzZTt2YXIgV29yZEFycmF5PUNfbGliLldvcmRBcnJheTt2YXIgQ19hbGdvPUMuYWxnbzt2YXIgU0hBMT1DX2FsZ28uU0hBMTt2YXIgSE1BQz1DX2FsZ28uSE1BQzt2YXIgUEJLREYyPUNfYWxnby5QQktERjI9QmFzZS5leHRlbmQoe2NmZzpCYXNlLmV4dGVuZCh7a2V5U2l6ZToxMjgvMzIsaGFzaGVyOlNIQTEsaXRlcmF0aW9uczoxfSksaW5pdDpmdW5jdGlvbihjZmcpe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZChjZmcpfSxjb21wdXRlOmZ1bmN0aW9uKHBhc3N3b3JkLHNhbHQpe3ZhciBjZmc9dGhpcy5jZmc7dmFyIGhtYWM9SE1BQy5jcmVhdGUoY2ZnLmhhc2hlcixwYXNzd29yZCk7dmFyIGRlcml2ZWRLZXk9V29yZEFycmF5LmNyZWF0ZSgpO3ZhciBibG9ja0luZGV4PVdvcmRBcnJheS5jcmVhdGUoWzFdKTt2YXIgZGVyaXZlZEtleVdvcmRzPWRlcml2ZWRLZXkud29yZHM7dmFyIGJsb2NrSW5kZXhXb3Jkcz1ibG9ja0luZGV4LndvcmRzO3ZhciBrZXlTaXplPWNmZy5rZXlTaXplO3ZhciBpdGVyYXRpb25zPWNmZy5pdGVyYXRpb25zO3doaWxlKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGg8a2V5U2l6ZSl7dmFyIGJsb2NrPWhtYWMudXBkYXRlKHNhbHQpLmZpbmFsaXplKGJsb2NrSW5kZXgpO2htYWMucmVzZXQoKTt2YXIgYmxvY2tXb3Jkcz1ibG9jay53b3Jkczt2YXIgYmxvY2tXb3Jkc0xlbmd0aD1ibG9ja1dvcmRzLmxlbmd0aDt2YXIgaW50ZXJtZWRpYXRlPWJsb2NrO2Zvcih2YXIgaT0xO2k8aXRlcmF0aW9ucztpKyspe2ludGVybWVkaWF0ZT1obWFjLmZpbmFsaXplKGludGVybWVkaWF0ZSk7aG1hYy5yZXNldCgpO3ZhciBpbnRlcm1lZGlhdGVXb3Jkcz1pbnRlcm1lZGlhdGUud29yZHM7Zm9yKHZhciBqPTA7ajxibG9ja1dvcmRzTGVuZ3RoO2orKyl7YmxvY2tXb3Jkc1tqXV49aW50ZXJtZWRpYXRlV29yZHNbal19fWRlcml2ZWRLZXkuY29uY2F0KGJsb2NrKTtibG9ja0luZGV4V29yZHNbMF0rK31kZXJpdmVkS2V5LnNpZ0J5dGVzPWtleVNpemUqNDtyZXR1cm4gZGVyaXZlZEtleX19KTtDLlBCS0RGMj1mdW5jdGlvbihwYXNzd29yZCxzYWx0LGNmZyl7cmV0dXJuIFBCS0RGMi5jcmVhdGUoY2ZnKS5jb21wdXRlKHBhc3N3b3JkLHNhbHQpfX0pKCk7cmV0dXJuIENyeXB0b0pTLlBCS0RGMn0pfSx7XCIuL2NvcmVcIjoyMCxcIi4vaG1hY1wiOjI2LFwiLi9zaGExXCI6NDV9XSw0MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi9lbmMtYmFzZTY0XCIpLF9kZXJlcV8oXCIuL21kNVwiKSxfZGVyZXFfKFwiLi9ldnBrZGZcIiksX2RlcmVxXyhcIi4vY2lwaGVyLWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi9lbmMtYmFzZTY0XCIsXCIuL21kNVwiLFwiLi9ldnBrZGZcIixcIi4vY2lwaGVyLWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbigpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgU3RyZWFtQ2lwaGVyPUNfbGliLlN0cmVhbUNpcGhlcjt2YXIgQ19hbGdvPUMuYWxnbzt2YXIgUz1bXTt2YXIgQ189W107dmFyIEc9W107dmFyIFJhYmJpdExlZ2FjeT1DX2FsZ28uUmFiYml0TGVnYWN5PVN0cmVhbUNpcGhlci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dmFyIEs9dGhpcy5fa2V5LndvcmRzO3ZhciBpdj10aGlzLmNmZy5pdjt2YXIgWD10aGlzLl9YPVtLWzBdLEtbM108PDE2fEtbMl0+Pj4xNixLWzFdLEtbMF08PDE2fEtbM10+Pj4xNixLWzJdLEtbMV08PDE2fEtbMF0+Pj4xNixLWzNdLEtbMl08PDE2fEtbMV0+Pj4xNl07dmFyIEM9dGhpcy5fQz1bS1syXTw8MTZ8S1syXT4+PjE2LEtbMF0mNDI5NDkwMTc2MHxLWzFdJjY1NTM1LEtbM108PDE2fEtbM10+Pj4xNixLWzFdJjQyOTQ5MDE3NjB8S1syXSY2NTUzNSxLWzBdPDwxNnxLWzBdPj4+MTYsS1syXSY0Mjk0OTAxNzYwfEtbM10mNjU1MzUsS1sxXTw8MTZ8S1sxXT4+PjE2LEtbM10mNDI5NDkwMTc2MHxLWzBdJjY1NTM1XTt0aGlzLl9iPTA7Zm9yKHZhciBpPTA7aTw0O2krKyl7bmV4dFN0YXRlLmNhbGwodGhpcyl9Zm9yKHZhciBpPTA7aTw4O2krKyl7Q1tpXV49WFtpKzQmN119aWYoaXYpe3ZhciBJVj1pdi53b3Jkczt2YXIgSVZfMD1JVlswXTt2YXIgSVZfMT1JVlsxXTt2YXIgaTA9KElWXzA8PDh8SVZfMD4+PjI0KSYxNjcxMTkzNXwoSVZfMDw8MjR8SVZfMD4+PjgpJjQyNzgyNTUzNjA7dmFyIGkyPShJVl8xPDw4fElWXzE+Pj4yNCkmMTY3MTE5MzV8KElWXzE8PDI0fElWXzE+Pj44KSY0Mjc4MjU1MzYwO3ZhciBpMT1pMD4+PjE2fGkyJjQyOTQ5MDE3NjA7dmFyIGkzPWkyPDwxNnxpMCY2NTUzNTtDWzBdXj1pMDtDWzFdXj1pMTtDWzJdXj1pMjtDWzNdXj1pMztDWzRdXj1pMDtDWzVdXj1pMTtDWzZdXj1pMjtDWzddXj1pMztmb3IodmFyIGk9MDtpPDQ7aSsrKXtuZXh0U3RhdGUuY2FsbCh0aGlzKX19fSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24oTSxvZmZzZXQpe3ZhciBYPXRoaXMuX1g7bmV4dFN0YXRlLmNhbGwodGhpcyk7U1swXT1YWzBdXlhbNV0+Pj4xNl5YWzNdPDwxNjtTWzFdPVhbMl1eWFs3XT4+PjE2XlhbNV08PDE2O1NbMl09WFs0XV5YWzFdPj4+MTZeWFs3XTw8MTY7U1szXT1YWzZdXlhbM10+Pj4xNl5YWzFdPDwxNjtmb3IodmFyIGk9MDtpPDQ7aSsrKXtTW2ldPShTW2ldPDw4fFNbaV0+Pj4yNCkmMTY3MTE5MzV8KFNbaV08PDI0fFNbaV0+Pj44KSY0Mjc4MjU1MzYwO01bb2Zmc2V0K2ldXj1TW2ldfX0sYmxvY2tTaXplOjEyOC8zMixpdlNpemU6NjQvMzJ9KTtcbmZ1bmN0aW9uIG5leHRTdGF0ZSgpe3ZhciBYPXRoaXMuX1g7dmFyIEM9dGhpcy5fQztmb3IodmFyIGk9MDtpPDg7aSsrKXtDX1tpXT1DW2ldfUNbMF09Q1swXSsxMjk1MzA3NTk3K3RoaXMuX2J8MDtDWzFdPUNbMV0rMzU0NTA1MjM3MSsoQ1swXT4+PjA8Q19bMF0+Pj4wPzE6MCl8MDtDWzJdPUNbMl0rODg2MjYzMDkyKyhDWzFdPj4+MDxDX1sxXT4+PjA/MTowKXwwO0NbM109Q1szXSsxMjk1MzA3NTk3KyhDWzJdPj4+MDxDX1syXT4+PjA/MTowKXwwO0NbNF09Q1s0XSszNTQ1MDUyMzcxKyhDWzNdPj4+MDxDX1szXT4+PjA/MTowKXwwO0NbNV09Q1s1XSs4ODYyNjMwOTIrKENbNF0+Pj4wPENfWzRdPj4+MD8xOjApfDA7Q1s2XT1DWzZdKzEyOTUzMDc1OTcrKENbNV0+Pj4wPENfWzVdPj4+MD8xOjApfDA7Q1s3XT1DWzddKzM1NDUwNTIzNzErKENbNl0+Pj4wPENfWzZdPj4+MD8xOjApfDA7dGhpcy5fYj1DWzddPj4+MDxDX1s3XT4+PjA/MTowO2Zvcih2YXIgaT0wO2k8ODtpKyspe3ZhciBneD1YW2ldK0NbaV07dmFyIGdhPWd4JjY1NTM1O3ZhciBnYj1neD4+PjE2O3ZhciBnaD0oKGdhKmdhPj4+MTcpK2dhKmdiPj4+MTUpK2diKmdiO3ZhciBnbD0oKGd4JjQyOTQ5MDE3NjApKmd4fDApKygoZ3gmNjU1MzUpKmd4fDApO0dbaV09Z2heZ2x9WFswXT1HWzBdKyhHWzddPDwxNnxHWzddPj4+MTYpKyhHWzZdPDwxNnxHWzZdPj4+MTYpfDA7WFsxXT1HWzFdKyhHWzBdPDw4fEdbMF0+Pj4yNCkrR1s3XXwwO1hbMl09R1syXSsoR1sxXTw8MTZ8R1sxXT4+PjE2KSsoR1swXTw8MTZ8R1swXT4+PjE2KXwwO1hbM109R1szXSsoR1syXTw8OHxHWzJdPj4+MjQpK0dbMV18MDtYWzRdPUdbNF0rKEdbM108PDE2fEdbM10+Pj4xNikrKEdbMl08PDE2fEdbMl0+Pj4xNil8MDtYWzVdPUdbNV0rKEdbNF08PDh8R1s0XT4+PjI0KStHWzNdfDA7WFs2XT1HWzZdKyhHWzVdPDwxNnxHWzVdPj4+MTYpKyhHWzRdPDwxNnxHWzRdPj4+MTYpfDA7WFs3XT1HWzddKyhHWzZdPDw4fEdbNl0+Pj4yNCkrR1s1XXwwfUMuUmFiYml0TGVnYWN5PVN0cmVhbUNpcGhlci5fY3JlYXRlSGVscGVyKFJhYmJpdExlZ2FjeSl9KSgpO3JldHVybiBDcnlwdG9KUy5SYWJiaXRMZWdhY3l9KX0se1wiLi9jaXBoZXItY29yZVwiOjE5LFwiLi9jb3JlXCI6MjAsXCIuL2VuYy1iYXNlNjRcIjoyMSxcIi4vZXZwa2RmXCI6MjMsXCIuL21kNVwiOjI5fV0sNDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vZW5jLWJhc2U2NFwiKSxfZGVyZXFfKFwiLi9tZDVcIiksX2RlcmVxXyhcIi4vZXZwa2RmXCIpLF9kZXJlcV8oXCIuL2NpcGhlci1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vZW5jLWJhc2U2NFwiLFwiLi9tZDVcIixcIi4vZXZwa2RmXCIsXCIuL2NpcGhlci1jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIFN0cmVhbUNpcGhlcj1DX2xpYi5TdHJlYW1DaXBoZXI7dmFyIENfYWxnbz1DLmFsZ287dmFyIFM9W107dmFyIENfPVtdO3ZhciBHPVtdO3ZhciBSYWJiaXQ9Q19hbGdvLlJhYmJpdD1TdHJlYW1DaXBoZXIuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3ZhciBLPXRoaXMuX2tleS53b3Jkczt2YXIgaXY9dGhpcy5jZmcuaXY7Zm9yKHZhciBpPTA7aTw0O2krKyl7S1tpXT0oS1tpXTw8OHxLW2ldPj4+MjQpJjE2NzExOTM1fChLW2ldPDwyNHxLW2ldPj4+OCkmNDI3ODI1NTM2MH12YXIgWD10aGlzLl9YPVtLWzBdLEtbM108PDE2fEtbMl0+Pj4xNixLWzFdLEtbMF08PDE2fEtbM10+Pj4xNixLWzJdLEtbMV08PDE2fEtbMF0+Pj4xNixLWzNdLEtbMl08PDE2fEtbMV0+Pj4xNl07dmFyIEM9dGhpcy5fQz1bS1syXTw8MTZ8S1syXT4+PjE2LEtbMF0mNDI5NDkwMTc2MHxLWzFdJjY1NTM1LEtbM108PDE2fEtbM10+Pj4xNixLWzFdJjQyOTQ5MDE3NjB8S1syXSY2NTUzNSxLWzBdPDwxNnxLWzBdPj4+MTYsS1syXSY0Mjk0OTAxNzYwfEtbM10mNjU1MzUsS1sxXTw8MTZ8S1sxXT4+PjE2LEtbM10mNDI5NDkwMTc2MHxLWzBdJjY1NTM1XTt0aGlzLl9iPTA7Zm9yKHZhciBpPTA7aTw0O2krKyl7bmV4dFN0YXRlLmNhbGwodGhpcyl9Zm9yKHZhciBpPTA7aTw4O2krKyl7Q1tpXV49WFtpKzQmN119aWYoaXYpe3ZhciBJVj1pdi53b3Jkczt2YXIgSVZfMD1JVlswXTt2YXIgSVZfMT1JVlsxXTt2YXIgaTA9KElWXzA8PDh8SVZfMD4+PjI0KSYxNjcxMTkzNXwoSVZfMDw8MjR8SVZfMD4+PjgpJjQyNzgyNTUzNjA7dmFyIGkyPShJVl8xPDw4fElWXzE+Pj4yNCkmMTY3MTE5MzV8KElWXzE8PDI0fElWXzE+Pj44KSY0Mjc4MjU1MzYwO3ZhciBpMT1pMD4+PjE2fGkyJjQyOTQ5MDE3NjA7dmFyIGkzPWkyPDwxNnxpMCY2NTUzNTtDWzBdXj1pMDtDWzFdXj1pMTtDWzJdXj1pMjtDWzNdXj1pMztDWzRdXj1pMDtDWzVdXj1pMTtDWzZdXj1pMjtDWzddXj1pMztmb3IodmFyIGk9MDtpPDQ7aSsrKXtuZXh0U3RhdGUuY2FsbCh0aGlzKX19fSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24oTSxvZmZzZXQpe3ZhciBYPXRoaXMuX1g7bmV4dFN0YXRlLmNhbGwodGhpcyk7U1swXT1YWzBdXlhbNV0+Pj4xNl5YWzNdPDwxNjtTWzFdPVhbMl1eWFs3XT4+PjE2XlhbNV08PDE2O1NbMl09WFs0XV5YWzFdPj4+MTZeWFs3XTw8MTY7U1szXT1YWzZdXlhbM10+Pj4xNl5YWzFdPDwxNjtmb3IodmFyIGk9MDtpPDQ7aSsrKXtTW2ldPShTW2ldPDw4fFNbaV0+Pj4yNCkmMTY3MTE5MzV8KFNbaV08PDI0fFNbaV0+Pj44KSY0Mjc4MjU1MzYwO01bb2Zmc2V0K2ldXj1TW2ldfX0sYmxvY2tTaXplOjEyOC8zMixpdlNpemU6NjQvMzJ9KTtmdW5jdGlvbiBuZXh0U3RhdGUoKXt2YXIgWD10aGlzLl9YO3ZhciBDPXRoaXMuX0M7Zm9yKHZhciBpPTA7aTw4O2krKyl7Q19baV09Q1tpXX1DWzBdPUNbMF0rMTI5NTMwNzU5Nyt0aGlzLl9ifDA7Q1sxXT1DWzFdKzM1NDUwNTIzNzErKENbMF0+Pj4wPENfWzBdPj4+MD8xOjApfDA7Q1syXT1DWzJdKzg4NjI2MzA5MisoQ1sxXT4+PjA8Q19bMV0+Pj4wPzE6MCl8MDtDWzNdPUNbM10rMTI5NTMwNzU5NysoQ1syXT4+PjA8Q19bMl0+Pj4wPzE6MCl8MDtDWzRdPUNbNF0rMzU0NTA1MjM3MSsoQ1szXT4+PjA8Q19bM10+Pj4wPzE6MCl8MDtDWzVdPUNbNV0rODg2MjYzMDkyKyhDWzRdPj4+MDxDX1s0XT4+PjA/MTowKXwwO0NbNl09Q1s2XSsxMjk1MzA3NTk3KyhDWzVdPj4+MDxDX1s1XT4+PjA/MTowKXwwO0NbN109Q1s3XSszNTQ1MDUyMzcxKyhDWzZdPj4+MDxDX1s2XT4+PjA/MTowKXwwO3RoaXMuX2I9Q1s3XT4+PjA8Q19bN10+Pj4wPzE6MDtmb3IodmFyIGk9MDtpPDg7aSsrKXt2YXIgZ3g9WFtpXStDW2ldO3ZhciBnYT1neCY2NTUzNTt2YXIgZ2I9Z3g+Pj4xNjt2YXIgZ2g9KChnYSpnYT4+PjE3KStnYSpnYj4+PjE1KStnYipnYjt2YXIgZ2w9KChneCY0Mjk0OTAxNzYwKSpneHwwKSsoKGd4JjY1NTM1KSpneHwwKTtHW2ldPWdoXmdsfVhbMF09R1swXSsoR1s3XTw8MTZ8R1s3XT4+PjE2KSsoR1s2XTw8MTZ8R1s2XT4+PjE2KXwwO1hbMV09R1sxXSsoR1swXTw8OHxHWzBdPj4+MjQpK0dbN118MDtYWzJdPUdbMl0rKEdbMV08PDE2fEdbMV0+Pj4xNikrKEdbMF08PDE2fEdbMF0+Pj4xNil8MDtYWzNdPUdbM10rKEdbMl08PDh8R1syXT4+PjI0KStHWzFdfDA7WFs0XT1HWzRdKyhHWzNdPDwxNnxHWzNdPj4+MTYpKyhHWzJdPDwxNnxHWzJdPj4+MTYpfDA7WFs1XT1HWzVdKyhHWzRdPDw4fEdbNF0+Pj4yNCkrR1szXXwwO1hbNl09R1s2XSsoR1s1XTw8MTZ8R1s1XT4+PjE2KSsoR1s0XTw8MTZ8R1s0XT4+PjE2KXwwO1hbN109R1s3XSsoR1s2XTw8OHxHWzZdPj4+MjQpK0dbNV18MH1DLlJhYmJpdD1TdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSYWJiaXQpfSkoKTtyZXR1cm4gQ3J5cHRvSlMuUmFiYml0fSl9LHtcIi4vY2lwaGVyLWNvcmVcIjoxOSxcIi4vY29yZVwiOjIwLFwiLi9lbmMtYmFzZTY0XCI6MjEsXCIuL2V2cGtkZlwiOjIzLFwiLi9tZDVcIjoyOX1dLDQzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL2VuYy1iYXNlNjRcIiksX2RlcmVxXyhcIi4vbWQ1XCIpLF9kZXJlcV8oXCIuL2V2cGtkZlwiKSxfZGVyZXFfKFwiLi9jaXBoZXItY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL2VuYy1iYXNlNjRcIixcIi4vbWQ1XCIsXCIuL2V2cGtkZlwiLFwiLi9jaXBoZXItY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBTdHJlYW1DaXBoZXI9Q19saWIuU3RyZWFtQ2lwaGVyO3ZhciBDX2FsZ289Qy5hbGdvO3ZhciBSQzQ9Q19hbGdvLlJDND1TdHJlYW1DaXBoZXIuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3ZhciBrZXk9dGhpcy5fa2V5O3ZhciBrZXlXb3Jkcz1rZXkud29yZHM7dmFyIGtleVNpZ0J5dGVzPWtleS5zaWdCeXRlczt2YXIgUz10aGlzLl9TPVtdO2Zvcih2YXIgaT0wO2k8MjU2O2krKyl7U1tpXT1pfWZvcih2YXIgaT0wLGo9MDtpPDI1NjtpKyspe3ZhciBrZXlCeXRlSW5kZXg9aSVrZXlTaWdCeXRlczt2YXIga2V5Qnl0ZT1rZXlXb3Jkc1trZXlCeXRlSW5kZXg+Pj4yXT4+PjI0LWtleUJ5dGVJbmRleCU0KjgmMjU1O2o9KGorU1tpXStrZXlCeXRlKSUyNTY7dmFyIHQ9U1tpXTtTW2ldPVNbal07U1tqXT10fXRoaXMuX2k9dGhpcy5faj0wfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24oTSxvZmZzZXQpe01bb2Zmc2V0XV49Z2VuZXJhdGVLZXlzdHJlYW1Xb3JkLmNhbGwodGhpcyl9LGtleVNpemU6MjU2LzMyLGl2U2l6ZTowfSk7ZnVuY3Rpb24gZ2VuZXJhdGVLZXlzdHJlYW1Xb3JkKCl7dmFyIFM9dGhpcy5fUzt2YXIgaT10aGlzLl9pO3ZhciBqPXRoaXMuX2o7dmFyIGtleXN0cmVhbVdvcmQ9MDtmb3IodmFyIG49MDtuPDQ7bisrKXtpPShpKzEpJTI1NjtqPShqK1NbaV0pJTI1Njt2YXIgdD1TW2ldO1NbaV09U1tqXTtTW2pdPXQ7a2V5c3RyZWFtV29yZHw9U1soU1tpXStTW2pdKSUyNTZdPDwyNC1uKjh9dGhpcy5faT1pO3RoaXMuX2o9ajtyZXR1cm4ga2V5c3RyZWFtV29yZH1DLlJDND1TdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSQzQpO3ZhciBSQzREcm9wPUNfYWxnby5SQzREcm9wPVJDNC5leHRlbmQoe2NmZzpSQzQuY2ZnLmV4dGVuZCh7ZHJvcDoxOTJ9KSxfZG9SZXNldDpmdW5jdGlvbigpe1JDNC5fZG9SZXNldC5jYWxsKHRoaXMpO2Zvcih2YXIgaT10aGlzLmNmZy5kcm9wO2k+MDtpLS0pe2dlbmVyYXRlS2V5c3RyZWFtV29yZC5jYWxsKHRoaXMpfX19KTtDLlJDNERyb3A9U3RyZWFtQ2lwaGVyLl9jcmVhdGVIZWxwZXIoUkM0RHJvcCl9KSgpO3JldHVybiBDcnlwdG9KUy5SQzR9KX0se1wiLi9jaXBoZXItY29yZVwiOjE5LFwiLi9jb3JlXCI6MjAsXCIuL2VuYy1iYXNlNjRcIjoyMSxcIi4vZXZwa2RmXCI6MjMsXCIuL21kNVwiOjI5fV0sNDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3Rvcnkpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKE1hdGgpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgV29yZEFycmF5PUNfbGliLldvcmRBcnJheTt2YXIgSGFzaGVyPUNfbGliLkhhc2hlcjt2YXIgQ19hbGdvPUMuYWxnbzt2YXIgX3psPVdvcmRBcnJheS5jcmVhdGUoWzAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsNyw0LDEzLDEsMTAsNiwxNSwzLDEyLDAsOSw1LDIsMTQsMTEsOCwzLDEwLDE0LDQsOSwxNSw4LDEsMiw3LDAsNiwxMywxMSw1LDEyLDEsOSwxMSwxMCwwLDgsMTIsNCwxMywzLDcsMTUsMTQsNSw2LDIsNCwwLDUsOSw3LDEyLDIsMTAsMTQsMSwzLDgsMTEsNiwxNSwxM10pO3ZhciBfenI9V29yZEFycmF5LmNyZWF0ZShbNSwxNCw3LDAsOSwyLDExLDQsMTMsNiwxNSw4LDEsMTAsMywxMiw2LDExLDMsNywwLDEzLDUsMTAsMTQsMTUsOCwxMiw0LDksMSwyLDE1LDUsMSwzLDcsMTQsNiw5LDExLDgsMTIsMiwxMCwwLDQsMTMsOCw2LDQsMSwzLDExLDE1LDAsNSwxMiwyLDEzLDksNywxMCwxNCwxMiwxNSwxMCw0LDEsNSw4LDcsNiwyLDEzLDE0LDAsMyw5LDExXSk7dmFyIF9zbD1Xb3JkQXJyYXkuY3JlYXRlKFsxMSwxNCwxNSwxMiw1LDgsNyw5LDExLDEzLDE0LDE1LDYsNyw5LDgsNyw2LDgsMTMsMTEsOSw3LDE1LDcsMTIsMTUsOSwxMSw3LDEzLDEyLDExLDEzLDYsNywxNCw5LDEzLDE1LDE0LDgsMTMsNiw1LDEyLDcsNSwxMSwxMiwxNCwxNSwxNCwxNSw5LDgsOSwxNCw1LDYsOCw2LDUsMTIsOSwxNSw1LDExLDYsOCwxMywxMiw1LDEyLDEzLDE0LDExLDgsNSw2XSk7dmFyIF9zcj1Xb3JkQXJyYXkuY3JlYXRlKFs4LDksOSwxMSwxMywxNSwxNSw1LDcsNyw4LDExLDE0LDE0LDEyLDYsOSwxMywxNSw3LDEyLDgsOSwxMSw3LDcsMTIsNyw2LDE1LDEzLDExLDksNywxNSwxMSw4LDYsNiwxNCwxMiwxMyw1LDE0LDEzLDEzLDcsNSwxNSw1LDgsMTEsMTQsMTQsNiwxNCw2LDksMTIsOSwxMiw1LDE1LDgsOCw1LDEyLDksMTIsNSwxNCw2LDgsMTMsNiw1LDE1LDEzLDExLDExXSk7dmFyIF9obD1Xb3JkQXJyYXkuY3JlYXRlKFswLDE1MTg1MDAyNDksMTg1OTc3NTM5MywyNDAwOTU5NzA4LDI4NDA4NTM4MzhdKTt2YXIgX2hyPVdvcmRBcnJheS5jcmVhdGUoWzEzNTI4Mjk5MjYsMTU0ODYwMzY4NCwxODM2MDcyNjkxLDIwNTM5OTQyMTcsMF0pO3ZhciBSSVBFTUQxNjA9Q19hbGdvLlJJUEVNRDE2MD1IYXNoZXIuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9V29yZEFycmF5LmNyZWF0ZShbMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4LDMyODUzNzc1MjBdKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKE0sb2Zmc2V0KXtmb3IodmFyIGk9MDtpPDE2O2krKyl7dmFyIG9mZnNldF9pPW9mZnNldCtpO3ZhciBNX29mZnNldF9pPU1bb2Zmc2V0X2ldO01bb2Zmc2V0X2ldPShNX29mZnNldF9pPDw4fE1fb2Zmc2V0X2k+Pj4yNCkmMTY3MTE5MzV8KE1fb2Zmc2V0X2k8PDI0fE1fb2Zmc2V0X2k+Pj44KSY0Mjc4MjU1MzYwfXZhciBIPXRoaXMuX2hhc2gud29yZHM7dmFyIGhsPV9obC53b3Jkczt2YXIgaHI9X2hyLndvcmRzO3ZhciB6bD1femwud29yZHM7dmFyIHpyPV96ci53b3Jkczt2YXIgc2w9X3NsLndvcmRzO3ZhciBzcj1fc3Iud29yZHM7dmFyIGFsLGJsLGNsLGRsLGVsO3ZhciBhcixicixjcixkcixlcjthcj1hbD1IWzBdO2JyPWJsPUhbMV07Y3I9Y2w9SFsyXTtkcj1kbD1IWzNdO2VyPWVsPUhbNF07dmFyIHQ7Zm9yKHZhciBpPTA7aTw4MDtpKz0xKXt0PWFsK01bb2Zmc2V0K3psW2ldXXwwO2lmKGk8MTYpe3QrPWYxKGJsLGNsLGRsKStobFswXX1lbHNlIGlmKGk8MzIpe3QrPWYyKGJsLGNsLGRsKStobFsxXX1lbHNlIGlmKGk8NDgpe3QrPWYzKGJsLGNsLGRsKStobFsyXX1lbHNlIGlmKGk8NjQpe3QrPWY0KGJsLGNsLGRsKStobFszXX1lbHNle3QrPWY1KGJsLGNsLGRsKStobFs0XX10PXR8MDt0PXJvdGwodCxzbFtpXSk7dD10K2VsfDA7YWw9ZWw7ZWw9ZGw7ZGw9cm90bChjbCwxMCk7Y2w9Ymw7Ymw9dDt0PWFyK01bb2Zmc2V0K3pyW2ldXXwwO2lmKGk8MTYpe3QrPWY1KGJyLGNyLGRyKStoclswXX1lbHNlIGlmKGk8MzIpe3QrPWY0KGJyLGNyLGRyKStoclsxXX1lbHNlIGlmKGk8NDgpe3QrPWYzKGJyLGNyLGRyKStoclsyXX1lbHNlIGlmKGk8NjQpe3QrPWYyKGJyLGNyLGRyKStoclszXX1lbHNle3QrPWYxKGJyLGNyLGRyKStocls0XX10PXR8MDt0PXJvdGwodCxzcltpXSk7dD10K2VyfDA7YXI9ZXI7ZXI9ZHI7ZHI9cm90bChjciwxMCk7Y3I9YnI7YnI9dH10PUhbMV0rY2wrZHJ8MDtIWzFdPUhbMl0rZGwrZXJ8MDtIWzJdPUhbM10rZWwrYXJ8MDtIWzNdPUhbNF0rYWwrYnJ8MDtIWzRdPUhbMF0rYmwrY3J8MDtIWzBdPXR9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGRhdGE9dGhpcy5fZGF0YTt2YXIgZGF0YVdvcmRzPWRhdGEud29yZHM7dmFyIG5CaXRzVG90YWw9dGhpcy5fbkRhdGFCeXRlcyo4O3ZhciBuQml0c0xlZnQ9ZGF0YS5zaWdCeXRlcyo4O2RhdGFXb3Jkc1tuQml0c0xlZnQ+Pj41XXw9MTI4PDwyNC1uQml0c0xlZnQlMzI7ZGF0YVdvcmRzWyhuQml0c0xlZnQrNjQ+Pj45PDw0KSsxNF09KG5CaXRzVG90YWw8PDh8bkJpdHNUb3RhbD4+PjI0KSYxNjcxMTkzNXwobkJpdHNUb3RhbDw8MjR8bkJpdHNUb3RhbD4+PjgpJjQyNzgyNTUzNjA7ZGF0YS5zaWdCeXRlcz0oZGF0YVdvcmRzLmxlbmd0aCsxKSo0O3RoaXMuX3Byb2Nlc3MoKTt2YXIgaGFzaD10aGlzLl9oYXNoO3ZhciBIPWhhc2gud29yZHM7Zm9yKHZhciBpPTA7aTw1O2krKyl7dmFyIEhfaT1IW2ldO0hbaV09KEhfaTw8OHxIX2k+Pj4yNCkmMTY3MTE5MzV8KEhfaTw8MjR8SF9pPj4+OCkmNDI3ODI1NTM2MH1yZXR1cm4gaGFzaH0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgY2xvbmU9SGFzaGVyLmNsb25lLmNhbGwodGhpcyk7Y2xvbmUuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpO3JldHVybiBjbG9uZX19KTtmdW5jdGlvbiBmMSh4LHkseil7cmV0dXJuIHheeV56fWZ1bmN0aW9uIGYyKHgseSx6KXtyZXR1cm4geCZ5fH54Jnp9ZnVuY3Rpb24gZjMoeCx5LHope3JldHVybih4fH55KV56fWZ1bmN0aW9uIGY0KHgseSx6KXtyZXR1cm4geCZ6fHkmfnp9ZnVuY3Rpb24gZjUoeCx5LHope3JldHVybiB4Xih5fH56KX1mdW5jdGlvbiByb3RsKHgsbil7cmV0dXJuIHg8PG58eD4+PjMyLW59Qy5SSVBFTUQxNjA9SGFzaGVyLl9jcmVhdGVIZWxwZXIoUklQRU1EMTYwKTtDLkhtYWNSSVBFTUQxNjA9SGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFJJUEVNRDE2MCl9KShNYXRoKTtyZXR1cm4gQ3J5cHRvSlMuUklQRU1EMTYwfSl9LHtcIi4vY29yZVwiOjIwfV0sNDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3Rvcnkpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBXb3JkQXJyYXk9Q19saWIuV29yZEFycmF5O3ZhciBIYXNoZXI9Q19saWIuSGFzaGVyO3ZhciBDX2FsZ289Qy5hbGdvO3ZhciBXPVtdO3ZhciBTSEExPUNfYWxnby5TSEExPUhhc2hlci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgV29yZEFycmF5LmluaXQoWzE3MzI1ODQxOTMsNDAyMzIzMzQxNywyNTYyMzgzMTAyLDI3MTczMzg3OCwzMjg1Mzc3NTIwXSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihNLG9mZnNldCl7dmFyIEg9dGhpcy5faGFzaC53b3Jkczt2YXIgYT1IWzBdO3ZhciBiPUhbMV07dmFyIGM9SFsyXTt2YXIgZD1IWzNdO3ZhciBlPUhbNF07Zm9yKHZhciBpPTA7aTw4MDtpKyspe2lmKGk8MTYpe1dbaV09TVtvZmZzZXQraV18MH1lbHNle3ZhciBuPVdbaS0zXV5XW2ktOF1eV1tpLTE0XV5XW2ktMTZdO1dbaV09bjw8MXxuPj4+MzF9dmFyIHQ9KGE8PDV8YT4+PjI3KStlK1dbaV07aWYoaTwyMCl7dCs9KGImY3x+YiZkKSsxNTE4NTAwMjQ5fWVsc2UgaWYoaTw0MCl7dCs9KGJeY15kKSsxODU5Nzc1MzkzfWVsc2UgaWYoaTw2MCl7dCs9KGImY3xiJmR8YyZkKS0xODk0MDA3NTg4fWVsc2V7dCs9KGJeY15kKS04OTk0OTc1MTR9ZT1kO2Q9YztjPWI8PDMwfGI+Pj4yO2I9YTthPXR9SFswXT1IWzBdK2F8MDtIWzFdPUhbMV0rYnwwO0hbMl09SFsyXStjfDA7SFszXT1IWzNdK2R8MDtIWzRdPUhbNF0rZXwwfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciBkYXRhPXRoaXMuX2RhdGE7dmFyIGRhdGFXb3Jkcz1kYXRhLndvcmRzO3ZhciBuQml0c1RvdGFsPXRoaXMuX25EYXRhQnl0ZXMqODt2YXIgbkJpdHNMZWZ0PWRhdGEuc2lnQnl0ZXMqODtkYXRhV29yZHNbbkJpdHNMZWZ0Pj4+NV18PTEyODw8MjQtbkJpdHNMZWZ0JTMyO2RhdGFXb3Jkc1sobkJpdHNMZWZ0KzY0Pj4+OTw8NCkrMTRdPU1hdGguZmxvb3IobkJpdHNUb3RhbC80Mjk0OTY3Mjk2KTtkYXRhV29yZHNbKG5CaXRzTGVmdCs2ND4+Pjk8PDQpKzE1XT1uQml0c1RvdGFsO2RhdGEuc2lnQnl0ZXM9ZGF0YVdvcmRzLmxlbmd0aCo0O3RoaXMuX3Byb2Nlc3MoKTtyZXR1cm4gdGhpcy5faGFzaH0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgY2xvbmU9SGFzaGVyLmNsb25lLmNhbGwodGhpcyk7Y2xvbmUuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpO3JldHVybiBjbG9uZX19KTtDLlNIQTE9SGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMSk7Qy5IbWFjU0hBMT1IYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMSl9KSgpO3JldHVybiBDcnlwdG9KUy5TSEExfSl9LHtcIi4vY29yZVwiOjIwfV0sNDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4vc2hhMjU2XCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4vc2hhMjU2XCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIFdvcmRBcnJheT1DX2xpYi5Xb3JkQXJyYXk7dmFyIENfYWxnbz1DLmFsZ287dmFyIFNIQTI1Nj1DX2FsZ28uU0hBMjU2O3ZhciBTSEEyMjQ9Q19hbGdvLlNIQTIyND1TSEEyNTYuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IFdvcmRBcnJheS5pbml0KFszMjM4MzcxMDMyLDkxNDE1MDY2Myw4MTI3MDI5OTksNDE0NDkxMjY5Nyw0MjkwNzc1ODU3LDE3NTA2MDMwMjUsMTY5NDA3NjgzOSwzMjA0MDc1NDI4XSl9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIGhhc2g9U0hBMjU2Ll9kb0ZpbmFsaXplLmNhbGwodGhpcyk7aGFzaC5zaWdCeXRlcy09NDtyZXR1cm4gaGFzaH19KTtDLlNIQTIyND1TSEEyNTYuX2NyZWF0ZUhlbHBlcihTSEEyMjQpO0MuSG1hY1NIQTIyND1TSEEyNTYuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMjI0KX0pKCk7cmV0dXJuIENyeXB0b0pTLlNIQTIyNH0pfSx7XCIuL2NvcmVcIjoyMCxcIi4vc2hhMjU2XCI6NDd9XSw0NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSl7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24oTWF0aCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBXb3JkQXJyYXk9Q19saWIuV29yZEFycmF5O3ZhciBIYXNoZXI9Q19saWIuSGFzaGVyO3ZhciBDX2FsZ289Qy5hbGdvO3ZhciBIPVtdO3ZhciBLPVtdOyhmdW5jdGlvbigpe2Z1bmN0aW9uIGlzUHJpbWUobil7dmFyIHNxcnROPU1hdGguc3FydChuKTtmb3IodmFyIGZhY3Rvcj0yO2ZhY3Rvcjw9c3FydE47ZmFjdG9yKyspe2lmKCEobiVmYWN0b3IpKXtyZXR1cm4gZmFsc2V9fXJldHVybiB0cnVlfWZ1bmN0aW9uIGdldEZyYWN0aW9uYWxCaXRzKG4pe3JldHVybihuLShufDApKSo0Mjk0OTY3Mjk2fDB9dmFyIG49Mjt2YXIgblByaW1lPTA7d2hpbGUoblByaW1lPDY0KXtpZihpc1ByaW1lKG4pKXtpZihuUHJpbWU8OCl7SFtuUHJpbWVdPWdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sMS8yKSl9S1tuUHJpbWVdPWdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sMS8zKSk7blByaW1lKyt9bisrfX0pKCk7dmFyIFc9W107dmFyIFNIQTI1Nj1DX2FsZ28uU0hBMjU2PUhhc2hlci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgV29yZEFycmF5LmluaXQoSC5zbGljZSgwKSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbihNLG9mZnNldCl7dmFyIEg9dGhpcy5faGFzaC53b3Jkczt2YXIgYT1IWzBdO3ZhciBiPUhbMV07dmFyIGM9SFsyXTt2YXIgZD1IWzNdO3ZhciBlPUhbNF07dmFyIGY9SFs1XTt2YXIgZz1IWzZdO3ZhciBoPUhbN107Zm9yKHZhciBpPTA7aTw2NDtpKyspe2lmKGk8MTYpe1dbaV09TVtvZmZzZXQraV18MH1lbHNle3ZhciBnYW1tYTB4PVdbaS0xNV07dmFyIGdhbW1hMD0oZ2FtbWEweDw8MjV8Z2FtbWEweD4+PjcpXihnYW1tYTB4PDwxNHxnYW1tYTB4Pj4+MTgpXmdhbW1hMHg+Pj4zO3ZhciBnYW1tYTF4PVdbaS0yXTt2YXIgZ2FtbWExPShnYW1tYTF4PDwxNXxnYW1tYTF4Pj4+MTcpXihnYW1tYTF4PDwxM3xnYW1tYTF4Pj4+MTkpXmdhbW1hMXg+Pj4xMDtXW2ldPWdhbW1hMCtXW2ktN10rZ2FtbWExK1dbaS0xNl19dmFyIGNoPWUmZl5+ZSZnO3ZhciBtYWo9YSZiXmEmY15iJmM7dmFyIHNpZ21hMD0oYTw8MzB8YT4+PjIpXihhPDwxOXxhPj4+MTMpXihhPDwxMHxhPj4+MjIpO3ZhciBzaWdtYTE9KGU8PDI2fGU+Pj42KV4oZTw8MjF8ZT4+PjExKV4oZTw8N3xlPj4+MjUpO3ZhciB0MT1oK3NpZ21hMStjaCtLW2ldK1dbaV07dmFyIHQyPXNpZ21hMCttYWo7aD1nO2c9ZjtmPWU7ZT1kK3QxfDA7ZD1jO2M9YjtiPWE7YT10MSt0MnwwfUhbMF09SFswXSthfDA7SFsxXT1IWzFdK2J8MDtIWzJdPUhbMl0rY3wwO0hbM109SFszXStkfDA7SFs0XT1IWzRdK2V8MDtIWzVdPUhbNV0rZnwwO0hbNl09SFs2XStnfDA7SFs3XT1IWzddK2h8MH0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgZGF0YT10aGlzLl9kYXRhO3ZhciBkYXRhV29yZHM9ZGF0YS53b3Jkczt2YXIgbkJpdHNUb3RhbD10aGlzLl9uRGF0YUJ5dGVzKjg7dmFyIG5CaXRzTGVmdD1kYXRhLnNpZ0J5dGVzKjg7ZGF0YVdvcmRzW25CaXRzTGVmdD4+PjVdfD0xMjg8PDI0LW5CaXRzTGVmdCUzMjtkYXRhV29yZHNbKG5CaXRzTGVmdCs2ND4+Pjk8PDQpKzE0XT1NYXRoLmZsb29yKG5CaXRzVG90YWwvNDI5NDk2NzI5Nik7ZGF0YVdvcmRzWyhuQml0c0xlZnQrNjQ+Pj45PDw0KSsxNV09bkJpdHNUb3RhbDtkYXRhLnNpZ0J5dGVzPWRhdGFXb3Jkcy5sZW5ndGgqNDt0aGlzLl9wcm9jZXNzKCk7cmV0dXJuIHRoaXMuX2hhc2h9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGNsb25lPUhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO2Nsb25lLl9oYXNoPXRoaXMuX2hhc2guY2xvbmUoKTtyZXR1cm4gY2xvbmV9fSk7Qy5TSEEyNTY9SGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMjU2KTtDLkhtYWNTSEEyNTY9SGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTI1Nil9KShNYXRoKTtyZXR1cm4gQ3J5cHRvSlMuU0hBMjU2fSl9LHtcIi4vY29yZVwiOjIwfV0sNDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihyb290LGZhY3RvcnksdW5kZWYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIil7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1mYWN0b3J5KF9kZXJlcV8oXCIuL2NvcmVcIiksX2RlcmVxXyhcIi4veDY0LWNvcmVcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi94NjQtY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKE1hdGgpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgV29yZEFycmF5PUNfbGliLldvcmRBcnJheTt2YXIgSGFzaGVyPUNfbGliLkhhc2hlcjt2YXIgQ194NjQ9Qy54NjQ7dmFyIFg2NFdvcmQ9Q194NjQuV29yZDt2YXIgQ19hbGdvPUMuYWxnbzt2YXIgUkhPX09GRlNFVFM9W107dmFyIFBJX0lOREVYRVM9W107dmFyIFJPVU5EX0NPTlNUQU5UUz1bXTsoZnVuY3Rpb24oKXt2YXIgeD0xLHk9MDtmb3IodmFyIHQ9MDt0PDI0O3QrKyl7UkhPX09GRlNFVFNbeCs1KnldPSh0KzEpKih0KzIpLzIlNjQ7dmFyIG5ld1g9eSU1O3ZhciBuZXdZPSgyKngrMyp5KSU1O3g9bmV3WDt5PW5ld1l9Zm9yKHZhciB4PTA7eDw1O3grKyl7Zm9yKHZhciB5PTA7eTw1O3krKyl7UElfSU5ERVhFU1t4KzUqeV09eSsoMip4KzMqeSklNSo1fX12YXIgTEZTUj0xO2Zvcih2YXIgaT0wO2k8MjQ7aSsrKXt2YXIgcm91bmRDb25zdGFudE1zdz0wO3ZhciByb3VuZENvbnN0YW50THN3PTA7Zm9yKHZhciBqPTA7ajw3O2orKyl7aWYoTEZTUiYxKXt2YXIgYml0UG9zaXRpb249KDE8PGopLTE7aWYoYml0UG9zaXRpb248MzIpe3JvdW5kQ29uc3RhbnRMc3dePTE8PGJpdFBvc2l0aW9ufWVsc2V7cm91bmRDb25zdGFudE1zd149MTw8Yml0UG9zaXRpb24tMzJ9fWlmKExGU1ImMTI4KXtMRlNSPUxGU1I8PDFeMTEzfWVsc2V7TEZTUjw8PTF9fVJPVU5EX0NPTlNUQU5UU1tpXT1YNjRXb3JkLmNyZWF0ZShyb3VuZENvbnN0YW50TXN3LHJvdW5kQ29uc3RhbnRMc3cpfX0pKCk7dmFyIFQ9W107KGZ1bmN0aW9uKCl7Zm9yKHZhciBpPTA7aTwyNTtpKyspe1RbaV09WDY0V29yZC5jcmVhdGUoKX19KSgpO3ZhciBTSEEzPUNfYWxnby5TSEEzPUhhc2hlci5leHRlbmQoe2NmZzpIYXNoZXIuY2ZnLmV4dGVuZCh7b3V0cHV0TGVuZ3RoOjUxMn0pLF9kb1Jlc2V0OmZ1bmN0aW9uKCl7dmFyIHN0YXRlPXRoaXMuX3N0YXRlPVtdO2Zvcih2YXIgaT0wO2k8MjU7aSsrKXtzdGF0ZVtpXT1uZXcgWDY0V29yZC5pbml0fXRoaXMuYmxvY2tTaXplPSgxNjAwLTIqdGhpcy5jZmcub3V0cHV0TGVuZ3RoKS8zMn0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKE0sb2Zmc2V0KXt2YXIgc3RhdGU9dGhpcy5fc3RhdGU7dmFyIG5CbG9ja1NpemVMYW5lcz10aGlzLmJsb2NrU2l6ZS8yO2Zvcih2YXIgaT0wO2k8bkJsb2NrU2l6ZUxhbmVzO2krKyl7dmFyIE0yaT1NW29mZnNldCsyKmldO3ZhciBNMmkxPU1bb2Zmc2V0KzIqaSsxXTtNMmk9KE0yaTw8OHxNMmk+Pj4yNCkmMTY3MTE5MzV8KE0yaTw8MjR8TTJpPj4+OCkmNDI3ODI1NTM2MDtNMmkxPShNMmkxPDw4fE0yaTE+Pj4yNCkmMTY3MTE5MzV8KE0yaTE8PDI0fE0yaTE+Pj44KSY0Mjc4MjU1MzYwO3ZhciBsYW5lPXN0YXRlW2ldO2xhbmUuaGlnaF49TTJpMTtsYW5lLmxvd149TTJpfWZvcih2YXIgcm91bmQ9MDtyb3VuZDwyNDtyb3VuZCsrKXtmb3IodmFyIHg9MDt4PDU7eCsrKXt2YXIgdE1zdz0wLHRMc3c9MDtmb3IodmFyIHk9MDt5PDU7eSsrKXt2YXIgbGFuZT1zdGF0ZVt4KzUqeV07dE1zd149bGFuZS5oaWdoO3RMc3dePWxhbmUubG93fXZhciBUeD1UW3hdO1R4LmhpZ2g9dE1zdztUeC5sb3c9dExzd31mb3IodmFyIHg9MDt4PDU7eCsrKXt2YXIgVHg0PVRbKHgrNCklNV07dmFyIFR4MT1UWyh4KzEpJTVdO3ZhciBUeDFNc3c9VHgxLmhpZ2g7dmFyIFR4MUxzdz1UeDEubG93O3ZhciB0TXN3PVR4NC5oaWdoXihUeDFNc3c8PDF8VHgxTHN3Pj4+MzEpO3ZhciB0THN3PVR4NC5sb3deKFR4MUxzdzw8MXxUeDFNc3c+Pj4zMSk7Zm9yKHZhciB5PTA7eTw1O3krKyl7dmFyIGxhbmU9c3RhdGVbeCs1KnldO2xhbmUuaGlnaF49dE1zdztsYW5lLmxvd149dExzd319Zm9yKHZhciBsYW5lSW5kZXg9MTtsYW5lSW5kZXg8MjU7bGFuZUluZGV4Kyspe3ZhciBsYW5lPXN0YXRlW2xhbmVJbmRleF07dmFyIGxhbmVNc3c9bGFuZS5oaWdoO3ZhciBsYW5lTHN3PWxhbmUubG93O3ZhciByaG9PZmZzZXQ9UkhPX09GRlNFVFNbbGFuZUluZGV4XTtpZihyaG9PZmZzZXQ8MzIpe3ZhciB0TXN3PWxhbmVNc3c8PHJob09mZnNldHxsYW5lTHN3Pj4+MzItcmhvT2Zmc2V0O3ZhciB0THN3PWxhbmVMc3c8PHJob09mZnNldHxsYW5lTXN3Pj4+MzItcmhvT2Zmc2V0fWVsc2V7dmFyIHRNc3c9bGFuZUxzdzw8cmhvT2Zmc2V0LTMyfGxhbmVNc3c+Pj42NC1yaG9PZmZzZXQ7dmFyIHRMc3c9bGFuZU1zdzw8cmhvT2Zmc2V0LTMyfGxhbmVMc3c+Pj42NC1yaG9PZmZzZXR9dmFyIFRQaUxhbmU9VFtQSV9JTkRFWEVTW2xhbmVJbmRleF1dO1RQaUxhbmUuaGlnaD10TXN3O1RQaUxhbmUubG93PXRMc3d9dmFyIFQwPVRbMF07dmFyIHN0YXRlMD1zdGF0ZVswXTtUMC5oaWdoPXN0YXRlMC5oaWdoO1QwLmxvdz1zdGF0ZTAubG93O2Zvcih2YXIgeD0wO3g8NTt4Kyspe2Zvcih2YXIgeT0wO3k8NTt5Kyspe3ZhciBsYW5lSW5kZXg9eCs1Knk7dmFyIGxhbmU9c3RhdGVbbGFuZUluZGV4XTt2YXIgVExhbmU9VFtsYW5lSW5kZXhdO3ZhciBUeDFMYW5lPVRbKHgrMSklNSs1KnldO3ZhciBUeDJMYW5lPVRbKHgrMiklNSs1KnldO2xhbmUuaGlnaD1UTGFuZS5oaWdoXn5UeDFMYW5lLmhpZ2gmVHgyTGFuZS5oaWdoO2xhbmUubG93PVRMYW5lLmxvd15+VHgxTGFuZS5sb3cmVHgyTGFuZS5sb3d9fXZhciBsYW5lPXN0YXRlWzBdO3ZhciByb3VuZENvbnN0YW50PVJPVU5EX0NPTlNUQU5UU1tyb3VuZF07bGFuZS5oaWdoXj1yb3VuZENvbnN0YW50LmhpZ2g7bGFuZS5sb3dePXJvdW5kQ29uc3RhbnQubG93fX0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgZGF0YT10aGlzLl9kYXRhO3ZhciBkYXRhV29yZHM9ZGF0YS53b3Jkczt2YXIgbkJpdHNUb3RhbD10aGlzLl9uRGF0YUJ5dGVzKjg7dmFyIG5CaXRzTGVmdD1kYXRhLnNpZ0J5dGVzKjg7dmFyIGJsb2NrU2l6ZUJpdHM9dGhpcy5ibG9ja1NpemUqMzI7ZGF0YVdvcmRzW25CaXRzTGVmdD4+PjVdfD0xPDwyNC1uQml0c0xlZnQlMzI7ZGF0YVdvcmRzWyhNYXRoLmNlaWwoKG5CaXRzTGVmdCsxKS9ibG9ja1NpemVCaXRzKSpibG9ja1NpemVCaXRzPj4+NSktMV18PTEyODtkYXRhLnNpZ0J5dGVzPWRhdGFXb3Jkcy5sZW5ndGgqNDt0aGlzLl9wcm9jZXNzKCk7dmFyIHN0YXRlPXRoaXMuX3N0YXRlO3ZhciBvdXRwdXRMZW5ndGhCeXRlcz10aGlzLmNmZy5vdXRwdXRMZW5ndGgvODt2YXIgb3V0cHV0TGVuZ3RoTGFuZXM9b3V0cHV0TGVuZ3RoQnl0ZXMvODt2YXIgaGFzaFdvcmRzPVtdO2Zvcih2YXIgaT0wO2k8b3V0cHV0TGVuZ3RoTGFuZXM7aSsrKXt2YXIgbGFuZT1zdGF0ZVtpXTt2YXIgbGFuZU1zdz1sYW5lLmhpZ2g7dmFyIGxhbmVMc3c9bGFuZS5sb3c7bGFuZU1zdz0obGFuZU1zdzw8OHxsYW5lTXN3Pj4+MjQpJjE2NzExOTM1fChsYW5lTXN3PDwyNHxsYW5lTXN3Pj4+OCkmNDI3ODI1NTM2MDtsYW5lTHN3PShsYW5lTHN3PDw4fGxhbmVMc3c+Pj4yNCkmMTY3MTE5MzV8KGxhbmVMc3c8PDI0fGxhbmVMc3c+Pj44KSY0Mjc4MjU1MzYwO2hhc2hXb3Jkcy5wdXNoKGxhbmVMc3cpO2hhc2hXb3Jkcy5wdXNoKGxhbmVNc3cpfXJldHVybiBuZXcgV29yZEFycmF5LmluaXQoaGFzaFdvcmRzLG91dHB1dExlbmd0aEJ5dGVzKX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgY2xvbmU9SGFzaGVyLmNsb25lLmNhbGwodGhpcyk7dmFyIHN0YXRlPWNsb25lLl9zdGF0ZT10aGlzLl9zdGF0ZS5zbGljZSgwKTtmb3IodmFyIGk9MDtpPDI1O2krKyl7c3RhdGVbaV09c3RhdGVbaV0uY2xvbmUoKX1yZXR1cm4gY2xvbmV9fSk7Qy5TSEEzPUhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTMpO0MuSG1hY1NIQTM9SGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTMpfSkoTWF0aCk7cmV0dXJuIENyeXB0b0pTLlNIQTN9KX0se1wiLi9jb3JlXCI6MjAsXCIuL3g2NC1jb3JlXCI6NTJ9XSw0OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSx1bmRlZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSxfZGVyZXFfKFwiLi94NjQtY29yZVwiKSxfZGVyZXFfKFwiLi9zaGE1MTJcIikpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtcIi4vY29yZVwiLFwiLi94NjQtY29yZVwiLFwiLi9zaGE1MTJcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbigpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX3g2ND1DLng2NDt2YXIgWDY0V29yZD1DX3g2NC5Xb3JkO3ZhciBYNjRXb3JkQXJyYXk9Q194NjQuV29yZEFycmF5O3ZhciBDX2FsZ289Qy5hbGdvO3ZhciBTSEE1MTI9Q19hbGdvLlNIQTUxMjt2YXIgU0hBMzg0PUNfYWxnby5TSEEzODQ9U0hBNTEyLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyBYNjRXb3JkQXJyYXkuaW5pdChbbmV3IFg2NFdvcmQuaW5pdCgzNDE4MDcwMzY1LDMyMzgzNzEwMzIpLG5ldyBYNjRXb3JkLmluaXQoMTY1NDI3MDI1MCw5MTQxNTA2NjMpLG5ldyBYNjRXb3JkLmluaXQoMjQzODUyOTM3MCw4MTI3MDI5OTkpLG5ldyBYNjRXb3JkLmluaXQoMzU1NDYyMzYwLDQxNDQ5MTI2OTcpLG5ldyBYNjRXb3JkLmluaXQoMTczMTQwNTQxNSw0MjkwNzc1ODU3KSxuZXcgWDY0V29yZC5pbml0KDIzOTQxODAyMzEsMTc1MDYwMzAyNSksbmV3IFg2NFdvcmQuaW5pdCgzNjc1MDA4NTI1LDE2OTQwNzY4MzkpLG5ldyBYNjRXb3JkLmluaXQoMTIwMzA2MjgxMywzMjA0MDc1NDI4KV0pfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciBoYXNoPVNIQTUxMi5fZG9GaW5hbGl6ZS5jYWxsKHRoaXMpO2hhc2guc2lnQnl0ZXMtPTE2O3JldHVybiBoYXNofX0pO0MuU0hBMzg0PVNIQTUxMi5fY3JlYXRlSGVscGVyKFNIQTM4NCk7Qy5IbWFjU0hBMzg0PVNIQTUxMi5fY3JlYXRlSG1hY0hlbHBlcihTSEEzODQpfSkoKTtyZXR1cm4gQ3J5cHRvSlMuU0hBMzg0fSl9LHtcIi4vY29yZVwiOjIwLFwiLi9zaGE1MTJcIjo1MCxcIi4veDY0LWNvcmVcIjo1Mn1dLDUwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL3g2NC1jb3JlXCIpKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXCIuL2NvcmVcIixcIi4veDY0LWNvcmVcIl0sZmFjdG9yeSl9ZWxzZXtmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpfX0pKHRoaXMsZnVuY3Rpb24oQ3J5cHRvSlMpeyhmdW5jdGlvbigpe3ZhciBDPUNyeXB0b0pTO3ZhciBDX2xpYj1DLmxpYjt2YXIgSGFzaGVyPUNfbGliLkhhc2hlcjt2YXIgQ194NjQ9Qy54NjQ7dmFyIFg2NFdvcmQ9Q194NjQuV29yZDt2YXIgWDY0V29yZEFycmF5PUNfeDY0LldvcmRBcnJheTt2YXIgQ19hbGdvPUMuYWxnbztmdW5jdGlvbiBYNjRXb3JkX2NyZWF0ZSgpe3JldHVybiBYNjRXb3JkLmNyZWF0ZS5hcHBseShYNjRXb3JkLGFyZ3VtZW50cyl9dmFyIEs9W1g2NFdvcmRfY3JlYXRlKDExMTYzNTI0MDgsMzYwOTc2NzQ1OCksWDY0V29yZF9jcmVhdGUoMTg5OTQ0NzQ0MSw2MDI4OTE3MjUpLFg2NFdvcmRfY3JlYXRlKDMwNDkzMjM0NzEsMzk2NDQ4NDM5OSksWDY0V29yZF9jcmVhdGUoMzkyMTAwOTU3MywyMTczMjk1NTQ4KSxYNjRXb3JkX2NyZWF0ZSg5NjE5ODcxNjMsNDA4MTYyODQ3MiksWDY0V29yZF9jcmVhdGUoMTUwODk3MDk5MywzMDUzODM0MjY1KSxYNjRXb3JkX2NyZWF0ZSgyNDUzNjM1NzQ4LDI5Mzc2NzE1NzkpLFg2NFdvcmRfY3JlYXRlKDI4NzA3NjMyMjEsMzY2NDYwOTU2MCksWDY0V29yZF9jcmVhdGUoMzYyNDM4MTA4MCwyNzM0ODgzMzk0KSxYNjRXb3JkX2NyZWF0ZSgzMTA1OTg0MDEsMTE2NDk5NjU0MiksWDY0V29yZF9jcmVhdGUoNjA3MjI1Mjc4LDEzMjM2MTA3NjQpLFg2NFdvcmRfY3JlYXRlKDE0MjY4ODE5ODcsMzU5MDMwNDk5NCksWDY0V29yZF9jcmVhdGUoMTkyNTA3ODM4OCw0MDY4MTgyMzgzKSxYNjRXb3JkX2NyZWF0ZSgyMTYyMDc4MjA2LDk5MTMzNjExMyksWDY0V29yZF9jcmVhdGUoMjYxNDg4ODEwMyw2MzM4MDMzMTcpLFg2NFdvcmRfY3JlYXRlKDMyNDgyMjI1ODAsMzQ3OTc3NDg2OCksWDY0V29yZF9jcmVhdGUoMzgzNTM5MDQwMSwyNjY2NjEzNDU4KSxYNjRXb3JkX2NyZWF0ZSg0MDIyMjI0Nzc0LDk0NDcxMTEzOSksWDY0V29yZF9jcmVhdGUoMjY0MzQ3MDc4LDIzNDEyNjI3NzMpLFg2NFdvcmRfY3JlYXRlKDYwNDgwNzYyOCwyMDA3ODAwOTMzKSxYNjRXb3JkX2NyZWF0ZSg3NzAyNTU5ODMsMTQ5NTk5MDkwMSksWDY0V29yZF9jcmVhdGUoMTI0OTE1MDEyMiwxODU2NDMxMjM1KSxYNjRXb3JkX2NyZWF0ZSgxNTU1MDgxNjkyLDMxNzUyMTgxMzIpLFg2NFdvcmRfY3JlYXRlKDE5OTYwNjQ5ODYsMjE5ODk1MDgzNyksWDY0V29yZF9jcmVhdGUoMjU1NDIyMDg4MiwzOTk5NzE5MzM5KSxYNjRXb3JkX2NyZWF0ZSgyODIxODM0MzQ5LDc2Njc4NDAxNiksWDY0V29yZF9jcmVhdGUoMjk1Mjk5NjgwOCwyNTY2NTk0ODc5KSxYNjRXb3JkX2NyZWF0ZSgzMjEwMzEzNjcxLDMyMDMzMzc5NTYpLFg2NFdvcmRfY3JlYXRlKDMzMzY1NzE4OTEsMTAzNDQ1NzAyNiksWDY0V29yZF9jcmVhdGUoMzU4NDUyODcxMSwyNDY2OTQ4OTAxKSxYNjRXb3JkX2NyZWF0ZSgxMTM5MjY5OTMsMzc1ODMyNjM4MyksWDY0V29yZF9jcmVhdGUoMzM4MjQxODk1LDE2ODcxNzkzNiksWDY0V29yZF9jcmVhdGUoNjY2MzA3MjA1LDExODgxNzk5NjQpLFg2NFdvcmRfY3JlYXRlKDc3MzUyOTkxMiwxNTQ2MDQ1NzM0KSxYNjRXb3JkX2NyZWF0ZSgxMjk0NzU3MzcyLDE1MjI4MDU0ODUpLFg2NFdvcmRfY3JlYXRlKDEzOTYxODIyOTEsMjY0MzgzMzgyMyksWDY0V29yZF9jcmVhdGUoMTY5NTE4MzcwMCwyMzQzNTI3MzkwKSxYNjRXb3JkX2NyZWF0ZSgxOTg2NjYxMDUxLDEwMTQ0Nzc0ODApLFg2NFdvcmRfY3JlYXRlKDIxNzcwMjYzNTAsMTIwNjc1OTE0MiksWDY0V29yZF9jcmVhdGUoMjQ1Njk1NjAzNywzNDQwNzc2MjcpLFg2NFdvcmRfY3JlYXRlKDI3MzA0ODU5MjEsMTI5MDg2MzQ2MCksWDY0V29yZF9jcmVhdGUoMjgyMDMwMjQxMSwzMTU4NDU0MjczKSxYNjRXb3JkX2NyZWF0ZSgzMjU5NzMwODAwLDM1MDU5NTI2NTcpLFg2NFdvcmRfY3JlYXRlKDMzNDU3NjQ3NzEsMTA2MjE3MDA4KSxYNjRXb3JkX2NyZWF0ZSgzNTE2MDY1ODE3LDM2MDYwMDgzNDQpLFg2NFdvcmRfY3JlYXRlKDM2MDAzNTI4MDQsMTQzMjcyNTc3NiksWDY0V29yZF9jcmVhdGUoNDA5NDU3MTkwOSwxNDY3MDMxNTk0KSxYNjRXb3JkX2NyZWF0ZSgyNzU0MjMzNDQsODUxMTY5NzIwKSxYNjRXb3JkX2NyZWF0ZSg0MzAyMjc3MzQsMzEwMDgyMzc1MiksWDY0V29yZF9jcmVhdGUoNTA2OTQ4NjE2LDEzNjMyNTgxOTUpLFg2NFdvcmRfY3JlYXRlKDY1OTA2MDU1NiwzNzUwNjg1NTkzKSxYNjRXb3JkX2NyZWF0ZSg4ODM5OTc4NzcsMzc4NTA1MDI4MCksWDY0V29yZF9jcmVhdGUoOTU4MTM5NTcxLDMzMTgzMDc0MjcpLFg2NFdvcmRfY3JlYXRlKDEzMjI4MjIyMTgsMzgxMjcyMzQwMyksWDY0V29yZF9jcmVhdGUoMTUzNzAwMjA2MywyMDAzMDM0OTk1KSxYNjRXb3JkX2NyZWF0ZSgxNzQ3ODczNzc5LDM2MDIwMzY4OTkpLFg2NFdvcmRfY3JlYXRlKDE5NTU1NjIyMjIsMTU3NTk5MDAxMiksWDY0V29yZF9jcmVhdGUoMjAyNDEwNDgxNSwxMTI1NTkyOTI4KSxYNjRXb3JkX2NyZWF0ZSgyMjI3NzMwNDUyLDI3MTY5MDQzMDYpLFg2NFdvcmRfY3JlYXRlKDIzNjE4NTI0MjQsNDQyNzc2MDQ0KSxYNjRXb3JkX2NyZWF0ZSgyNDI4NDM2NDc0LDU5MzY5ODM0NCksWDY0V29yZF9jcmVhdGUoMjc1NjczNDE4NywzNzMzMTEwMjQ5KSxYNjRXb3JkX2NyZWF0ZSgzMjA0MDMxNDc5LDI5OTkzNTE1NzMpLFg2NFdvcmRfY3JlYXRlKDMzMjkzMjUyOTgsMzgxNTkyMDQyNyksWDY0V29yZF9jcmVhdGUoMzM5MTU2OTYxNCwzOTI4MzgzOTAwKSxYNjRXb3JkX2NyZWF0ZSgzNTE1MjY3MjcxLDU2NjI4MDcxMSksWDY0V29yZF9jcmVhdGUoMzk0MDE4NzYwNiwzNDU0MDY5NTM0KSxYNjRXb3JkX2NyZWF0ZSg0MTE4NjMwMjcxLDQwMDAyMzk5OTIpLFg2NFdvcmRfY3JlYXRlKDExNjQxODQ3NCwxOTE0MTM4NTU0KSxYNjRXb3JkX2NyZWF0ZSgxNzQyOTI0MjEsMjczMTA1NTI3MCksWDY0V29yZF9jcmVhdGUoMjg5MzgwMzU2LDMyMDM5OTMwMDYpLFg2NFdvcmRfY3JlYXRlKDQ2MDM5MzI2OSwzMjA2MjAzMTUpLFg2NFdvcmRfY3JlYXRlKDY4NTQ3MTczMyw1ODc0OTY4MzYpLFg2NFdvcmRfY3JlYXRlKDg1MjE0Mjk3MSwxMDg2NzkyODUxKSxYNjRXb3JkX2NyZWF0ZSgxMDE3MDM2Mjk4LDM2NTU0MzEwMCksWDY0V29yZF9jcmVhdGUoMTEyNjAwMDU4MCwyNjE4Mjk3Njc2KSxYNjRXb3JkX2NyZWF0ZSgxMjg4MDMzNDcwLDM0MDk4NTUxNTgpLFg2NFdvcmRfY3JlYXRlKDE1MDE1MDU5NDgsNDIzNDUwOTg2NiksWDY0V29yZF9jcmVhdGUoMTYwNzE2NzkxNSw5ODcxNjc0NjgpLFg2NFdvcmRfY3JlYXRlKDE4MTY0MDIzMTYsMTI0NjE4OTU5MSldO3ZhciBXPVtdOyhmdW5jdGlvbigpe2Zvcih2YXIgaT0wO2k8ODA7aSsrKXtXW2ldPVg2NFdvcmRfY3JlYXRlKCl9fSkoKTt2YXIgU0hBNTEyPUNfYWxnby5TSEE1MTI9SGFzaGVyLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyBYNjRXb3JkQXJyYXkuaW5pdChbbmV3IFg2NFdvcmQuaW5pdCgxNzc5MDMzNzAzLDQwODkyMzU3MjApLG5ldyBYNjRXb3JkLmluaXQoMzE0NDEzNDI3NywyMjI3ODczNTk1KSxuZXcgWDY0V29yZC5pbml0KDEwMTM5MDQyNDIsNDI3MTE3NTcyMyksbmV3IFg2NFdvcmQuaW5pdCgyNzczNDgwNzYyLDE1OTU3NTAxMjkpLG5ldyBYNjRXb3JkLmluaXQoMTM1OTg5MzExOSwyOTE3NTY1MTM3KSxuZXcgWDY0V29yZC5pbml0KDI2MDA4MjI5MjQsNzI1NTExMTk5KSxuZXcgWDY0V29yZC5pbml0KDUyODczNDYzNSw0MjE1Mzg5NTQ3KSxuZXcgWDY0V29yZC5pbml0KDE1NDE0NTkyMjUsMzI3MDMzMjA5KV0pfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24oTSxvZmZzZXQpe3ZhciBIPXRoaXMuX2hhc2gud29yZHM7dmFyIEgwPUhbMF07dmFyIEgxPUhbMV07dmFyIEgyPUhbMl07dmFyIEgzPUhbM107dmFyIEg0PUhbNF07dmFyIEg1PUhbNV07dmFyIEg2PUhbNl07dmFyIEg3PUhbN107dmFyIEgwaD1IMC5oaWdoO3ZhciBIMGw9SDAubG93O3ZhciBIMWg9SDEuaGlnaDt2YXIgSDFsPUgxLmxvdzt2YXIgSDJoPUgyLmhpZ2g7dmFyIEgybD1IMi5sb3c7dmFyIEgzaD1IMy5oaWdoO3ZhciBIM2w9SDMubG93O3ZhciBINGg9SDQuaGlnaDt2YXIgSDRsPUg0Lmxvdzt2YXIgSDVoPUg1LmhpZ2g7dmFyIEg1bD1INS5sb3c7dmFyIEg2aD1INi5oaWdoO3ZhciBINmw9SDYubG93O3ZhciBIN2g9SDcuaGlnaDt2YXIgSDdsPUg3Lmxvdzt2YXIgYWg9SDBoO3ZhciBhbD1IMGw7dmFyIGJoPUgxaDt2YXIgYmw9SDFsO3ZhciBjaD1IMmg7dmFyIGNsPUgybDt2YXIgZGg9SDNoO3ZhciBkbD1IM2w7dmFyIGVoPUg0aDt2YXIgZWw9SDRsO3ZhciBmaD1INWg7dmFyIGZsPUg1bDt2YXIgZ2g9SDZoO3ZhciBnbD1INmw7dmFyIGhoPUg3aDt2YXIgaGw9SDdsO2Zvcih2YXIgaT0wO2k8ODA7aSsrKXt2YXIgV2k9V1tpXTtpZihpPDE2KXt2YXIgV2loPVdpLmhpZ2g9TVtvZmZzZXQraSoyXXwwO3ZhciBXaWw9V2kubG93PU1bb2Zmc2V0K2kqMisxXXwwfWVsc2V7dmFyIGdhbW1hMHg9V1tpLTE1XTt2YXIgZ2FtbWEweGg9Z2FtbWEweC5oaWdoO3ZhciBnYW1tYTB4bD1nYW1tYTB4Lmxvdzt2YXIgZ2FtbWEwaD0oZ2FtbWEweGg+Pj4xfGdhbW1hMHhsPDwzMSleKGdhbW1hMHhoPj4+OHxnYW1tYTB4bDw8MjQpXmdhbW1hMHhoPj4+Nzt2YXIgZ2FtbWEwbD0oZ2FtbWEweGw+Pj4xfGdhbW1hMHhoPDwzMSleKGdhbW1hMHhsPj4+OHxnYW1tYTB4aDw8MjQpXihnYW1tYTB4bD4+Pjd8Z2FtbWEweGg8PDI1KTt2YXIgZ2FtbWExeD1XW2ktMl07dmFyIGdhbW1hMXhoPWdhbW1hMXguaGlnaDt2YXIgZ2FtbWExeGw9Z2FtbWExeC5sb3c7dmFyIGdhbW1hMWg9KGdhbW1hMXhoPj4+MTl8Z2FtbWExeGw8PDEzKV4oZ2FtbWExeGg8PDN8Z2FtbWExeGw+Pj4yOSleZ2FtbWExeGg+Pj42O3ZhciBnYW1tYTFsPShnYW1tYTF4bD4+PjE5fGdhbW1hMXhoPDwxMyleKGdhbW1hMXhsPDwzfGdhbW1hMXhoPj4+MjkpXihnYW1tYTF4bD4+PjZ8Z2FtbWExeGg8PDI2KTt2YXIgV2k3PVdbaS03XTt2YXIgV2k3aD1XaTcuaGlnaDt2YXIgV2k3bD1XaTcubG93O3ZhciBXaTE2PVdbaS0xNl07dmFyIFdpMTZoPVdpMTYuaGlnaDt2YXIgV2kxNmw9V2kxNi5sb3c7dmFyIFdpbD1nYW1tYTBsK1dpN2w7dmFyIFdpaD1nYW1tYTBoK1dpN2grKFdpbD4+PjA8Z2FtbWEwbD4+PjA/MTowKTt2YXIgV2lsPVdpbCtnYW1tYTFsO3ZhciBXaWg9V2loK2dhbW1hMWgrKFdpbD4+PjA8Z2FtbWExbD4+PjA/MTowKTt2YXIgV2lsPVdpbCtXaTE2bDt2YXIgV2loPVdpaCtXaTE2aCsoV2lsPj4+MDxXaTE2bD4+PjA/MTowKTtXaS5oaWdoPVdpaDtXaS5sb3c9V2lsfXZhciBjaGg9ZWgmZmhefmVoJmdoO3ZhciBjaGw9ZWwmZmxefmVsJmdsO3ZhciBtYWpoPWFoJmJoXmFoJmNoXmJoJmNoO3ZhciBtYWpsPWFsJmJsXmFsJmNsXmJsJmNsO3ZhciBzaWdtYTBoPShhaD4+PjI4fGFsPDw0KV4oYWg8PDMwfGFsPj4+MileKGFoPDwyNXxhbD4+PjcpO3ZhciBzaWdtYTBsPShhbD4+PjI4fGFoPDw0KV4oYWw8PDMwfGFoPj4+MileKGFsPDwyNXxhaD4+PjcpO3ZhciBzaWdtYTFoPShlaD4+PjE0fGVsPDwxOCleKGVoPj4+MTh8ZWw8PDE0KV4oZWg8PDIzfGVsPj4+OSk7dmFyIHNpZ21hMWw9KGVsPj4+MTR8ZWg8PDE4KV4oZWw+Pj4xOHxlaDw8MTQpXihlbDw8MjN8ZWg+Pj45KTt2YXIgS2k9S1tpXTt2YXIgS2loPUtpLmhpZ2g7dmFyIEtpbD1LaS5sb3c7dmFyIHQxbD1obCtzaWdtYTFsO3ZhciB0MWg9aGgrc2lnbWExaCsodDFsPj4+MDxobD4+PjA/MTowKTt2YXIgdDFsPXQxbCtjaGw7dmFyIHQxaD10MWgrY2hoKyh0MWw+Pj4wPGNobD4+PjA/MTowKTt2YXIgdDFsPXQxbCtLaWw7dmFyIHQxaD10MWgrS2loKyh0MWw+Pj4wPEtpbD4+PjA/MTowKTt2YXIgdDFsPXQxbCtXaWw7dmFyIHQxaD10MWgrV2loKyh0MWw+Pj4wPFdpbD4+PjA/MTowKTt2YXIgdDJsPXNpZ21hMGwrbWFqbDt2YXIgdDJoPXNpZ21hMGgrbWFqaCsodDJsPj4+MDxzaWdtYTBsPj4+MD8xOjApO2hoPWdoO2hsPWdsO2doPWZoO2dsPWZsO2ZoPWVoO2ZsPWVsO2VsPWRsK3QxbHwwO2VoPWRoK3QxaCsoZWw+Pj4wPGRsPj4+MD8xOjApfDA7ZGg9Y2g7ZGw9Y2w7Y2g9Ymg7Y2w9Ymw7Ymg9YWg7Ymw9YWw7YWw9dDFsK3QybHwwO2FoPXQxaCt0MmgrKGFsPj4+MDx0MWw+Pj4wPzE6MCl8MH1IMGw9SDAubG93PUgwbCthbDtIMC5oaWdoPUgwaCthaCsoSDBsPj4+MDxhbD4+PjA/MTowKTtIMWw9SDEubG93PUgxbCtibDtIMS5oaWdoPUgxaCtiaCsoSDFsPj4+MDxibD4+PjA/MTowKTtIMmw9SDIubG93PUgybCtjbDtIMi5oaWdoPUgyaCtjaCsoSDJsPj4+MDxjbD4+PjA/MTowKTtIM2w9SDMubG93PUgzbCtkbDtIMy5oaWdoPUgzaCtkaCsoSDNsPj4+MDxkbD4+PjA/MTowKTtINGw9SDQubG93PUg0bCtlbDtINC5oaWdoPUg0aCtlaCsoSDRsPj4+MDxlbD4+PjA/MTowKTtINWw9SDUubG93PUg1bCtmbDtINS5oaWdoPUg1aCtmaCsoSDVsPj4+MDxmbD4+PjA/MTowKTtINmw9SDYubG93PUg2bCtnbDtINi5oaWdoPUg2aCtnaCsoSDZsPj4+MDxnbD4+PjA/MTowKTtIN2w9SDcubG93PUg3bCtobDtINy5oaWdoPUg3aCtoaCsoSDdsPj4+MDxobD4+PjA/MTowKX0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgZGF0YT10aGlzLl9kYXRhO3ZhciBkYXRhV29yZHM9ZGF0YS53b3Jkczt2YXIgbkJpdHNUb3RhbD10aGlzLl9uRGF0YUJ5dGVzKjg7dmFyIG5CaXRzTGVmdD1kYXRhLnNpZ0J5dGVzKjg7ZGF0YVdvcmRzW25CaXRzTGVmdD4+PjVdfD0xMjg8PDI0LW5CaXRzTGVmdCUzMjtkYXRhV29yZHNbKG5CaXRzTGVmdCsxMjg+Pj4xMDw8NSkrMzBdPU1hdGguZmxvb3IobkJpdHNUb3RhbC80Mjk0OTY3Mjk2KTtkYXRhV29yZHNbKG5CaXRzTGVmdCsxMjg+Pj4xMDw8NSkrMzFdPW5CaXRzVG90YWw7ZGF0YS5zaWdCeXRlcz1kYXRhV29yZHMubGVuZ3RoKjQ7dGhpcy5fcHJvY2VzcygpO3ZhciBoYXNoPXRoaXMuX2hhc2gudG9YMzIoKTtyZXR1cm4gaGFzaH0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgY2xvbmU9SGFzaGVyLmNsb25lLmNhbGwodGhpcyk7Y2xvbmUuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpO3JldHVybiBjbG9uZX0sYmxvY2tTaXplOjEwMjQvMzJ9KTtDLlNIQTUxMj1IYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEE1MTIpO0MuSG1hY1NIQTUxMj1IYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBNTEyKX0pKCk7cmV0dXJuIENyeXB0b0pTLlNIQTUxMn0pfSx7XCIuL2NvcmVcIjoyMCxcIi4veDY0LWNvcmVcIjo1Mn1dLDUxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24ocm9vdCxmYWN0b3J5LHVuZGVmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWV4cG9ydHM9ZmFjdG9yeShfZGVyZXFfKFwiLi9jb3JlXCIpLF9kZXJlcV8oXCIuL2VuYy1iYXNlNjRcIiksX2RlcmVxXyhcIi4vbWQ1XCIpLF9kZXJlcV8oXCIuL2V2cGtkZlwiKSxfZGVyZXFfKFwiLi9jaXBoZXItY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCIsXCIuL2VuYy1iYXNlNjRcIixcIi4vbWQ1XCIsXCIuL2V2cGtkZlwiLFwiLi9jaXBoZXItY29yZVwiXSxmYWN0b3J5KX1lbHNle2ZhY3Rvcnkocm9vdC5DcnlwdG9KUyl9fSkodGhpcyxmdW5jdGlvbihDcnlwdG9KUyl7KGZ1bmN0aW9uKCl7dmFyIEM9Q3J5cHRvSlM7dmFyIENfbGliPUMubGliO3ZhciBXb3JkQXJyYXk9Q19saWIuV29yZEFycmF5O3ZhciBCbG9ja0NpcGhlcj1DX2xpYi5CbG9ja0NpcGhlcjt2YXIgQ19hbGdvPUMuYWxnbzt2YXIgUEMxPVs1Nyw0OSw0MSwzMywyNSwxNyw5LDEsNTgsNTAsNDIsMzQsMjYsMTgsMTAsMiw1OSw1MSw0MywzNSwyNywxOSwxMSwzLDYwLDUyLDQ0LDM2LDYzLDU1LDQ3LDM5LDMxLDIzLDE1LDcsNjIsNTQsNDYsMzgsMzAsMjIsMTQsNiw2MSw1Myw0NSwzNywyOSwyMSwxMyw1LDI4LDIwLDEyLDRdO3ZhciBQQzI9WzE0LDE3LDExLDI0LDEsNSwzLDI4LDE1LDYsMjEsMTAsMjMsMTksMTIsNCwyNiw4LDE2LDcsMjcsMjAsMTMsMiw0MSw1MiwzMSwzNyw0Nyw1NSwzMCw0MCw1MSw0NSwzMyw0OCw0NCw0OSwzOSw1NiwzNCw1Myw0Niw0Miw1MCwzNiwyOSwzMl07dmFyIEJJVF9TSElGVFM9WzEsMiw0LDYsOCwxMCwxMiwxNCwxNSwxNywxOSwyMSwyMywyNSwyNywyOF07dmFyIFNCT1hfUD1bezA6ODQyMTg4OCwyNjg0MzU0NTY6MzI3NjgsNTM2ODcwOTEyOjg0MjEzNzgsODA1MzA2MzY4OjIsMTA3Mzc0MTgyNDo1MTIsMTM0MjE3NzI4MDo4NDIxODkwLDE2MTA2MTI3MzY6ODM4OTEyMiwxODc5MDQ4MTkyOjgzODg2MDgsMjE0NzQ4MzY0ODo1MTQsMjQxNTkxOTEwNDo4Mzg5MTIwLDI2ODQzNTQ1NjA6MzMyODAsMjk1Mjc5MDAxNjo4NDIxMzc2LDMyMjEyMjU0NzI6MzI3NzAsMzQ4OTY2MDkyODo4Mzg4NjEwLDM3NTgwOTYzODQ6MCw0MDI2NTMxODQwOjMzMjgyLDEzNDIxNzcyODowLDQwMjY1MzE4NDo4NDIxODkwLDY3MTA4ODY0MDozMzI4Miw5Mzk1MjQwOTY6MzI3NjgsMTIwNzk1OTU1Mjo4NDIxODg4LDE0NzYzOTUwMDg6NTEyLDE3NDQ4MzA0NjQ6ODQyMTM3OCwyMDEzMjY1OTIwOjIsMjI4MTcwMTM3Njo4Mzg5MTIwLDI1NTAxMzY4MzI6MzMyODAsMjgxODU3MjI4ODo4NDIxMzc2LDMwODcwMDc3NDQ6ODM4OTEyMiwzMzU1NDQzMjAwOjgzODg2MTAsMzYyMzg3ODY1NjozMjc3MCwzODkyMzE0MTEyOjUxNCw0MTYwNzQ5NTY4OjgzODg2MDgsMTozMjc2OCwyNjg0MzU0NTc6Miw1MzY4NzA5MTM6ODQyMTg4OCw4MDUzMDYzNjk6ODM4ODYwOCwxMDczNzQxODI1Ojg0MjEzNzgsMTM0MjE3NzI4MTozMzI4MCwxNjEwNjEyNzM3OjUxMiwxODc5MDQ4MTkzOjgzODkxMjIsMjE0NzQ4MzY0OTo4NDIxODkwLDI0MTU5MTkxMDU6ODQyMTM3NiwyNjg0MzU0NTYxOjgzODg2MTAsMjk1Mjc5MDAxNzozMzI4MiwzMjIxMjI1NDczOjUxNCwzNDg5NjYwOTI5OjgzODkxMjAsMzc1ODA5NjM4NTozMjc3MCw0MDI2NTMxODQxOjAsMTM0MjE3NzI5Ojg0MjE4OTAsNDAyNjUzMTg1Ojg0MjEzNzYsNjcxMDg4NjQxOjgzODg2MDgsOTM5NTI0MDk3OjUxMiwxMjA3OTU5NTUzOjMyNzY4LDE0NzYzOTUwMDk6ODM4ODYxMCwxNzQ0ODMwNDY1OjIsMjAxMzI2NTkyMTozMzI4MiwyMjgxNzAxMzc3OjMyNzcwLDI1NTAxMzY4MzM6ODM4OTEyMiwyODE4NTcyMjg5OjUxNCwzMDg3MDA3NzQ1Ojg0MjE4ODgsMzM1NTQ0MzIwMTo4Mzg5MTIwLDM2MjM4Nzg2NTc6MCwzODkyMzE0MTEzOjMzMjgwLDQxNjA3NDk1Njk6ODQyMTM3OH0sezA6MTA3NDI4MjUxMiwxNjc3NzIxNjoxNjM4NCwzMzU1NDQzMjo1MjQyODgsNTAzMzE2NDg6MTA3NDI2NjEyOCw2NzEwODg2NDoxMDczNzQxODQwLDgzODg2MDgwOjEwNzQyODI0OTYsMTAwNjYzMjk2OjEwNzM3NTgyMDgsMTE3NDQwNTEyOjE2LDEzNDIxNzcyODo1NDA2NzIsMTUwOTk0OTQ0OjEwNzM3NTgyMjQsMTY3NzcyMTYwOjEwNzM3NDE4MjQsMTg0NTQ5Mzc2OjU0MDY4OCwyMDEzMjY1OTI6NTI0MzA0LDIxODEwMzgwODowLDIzNDg4MTAyNDoxNjQwMCwyNTE2NTgyNDA6MTA3NDI2NjExMiw4Mzg4NjA4OjEwNzM3NTgyMDgsMjUxNjU4MjQ6NTQwNjg4LDQxOTQzMDQwOjE2LDU4NzIwMjU2OjEwNzM3NTgyMjQsNzU0OTc0NzI6MTA3NDI4MjUxMiw5MjI3NDY4ODoxMDczNzQxODI0LDEwOTA1MTkwNDo1MjQyODgsMTI1ODI5MTIwOjEwNzQyNjYxMjgsMTQyNjA2MzM2OjUyNDMwNCwxNTkzODM1NTI6MCwxNzYxNjA3Njg6MTYzODQsMTkyOTM3OTg0OjEwNzQyNjYxMTIsMjA5NzE1MjAwOjEwNzM3NDE4NDAsMjI2NDkyNDE2OjU0MDY3MiwyNDMyNjk2MzI6MTA3NDI4MjQ5NiwyNjAwNDY4NDg6MTY0MDAsMjY4NDM1NDU2OjAsMjg1MjEyNjcyOjEwNzQyNjYxMjgsMzAxOTg5ODg4OjEwNzM3NTgyMjQsMzE4NzY3MTA0OjEwNzQyODI0OTYsMzM1NTQ0MzIwOjEwNzQyNjYxMTIsMzUyMzIxNTM2OjE2LDM2OTA5ODc1Mjo1NDA2ODgsMzg1ODc1OTY4OjE2Mzg0LDQwMjY1MzE4NDoxNjQwMCw0MTk0MzA0MDA6NTI0Mjg4LDQzNjIwNzYxNjo1MjQzMDQsNDUyOTg0ODMyOjEwNzM3NDE4NDAsNDY5NzYyMDQ4OjU0MDY3Miw0ODY1MzkyNjQ6MTA3Mzc1ODIwOCw1MDMzMTY0ODA6MTA3Mzc0MTgyNCw1MjAwOTM2OTY6MTA3NDI4MjUxMiwyNzY4MjQwNjQ6NTQwNjg4LDI5MzYwMTI4MDo1MjQyODgsMzEwMzc4NDk2OjEwNzQyNjYxMTIsMzI3MTU1NzEyOjE2Mzg0LDM0MzkzMjkyODoxMDczNzU4MjA4LDM2MDcxMDE0NDoxMDc0MjgyNTEyLDM3NzQ4NzM2MDoxNiwzOTQyNjQ1NzY6MTA3Mzc0MTgyNCw0MTEwNDE3OTI6MTA3NDI4MjQ5Niw0Mjc4MTkwMDg6MTA3Mzc0MTg0MCw0NDQ1OTYyMjQ6MTA3Mzc1ODIyNCw0NjEzNzM0NDA6NTI0MzA0LDQ3ODE1MDY1NjowLDQ5NDkyNzg3MjoxNjQwMCw1MTE3MDUwODg6MTA3NDI2NjEyOCw1Mjg0ODIzMDQ6NTQwNjcyfSx7MDoyNjAsMTA0ODU3NjowLDIwOTcxNTI6NjcxMDkxMjAsMzE0NTcyODo2NTc5Niw0MTk0MzA0OjY1NTQwLDUyNDI4ODA6NjcxMDg4NjgsNjI5MTQ1Njo2NzE3NDY2MCw3MzQwMDMyOjY3MTc0NDAwLDgzODg2MDg6NjcxMDg4NjQsOTQzNzE4NDo2NzE3NDY1NiwxMDQ4NTc2MDo2NTc5MiwxMTUzNDMzNjo2NzE3NDQwNCwxMjU4MjkxMjo2NzEwOTEyNCwxMzYzMTQ4ODo2NTUzNiwxNDY4MDA2NDo0LDE1NzI4NjQwOjI1Niw1MjQyODg6NjcxNzQ2NTYsMTU3Mjg2NDo2NzE3NDQwNCwyNjIxNDQwOjAsMzY3MDAxNjo2NzEwOTEyMCw0NzE4NTkyOjY3MTA4ODY4LDU3NjcxNjg6NjU1MzYsNjgxNTc0NDo2NTU0MCw3ODY0MzIwOjI2MCw4OTEyODk2OjQsOTk2MTQ3MjoyNTYsMTEwMTAwNDg6NjcxNzQ0MDAsMTIwNTg2MjQ6NjU3OTYsMTMxMDcyMDA6NjU3OTIsMTQxNTU3NzY6NjcxMDkxMjQsMTUyMDQzNTI6NjcxNzQ2NjAsMTYyNTI5Mjg6NjcxMDg4NjQsMTY3NzcyMTY6NjcxNzQ2NTYsMTc4MjU3OTI6NjU1NDAsMTg4NzQzNjg6NjU1MzYsMTk5MjI5NDQ6NjcxMDkxMjAsMjA5NzE1MjA6MjU2LDIyMDIwMDk2OjY3MTc0NjYwLDIzMDY4NjcyOjY3MTA4ODY4LDI0MTE3MjQ4OjAsMjUxNjU4MjQ6NjcxMDkxMjQsMjYyMTQ0MDA6NjcxMDg4NjQsMjcyNjI5NzY6NCwyODMxMTU1Mjo2NTc5MiwyOTM2MDEyODo2NzE3NDQwMCwzMDQwODcwNDoyNjAsMzE0NTcyODA6NjU3OTYsMzI1MDU4NTY6NjcxNzQ0MDQsMTczMDE1MDQ6NjcxMDg4NjQsMTgzNTAwODA6MjYwLDE5Mzk4NjU2OjY3MTc0NjU2LDIwNDQ3MjMyOjAsMjE0OTU4MDg6NjU1NDAsMjI1NDQzODQ6NjcxMDkxMjAsMjM1OTI5NjA6MjU2LDI0NjQxNTM2OjY3MTc0NDA0LDI1NjkwMTEyOjY1NTM2LDI2NzM4Njg4OjY3MTc0NjYwLDI3Nzg3MjY0OjY1Nzk2LDI4ODM1ODQwOjY3MTA4ODY4LDI5ODg0NDE2OjY3MTA5MTI0LDMwOTMyOTkyOjY3MTc0NDAwLDMxOTgxNTY4OjQsMzMwMzAxNDQ6NjU3OTJ9LHswOjIxNTE2ODIwNDgsNjU1MzY6MjE0NzQ4NzgwOCwxMzEwNzI6NDE5ODQ2NCwxOTY2MDg6MjE1MTY3Nzk1MiwyNjIxNDQ6MCwzMjc2ODA6NDE5ODQwMCwzOTMyMTY6MjE0NzQ4MzcxMiw0NTg3NTI6NDE5NDM2OCw1MjQyODg6MjE0NzQ4MzY0OCw1ODk4MjQ6NDE5NDMwNCw2NTUzNjA6NjQsNzIwODk2OjIxNDc0ODc3NDQsNzg2NDMyOjIxNTE2NzgwMTYsODUxOTY4OjQxNjAsOTE3NTA0OjQwOTYsOTgzMDQwOjIxNTE2ODIxMTIsMzI3Njg6MjE0NzQ4NzgwOCw5ODMwNDo2NCwxNjM4NDA6MjE1MTY3ODAxNiwyMjkzNzY6MjE0NzQ4Nzc0NCwyOTQ5MTI6NDE5ODQwMCwzNjA0NDg6MjE1MTY4MjExMiw0MjU5ODQ6MCw0OTE1MjA6MjE1MTY3Nzk1Miw1NTcwNTY6NDA5Niw2MjI1OTI6MjE1MTY4MjA0OCw2ODgxMjg6NDE5NDMwNCw3NTM2NjQ6NDE2MCw4MTkyMDA6MjE0NzQ4MzY0OCw4ODQ3MzY6NDE5NDM2OCw5NTAyNzI6NDE5ODQ2NCwxMDE1ODA4OjIxNDc0ODM3MTIsMTA0ODU3Njo0MTk0MzY4LDExMTQxMTI6NDE5ODQwMCwxMTc5NjQ4OjIxNDc0ODM3MTIsMTI0NTE4NDowLDEzMTA3MjA6NDE2MCwxMzc2MjU2OjIxNTE2NzgwMTYsMTQ0MTc5MjoyMTUxNjgyMDQ4LDE1MDczMjg6MjE0NzQ4NzgwOCwxNTcyODY0OjIxNTE2ODIxMTIsMTYzODQwMDoyMTQ3NDgzNjQ4LDE3MDM5MzY6MjE1MTY3Nzk1MiwxNzY5NDcyOjQxOTg0NjQsMTgzNTAwODoyMTQ3NDg3NzQ0LDE5MDA1NDQ6NDE5NDMwNCwxOTY2MDgwOjY0LDIwMzE2MTY6NDA5NiwxMDgxMzQ0OjIxNTE2Nzc5NTIsMTE0Njg4MDoyMTUxNjgyMTEyLDEyMTI0MTY6MCwxMjc3OTUyOjQxOTg0MDAsMTM0MzQ4ODo0MTk0MzY4LDE0MDkwMjQ6MjE0NzQ4MzY0OCwxNDc0NTYwOjIxNDc0ODc4MDgsMTU0MDA5Njo2NCwxNjA1NjMyOjIxNDc0ODM3MTIsMTY3MTE2ODo0MDk2LDE3MzY3MDQ6MjE0NzQ4Nzc0NCwxODAyMjQwOjIxNTE2NzgwMTYsMTg2Nzc3Njo0MTYwLDE5MzMzMTI6MjE1MTY4MjA0OCwxOTk4ODQ4OjQxOTQzMDQsMjA2NDM4NDo0MTk4NDY0fSx7MDoxMjgsNDA5NjoxNzAzOTM2MCw4MTkyOjI2MjE0NCwxMjI4ODo1MzY4NzA5MTIsMTYzODQ6NTM3MTMzMTg0LDIwNDgwOjE2Nzc3MzQ0LDI0NTc2OjU1MzY0ODI1NiwyODY3MjoyNjIyNzIsMzI3Njg6MTY3NzcyMTYsMzY4NjQ6NTM3MTMzMDU2LDQwOTYwOjUzNjg3MTA0MCw0NTA1Njo1NTM5MTA0MDAsNDkxNTI6NTUzOTEwMjcyLDUzMjQ4OjAsNTczNDQ6MTcwMzk0ODgsNjE0NDA6NTUzNjQ4MTI4LDIwNDg6MTcwMzk0ODgsNjE0NDo1NTM2NDgyNTYsMTAyNDA6MTI4LDE0MzM2OjE3MDM5MzYwLDE4NDMyOjI2MjE0NCwyMjUyODo1MzcxMzMxODQsMjY2MjQ6NTUzOTEwMjcyLDMwNzIwOjUzNjg3MDkxMiwzNDgxNjo1MzcxMzMwNTYsMzg5MTI6MCw0MzAwODo1NTM5MTA0MDAsNDcxMDQ6MTY3NzczNDQsNTEyMDA6NTM2ODcxMDQwLDU1Mjk2OjU1MzY0ODEyOCw1OTM5MjoxNjc3NzIxNiw2MzQ4ODoyNjIyNzIsNjU1MzY6MjYyMTQ0LDY5NjMyOjEyOCw3MzcyODo1MzY4NzA5MTIsNzc4MjQ6NTUzNjQ4MjU2LDgxOTIwOjE2Nzc3MzQ0LDg2MDE2OjU1MzkxMDI3Miw5MDExMjo1MzcxMzMxODQsOTQyMDg6MTY3NzcyMTYsOTgzMDQ6NTUzOTEwNDAwLDEwMjQwMDo1NTM2NDgxMjgsMTA2NDk2OjE3MDM5MzYwLDExMDU5Mjo1MzcxMzMwNTYsMTE0Njg4OjI2MjI3MiwxMTg3ODQ6NTM2ODcxMDQwLDEyMjg4MDowLDEyNjk3NjoxNzAzOTQ4OCw2NzU4NDo1NTM2NDgyNTYsNzE2ODA6MTY3NzcyMTYsNzU3NzY6MTcwMzkzNjAsNzk4NzI6NTM3MTMzMTg0LDgzOTY4OjUzNjg3MDkxMiw4ODA2NDoxNzAzOTQ4OCw5MjE2MDoxMjgsOTYyNTY6NTUzOTEwMjcyLDEwMDM1MjoyNjIyNzIsMTA0NDQ4OjU1MzkxMDQwMCwxMDg1NDQ6MCwxMTI2NDA6NTUzNjQ4MTI4LDExNjczNjoxNjc3NzM0NCwxMjA4MzI6MjYyMTQ0LDEyNDkyODo1MzcxMzMwNTYsMTI5MDI0OjUzNjg3MTA0MH0sezA6MjY4NDM1NDY0LDI1Njo4MTkyLDUxMjoyNzA1MzI2MDgsNzY4OjI3MDU0MDgwOCwxMDI0OjI2ODQ0MzY0OCwxMjgwOjIwOTcxNTIsMTUzNjoyMDk3MTYwLDE3OTI6MjY4NDM1NDU2LDIwNDg6MCwyMzA0OjI2ODQ0MzY1NiwyNTYwOjIxMDUzNDQsMjgxNjo4LDMwNzI6MjcwNTMyNjE2LDMzMjg6MjEwNTM1MiwzNTg0OjgyMDAsMzg0MDoyNzA1NDA4MDAsMTI4OjI3MDUzMjYwOCwzODQ6MjcwNTQwODA4LDY0MDo4LDg5NjoyMDk3MTUyLDExNTI6MjEwNTM1MiwxNDA4OjI2ODQzNTQ2NCwxNjY0OjI2ODQ0MzY0OCwxOTIwOjgyMDAsMjE3NjoyMDk3MTYwLDI0MzI6ODE5MiwyNjg4OjI2ODQ0MzY1NiwyOTQ0OjI3MDUzMjYxNiwzMjAwOjAsMzQ1NjoyNzA1NDA4MDAsMzcxMjoyMTA1MzQ0LDM5Njg6MjY4NDM1NDU2LDQwOTY6MjY4NDQzNjQ4LDQzNTI6MjcwNTMyNjE2LDQ2MDg6MjcwNTQwODA4LDQ4NjQ6ODIwMCw1MTIwOjIwOTcxNTIsNTM3NjoyNjg0MzU0NTYsNTYzMjoyNjg0MzU0NjQsNTg4ODoyMTA1MzQ0LDYxNDQ6MjEwNTM1Miw2NDAwOjAsNjY1Njo4LDY5MTI6MjcwNTMyNjA4LDcxNjg6ODE5Miw3NDI0OjI2ODQ0MzY1Niw3NjgwOjI3MDU0MDgwMCw3OTM2OjIwOTcxNjAsNDIyNDo4LDQ0ODA6MjEwNTM0NCw0NzM2OjIwOTcxNTIsNDk5MjoyNjg0MzU0NjQsNTI0ODoyNjg0NDM2NDgsNTUwNDo4MjAwLDU3NjA6MjcwNTQwODA4LDYwMTY6MjcwNTMyNjA4LDYyNzI6MjcwNTQwODAwLDY1Mjg6MjcwNTMyNjE2LDY3ODQ6ODE5Miw3MDQwOjIxMDUzNTIsNzI5NjoyMDk3MTYwLDc1NTI6MCw3ODA4OjI2ODQzNTQ1Niw4MDY0OjI2ODQ0MzY1Nn0sezA6MTA0ODU3NiwxNjozMzU1NTQ1NywzMjoxMDI0LDQ4OjEwNDk2MDEsNjQ6MzQ2MDQwMzMsODA6MCw5NjoxLDExMjozNDYwMzAwOSwxMjg6MzM1NTU0NTYsMTQ0OjEwNDg1NzcsMTYwOjMzNTU0NDMzLDE3NjozNDYwNDAzMiwxOTI6MzQ2MDMwMDgsMjA4OjEwMjUsMjI0OjEwNDk2MDAsMjQwOjMzNTU0NDMyLDg6MzQ2MDMwMDksMjQ6MCw0MDozMzU1NTQ1Nyw1NjozNDYwNDAzMiw3MjoxMDQ4NTc2LDg4OjMzNTU0NDMzLDEwNDozMzU1NDQzMiwxMjA6MTAyNSwxMzY6MTA0OTYwMSwxNTI6MzM1NTU0NTYsMTY4OjM0NjAzMDA4LDE4NDoxMDQ4NTc3LDIwMDoxMDI0LDIxNjozNDYwNDAzMywyMzI6MSwyNDg6MTA0OTYwMCwyNTY6MzM1NTQ0MzIsMjcyOjEwNDg1NzYsMjg4OjMzNTU1NDU3LDMwNDozNDYwMzAwOSwzMjA6MTA0ODU3NywzMzY6MzM1NTU0NTYsMzUyOjM0NjA0MDMyLDM2ODoxMDQ5NjAxLDM4NDoxMDI1LDQwMDozNDYwNDAzMyw0MTY6MTA0OTYwMCw0MzI6MSw0NDg6MCw0NjQ6MzQ2MDMwMDgsNDgwOjMzNTU0NDMzLDQ5NjoxMDI0LDI2NDoxMDQ5NjAwLDI4MDozMzU1NTQ1NywyOTY6MzQ2MDMwMDksMzEyOjEsMzI4OjMzNTU0NDMyLDM0NDoxMDQ4NTc2LDM2MDoxMDI1LDM3NjozNDYwNDAzMiwzOTI6MzM1NTQ0MzMsNDA4OjM0NjAzMDA4LDQyNDowLDQ0MDozNDYwNDAzMyw0NTY6MTA0OTYwMSw0NzI6MTAyNCw0ODg6MzM1NTU0NTYsNTA0OjEwNDg1Nzd9LHswOjEzNDIxOTgwOCwxOjEzMTA3MiwyOjEzNDIxNzcyOCwzOjMyLDQ6MTMxMTA0LDU6MTM0MzUwODgwLDY6MTM0MzUwODQ4LDc6MjA0OCw4OjEzNDM0ODgwMCw5OjEzNDIxOTc3NiwxMDoxMzMxMjAsMTE6MTM0MzQ4ODMyLDEyOjIwODAsMTM6MCwxNDoxMzQyMTc3NjAsMTU6MTMzMTUyLDIxNDc0ODM2NDg6MjA0OCwyMTQ3NDgzNjQ5OjEzNDM1MDg4MCwyMTQ3NDgzNjUwOjEzNDIxOTgwOCwyMTQ3NDgzNjUxOjEzNDIxNzcyOCwyMTQ3NDgzNjUyOjEzNDM0ODgwMCwyMTQ3NDgzNjUzOjEzMzEyMCwyMTQ3NDgzNjU0OjEzMzE1MiwyMTQ3NDgzNjU1OjMyLDIxNDc0ODM2NTY6MTM0MjE3NzYwLDIxNDc0ODM2NTc6MjA4MCwyMTQ3NDgzNjU4OjEzMTEwNCwyMTQ3NDgzNjU5OjEzNDM1MDg0OCwyMTQ3NDgzNjYwOjAsMjE0NzQ4MzY2MToxMzQzNDg4MzIsMjE0NzQ4MzY2MjoxMzQyMTk3NzYsMjE0NzQ4MzY2MzoxMzEwNzIsMTY6MTMzMTUyLDE3OjEzNDM1MDg0OCwxODozMiwxOToyMDQ4LDIwOjEzNDIxOTc3NiwyMToxMzQyMTc3NjAsMjI6MTM0MzQ4ODMyLDIzOjEzMTA3MiwyNDowLDI1OjEzMTEwNCwyNjoxMzQzNDg4MDAsMjc6MTM0MjE5ODA4LDI4OjEzNDM1MDg4MCwyOToxMzMxMjAsMzA6MjA4MCwzMToxMzQyMTc3MjgsMjE0NzQ4MzY2NDoxMzEwNzIsMjE0NzQ4MzY2NToyMDQ4LDIxNDc0ODM2NjY6MTM0MzQ4ODMyLDIxNDc0ODM2Njc6MTMzMTUyLDIxNDc0ODM2Njg6MzIsMjE0NzQ4MzY2OToxMzQzNDg4MDAsMjE0NzQ4MzY3MDoxMzQyMTc3MjgsMjE0NzQ4MzY3MToxMzQyMTk4MDgsMjE0NzQ4MzY3MjoxMzQzNTA4ODAsMjE0NzQ4MzY3MzoxMzQyMTc3NjAsMjE0NzQ4MzY3NDoxMzQyMTk3NzYsMjE0NzQ4MzY3NTowLDIxNDc0ODM2NzY6MTMzMTIwLDIxNDc0ODM2Nzc6MjA4MCwyMTQ3NDgzNjc4OjEzMTEwNCwyMTQ3NDgzNjc5OjEzNDM1MDg0OH1dO1xudmFyIFNCT1hfTUFTSz1bNDE2MDc0OTU2OSw1Mjg0ODIzMDQsMzMwMzAxNDQsMjA2NDM4NCwxMjkwMjQsODA2NCw1MDQsMjE0NzQ4MzY3OV07dmFyIERFUz1DX2FsZ28uREVTPUJsb2NrQ2lwaGVyLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt2YXIga2V5PXRoaXMuX2tleTt2YXIga2V5V29yZHM9a2V5LndvcmRzO3ZhciBrZXlCaXRzPVtdO2Zvcih2YXIgaT0wO2k8NTY7aSsrKXt2YXIga2V5Qml0UG9zPVBDMVtpXS0xO2tleUJpdHNbaV09a2V5V29yZHNba2V5Qml0UG9zPj4+NV0+Pj4zMS1rZXlCaXRQb3MlMzImMX12YXIgc3ViS2V5cz10aGlzLl9zdWJLZXlzPVtdO2Zvcih2YXIgblN1YktleT0wO25TdWJLZXk8MTY7blN1YktleSsrKXt2YXIgc3ViS2V5PXN1YktleXNbblN1YktleV09W107dmFyIGJpdFNoaWZ0PUJJVF9TSElGVFNbblN1YktleV07Zm9yKHZhciBpPTA7aTwyNDtpKyspe3N1YktleVtpLzZ8MF18PWtleUJpdHNbKFBDMltpXS0xK2JpdFNoaWZ0KSUyOF08PDMxLWklNjtzdWJLZXlbNCsoaS82fDApXXw9a2V5Qml0c1syOCsoUEMyW2krMjRdLTErYml0U2hpZnQpJTI4XTw8MzEtaSU2fXN1YktleVswXT1zdWJLZXlbMF08PDF8c3ViS2V5WzBdPj4+MzE7Zm9yKHZhciBpPTE7aTw3O2krKyl7c3ViS2V5W2ldPXN1YktleVtpXT4+PihpLTEpKjQrM31zdWJLZXlbN109c3ViS2V5WzddPDw1fHN1YktleVs3XT4+PjI3fXZhciBpbnZTdWJLZXlzPXRoaXMuX2ludlN1YktleXM9W107Zm9yKHZhciBpPTA7aTwxNjtpKyspe2ludlN1YktleXNbaV09c3ViS2V5c1sxNS1pXX19LGVuY3J5cHRCbG9jazpmdW5jdGlvbihNLG9mZnNldCl7dGhpcy5fZG9DcnlwdEJsb2NrKE0sb2Zmc2V0LHRoaXMuX3N1YktleXMpfSxkZWNyeXB0QmxvY2s6ZnVuY3Rpb24oTSxvZmZzZXQpe3RoaXMuX2RvQ3J5cHRCbG9jayhNLG9mZnNldCx0aGlzLl9pbnZTdWJLZXlzKX0sX2RvQ3J5cHRCbG9jazpmdW5jdGlvbihNLG9mZnNldCxzdWJLZXlzKXt0aGlzLl9sQmxvY2s9TVtvZmZzZXRdO3RoaXMuX3JCbG9jaz1NW29mZnNldCsxXTtleGNoYW5nZUxSLmNhbGwodGhpcyw0LDI1MjY0NTEzNSk7ZXhjaGFuZ2VMUi5jYWxsKHRoaXMsMTYsNjU1MzUpO2V4Y2hhbmdlUkwuY2FsbCh0aGlzLDIsODU4OTkzNDU5KTtleGNoYW5nZVJMLmNhbGwodGhpcyw4LDE2NzExOTM1KTtleGNoYW5nZUxSLmNhbGwodGhpcywxLDE0MzE2NTU3NjUpO2Zvcih2YXIgcm91bmQ9MDtyb3VuZDwxNjtyb3VuZCsrKXt2YXIgc3ViS2V5PXN1YktleXNbcm91bmRdO3ZhciBsQmxvY2s9dGhpcy5fbEJsb2NrO3ZhciByQmxvY2s9dGhpcy5fckJsb2NrO3ZhciBmPTA7Zm9yKHZhciBpPTA7aTw4O2krKyl7Znw9U0JPWF9QW2ldWygockJsb2NrXnN1YktleVtpXSkmU0JPWF9NQVNLW2ldKT4+PjBdfXRoaXMuX2xCbG9jaz1yQmxvY2s7dGhpcy5fckJsb2NrPWxCbG9ja15mfXZhciB0PXRoaXMuX2xCbG9jazt0aGlzLl9sQmxvY2s9dGhpcy5fckJsb2NrO3RoaXMuX3JCbG9jaz10O2V4Y2hhbmdlTFIuY2FsbCh0aGlzLDEsMTQzMTY1NTc2NSk7ZXhjaGFuZ2VSTC5jYWxsKHRoaXMsOCwxNjcxMTkzNSk7ZXhjaGFuZ2VSTC5jYWxsKHRoaXMsMiw4NTg5OTM0NTkpO2V4Y2hhbmdlTFIuY2FsbCh0aGlzLDE2LDY1NTM1KTtleGNoYW5nZUxSLmNhbGwodGhpcyw0LDI1MjY0NTEzNSk7TVtvZmZzZXRdPXRoaXMuX2xCbG9jaztNW29mZnNldCsxXT10aGlzLl9yQmxvY2t9LGtleVNpemU6NjQvMzIsaXZTaXplOjY0LzMyLGJsb2NrU2l6ZTo2NC8zMn0pO2Z1bmN0aW9uIGV4Y2hhbmdlTFIob2Zmc2V0LG1hc2spe3ZhciB0PSh0aGlzLl9sQmxvY2s+Pj5vZmZzZXRedGhpcy5fckJsb2NrKSZtYXNrO3RoaXMuX3JCbG9ja149dDt0aGlzLl9sQmxvY2tePXQ8PG9mZnNldH1mdW5jdGlvbiBleGNoYW5nZVJMKG9mZnNldCxtYXNrKXt2YXIgdD0odGhpcy5fckJsb2NrPj4+b2Zmc2V0XnRoaXMuX2xCbG9jaykmbWFzazt0aGlzLl9sQmxvY2tePXQ7dGhpcy5fckJsb2NrXj10PDxvZmZzZXR9Qy5ERVM9QmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihERVMpO3ZhciBUcmlwbGVERVM9Q19hbGdvLlRyaXBsZURFUz1CbG9ja0NpcGhlci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dmFyIGtleT10aGlzLl9rZXk7dmFyIGtleVdvcmRzPWtleS53b3Jkczt0aGlzLl9kZXMxPURFUy5jcmVhdGVFbmNyeXB0b3IoV29yZEFycmF5LmNyZWF0ZShrZXlXb3Jkcy5zbGljZSgwLDIpKSk7dGhpcy5fZGVzMj1ERVMuY3JlYXRlRW5jcnlwdG9yKFdvcmRBcnJheS5jcmVhdGUoa2V5V29yZHMuc2xpY2UoMiw0KSkpO3RoaXMuX2RlczM9REVTLmNyZWF0ZUVuY3J5cHRvcihXb3JkQXJyYXkuY3JlYXRlKGtleVdvcmRzLnNsaWNlKDQsNikpKX0sZW5jcnlwdEJsb2NrOmZ1bmN0aW9uKE0sb2Zmc2V0KXt0aGlzLl9kZXMxLmVuY3J5cHRCbG9jayhNLG9mZnNldCk7dGhpcy5fZGVzMi5kZWNyeXB0QmxvY2soTSxvZmZzZXQpO3RoaXMuX2RlczMuZW5jcnlwdEJsb2NrKE0sb2Zmc2V0KX0sZGVjcnlwdEJsb2NrOmZ1bmN0aW9uKE0sb2Zmc2V0KXt0aGlzLl9kZXMzLmRlY3J5cHRCbG9jayhNLG9mZnNldCk7dGhpcy5fZGVzMi5lbmNyeXB0QmxvY2soTSxvZmZzZXQpO3RoaXMuX2RlczEuZGVjcnlwdEJsb2NrKE0sb2Zmc2V0KX0sa2V5U2l6ZToxOTIvMzIsaXZTaXplOjY0LzMyLGJsb2NrU2l6ZTo2NC8zMn0pO0MuVHJpcGxlREVTPUJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoVHJpcGxlREVTKX0pKCk7cmV0dXJuIENyeXB0b0pTLlRyaXBsZURFU30pfSx7XCIuL2NpcGhlci1jb3JlXCI6MTksXCIuL2NvcmVcIjoyMCxcIi4vZW5jLWJhc2U2NFwiOjIxLFwiLi9ldnBrZGZcIjoyMyxcIi4vbWQ1XCI6Mjl9XSw1MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHJvb3QsZmFjdG9yeSl7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiKXttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWZhY3RvcnkoX2RlcmVxXyhcIi4vY29yZVwiKSl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW1wiLi9jb3JlXCJdLGZhY3RvcnkpfWVsc2V7ZmFjdG9yeShyb290LkNyeXB0b0pTKX19KSh0aGlzLGZ1bmN0aW9uKENyeXB0b0pTKXsoZnVuY3Rpb24odW5kZWZpbmVkKXt2YXIgQz1DcnlwdG9KUzt2YXIgQ19saWI9Qy5saWI7dmFyIEJhc2U9Q19saWIuQmFzZTt2YXIgWDMyV29yZEFycmF5PUNfbGliLldvcmRBcnJheTt2YXIgQ194NjQ9Qy54NjQ9e307dmFyIFg2NFdvcmQ9Q194NjQuV29yZD1CYXNlLmV4dGVuZCh7aW5pdDpmdW5jdGlvbihoaWdoLGxvdyl7dGhpcy5oaWdoPWhpZ2g7dGhpcy5sb3c9bG93fX0pO3ZhciBYNjRXb3JkQXJyYXk9Q194NjQuV29yZEFycmF5PUJhc2UuZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKHdvcmRzLHNpZ0J5dGVzKXt3b3Jkcz10aGlzLndvcmRzPXdvcmRzfHxbXTtpZihzaWdCeXRlcyE9dW5kZWZpbmVkKXt0aGlzLnNpZ0J5dGVzPXNpZ0J5dGVzfWVsc2V7dGhpcy5zaWdCeXRlcz13b3Jkcy5sZW5ndGgqOH19LHRvWDMyOmZ1bmN0aW9uKCl7dmFyIHg2NFdvcmRzPXRoaXMud29yZHM7dmFyIHg2NFdvcmRzTGVuZ3RoPXg2NFdvcmRzLmxlbmd0aDt2YXIgeDMyV29yZHM9W107Zm9yKHZhciBpPTA7aTx4NjRXb3Jkc0xlbmd0aDtpKyspe3ZhciB4NjRXb3JkPXg2NFdvcmRzW2ldO3gzMldvcmRzLnB1c2goeDY0V29yZC5oaWdoKTt4MzJXb3Jkcy5wdXNoKHg2NFdvcmQubG93KX1yZXR1cm4gWDMyV29yZEFycmF5LmNyZWF0ZSh4MzJXb3Jkcyx0aGlzLnNpZ0J5dGVzKX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgY2xvbmU9QmFzZS5jbG9uZS5jYWxsKHRoaXMpO3ZhciB3b3Jkcz1jbG9uZS53b3Jkcz10aGlzLndvcmRzLnNsaWNlKDApO3ZhciB3b3Jkc0xlbmd0aD13b3Jkcy5sZW5ndGg7Zm9yKHZhciBpPTA7aTx3b3Jkc0xlbmd0aDtpKyspe3dvcmRzW2ldPXdvcmRzW2ldLmNsb25lKCl9cmV0dXJuIGNsb25lfX0pfSkoKTtyZXR1cm4gQ3J5cHRvSlN9KX0se1wiLi9jb3JlXCI6MjB9XSw1MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHByb2Nlc3MpeyFmdW5jdGlvbihnbG9iYWxzKXtcInVzZSBzdHJpY3RcIjtpZih0eXBlb2YgZGVmaW5lIT09XCJ1bmRlZmluZWRcIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGZ1bmN0aW9uKCl7cmV0dXJuIHNlY3VyZVJhbmRvbX0pfWVsc2UgaWYodHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCImJm1vZHVsZS5leHBvcnRzKXttb2R1bGUuZXhwb3J0cz1zZWN1cmVSYW5kb219ZWxzZXtnbG9iYWxzLnNlY3VyZVJhbmRvbT1zZWN1cmVSYW5kb219ZnVuY3Rpb24gc2VjdXJlUmFuZG9tKGNvdW50LG9wdGlvbnMpe29wdGlvbnM9b3B0aW9uc3x8e307aWYodHlwZW9mIHByb2Nlc3MhPVwidW5kZWZpbmVkXCImJnR5cGVvZiBwcm9jZXNzLnBpZD09XCJudW1iZXJcIil7cmV0dXJuIG5vZGVSYW5kb20oY291bnQsb3B0aW9ucyl9ZWxzZXtpZighd2luZG93LmNyeXB0byl0aHJvdyBuZXcgRXJyb3IoXCJZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB3aW5kb3cuY3J5cHRvLlwiKTtyZXR1cm4gYnJvd3NlclJhbmRvbShjb3VudCxvcHRpb25zKX19ZnVuY3Rpb24gbm9kZVJhbmRvbShjb3VudCxvcHRpb25zKXt2YXIgY3J5cHRvPV9kZXJlcV8oXCJjcnlwdG9cIik7dmFyIGJ1Zj1jcnlwdG8ucmFuZG9tQnl0ZXMoY291bnQpO2lmKG9wdGlvbnMuYXJyYXkpdmFyIHJldD1bXTtlbHNlIHZhciByZXQ9bmV3IFVpbnQ4QXJyYXkoY291bnQpO2Zvcih2YXIgaT0wO2k8Y291bnQ7KytpKXtyZXRbaV09YnVmLnJlYWRVSW50OChpKX1yZXR1cm4gcmV0fWZ1bmN0aW9uIGJyb3dzZXJSYW5kb20oY291bnQsb3B0aW9ucyl7dmFyIG5hdGl2ZUFycj1uZXcgVWludDhBcnJheShjb3VudCk7d2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmF0aXZlQXJyKTtpZihvcHRpb25zLmFycmF5KXt2YXIgcmV0PVtdO2Zvcih2YXIgaT0wO2k8bmF0aXZlQXJyLmxlbmd0aDsrK2kpe3JldFtpXT1uYXRpdmVBcnJbaV19fWVsc2V7cmV0PW5hdGl2ZUFycn1yZXR1cm4gcmV0fX0odGhpcyl9KS5jYWxsKHRoaXMsX2RlcmVxXyhcIkZXYUFTSFwiKSl9LHtGV2FBU0g6MTUsY3J5cHRvOjR9XSw1NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIGJhc2U1OD1fZGVyZXFfKFwiLi9iYXNlNThcIik7dmFyIGJhc2U1OGNoZWNrPV9kZXJlcV8oXCIuL2Jhc2U1OGNoZWNrXCIpO3ZhciBjb252ZXJ0PV9kZXJlcV8oXCIuL2NvbnZlcnRcIik7dmFyIGVycm9yPV9kZXJlcV8oXCIuL3V0aWxcIikuZXJyb3I7dmFyIG1haW5uZXQ9X2RlcmVxXyhcIi4vbmV0d29ya1wiKS5tYWlubmV0LmFkZHJlc3NWZXJzaW9uO2Z1bmN0aW9uIEFkZHJlc3MoYnl0ZXMsdmVyc2lvbil7aWYoISh0aGlzIGluc3RhbmNlb2YgQWRkcmVzcykpe3JldHVybiBuZXcgQWRkcmVzcyhieXRlcyx2ZXJzaW9uKX1pZihieXRlcyBpbnN0YW5jZW9mIEFkZHJlc3Mpe3RoaXMuaGFzaD1ieXRlcy5oYXNoO3RoaXMudmVyc2lvbj1ieXRlcy52ZXJzaW9ufWVsc2UgaWYodHlwZW9mIGJ5dGVzPT09XCJzdHJpbmdcIil7aWYoYnl0ZXMubGVuZ3RoPD0zNSl7dmFyIGRlY29kZT1iYXNlNThjaGVjay5kZWNvZGUoYnl0ZXMpO3RoaXMuaGFzaD1kZWNvZGUucGF5bG9hZDt0aGlzLnZlcnNpb249ZGVjb2RlLnZlcnNpb259ZWxzZSBpZihieXRlcy5sZW5ndGg8PTQwKXt0aGlzLmhhc2g9Y29udmVydC5oZXhUb0J5dGVzKGJ5dGVzKTt0aGlzLnZlcnNpb249dmVyc2lvbnx8bWFpbm5ldH1lbHNle2Vycm9yKFwiaW52YWxpZCBvciB1bnJlY29nbml6ZWQgaW5wdXRcIil9fWVsc2V7dGhpcy5oYXNoPWJ5dGVzO3RoaXMudmVyc2lvbj12ZXJzaW9ufHxtYWlubmV0fX1BZGRyZXNzLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBiYXNlNThjaGVjay5lbmNvZGUodGhpcy5oYXNoLnNsaWNlKDApLHRoaXMudmVyc2lvbil9O0FkZHJlc3MuZ2V0VmVyc2lvbj1mdW5jdGlvbihhZGRyZXNzKXtyZXR1cm4gYmFzZTU4LmRlY29kZShhZGRyZXNzKVswXX07QWRkcmVzcy52YWxpZGF0ZT1mdW5jdGlvbihhZGRyZXNzKXt0cnl7YmFzZTU4Y2hlY2suZGVjb2RlKGFkZHJlc3MpO3JldHVybiB0cnVlfWNhdGNoKGUpe3JldHVybiBmYWxzZX19O21vZHVsZS5leHBvcnRzPUFkZHJlc3N9LHtcIi4vYmFzZTU4XCI6NTUsXCIuL2Jhc2U1OGNoZWNrXCI6NTYsXCIuL2NvbnZlcnRcIjo1NyxcIi4vbmV0d29ya1wiOjY2LFwiLi91dGlsXCI6NzB9XSw1NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKEJ1ZmZlcil7dmFyIEJpZ0ludGVnZXI9X2RlcmVxXyhcIi4vanNibi9qc2JuXCIpO3ZhciBhbHBoYWJldD1cIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIjt2YXIgYmFzZT1CaWdJbnRlZ2VyLnZhbHVlT2YoNTgpO3ZhciBhbHBoYWJldE1hcD17fTtmb3IodmFyIGk9MDtpPGFscGhhYmV0Lmxlbmd0aDsrK2kpe3ZhciBjaHI9YWxwaGFiZXRbaV07YWxwaGFiZXRNYXBbY2hyXT1CaWdJbnRlZ2VyLnZhbHVlT2YoaSl9ZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlcil7dmFyIGJpPUJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKGJ1ZmZlcik7dmFyIGNoYXJzPVtdO3doaWxlKGJpLmNvbXBhcmVUbyhiYXNlKT49MCl7dmFyIG1vZD1iaS5tb2QoYmFzZSk7Ymk9Ymkuc3VidHJhY3QobW9kKS5kaXZpZGUoYmFzZSk7Y2hhcnMucHVzaChhbHBoYWJldFttb2QuaW50VmFsdWUoKV0pfWNoYXJzLnB1c2goYWxwaGFiZXRbYmkuaW50VmFsdWUoKV0pO2Zvcih2YXIgaT0wO2k8YnVmZmVyLmxlbmd0aDtpKyspe2lmKGJ1ZmZlcltpXSE9PTApYnJlYWs7Y2hhcnMucHVzaChhbHBoYWJldFswXSl9cmV0dXJuIGNoYXJzLnJldmVyc2UoKS5qb2luKFwiXCIpfWZ1bmN0aW9uIGRlY29kZShzdHIpe3ZhciBudW09QmlnSW50ZWdlci52YWx1ZU9mKDApO3ZhciBsZWFkaW5nX3plcm89MDt2YXIgc2Vlbl9vdGhlcj1mYWxzZTtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgY2hyPXN0cltpXTt2YXIgYmk9YWxwaGFiZXRNYXBbY2hyXTtpZihiaT09PXVuZGVmaW5lZCl7dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiYXNlNTggc3RyaW5nOiBcIitzdHIpfW51bT1udW0ubXVsdGlwbHkoYmFzZSkuYWRkKGJpKTtpZihjaHI9PT1cIjFcIiYmIXNlZW5fb3RoZXIpeysrbGVhZGluZ196ZXJvfWVsc2V7c2Vlbl9vdGhlcj10cnVlfX12YXIgYnl0ZXM9bnVtLnRvQnl0ZUFycmF5VW5zaWduZWQoKTt3aGlsZShsZWFkaW5nX3plcm8tLT4wKXtieXRlcy51bnNoaWZ0KDApfXJldHVybiBuZXcgQnVmZmVyKGJ5dGVzKX1tb2R1bGUuZXhwb3J0cz17ZW5jb2RlOmVuY29kZSxkZWNvZGU6ZGVjb2RlfX0pLmNhbGwodGhpcyxfZGVyZXFfKFwiYnVmZmVyXCIpLkJ1ZmZlcil9LHtcIi4vanNibi9qc2JuXCI6NjMsYnVmZmVyOjV9XSw1NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKEJ1ZmZlcil7dmFyIGFzc2VydD1fZGVyZXFfKFwiYXNzZXJ0XCIpO3ZhciBiYXNlNTg9X2RlcmVxXyhcIi4vYmFzZTU4XCIpO3ZhciBjcnlwdG89X2RlcmVxXyhcImNyeXB0b1wiKTtmdW5jdGlvbiBzaGEyNTYoYnVmKXt2YXIgaGFzaD1jcnlwdG8uY3JlYXRlSGFzaChcInNoYTI1NlwiKTtoYXNoLnVwZGF0ZShidWYpO3JldHVybiBoYXNoLmRpZ2VzdCgpfWZ1bmN0aW9uIGVuY29kZShidWZmZXIsdmVyc2lvbil7dmVyc2lvbj12ZXJzaW9ufHwwO3ZhciB2ZXJzaW9uPW5ldyBCdWZmZXIoW3ZlcnNpb25dKTt2YXIgcGF5bG9hZD1uZXcgQnVmZmVyKGJ1ZmZlcik7dmFyIG1lc3NhZ2U9QnVmZmVyLmNvbmNhdChbdmVyc2lvbixwYXlsb2FkXSk7dmFyIGNoZWNrc3VtPXNoYTI1NihzaGEyNTYobWVzc2FnZSkpLnNsaWNlKDAsNCk7cmV0dXJuIGJhc2U1OC5lbmNvZGUoQnVmZmVyLmNvbmNhdChbbWVzc2FnZSxjaGVja3N1bV0pKX1mdW5jdGlvbiBkZWNvZGUoc3RyaW5nKXt2YXIgYnVmZmVyPWJhc2U1OC5kZWNvZGUoc3RyaW5nKTt2YXIgbWVzc2FnZT1idWZmZXIuc2xpY2UoMCwtNCk7dmFyIGNoZWNrc3VtPWJ1ZmZlci5zbGljZSgtNCk7dmFyIG5ld0NoZWNrc3VtPXNoYTI1NihzaGEyNTYobWVzc2FnZSkpLnNsaWNlKDAsNCk7YXNzZXJ0LmRlZXBFcXVhbChuZXdDaGVja3N1bSxjaGVja3N1bSk7dmFyIHZlcnNpb249bWVzc2FnZS5yZWFkVUludDgoMCk7dmFyIHBheWxvYWQ9bWVzc2FnZS5zbGljZSgxKTtyZXR1cm57dmVyc2lvbjp2ZXJzaW9uLHBheWxvYWQ6cGF5bG9hZCxjaGVja3N1bTpjaGVja3N1bX19bW9kdWxlLmV4cG9ydHM9e2VuY29kZTplbmNvZGUsZGVjb2RlOmRlY29kZX19KS5jYWxsKHRoaXMsX2RlcmVxXyhcImJ1ZmZlclwiKS5CdWZmZXIpfSx7XCIuL2Jhc2U1OFwiOjU1LGFzc2VydDoxLGJ1ZmZlcjo1LGNyeXB0bzo5fV0sNTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihCdWZmZXIpe3ZhciBDcnlwdG89X2RlcmVxXyhcImNyeXB0by1qc1wiKTt2YXIgV29yZEFycmF5PUNyeXB0by5saWIuV29yZEFycmF5O3ZhciBiYXNlNjRtYXA9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7ZnVuY3Rpb24gbHBhZChzdHIscGFkU3RyaW5nLGxlbmd0aCl7d2hpbGUoc3RyLmxlbmd0aDxsZW5ndGgpc3RyPXBhZFN0cmluZytzdHI7cmV0dXJuIHN0cn1mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKXtpZihCdWZmZXIuaXNCdWZmZXIoYnl0ZXMpKXtyZXR1cm4gYnl0ZXMudG9TdHJpbmcoXCJoZXhcIil9cmV0dXJuIGJ5dGVzLm1hcChmdW5jdGlvbih4KXtyZXR1cm4gbHBhZCh4LnRvU3RyaW5nKDE2KSxcIjBcIiwyKX0pLmpvaW4oXCJcIil9ZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpe3JldHVybiBoZXgubWF0Y2goLy4uL2cpLm1hcChmdW5jdGlvbih4KXtyZXR1cm4gcGFyc2VJbnQoeCwxNil9KX1mdW5jdGlvbiBieXRlc1RvQmFzZTY0KGJ5dGVzKXt2YXIgYmFzZTY0PVtdO2Zvcih2YXIgaT0wO2k8Ynl0ZXMubGVuZ3RoO2krPTMpe3ZhciB0cmlwbGV0PWJ5dGVzW2ldPDwxNnxieXRlc1tpKzFdPDw4fGJ5dGVzW2krMl07Zm9yKHZhciBqPTA7ajw0O2orKyl7aWYoaSo4K2oqNjw9Ynl0ZXMubGVuZ3RoKjgpe2Jhc2U2NC5wdXNoKGJhc2U2NG1hcC5jaGFyQXQodHJpcGxldD4+PjYqKDMtaikmNjMpKX1lbHNle2Jhc2U2NC5wdXNoKFwiPVwiKX19fXJldHVybiBiYXNlNjQuam9pbihcIlwiKX1mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKGJhc2U2NCl7YmFzZTY0PWJhc2U2NC5yZXBsYWNlKC9bXkEtWjAtOStcXC9dL2dpLFwiXCIpO3ZhciBieXRlcz1bXTt2YXIgaW1vZDQ9MDtmb3IodmFyIGk9MDtpPGJhc2U2NC5sZW5ndGg7aW1vZDQ9KytpJTQpe2lmKCFpbW9kNCljb250aW51ZTtieXRlcy5wdXNoKChiYXNlNjRtYXAuaW5kZXhPZihiYXNlNjQuY2hhckF0KGktMSkpJk1hdGgucG93KDIsLTIqaW1vZDQrOCktMSk8PGltb2Q0KjJ8YmFzZTY0bWFwLmluZGV4T2YoYmFzZTY0LmNoYXJBdChpKSk+Pj42LWltb2Q0KjIpfXJldHVybiBieXRlc31mdW5jdGlvbiBjb2VyY2VUb0J5dGVzKGlucHV0KXtpZih0eXBlb2YgaW5wdXQhPVwic3RyaW5nXCIpcmV0dXJuIGlucHV0O3JldHVybiBoZXhUb0J5dGVzKGlucHV0KX1mdW5jdGlvbiBiaW5Ub0J5dGVzKGJpbil7cmV0dXJuIGJpbi5tYXRjaCgvLi4uLi4uLi4vZykubWFwKGZ1bmN0aW9uKHgpe3JldHVybiBwYXJzZUludCh4LDIpfSl9ZnVuY3Rpb24gYnl0ZXNUb0JpbihieXRlcyl7cmV0dXJuIGJ5dGVzLm1hcChmdW5jdGlvbih4KXtyZXR1cm4gbHBhZCh4LnRvU3RyaW5nKDIpLFwiMFwiLDgpfSkuam9pbihcIlwiKX1mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKXtyZXR1cm4gYnl0ZXMubWFwKGZ1bmN0aW9uKHgpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpfSkuam9pbihcIlwiKX1mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cmluZyl7cmV0dXJuIHN0cmluZy5zcGxpdChcIlwiKS5tYXAoZnVuY3Rpb24oeCl7cmV0dXJuIHguY2hhckNvZGVBdCgwKX0pfWZ1bmN0aW9uIG51bVRvQnl0ZXMobnVtLGJ5dGVzKXtpZihieXRlcz09PXVuZGVmaW5lZClieXRlcz04O2lmKGJ5dGVzPT09MClyZXR1cm5bXTtyZXR1cm5bbnVtJTI1Nl0uY29uY2F0KG51bVRvQnl0ZXMoTWF0aC5mbG9vcihudW0vMjU2KSxieXRlcy0xKSl9ZnVuY3Rpb24gYnl0ZXNUb051bShieXRlcyl7aWYoYnl0ZXMubGVuZ3RoPT09MClyZXR1cm4gMDtyZXR1cm4gYnl0ZXNbMF0rMjU2KmJ5dGVzVG9OdW0oYnl0ZXMuc2xpY2UoMSkpfWZ1bmN0aW9uIG51bVRvVmFySW50KG51bSl7aWYobnVtPDI1MylyZXR1cm5bbnVtXTtpZihudW08NjU1MzYpcmV0dXJuWzI1M10uY29uY2F0KG51bVRvQnl0ZXMobnVtLDIpKTtpZihudW08NDI5NDk2NzI5NilyZXR1cm5bMjU0XS5jb25jYXQobnVtVG9CeXRlcyhudW0sNCkpO3JldHVyblsyNTVdLmNvbmNhdChudW1Ub0J5dGVzKG51bSw4KSl9ZnVuY3Rpb24gdmFySW50VG9OdW0oYnl0ZXMpe3ZhciBwcmVmaXg9Ynl0ZXNbMF07dmFyIHZpQnl0ZXM9cHJlZml4PDI1Mz9ieXRlcy5zbGljZSgwLDEpOnByZWZpeD09PTI1Mz9ieXRlcy5zbGljZSgxLDMpOnByZWZpeD09PTI1ND9ieXRlcy5zbGljZSgxLDUpOmJ5dGVzLnNsaWNlKDEsOSk7cmV0dXJue2J5dGVzOnByZWZpeDwyNTM/dmlCeXRlczpieXRlcy5zbGljZSgwLHZpQnl0ZXMubGVuZ3RoKzEpLG51bWJlcjpieXRlc1RvTnVtKHZpQnl0ZXMpfX1mdW5jdGlvbiBieXRlc1RvV29yZHMoYnl0ZXMpe3ZhciB3b3Jkcz1bXTtmb3IodmFyIGk9MCxiPTA7aTxieXRlcy5sZW5ndGg7aSsrLGIrPTgpe3dvcmRzW2I+Pj41XXw9Ynl0ZXNbaV08PDI0LWIlMzJ9cmV0dXJuIHdvcmRzfWZ1bmN0aW9uIHdvcmRzVG9CeXRlcyh3b3Jkcyl7dmFyIGJ5dGVzPVtdO2Zvcih2YXIgYj0wO2I8d29yZHMubGVuZ3RoKjMyO2IrPTgpe2J5dGVzLnB1c2god29yZHNbYj4+PjVdPj4+MjQtYiUzMiYyNTUpfXJldHVybiBieXRlc31mdW5jdGlvbiBieXRlc1RvV29yZEFycmF5KGJ5dGVzKXtyZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KGJ5dGVzVG9Xb3JkcyhieXRlcyksYnl0ZXMubGVuZ3RoKX1mdW5jdGlvbiB3b3JkQXJyYXlUb0J5dGVzKHdvcmRBcnJheSl7cmV0dXJuIHdvcmRzVG9CeXRlcyh3b3JkQXJyYXkud29yZHMpfWZ1bmN0aW9uIHJldmVyc2VFbmRpYW4oaGV4KXtyZXR1cm4gYnl0ZXNUb0hleChoZXhUb0J5dGVzKGhleCkucmV2ZXJzZSgpKX1tb2R1bGUuZXhwb3J0cz17bHBhZDpscGFkLGJ5dGVzVG9IZXg6Ynl0ZXNUb0hleCxoZXhUb0J5dGVzOmhleFRvQnl0ZXMsYnl0ZXNUb0Jhc2U2NDpieXRlc1RvQmFzZTY0LGJhc2U2NFRvQnl0ZXM6YmFzZTY0VG9CeXRlcyxjb2VyY2VUb0J5dGVzOmNvZXJjZVRvQnl0ZXMsYmluVG9CeXRlczpiaW5Ub0J5dGVzLGJ5dGVzVG9CaW46Ynl0ZXNUb0JpbixieXRlc1RvU3RyaW5nOmJ5dGVzVG9TdHJpbmcsc3RyaW5nVG9CeXRlczpzdHJpbmdUb0J5dGVzLG51bVRvQnl0ZXM6bnVtVG9CeXRlcyxieXRlc1RvTnVtOmJ5dGVzVG9OdW0sbnVtVG9WYXJJbnQ6bnVtVG9WYXJJbnQsdmFySW50VG9OdW06dmFySW50VG9OdW0sYnl0ZXNUb1dvcmRzOmJ5dGVzVG9Xb3Jkcyx3b3Jkc1RvQnl0ZXM6d29yZHNUb0J5dGVzLGJ5dGVzVG9Xb3JkQXJyYXk6Ynl0ZXNUb1dvcmRBcnJheSx3b3JkQXJyYXlUb0J5dGVzOndvcmRBcnJheVRvQnl0ZXMscmV2ZXJzZUVuZGlhbjpyZXZlcnNlRW5kaWFufX0pLmNhbGwodGhpcyxfZGVyZXFfKFwiYnVmZmVyXCIpLkJ1ZmZlcil9LHtidWZmZXI6NSxcImNyeXB0by1qc1wiOjI3fV0sNTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBzZWM9X2RlcmVxXyhcIi4vanNibi9zZWNcIik7dmFyIHJuZz1fZGVyZXFfKFwic2VjdXJlLXJhbmRvbVwiKTt2YXIgQmlnSW50ZWdlcj1fZGVyZXFfKFwiLi9qc2JuL2pzYm5cIik7dmFyIGNvbnZlcnQ9X2RlcmVxXyhcIi4vY29udmVydFwiKTt2YXIgSG1hY1NIQTI1Nj1fZGVyZXFfKFwiY3J5cHRvLWpzL2htYWMtc2hhMjU2XCIpO3ZhciBFQ1BvaW50RnA9X2RlcmVxXyhcIi4vanNibi9lY1wiKS5FQ1BvaW50RnA7dmFyIGVjcGFyYW1zPXNlYyhcInNlY3AyNTZrMVwiKTt2YXIgUF9PVkVSX0ZPVVI9bnVsbDtmdW5jdGlvbiBpbXBsU2hhbWlyc1RyaWNrKFAsayxRLGwpe3ZhciBtPU1hdGgubWF4KGsuYml0TGVuZ3RoKCksbC5iaXRMZW5ndGgoKSk7dmFyIFo9UC5hZGQyRChRKTt2YXIgUj1QLmN1cnZlLmdldEluZmluaXR5KCk7Zm9yKHZhciBpPW0tMTtpPj0wOy0taSl7Uj1SLnR3aWNlMkQoKTtSLno9QmlnSW50ZWdlci5PTkU7aWYoay50ZXN0Qml0KGkpKXtpZihsLnRlc3RCaXQoaSkpe1I9Ui5hZGQyRChaKX1lbHNle1I9Ui5hZGQyRChQKX19ZWxzZXtpZihsLnRlc3RCaXQoaSkpe1I9Ui5hZGQyRChRKX19fXJldHVybiBSfWZ1bmN0aW9uIGRldGVybWluaXN0aWNHZW5lcmF0ZUsoaGFzaCxrZXkpe3ZhciB2QXJyPVtdO3ZhciBrQXJyPVtdO2Zvcih2YXIgaT0wO2k8MzI7aSsrKXZBcnIucHVzaCgxKTtmb3IodmFyIGk9MDtpPDMyO2krKylrQXJyLnB1c2goMCk7dmFyIHY9Y29udmVydC5ieXRlc1RvV29yZEFycmF5KHZBcnIpO3ZhciBrPWNvbnZlcnQuYnl0ZXNUb1dvcmRBcnJheShrQXJyKTtrPUhtYWNTSEEyNTYoY29udmVydC5ieXRlc1RvV29yZEFycmF5KHZBcnIuY29uY2F0KFswXSkuY29uY2F0KGtleSkuY29uY2F0KGhhc2gpKSxrKTt2PUhtYWNTSEEyNTYodixrKTt2QXJyPWNvbnZlcnQud29yZEFycmF5VG9CeXRlcyh2KTtrPUhtYWNTSEEyNTYoY29udmVydC5ieXRlc1RvV29yZEFycmF5KHZBcnIuY29uY2F0KFsxXSkuY29uY2F0KGtleSkuY29uY2F0KGhhc2gpKSxrKTt2PUhtYWNTSEEyNTYodixrKTt2PUhtYWNTSEEyNTYodixrKTt2QXJyPWNvbnZlcnQud29yZEFycmF5VG9CeXRlcyh2KTtyZXR1cm4gQmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQodkFycil9dmFyIEVDRFNBPXtnZXRCaWdSYW5kb206ZnVuY3Rpb24obGltaXQpe3JldHVybiBuZXcgQmlnSW50ZWdlcihsaW1pdC5iaXRMZW5ndGgoKSxybmcpLm1vZChsaW1pdC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkpLmFkZChCaWdJbnRlZ2VyLk9ORSl9LHNpZ246ZnVuY3Rpb24oaGFzaCxwcml2KXt2YXIgZD1wcml2O3ZhciBuPWVjcGFyYW1zLmdldE4oKTt2YXIgZT1CaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZChoYXNoKTt2YXIgaz1kZXRlcm1pbmlzdGljR2VuZXJhdGVLKGhhc2gscHJpdi50b0J5dGVBcnJheVVuc2lnbmVkKCkpO3ZhciBHPWVjcGFyYW1zLmdldEcoKTt2YXIgUT1HLm11bHRpcGx5KGspO3ZhciByPVEuZ2V0WCgpLnRvQmlnSW50ZWdlcigpLm1vZChuKTt2YXIgcz1rLm1vZEludmVyc2UobikubXVsdGlwbHkoZS5hZGQoZC5tdWx0aXBseShyKSkpLm1vZChuKTtyZXR1cm4gRUNEU0Euc2VyaWFsaXplU2lnKHIscyl9LHZlcmlmeTpmdW5jdGlvbihoYXNoLHNpZyxwdWJrZXkpe3ZhciByLHM7aWYoQXJyYXkuaXNBcnJheShzaWcpKXt2YXIgb2JqPUVDRFNBLnBhcnNlU2lnKHNpZyk7cj1vYmoucjtzPW9iai5zfWVsc2UgaWYoXCJvYmplY3RcIj09PXR5cGVvZiBzaWcmJnNpZy5yJiZzaWcucyl7cj1zaWcucjtzPXNpZy5zfWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3Igc2lnbmF0dXJlXCIpfXZhciBRO2lmKHB1YmtleSBpbnN0YW5jZW9mIEVDUG9pbnRGcCl7UT1wdWJrZXl9ZWxzZSBpZihBcnJheS5pc0FycmF5KHB1YmtleSkpe1E9RUNQb2ludEZwLmRlY29kZUZyb20oZWNwYXJhbXMuZ2V0Q3VydmUoKSxwdWJrZXkpfWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBmb3JtYXQgZm9yIHB1YmtleSB2YWx1ZSwgbXVzdCBiZSBieXRlIGFycmF5IG9yIEVDUG9pbnRGcFwiKX12YXIgZT1CaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZChoYXNoKTtyZXR1cm4gRUNEU0EudmVyaWZ5UmF3KGUscixzLFEpfSx2ZXJpZnlSYXc6ZnVuY3Rpb24oZSxyLHMsUSl7dmFyIG49ZWNwYXJhbXMuZ2V0TigpO3ZhciBHPWVjcGFyYW1zLmdldEcoKTtpZihyLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSk8MHx8ci5jb21wYXJlVG8obik+PTApe3JldHVybiBmYWxzZX1pZihzLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSk8MHx8cy5jb21wYXJlVG8obik+PTApe3JldHVybiBmYWxzZX12YXIgYz1zLm1vZEludmVyc2Uobik7dmFyIHUxPWUubXVsdGlwbHkoYykubW9kKG4pO3ZhciB1Mj1yLm11bHRpcGx5KGMpLm1vZChuKTt2YXIgcG9pbnQ9Ry5tdWx0aXBseSh1MSkuYWRkKFEubXVsdGlwbHkodTIpKTt2YXIgdj1wb2ludC5nZXRYKCkudG9CaWdJbnRlZ2VyKCkubW9kKG4pO3JldHVybiB2LmVxdWFscyhyKX0sc2VyaWFsaXplU2lnOmZ1bmN0aW9uKHIscyl7dmFyIHJCYT1yLnRvQnl0ZUFycmF5U2lnbmVkKCk7dmFyIHNCYT1zLnRvQnl0ZUFycmF5U2lnbmVkKCk7dmFyIHNlcXVlbmNlPVtdO3NlcXVlbmNlLnB1c2goMik7c2VxdWVuY2UucHVzaChyQmEubGVuZ3RoKTtzZXF1ZW5jZT1zZXF1ZW5jZS5jb25jYXQockJhKTtzZXF1ZW5jZS5wdXNoKDIpO3NlcXVlbmNlLnB1c2goc0JhLmxlbmd0aCk7c2VxdWVuY2U9c2VxdWVuY2UuY29uY2F0KHNCYSk7c2VxdWVuY2UudW5zaGlmdChzZXF1ZW5jZS5sZW5ndGgpO3NlcXVlbmNlLnVuc2hpZnQoNDgpO3JldHVybiBzZXF1ZW5jZX0scGFyc2VTaWc6ZnVuY3Rpb24oc2lnKXt2YXIgY3Vyc29yO2lmKHNpZ1swXSE9NDgpe3Rocm93IG5ldyBFcnJvcihcIlNpZ25hdHVyZSBub3QgYSB2YWxpZCBERVJTZXF1ZW5jZVwiKX1jdXJzb3I9MjtpZihzaWdbY3Vyc29yXSE9Mil7dGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgZWxlbWVudCBpbiBzaWduYXR1cmUgbXVzdCBiZSBhIERFUkludGVnZXJcIil9dmFyIHJCYT1zaWcuc2xpY2UoY3Vyc29yKzIsY3Vyc29yKzIrc2lnW2N1cnNvcisxXSk7Y3Vyc29yKz0yK3NpZ1tjdXJzb3IrMV07aWYoc2lnW2N1cnNvcl0hPTIpe3Rocm93IG5ldyBFcnJvcihcIlNlY29uZCBlbGVtZW50IGluIHNpZ25hdHVyZSBtdXN0IGJlIGEgREVSSW50ZWdlclwiKX12YXIgc0JhPXNpZy5zbGljZShjdXJzb3IrMixjdXJzb3IrMitzaWdbY3Vyc29yKzFdKTtjdXJzb3IrPTIrc2lnW2N1cnNvcisxXTt2YXIgcj1CaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZChyQmEpO3ZhciBzPUJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKHNCYSk7cmV0dXJue3I6cixzOnN9fSxwYXJzZVNpZ0NvbXBhY3Q6ZnVuY3Rpb24oc2lnKXtpZihzaWcubGVuZ3RoIT09NjUpe3Rocm93IG5ldyBFcnJvcihcIlNpZ25hdHVyZSBoYXMgdGhlIHdyb25nIGxlbmd0aFwiKX12YXIgaT1zaWdbMF0tMjc7aWYoaTwwfHxpPjcpe3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmF0dXJlIHR5cGVcIil9dmFyIG49ZWNwYXJhbXMuZ2V0TigpO3ZhciByPUJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKHNpZy5zbGljZSgxLDMzKSkubW9kKG4pO3ZhciBzPUJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKHNpZy5zbGljZSgzMyw2NSkpLm1vZChuKTtyZXR1cm57cjpyLHM6cyxpOml9fSxyZWNvdmVyUHViS2V5OmZ1bmN0aW9uKHIscyxoYXNoLGkpe2k9aSYzO3ZhciBpc1lFdmVuPWkmMTt2YXIgaXNTZWNvbmRLZXk9aT4+MTt2YXIgbj1lY3BhcmFtcy5nZXROKCk7dmFyIEc9ZWNwYXJhbXMuZ2V0RygpO3ZhciBjdXJ2ZT1lY3BhcmFtcy5nZXRDdXJ2ZSgpO3ZhciBwPWN1cnZlLmdldFEoKTt2YXIgYT1jdXJ2ZS5nZXRBKCkudG9CaWdJbnRlZ2VyKCk7dmFyIGI9Y3VydmUuZ2V0QigpLnRvQmlnSW50ZWdlcigpO2lmKCFQX09WRVJfRk9VUil7UF9PVkVSX0ZPVVI9cC5hZGQoQmlnSW50ZWdlci5PTkUpLmRpdmlkZShCaWdJbnRlZ2VyLnZhbHVlT2YoNCkpfXZhciB4PWlzU2Vjb25kS2V5P3IuYWRkKG4pOnI7dmFyIGFscGhhPXgubXVsdGlwbHkoeCkubXVsdGlwbHkoeCkuYWRkKGEubXVsdGlwbHkoeCkpLmFkZChiKS5tb2QocCk7dmFyIGJldGE9YWxwaGEubW9kUG93KFBfT1ZFUl9GT1VSLHApO3ZhciB5PShiZXRhLmlzRXZlbigpPyFpc1lFdmVuOmlzWUV2ZW4pP2JldGE6cC5zdWJ0cmFjdChiZXRhKTt2YXIgUj1uZXcgRUNQb2ludEZwKGN1cnZlLGN1cnZlLmZyb21CaWdJbnRlZ2VyKHgpLGN1cnZlLmZyb21CaWdJbnRlZ2VyKHkpKTtSLnZhbGlkYXRlKCk7dmFyIGU9QmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQoaGFzaCk7dmFyIGVOZWc9QmlnSW50ZWdlci5aRVJPLnN1YnRyYWN0KGUpLm1vZChuKTt2YXIgckludj1yLm1vZEludmVyc2Uobik7dmFyIFE9aW1wbFNoYW1pcnNUcmljayhSLHMsRyxlTmVnKS5tdWx0aXBseShySW52KTtRLnZhbGlkYXRlKCk7aWYoIUVDRFNBLnZlcmlmeVJhdyhlLHIscyxRKSl7dGhyb3cgbmV3IEVycm9yKFwiUHVia2V5IHJlY292ZXJ5IHVuc3VjY2Vzc2Z1bFwiKX1yZXR1cm4gUX0sY2FsY1B1YktleVJlY292ZXJ5UGFyYW06ZnVuY3Rpb24ob3JpZ1B1YktleSxyLHMsaGFzaCl7Zm9yKHZhciBpPTA7aTw0O2krKyl7dmFyIHB1YktleT1FQ0RTQS5yZWNvdmVyUHViS2V5KHIscyxoYXNoLGkpO2lmKHB1YktleS5lcXVhbHMob3JpZ1B1YktleSkpe3JldHVybiBpfX10aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCB2YWxpZCByZWNvdmVyeSBmYWN0b3JcIil9fTttb2R1bGUuZXhwb3J0cz1FQ0RTQX0se1wiLi9jb252ZXJ0XCI6NTcsXCIuL2pzYm4vZWNcIjo2MixcIi4vanNibi9qc2JuXCI6NjMsXCIuL2pzYm4vc2VjXCI6NjQsXCJjcnlwdG8tanMvaG1hYy1zaGEyNTZcIjoyNSxcInNlY3VyZS1yYW5kb21cIjo1M31dLDU5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgQWRkcmVzcz1fZGVyZXFfKFwiLi9hZGRyZXNzXCIpO3ZhciBhc3NlcnQ9X2RlcmVxXyhcImFzc2VydFwiKTt2YXIgY29udmVydD1fZGVyZXFfKFwiLi9jb252ZXJ0XCIpO3ZhciBiYXNlNThjaGVjaz1fZGVyZXFfKFwiLi9iYXNlNThjaGVja1wiKTt2YXIgQmlnSW50ZWdlcj1fZGVyZXFfKFwiLi9qc2JuL2pzYm5cIik7dmFyIGVjZHNhPV9kZXJlcV8oXCIuL2VjZHNhXCIpO3ZhciBFQ1BvaW50RnA9X2RlcmVxXyhcIi4vanNibi9lY1wiKS5FQ1BvaW50RnA7dmFyIHNlYz1fZGVyZXFfKFwiLi9qc2JuL3NlY1wiKTt2YXIgTmV0d29yaz1fZGVyZXFfKFwiLi9uZXR3b3JrXCIpO3ZhciB1dGlsPV9kZXJlcV8oXCIuL3V0aWxcIik7dmFyIGVjcGFyYW1zPXNlYyhcInNlY3AyNTZrMVwiKTt2YXIgRUNLZXk9ZnVuY3Rpb24oaW5wdXQsY29tcHJlc3NlZCl7aWYoISh0aGlzIGluc3RhbmNlb2YgRUNLZXkpKXtyZXR1cm4gbmV3IEVDS2V5KGlucHV0LGNvbXByZXNzZWQpfWlmKCFpbnB1dCl7dmFyIG49ZWNwYXJhbXMuZ2V0TigpO3RoaXMucHJpdj1lY2RzYS5nZXRCaWdSYW5kb20obik7dGhpcy5jb21wcmVzc2VkPWNvbXByZXNzZWR8fGZhbHNlfWVsc2UgdGhpcy5pbXBvcnQoaW5wdXQsY29tcHJlc3NlZCl9O0VDS2V5LnByb3RvdHlwZS5pbXBvcnQ9ZnVuY3Rpb24oaW5wdXQsY29tcHJlc3NlZCl7ZnVuY3Rpb24gaGFzKGxpLHYpe3JldHVybiBsaS5pbmRleE9mKHYpPj0wfWZ1bmN0aW9uIGZyb21CaW4oeCl7cmV0dXJuIEJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKHgpfXRoaXMucHJpdj1pbnB1dCBpbnN0YW5jZW9mIEVDS2V5P2lucHV0LnByaXY6aW5wdXQgaW5zdGFuY2VvZiBCaWdJbnRlZ2VyP2lucHV0Lm1vZChlY3BhcmFtcy5nZXROKCkpOkFycmF5LmlzQXJyYXkoaW5wdXQpP2Zyb21CaW4oaW5wdXQuc2xpY2UoMCwzMikpOnR5cGVvZiBpbnB1dCE9XCJzdHJpbmdcIj9udWxsOmlucHV0Lmxlbmd0aD09NDQ/ZnJvbUJpbihjb252ZXJ0LmJhc2U2NFRvQnl0ZXMoaW5wdXQpKTppbnB1dC5sZW5ndGg9PTUxJiZpbnB1dFswXT09XCI1XCI/ZnJvbUJpbihiYXNlNThjaGVjay5kZWNvZGUoaW5wdXQpLnBheWxvYWQpOmlucHV0Lmxlbmd0aD09NTEmJmlucHV0WzBdPT1cIjlcIj9mcm9tQmluKGJhc2U1OGNoZWNrLmRlY29kZShpbnB1dCkucGF5bG9hZCk6aW5wdXQubGVuZ3RoPT01MiYmaGFzKFwiTEtcIixpbnB1dFswXSk/ZnJvbUJpbihiYXNlNThjaGVjay5kZWNvZGUoaW5wdXQpLnBheWxvYWQuc2xpY2UoMCwzMikpOmlucHV0Lmxlbmd0aD09NTImJmlucHV0WzBdPT1cImNcIj9mcm9tQmluKGJhc2U1OGNoZWNrLmRlY29kZShpbnB1dCkucGF5bG9hZC5zbGljZSgwLDMyKSk6aGFzKFs2NCw2NV0saW5wdXQubGVuZ3RoKT9mcm9tQmluKGNvbnZlcnQuaGV4VG9CeXRlcyhpbnB1dC5zbGljZSgwLDY0KSkpOm51bGw7YXNzZXJ0KHRoaXMucHJpdiE9PW51bGwpO3RoaXMuY29tcHJlc3NlZD1jb21wcmVzc2VkIT09dW5kZWZpbmVkP2NvbXByZXNzZWQ6aW5wdXQgaW5zdGFuY2VvZiBFQ0tleT9pbnB1dC5jb21wcmVzc2VkOmlucHV0IGluc3RhbmNlb2YgQmlnSW50ZWdlcj9mYWxzZTpBcnJheS5pc0FycmF5KGlucHV0KT9mYWxzZTp0eXBlb2YgaW5wdXQhPVwic3RyaW5nXCI/bnVsbDppbnB1dC5sZW5ndGg9PTQ0P2ZhbHNlOmlucHV0Lmxlbmd0aD09NTEmJmlucHV0WzBdPT1cIjVcIj9mYWxzZTppbnB1dC5sZW5ndGg9PTUxJiZpbnB1dFswXT09XCI5XCI/ZmFsc2U6aW5wdXQubGVuZ3RoPT01MiYmaGFzKFwiTEtcIixpbnB1dFswXSk/dHJ1ZTppbnB1dC5sZW5ndGg9PTUyJiZpbnB1dFswXT09XCJjXCI/dHJ1ZTppbnB1dC5sZW5ndGg9PTY0P2ZhbHNlOmlucHV0Lmxlbmd0aD09NjU/dHJ1ZTpudWxsO2Fzc2VydCh0aGlzLmNvbXByZXNzZWQhPT1udWxsKX07RUNLZXkucHJvdG90eXBlLmdldFB1Yj1mdW5jdGlvbihjb21wcmVzc2VkKXtpZihjb21wcmVzc2VkPT09dW5kZWZpbmVkKWNvbXByZXNzZWQ9dGhpcy5jb21wcmVzc2VkO3JldHVybiBFQ1B1YktleShlY3BhcmFtcy5nZXRHKCkubXVsdGlwbHkodGhpcy5wcml2KSxjb21wcmVzc2VkKX07RUNLZXkucHJvdG90eXBlLnRvQmluPWZ1bmN0aW9uKCl7cmV0dXJuIGNvbnZlcnQuYnl0ZXNUb1N0cmluZyh0aGlzLnRvQnl0ZXMoKSl9O0VDS2V5LnZlcnNpb25fYnl0ZXM9ezA6MTI4LDExMToyMzl9O0VDS2V5LnByb3RvdHlwZS50b1dpZj1mdW5jdGlvbih2ZXJzaW9uKXt2ZXJzaW9uPXZlcnNpb258fE5ldHdvcmsubWFpbm5ldC5hZGRyZXNzVmVyc2lvbjtyZXR1cm4gYmFzZTU4Y2hlY2suZW5jb2RlKHRoaXMudG9CeXRlcygpLEVDS2V5LnZlcnNpb25fYnl0ZXNbdmVyc2lvbl0pfTtFQ0tleS5wcm90b3R5cGUudG9IZXg9ZnVuY3Rpb24oKXtyZXR1cm4gY29udmVydC5ieXRlc1RvSGV4KHRoaXMudG9CeXRlcygpKX07RUNLZXkucHJvdG90eXBlLnRvQnl0ZXM9ZnVuY3Rpb24oKXt2YXIgYnl0ZXM9dGhpcy5wcml2LnRvQnl0ZUFycmF5VW5zaWduZWQoKTtpZih0aGlzLmNvbXByZXNzZWQpYnl0ZXMucHVzaCgxKTtyZXR1cm4gYnl0ZXN9O0VDS2V5LnByb3RvdHlwZS50b0Jhc2U2ND1mdW5jdGlvbigpe3JldHVybiBjb252ZXJ0LmJ5dGVzVG9CYXNlNjQodGhpcy50b0J5dGVzKCkpfTtFQ0tleS5wcm90b3R5cGUudG9TdHJpbmc9RUNLZXkucHJvdG90eXBlLnRvSGV4O0VDS2V5LnByb3RvdHlwZS5nZXRBZGRyZXNzPWZ1bmN0aW9uKHZlcnNpb24pe3JldHVybiB0aGlzLmdldFB1YigpLmdldEFkZHJlc3ModmVyc2lvbil9O0VDS2V5LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oa2V5KXtyZXR1cm4gRUNLZXkodGhpcy5wcml2LmFkZChFQ0tleShrZXkpLnByaXYpLHRoaXMuY29tcHJlc3NlZCl9O0VDS2V5LnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbihrZXkpe3JldHVybiBFQ0tleSh0aGlzLnByaXYubXVsdGlwbHkoRUNLZXkoa2V5KS5wcml2KSx0aGlzLmNvbXByZXNzZWQpfTtFQ0tleS5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbihoYXNoKXtyZXR1cm4gZWNkc2Euc2lnbihoYXNoLHRoaXMucHJpdil9O0VDS2V5LnByb3RvdHlwZS52ZXJpZnk9ZnVuY3Rpb24oaGFzaCxzaWcpe3JldHVybiB0aGlzLmdldFB1YigpLnZlcmlmeShoYXNoLHNpZyl9O3ZhciBFQ1B1YktleT1mdW5jdGlvbihpbnB1dCxjb21wcmVzc2VkKXtpZighKHRoaXMgaW5zdGFuY2VvZiBFQ1B1YktleSkpe3JldHVybiBuZXcgRUNQdWJLZXkoaW5wdXQsY29tcHJlc3NlZCl9dGhpcy5pbXBvcnQoaW5wdXQsY29tcHJlc3NlZCl9O0VDUHViS2V5LnByb3RvdHlwZS5pbXBvcnQ9ZnVuY3Rpb24oaW5wdXQsY29tcHJlc3NlZCl7dmFyIGRlY29kZT1mdW5jdGlvbih4KXtyZXR1cm4gRUNQb2ludEZwLmRlY29kZUZyb20oZWNwYXJhbXMuZ2V0Q3VydmUoKSx4KX07dGhpcy5wdWI9aW5wdXQgaW5zdGFuY2VvZiBFQ1BvaW50RnA/aW5wdXQ6aW5wdXQgaW5zdGFuY2VvZiBFQ0tleT9lY3BhcmFtcy5nZXRHKCkubXVsdGlwbHkoaW5wdXQucHJpdik6aW5wdXQgaW5zdGFuY2VvZiBFQ1B1YktleT9pbnB1dC5wdWI6dHlwZW9mIGlucHV0PT1cInN0cmluZ1wiP2RlY29kZShjb252ZXJ0LmhleFRvQnl0ZXMoaW5wdXQpKTpBcnJheS5pc0FycmF5KGlucHV0KT9kZWNvZGUoaW5wdXQpOm51bGw7YXNzZXJ0KHRoaXMucHViIT09bnVsbCk7dGhpcy5jb21wcmVzc2VkPWNvbXByZXNzZWQ/Y29tcHJlc3NlZDppbnB1dCBpbnN0YW5jZW9mIEVDUG9pbnRGcD9pbnB1dC5jb21wcmVzc2VkOmlucHV0IGluc3RhbmNlb2YgRUNQdWJLZXk/aW5wdXQuY29tcHJlc3NlZDp0aGlzLnB1YlswXTw0fTtFQ1B1YktleS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGtleSl7cmV0dXJuIEVDUHViS2V5KHRoaXMucHViLmFkZChFQ1B1YktleShrZXkpLnB1YiksdGhpcy5jb21wcmVzc2VkKX07RUNQdWJLZXkucHJvdG90eXBlLm11bHRpcGx5PWZ1bmN0aW9uKGtleSl7cmV0dXJuIEVDUHViS2V5KHRoaXMucHViLm11bHRpcGx5KEVDS2V5KGtleSkucHJpdiksdGhpcy5jb21wcmVzc2VkKX07RUNQdWJLZXkucHJvdG90eXBlLnRvQnl0ZXM9ZnVuY3Rpb24oY29tcHJlc3NlZCl7aWYoY29tcHJlc3NlZD09PXVuZGVmaW5lZCljb21wcmVzc2VkPXRoaXMuY29tcHJlc3NlZDtyZXR1cm4gdGhpcy5wdWIuZ2V0RW5jb2RlZChjb21wcmVzc2VkKX07RUNQdWJLZXkucHJvdG90eXBlLnRvSGV4PWZ1bmN0aW9uKGNvbXByZXNzZWQpe3JldHVybiBjb252ZXJ0LmJ5dGVzVG9IZXgodGhpcy50b0J5dGVzKGNvbXByZXNzZWQpKX07RUNQdWJLZXkucHJvdG90eXBlLnRvQmluPWZ1bmN0aW9uKGNvbXByZXNzZWQpe3JldHVybiBjb252ZXJ0LmJ5dGVzVG9TdHJpbmcodGhpcy50b0J5dGVzKGNvbXByZXNzZWQpKX07RUNQdWJLZXkucHJvdG90eXBlLnRvV2lmPWZ1bmN0aW9uKHZlcnNpb24pe3ZlcnNpb249dmVyc2lvbnx8TmV0d29yay5tYWlubmV0LmFkZHJlc3NWZXJzaW9uO3JldHVybiBiYXNlNThjaGVjay5lbmNvZGUodGhpcy50b0J5dGVzKCksdmVyc2lvbil9O0VDUHViS2V5LnByb3RvdHlwZS50b1N0cmluZz1FQ1B1YktleS5wcm90b3R5cGUudG9IZXg7RUNQdWJLZXkucHJvdG90eXBlLmdldEFkZHJlc3M9ZnVuY3Rpb24odmVyc2lvbil7dmVyc2lvbj12ZXJzaW9ufHxOZXR3b3JrLm1haW5uZXQuYWRkcmVzc1ZlcnNpb247cmV0dXJuIG5ldyBBZGRyZXNzKHV0aWwuc2hhMjU2cmlwZTE2MCh0aGlzLnRvQnl0ZXMoKSksdmVyc2lvbil9O0VDUHViS2V5LnByb3RvdHlwZS52ZXJpZnk9ZnVuY3Rpb24oaGFzaCxzaWcpe3JldHVybiBlY2RzYS52ZXJpZnkoaGFzaCxzaWcsdGhpcy50b0J5dGVzKCkpfTttb2R1bGUuZXhwb3J0cz17RUNLZXk6RUNLZXksRUNQdWJLZXk6RUNQdWJLZXl9fSx7XCIuL2FkZHJlc3NcIjo1NCxcIi4vYmFzZTU4Y2hlY2tcIjo1NixcIi4vY29udmVydFwiOjU3LFwiLi9lY2RzYVwiOjU4LFwiLi9qc2JuL2VjXCI6NjIsXCIuL2pzYm4vanNiblwiOjYzLFwiLi9qc2JuL3NlY1wiOjY0LFwiLi9uZXR3b3JrXCI6NjYsXCIuL3V0aWxcIjo3MCxhc3NlcnQ6MX1dLDYwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oQnVmZmVyKXt2YXIgY29udmVydD1fZGVyZXFfKFwiLi9jb252ZXJ0LmpzXCIpO3ZhciBiYXNlNTg9X2RlcmVxXyhcIi4vYmFzZTU4LmpzXCIpO3ZhciBhc3NlcnQ9X2RlcmVxXyhcImFzc2VydFwiKTt2YXIgZm9ybWF0PV9kZXJlcV8oXCJ1dGlsXCIpLmZvcm1hdDt2YXIgdXRpbD1fZGVyZXFfKFwiLi91dGlsLmpzXCIpO3ZhciBDcnlwdG89X2RlcmVxXyhcImNyeXB0by1qc1wiKTt2YXIgSG1hY1NIQTUxMj1DcnlwdG8uSG1hY1NIQTUxMjt2YXIgSE1BQz1DcnlwdG8uYWxnby5ITUFDO3ZhciBFQ0tleT1fZGVyZXFfKFwiLi9lY2tleS5qc1wiKS5FQ0tleTt2YXIgRUNQdWJLZXk9X2RlcmVxXyhcIi4vZWNrZXkuanNcIikuRUNQdWJLZXk7dmFyIEFkZHJlc3M9X2RlcmVxXyhcIi4vYWRkcmVzcy5qc1wiKTt2YXIgTmV0d29yaz1fZGVyZXFfKFwiLi9uZXR3b3JrXCIpO3ZhciBjcnlwdG89X2RlcmVxXyhcImNyeXB0b1wiKTtmdW5jdGlvbiBzaGEyNTYoYnVmKXt2YXIgaGFzaD1jcnlwdG8uY3JlYXRlSGFzaChcInNoYTI1NlwiKTtoYXNoLnVwZGF0ZShidWYpO3JldHVybiBoYXNoLmRpZ2VzdCgpfWZ1bmN0aW9uIEhEV2FsbGV0KHNlZWQsbmV0d29yayl7aWYoc2VlZD09PXVuZGVmaW5lZClyZXR1cm47dmFyIHNlZWRXb3Jkcz1jb252ZXJ0LmJ5dGVzVG9Xb3JkQXJyYXkoc2VlZCk7dmFyIEk9Y29udmVydC53b3JkQXJyYXlUb0J5dGVzKEhtYWNTSEE1MTIoc2VlZFdvcmRzLFwiQml0Y29pbiBzZWVkXCIpKTt0aGlzLmNoYWluY29kZT1JLnNsaWNlKDMyKTt0aGlzLm5ldHdvcms9bmV0d29ya3x8XCJtYWlubmV0XCI7aWYoIU5ldHdvcmsuaGFzT3duUHJvcGVydHkodGhpcy5uZXR3b3JrKSl7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBuZXR3b3JrOiBcIit0aGlzLm5ldHdvcmspfXRoaXMucHJpdj1uZXcgRUNLZXkoSS5zbGljZSgwLDMyKS5jb25jYXQoWzFdKSx0cnVlKTt0aGlzLnB1Yj10aGlzLnByaXYuZ2V0UHViKCk7dGhpcy5pbmRleD0wO3RoaXMuZGVwdGg9MH1IRFdhbGxldC5ISUdIRVNUX0JJVD0yMTQ3NDgzNjQ4O0hEV2FsbGV0LkxFTkdUSD03ODtmdW5jdGlvbiBhcnJheUVxdWFsKGEsYil7cmV0dXJuIShhPGJ8fGE+Yil9SERXYWxsZXQuZnJvbVNlZWRIZXg9ZnVuY3Rpb24oaGV4LG5ldHdvcmspe3JldHVybiBuZXcgSERXYWxsZXQoY29udmVydC5oZXhUb0J5dGVzKGhleCksbmV0d29yayl9O0hEV2FsbGV0LmZyb21TZWVkU3RyaW5nPWZ1bmN0aW9uKHN0cmluZyxuZXR3b3JrKXtyZXR1cm4gbmV3IEhEV2FsbGV0KGNvbnZlcnQuc3RyaW5nVG9CeXRlcyhzdHJpbmcpLG5ldHdvcmspfTtIRFdhbGxldC5mcm9tQmFzZTU4PWZ1bmN0aW9uKHN0cmluZyl7dmFyIGJ1ZmZlcj1iYXNlNTguZGVjb2RlKHN0cmluZyk7dmFyIHBheWxvYWQ9YnVmZmVyLnNsaWNlKDAsLTQpO3ZhciBjaGVja3N1bT1idWZmZXIuc2xpY2UoLTQpO3ZhciBuZXdDaGVja3N1bT1zaGEyNTYoc2hhMjU2KHBheWxvYWQpKS5zbGljZSgwLDQpO2Fzc2VydC5kZWVwRXF1YWwobmV3Q2hlY2tzdW0sY2hlY2tzdW0pO2Fzc2VydC5lcXVhbChwYXlsb2FkLmxlbmd0aCxIRFdhbGxldC5MRU5HVEgpO3JldHVybiBIRFdhbGxldC5mcm9tQnl0ZXMocGF5bG9hZCl9O0hEV2FsbGV0LmZyb21IZXg9ZnVuY3Rpb24oaW5wdXQpe3JldHVybiBIRFdhbGxldC5mcm9tQnl0ZXMoY29udmVydC5oZXhUb0J5dGVzKGlucHV0KSl9O0hEV2FsbGV0LmZyb21CeXRlcz1mdW5jdGlvbihpbnB1dCl7aWYoaW5wdXQubGVuZ3RoIT1IRFdhbGxldC5MRU5HVEgpe3Rocm93IG5ldyBFcnJvcihmb3JtYXQoXCJJbnZhbGlkIGlucHV0IGxlbmd0aCwgJXMuIEV4cGVjdGVkICVzLlwiLGlucHV0Lmxlbmd0aCxIRFdhbGxldC5MRU5HVEgpKX1pZihCdWZmZXIuaXNCdWZmZXIoaW5wdXQpKXtpbnB1dD1BcnJheS5wcm90b3R5cGUubWFwLmJpbmQoaW5wdXQsZnVuY3Rpb24oeCl7cmV0dXJuIHh9KSgpfXZhciBoZD1uZXcgSERXYWxsZXQ7dmFyIHZlcnNpb25CeXRlcz1pbnB1dC5zbGljZSgwLDQpO3ZhciB2ZXJzaW9uV29yZD1jb252ZXJ0LmJ5dGVzVG9Xb3Jkcyh2ZXJzaW9uQnl0ZXMpWzBdO3ZhciB0eXBlO2Zvcih2YXIgbmFtZSBpbiBOZXR3b3JrKXt2YXIgbmV0d29yaz1OZXR3b3JrW25hbWVdO2Zvcih2YXIgdCBpbiBuZXR3b3JrLmhkVmVyc2lvbnMpe2lmKHZlcnNpb25Xb3JkIT1uZXR3b3JrLmhkVmVyc2lvbnNbdF0pY29udGludWU7dHlwZT10O2hkLm5ldHdvcms9bmFtZX19aWYoIWhkLm5ldHdvcmspe3Rocm93IG5ldyBFcnJvcihmb3JtYXQoXCJDb3VsZCBub3QgZmluZCB2ZXJzaW9uICVzXCIsY29udmVydC5ieXRlc1RvSGV4KHZlcnNpb25CeXRlcykpKX1oZC5kZXB0aD1pbnB1dFs0XTtoZC5wYXJlbnRGaW5nZXJwcmludD1pbnB1dC5zbGljZSg1LDkpO2Fzc2VydChoZC5kZXB0aD09PTA9PWFycmF5RXF1YWwoaGQucGFyZW50RmluZ2VycHJpbnQsWzAsMCwwLDBdKSk7aGQuaW5kZXg9Y29udmVydC5ieXRlc1RvTnVtKGlucHV0LnNsaWNlKDksMTMpLnJldmVyc2UoKSk7YXNzZXJ0KGhkLmRlcHRoPjB8fGhkLmluZGV4PT09MCk7aGQuY2hhaW5jb2RlPWlucHV0LnNsaWNlKDEzLDQ1KTtpZih0eXBlPT1cInByaXZcIil7aGQucHJpdj1uZXcgRUNLZXkoaW5wdXQuc2xpY2UoNDYsNzgpLmNvbmNhdChbMV0pLHRydWUpO2hkLnB1Yj1oZC5wcml2LmdldFB1YigpfWVsc2V7aGQucHViPW5ldyBFQ1B1YktleShpbnB1dC5zbGljZSg0NSw3OCksdHJ1ZSl9cmV0dXJuIGhkfTtIRFdhbGxldC5wcm90b3R5cGUuZ2V0SWRlbnRpZmllcj1mdW5jdGlvbigpe3JldHVybiB1dGlsLnNoYTI1NnJpcGUxNjAodGhpcy5wdWIudG9CeXRlcygpKX07SERXYWxsZXQucHJvdG90eXBlLmdldEZpbmdlcnByaW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0SWRlbnRpZmllcigpLnNsaWNlKDAsNCl9O0hEV2FsbGV0LnByb3RvdHlwZS5nZXRBZGRyZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBBZGRyZXNzKHV0aWwuc2hhMjU2cmlwZTE2MCh0aGlzLnB1Yi50b0J5dGVzKCkpLHRoaXMuZ2V0S2V5VmVyc2lvbigpKX07SERXYWxsZXQucHJvdG90eXBlLnRvQnl0ZXM9ZnVuY3Rpb24ocHJpdil7dmFyIGJ1ZmZlcj1bXTt2YXIgdmVyc2lvbj1OZXR3b3JrW3RoaXMubmV0d29ya10uaGRWZXJzaW9uc1twcml2P1wicHJpdlwiOlwicHViXCJdO3ZhciB2Qnl0ZXM9Y29udmVydC53b3Jkc1RvQnl0ZXMoW3ZlcnNpb25dKTtidWZmZXI9YnVmZmVyLmNvbmNhdCh2Qnl0ZXMpO2Fzc2VydC5lcXVhbChidWZmZXIubGVuZ3RoLDQpO2J1ZmZlci5wdXNoKHRoaXMuZGVwdGgpO2Fzc2VydC5lcXVhbChidWZmZXIubGVuZ3RoLDQrMSk7YnVmZmVyPWJ1ZmZlci5jb25jYXQodGhpcy5kZXB0aD90aGlzLnBhcmVudEZpbmdlcnByaW50OlswLDAsMCwwXSk7YXNzZXJ0LmVxdWFsKGJ1ZmZlci5sZW5ndGgsNCsxKzQpO2J1ZmZlcj1idWZmZXIuY29uY2F0KGNvbnZlcnQubnVtVG9CeXRlcyh0aGlzLmluZGV4LDQpLnJldmVyc2UoKSk7YXNzZXJ0LmVxdWFsKGJ1ZmZlci5sZW5ndGgsNCsxKzQrNCk7YnVmZmVyPWJ1ZmZlci5jb25jYXQodGhpcy5jaGFpbmNvZGUpO2Fzc2VydC5lcXVhbChidWZmZXIubGVuZ3RoLDQrMSs0KzQrMzIpO2lmKHByaXYpe2Fzc2VydCh0aGlzLnByaXYsXCJDYW5ub3Qgc2VyaWFsaXplIHRvIHByaXZhdGUgd2l0aG91dCBwcml2YXRlIGtleVwiKTtidWZmZXIucHVzaCgwKTtidWZmZXI9YnVmZmVyLmNvbmNhdCh0aGlzLnByaXYudG9CeXRlcygpLnNsaWNlKDAsMzIpKX1lbHNle2J1ZmZlcj1idWZmZXIuY29uY2F0KHRoaXMucHViLnRvQnl0ZXModHJ1ZSkpfXJldHVybiBidWZmZXJ9O0hEV2FsbGV0LnByb3RvdHlwZS50b0hleD1mdW5jdGlvbihwcml2KXt2YXIgYnl0ZXM9dGhpcy50b0J5dGVzKHByaXYpO3JldHVybiBjb252ZXJ0LmJ5dGVzVG9IZXgoYnl0ZXMpfTtIRFdhbGxldC5wcm90b3R5cGUudG9CYXNlNTg9ZnVuY3Rpb24ocHJpdil7dmFyIGJ1ZmZlcj1uZXcgQnVmZmVyKHRoaXMudG9CeXRlcyhwcml2KSk7dmFyIGNoZWNrc3VtPXNoYTI1NihzaGEyNTYoYnVmZmVyKSkuc2xpY2UoMCw0KTtyZXR1cm4gYmFzZTU4LmVuY29kZShCdWZmZXIuY29uY2F0KFtidWZmZXIsY2hlY2tzdW1dKSl9O0hEV2FsbGV0LnByb3RvdHlwZS5kZXJpdmU9ZnVuY3Rpb24oaSl7dmFyIEksaUJ5dGVzPWNvbnZlcnQubnVtVG9CeXRlcyhpLDQpLnJldmVyc2UoKSxjUGFyPXRoaXMuY2hhaW5jb2RlLHVzZVByaXY9aT49SERXYWxsZXQuSElHSEVTVF9CSVQsU0hBNTEyPUNyeXB0by5hbGdvLlNIQTUxMjtpZih1c2VQcml2KXthc3NlcnQodGhpcy5wcml2LFwiUHJpdmF0ZSBkZXJpdmUgb24gcHVibGljIGtleVwiKTt2YXIga1Bhcj10aGlzLnByaXYudG9CeXRlcygpLnNsaWNlKDAsMzIpO0k9SG1hY0Zyb21CeXRlc1RvQnl0ZXMoU0hBNTEyLFswXS5jb25jYXQoa1BhcixpQnl0ZXMpLGNQYXIpfWVsc2V7dmFyIEtQYXI9dGhpcy5wdWIudG9CeXRlcyh0cnVlKTtJPUhtYWNGcm9tQnl0ZXNUb0J5dGVzKFNIQTUxMixLUGFyLmNvbmNhdChpQnl0ZXMpLGNQYXIpfXZhciBJTD1JLnNsaWNlKDAsMzIpLElSPUkuc2xpY2UoMzIpO3ZhciBoZD1uZXcgSERXYWxsZXQ7aGQubmV0d29yaz10aGlzLm5ldHdvcms7aWYodGhpcy5wcml2KXtoZC5wcml2PXRoaXMucHJpdi5hZGQobmV3IEVDS2V5KElMLmNvbmNhdChbMV0pKSk7aGQucHJpdi5jb21wcmVzc2VkPXRydWU7aGQucHJpdi52ZXJzaW9uPXRoaXMuZ2V0S2V5VmVyc2lvbigpO2hkLnB1Yj1oZC5wcml2LmdldFB1YigpfWVsc2V7aGQucHViPXRoaXMucHViLmFkZChuZXcgRUNLZXkoSUwuY29uY2F0KFsxXSksdHJ1ZSkuZ2V0UHViKCkpfWhkLmNoYWluY29kZT1JUjtoZC5wYXJlbnRGaW5nZXJwcmludD10aGlzLmdldEZpbmdlcnByaW50KCk7aGQuZGVwdGg9dGhpcy5kZXB0aCsxO2hkLmluZGV4PWk7aGQucHViLmNvbXByZXNzZWQ9dHJ1ZTtyZXR1cm4gaGR9O0hEV2FsbGV0LnByb3RvdHlwZS5kZXJpdmVQcml2YXRlPWZ1bmN0aW9uKGluZGV4KXtyZXR1cm4gdGhpcy5kZXJpdmUoaW5kZXgrSERXYWxsZXQuSElHSEVTVF9CSVQpfTtIRFdhbGxldC5wcm90b3R5cGUuZ2V0S2V5VmVyc2lvbj1mdW5jdGlvbigpe3JldHVybiBOZXR3b3JrW3RoaXMubmV0d29ya10uYWRkcmVzc1ZlcnNpb259O0hEV2FsbGV0LnByb3RvdHlwZS50b1N0cmluZz1IRFdhbGxldC5wcm90b3R5cGUudG9CYXNlNTg7ZnVuY3Rpb24gSG1hY0Zyb21CeXRlc1RvQnl0ZXMoaGFzaGVyLG1lc3NhZ2Usa2V5KXt2YXIgaG1hYz1ITUFDLmNyZWF0ZShoYXNoZXIsY29udmVydC5ieXRlc1RvV29yZEFycmF5KGtleSkpO2htYWMudXBkYXRlKGNvbnZlcnQuYnl0ZXNUb1dvcmRBcnJheShtZXNzYWdlKSk7cmV0dXJuIGNvbnZlcnQud29yZEFycmF5VG9CeXRlcyhobWFjLmZpbmFsaXplKCkpfW1vZHVsZS5leHBvcnRzPUhEV2FsbGV0fSkuY2FsbCh0aGlzLF9kZXJlcV8oXCJidWZmZXJcIikuQnVmZmVyKX0se1wiLi9hZGRyZXNzLmpzXCI6NTQsXCIuL2Jhc2U1OC5qc1wiOjU1LFwiLi9jb252ZXJ0LmpzXCI6NTcsXCIuL2Vja2V5LmpzXCI6NTksXCIuL25ldHdvcmtcIjo2NixcIi4vdXRpbC5qc1wiOjcwLGFzc2VydDoxLGJ1ZmZlcjo1LGNyeXB0bzo5LFwiY3J5cHRvLWpzXCI6MjcsdXRpbDoxN31dLDYxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgS2V5PV9kZXJlcV8oXCIuL2Vja2V5XCIpO3ZhciBUPV9kZXJlcV8oXCIuL3RyYW5zYWN0aW9uXCIpO21vZHVsZS5leHBvcnRzPXtBZGRyZXNzOl9kZXJlcV8oXCIuL2FkZHJlc3NcIiksS2V5OktleS5FQ0tleSxFQ0tleTpLZXkuRUNLZXksRUNQdWJLZXk6S2V5LkVDUHViS2V5LE1lc3NhZ2U6X2RlcmVxXyhcIi4vbWVzc2FnZVwiKSxCaWdJbnRlZ2VyOl9kZXJlcV8oXCIuL2pzYm4vanNiblwiKSxDcnlwdG86X2RlcmVxXyhcImNyeXB0by1qc1wiKSxTY3JpcHQ6X2RlcmVxXyhcIi4vc2NyaXB0XCIpLE9wY29kZTpfZGVyZXFfKFwiLi9vcGNvZGVcIiksVHJhbnNhY3Rpb246VC5UcmFuc2FjdGlvbixVdGlsOl9kZXJlcV8oXCIuL3V0aWxcIiksVHJhbnNhY3Rpb25JbjpULlRyYW5zYWN0aW9uSW4sVHJhbnNhY3Rpb25PdXQ6VC5UcmFuc2FjdGlvbk91dCxFQ1BvaW50RnA6X2RlcmVxXyhcIi4vanNibi9lY1wiKS5FQ1BvaW50RnAsV2FsbGV0Ol9kZXJlcV8oXCIuL3dhbGxldFwiKSxuZXR3b3JrOl9kZXJlcV8oXCIuL25ldHdvcmtcIiksZWNkc2E6X2RlcmVxXyhcIi4vZWNkc2FcIiksSERXYWxsZXQ6X2RlcmVxXyhcIi4vaGR3YWxsZXQuanNcIiksYmFzZTU4Ol9kZXJlcV8oXCIuL2Jhc2U1OFwiKSxiYXNlNThjaGVjazpfZGVyZXFfKFwiLi9iYXNlNThjaGVja1wiKSxjb252ZXJ0Ol9kZXJlcV8oXCIuL2NvbnZlcnRcIil9fSx7XCIuL2FkZHJlc3NcIjo1NCxcIi4vYmFzZTU4XCI6NTUsXCIuL2Jhc2U1OGNoZWNrXCI6NTYsXCIuL2NvbnZlcnRcIjo1NyxcIi4vZWNkc2FcIjo1OCxcIi4vZWNrZXlcIjo1OSxcIi4vaGR3YWxsZXQuanNcIjo2MCxcIi4vanNibi9lY1wiOjYyLFwiLi9qc2JuL2pzYm5cIjo2MyxcIi4vbWVzc2FnZVwiOjY1LFwiLi9uZXR3b3JrXCI6NjYsXCIuL29wY29kZVwiOjY3LFwiLi9zY3JpcHRcIjo2OCxcIi4vdHJhbnNhY3Rpb25cIjo2OSxcIi4vdXRpbFwiOjcwLFwiLi93YWxsZXRcIjo3MSxcImNyeXB0by1qc1wiOjI3fV0sNjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBCaWdJbnRlZ2VyPV9kZXJlcV8oXCIuL2pzYm5cIiksc2VjPV9kZXJlcV8oXCIuL3NlY1wiKTtmdW5jdGlvbiBFQ0ZpZWxkRWxlbWVudEZwKHEseCl7dGhpcy54PXg7dGhpcy5xPXF9ZnVuY3Rpb24gZmVGcEVxdWFscyhvdGhlcil7aWYob3RoZXI9PXRoaXMpcmV0dXJuIHRydWU7cmV0dXJuIHRoaXMucS5lcXVhbHMob3RoZXIucSkmJnRoaXMueC5lcXVhbHMob3RoZXIueCl9ZnVuY3Rpb24gZmVGcFRvQmlnSW50ZWdlcigpe3JldHVybiB0aGlzLnh9ZnVuY3Rpb24gZmVGcE5lZ2F0ZSgpe3JldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcCh0aGlzLnEsdGhpcy54Lm5lZ2F0ZSgpLm1vZCh0aGlzLnEpKX1mdW5jdGlvbiBmZUZwQWRkKGIpe3JldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcCh0aGlzLnEsdGhpcy54LmFkZChiLnRvQmlnSW50ZWdlcigpKS5tb2QodGhpcy5xKSl9ZnVuY3Rpb24gZmVGcFN1YnRyYWN0KGIpe3JldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcCh0aGlzLnEsdGhpcy54LnN1YnRyYWN0KGIudG9CaWdJbnRlZ2VyKCkpLm1vZCh0aGlzLnEpKX1mdW5jdGlvbiBmZUZwTXVsdGlwbHkoYil7cmV0dXJuIG5ldyBFQ0ZpZWxkRWxlbWVudEZwKHRoaXMucSx0aGlzLngubXVsdGlwbHkoYi50b0JpZ0ludGVnZXIoKSkubW9kKHRoaXMucSkpfWZ1bmN0aW9uIGZlRnBTcXVhcmUoKXtyZXR1cm4gbmV3IEVDRmllbGRFbGVtZW50RnAodGhpcy5xLHRoaXMueC5zcXVhcmUoKS5tb2QodGhpcy5xKSl9ZnVuY3Rpb24gZmVGcERpdmlkZShiKXtyZXR1cm4gbmV3IEVDRmllbGRFbGVtZW50RnAodGhpcy5xLHRoaXMueC5tdWx0aXBseShiLnRvQmlnSW50ZWdlcigpLm1vZEludmVyc2UodGhpcy5xKSkubW9kKHRoaXMucSkpfUVDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLmVxdWFscz1mZUZwRXF1YWxzO0VDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLnRvQmlnSW50ZWdlcj1mZUZwVG9CaWdJbnRlZ2VyO0VDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLm5lZ2F0ZT1mZUZwTmVnYXRlO0VDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLmFkZD1mZUZwQWRkO0VDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLnN1YnRyYWN0PWZlRnBTdWJ0cmFjdDtFQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5tdWx0aXBseT1mZUZwTXVsdGlwbHk7RUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUuc3F1YXJlPWZlRnBTcXVhcmU7RUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUuZGl2aWRlPWZlRnBEaXZpZGU7ZnVuY3Rpb24gRUNQb2ludEZwKGN1cnZlLHgseSx6KXt0aGlzLmN1cnZlPWN1cnZlO3RoaXMueD14O3RoaXMueT15O2lmKHo9PW51bGwpe3RoaXMuej1CaWdJbnRlZ2VyLk9ORX1lbHNle3RoaXMuej16fXRoaXMuemludj1udWxsfWZ1bmN0aW9uIHBvaW50RnBHZXRYKCl7aWYodGhpcy56aW52PT1udWxsKXt0aGlzLnppbnY9dGhpcy56Lm1vZEludmVyc2UodGhpcy5jdXJ2ZS5xKX1yZXR1cm4gdGhpcy5jdXJ2ZS5mcm9tQmlnSW50ZWdlcih0aGlzLngudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkodGhpcy56aW52KS5tb2QodGhpcy5jdXJ2ZS5xKSl9ZnVuY3Rpb24gcG9pbnRGcEdldFkoKXtpZih0aGlzLnppbnY9PW51bGwpe3RoaXMuemludj10aGlzLnoubW9kSW52ZXJzZSh0aGlzLmN1cnZlLnEpfXJldHVybiB0aGlzLmN1cnZlLmZyb21CaWdJbnRlZ2VyKHRoaXMueS50b0JpZ0ludGVnZXIoKS5tdWx0aXBseSh0aGlzLnppbnYpLm1vZCh0aGlzLmN1cnZlLnEpKX1mdW5jdGlvbiBwb2ludEZwRXF1YWxzKG90aGVyKXtpZihvdGhlcj09dGhpcylyZXR1cm4gdHJ1ZTtpZih0aGlzLmlzSW5maW5pdHkoKSlyZXR1cm4gb3RoZXIuaXNJbmZpbml0eSgpO2lmKG90aGVyLmlzSW5maW5pdHkoKSlyZXR1cm4gdGhpcy5pc0luZmluaXR5KCk7dmFyIHUsdjt1PW90aGVyLnkudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkodGhpcy56KS5zdWJ0cmFjdCh0aGlzLnkudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkob3RoZXIueikpLm1vZCh0aGlzLmN1cnZlLnEpO2lmKCF1LmVxdWFscyhCaWdJbnRlZ2VyLlpFUk8pKXJldHVybiBmYWxzZTt2PW90aGVyLngudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkodGhpcy56KS5zdWJ0cmFjdCh0aGlzLngudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkob3RoZXIueikpLm1vZCh0aGlzLmN1cnZlLnEpO3JldHVybiB2LmVxdWFscyhCaWdJbnRlZ2VyLlpFUk8pfWZ1bmN0aW9uIHBvaW50RnBJc0luZmluaXR5KCl7aWYodGhpcy54PT1udWxsJiZ0aGlzLnk9PW51bGwpcmV0dXJuIHRydWU7cmV0dXJuIHRoaXMuei5lcXVhbHMoQmlnSW50ZWdlci5aRVJPKSYmIXRoaXMueS50b0JpZ0ludGVnZXIoKS5lcXVhbHMoQmlnSW50ZWdlci5aRVJPKX1mdW5jdGlvbiBwb2ludEZwTmVnYXRlKCl7cmV0dXJuIG5ldyBFQ1BvaW50RnAodGhpcy5jdXJ2ZSx0aGlzLngsdGhpcy55Lm5lZ2F0ZSgpLHRoaXMueil9ZnVuY3Rpb24gcG9pbnRGcEFkZChiKXtpZih0aGlzLmlzSW5maW5pdHkoKSlyZXR1cm4gYjtpZihiLmlzSW5maW5pdHkoKSlyZXR1cm4gdGhpczt2YXIgdT1iLnkudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkodGhpcy56KS5zdWJ0cmFjdCh0aGlzLnkudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkoYi56KSkubW9kKHRoaXMuY3VydmUucSk7dmFyIHY9Yi54LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QodGhpcy54LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KGIueikpLm1vZCh0aGlzLmN1cnZlLnEpO2lmKEJpZ0ludGVnZXIuWkVSTy5lcXVhbHModikpe2lmKEJpZ0ludGVnZXIuWkVSTy5lcXVhbHModSkpe3JldHVybiB0aGlzLnR3aWNlKCl9cmV0dXJuIHRoaXMuY3VydmUuZ2V0SW5maW5pdHkoKX12YXIgVEhSRUU9bmV3IEJpZ0ludGVnZXIoXCIzXCIpO3ZhciB4MT10aGlzLngudG9CaWdJbnRlZ2VyKCk7dmFyIHkxPXRoaXMueS50b0JpZ0ludGVnZXIoKTt2YXIgeDI9Yi54LnRvQmlnSW50ZWdlcigpO3ZhciB5Mj1iLnkudG9CaWdJbnRlZ2VyKCk7dmFyIHYyPXYuc3F1YXJlKCk7dmFyIHYzPXYyLm11bHRpcGx5KHYpO3ZhciB4MXYyPXgxLm11bHRpcGx5KHYyKTt2YXIgenUyPXUuc3F1YXJlKCkubXVsdGlwbHkodGhpcy56KTt2YXIgeDM9enUyLnN1YnRyYWN0KHgxdjIuc2hpZnRMZWZ0KDEpKS5tdWx0aXBseShiLnopLnN1YnRyYWN0KHYzKS5tdWx0aXBseSh2KS5tb2QodGhpcy5jdXJ2ZS5xKTt2YXIgeTM9eDF2Mi5tdWx0aXBseShUSFJFRSkubXVsdGlwbHkodSkuc3VidHJhY3QoeTEubXVsdGlwbHkodjMpKS5zdWJ0cmFjdCh6dTIubXVsdGlwbHkodSkpLm11bHRpcGx5KGIueikuYWRkKHUubXVsdGlwbHkodjMpKS5tb2QodGhpcy5jdXJ2ZS5xKTt2YXIgejM9djMubXVsdGlwbHkodGhpcy56KS5tdWx0aXBseShiLnopLm1vZCh0aGlzLmN1cnZlLnEpO3JldHVybiBuZXcgRUNQb2ludEZwKHRoaXMuY3VydmUsdGhpcy5jdXJ2ZS5mcm9tQmlnSW50ZWdlcih4MyksdGhpcy5jdXJ2ZS5mcm9tQmlnSW50ZWdlcih5MyksejMpfWZ1bmN0aW9uIHBvaW50RnBUd2ljZSgpe2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVybiB0aGlzO2lmKHRoaXMueS50b0JpZ0ludGVnZXIoKS5zaWdudW0oKT09MClyZXR1cm4gdGhpcy5jdXJ2ZS5nZXRJbmZpbml0eSgpO3ZhciBUSFJFRT1uZXcgQmlnSW50ZWdlcihcIjNcIik7dmFyIHgxPXRoaXMueC50b0JpZ0ludGVnZXIoKTt2YXIgeTE9dGhpcy55LnRvQmlnSW50ZWdlcigpO3ZhciB5MXoxPXkxLm11bHRpcGx5KHRoaXMueik7dmFyIHkxc3F6MT15MXoxLm11bHRpcGx5KHkxKS5tb2QodGhpcy5jdXJ2ZS5xKTt2YXIgYT10aGlzLmN1cnZlLmEudG9CaWdJbnRlZ2VyKCk7XG52YXIgdz14MS5zcXVhcmUoKS5tdWx0aXBseShUSFJFRSk7aWYoIUJpZ0ludGVnZXIuWkVSTy5lcXVhbHMoYSkpe3c9dy5hZGQodGhpcy56LnNxdWFyZSgpLm11bHRpcGx5KGEpKX13PXcubW9kKHRoaXMuY3VydmUucSk7dmFyIHgzPXcuc3F1YXJlKCkuc3VidHJhY3QoeDEuc2hpZnRMZWZ0KDMpLm11bHRpcGx5KHkxc3F6MSkpLnNoaWZ0TGVmdCgxKS5tdWx0aXBseSh5MXoxKS5tb2QodGhpcy5jdXJ2ZS5xKTt2YXIgeTM9dy5tdWx0aXBseShUSFJFRSkubXVsdGlwbHkoeDEpLnN1YnRyYWN0KHkxc3F6MS5zaGlmdExlZnQoMSkpLnNoaWZ0TGVmdCgyKS5tdWx0aXBseSh5MXNxejEpLnN1YnRyYWN0KHcuc3F1YXJlKCkubXVsdGlwbHkodykpLm1vZCh0aGlzLmN1cnZlLnEpO3ZhciB6Mz15MXoxLnNxdWFyZSgpLm11bHRpcGx5KHkxejEpLnNoaWZ0TGVmdCgzKS5tb2QodGhpcy5jdXJ2ZS5xKTtyZXR1cm4gbmV3IEVDUG9pbnRGcCh0aGlzLmN1cnZlLHRoaXMuY3VydmUuZnJvbUJpZ0ludGVnZXIoeDMpLHRoaXMuY3VydmUuZnJvbUJpZ0ludGVnZXIoeTMpLHozKX1mdW5jdGlvbiBwb2ludEZwTXVsdGlwbHkoayl7aWYodGhpcy5pc0luZmluaXR5KCkpcmV0dXJuIHRoaXM7aWYoay5zaWdudW0oKT09MClyZXR1cm4gdGhpcy5jdXJ2ZS5nZXRJbmZpbml0eSgpO3ZhciBlPWs7dmFyIGg9ZS5tdWx0aXBseShuZXcgQmlnSW50ZWdlcihcIjNcIikpO3ZhciBuZWc9dGhpcy5uZWdhdGUoKTt2YXIgUj10aGlzO3ZhciBpO2ZvcihpPWguYml0TGVuZ3RoKCktMjtpPjA7LS1pKXtSPVIudHdpY2UoKTt2YXIgaEJpdD1oLnRlc3RCaXQoaSk7dmFyIGVCaXQ9ZS50ZXN0Qml0KGkpO2lmKGhCaXQhPWVCaXQpe1I9Ui5hZGQoaEJpdD90aGlzOm5lZyl9fXJldHVybiBSfWZ1bmN0aW9uIHBvaW50RnBNdWx0aXBseVR3byhqLHgsayl7dmFyIGk7aWYoai5iaXRMZW5ndGgoKT5rLmJpdExlbmd0aCgpKWk9ai5iaXRMZW5ndGgoKS0xO2Vsc2UgaT1rLmJpdExlbmd0aCgpLTE7dmFyIFI9dGhpcy5jdXJ2ZS5nZXRJbmZpbml0eSgpO3ZhciBib3RoPXRoaXMuYWRkKHgpO3doaWxlKGk+PTApe1I9Ui50d2ljZSgpO2lmKGoudGVzdEJpdChpKSl7aWYoay50ZXN0Qml0KGkpKXtSPVIuYWRkKGJvdGgpfWVsc2V7Uj1SLmFkZCh0aGlzKX19ZWxzZXtpZihrLnRlc3RCaXQoaSkpe1I9Ui5hZGQoeCl9fS0taX1yZXR1cm4gUn1FQ1BvaW50RnAucHJvdG90eXBlLmdldFg9cG9pbnRGcEdldFg7RUNQb2ludEZwLnByb3RvdHlwZS5nZXRZPXBvaW50RnBHZXRZO0VDUG9pbnRGcC5wcm90b3R5cGUuZXF1YWxzPXBvaW50RnBFcXVhbHM7RUNQb2ludEZwLnByb3RvdHlwZS5pc0luZmluaXR5PXBvaW50RnBJc0luZmluaXR5O0VDUG9pbnRGcC5wcm90b3R5cGUubmVnYXRlPXBvaW50RnBOZWdhdGU7RUNQb2ludEZwLnByb3RvdHlwZS5hZGQ9cG9pbnRGcEFkZDtFQ1BvaW50RnAucHJvdG90eXBlLnR3aWNlPXBvaW50RnBUd2ljZTtFQ1BvaW50RnAucHJvdG90eXBlLm11bHRpcGx5PXBvaW50RnBNdWx0aXBseTtFQ1BvaW50RnAucHJvdG90eXBlLm11bHRpcGx5VHdvPXBvaW50RnBNdWx0aXBseVR3bztmdW5jdGlvbiBFQ0N1cnZlRnAocSxhLGIpe3RoaXMucT1xO3RoaXMuYT10aGlzLmZyb21CaWdJbnRlZ2VyKGEpO3RoaXMuYj10aGlzLmZyb21CaWdJbnRlZ2VyKGIpO3RoaXMuaW5maW5pdHk9bmV3IEVDUG9pbnRGcCh0aGlzLG51bGwsbnVsbCl9ZnVuY3Rpb24gY3VydmVGcEdldFEoKXtyZXR1cm4gdGhpcy5xfWZ1bmN0aW9uIGN1cnZlRnBHZXRBKCl7cmV0dXJuIHRoaXMuYX1mdW5jdGlvbiBjdXJ2ZUZwR2V0Qigpe3JldHVybiB0aGlzLmJ9ZnVuY3Rpb24gY3VydmVGcEVxdWFscyhvdGhlcil7aWYob3RoZXI9PXRoaXMpcmV0dXJuIHRydWU7cmV0dXJuIHRoaXMucS5lcXVhbHMob3RoZXIucSkmJnRoaXMuYS5lcXVhbHMob3RoZXIuYSkmJnRoaXMuYi5lcXVhbHMob3RoZXIuYil9ZnVuY3Rpb24gY3VydmVGcEdldEluZmluaXR5KCl7cmV0dXJuIHRoaXMuaW5maW5pdHl9ZnVuY3Rpb24gY3VydmVGcEZyb21CaWdJbnRlZ2VyKHgpe3JldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcCh0aGlzLnEseCl9ZnVuY3Rpb24gY3VydmVGcERlY29kZVBvaW50SGV4KHMpe3N3aXRjaChwYXJzZUludChzLnN1YnN0cigwLDIpLDE2KSl7Y2FzZSAwOnJldHVybiB0aGlzLmluZmluaXR5O2Nhc2UgMjpjYXNlIDM6cmV0dXJuIG51bGw7Y2FzZSA0OmNhc2UgNjpjYXNlIDc6dmFyIGxlbj0ocy5sZW5ndGgtMikvMjt2YXIgeEhleD1zLnN1YnN0cigyLGxlbik7dmFyIHlIZXg9cy5zdWJzdHIobGVuKzIsbGVuKTtyZXR1cm4gbmV3IEVDUG9pbnRGcCh0aGlzLHRoaXMuZnJvbUJpZ0ludGVnZXIobmV3IEJpZ0ludGVnZXIoeEhleCwxNikpLHRoaXMuZnJvbUJpZ0ludGVnZXIobmV3IEJpZ0ludGVnZXIoeUhleCwxNikpKTtkZWZhdWx0OnJldHVybiBudWxsfX1FQ0N1cnZlRnAucHJvdG90eXBlLmdldFE9Y3VydmVGcEdldFE7RUNDdXJ2ZUZwLnByb3RvdHlwZS5nZXRBPWN1cnZlRnBHZXRBO0VDQ3VydmVGcC5wcm90b3R5cGUuZ2V0Qj1jdXJ2ZUZwR2V0QjtFQ0N1cnZlRnAucHJvdG90eXBlLmVxdWFscz1jdXJ2ZUZwRXF1YWxzO0VDQ3VydmVGcC5wcm90b3R5cGUuZ2V0SW5maW5pdHk9Y3VydmVGcEdldEluZmluaXR5O0VDQ3VydmVGcC5wcm90b3R5cGUuZnJvbUJpZ0ludGVnZXI9Y3VydmVGcEZyb21CaWdJbnRlZ2VyO0VDQ3VydmVGcC5wcm90b3R5cGUuZGVjb2RlUG9pbnRIZXg9Y3VydmVGcERlY29kZVBvaW50SGV4O2Z1bmN0aW9uIGludGVnZXJUb0J5dGVzKGksbGVuKXt2YXIgYnl0ZXM9aS50b0J5dGVBcnJheVVuc2lnbmVkKCk7aWYobGVuPGJ5dGVzLmxlbmd0aCl7Ynl0ZXM9Ynl0ZXMuc2xpY2UoYnl0ZXMubGVuZ3RoLWxlbil9ZWxzZSB3aGlsZShsZW4+Ynl0ZXMubGVuZ3RoKXtieXRlcy51bnNoaWZ0KDApfXJldHVybiBieXRlc31FQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5nZXRCeXRlTGVuZ3RoPWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguZmxvb3IoKHRoaXMudG9CaWdJbnRlZ2VyKCkuYml0TGVuZ3RoKCkrNykvOCl9O0VDUG9pbnRGcC5wcm90b3R5cGUuZ2V0RW5jb2RlZD1mdW5jdGlvbihjb21wcmVzc2VkKXt2YXIgeD10aGlzLmdldFgoKS50b0JpZ0ludGVnZXIoKTt2YXIgeT10aGlzLmdldFkoKS50b0JpZ0ludGVnZXIoKTt2YXIgZW5jPWludGVnZXJUb0J5dGVzKHgsMzIpO2lmKGNvbXByZXNzZWQpe2lmKHkuaXNFdmVuKCkpe2VuYy51bnNoaWZ0KDIpfWVsc2V7ZW5jLnVuc2hpZnQoMyl9fWVsc2V7ZW5jLnVuc2hpZnQoNCk7ZW5jPWVuYy5jb25jYXQoaW50ZWdlclRvQnl0ZXMoeSwzMikpfXJldHVybiBlbmN9O0VDUG9pbnRGcC5kZWNvZGVGcm9tPWZ1bmN0aW9uKGVjcGFyYW1zLGVuYyl7dmFyIHR5cGU9ZW5jWzBdO3ZhciBkYXRhTGVuPWVuYy5sZW5ndGgtMTtpZih0eXBlPT00KXt2YXIgeEJhPWVuYy5zbGljZSgxLDErZGF0YUxlbi8yKSx5QmE9ZW5jLnNsaWNlKDErZGF0YUxlbi8yLDErZGF0YUxlbikseD1CaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZCh4QmEpLHk9QmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQoeUJhKX1lbHNle3ZhciB4QmE9ZW5jLnNsaWNlKDEpLHg9QmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQoeEJhKSxwPWVjcGFyYW1zLmdldFEoKSx4Q3ViZWRQbHVzNz14Lm11bHRpcGx5KHgpLm11bHRpcGx5KHgpLmFkZChuZXcgQmlnSW50ZWdlcihcIjdcIikpLm1vZChwKSxwUGx1czFPdmVyND1wLmFkZChuZXcgQmlnSW50ZWdlcihcIjFcIikpLmRpdmlkZShuZXcgQmlnSW50ZWdlcihcIjRcIikpLHk9eEN1YmVkUGx1czcubW9kUG93KHBQbHVzMU92ZXI0LHApO2lmKHkubW9kKG5ldyBCaWdJbnRlZ2VyKFwiMlwiKSkudG9TdHJpbmcoKSE9XCJcIit0eXBlJTIpe3k9cC5zdWJ0cmFjdCh5KX19cmV0dXJuIG5ldyBFQ1BvaW50RnAoZWNwYXJhbXMsZWNwYXJhbXMuZnJvbUJpZ0ludGVnZXIoeCksZWNwYXJhbXMuZnJvbUJpZ0ludGVnZXIoeSkpfTtFQ1BvaW50RnAucHJvdG90eXBlLmFkZDJEPWZ1bmN0aW9uKGIpe2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVybiBiO2lmKGIuaXNJbmZpbml0eSgpKXJldHVybiB0aGlzO2lmKHRoaXMueC5lcXVhbHMoYi54KSl7aWYodGhpcy55LmVxdWFscyhiLnkpKXtyZXR1cm4gdGhpcy50d2ljZSgpfXJldHVybiB0aGlzLmN1cnZlLmdldEluZmluaXR5KCl9dmFyIHhfeD1iLnguc3VidHJhY3QodGhpcy54KTt2YXIgeV95PWIueS5zdWJ0cmFjdCh0aGlzLnkpO3ZhciBnYW1tYT15X3kuZGl2aWRlKHhfeCk7dmFyIHgzPWdhbW1hLnNxdWFyZSgpLnN1YnRyYWN0KHRoaXMueCkuc3VidHJhY3QoYi54KTt2YXIgeTM9Z2FtbWEubXVsdGlwbHkodGhpcy54LnN1YnRyYWN0KHgzKSkuc3VidHJhY3QodGhpcy55KTtyZXR1cm4gbmV3IEVDUG9pbnRGcCh0aGlzLmN1cnZlLHgzLHkzKX07RUNQb2ludEZwLnByb3RvdHlwZS50d2ljZTJEPWZ1bmN0aW9uKCl7aWYodGhpcy5pc0luZmluaXR5KCkpcmV0dXJuIHRoaXM7aWYodGhpcy55LnRvQmlnSW50ZWdlcigpLnNpZ251bSgpPT0wKXtyZXR1cm4gdGhpcy5jdXJ2ZS5nZXRJbmZpbml0eSgpfXZhciBUV089dGhpcy5jdXJ2ZS5mcm9tQmlnSW50ZWdlcihCaWdJbnRlZ2VyLnZhbHVlT2YoMikpO3ZhciBUSFJFRT10aGlzLmN1cnZlLmZyb21CaWdJbnRlZ2VyKEJpZ0ludGVnZXIudmFsdWVPZigzKSk7dmFyIGdhbW1hPXRoaXMueC5zcXVhcmUoKS5tdWx0aXBseShUSFJFRSkuYWRkKHRoaXMuY3VydmUuYSkuZGl2aWRlKHRoaXMueS5tdWx0aXBseShUV08pKTt2YXIgeDM9Z2FtbWEuc3F1YXJlKCkuc3VidHJhY3QodGhpcy54Lm11bHRpcGx5KFRXTykpO3ZhciB5Mz1nYW1tYS5tdWx0aXBseSh0aGlzLnguc3VidHJhY3QoeDMpKS5zdWJ0cmFjdCh0aGlzLnkpO3JldHVybiBuZXcgRUNQb2ludEZwKHRoaXMuY3VydmUseDMseTMpfTtFQ1BvaW50RnAucHJvdG90eXBlLm11bHRpcGx5MkQ9ZnVuY3Rpb24oayl7aWYodGhpcy5pc0luZmluaXR5KCkpcmV0dXJuIHRoaXM7aWYoay5zaWdudW0oKT09MClyZXR1cm4gdGhpcy5jdXJ2ZS5nZXRJbmZpbml0eSgpO3ZhciBlPWs7dmFyIGg9ZS5tdWx0aXBseShuZXcgQmlnSW50ZWdlcihcIjNcIikpO3ZhciBuZWc9dGhpcy5uZWdhdGUoKTt2YXIgUj10aGlzO3ZhciBpO2ZvcihpPWguYml0TGVuZ3RoKCktMjtpPjA7LS1pKXtSPVIudHdpY2UoKTt2YXIgaEJpdD1oLnRlc3RCaXQoaSk7dmFyIGVCaXQ9ZS50ZXN0Qml0KGkpO2lmKGhCaXQhPWVCaXQpe1I9Ui5hZGQyRChoQml0P3RoaXM6bmVnKX19cmV0dXJuIFJ9O0VDUG9pbnRGcC5wcm90b3R5cGUuaXNPbkN1cnZlPWZ1bmN0aW9uKCl7dmFyIHg9dGhpcy5nZXRYKCkudG9CaWdJbnRlZ2VyKCk7dmFyIHk9dGhpcy5nZXRZKCkudG9CaWdJbnRlZ2VyKCk7dmFyIGE9dGhpcy5jdXJ2ZS5nZXRBKCkudG9CaWdJbnRlZ2VyKCk7dmFyIGI9dGhpcy5jdXJ2ZS5nZXRCKCkudG9CaWdJbnRlZ2VyKCk7dmFyIG49dGhpcy5jdXJ2ZS5nZXRRKCk7dmFyIGxocz15Lm11bHRpcGx5KHkpLm1vZChuKTt2YXIgcmhzPXgubXVsdGlwbHkoeCkubXVsdGlwbHkoeCkuYWRkKGEubXVsdGlwbHkoeCkpLmFkZChiKS5tb2Qobik7cmV0dXJuIGxocy5lcXVhbHMocmhzKX07RUNQb2ludEZwLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiKFwiK3RoaXMuZ2V0WCgpLnRvQmlnSW50ZWdlcigpLnRvU3RyaW5nKCkrXCIsXCIrdGhpcy5nZXRZKCkudG9CaWdJbnRlZ2VyKCkudG9TdHJpbmcoKStcIilcIn07RUNQb2ludEZwLnByb3RvdHlwZS52YWxpZGF0ZT1mdW5jdGlvbigpe3ZhciBuPXRoaXMuY3VydmUuZ2V0USgpO2lmKHRoaXMuaXNJbmZpbml0eSgpKXt0aHJvdyBuZXcgRXJyb3IoXCJQb2ludCBpcyBhdCBpbmZpbml0eS5cIil9dmFyIHg9dGhpcy5nZXRYKCkudG9CaWdJbnRlZ2VyKCk7dmFyIHk9dGhpcy5nZXRZKCkudG9CaWdJbnRlZ2VyKCk7aWYoeC5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpPDB8fHguY29tcGFyZVRvKG4uc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpKT4wKXt0aHJvdyBuZXcgRXJyb3IoXCJ4IGNvb3JkaW5hdGUgb3V0IG9mIGJvdW5kc1wiKX1pZih5LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSk8MHx8eS5jb21wYXJlVG8obi5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkpPjApe3Rocm93IG5ldyBFcnJvcihcInkgY29vcmRpbmF0ZSBvdXQgb2YgYm91bmRzXCIpfWlmKCF0aGlzLmlzT25DdXJ2ZSgpKXt0aHJvdyBuZXcgRXJyb3IoXCJQb2ludCBpcyBub3Qgb24gdGhlIGN1cnZlLlwiKX1pZih0aGlzLm11bHRpcGx5KG4pLmlzSW5maW5pdHkoKSl7dGhyb3cgbmV3IEVycm9yKFwiUG9pbnQgaXMgbm90IGEgc2NhbGFyIG11bHRpcGxlIG9mIEcuXCIpfXJldHVybiB0cnVlfTttb2R1bGUuZXhwb3J0cz1FQ0N1cnZlRnA7bW9kdWxlLmV4cG9ydHMuRUNQb2ludEZwPUVDUG9pbnRGcH0se1wiLi9qc2JuXCI6NjMsXCIuL3NlY1wiOjY0fV0sNjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihCdWZmZXIpe3ZhciBkYml0czt2YXIgY2FuYXJ5PTB4ZGVhZGJlZWZjYWZlO3ZhciBqX2xtPShjYW5hcnkmMTY3NzcyMTUpPT0xNTcxNTA3MDtmdW5jdGlvbiBCaWdJbnRlZ2VyKGEsYixjKXtpZighKHRoaXMgaW5zdGFuY2VvZiBCaWdJbnRlZ2VyKSl7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGEsYixjKX1pZihhIT1udWxsKXtpZihcIm51bWJlclwiPT10eXBlb2YgYSl0aGlzLmZyb21OdW1iZXIoYSxiLGMpO2Vsc2UgaWYoYj09bnVsbCYmXCJzdHJpbmdcIiE9dHlwZW9mIGEpdGhpcy5mcm9tU3RyaW5nKGEsMjU2KTtlbHNlIHRoaXMuZnJvbVN0cmluZyhhLGIpfX12YXIgcHJvdG89QmlnSW50ZWdlci5wcm90b3R5cGU7ZnVuY3Rpb24gbmJpKCl7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG51bGwpfWZ1bmN0aW9uIGFtMShpLHgsdyxqLGMsbil7d2hpbGUoLS1uPj0wKXt2YXIgdj14KnRoaXNbaSsrXSt3W2pdK2M7Yz1NYXRoLmZsb29yKHYvNjcxMDg4NjQpO3dbaisrXT12JjY3MTA4ODYzfXJldHVybiBjfWZ1bmN0aW9uIGFtMihpLHgsdyxqLGMsbil7dmFyIHhsPXgmMzI3NjcseGg9eD4+MTU7d2hpbGUoLS1uPj0wKXt2YXIgbD10aGlzW2ldJjMyNzY3O3ZhciBoPXRoaXNbaSsrXT4+MTU7dmFyIG09eGgqbCtoKnhsO2w9eGwqbCsoKG0mMzI3NjcpPDwxNSkrd1tqXSsoYyYxMDczNzQxODIzKTtjPShsPj4+MzApKyhtPj4+MTUpK3hoKmgrKGM+Pj4zMCk7d1tqKytdPWwmMTA3Mzc0MTgyM31yZXR1cm4gY31mdW5jdGlvbiBhbTMoaSx4LHcsaixjLG4pe3ZhciB4bD14JjE2MzgzLHhoPXg+PjE0O3doaWxlKC0tbj49MCl7dmFyIGw9dGhpc1tpXSYxNjM4Mzt2YXIgaD10aGlzW2krK10+PjE0O3ZhciBtPXhoKmwraCp4bDtsPXhsKmwrKChtJjE2MzgzKTw8MTQpK3dbal0rYztjPShsPj4yOCkrKG0+PjE0KSt4aCpoO3dbaisrXT1sJjI2ODQzNTQ1NX1yZXR1cm4gY31CaWdJbnRlZ2VyLnByb3RvdHlwZS5hbT1hbTE7ZGJpdHM9MjY7QmlnSW50ZWdlci5wcm90b3R5cGUuREI9ZGJpdHM7QmlnSW50ZWdlci5wcm90b3R5cGUuRE09KDE8PGRiaXRzKS0xO3ZhciBEVj1CaWdJbnRlZ2VyLnByb3RvdHlwZS5EVj0xPDxkYml0czt2YXIgQklfRlA9NTI7QmlnSW50ZWdlci5wcm90b3R5cGUuRlY9TWF0aC5wb3coMixCSV9GUCk7QmlnSW50ZWdlci5wcm90b3R5cGUuRjE9QklfRlAtZGJpdHM7QmlnSW50ZWdlci5wcm90b3R5cGUuRjI9MipkYml0cy1CSV9GUDt2YXIgQklfUk09XCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjt2YXIgQklfUkM9bmV3IEFycmF5O3ZhciBycix2djtycj1cIjBcIi5jaGFyQ29kZUF0KDApO2Zvcih2dj0wO3Z2PD05OysrdnYpQklfUkNbcnIrK109dnY7cnI9XCJhXCIuY2hhckNvZGVBdCgwKTtmb3IodnY9MTA7dnY8MzY7Kyt2dilCSV9SQ1tycisrXT12djtycj1cIkFcIi5jaGFyQ29kZUF0KDApO2Zvcih2dj0xMDt2djwzNjsrK3Z2KUJJX1JDW3JyKytdPXZ2O2Z1bmN0aW9uIGludDJjaGFyKG4pe3JldHVybiBCSV9STS5jaGFyQXQobil9ZnVuY3Rpb24gaW50QXQocyxpKXt2YXIgYz1CSV9SQ1tzLmNoYXJDb2RlQXQoaSldO3JldHVybiBjPT1udWxsPy0xOmN9ZnVuY3Rpb24gYm5wQ29weVRvKHIpe2Zvcih2YXIgaT10aGlzLnQtMTtpPj0wOy0taSlyW2ldPXRoaXNbaV07ci50PXRoaXMudDtyLnM9dGhpcy5zfWZ1bmN0aW9uIGJucEZyb21JbnQoeCl7dGhpcy50PTE7dGhpcy5zPXg8MD8tMTowO2lmKHg+MCl0aGlzWzBdPXg7ZWxzZSBpZih4PC0xKXRoaXNbMF09eCtEVjtlbHNlIHRoaXMudD0wfWZ1bmN0aW9uIG5idihpKXt2YXIgcj1uYmkoKTtyLmZyb21JbnQoaSk7cmV0dXJuIHJ9ZnVuY3Rpb24gYm5wRnJvbVN0cmluZyhzLGIpe3ZhciBzZWxmPXRoaXM7dmFyIGs7aWYoYj09MTYpaz00O2Vsc2UgaWYoYj09OClrPTM7ZWxzZSBpZihiPT0yNTYpaz04O2Vsc2UgaWYoYj09MilrPTE7ZWxzZSBpZihiPT0zMilrPTU7ZWxzZSBpZihiPT00KWs9MjtlbHNle3NlbGYuZnJvbVJhZGl4KHMsYik7cmV0dXJufXNlbGYudD0wO3NlbGYucz0wO3ZhciBpPXMubGVuZ3RoLG1pPWZhbHNlLHNoPTA7d2hpbGUoLS1pPj0wKXt2YXIgeD1rPT04P3NbaV0mMjU1OmludEF0KHMsaSk7aWYoeDwwKXtpZihzLmNoYXJBdChpKT09XCItXCIpbWk9dHJ1ZTtjb250aW51ZX1taT1mYWxzZTtpZihzaD09MClzZWxmW3NlbGYudCsrXT14O2Vsc2UgaWYoc2graz5zZWxmLkRCKXtzZWxmW3NlbGYudC0xXXw9KHgmKDE8PHNlbGYuREItc2gpLTEpPDxzaDtzZWxmW3NlbGYudCsrXT14Pj5zZWxmLkRCLXNofWVsc2Ugc2VsZltzZWxmLnQtMV18PXg8PHNoO3NoKz1rO2lmKHNoPj1zZWxmLkRCKXNoLT1zZWxmLkRCfWlmKGs9PTgmJihzWzBdJjEyOCkhPTApe3NlbGYucz0tMTtpZihzaD4wKXNlbGZbc2VsZi50LTFdfD0oMTw8c2VsZi5EQi1zaCktMTw8c2h9c2VsZi5jbGFtcCgpO2lmKG1pKUJpZ0ludGVnZXIuWkVSTy5zdWJUbyhzZWxmLHNlbGYpfWZ1bmN0aW9uIGJucENsYW1wKCl7dmFyIGM9dGhpcy5zJnRoaXMuRE07d2hpbGUodGhpcy50PjAmJnRoaXNbdGhpcy50LTFdPT1jKS0tdGhpcy50fWZ1bmN0aW9uIGJuVG9TdHJpbmcoYil7dmFyIHNlbGY9dGhpcztpZihzZWxmLnM8MClyZXR1cm5cIi1cIitzZWxmLm5lZ2F0ZSgpLnRvU3RyaW5nKGIpO3ZhciBrO2lmKGI9PTE2KWs9NDtlbHNlIGlmKGI9PTgpaz0zO2Vsc2UgaWYoYj09MilrPTE7ZWxzZSBpZihiPT0zMilrPTU7ZWxzZSBpZihiPT00KWs9MjtlbHNlIHJldHVybiBzZWxmLnRvUmFkaXgoYik7dmFyIGttPSgxPDxrKS0xLGQsbT1mYWxzZSxyPVwiXCIsaT1zZWxmLnQ7dmFyIHA9c2VsZi5EQi1pKnNlbGYuREIlaztpZihpLS0+MCl7aWYocDxzZWxmLkRCJiYoZD1zZWxmW2ldPj5wKT4wKXttPXRydWU7cj1pbnQyY2hhcihkKX13aGlsZShpPj0wKXtpZihwPGspe2Q9KHNlbGZbaV0mKDE8PHApLTEpPDxrLXA7ZHw9c2VsZlstLWldPj4ocCs9c2VsZi5EQi1rKX1lbHNle2Q9c2VsZltpXT4+KHAtPWspJmttO2lmKHA8PTApe3ArPXNlbGYuREI7LS1pfX1pZihkPjApbT10cnVlO2lmKG0pcis9aW50MmNoYXIoZCl9fXJldHVybiBtP3I6XCIwXCJ9ZnVuY3Rpb24gYm5OZWdhdGUoKXt2YXIgcj1uYmkoKTtCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcyxyKTtyZXR1cm4gcn1mdW5jdGlvbiBibkFicygpe3JldHVybiB0aGlzLnM8MD90aGlzLm5lZ2F0ZSgpOnRoaXN9ZnVuY3Rpb24gYm5Db21wYXJlVG8oYSl7dmFyIHI9dGhpcy5zLWEucztpZihyIT0wKXJldHVybiByO3ZhciBpPXRoaXMudDtyPWktYS50O2lmKHIhPTApcmV0dXJuIHRoaXMuczwwPy1yOnI7d2hpbGUoLS1pPj0wKWlmKChyPXRoaXNbaV0tYVtpXSkhPTApcmV0dXJuIHI7cmV0dXJuIDB9ZnVuY3Rpb24gbmJpdHMoeCl7dmFyIHI9MSx0O2lmKCh0PXg+Pj4xNikhPTApe3g9dDtyKz0xNn1pZigodD14Pj44KSE9MCl7eD10O3IrPTh9aWYoKHQ9eD4+NCkhPTApe3g9dDtyKz00fWlmKCh0PXg+PjIpIT0wKXt4PXQ7cis9Mn1pZigodD14Pj4xKSE9MCl7eD10O3IrPTF9cmV0dXJuIHJ9ZnVuY3Rpb24gYm5CaXRMZW5ndGgoKXtpZih0aGlzLnQ8PTApcmV0dXJuIDA7cmV0dXJuIHRoaXMuREIqKHRoaXMudC0xKStuYml0cyh0aGlzW3RoaXMudC0xXV50aGlzLnMmdGhpcy5ETSl9ZnVuY3Rpb24gYm5wRExTaGlmdFRvKG4scil7dmFyIGk7Zm9yKGk9dGhpcy50LTE7aT49MDstLWkpcltpK25dPXRoaXNbaV07Zm9yKGk9bi0xO2k+PTA7LS1pKXJbaV09MDtyLnQ9dGhpcy50K247ci5zPXRoaXMuc31mdW5jdGlvbiBibnBEUlNoaWZ0VG8obixyKXtmb3IodmFyIGk9bjtpPHRoaXMudDsrK2kpcltpLW5dPXRoaXNbaV07ci50PU1hdGgubWF4KHRoaXMudC1uLDApO3Iucz10aGlzLnN9ZnVuY3Rpb24gYm5wTFNoaWZ0VG8obixyKXt2YXIgc2VsZj10aGlzO3ZhciBicz1uJXNlbGYuREI7dmFyIGNicz1zZWxmLkRCLWJzO3ZhciBibT0oMTw8Y2JzKS0xO3ZhciBkcz1NYXRoLmZsb29yKG4vc2VsZi5EQiksYz1zZWxmLnM8PGJzJnNlbGYuRE0saTtmb3IoaT1zZWxmLnQtMTtpPj0wOy0taSl7cltpK2RzKzFdPXNlbGZbaV0+PmNic3xjO2M9KHNlbGZbaV0mYm0pPDxic31mb3IoaT1kcy0xO2k+PTA7LS1pKXJbaV09MDtyW2RzXT1jO3IudD1zZWxmLnQrZHMrMTtyLnM9c2VsZi5zO3IuY2xhbXAoKX1mdW5jdGlvbiBibnBSU2hpZnRUbyhuLHIpe3ZhciBzZWxmPXRoaXM7ci5zPXNlbGYuczt2YXIgZHM9TWF0aC5mbG9vcihuL3NlbGYuREIpO2lmKGRzPj1zZWxmLnQpe3IudD0wO3JldHVybn12YXIgYnM9biVzZWxmLkRCO3ZhciBjYnM9c2VsZi5EQi1iczt2YXIgYm09KDE8PGJzKS0xO3JbMF09c2VsZltkc10+PmJzO2Zvcih2YXIgaT1kcysxO2k8c2VsZi50OysraSl7cltpLWRzLTFdfD0oc2VsZltpXSZibSk8PGNicztyW2ktZHNdPXNlbGZbaV0+PmJzfWlmKGJzPjApcltzZWxmLnQtZHMtMV18PShzZWxmLnMmYm0pPDxjYnM7ci50PXNlbGYudC1kcztyLmNsYW1wKCl9ZnVuY3Rpb24gYm5wU3ViVG8oYSxyKXt2YXIgc2VsZj10aGlzO3ZhciBpPTAsYz0wLG09TWF0aC5taW4oYS50LHNlbGYudCk7d2hpbGUoaTxtKXtjKz1zZWxmW2ldLWFbaV07cltpKytdPWMmc2VsZi5ETTtjPj49c2VsZi5EQn1pZihhLnQ8c2VsZi50KXtjLT1hLnM7d2hpbGUoaTxzZWxmLnQpe2MrPXNlbGZbaV07cltpKytdPWMmc2VsZi5ETTtjPj49c2VsZi5EQn1jKz1zZWxmLnN9ZWxzZXtjKz1zZWxmLnM7d2hpbGUoaTxhLnQpe2MtPWFbaV07cltpKytdPWMmc2VsZi5ETTtjPj49c2VsZi5EQn1jLT1hLnN9ci5zPWM8MD8tMTowO2lmKGM8LTEpcltpKytdPXNlbGYuRFYrYztlbHNlIGlmKGM+MClyW2krK109YztyLnQ9aTtyLmNsYW1wKCl9ZnVuY3Rpb24gYm5wTXVsdGlwbHlUbyhhLHIpe3ZhciB4PXRoaXMuYWJzKCkseT1hLmFicygpO3ZhciBpPXgudDtyLnQ9aSt5LnQ7d2hpbGUoLS1pPj0wKXJbaV09MDtmb3IoaT0wO2k8eS50OysraSlyW2kreC50XT14LmFtKDAseVtpXSxyLGksMCx4LnQpO3Iucz0wO3IuY2xhbXAoKTtpZih0aGlzLnMhPWEucylCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKX1mdW5jdGlvbiBibnBTcXVhcmVUbyhyKXt2YXIgeD10aGlzLmFicygpO3ZhciBpPXIudD0yKngudDt3aGlsZSgtLWk+PTApcltpXT0wO2ZvcihpPTA7aTx4LnQtMTsrK2kpe3ZhciBjPXguYW0oaSx4W2ldLHIsMippLDAsMSk7aWYoKHJbaSt4LnRdKz14LmFtKGkrMSwyKnhbaV0sciwyKmkrMSxjLHgudC1pLTEpKT49eC5EVil7cltpK3gudF0tPXguRFY7cltpK3gudCsxXT0xfX1pZihyLnQ+MClyW3IudC0xXSs9eC5hbShpLHhbaV0sciwyKmksMCwxKTtyLnM9MDtyLmNsYW1wKCl9ZnVuY3Rpb24gYm5wRGl2UmVtVG8obSxxLHIpe3ZhciBzZWxmPXRoaXM7dmFyIHBtPW0uYWJzKCk7aWYocG0udDw9MClyZXR1cm47dmFyIHB0PXNlbGYuYWJzKCk7aWYocHQudDxwbS50KXtpZihxIT1udWxsKXEuZnJvbUludCgwKTtpZihyIT1udWxsKXNlbGYuY29weVRvKHIpO3JldHVybn1pZihyPT1udWxsKXI9bmJpKCk7dmFyIHk9bmJpKCksdHM9c2VsZi5zLG1zPW0uczt2YXIgbnNoPXNlbGYuREItbmJpdHMocG1bcG0udC0xXSk7aWYobnNoPjApe3BtLmxTaGlmdFRvKG5zaCx5KTtwdC5sU2hpZnRUbyhuc2gscil9ZWxzZXtwbS5jb3B5VG8oeSk7cHQuY29weVRvKHIpfXZhciB5cz15LnQ7dmFyIHkwPXlbeXMtMV07aWYoeTA9PTApcmV0dXJuO3ZhciB5dD15MCooMTw8c2VsZi5GMSkrKHlzPjE/eVt5cy0yXT4+c2VsZi5GMjowKTt2YXIgZDE9c2VsZi5GVi95dCxkMj0oMTw8c2VsZi5GMSkveXQsZT0xPDxzZWxmLkYyO3ZhciBpPXIudCxqPWkteXMsdD1xPT1udWxsP25iaSgpOnE7eS5kbFNoaWZ0VG8oaix0KTtpZihyLmNvbXBhcmVUbyh0KT49MCl7cltyLnQrK109MTtyLnN1YlRvKHQscil9QmlnSW50ZWdlci5PTkUuZGxTaGlmdFRvKHlzLHQpO3Quc3ViVG8oeSx5KTt3aGlsZSh5LnQ8eXMpeVt5LnQrK109MDt3aGlsZSgtLWo+PTApe3ZhciBxZD1yWy0taV09PXkwP3NlbGYuRE06TWF0aC5mbG9vcihyW2ldKmQxKyhyW2ktMV0rZSkqZDIpO2lmKChyW2ldKz15LmFtKDAscWQscixqLDAseXMpKTxxZCl7eS5kbFNoaWZ0VG8oaix0KTtyLnN1YlRvKHQscik7d2hpbGUocltpXTwtLXFkKXIuc3ViVG8odCxyKX19aWYocSE9bnVsbCl7ci5kclNoaWZ0VG8oeXMscSk7aWYodHMhPW1zKUJpZ0ludGVnZXIuWkVSTy5zdWJUbyhxLHEpfXIudD15cztyLmNsYW1wKCk7aWYobnNoPjApci5yU2hpZnRUbyhuc2gscik7aWYodHM8MClCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKX1mdW5jdGlvbiBibk1vZChhKXt2YXIgcj1uYmkoKTt0aGlzLmFicygpLmRpdlJlbVRvKGEsbnVsbCxyKTtpZih0aGlzLnM8MCYmci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKT4wKWEuc3ViVG8ocixyKTtyZXR1cm4gcn1mdW5jdGlvbiBDbGFzc2ljKG0pe3RoaXMubT1tfWZ1bmN0aW9uIGNDb252ZXJ0KHgpe2lmKHguczwwfHx4LmNvbXBhcmVUbyh0aGlzLm0pPj0wKXJldHVybiB4Lm1vZCh0aGlzLm0pO2Vsc2UgcmV0dXJuIHh9ZnVuY3Rpb24gY1JldmVydCh4KXtyZXR1cm4geH1mdW5jdGlvbiBjUmVkdWNlKHgpe3guZGl2UmVtVG8odGhpcy5tLG51bGwseCl9ZnVuY3Rpb24gY011bFRvKHgseSxyKXt4Lm11bHRpcGx5VG8oeSxyKTt0aGlzLnJlZHVjZShyKX1mdW5jdGlvbiBjU3FyVG8oeCxyKXt4LnNxdWFyZVRvKHIpO3RoaXMucmVkdWNlKHIpfUNsYXNzaWMucHJvdG90eXBlLmNvbnZlcnQ9Y0NvbnZlcnQ7Q2xhc3NpYy5wcm90b3R5cGUucmV2ZXJ0PWNSZXZlcnQ7Q2xhc3NpYy5wcm90b3R5cGUucmVkdWNlPWNSZWR1Y2U7Q2xhc3NpYy5wcm90b3R5cGUubXVsVG89Y011bFRvO0NsYXNzaWMucHJvdG90eXBlLnNxclRvPWNTcXJUbztmdW5jdGlvbiBibnBJbnZEaWdpdCgpe2lmKHRoaXMudDwxKXJldHVybiAwO3ZhciB4PXRoaXNbMF07aWYoKHgmMSk9PTApcmV0dXJuIDA7dmFyIHk9eCYzO3k9eSooMi0oeCYxNSkqeSkmMTU7eT15KigyLSh4JjI1NSkqeSkmMjU1O3k9eSooMi0oKHgmNjU1MzUpKnkmNjU1MzUpKSY2NTUzNTt5PXkqKDIteCp5JXRoaXMuRFYpJXRoaXMuRFY7cmV0dXJuIHk+MD90aGlzLkRWLXk6LXl9ZnVuY3Rpb24gTW9udGdvbWVyeShtKXt0aGlzLm09bTt0aGlzLm1wPW0uaW52RGlnaXQoKTt0aGlzLm1wbD10aGlzLm1wJjMyNzY3O3RoaXMubXBoPXRoaXMubXA+PjE1O3RoaXMudW09KDE8PG0uREItMTUpLTE7dGhpcy5tdDI9MiptLnR9ZnVuY3Rpb24gbW9udENvbnZlcnQoeCl7dmFyIHI9bmJpKCk7eC5hYnMoKS5kbFNoaWZ0VG8odGhpcy5tLnQscik7ci5kaXZSZW1Ubyh0aGlzLm0sbnVsbCxyKTtpZih4LnM8MCYmci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKT4wKXRoaXMubS5zdWJUbyhyLHIpO3JldHVybiByfWZ1bmN0aW9uIG1vbnRSZXZlcnQoeCl7dmFyIHI9bmJpKCk7eC5jb3B5VG8ocik7dGhpcy5yZWR1Y2Uocik7cmV0dXJuIHJ9ZnVuY3Rpb24gbW9udFJlZHVjZSh4KXt3aGlsZSh4LnQ8PXRoaXMubXQyKXhbeC50KytdPTA7Zm9yKHZhciBpPTA7aTx0aGlzLm0udDsrK2kpe3ZhciBqPXhbaV0mMzI3Njc7dmFyIHUwPWoqdGhpcy5tcGwrKChqKnRoaXMubXBoKyh4W2ldPj4xNSkqdGhpcy5tcGwmdGhpcy51bSk8PDE1KSZ4LkRNO2o9aSt0aGlzLm0udDt4W2pdKz10aGlzLm0uYW0oMCx1MCx4LGksMCx0aGlzLm0udCk7d2hpbGUoeFtqXT49eC5EVil7eFtqXS09eC5EVjt4Wysral0rK319eC5jbGFtcCgpO3guZHJTaGlmdFRvKHRoaXMubS50LHgpO2lmKHguY29tcGFyZVRvKHRoaXMubSk+PTApeC5zdWJUbyh0aGlzLm0seCl9ZnVuY3Rpb24gbW9udFNxclRvKHgscil7eC5zcXVhcmVUbyhyKTt0aGlzLnJlZHVjZShyKX1mdW5jdGlvbiBtb250TXVsVG8oeCx5LHIpe3gubXVsdGlwbHlUbyh5LHIpO3RoaXMucmVkdWNlKHIpfU1vbnRnb21lcnkucHJvdG90eXBlLmNvbnZlcnQ9bW9udENvbnZlcnQ7TW9udGdvbWVyeS5wcm90b3R5cGUucmV2ZXJ0PW1vbnRSZXZlcnQ7TW9udGdvbWVyeS5wcm90b3R5cGUucmVkdWNlPW1vbnRSZWR1Y2U7TW9udGdvbWVyeS5wcm90b3R5cGUubXVsVG89bW9udE11bFRvO01vbnRnb21lcnkucHJvdG90eXBlLnNxclRvPW1vbnRTcXJUbztmdW5jdGlvbiBibnBJc0V2ZW4oKXtyZXR1cm4odGhpcy50PjA/dGhpc1swXSYxOnRoaXMucyk9PTB9ZnVuY3Rpb24gYm5wRXhwKGUseil7aWYoZT40Mjk0OTY3Mjk1fHxlPDEpcmV0dXJuIEJpZ0ludGVnZXIuT05FO3ZhciByPW5iaSgpLHIyPW5iaSgpLGc9ei5jb252ZXJ0KHRoaXMpLGk9bmJpdHMoZSktMTtnLmNvcHlUbyhyKTt3aGlsZSgtLWk+PTApe3ouc3FyVG8ocixyMik7aWYoKGUmMTw8aSk+MCl6Lm11bFRvKHIyLGcscik7ZWxzZXt2YXIgdD1yO3I9cjI7cjI9dH19cmV0dXJuIHoucmV2ZXJ0KHIpfWZ1bmN0aW9uIGJuTW9kUG93SW50KGUsbSl7dmFyIHo7aWYoZTwyNTZ8fG0uaXNFdmVuKCkpej1uZXcgQ2xhc3NpYyhtKTtlbHNlIHo9bmV3IE1vbnRnb21lcnkobSk7cmV0dXJuIHRoaXMuZXhwKGUseil9cHJvdG8uY29weVRvPWJucENvcHlUbztwcm90by5mcm9tSW50PWJucEZyb21JbnQ7cHJvdG8uZnJvbVN0cmluZz1ibnBGcm9tU3RyaW5nO3Byb3RvLmNsYW1wPWJucENsYW1wO3Byb3RvLmRsU2hpZnRUbz1ibnBETFNoaWZ0VG87cHJvdG8uZHJTaGlmdFRvPWJucERSU2hpZnRUbztwcm90by5sU2hpZnRUbz1ibnBMU2hpZnRUbztwcm90by5yU2hpZnRUbz1ibnBSU2hpZnRUbztwcm90by5zdWJUbz1ibnBTdWJUbztwcm90by5tdWx0aXBseVRvPWJucE11bHRpcGx5VG87cHJvdG8uc3F1YXJlVG89Ym5wU3F1YXJlVG87cHJvdG8uZGl2UmVtVG89Ym5wRGl2UmVtVG87cHJvdG8uaW52RGlnaXQ9Ym5wSW52RGlnaXQ7cHJvdG8uaXNFdmVuPWJucElzRXZlbjtwcm90by5leHA9Ym5wRXhwO3Byb3RvLnRvU3RyaW5nPWJuVG9TdHJpbmc7cHJvdG8ubmVnYXRlPWJuTmVnYXRlO3Byb3RvLmFicz1ibkFicztwcm90by5jb21wYXJlVG89Ym5Db21wYXJlVG87cHJvdG8uYml0TGVuZ3RoPWJuQml0TGVuZ3RoO3Byb3RvLm1vZD1ibk1vZDtwcm90by5tb2RQb3dJbnQ9Ym5Nb2RQb3dJbnQ7ZnVuY3Rpb24gbmJpKCl7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG51bGwpfWZ1bmN0aW9uIGJuQ2xvbmUoKXt2YXIgcj1uYmkoKTt0aGlzLmNvcHlUbyhyKTtyZXR1cm4gcn1mdW5jdGlvbiBibkludFZhbHVlKCl7aWYodGhpcy5zPDApe2lmKHRoaXMudD09MSlyZXR1cm4gdGhpc1swXS10aGlzLkRWO2Vsc2UgaWYodGhpcy50PT0wKXJldHVybi0xfWVsc2UgaWYodGhpcy50PT0xKXJldHVybiB0aGlzWzBdO2Vsc2UgaWYodGhpcy50PT0wKXJldHVybiAwO3JldHVybih0aGlzWzFdJigxPDwzMi10aGlzLkRCKS0xKTw8dGhpcy5EQnx0aGlzWzBdfWZ1bmN0aW9uIGJuQnl0ZVZhbHVlKCl7cmV0dXJuIHRoaXMudD09MD90aGlzLnM6dGhpc1swXTw8MjQ+PjI0fWZ1bmN0aW9uIGJuU2hvcnRWYWx1ZSgpe3JldHVybiB0aGlzLnQ9PTA/dGhpcy5zOnRoaXNbMF08PDE2Pj4xNn1mdW5jdGlvbiBibnBDaHVua1NpemUocil7cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5MTjIqdGhpcy5EQi9NYXRoLmxvZyhyKSl9ZnVuY3Rpb24gYm5TaWdOdW0oKXtpZih0aGlzLnM8MClyZXR1cm4tMTtlbHNlIGlmKHRoaXMudDw9MHx8dGhpcy50PT0xJiZ0aGlzWzBdPD0wKXJldHVybiAwO2Vsc2UgcmV0dXJuIDF9ZnVuY3Rpb24gYm5wVG9SYWRpeChiKXtpZihiPT1udWxsKWI9MTA7aWYodGhpcy5zaWdudW0oKT09MHx8YjwyfHxiPjM2KXJldHVyblwiMFwiO3ZhciBjcz10aGlzLmNodW5rU2l6ZShiKTt2YXIgYT1NYXRoLnBvdyhiLGNzKTt2YXIgZD1uYnYoYSkseT1uYmkoKSx6PW5iaSgpLHI9XCJcIjt0aGlzLmRpdlJlbVRvKGQseSx6KTt3aGlsZSh5LnNpZ251bSgpPjApe3I9KGErei5pbnRWYWx1ZSgpKS50b1N0cmluZyhiKS5zdWJzdHIoMSkrcjt5LmRpdlJlbVRvKGQseSx6KX1yZXR1cm4gei5pbnRWYWx1ZSgpLnRvU3RyaW5nKGIpK3J9ZnVuY3Rpb24gYm5wRnJvbVJhZGl4KHMsYil7dmFyIHNlbGY9dGhpcztzZWxmLmZyb21JbnQoMCk7aWYoYj09bnVsbCliPTEwO3ZhciBjcz1zZWxmLmNodW5rU2l6ZShiKTt2YXIgZD1NYXRoLnBvdyhiLGNzKSxtaT1mYWxzZSxqPTAsdz0wO2Zvcih2YXIgaT0wO2k8cy5sZW5ndGg7KytpKXt2YXIgeD1pbnRBdChzLGkpO2lmKHg8MCl7aWYocy5jaGFyQXQoaSk9PVwiLVwiJiZzZWxmLnNpZ251bSgpPT0wKW1pPXRydWU7Y29udGludWV9dz1iKncreDtpZigrK2o+PWNzKXtzZWxmLmRNdWx0aXBseShkKTtzZWxmLmRBZGRPZmZzZXQodywwKTtqPTA7dz0wfX1pZihqPjApe3NlbGYuZE11bHRpcGx5KE1hdGgucG93KGIsaikpO3NlbGYuZEFkZE9mZnNldCh3LDApfWlmKG1pKUJpZ0ludGVnZXIuWkVSTy5zdWJUbyhzZWxmLHNlbGYpfWZ1bmN0aW9uIGJucEZyb21OdW1iZXIoYSxiLGMpe3ZhciBzZWxmPXRoaXM7aWYoXCJudW1iZXJcIj09dHlwZW9mIGIpe2lmKGE8MilzZWxmLmZyb21JbnQoMSk7ZWxzZXtzZWxmLmZyb21OdW1iZXIoYSxjKTtpZighc2VsZi50ZXN0Qml0KGEtMSkpc2VsZi5iaXR3aXNlVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEtMSksb3Bfb3Isc2VsZik7aWYoc2VsZi5pc0V2ZW4oKSlzZWxmLmRBZGRPZmZzZXQoMSwwKTt3aGlsZSghc2VsZi5pc1Byb2JhYmxlUHJpbWUoYikpe3NlbGYuZEFkZE9mZnNldCgyLDApO2lmKHNlbGYuYml0TGVuZ3RoKCk+YSlzZWxmLnN1YlRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhLTEpLHNlbGYpfX19ZWxzZXt2YXIgdD1hJjc7dmFyIGxlbmd0aD0oYT4+MykrMTt2YXIgeD1iKGxlbmd0aCx7YXJyYXk6dHJ1ZX0pO2lmKHQ+MCl4WzBdJj0oMTw8dCktMTtlbHNlIHhbMF09MDtzZWxmLmZyb21TdHJpbmcoeCwyNTYpfX1mdW5jdGlvbiBiblRvQnl0ZUFycmF5KCl7dmFyIHNlbGY9dGhpczt2YXIgaT1zZWxmLnQscj1uZXcgQXJyYXk7clswXT1zZWxmLnM7dmFyIHA9c2VsZi5EQi1pKnNlbGYuREIlOCxkLGs9MDtpZihpLS0+MCl7aWYocDxzZWxmLkRCJiYoZD1zZWxmW2ldPj5wKSE9KHNlbGYucyZzZWxmLkRNKT4+cClyW2srK109ZHxzZWxmLnM8PHNlbGYuREItcDt3aGlsZShpPj0wKXtpZihwPDgpe2Q9KHNlbGZbaV0mKDE8PHApLTEpPDw4LXA7ZHw9c2VsZlstLWldPj4ocCs9c2VsZi5EQi04KX1lbHNle2Q9c2VsZltpXT4+KHAtPTgpJjI1NTtpZihwPD0wKXtwKz1zZWxmLkRCOy0taX19aWYoKGQmMTI4KSE9MClkfD0tMjU2O2lmKGs9PT0wJiYoc2VsZi5zJjEyOCkhPShkJjEyOCkpKytrO2lmKGs+MHx8ZCE9c2VsZi5zKXJbaysrXT1kfX1yZXR1cm4gcn1mdW5jdGlvbiBibkVxdWFscyhhKXtyZXR1cm4gdGhpcy5jb21wYXJlVG8oYSk9PTB9ZnVuY3Rpb24gYm5NaW4oYSl7cmV0dXJuIHRoaXMuY29tcGFyZVRvKGEpPDA/dGhpczphfWZ1bmN0aW9uIGJuTWF4KGEpe3JldHVybiB0aGlzLmNvbXBhcmVUbyhhKT4wP3RoaXM6YX1mdW5jdGlvbiBibnBCaXR3aXNlVG8oYSxvcCxyKXt2YXIgc2VsZj10aGlzO3ZhciBpLGYsbT1NYXRoLm1pbihhLnQsc2VsZi50KTtmb3IoaT0wO2k8bTsrK2kpcltpXT1vcChzZWxmW2ldLGFbaV0pO2lmKGEudDxzZWxmLnQpe2Y9YS5zJnNlbGYuRE07Zm9yKGk9bTtpPHNlbGYudDsrK2kpcltpXT1vcChzZWxmW2ldLGYpO3IudD1zZWxmLnR9ZWxzZXtmPXNlbGYucyZzZWxmLkRNO2ZvcihpPW07aTxhLnQ7KytpKXJbaV09b3AoZixhW2ldKTtyLnQ9YS50fXIucz1vcChzZWxmLnMsYS5zKTtyLmNsYW1wKCl9ZnVuY3Rpb24gb3BfYW5kKHgseSl7cmV0dXJuIHgmeX1mdW5jdGlvbiBibkFuZChhKXt2YXIgcj1uYmkoKTt0aGlzLmJpdHdpc2VUbyhhLG9wX2FuZCxyKTtyZXR1cm4gcn1mdW5jdGlvbiBvcF9vcih4LHkpe3JldHVybiB4fHl9ZnVuY3Rpb24gYm5PcihhKXt2YXIgcj1uYmkoKTt0aGlzLmJpdHdpc2VUbyhhLG9wX29yLHIpO3JldHVybiByfWZ1bmN0aW9uIG9wX3hvcih4LHkpe3JldHVybiB4Xnl9ZnVuY3Rpb24gYm5Yb3IoYSl7dmFyIHI9bmJpKCk7dGhpcy5iaXR3aXNlVG8oYSxvcF94b3Iscik7cmV0dXJuIHJ9ZnVuY3Rpb24gb3BfYW5kbm90KHgseSl7cmV0dXJuIHgmfnl9ZnVuY3Rpb24gYm5BbmROb3QoYSl7dmFyIHI9bmJpKCk7dGhpcy5iaXR3aXNlVG8oYSxvcF9hbmRub3Qscik7cmV0dXJuIHJ9ZnVuY3Rpb24gYm5Ob3QoKXt2YXIgcj1uYmkoKTtmb3IodmFyIGk9MDtpPHRoaXMudDsrK2kpcltpXT10aGlzLkRNJn50aGlzW2ldO3IudD10aGlzLnQ7ci5zPX50aGlzLnM7cmV0dXJuIHJ9ZnVuY3Rpb24gYm5TaGlmdExlZnQobil7dmFyIHI9bmJpKCk7aWYobjwwKXRoaXMuclNoaWZ0VG8oLW4scik7ZWxzZSB0aGlzLmxTaGlmdFRvKG4scik7cmV0dXJuIHJ9ZnVuY3Rpb24gYm5TaGlmdFJpZ2h0KG4pe3ZhciByPW5iaSgpO2lmKG48MCl0aGlzLmxTaGlmdFRvKC1uLHIpO2Vsc2UgdGhpcy5yU2hpZnRUbyhuLHIpO3JldHVybiByfWZ1bmN0aW9uIGxiaXQoeCl7aWYoeD09MClyZXR1cm4tMTt2YXIgcj0wO2lmKCh4JjY1NTM1KT09MCl7eD4+PTE2O3IrPTE2fWlmKCh4JjI1NSk9PTApe3g+Pj04O3IrPTh9aWYoKHgmMTUpPT0wKXt4Pj49NDtyKz00fWlmKCh4JjMpPT0wKXt4Pj49MjtyKz0yfWlmKCh4JjEpPT0wKSsrcjtyZXR1cm4gcn1mdW5jdGlvbiBibkdldExvd2VzdFNldEJpdCgpe2Zvcih2YXIgaT0wO2k8dGhpcy50OysraSlpZih0aGlzW2ldIT0wKXJldHVybiBpKnRoaXMuREIrbGJpdCh0aGlzW2ldKTtpZih0aGlzLnM8MClyZXR1cm4gdGhpcy50KnRoaXMuREI7cmV0dXJuLTF9ZnVuY3Rpb24gY2JpdCh4KXt2YXIgcj0wO3doaWxlKHghPTApe3gmPXgtMTsrK3J9cmV0dXJuIHJ9ZnVuY3Rpb24gYm5CaXRDb3VudCgpe3ZhciByPTAseD10aGlzLnMmdGhpcy5ETTtmb3IodmFyIGk9MDtpPHRoaXMudDsrK2kpcis9Y2JpdCh0aGlzW2ldXngpO3JldHVybiByfWZ1bmN0aW9uIGJuVGVzdEJpdChuKXt2YXIgaj1NYXRoLmZsb29yKG4vdGhpcy5EQik7aWYoaj49dGhpcy50KXJldHVybiB0aGlzLnMhPTA7cmV0dXJuKHRoaXNbal0mMTw8biV0aGlzLkRCKSE9MH1mdW5jdGlvbiBibnBDaGFuZ2VCaXQobixvcCl7dmFyIHI9QmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KG4pO3RoaXMuYml0d2lzZVRvKHIsb3Ascik7cmV0dXJuIHJ9ZnVuY3Rpb24gYm5TZXRCaXQobil7cmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3Bfb3IpfWZ1bmN0aW9uIGJuQ2xlYXJCaXQobil7cmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3BfYW5kbm90KX1mdW5jdGlvbiBibkZsaXBCaXQobil7cmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3BfeG9yKX1mdW5jdGlvbiBibnBBZGRUbyhhLHIpe3ZhciBzZWxmPXRoaXM7dmFyIGk9MCxjPTAsbT1NYXRoLm1pbihhLnQsc2VsZi50KTt3aGlsZShpPG0pe2MrPXNlbGZbaV0rYVtpXTtyW2krK109YyZzZWxmLkRNO2M+Pj1zZWxmLkRCfWlmKGEudDxzZWxmLnQpe2MrPWEuczt3aGlsZShpPHNlbGYudCl7Yys9c2VsZltpXTtyW2krK109YyZzZWxmLkRNO2M+Pj1zZWxmLkRCfWMrPXNlbGYuc31lbHNle2MrPXNlbGYuczt3aGlsZShpPGEudCl7Yys9YVtpXTtyW2krK109YyZzZWxmLkRNO2M+Pj1zZWxmLkRCfWMrPWEuc31yLnM9YzwwPy0xOjA7aWYoYz4wKXJbaSsrXT1jO2Vsc2UgaWYoYzwtMSlyW2krK109c2VsZi5EVitjO3IudD1pO3IuY2xhbXAoKX1mdW5jdGlvbiBibkFkZChhKXt2YXIgcj1uYmkoKTt0aGlzLmFkZFRvKGEscik7cmV0dXJuIHJ9ZnVuY3Rpb24gYm5TdWJ0cmFjdChhKXt2YXIgcj1uYmkoKTt0aGlzLnN1YlRvKGEscik7cmV0dXJuIHJ9ZnVuY3Rpb24gYm5NdWx0aXBseShhKXt2YXIgcj1uYmkoKTt0aGlzLm11bHRpcGx5VG8oYSxyKTtyZXR1cm4gcn1mdW5jdGlvbiBiblNxdWFyZSgpe3ZhciByPW5iaSgpO3RoaXMuc3F1YXJlVG8ocik7cmV0dXJuIHJ9ZnVuY3Rpb24gYm5EaXZpZGUoYSl7dmFyIHI9bmJpKCk7dGhpcy5kaXZSZW1UbyhhLHIsbnVsbCk7cmV0dXJuIHJ9ZnVuY3Rpb24gYm5SZW1haW5kZXIoYSl7dmFyIHI9bmJpKCk7dGhpcy5kaXZSZW1UbyhhLG51bGwscik7cmV0dXJuIHJ9ZnVuY3Rpb24gYm5EaXZpZGVBbmRSZW1haW5kZXIoYSl7dmFyIHE9bmJpKCkscj1uYmkoKTt0aGlzLmRpdlJlbVRvKGEscSxyKTtyZXR1cm4gbmV3IEFycmF5KHEscil9ZnVuY3Rpb24gYm5wRE11bHRpcGx5KG4pe3RoaXNbdGhpcy50XT10aGlzLmFtKDAsbi0xLHRoaXMsMCwwLHRoaXMudCk7Kyt0aGlzLnQ7dGhpcy5jbGFtcCgpfWZ1bmN0aW9uIGJucERBZGRPZmZzZXQobix3KXtpZihuPT0wKXJldHVybjt3aGlsZSh0aGlzLnQ8PXcpdGhpc1t0aGlzLnQrK109MDt0aGlzW3ddKz1uO3doaWxlKHRoaXNbd10+PXRoaXMuRFYpe3RoaXNbd10tPXRoaXMuRFY7aWYoKyt3Pj10aGlzLnQpdGhpc1t0aGlzLnQrK109MDsrK3RoaXNbd119fWZ1bmN0aW9uIE51bGxFeHAoKXt9ZnVuY3Rpb24gbk5vcCh4KXtyZXR1cm4geH1mdW5jdGlvbiBuTXVsVG8oeCx5LHIpe3gubXVsdGlwbHlUbyh5LHIpfWZ1bmN0aW9uIG5TcXJUbyh4LHIpe3guc3F1YXJlVG8ocil9TnVsbEV4cC5wcm90b3R5cGUuY29udmVydD1uTm9wO051bGxFeHAucHJvdG90eXBlLnJldmVydD1uTm9wO051bGxFeHAucHJvdG90eXBlLm11bFRvPW5NdWxUbztOdWxsRXhwLnByb3RvdHlwZS5zcXJUbz1uU3FyVG87ZnVuY3Rpb24gYm5Qb3coZSl7cmV0dXJuIHRoaXMuZXhwKGUsbmV3IE51bGxFeHApfWZ1bmN0aW9uIGJucE11bHRpcGx5TG93ZXJUbyhhLG4scil7dmFyIGk9TWF0aC5taW4odGhpcy50K2EudCxuKTtyLnM9MDtyLnQ9aTt3aGlsZShpPjApclstLWldPTA7dmFyIGo7Zm9yKGo9ci50LXRoaXMudDtpPGo7KytpKXJbaSt0aGlzLnRdPXRoaXMuYW0oMCxhW2ldLHIsaSwwLHRoaXMudCk7Zm9yKGo9TWF0aC5taW4oYS50LG4pO2k8ajsrK2kpdGhpcy5hbSgwLGFbaV0scixpLDAsbi1pKTtyLmNsYW1wKCl9ZnVuY3Rpb24gYm5wTXVsdGlwbHlVcHBlclRvKGEsbixyKXstLW47dmFyIGk9ci50PXRoaXMudCthLnQtbjtyLnM9MDt3aGlsZSgtLWk+PTApcltpXT0wO2ZvcihpPU1hdGgubWF4KG4tdGhpcy50LDApO2k8YS50OysraSlyW3RoaXMudCtpLW5dPXRoaXMuYW0obi1pLGFbaV0sciwwLDAsdGhpcy50K2ktbik7ci5jbGFtcCgpO3IuZHJTaGlmdFRvKDEscil9ZnVuY3Rpb24gQmFycmV0dChtKXt0aGlzLnIyPW5iaSgpO3RoaXMucTM9bmJpKCk7QmlnSW50ZWdlci5PTkUuZGxTaGlmdFRvKDIqbS50LHRoaXMucjIpO3RoaXMubXU9dGhpcy5yMi5kaXZpZGUobSk7dGhpcy5tPW19ZnVuY3Rpb24gYmFycmV0dENvbnZlcnQoeCl7aWYoeC5zPDB8fHgudD4yKnRoaXMubS50KXJldHVybiB4Lm1vZCh0aGlzLm0pO2Vsc2UgaWYoeC5jb21wYXJlVG8odGhpcy5tKTwwKXJldHVybiB4O2Vsc2V7dmFyIHI9bmJpKCk7eC5jb3B5VG8ocik7dGhpcy5yZWR1Y2Uocik7cmV0dXJuIHJ9fWZ1bmN0aW9uIGJhcnJldHRSZXZlcnQoeCl7cmV0dXJuIHh9ZnVuY3Rpb24gYmFycmV0dFJlZHVjZSh4KXt2YXIgc2VsZj10aGlzO3guZHJTaGlmdFRvKHNlbGYubS50LTEsc2VsZi5yMik7aWYoeC50PnNlbGYubS50KzEpe3gudD1zZWxmLm0udCsxO3guY2xhbXAoKX1zZWxmLm11Lm11bHRpcGx5VXBwZXJUbyhzZWxmLnIyLHNlbGYubS50KzEsc2VsZi5xMyk7c2VsZi5tLm11bHRpcGx5TG93ZXJUbyhzZWxmLnEzLHNlbGYubS50KzEsc2VsZi5yMik7d2hpbGUoeC5jb21wYXJlVG8oc2VsZi5yMik8MCl4LmRBZGRPZmZzZXQoMSxzZWxmLm0udCsxKTt4LnN1YlRvKHNlbGYucjIseCk7d2hpbGUoeC5jb21wYXJlVG8oc2VsZi5tKT49MCl4LnN1YlRvKHNlbGYubSx4KX1mdW5jdGlvbiBiYXJyZXR0U3FyVG8oeCxyKXt4LnNxdWFyZVRvKHIpO3RoaXMucmVkdWNlKHIpfWZ1bmN0aW9uIGJhcnJldHRNdWxUbyh4LHkscil7eC5tdWx0aXBseVRvKHkscik7dGhpcy5yZWR1Y2Uocil9QmFycmV0dC5wcm90b3R5cGUuY29udmVydD1iYXJyZXR0Q29udmVydDtCYXJyZXR0LnByb3RvdHlwZS5yZXZlcnQ9YmFycmV0dFJldmVydDtCYXJyZXR0LnByb3RvdHlwZS5yZWR1Y2U9YmFycmV0dFJlZHVjZTtCYXJyZXR0LnByb3RvdHlwZS5tdWxUbz1iYXJyZXR0TXVsVG87QmFycmV0dC5wcm90b3R5cGUuc3FyVG89YmFycmV0dFNxclRvO2Z1bmN0aW9uIGJuTW9kUG93KGUsbSl7dmFyIGk9ZS5iaXRMZW5ndGgoKSxrLHI9bmJ2KDEpLHo7aWYoaTw9MClyZXR1cm4gcjtlbHNlIGlmKGk8MTgpaz0xO2Vsc2UgaWYoaTw0OClrPTM7ZWxzZSBpZihpPDE0NClrPTQ7ZWxzZSBpZihpPDc2OClrPTU7ZWxzZSBrPTY7aWYoaTw4KXo9bmV3IENsYXNzaWMobSk7ZWxzZSBpZihtLmlzRXZlbigpKXo9bmV3IEJhcnJldHQobSk7ZWxzZSB6PW5ldyBNb250Z29tZXJ5KG0pO3ZhciBnPW5ldyBBcnJheSxuPTMsazE9ay0xLGttPSgxPDxrKS0xO2dbMV09ei5jb252ZXJ0KHRoaXMpO2lmKGs+MSl7dmFyIGcyPW5iaSgpO3ouc3FyVG8oZ1sxXSxnMik7d2hpbGUobjw9a20pe2dbbl09bmJpKCk7ei5tdWxUbyhnMixnW24tMl0sZ1tuXSk7bis9Mn19dmFyIGo9ZS50LTEsdyxpczE9dHJ1ZSxyMj1uYmkoKSx0O2k9bmJpdHMoZVtqXSktMTt3aGlsZShqPj0wKXtpZihpPj1rMSl3PWVbal0+PmktazEma207ZWxzZXt3PShlW2pdJigxPDxpKzEpLTEpPDxrMS1pO2lmKGo+MCl3fD1lW2otMV0+PnRoaXMuREIraS1rMX1uPWs7d2hpbGUoKHcmMSk9PTApe3c+Pj0xOy0tbn1pZigoaS09bik8MCl7aSs9dGhpcy5EQjstLWp9aWYoaXMxKXtnW3ddLmNvcHlUbyhyKTtpczE9ZmFsc2V9ZWxzZXt3aGlsZShuPjEpe3ouc3FyVG8ocixyMik7ei5zcXJUbyhyMixyKTtuLT0yfWlmKG4+MCl6LnNxclRvKHIscjIpO2Vsc2V7dD1yO3I9cjI7cjI9dH16Lm11bFRvKHIyLGdbd10scil9d2hpbGUoaj49MCYmKGVbal0mMTw8aSk9PTApe3ouc3FyVG8ocixyMik7dD1yO3I9cjI7cjI9dDtpZigtLWk8MCl7aT10aGlzLkRCLTE7LS1qfX19cmV0dXJuIHoucmV2ZXJ0KHIpfWZ1bmN0aW9uIGJuR0NEKGEpe3ZhciB4PXRoaXMuczwwP3RoaXMubmVnYXRlKCk6dGhpcy5jbG9uZSgpO3ZhciB5PWEuczwwP2EubmVnYXRlKCk6YS5jbG9uZSgpO2lmKHguY29tcGFyZVRvKHkpPDApe3ZhciB0PXg7eD15O3k9dH12YXIgaT14LmdldExvd2VzdFNldEJpdCgpLGc9eS5nZXRMb3dlc3RTZXRCaXQoKTtpZihnPDApcmV0dXJuIHg7aWYoaTxnKWc9aTtpZihnPjApe3guclNoaWZ0VG8oZyx4KTt5LnJTaGlmdFRvKGcseSl9d2hpbGUoeC5zaWdudW0oKT4wKXtpZigoaT14LmdldExvd2VzdFNldEJpdCgpKT4wKXguclNoaWZ0VG8oaSx4KTtpZigoaT15LmdldExvd2VzdFNldEJpdCgpKT4wKXkuclNoaWZ0VG8oaSx5KTtpZih4LmNvbXBhcmVUbyh5KT49MCl7eC5zdWJUbyh5LHgpO3guclNoaWZ0VG8oMSx4KX1lbHNle3kuc3ViVG8oeCx5KTt5LnJTaGlmdFRvKDEseSl9fWlmKGc+MCl5LmxTaGlmdFRvKGcseSk7cmV0dXJuIHl9ZnVuY3Rpb24gYm5wTW9kSW50KG4pe2lmKG48PTApcmV0dXJuIDA7dmFyIGQ9dGhpcy5EViVuLHI9dGhpcy5zPDA/bi0xOjA7aWYodGhpcy50PjApaWYoZD09MClyPXRoaXNbMF0lbjtlbHNlIGZvcih2YXIgaT10aGlzLnQtMTtpPj0wOy0taSlyPShkKnIrdGhpc1tpXSklbjtyZXR1cm4gcn1mdW5jdGlvbiBibk1vZEludmVyc2UobSl7dmFyIGFjPW0uaXNFdmVuKCk7aWYodGhpcy5pc0V2ZW4oKSYmYWN8fG0uc2lnbnVtKCk9PTApcmV0dXJuIEJpZ0ludGVnZXIuWkVSTzt2YXIgdT1tLmNsb25lKCksdj10aGlzLmNsb25lKCk7dmFyIGE9bmJ2KDEpLGI9bmJ2KDApLGM9bmJ2KDApLGQ9bmJ2KDEpO3doaWxlKHUuc2lnbnVtKCkhPTApe3doaWxlKHUuaXNFdmVuKCkpe3UuclNoaWZ0VG8oMSx1KTtpZihhYyl7aWYoIWEuaXNFdmVuKCl8fCFiLmlzRXZlbigpKXthLmFkZFRvKHRoaXMsYSk7Yi5zdWJUbyhtLGIpfWEuclNoaWZ0VG8oMSxhKX1lbHNlIGlmKCFiLmlzRXZlbigpKWIuc3ViVG8obSxiKTtiLnJTaGlmdFRvKDEsYil9d2hpbGUodi5pc0V2ZW4oKSl7di5yU2hpZnRUbygxLHYpO2lmKGFjKXtpZighYy5pc0V2ZW4oKXx8IWQuaXNFdmVuKCkpe2MuYWRkVG8odGhpcyxjKTtkLnN1YlRvKG0sZCl9Yy5yU2hpZnRUbygxLGMpfWVsc2UgaWYoIWQuaXNFdmVuKCkpZC5zdWJUbyhtLGQpO2QuclNoaWZ0VG8oMSxkKX1pZih1LmNvbXBhcmVUbyh2KT49MCl7dS5zdWJUbyh2LHUpO2lmKGFjKWEuc3ViVG8oYyxhKTtiLnN1YlRvKGQsYil9ZWxzZXt2LnN1YlRvKHUsdik7aWYoYWMpYy5zdWJUbyhhLGMpO2Quc3ViVG8oYixkKX19aWYodi5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpIT0wKXJldHVybiBCaWdJbnRlZ2VyLlpFUk87aWYoZC5jb21wYXJlVG8obSk+PTApcmV0dXJuIGQuc3VidHJhY3QobSk7aWYoZC5zaWdudW0oKTwwKWQuYWRkVG8obSxkKTtlbHNlIHJldHVybiBkO2lmKGQuc2lnbnVtKCk8MClyZXR1cm4gZC5hZGQobSk7ZWxzZSByZXR1cm4gZH1wcm90by5jaHVua1NpemU9Ym5wQ2h1bmtTaXplO3Byb3RvLnRvUmFkaXg9Ym5wVG9SYWRpeDtwcm90by5mcm9tUmFkaXg9Ym5wRnJvbVJhZGl4O3Byb3RvLmZyb21OdW1iZXI9Ym5wRnJvbU51bWJlcjtwcm90by5iaXR3aXNlVG89Ym5wQml0d2lzZVRvO3Byb3RvLmNoYW5nZUJpdD1ibnBDaGFuZ2VCaXQ7cHJvdG8uYWRkVG89Ym5wQWRkVG87cHJvdG8uZE11bHRpcGx5PWJucERNdWx0aXBseTtwcm90by5kQWRkT2Zmc2V0PWJucERBZGRPZmZzZXQ7cHJvdG8ubXVsdGlwbHlMb3dlclRvPWJucE11bHRpcGx5TG93ZXJUbztwcm90by5tdWx0aXBseVVwcGVyVG89Ym5wTXVsdGlwbHlVcHBlclRvO3Byb3RvLm1vZEludD1ibnBNb2RJbnQ7cHJvdG8uY2xvbmU9Ym5DbG9uZTtwcm90by5pbnRWYWx1ZT1ibkludFZhbHVlO3Byb3RvLmJ5dGVWYWx1ZT1ibkJ5dGVWYWx1ZTtwcm90by5zaG9ydFZhbHVlPWJuU2hvcnRWYWx1ZTtwcm90by5zaWdudW09Ym5TaWdOdW07cHJvdG8udG9CeXRlQXJyYXk9Ym5Ub0J5dGVBcnJheTtwcm90by5lcXVhbHM9Ym5FcXVhbHM7cHJvdG8ubWluPWJuTWluO3Byb3RvLm1heD1ibk1heDtwcm90by5hbmQ9Ym5BbmQ7cHJvdG8ub3I9Ym5Pcjtwcm90by54b3I9Ym5Yb3I7cHJvdG8uYW5kTm90PWJuQW5kTm90O3Byb3RvLm5vdD1ibk5vdDtwcm90by5zaGlmdExlZnQ9Ym5TaGlmdExlZnQ7cHJvdG8uc2hpZnRSaWdodD1iblNoaWZ0UmlnaHQ7cHJvdG8uZ2V0TG93ZXN0U2V0Qml0PWJuR2V0TG93ZXN0U2V0Qml0O3Byb3RvLmJpdENvdW50PWJuQml0Q291bnQ7cHJvdG8udGVzdEJpdD1iblRlc3RCaXQ7cHJvdG8uc2V0Qml0PWJuU2V0Qml0O3Byb3RvLmNsZWFyQml0PWJuQ2xlYXJCaXQ7cHJvdG8uZmxpcEJpdD1ibkZsaXBCaXQ7cHJvdG8uYWRkPWJuQWRkO3Byb3RvLnN1YnRyYWN0PWJuU3VidHJhY3Q7cHJvdG8ubXVsdGlwbHk9Ym5NdWx0aXBseTtwcm90by5kaXZpZGU9Ym5EaXZpZGU7cHJvdG8ucmVtYWluZGVyPWJuUmVtYWluZGVyO3Byb3RvLmRpdmlkZUFuZFJlbWFpbmRlcj1ibkRpdmlkZUFuZFJlbWFpbmRlcjtwcm90by5tb2RQb3c9Ym5Nb2RQb3c7cHJvdG8ubW9kSW52ZXJzZT1ibk1vZEludmVyc2U7cHJvdG8ucG93PWJuUG93O3Byb3RvLmdjZD1ibkdDRDtwcm90by5zcXVhcmU9Ym5TcXVhcmU7QmlnSW50ZWdlci5aRVJPPW5idigwKTtCaWdJbnRlZ2VyLk9ORT1uYnYoMSk7QmlnSW50ZWdlci52YWx1ZU9mPW5idjtCaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZD1mdW5jdGlvbihiYSl7aWYoQnVmZmVyLmlzQnVmZmVyKGJhKSl7YmE9QXJyYXkucHJvdG90eXBlLm1hcC5iaW5kKGJhLGZ1bmN0aW9uKHgpe3JldHVybiB4fSkoKX1pZighYmEubGVuZ3RoKXtyZXR1cm4gbmV3IEJpZ0ludGVnZXIudmFsdWVPZigwKX1lbHNlIGlmKGJhWzBdJjEyOCl7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKFswXS5jb25jYXQoYmEpKX1lbHNle3JldHVybiBuZXcgQmlnSW50ZWdlcihiYSl9fTtCaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlTaWduZWQ9ZnVuY3Rpb24oYmEpe2lmKGJhWzBdJjEyOCl7YmFbMF0mPTEyNztyZXR1cm4gQmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQoYmEpLm5lZ2F0ZSgpfWVsc2V7cmV0dXJuIEJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKGJhKX19O0JpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5VW5zaWduZWQ9ZnVuY3Rpb24oKXt2YXIgYmE9dGhpcy5hYnMoKS50b0J5dGVBcnJheSgpO2lmKCFiYS5sZW5ndGgpe3JldHVybiBiYX1pZihiYVswXT09PTApe2JhPWJhLnNsaWNlKDEpfWZvcih2YXIgaT0wO2k8YmEubGVuZ3RoOysraSl7YmFbaV09YmFbaV08MD9iYVtpXSsyNTY6YmFbaV19cmV0dXJuIGJhfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS50b0J5dGVBcnJheVNpZ25lZD1mdW5jdGlvbigpe3ZhciB2YWw9dGhpcy50b0J5dGVBcnJheVVuc2lnbmVkKCk7dmFyIG5lZz10aGlzLnM8MDtpZih2YWxbMF0mMTI4KXt2YWwudW5zaGlmdChuZWc/MTI4OjApfWVsc2UgaWYobmVnKXt2YWxbMF18PTEyOH1yZXR1cm4gdmFsfTttb2R1bGUuZXhwb3J0cz1CaWdJbnRlZ2VyfSkuY2FsbCh0aGlzLF9kZXJlcV8oXCJidWZmZXJcIikuQnVmZmVyKX0se2J1ZmZlcjo1fV0sNjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBFQ0N1cnZlRnA9X2RlcmVxXyhcIi4vZWNcIik7dmFyIEJpZ0ludGVnZXI9X2RlcmVxXyhcIi4vanNiblwiKTtmdW5jdGlvbiBYOUVDUGFyYW1ldGVycyhjdXJ2ZSxnLG4saCl7dGhpcy5jdXJ2ZT1jdXJ2ZTt0aGlzLmc9Zzt0aGlzLm49bjt0aGlzLmg9aH1mdW5jdGlvbiB4OWdldEN1cnZlKCl7cmV0dXJuIHRoaXMuY3VydmV9ZnVuY3Rpb24geDlnZXRHKCl7cmV0dXJuIHRoaXMuZ31mdW5jdGlvbiB4OWdldE4oKXtyZXR1cm4gdGhpcy5ufWZ1bmN0aW9uIHg5Z2V0SCgpe3JldHVybiB0aGlzLmh9WDlFQ1BhcmFtZXRlcnMucHJvdG90eXBlLmdldEN1cnZlPXg5Z2V0Q3VydmU7WDlFQ1BhcmFtZXRlcnMucHJvdG90eXBlLmdldEc9eDlnZXRHO1g5RUNQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXROPXg5Z2V0TjtYOUVDUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0SD14OWdldEg7ZnVuY3Rpb24gZnJvbUhleChzKXtyZXR1cm4gbmV3IEJpZ0ludGVnZXIocywxNil9ZnVuY3Rpb24gc2VjcDEyOHIxKCl7dmFyIHA9ZnJvbUhleChcIkZGRkZGRkZERkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGXCIpO3ZhciBhPWZyb21IZXgoXCJGRkZGRkZGREZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGQ1wiKTt2YXIgYj1mcm9tSGV4KFwiRTg3NTc5QzExMDc5RjQzREQ4MjQ5OTNDMkNFRTVFRDNcIik7dmFyIG49ZnJvbUhleChcIkZGRkZGRkZFMDAwMDAwMDA3NUEzMEQxQjkwMzhBMTE1XCIpO3ZhciBoPUJpZ0ludGVnZXIuT05FO3ZhciBjdXJ2ZT1uZXcgRUNDdXJ2ZUZwKHAsYSxiKTt2YXIgRz1jdXJ2ZS5kZWNvZGVQb2ludEhleChcIjA0XCIrXCIxNjFGRjc1MjhCODk5QjJEMEMyODYwN0NBNTJDNUI4NlwiK1wiQ0Y1QUM4Mzk1QkFGRUIxM0MwMkRBMjkyRERFRDdBODNcIik7cmV0dXJuIG5ldyBYOUVDUGFyYW1ldGVycyhjdXJ2ZSxHLG4saCl9ZnVuY3Rpb24gc2VjcDE2MGsxKCl7dmFyIHA9ZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZFRkZGRkFDNzNcIik7dmFyIGE9QmlnSW50ZWdlci5aRVJPO3ZhciBiPWZyb21IZXgoXCI3XCIpO3ZhciBuPWZyb21IZXgoXCIwMTAwMDAwMDAwMDAwMDAwMDAwMDAxQjhGQTE2REZBQjlBQ0ExNkI2QjNcIik7dmFyIGg9QmlnSW50ZWdlci5PTkU7dmFyIGN1cnZlPW5ldyBFQ0N1cnZlRnAocCxhLGIpO3ZhciBHPWN1cnZlLmRlY29kZVBvaW50SGV4KFwiMDRcIitcIjNCNEMzODJDRTM3QUExOTJBNDAxOUU3NjMwMzZGNEY1REQ0RDdFQkJcIitcIjkzOENGOTM1MzE4RkRDRUQ2QkMyODI4NjUzMTczM0MzRjAzQzRGRUVcIik7cmV0dXJuIG5ldyBYOUVDUGFyYW1ldGVycyhjdXJ2ZSxHLG4saCl9ZnVuY3Rpb24gc2VjcDE2MHIxKCl7dmFyIHA9ZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGN0ZGRkZGRkZcIik7dmFyIGE9ZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGN0ZGRkZGRkNcIik7dmFyIGI9ZnJvbUhleChcIjFDOTdCRUZDNTRCRDdBOEI2NUFDRjg5RjgxRDRENEFEQzU2NUZBNDVcIik7dmFyIG49ZnJvbUhleChcIjAxMDAwMDAwMDAwMDAwMDAwMDAwMDFGNEM4RjkyN0FFRDNDQTc1MjI1N1wiKTt2YXIgaD1CaWdJbnRlZ2VyLk9ORTt2YXIgY3VydmU9bmV3IEVDQ3VydmVGcChwLGEsYik7dmFyIEc9Y3VydmUuZGVjb2RlUG9pbnRIZXgoXCIwNFwiK1wiNEE5NkI1Njg4RUY1NzMyODQ2NjQ2OTg5NjhDMzhCQjkxM0NCRkM4MlwiK1wiMjNBNjI4NTUzMTY4OTQ3RDU5RENDOTEyMDQyMzUxMzc3QUM1RkIzMlwiKTtyZXR1cm4gbmV3IFg5RUNQYXJhbWV0ZXJzKGN1cnZlLEcsbixoKX1mdW5jdGlvbiBzZWNwMTkyazEoKXt2YXIgcD1mcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRUZGRkZFRTM3XCIpO3ZhciBhPUJpZ0ludGVnZXIuWkVSTzt2YXIgYj1mcm9tSGV4KFwiM1wiKTt2YXIgbj1mcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZFMjZGMkZDMTcwRjY5NDY2QTc0REVGRDhEXCIpO3ZhciBoPUJpZ0ludGVnZXIuT05FO3ZhciBjdXJ2ZT1uZXcgRUNDdXJ2ZUZwKHAsYSxiKTt2YXIgRz1jdXJ2ZS5kZWNvZGVQb2ludEhleChcIjA0XCIrXCJEQjRGRjEwRUMwNTdFOUFFMjZCMDdEMDI4MEI3RjQzNDFEQTVEMUIxRUFFMDZDN0RcIitcIjlCMkYyRjZEOUM1NjI4QTc4NDQxNjNEMDE1QkU4NjM0NDA4MkFBODhEOTVFMkY5RFwiKTtyZXR1cm4gbmV3IFg5RUNQYXJhbWV0ZXJzKGN1cnZlLEcsbixoKX1mdW5jdGlvbiBzZWNwMTkycjEoKXt2YXIgcD1mcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkVGRkZGRkZGRkZGRkZGRkZGXCIpO3ZhciBhPWZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRUZGRkZGRkZGRkZGRkZGRkNcIik7dmFyIGI9ZnJvbUhleChcIjY0MjEwNTE5RTU5QzgwRTcwRkE3RTlBQjcyMjQzMDQ5RkVCOERFRUNDMTQ2QjlCMVwiKTt2YXIgbj1mcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGOTlERUY4MzYxNDZCQzlCMUI0RDIyODMxXCIpO3ZhciBoPUJpZ0ludGVnZXIuT05FO3ZhciBjdXJ2ZT1uZXcgRUNDdXJ2ZUZwKHAsYSxiKTt2YXIgRz1jdXJ2ZS5kZWNvZGVQb2ludEhleChcIjA0XCIrXCIxODhEQTgwRUIwMzA5MEY2N0NCRjIwRUI0M0ExODgwMEY0RkYwQUZEODJGRjEwMTJcIitcIjA3MTkyQjk1RkZDOERBNzg2MzEwMTFFRDZCMjRDREQ1NzNGOTc3QTExRTc5NDgxMVwiKTtyZXR1cm4gbmV3IFg5RUNQYXJhbWV0ZXJzKGN1cnZlLEcsbixoKX1mdW5jdGlvbiBzZWNwMjI0cjEoKXt2YXIgcD1mcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFcIik7dmFyIGE9ZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZFRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZFXCIpO3ZhciBiPWZyb21IZXgoXCJCNDA1MEE4NTBDMDRCM0FCRjU0MTMyNTY1MDQ0QjBCN0Q3QkZEOEJBMjcwQjM5NDMyMzU1RkZCNFwiKTt2YXIgbj1mcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRjE2QTJFMEI4RjAzRTEzREQyOTQ1NUM1QzJBM0RcIik7dmFyIGg9QmlnSW50ZWdlci5PTkU7dmFyIGN1cnZlPW5ldyBFQ0N1cnZlRnAocCxhLGIpO3ZhciBHPWN1cnZlLmRlY29kZVBvaW50SGV4KFwiMDRcIitcIkI3MEUwQ0JENkJCNEJGN0YzMjEzOTBCOTRBMDNDMUQzNTZDMjExMjIzNDMyODBENjExNUMxRDIxXCIrXCJCRDM3NjM4OEI1RjcyM0ZCNEMyMkRGRTZDRDQzNzVBMDVBMDc0NzY0NDRENTgxOTk4NTAwN0UzNFwiKTtyZXR1cm4gbmV3IFg5RUNQYXJhbWV0ZXJzKGN1cnZlLEcsbixoKX1mdW5jdGlvbiBzZWNwMjU2azEoKXt2YXIgcD1mcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkVGRkZGRkMyRlwiKTt2YXIgYT1CaWdJbnRlZ2VyLlpFUk87dmFyIGI9ZnJvbUhleChcIjdcIik7dmFyIG49ZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZFQkFBRURDRTZBRjQ4QTAzQkJGRDI1RThDRDAzNjQxNDFcIik7dmFyIGg9QmlnSW50ZWdlci5PTkU7dmFyIGN1cnZlPW5ldyBFQ0N1cnZlRnAocCxhLGIpO3ZhciBHPWN1cnZlLmRlY29kZVBvaW50SGV4KFwiMDRcIitcIjc5QkU2NjdFRjlEQ0JCQUM1NUEwNjI5NUNFODcwQjA3MDI5QkZDREIyRENFMjhEOTU5RjI4MTVCMTZGODE3OThcIitcIjQ4M0FEQTc3MjZBM0M0NjU1REE0RkJGQzBFMTEwOEE4RkQxN0I0NDhBNjg1NTQxOTlDNDdEMDhGRkIxMEQ0QjhcIik7cmV0dXJuIG5ldyBYOUVDUGFyYW1ldGVycyhjdXJ2ZSxHLG4saCl9ZnVuY3Rpb24gc2VjcDI1NnIxKCl7dmFyIHA9ZnJvbUhleChcIkZGRkZGRkZGMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZcIik7dmFyIGE9ZnJvbUhleChcIkZGRkZGRkZGMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkNcIik7dmFyIGI9ZnJvbUhleChcIjVBQzYzNUQ4QUEzQTkzRTdCM0VCQkQ1NTc2OTg4NkJDNjUxRDA2QjBDQzUzQjBGNjNCQ0UzQzNFMjdEMjYwNEJcIik7dmFyIG49ZnJvbUhleChcIkZGRkZGRkZGMDAwMDAwMDBGRkZGRkZGRkZGRkZGRkZGQkNFNkZBQURBNzE3OUU4NEYzQjlDQUMyRkM2MzI1NTFcIik7dmFyIGg9QmlnSW50ZWdlci5PTkU7dmFyIGN1cnZlPW5ldyBFQ0N1cnZlRnAocCxhLGIpO3ZhciBHPWN1cnZlLmRlY29kZVBvaW50SGV4KFwiMDRcIitcIjZCMTdEMUYyRTEyQzQyNDdGOEJDRTZFNTYzQTQ0MEYyNzcwMzdEODEyREVCMzNBMEY0QTEzOTQ1RDg5OEMyOTZcIitcIjRGRTM0MkUyRkUxQTdGOUI4RUU3RUI0QTdDMEY5RTE2MkJDRTMzNTc2QjMxNUVDRUNCQjY0MDY4MzdCRjUxRjVcIik7cmV0dXJuIG5ldyBYOUVDUGFyYW1ldGVycyhjdXJ2ZSxHLG4saCl9ZnVuY3Rpb24gZ2V0U0VDQ3VydmVCeU5hbWUobmFtZSl7aWYobmFtZT09XCJzZWNwMTI4cjFcIilyZXR1cm4gc2VjcDEyOHIxKCk7aWYobmFtZT09XCJzZWNwMTYwazFcIilyZXR1cm4gc2VjcDE2MGsxKCk7aWYobmFtZT09XCJzZWNwMTYwcjFcIilyZXR1cm4gc2VjcDE2MHIxKCk7aWYobmFtZT09XCJzZWNwMTkyazFcIilyZXR1cm4gc2VjcDE5MmsxKCk7aWYobmFtZT09XCJzZWNwMTkycjFcIilyZXR1cm4gc2VjcDE5MnIxKCk7aWYobmFtZT09XCJzZWNwMjI0cjFcIilyZXR1cm4gc2VjcDIyNHIxKCk7aWYobmFtZT09XCJzZWNwMjU2azFcIilyZXR1cm4gc2VjcDI1NmsxKCk7aWYobmFtZT09XCJzZWNwMjU2cjFcIilyZXR1cm4gc2VjcDI1NnIxKCk7cmV0dXJuIG51bGx9bW9kdWxlLmV4cG9ydHM9Z2V0U0VDQ3VydmVCeU5hbWV9LHtcIi4vZWNcIjo2MixcIi4vanNiblwiOjYzfV0sNjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBBZGRyZXNzPV9kZXJlcV8oXCIuL2FkZHJlc3NcIik7dmFyIGNvbnZlcnQ9X2RlcmVxXyhcIi4vY29udmVydFwiKTt2YXIgZWNkc2E9X2RlcmVxXyhcIi4vZWNkc2FcIik7dmFyIEVDUHViS2V5PV9kZXJlcV8oXCIuL2Vja2V5XCIpLkVDUHViS2V5O3ZhciBTSEEyNTY9X2RlcmVxXyhcImNyeXB0by1qcy9zaGEyNTZcIik7dmFyIG1hZ2ljQnl0ZXM9Y29udmVydC5zdHJpbmdUb0J5dGVzKFwiQml0Y29pbiBTaWduZWQgTWVzc2FnZTpcXG5cIik7ZnVuY3Rpb24gbWFnaWNIYXNoKG1lc3NhZ2Upe3ZhciBtZXNzYWdlQnl0ZXM9Y29udmVydC5zdHJpbmdUb0J5dGVzKG1lc3NhZ2UpO3ZhciBidWZmZXI9W10uY29uY2F0KGNvbnZlcnQubnVtVG9WYXJJbnQobWFnaWNCeXRlcy5sZW5ndGgpLG1hZ2ljQnl0ZXMsY29udmVydC5udW1Ub1ZhckludChtZXNzYWdlQnl0ZXMubGVuZ3RoKSxtZXNzYWdlQnl0ZXMpO1xucmV0dXJuIGNvbnZlcnQud29yZEFycmF5VG9CeXRlcyhTSEEyNTYoU0hBMjU2KGNvbnZlcnQuYnl0ZXNUb1dvcmRBcnJheShidWZmZXIpKSkpfWZ1bmN0aW9uIHNpZ24oa2V5LG1lc3NhZ2Upe3ZhciBoYXNoPW1hZ2ljSGFzaChtZXNzYWdlKTt2YXIgc2lnPWtleS5zaWduKGhhc2gpO3ZhciBvYmo9ZWNkc2EucGFyc2VTaWcoc2lnKTt2YXIgaT1lY2RzYS5jYWxjUHViS2V5UmVjb3ZlcnlQYXJhbShrZXkuZ2V0UHViKCkucHViLG9iai5yLG9iai5zLGhhc2gpO2krPTI3O2lmKGtleS5jb21wcmVzc2VkKXtpKz00fXZhciByQmE9b2JqLnIudG9CeXRlQXJyYXlVbnNpZ25lZCgpO3ZhciBzQmE9b2JqLnMudG9CeXRlQXJyYXlVbnNpZ25lZCgpO3doaWxlKHJCYS5sZW5ndGg8MzIpckJhLnVuc2hpZnQoMCk7d2hpbGUoc0JhLmxlbmd0aDwzMilzQmEudW5zaGlmdCgwKTtzaWc9W2ldLmNvbmNhdChyQmEsc0JhKTtyZXR1cm4gc2lnfWZ1bmN0aW9uIHZlcmlmeShhZGRyZXNzLHNpZyxtZXNzYWdlKXtzaWc9ZWNkc2EucGFyc2VTaWdDb21wYWN0KHNpZyk7dmFyIHB1YktleT1uZXcgRUNQdWJLZXkoZWNkc2EucmVjb3ZlclB1YktleShzaWcucixzaWcucyxtYWdpY0hhc2gobWVzc2FnZSksc2lnLmkpKTt2YXIgaXNDb21wcmVzc2VkPSEhKHNpZy5pJjQpO3B1YktleS5jb21wcmVzc2VkPWlzQ29tcHJlc3NlZDthZGRyZXNzPW5ldyBBZGRyZXNzKGFkZHJlc3MpO3JldHVybiBwdWJLZXkuZ2V0QWRkcmVzcyhhZGRyZXNzLnZlcnNpb24pLnRvU3RyaW5nKCk9PT1hZGRyZXNzLnRvU3RyaW5nKCl9bW9kdWxlLmV4cG9ydHM9e21hZ2ljSGFzaDptYWdpY0hhc2gsc2lnbjpzaWduLHZlcmlmeTp2ZXJpZnl9fSx7XCIuL2FkZHJlc3NcIjo1NCxcIi4vY29udmVydFwiOjU3LFwiLi9lY2RzYVwiOjU4LFwiLi9lY2tleVwiOjU5LFwiY3J5cHRvLWpzL3NoYTI1NlwiOjQ3fV0sNjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPXttYWlubmV0OnthZGRyZXNzVmVyc2lvbjowLHAyc2hWZXJzaW9uOjUsaGRWZXJzaW9uczp7cHViOjc2MDY3MzU4LHByaXY6NzYwNjYyNzZ9fSx0ZXN0bmV0OnthZGRyZXNzVmVyc2lvbjoxMTEscDJzaFZlcnNpb246MTk2LGhkVmVyc2lvbnM6e3B1Yjo3MDYxNzAzOSxwcml2OjcwNjE1OTU2fX19fSx7fV0sNjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBPcGNvZGU9e21hcDp7T1BfMDowLE9QX0ZBTFNFOjAsT1BfUFVTSERBVEExOjc2LE9QX1BVU0hEQVRBMjo3NyxPUF9QVVNIREFUQTQ6NzgsT1BfMU5FR0FURTo3OSxPUF9SRVNFUlZFRDo4MCxPUF8xOjgxLE9QX1RSVUU6ODEsT1BfMjo4MixPUF8zOjgzLE9QXzQ6ODQsT1BfNTo4NSxPUF82Ojg2LE9QXzc6ODcsT1BfODo4OCxPUF85Ojg5LE9QXzEwOjkwLE9QXzExOjkxLE9QXzEyOjkyLE9QXzEzOjkzLE9QXzE0Ojk0LE9QXzE1Ojk1LE9QXzE2Ojk2LE9QX05PUDo5NyxPUF9WRVI6OTgsT1BfSUY6OTksT1BfTk9USUY6MTAwLE9QX1ZFUklGOjEwMSxPUF9WRVJOT1RJRjoxMDIsT1BfRUxTRToxMDMsT1BfRU5ESUY6MTA0LE9QX1ZFUklGWToxMDUsT1BfUkVUVVJOOjEwNixPUF9UT0FMVFNUQUNLOjEwNyxPUF9GUk9NQUxUU1RBQ0s6MTA4LE9QXzJEUk9QOjEwOSxPUF8yRFVQOjExMCxPUF8zRFVQOjExMSxPUF8yT1ZFUjoxMTIsT1BfMlJPVDoxMTMsT1BfMlNXQVA6MTE0LE9QX0lGRFVQOjExNSxPUF9ERVBUSDoxMTYsT1BfRFJPUDoxMTcsT1BfRFVQOjExOCxPUF9OSVA6MTE5LE9QX09WRVI6MTIwLE9QX1BJQ0s6MTIxLE9QX1JPTEw6MTIyLE9QX1JPVDoxMjMsT1BfU1dBUDoxMjQsT1BfVFVDSzoxMjUsT1BfQ0FUOjEyNixPUF9TVUJTVFI6MTI3LE9QX0xFRlQ6MTI4LE9QX1JJR0hUOjEyOSxPUF9TSVpFOjEzMCxPUF9JTlZFUlQ6MTMxLE9QX0FORDoxMzIsT1BfT1I6MTMzLE9QX1hPUjoxMzQsT1BfRVFVQUw6MTM1LE9QX0VRVUFMVkVSSUZZOjEzNixPUF9SRVNFUlZFRDE6MTM3LE9QX1JFU0VSVkVEMjoxMzgsT1BfMUFERDoxMzksT1BfMVNVQjoxNDAsT1BfMk1VTDoxNDEsT1BfMkRJVjoxNDIsT1BfTkVHQVRFOjE0MyxPUF9BQlM6MTQ0LE9QX05PVDoxNDUsT1BfME5PVEVRVUFMOjE0NixPUF9BREQ6MTQ3LE9QX1NVQjoxNDgsT1BfTVVMOjE0OSxPUF9ESVY6MTUwLE9QX01PRDoxNTEsT1BfTFNISUZUOjE1MixPUF9SU0hJRlQ6MTUzLE9QX0JPT0xBTkQ6MTU0LE9QX0JPT0xPUjoxNTUsT1BfTlVNRVFVQUw6MTU2LE9QX05VTUVRVUFMVkVSSUZZOjE1NyxPUF9OVU1OT1RFUVVBTDoxNTgsT1BfTEVTU1RIQU46MTU5LE9QX0dSRUFURVJUSEFOOjE2MCxPUF9MRVNTVEhBTk9SRVFVQUw6MTYxLE9QX0dSRUFURVJUSEFOT1JFUVVBTDoxNjIsT1BfTUlOOjE2MyxPUF9NQVg6MTY0LE9QX1dJVEhJTjoxNjUsT1BfUklQRU1EMTYwOjE2NixPUF9TSEExOjE2NyxPUF9TSEEyNTY6MTY4LE9QX0hBU0gxNjA6MTY5LE9QX0hBU0gyNTY6MTcwLE9QX0NPREVTRVBBUkFUT1I6MTcxLE9QX0NIRUNLU0lHOjE3MixPUF9DSEVDS1NJR1ZFUklGWToxNzMsT1BfQ0hFQ0tNVUxUSVNJRzoxNzQsT1BfQ0hFQ0tNVUxUSVNJR1ZFUklGWToxNzUsT1BfTk9QMToxNzYsT1BfTk9QMjoxNzcsT1BfTk9QMzoxNzgsT1BfTk9QNDoxNzksT1BfTk9QNToxODAsT1BfTk9QNjoxODEsT1BfTk9QNzoxODIsT1BfTk9QODoxODMsT1BfTk9QOToxODQsT1BfTk9QMTA6MTg1LE9QX1BVQktFWUhBU0g6MjUzLE9QX1BVQktFWToyNTQsT1BfSU5WQUxJRE9QQ09ERToyNTV9LHJldmVyc2VNYXA6W119O2Zvcih2YXIgaSBpbiBPcGNvZGUubWFwKXtPcGNvZGUucmV2ZXJzZU1hcFtPcGNvZGUubWFwW2ldXT1pfW1vZHVsZS5leHBvcnRzPU9wY29kZX0se31dLDY4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oQnVmZmVyKXt2YXIgT3Bjb2RlPV9kZXJlcV8oXCIuL29wY29kZVwiKTt2YXIgdXRpbD1fZGVyZXFfKFwiLi91dGlsXCIpO3ZhciBjb252ZXJ0PV9kZXJlcV8oXCIuL2NvbnZlcnRcIik7dmFyIEFkZHJlc3M9X2RlcmVxXyhcIi4vYWRkcmVzc1wiKTt2YXIgbmV0d29yaz1fZGVyZXFfKFwiLi9uZXR3b3JrXCIpO3ZhciBTY3JpcHQ9ZnVuY3Rpb24oZGF0YSl7dGhpcy5idWZmZXI9ZGF0YXx8W107aWYoIUFycmF5LmlzQXJyYXkodGhpcy5idWZmZXIpKXt0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3QgU2NyaXB0IHRvIGJlIGluaXRpYWxpemVkIHdpdGggQXJyYXksIGJ1dCBnb3QgXCIrZGF0YSl9dGhpcy5wYXJzZSgpfTtTY3JpcHQuZnJvbUhleD1mdW5jdGlvbihkYXRhKXtyZXR1cm4gbmV3IFNjcmlwdChjb252ZXJ0LmhleFRvQnl0ZXMoZGF0YSkpfTtTY3JpcHQuZnJvbVB1YktleT1mdW5jdGlvbihzdHIpe3ZhciBzY3JpcHQ9bmV3IFNjcmlwdDt2YXIgcz1zdHIuc3BsaXQoXCIgXCIpO2Zvcih2YXIgaSBpbiBzKXtpZihPcGNvZGUubWFwLmhhc093blByb3BlcnR5KHNbaV0pKXtzY3JpcHQud3JpdGVPcChPcGNvZGUubWFwW3NbaV1dKX1lbHNle3NjcmlwdC53cml0ZUJ5dGVzKGNvbnZlcnQuaGV4VG9CeXRlcyhzW2ldKSl9fXJldHVybiBzY3JpcHR9O1NjcmlwdC5mcm9tU2NyaXB0U2lnPWZ1bmN0aW9uKHN0cil7dmFyIHNjcmlwdD1uZXcgU2NyaXB0O3ZhciBzPXN0ci5zcGxpdChcIiBcIik7Zm9yKHZhciBpIGluIHMpe2lmKE9wY29kZS5tYXAuaGFzT3duUHJvcGVydHkoc1tpXSkpe3NjcmlwdC53cml0ZU9wKE9wY29kZS5tYXBbc1tpXV0pfWVsc2V7c2NyaXB0LndyaXRlQnl0ZXMoY29udmVydC5oZXhUb0J5dGVzKHNbaV0pKX19cmV0dXJuIHNjcmlwdH07U2NyaXB0LnByb3RvdHlwZS5wYXJzZT1mdW5jdGlvbigpe3ZhciBzZWxmPXRoaXM7dGhpcy5jaHVua3M9W107dmFyIGk9MDtmdW5jdGlvbiByZWFkQ2h1bmsobil7c2VsZi5jaHVua3MucHVzaChzZWxmLmJ1ZmZlci5zbGljZShpLGkrbikpO2krPW59d2hpbGUoaTx0aGlzLmJ1ZmZlci5sZW5ndGgpe3ZhciBvcGNvZGU9dGhpcy5idWZmZXJbaSsrXTtpZihvcGNvZGU+PTI0MCl7b3Bjb2RlPW9wY29kZTw8OHx0aGlzLmJ1ZmZlcltpKytdfXZhciBsZW47aWYob3Bjb2RlPjAmJm9wY29kZTxPcGNvZGUubWFwLk9QX1BVU0hEQVRBMSl7cmVhZENodW5rKG9wY29kZSl9ZWxzZSBpZihvcGNvZGU9PU9wY29kZS5tYXAuT1BfUFVTSERBVEExKXtsZW49dGhpcy5idWZmZXJbaSsrXTtyZWFkQ2h1bmsobGVuKX1lbHNlIGlmKG9wY29kZT09T3Bjb2RlLm1hcC5PUF9QVVNIREFUQTIpe2xlbj10aGlzLmJ1ZmZlcltpKytdPDw4fHRoaXMuYnVmZmVyW2krK107cmVhZENodW5rKGxlbil9ZWxzZSBpZihvcGNvZGU9PU9wY29kZS5tYXAuT1BfUFVTSERBVEE0KXtsZW49dGhpcy5idWZmZXJbaSsrXTw8MjR8dGhpcy5idWZmZXJbaSsrXTw8MTZ8dGhpcy5idWZmZXJbaSsrXTw8OHx0aGlzLmJ1ZmZlcltpKytdO3JlYWRDaHVuayhsZW4pfWVsc2V7dGhpcy5jaHVua3MucHVzaChvcGNvZGUpfX19O1NjcmlwdC5wcm90b3R5cGUuZ2V0T3V0VHlwZT1mdW5jdGlvbigpe2lmKHRoaXMuY2h1bmtzW3RoaXMuY2h1bmtzLmxlbmd0aC0xXT09T3Bjb2RlLm1hcC5PUF9FUVVBTCYmdGhpcy5jaHVua3NbMF09PU9wY29kZS5tYXAuT1BfSEFTSDE2MCYmdGhpcy5jaHVua3MubGVuZ3RoPT0zKXtyZXR1cm5cIlAyU0hcIn1lbHNlIGlmKHRoaXMuY2h1bmtzLmxlbmd0aD09NSYmdGhpcy5jaHVua3NbMF09PU9wY29kZS5tYXAuT1BfRFVQJiZ0aGlzLmNodW5rc1sxXT09T3Bjb2RlLm1hcC5PUF9IQVNIMTYwJiZ0aGlzLmNodW5rc1szXT09T3Bjb2RlLm1hcC5PUF9FUVVBTFZFUklGWSYmdGhpcy5jaHVua3NbNF09PU9wY29kZS5tYXAuT1BfQ0hFQ0tTSUcpe3JldHVyblwiUHVia2V5XCJ9ZWxzZXtyZXR1cm5cIlN0cmFuZ2VcIn19O1NjcmlwdC5wcm90b3R5cGUudG9TY3JpcHRIYXNoPWZ1bmN0aW9uKCl7dmFyIG91dFR5cGU9dGhpcy5nZXRPdXRUeXBlKCk7aWYob3V0VHlwZT09XCJQdWJrZXlcIil7cmV0dXJuIHRoaXMuY2h1bmtzWzJdfWlmKG91dFR5cGU9PVwiUDJTSFwiKXtyZXR1cm4gdXRpbC5zaGEyNTZyaXBlMTYwKHRoaXMuYnVmZmVyKX1yZXR1cm4gdXRpbC5zaGEyNTZyaXBlMTYwKHRoaXMuYnVmZmVyKX07U2NyaXB0LnByb3RvdHlwZS5nZXRUb0FkZHJlc3M9ZnVuY3Rpb24oKXt2YXIgb3V0VHlwZT10aGlzLmdldE91dFR5cGUoKTtpZihvdXRUeXBlPT1cIlB1YmtleVwiKXtyZXR1cm4gbmV3IEFkZHJlc3ModGhpcy5jaHVua3NbMl0pfWlmKG91dFR5cGU9PVwiUDJTSFwiKXtyZXR1cm4gbmV3IEFkZHJlc3ModGhpcy5jaHVua3NbMV0sNSl9cmV0dXJuIG5ldyBBZGRyZXNzKHRoaXMuY2h1bmtzWzFdLDUpfTtTY3JpcHQucHJvdG90eXBlLmdldEZyb21BZGRyZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBBZGRyZXNzKHRoaXMuc2ltcGxlSW5IYXNoKCkpfTtTY3JpcHQucHJvdG90eXBlLmdldEluVHlwZT1mdW5jdGlvbigpe2lmKHRoaXMuY2h1bmtzLmxlbmd0aD09MSYmQXJyYXkuaXNBcnJheSh0aGlzLmNodW5rc1swXSkpe3JldHVyblwiUHVia2V5XCJ9ZWxzZSBpZih0aGlzLmNodW5rcy5sZW5ndGg9PTImJkFycmF5LmlzQXJyYXkodGhpcy5jaHVua3NbMF0pJiZBcnJheS5pc0FycmF5KHRoaXMuY2h1bmtzWzFdKSl7cmV0dXJuXCJBZGRyZXNzXCJ9ZWxzZSBpZih0aGlzLmNodW5rc1swXT09T3Bjb2RlLm1hcC5PUF8wJiZ0aGlzLmNodW5rcy5zbGljZSgxKS5yZWR1Y2UoZnVuY3Rpb24odCxjaHVuayxpKXtyZXR1cm4gdCYmQXJyYXkuaXNBcnJheShjaHVuaykmJihjaHVua1swXT09NDh8fGk9PXRoaXMuY2h1bmtzLmxlbmd0aC0xKX0sdHJ1ZSkpe3JldHVyblwiTXVsdGlzaWdcIn1lbHNle3JldHVyblwiU3RyYW5nZVwifX07U2NyaXB0LnByb3RvdHlwZS5zaW1wbGVJblB1YktleT1mdW5jdGlvbigpe3N3aXRjaCh0aGlzLmdldEluVHlwZSgpKXtjYXNlXCJBZGRyZXNzXCI6cmV0dXJuIHRoaXMuY2h1bmtzWzFdO2Nhc2VcIlB1YmtleVwiOnRocm93IG5ldyBFcnJvcihcIlNjcmlwdCBkb2VzIG5vdCBjb250YWluIHB1YmtleVwiKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIkVuY291bnRlcmVkIG5vbi1zdGFuZGFyZCBzY3JpcHRTaWdcIil9fTtTY3JpcHQucHJvdG90eXBlLnNpbXBsZUluSGFzaD1mdW5jdGlvbigpe3JldHVybiB1dGlsLnNoYTI1NnJpcGUxNjAodGhpcy5zaW1wbGVJblB1YktleSgpKX07U2NyaXB0LnByb3RvdHlwZS5zaW1wbGVJblB1YktleUhhc2g9U2NyaXB0LnByb3RvdHlwZS5zaW1wbGVJbkhhc2g7U2NyaXB0LnByb3RvdHlwZS53cml0ZU9wPWZ1bmN0aW9uKG9wY29kZSl7dGhpcy5idWZmZXIucHVzaChvcGNvZGUpO3RoaXMuY2h1bmtzLnB1c2gob3Bjb2RlKX07U2NyaXB0LnByb3RvdHlwZS53cml0ZUJ5dGVzPWZ1bmN0aW9uKGRhdGEpe2lmKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSl7ZGF0YT1BcnJheS5wcm90b3R5cGUubWFwLmJpbmQoZGF0YSxmdW5jdGlvbih4KXtyZXR1cm4geH0pKCl9aWYoZGF0YS5sZW5ndGg8T3Bjb2RlLm1hcC5PUF9QVVNIREFUQTEpe3RoaXMuYnVmZmVyLnB1c2goZGF0YS5sZW5ndGgpfWVsc2UgaWYoZGF0YS5sZW5ndGg8PTI1NSl7dGhpcy5idWZmZXIucHVzaChPcGNvZGUubWFwLk9QX1BVU0hEQVRBMSk7dGhpcy5idWZmZXIucHVzaChkYXRhLmxlbmd0aCl9ZWxzZSBpZihkYXRhLmxlbmd0aDw9NjU1MzUpe3RoaXMuYnVmZmVyLnB1c2goT3Bjb2RlLm1hcC5PUF9QVVNIREFUQTIpO3RoaXMuYnVmZmVyLnB1c2goZGF0YS5sZW5ndGgmMjU1KTt0aGlzLmJ1ZmZlci5wdXNoKGRhdGEubGVuZ3RoPj4+OCYyNTUpfWVsc2V7dGhpcy5idWZmZXIucHVzaChPcGNvZGUubWFwLk9QX1BVU0hEQVRBNCk7dGhpcy5idWZmZXIucHVzaChkYXRhLmxlbmd0aCYyNTUpO3RoaXMuYnVmZmVyLnB1c2goZGF0YS5sZW5ndGg+Pj44JjI1NSk7dGhpcy5idWZmZXIucHVzaChkYXRhLmxlbmd0aD4+PjE2JjI1NSk7dGhpcy5idWZmZXIucHVzaChkYXRhLmxlbmd0aD4+PjI0JjI1NSl9dGhpcy5idWZmZXI9dGhpcy5idWZmZXIuY29uY2F0KGRhdGEpO3RoaXMuY2h1bmtzLnB1c2goZGF0YSl9O1NjcmlwdC5jcmVhdGVPdXRwdXRTY3JpcHQ9ZnVuY3Rpb24oYWRkcmVzcyl7dmFyIHNjcmlwdD1uZXcgU2NyaXB0O2FkZHJlc3M9bmV3IEFkZHJlc3MoYWRkcmVzcyk7aWYoYWRkcmVzcy52ZXJzaW9uPT1uZXR3b3JrLm1haW5uZXQucDJzaFZlcnNpb258fGFkZHJlc3MudmVyc2lvbj09bmV0d29yay50ZXN0bmV0LnAyc2hWZXJzaW9uKXtzY3JpcHQud3JpdGVPcChPcGNvZGUubWFwLk9QX0hBU0gxNjApO3NjcmlwdC53cml0ZUJ5dGVzKGFkZHJlc3MuaGFzaCk7c2NyaXB0LndyaXRlT3AoT3Bjb2RlLm1hcC5PUF9FUVVBTCl9ZWxzZXtzY3JpcHQud3JpdGVPcChPcGNvZGUubWFwLk9QX0RVUCk7c2NyaXB0LndyaXRlT3AoT3Bjb2RlLm1hcC5PUF9IQVNIMTYwKTtzY3JpcHQud3JpdGVCeXRlcyhhZGRyZXNzLmhhc2gpO3NjcmlwdC53cml0ZU9wKE9wY29kZS5tYXAuT1BfRVFVQUxWRVJJRlkpO3NjcmlwdC53cml0ZU9wKE9wY29kZS5tYXAuT1BfQ0hFQ0tTSUcpfXJldHVybiBzY3JpcHR9O1NjcmlwdC5wcm90b3R5cGUuZXh0cmFjdFB1YmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaHVua3MuZmlsdGVyKGZ1bmN0aW9uKGNodW5rKXtyZXR1cm4gY2h1bmtbMF09PTQmJmNodW5rLmxlbmd0aD09NjV8fGNodW5rWzBdPDQmJmNodW5rLmxlbmd0aD09MzN9KX07U2NyaXB0LmNyZWF0ZU11bHRpU2lnT3V0cHV0U2NyaXB0PWZ1bmN0aW9uKG0scHVia2V5cyl7dmFyIHNjcmlwdD1uZXcgU2NyaXB0O3B1YmtleXM9cHVia2V5cy5zb3J0KCk7c2NyaXB0LndyaXRlT3AoT3Bjb2RlLm1hcC5PUF8xK20tMSk7Zm9yKHZhciBpPTA7aTxwdWJrZXlzLmxlbmd0aDsrK2kpe3NjcmlwdC53cml0ZUJ5dGVzKHB1YmtleXNbaV0pfXNjcmlwdC53cml0ZU9wKE9wY29kZS5tYXAuT1BfMStwdWJrZXlzLmxlbmd0aC0xKTtzY3JpcHQud3JpdGVPcChPcGNvZGUubWFwLk9QX0NIRUNLTVVMVElTSUcpO3JldHVybiBzY3JpcHR9O1NjcmlwdC5jcmVhdGVJbnB1dFNjcmlwdD1mdW5jdGlvbihzaWduYXR1cmUscHViS2V5KXt2YXIgc2NyaXB0PW5ldyBTY3JpcHQ7c2NyaXB0LndyaXRlQnl0ZXMoc2lnbmF0dXJlKTtzY3JpcHQud3JpdGVCeXRlcyhwdWJLZXkpO3JldHVybiBzY3JpcHR9O1NjcmlwdC5jcmVhdGVNdWx0aVNpZ0lucHV0U2NyaXB0PWZ1bmN0aW9uKHNpZ25hdHVyZXMsc2NyaXB0KXtzY3JpcHQ9bmV3IFNjcmlwdChzY3JpcHQpO3ZhciBrPXNjcmlwdC5jaHVua3NbMF1bMF07aWYoc2lnbmF0dXJlcy5sZW5ndGg8aylyZXR1cm4gZmFsc2U7dmFyIGluU2NyaXB0PW5ldyBTY3JpcHQ7aW5TY3JpcHQud3JpdGVPcChPcGNvZGUubWFwLk9QXzApO3NpZ25hdHVyZXMubWFwKGZ1bmN0aW9uKHNpZyl7aW5TY3JpcHQud3JpdGVCeXRlcyhzaWcpfSk7aW5TY3JpcHQud3JpdGVCeXRlcyhzY3JpcHQuYnVmZmVyKTtyZXR1cm4gaW5TY3JpcHR9O1NjcmlwdC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNjcmlwdCh0aGlzLmJ1ZmZlcil9O21vZHVsZS5leHBvcnRzPVNjcmlwdH0pLmNhbGwodGhpcyxfZGVyZXFfKFwiYnVmZmVyXCIpLkJ1ZmZlcil9LHtcIi4vYWRkcmVzc1wiOjU0LFwiLi9jb252ZXJ0XCI6NTcsXCIuL25ldHdvcmtcIjo2NixcIi4vb3Bjb2RlXCI6NjcsXCIuL3V0aWxcIjo3MCxidWZmZXI6NX1dLDY5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgQmlnSW50ZWdlcj1fZGVyZXFfKFwiLi9qc2JuL2pzYm5cIik7dmFyIFNjcmlwdD1fZGVyZXFfKFwiLi9zY3JpcHRcIik7dmFyIHV0aWw9X2RlcmVxXyhcIi4vdXRpbFwiKTt2YXIgY29udmVydD1fZGVyZXFfKFwiLi9jb252ZXJ0XCIpO3ZhciBFQ0tleT1fZGVyZXFfKFwiLi9lY2tleVwiKS5FQ0tleTt2YXIgRUNEU0E9X2RlcmVxXyhcIi4vZWNkc2FcIik7dmFyIEFkZHJlc3M9X2RlcmVxXyhcIi4vYWRkcmVzc1wiKTt2YXIgU0hBMjU2PV9kZXJlcV8oXCJjcnlwdG8tanMvc2hhMjU2XCIpO3ZhciBUcmFuc2FjdGlvbj1mdW5jdGlvbihkb2Mpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSl7cmV0dXJuIG5ldyBUcmFuc2FjdGlvbihkb2MpfXRoaXMudmVyc2lvbj0xO3RoaXMubG9ja3RpbWU9MDt0aGlzLmlucz1bXTt0aGlzLm91dHM9W107dGhpcy5kZWZhdWx0U2VxdWVuY2U9WzI1NSwyNTUsMjU1LDI1NV07aWYoZG9jKXtpZih0eXBlb2YgZG9jPT1cInN0cmluZ1wifHxBcnJheS5pc0FycmF5KGRvYykpe2RvYz1UcmFuc2FjdGlvbi5kZXNlcmlhbGl6ZShkb2MpfWlmKGRvYy5oYXNoKXRoaXMuaGFzaD1kb2MuaGFzaDtpZihkb2MudmVyc2lvbil0aGlzLnZlcnNpb249ZG9jLnZlcnNpb247aWYoZG9jLmxvY2t0aW1lKXRoaXMubG9ja3RpbWU9ZG9jLmxvY2t0aW1lO2lmKGRvYy5pbnMmJmRvYy5pbnMubGVuZ3RoKXtkb2MuaW5zLmZvckVhY2goZnVuY3Rpb24oaW5wdXQpe3RoaXMuYWRkSW5wdXQobmV3IFRyYW5zYWN0aW9uSW4oaW5wdXQpKX0sdGhpcyl9aWYoZG9jLm91dHMmJmRvYy5vdXRzLmxlbmd0aCl7ZG9jLm91dHMuZm9yRWFjaChmdW5jdGlvbihvdXRwdXQpe3RoaXMuYWRkT3V0cHV0KG5ldyBUcmFuc2FjdGlvbk91dChvdXRwdXQpKX0sdGhpcyl9dGhpcy5oYXNoPXRoaXMuaGFzaHx8dGhpcy5nZXRIYXNoKCl9fTtUcmFuc2FjdGlvbi5wcm90b3R5cGUuYWRkSW5wdXQ9ZnVuY3Rpb24odHgsb3V0SW5kZXgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHJhbnNhY3Rpb25Jbil7dGhpcy5pbnMucHVzaChhcmd1bWVudHNbMF0pfWVsc2UgaWYoYXJndW1lbnRzWzBdLmxlbmd0aD42NSl7dmFyIGFyZ3M9YXJndW1lbnRzWzBdLnNwbGl0KFwiOlwiKTtyZXR1cm4gdGhpcy5hZGRJbnB1dChhcmdzWzBdLGFyZ3NbMV0pfWVsc2V7dmFyIGhhc2g9dHlwZW9mIHR4PT09XCJzdHJpbmdcIj90eDp0eC5oYXNoO2hhc2g9QXJyYXkuaXNBcnJheShoYXNoKT9jb252ZXJ0LmJ5dGVzVG9IZXgoaGFzaCk6aGFzaDt0aGlzLmlucy5wdXNoKG5ldyBUcmFuc2FjdGlvbkluKHtvdXRwb2ludDp7aGFzaDpoYXNoLGluZGV4Om91dEluZGV4fSxzY3JpcHQ6bmV3IFNjcmlwdCxzZXF1ZW5jZTp0aGlzLmRlZmF1bHRTZXF1ZW5jZX0pKX19O1RyYW5zYWN0aW9uLnByb3RvdHlwZS5hZGRPdXRwdXQ9ZnVuY3Rpb24oYWRkcmVzcyx2YWx1ZSl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBUcmFuc2FjdGlvbk91dCl7dGhpcy5vdXRzLnB1c2goYXJndW1lbnRzWzBdKTtyZXR1cm59aWYoYXJndW1lbnRzWzBdLmluZGV4T2YoXCI6XCIpPj0wKXt2YXIgYXJncz1hcmd1bWVudHNbMF0uc3BsaXQoXCI6XCIpO2FkZHJlc3M9YXJnc1swXTt2YWx1ZT1wYXJzZUludChhcmdzWzFdKX10aGlzLm91dHMucHVzaChuZXcgVHJhbnNhY3Rpb25PdXQoe3ZhbHVlOnZhbHVlLHNjcmlwdDpTY3JpcHQuY3JlYXRlT3V0cHV0U2NyaXB0KGFkZHJlc3MpfSkpfTtUcmFuc2FjdGlvbi5wcm90b3R5cGUuc2VyaWFsaXplPWZ1bmN0aW9uKCl7dmFyIGJ1ZmZlcj1bXTtidWZmZXI9YnVmZmVyLmNvbmNhdChjb252ZXJ0Lm51bVRvQnl0ZXMocGFyc2VJbnQodGhpcy52ZXJzaW9uKSw0KSk7YnVmZmVyPWJ1ZmZlci5jb25jYXQoY29udmVydC5udW1Ub1ZhckludCh0aGlzLmlucy5sZW5ndGgpKTt0aGlzLmlucy5mb3JFYWNoKGZ1bmN0aW9uKHR4aW4pe2J1ZmZlcj1idWZmZXIuY29uY2F0KGNvbnZlcnQuaGV4VG9CeXRlcyh0eGluLm91dHBvaW50Lmhhc2gpLnJldmVyc2UoKSk7YnVmZmVyPWJ1ZmZlci5jb25jYXQoY29udmVydC5udW1Ub0J5dGVzKHBhcnNlSW50KHR4aW4ub3V0cG9pbnQuaW5kZXgpLDQpKTt2YXIgc2NyaXB0Qnl0ZXM9dHhpbi5zY3JpcHQuYnVmZmVyO2J1ZmZlcj1idWZmZXIuY29uY2F0KGNvbnZlcnQubnVtVG9WYXJJbnQoc2NyaXB0Qnl0ZXMubGVuZ3RoKSk7YnVmZmVyPWJ1ZmZlci5jb25jYXQoc2NyaXB0Qnl0ZXMpO2J1ZmZlcj1idWZmZXIuY29uY2F0KHR4aW4uc2VxdWVuY2UpfSk7YnVmZmVyPWJ1ZmZlci5jb25jYXQoY29udmVydC5udW1Ub1ZhckludCh0aGlzLm91dHMubGVuZ3RoKSk7dGhpcy5vdXRzLmZvckVhY2goZnVuY3Rpb24odHhvdXQpe2J1ZmZlcj1idWZmZXIuY29uY2F0KGNvbnZlcnQubnVtVG9CeXRlcyh0eG91dC52YWx1ZSw4KSk7dmFyIHNjcmlwdEJ5dGVzPXR4b3V0LnNjcmlwdC5idWZmZXI7YnVmZmVyPWJ1ZmZlci5jb25jYXQoY29udmVydC5udW1Ub1ZhckludChzY3JpcHRCeXRlcy5sZW5ndGgpKTtidWZmZXI9YnVmZmVyLmNvbmNhdChzY3JpcHRCeXRlcyl9KTtidWZmZXI9YnVmZmVyLmNvbmNhdChjb252ZXJ0Lm51bVRvQnl0ZXMocGFyc2VJbnQodGhpcy5sb2NrdGltZSksNCkpO3JldHVybiBidWZmZXJ9O1RyYW5zYWN0aW9uLnByb3RvdHlwZS5zZXJpYWxpemVIZXg9ZnVuY3Rpb24oKXtyZXR1cm4gY29udmVydC5ieXRlc1RvSGV4KHRoaXMuc2VyaWFsaXplKCkpfTt2YXIgU0lHSEFTSF9BTEw9MTt2YXIgU0lHSEFTSF9OT05FPTI7dmFyIFNJR0hBU0hfU0lOR0xFPTM7dmFyIFNJR0hBU0hfQU5ZT05FQ0FOUEFZPTgwO1RyYW5zYWN0aW9uLnByb3RvdHlwZS5oYXNoVHJhbnNhY3Rpb25Gb3JTaWduYXR1cmU9ZnVuY3Rpb24oY29ubmVjdGVkU2NyaXB0LGluSW5kZXgsaGFzaFR5cGUpe3ZhciB0eFRtcD10aGlzLmNsb25lKCk7dHhUbXAuaW5zLmZvckVhY2goZnVuY3Rpb24odHhpbil7dHhpbi5zY3JpcHQ9bmV3IFNjcmlwdH0pO3R4VG1wLmluc1tpbkluZGV4XS5zY3JpcHQ9Y29ubmVjdGVkU2NyaXB0O2lmKChoYXNoVHlwZSYzMSk9PVNJR0hBU0hfTk9ORSl7dHhUbXAub3V0cz1bXTt0eFRtcC5pbnMuZm9yRWFjaChmdW5jdGlvbih0eGluLGkpe2lmKGkhPWluSW5kZXgpe3R4VG1wLmluc1tpXS5zZXF1ZW5jZT0wfX0pfWVsc2UgaWYoKGhhc2hUeXBlJjMxKT09U0lHSEFTSF9TSU5HTEUpe31pZihoYXNoVHlwZSZTSUdIQVNIX0FOWU9ORUNBTlBBWSl7dHhUbXAuaW5zPVt0eFRtcC5pbnNbaW5JbmRleF1dfXZhciBidWZmZXI9dHhUbXAuc2VyaWFsaXplKCk7YnVmZmVyPWJ1ZmZlci5jb25jYXQoY29udmVydC5udW1Ub0J5dGVzKHBhcnNlSW50KGhhc2hUeXBlKSw0KSk7YnVmZmVyPWNvbnZlcnQuYnl0ZXNUb1dvcmRBcnJheShidWZmZXIpO3JldHVybiBjb252ZXJ0LndvcmRBcnJheVRvQnl0ZXMoU0hBMjU2KFNIQTI1NihidWZmZXIpKSl9O1RyYW5zYWN0aW9uLnByb3RvdHlwZS5nZXRIYXNoPWZ1bmN0aW9uKCl7dmFyIGJ1ZmZlcj1jb252ZXJ0LmJ5dGVzVG9Xb3JkQXJyYXkodGhpcy5zZXJpYWxpemUoKSk7cmV0dXJuIGNvbnZlcnQud29yZEFycmF5VG9CeXRlcyhTSEEyNTYoU0hBMjU2KGJ1ZmZlcikpKS5yZXZlcnNlKCl9O1RyYW5zYWN0aW9uLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBuZXdUeD1uZXcgVHJhbnNhY3Rpb247bmV3VHgudmVyc2lvbj10aGlzLnZlcnNpb247bmV3VHgubG9ja3RpbWU9dGhpcy5sb2NrdGltZTt0aGlzLmlucy5mb3JFYWNoKGZ1bmN0aW9uKHR4aW4pe25ld1R4LmFkZElucHV0KHR4aW4uY2xvbmUoKSl9KTt0aGlzLm91dHMuZm9yRWFjaChmdW5jdGlvbih0eG91dCl7bmV3VHguYWRkT3V0cHV0KHR4b3V0LmNsb25lKCkpfSk7cmV0dXJuIG5ld1R4fTtUcmFuc2FjdGlvbi5kZXNlcmlhbGl6ZT1mdW5jdGlvbihidWZmZXIpe2lmKHR5cGVvZiBidWZmZXI9PVwic3RyaW5nXCIpe2J1ZmZlcj1jb252ZXJ0LmhleFRvQnl0ZXMoYnVmZmVyKX12YXIgcG9zPTA7dmFyIHJlYWRBc0ludD1mdW5jdGlvbihieXRlcyl7aWYoYnl0ZXM9PT0wKXJldHVybiAwO3BvcysrO3JldHVybiBidWZmZXJbcG9zLTFdK3JlYWRBc0ludChieXRlcy0xKSoyNTZ9O3ZhciByZWFkVmFySW50PWZ1bmN0aW9uKCl7dmFyIGJ5dGVzPWJ1ZmZlci5zbGljZShwb3MscG9zKzkpO3ZhciByZXN1bHQ9Y29udmVydC52YXJJbnRUb051bShieXRlcyk7cG9zKz1yZXN1bHQuYnl0ZXMubGVuZ3RoO3JldHVybiByZXN1bHQubnVtYmVyfTt2YXIgcmVhZEJ5dGVzPWZ1bmN0aW9uKGJ5dGVzKXtwb3MrPWJ5dGVzO3JldHVybiBidWZmZXIuc2xpY2UocG9zLWJ5dGVzLHBvcyl9O3ZhciByZWFkVmFyU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIHNpemU9cmVhZFZhckludCgpO3JldHVybiByZWFkQnl0ZXMoc2l6ZSl9O3ZhciBvYmo9e2luczpbXSxvdXRzOltdfTtvYmoudmVyc2lvbj1yZWFkQXNJbnQoNCk7dmFyIGlucz1yZWFkVmFySW50KCk7dmFyIGk7Zm9yKGk9MDtpPGlucztpKyspe29iai5pbnMucHVzaCh7b3V0cG9pbnQ6e2hhc2g6Y29udmVydC5ieXRlc1RvSGV4KHJlYWRCeXRlcygzMikucmV2ZXJzZSgpKSxpbmRleDpyZWFkQXNJbnQoNCl9LHNjcmlwdDpuZXcgU2NyaXB0KHJlYWRWYXJTdHJpbmcoKSksc2VxdWVuY2U6cmVhZEJ5dGVzKDQpfSl9dmFyIG91dHM9cmVhZFZhckludCgpO2ZvcihpPTA7aTxvdXRzO2krKyl7b2JqLm91dHMucHVzaCh7dmFsdWU6Y29udmVydC5ieXRlc1RvTnVtKHJlYWRCeXRlcyg4KSksc2NyaXB0Om5ldyBTY3JpcHQocmVhZFZhclN0cmluZygpKX0pfW9iai5sb2NrdGltZT1yZWFkQXNJbnQoNCk7cmV0dXJuIG5ldyBUcmFuc2FjdGlvbihvYmopfTtUcmFuc2FjdGlvbi5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbihpbmRleCxrZXksdHlwZSl7dHlwZT10eXBlfHxTSUdIQVNIX0FMTDtrZXk9bmV3IEVDS2V5KGtleSk7dmFyIHB1Yj1rZXkuZ2V0UHViKCkudG9CeXRlcygpLGhhc2gxNjA9dXRpbC5zaGEyNTZyaXBlMTYwKHB1Yiksc2NyaXB0PVNjcmlwdC5jcmVhdGVPdXRwdXRTY3JpcHQobmV3IEFkZHJlc3MoaGFzaDE2MCkpLGhhc2g9dGhpcy5oYXNoVHJhbnNhY3Rpb25Gb3JTaWduYXR1cmUoc2NyaXB0LGluZGV4LHR5cGUpLHNpZz1rZXkuc2lnbihoYXNoKS5jb25jYXQoW3R5cGVdKTt0aGlzLmluc1tpbmRleF0uc2NyaXB0PVNjcmlwdC5jcmVhdGVJbnB1dFNjcmlwdChzaWcscHViKX07VHJhbnNhY3Rpb24ucHJvdG90eXBlLnNpZ25XaXRoS2V5cz1mdW5jdGlvbihrZXlzLG91dHB1dHMsdHlwZSl7dHlwZT10eXBlfHxTSUdIQVNIX0FMTDt2YXIgYWRkcmRhdGE9a2V5cy5tYXAoZnVuY3Rpb24oa2V5KXtrZXk9bmV3IEVDS2V5KGtleSk7cmV0dXJue2tleTprZXksYWRkcmVzczprZXkuZ2V0QWRkcmVzcygpLnRvU3RyaW5nKCl9fSk7dmFyIGhtYXA9e307b3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uKG8pe2htYXBbby5vdXRwdXRdPW99KTtmb3IodmFyIGk9MDtpPHRoaXMuaW5zLmxlbmd0aDtpKyspe3ZhciBvdXRwb2ludD10aGlzLmluc1tpXS5vdXRwb2ludC5oYXNoK1wiOlwiK3RoaXMuaW5zW2ldLm91dHBvaW50LmluZGV4O3ZhciBoaXN0SXRlbT1obWFwW291dHBvaW50XTtpZighaGlzdEl0ZW0pY29udGludWU7dmFyIHRoaXNJbnB1dEFkZHJkYXRhPWFkZHJkYXRhLmZpbHRlcihmdW5jdGlvbihhKXtyZXR1cm4gYS5hZGRyZXNzPT1oaXN0SXRlbS5hZGRyZXNzfSk7aWYodGhpc0lucHV0QWRkcmRhdGEubGVuZ3RoPT09MCljb250aW51ZTt0aGlzLnNpZ24oaSx0aGlzSW5wdXRBZGRyZGF0YVswXS5rZXkpfX07VHJhbnNhY3Rpb24ucHJvdG90eXBlLnAyc2hzaWduPWZ1bmN0aW9uKGluZGV4LHNjcmlwdCxrZXksdHlwZSl7c2NyaXB0PW5ldyBTY3JpcHQoc2NyaXB0KTtrZXk9bmV3IEVDS2V5KGtleSk7dHlwZT10eXBlfHxTSUdIQVNIX0FMTDt2YXIgaGFzaD10aGlzLmhhc2hUcmFuc2FjdGlvbkZvclNpZ25hdHVyZShzY3JpcHQsaW5kZXgsdHlwZSksc2lnPWtleS5zaWduKGhhc2gpLmNvbmNhdChbdHlwZV0pO3JldHVybiBzaWd9O1RyYW5zYWN0aW9uLnByb3RvdHlwZS5tdWx0aXNpZ249VHJhbnNhY3Rpb24ucHJvdG90eXBlLnAyc2hzaWduO1RyYW5zYWN0aW9uLnByb3RvdHlwZS5hcHBseU11bHRpc2lncz1mdW5jdGlvbihpbmRleCxzY3JpcHQsc2lncyl7dGhpcy5pbnNbaW5kZXhdLnNjcmlwdD1TY3JpcHQuY3JlYXRlTXVsdGlTaWdJbnB1dFNjcmlwdChzaWdzLHNjcmlwdCl9O1RyYW5zYWN0aW9uLnByb3RvdHlwZS52YWxpZGF0ZVNpZz1mdW5jdGlvbihpbmRleCxzY3JpcHQsc2lnLHB1Yil7c2NyaXB0PW5ldyBTY3JpcHQoc2NyaXB0KTt2YXIgaGFzaD10aGlzLmhhc2hUcmFuc2FjdGlvbkZvclNpZ25hdHVyZShzY3JpcHQsaW5kZXgsMSk7cmV0dXJuIEVDRFNBLnZlcmlmeShoYXNoLGNvbnZlcnQuY29lcmNlVG9CeXRlcyhzaWcpLGNvbnZlcnQuY29lcmNlVG9CeXRlcyhwdWIpKX07VHJhbnNhY3Rpb24uZmVlUGVyS2I9MmU0O1RyYW5zYWN0aW9uLnByb3RvdHlwZS5lc3RpbWF0ZUZlZT1mdW5jdGlvbihmZWVQZXJLYil7dmFyIHVuY29tcHJlc3NlZEluU2l6ZT0xODA7dmFyIG91dFNpemU9MzQ7dmFyIGZpeGVkUGFkZGluZz0zNDtpZihmZWVQZXJLYj09dW5kZWZpbmVkKWZlZVBlcktiPVRyYW5zYWN0aW9uLmZlZVBlcktiO3ZhciBzaXplPXRoaXMuaW5zLmxlbmd0aCp1bmNvbXByZXNzZWRJblNpemUrdGhpcy5vdXRzLmxlbmd0aCpvdXRTaXplK2ZpeGVkUGFkZGluZztyZXR1cm4gZmVlUGVyS2IqTWF0aC5jZWlsKHNpemUvMWUzKX07dmFyIFRyYW5zYWN0aW9uSW49ZnVuY3Rpb24oZGF0YSl7aWYodHlwZW9mIGRhdGE9PVwic3RyaW5nXCIpe3RoaXMub3V0cG9pbnQ9e2hhc2g6ZGF0YS5zcGxpdChcIjpcIilbMF0saW5kZXg6ZGF0YS5zcGxpdChcIjpcIilbMV19fWVsc2UgaWYoZGF0YS5vdXRwb2ludCl7dGhpcy5vdXRwb2ludD1kYXRhLm91dHBvaW50fWVsc2V7dGhpcy5vdXRwb2ludD17aGFzaDpkYXRhLmhhc2gsaW5kZXg6ZGF0YS5pbmRleH19aWYoZGF0YS5zY3JpcHRTaWcpe3RoaXMuc2NyaXB0PVNjcmlwdC5mcm9tU2NyaXB0U2lnKGRhdGEuc2NyaXB0U2lnKX1lbHNlIGlmKGRhdGEuc2NyaXB0KXt0aGlzLnNjcmlwdD1kYXRhLnNjcmlwdH1lbHNle3RoaXMuc2NyaXB0PW5ldyBTY3JpcHQoZGF0YS5zY3JpcHQpfXRoaXMuc2VxdWVuY2U9ZGF0YS5zZXF1ZW5jZXx8dGhpcy5kZWZhdWx0U2VxdWVuY2V9O1RyYW5zYWN0aW9uSW4ucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluKHtvdXRwb2ludDp7aGFzaDp0aGlzLm91dHBvaW50Lmhhc2gsaW5kZXg6dGhpcy5vdXRwb2ludC5pbmRleH0sc2NyaXB0OnRoaXMuc2NyaXB0LmNsb25lKCksc2VxdWVuY2U6dGhpcy5zZXF1ZW5jZX0pfTt2YXIgVHJhbnNhY3Rpb25PdXQ9ZnVuY3Rpb24oZGF0YSl7dGhpcy5zY3JpcHQ9ZGF0YS5zY3JpcHQgaW5zdGFuY2VvZiBTY3JpcHQ/ZGF0YS5zY3JpcHQuY2xvbmUoKTpBcnJheS5pc0FycmF5KGRhdGEuc2NyaXB0KT9uZXcgU2NyaXB0KGRhdGEuc2NyaXB0KTp0eXBlb2YgZGF0YS5zY3JpcHQ9PVwic3RyaW5nXCI/bmV3IFNjcmlwdChjb252ZXJ0LmhleFRvQnl0ZXMoZGF0YS5zY3JpcHQpKTpkYXRhLnNjcmlwdFB1YktleT9TY3JpcHQuZnJvbVNjcmlwdFNpZyhkYXRhLnNjcmlwdFB1YktleSk6ZGF0YS5hZGRyZXNzP1NjcmlwdC5jcmVhdGVPdXRwdXRTY3JpcHQoZGF0YS5hZGRyZXNzKTpuZXcgU2NyaXB0O2lmKHRoaXMuc2NyaXB0LmJ1ZmZlci5sZW5ndGg+MCl0aGlzLmFkZHJlc3M9dGhpcy5zY3JpcHQuZ2V0VG9BZGRyZXNzKCk7dGhpcy52YWx1ZT1BcnJheS5pc0FycmF5KGRhdGEudmFsdWUpP2NvbnZlcnQuYnl0ZXNUb051bShkYXRhLnZhbHVlKTpcInN0cmluZ1wiPT10eXBlb2YgZGF0YS52YWx1ZT9wYXJzZUludChkYXRhLnZhbHVlKTpkYXRhLnZhbHVlIGluc3RhbmNlb2YgQmlnSW50ZWdlcj9wYXJzZUludChkYXRhLnZhbHVlLnRvU3RyaW5nKCkpOmRhdGEudmFsdWV9O1RyYW5zYWN0aW9uT3V0LnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBuZXdUeG91dD1uZXcgVHJhbnNhY3Rpb25PdXQoe3NjcmlwdDp0aGlzLnNjcmlwdC5jbG9uZSgpLHZhbHVlOnRoaXMudmFsdWV9KTtyZXR1cm4gbmV3VHhvdXR9O1RyYW5zYWN0aW9uT3V0LnByb3RvdHlwZS5zY3JpcHRQdWJLZXk9ZnVuY3Rpb24oKXtyZXR1cm4gY29udmVydC5ieXRlc1RvSGV4KHRoaXMuc2NyaXB0LmJ1ZmZlcil9O21vZHVsZS5leHBvcnRzPXtUcmFuc2FjdGlvbjpUcmFuc2FjdGlvbixUcmFuc2FjdGlvbkluOlRyYW5zYWN0aW9uSW4sVHJhbnNhY3Rpb25PdXQ6VHJhbnNhY3Rpb25PdXR9fSx7XCIuL2FkZHJlc3NcIjo1NCxcIi4vY29udmVydFwiOjU3LFwiLi9lY2RzYVwiOjU4LFwiLi9lY2tleVwiOjU5LFwiLi9qc2JuL2pzYm5cIjo2MyxcIi4vc2NyaXB0XCI6NjgsXCIuL3V0aWxcIjo3MCxcImNyeXB0by1qcy9zaGEyNTZcIjo0N31dLDcwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgY29udmVydD1fZGVyZXFfKFwiLi9jb252ZXJ0LmpzXCIpO3ZhciBDcnlwdG89X2RlcmVxXyhcImNyeXB0by1qc1wiKTt2YXIgUklQRU1EMTYwPUNyeXB0by5SSVBFTUQxNjA7dmFyIFNIQTI1Nj1DcnlwdG8uU0hBMjU2O2V4cG9ydHMuc2hhMjU2cmlwZTE2MD1mdW5jdGlvbihkYXRhKXt2YXIgd29yZEFycmF5PVJJUEVNRDE2MChTSEEyNTYoY29udmVydC5ieXRlc1RvV29yZEFycmF5KGRhdGEpKSk7cmV0dXJuIGNvbnZlcnQud29yZEFycmF5VG9CeXRlcyh3b3JkQXJyYXkpfTtleHBvcnRzLmVycm9yPWZ1bmN0aW9uKG1zZyl7dGhyb3cgbmV3IEVycm9yKG1zZyl9fSx7XCIuL2NvbnZlcnQuanNcIjo1NyxcImNyeXB0by1qc1wiOjI3fV0sNzE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihwcm9jZXNzKXt2YXIgY29udmVydD1fZGVyZXFfKFwiLi9jb252ZXJ0XCIpO3ZhciBUcmFuc2FjdGlvbj1fZGVyZXFfKFwiLi90cmFuc2FjdGlvblwiKS5UcmFuc2FjdGlvbjt2YXIgSEROb2RlPV9kZXJlcV8oXCIuL2hkd2FsbGV0LmpzXCIpO3ZhciBybmc9X2RlcmVxXyhcInNlY3VyZS1yYW5kb21cIik7ZnVuY3Rpb24gV2FsbGV0KHNlZWQsb3B0aW9ucyl7aWYoISh0aGlzIGluc3RhbmNlb2YgV2FsbGV0KSl7cmV0dXJuIG5ldyBXYWxsZXQoc2VlZCxvcHRpb25zKX12YXIgb3B0aW9ucz1vcHRpb25zfHx7fTt2YXIgbmV0d29yaz1vcHRpb25zLm5ldHdvcmt8fFwibWFpbm5ldFwiO3ZhciBtYXN0ZXJrZXk9bnVsbDt2YXIgbWU9dGhpczt2YXIgYWNjb3VudFplcm89bnVsbDt2YXIgaW50ZXJuYWxBY2NvdW50PW51bGw7dmFyIGV4dGVybmFsQWNjb3VudD1udWxsO3RoaXMuYWRkcmVzc2VzPVtdO3RoaXMuY2hhbmdlQWRkcmVzc2VzPVtdO3RoaXMub3V0cHV0cz17fTt0aGlzLm5ld01hc3RlcktleT1mdW5jdGlvbihzZWVkLG5ldHdvcmspe2lmKCFzZWVkKXNlZWQ9cm5nKDMyLHthcnJheTp0cnVlfSk7bWFzdGVya2V5PW5ldyBIRE5vZGUoc2VlZCxuZXR3b3JrKTthY2NvdW50WmVybz1tYXN0ZXJrZXkuZGVyaXZlUHJpdmF0ZSgwKTtleHRlcm5hbEFjY291bnQ9YWNjb3VudFplcm8uZGVyaXZlKDApO2ludGVybmFsQWNjb3VudD1hY2NvdW50WmVyby5kZXJpdmUoMSk7bWUuYWRkcmVzc2VzPVtdO21lLmNoYW5nZUFkZHJlc3Nlcz1bXTttZS5vdXRwdXRzPXt9fTt0aGlzLm5ld01hc3RlcktleShzZWVkLG5ldHdvcmspO3RoaXMuZ2VuZXJhdGVBZGRyZXNzPWZ1bmN0aW9uKCl7dmFyIGtleT1leHRlcm5hbEFjY291bnQuZGVyaXZlKHRoaXMuYWRkcmVzc2VzLmxlbmd0aCk7dGhpcy5hZGRyZXNzZXMucHVzaChrZXkuZ2V0QWRkcmVzcygpLnRvU3RyaW5nKCkpO3JldHVybiB0aGlzLmFkZHJlc3Nlc1t0aGlzLmFkZHJlc3Nlcy5sZW5ndGgtMV19O3RoaXMuZ2VuZXJhdGVDaGFuZ2VBZGRyZXNzPWZ1bmN0aW9uKCl7dmFyIGtleT1pbnRlcm5hbEFjY291bnQuZGVyaXZlKHRoaXMuY2hhbmdlQWRkcmVzc2VzLmxlbmd0aCk7dGhpcy5jaGFuZ2VBZGRyZXNzZXMucHVzaChrZXkuZ2V0QWRkcmVzcygpLnRvU3RyaW5nKCkpO3JldHVybiB0aGlzLmNoYW5nZUFkZHJlc3Nlc1t0aGlzLmNoYW5nZUFkZHJlc3Nlcy5sZW5ndGgtMV19O3RoaXMuZ2V0QmFsYW5jZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFVuc3BlbnRPdXRwdXRzKCkucmVkdWNlKGZ1bmN0aW9uKG1lbW8sb3V0cHV0KXtyZXR1cm4gbWVtbytvdXRwdXQudmFsdWV9LDApfTt0aGlzLmdldFVuc3BlbnRPdXRwdXRzPWZ1bmN0aW9uKCl7dmFyIHV0eG89W107Zm9yKHZhciBrZXkgaW4gdGhpcy5vdXRwdXRzKXt2YXIgb3V0cHV0PXRoaXMub3V0cHV0c1trZXldO2lmKCFvdXRwdXQuc3BlbmQpdXR4by5wdXNoKG91dHB1dFRvVW5zcGVudE91dHB1dChvdXRwdXQpKX1yZXR1cm4gdXR4b307dGhpcy5zZXRVbnNwZW50T3V0cHV0cz1mdW5jdGlvbih1dHhvKXt2YXIgb3V0cHV0cz17fTt1dHhvLmZvckVhY2goZnVuY3Rpb24odW8pe3ZhbGlkYXRlVW5zcGVudE91dHB1dCh1byk7dmFyIG89dW5zcGVudE91dHB1dFRvT3V0cHV0KHVvKTtvdXRwdXRzW28ucmVjZWl2ZV09b30pO3RoaXMub3V0cHV0cz1vdXRwdXRzfTt0aGlzLnNldFVuc3BlbnRPdXRwdXRzQXN5bmM9ZnVuY3Rpb24odXR4byxjYWxsYmFjayl7dmFyIGVycm9yPW51bGw7dHJ5e3RoaXMuc2V0VW5zcGVudE91dHB1dHModXR4byl9Y2F0Y2goZXJyKXtlcnJvcj1lcnJ9ZmluYWxseXtwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCl7Y2FsbGJhY2soZXJyb3IpfSl9fTtmdW5jdGlvbiBvdXRwdXRUb1Vuc3BlbnRPdXRwdXQob3V0cHV0KXt2YXIgaGFzaEFuZEluZGV4PW91dHB1dC5yZWNlaXZlLnNwbGl0KFwiOlwiKTtyZXR1cm57aGFzaDpoYXNoQW5kSW5kZXhbMF0saGFzaExpdHRsZUVuZGlhbjpjb252ZXJ0LnJldmVyc2VFbmRpYW4oaGFzaEFuZEluZGV4WzBdKSxvdXRwdXRJbmRleDpwYXJzZUludChoYXNoQW5kSW5kZXhbMV0pLGFkZHJlc3M6b3V0cHV0LmFkZHJlc3MsdmFsdWU6b3V0cHV0LnZhbHVlfX1mdW5jdGlvbiB1bnNwZW50T3V0cHV0VG9PdXRwdXQobyl7dmFyIGhhc2g9by5oYXNofHxjb252ZXJ0LnJldmVyc2VFbmRpYW4oby5oYXNoTGl0dGxlRW5kaWFuKTt2YXIga2V5PWhhc2grXCI6XCIrby5vdXRwdXRJbmRleDtyZXR1cm57cmVjZWl2ZTprZXksYWRkcmVzczpvLmFkZHJlc3MsdmFsdWU6by52YWx1ZX19ZnVuY3Rpb24gdmFsaWRhdGVVbnNwZW50T3V0cHV0KHVvKXt2YXIgbWlzc2luZ0ZpZWxkO2lmKGlzTnVsbE9yVW5kZWZpbmVkKHVvLmhhc2gpJiZpc051bGxPclVuZGVmaW5lZCh1by5oYXNoTGl0dGxlRW5kaWFuKSl7bWlzc2luZ0ZpZWxkPVwiaGFzaChvciBoYXNoTGl0dGxlRW5kaWFuKVwifXZhciByZXF1aXJlZEtleXM9W1wib3V0cHV0SW5kZXhcIixcImFkZHJlc3NcIixcInZhbHVlXCJdO3JlcXVpcmVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7aWYoaXNOdWxsT3JVbmRlZmluZWQodW9ba2V5XSkpe21pc3NpbmdGaWVsZD1rZXl9fSk7aWYobWlzc2luZ0ZpZWxkKXt2YXIgbWVzc2FnZT1bXCJJbnZhbGlkIHVuc3BlbnQgb3V0cHV0OiBrZXlcIixtaXNzaW5nRmllbGQsXCJpcyBtaXNzaW5nLlwiLFwiQSB2YWxpZCB1bnNwZW50IG91dHB1dCBtdXN0IGNvbnRhaW5cIl07bWVzc2FnZS5wdXNoKHJlcXVpcmVkS2V5cy5qb2luKFwiLCBcIikpO21lc3NhZ2UucHVzaChcImFuZCBoYXNoKG9yIGhhc2hMaXR0bGVFbmRpYW4pXCIpO3Rocm93IG5ldyBFcnJvcihtZXNzYWdlLmpvaW4oXCIgXCIpKX19ZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpe3JldHVybiB2YWx1ZT09dW5kZWZpbmVkfXRoaXMucHJvY2Vzc1R4PWZ1bmN0aW9uKHR4KXt2YXIgdHhoYXNoPWNvbnZlcnQuYnl0ZXNUb0hleCh0eC5nZXRIYXNoKCkpO3R4Lm91dHMuZm9yRWFjaChmdW5jdGlvbih0eE91dCxpKXt2YXIgYWRkcmVzcz10eE91dC5hZGRyZXNzLnRvU3RyaW5nKCk7aWYoaXNNeUFkZHJlc3MoYWRkcmVzcykpe3ZhciBvdXRwdXQ9dHhoYXNoK1wiOlwiK2k7bWUub3V0cHV0c1tvdXRwdXRdPXtyZWNlaXZlOm91dHB1dCx2YWx1ZTp0eE91dC52YWx1ZSxhZGRyZXNzOmFkZHJlc3N9fX0pO3R4Lmlucy5mb3JFYWNoKGZ1bmN0aW9uKHR4SW4saSl7dmFyIG9wPXR4SW4ub3V0cG9pbnQ7dmFyIG89bWUub3V0cHV0c1tvcC5oYXNoK1wiOlwiK29wLmluZGV4XTtpZihvKXtvLnNwZW5kPXR4aGFzaCtcIjpcIitpfX0pfTt0aGlzLmNyZWF0ZVR4PWZ1bmN0aW9uKHRvLHZhbHVlLGZpeGVkRmVlKXtjaGVja0R1c3QodmFsdWUpO3ZhciB0eD1uZXcgVHJhbnNhY3Rpb247dHguYWRkT3V0cHV0KHRvLHZhbHVlKTt2YXIgdXR4bz1nZXRDYW5kaWRhdGVPdXRwdXRzKHZhbHVlKTt2YXIgdG90YWxJblZhbHVlPTA7Zm9yKHZhciBpPTA7aTx1dHhvLmxlbmd0aDtpKyspe3ZhciBvdXRwdXQ9dXR4b1tpXTt0eC5hZGRJbnB1dChvdXRwdXQucmVjZWl2ZSk7dG90YWxJblZhbHVlKz1vdXRwdXQudmFsdWU7aWYodG90YWxJblZhbHVlPHZhbHVlKWNvbnRpbnVlO3ZhciBmZWU9Zml4ZWRGZWU9PXVuZGVmaW5lZD9lc3RpbWF0ZUZlZVBhZENoYW5nZU91dHB1dCh0eCk6Zml4ZWRGZWU7aWYodG90YWxJblZhbHVlPHZhbHVlK2ZlZSljb250aW51ZTt2YXIgY2hhbmdlPXRvdGFsSW5WYWx1ZS12YWx1ZS1mZWU7aWYoY2hhbmdlPjAmJiFpc0R1c3QoY2hhbmdlKSl7dHguYWRkT3V0cHV0KGdldENoYW5nZUFkZHJlc3MoKSxjaGFuZ2UpfWJyZWFrfWNoZWNrSW5zdWZmaWNpZW50RnVuZCh0b3RhbEluVmFsdWUsdmFsdWUsZmVlKTt0aGlzLnNpZ24odHgpO3JldHVybiB0eH07dGhpcy5jcmVhdGVUeEFzeW5jPWZ1bmN0aW9uKHRvLHZhbHVlLGZpeGVkRmVlLGNhbGxiYWNrKXtpZihmaXhlZEZlZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtjYWxsYmFjaz1maXhlZEZlZTtmaXhlZEZlZT11bmRlZmluZWR9dmFyIHR4PW51bGw7dmFyIGVycm9yPW51bGw7dHJ5e3R4PXRoaXMuY3JlYXRlVHgodG8sdmFsdWUsZml4ZWRGZWUpfWNhdGNoKGVycil7ZXJyb3I9ZXJyfWZpbmFsbHl7cHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpe2NhbGxiYWNrKGVycm9yLHR4KX0pfX07dGhpcy5kdXN0VGhyZXNob2xkPTU0MzA7ZnVuY3Rpb24gaXNEdXN0KGFtb3VudCl7cmV0dXJuIGFtb3VudDw9bWUuZHVzdFRocmVzaG9sZH1mdW5jdGlvbiBjaGVja0R1c3QodmFsdWUpe2lmKGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKXx8aXNEdXN0KHZhbHVlKSl7dGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgbXVzdCBiZSBhYm92ZSBkdXN0IHRocmVzaG9sZFwiKX19ZnVuY3Rpb24gZ2V0Q2FuZGlkYXRlT3V0cHV0cyh2YWx1ZSl7dmFyIHVuc3BlbnQ9W107Zm9yKHZhciBrZXkgaW4gbWUub3V0cHV0cyl7dmFyIG91dHB1dD1tZS5vdXRwdXRzW2tleV07aWYoIW91dHB1dC5zcGVuZCl1bnNwZW50LnB1c2gob3V0cHV0KX12YXIgc29ydEJ5VmFsdWVEZXNjPXVuc3BlbnQuc29ydChmdW5jdGlvbihvMSxvMil7cmV0dXJuIG8yLnZhbHVlLW8xLnZhbHVlfSk7cmV0dXJuIHNvcnRCeVZhbHVlRGVzY31mdW5jdGlvbiBlc3RpbWF0ZUZlZVBhZENoYW5nZU91dHB1dCh0eCl7dmFyIHRtcFR4PXR4LmNsb25lKCk7dG1wVHguYWRkT3V0cHV0KGdldENoYW5nZUFkZHJlc3MoKSwwKTtyZXR1cm4gdG1wVHguZXN0aW1hdGVGZWUoKX1mdW5jdGlvbiBnZXRDaGFuZ2VBZGRyZXNzKCl7aWYobWUuY2hhbmdlQWRkcmVzc2VzLmxlbmd0aD09PTApbWUuZ2VuZXJhdGVDaGFuZ2VBZGRyZXNzKCk7cmV0dXJuIG1lLmNoYW5nZUFkZHJlc3Nlc1ttZS5jaGFuZ2VBZGRyZXNzZXMubGVuZ3RoLTFdfWZ1bmN0aW9uIGNoZWNrSW5zdWZmaWNpZW50RnVuZCh0b3RhbEluVmFsdWUsdmFsdWUsZmVlKXtpZih0b3RhbEluVmFsdWU8dmFsdWUrZmVlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgZW5vdWdoIG1vbmV5IHRvIHNlbmQgZnVuZHMgaW5jbHVkaW5nIHRyYW5zYWN0aW9uIGZlZS4gSGF2ZTogXCIrdG90YWxJblZhbHVlK1wiLCBuZWVkZWQ6IFwiKyh2YWx1ZStmZWUpKX19dGhpcy5zaWduPWZ1bmN0aW9uKHR4KXt0eC5pbnMuZm9yRWFjaChmdW5jdGlvbihpbnAsaSl7dmFyIG91dHB1dD1tZS5vdXRwdXRzW2lucC5vdXRwb2ludC5oYXNoK1wiOlwiK2lucC5vdXRwb2ludC5pbmRleF07aWYob3V0cHV0KXt0eC5zaWduKGksbWUuZ2V0UHJpdmF0ZUtleUZvckFkZHJlc3Mob3V0cHV0LmFkZHJlc3MpKX19KTtyZXR1cm4gdHh9O3RoaXMuZ2V0TWFzdGVyS2V5PWZ1bmN0aW9uKCl7cmV0dXJuIG1hc3RlcmtleX07dGhpcy5nZXRBY2NvdW50WmVybz1mdW5jdGlvbigpe3JldHVybiBhY2NvdW50WmVyb307dGhpcy5nZXRJbnRlcm5hbEFjY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gaW50ZXJuYWxBY2NvdW50fTt0aGlzLmdldEV4dGVybmFsQWNjb3VudD1mdW5jdGlvbigpe3JldHVybiBleHRlcm5hbEFjY291bnR9O3RoaXMuZ2V0UHJpdmF0ZUtleT1mdW5jdGlvbihpbmRleCl7cmV0dXJuIGV4dGVybmFsQWNjb3VudC5kZXJpdmUoaW5kZXgpLnByaXZ9O3RoaXMuZ2V0SW50ZXJuYWxQcml2YXRlS2V5PWZ1bmN0aW9uKGluZGV4KXtyZXR1cm4gaW50ZXJuYWxBY2NvdW50LmRlcml2ZShpbmRleCkucHJpdn07dGhpcy5nZXRQcml2YXRlS2V5Rm9yQWRkcmVzcz1mdW5jdGlvbihhZGRyZXNzKXt2YXIgaW5kZXg7aWYoKGluZGV4PXRoaXMuYWRkcmVzc2VzLmluZGV4T2YoYWRkcmVzcykpPi0xKXtyZXR1cm4gdGhpcy5nZXRQcml2YXRlS2V5KGluZGV4KX1lbHNlIGlmKChpbmRleD10aGlzLmNoYW5nZUFkZHJlc3Nlcy5pbmRleE9mKGFkZHJlc3MpKT4tMSl7cmV0dXJuIHRoaXMuZ2V0SW50ZXJuYWxQcml2YXRlS2V5KGluZGV4KX1lbHNle3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gYWRkcmVzcy4gTWFrZSBzdXJlIHRoZSBhZGRyZXNzIGlzIGZyb20gdGhlIGtleWNoYWluIGFuZCBoYXMgYmVlbiBnZW5lcmF0ZWQuXCIpfX07ZnVuY3Rpb24gaXNSZWNlaXZlQWRkcmVzcyhhZGRyZXNzKXtyZXR1cm4gbWUuYWRkcmVzc2VzLmluZGV4T2YoYWRkcmVzcyk+LTF9ZnVuY3Rpb24gaXNDaGFuZ2VBZGRyZXNzKGFkZHJlc3Mpe3JldHVybiBtZS5jaGFuZ2VBZGRyZXNzZXMuaW5kZXhPZihhZGRyZXNzKT4tMX1mdW5jdGlvbiBpc015QWRkcmVzcyhhZGRyZXNzKXtyZXR1cm4gaXNSZWNlaXZlQWRkcmVzcyhhZGRyZXNzKXx8aXNDaGFuZ2VBZGRyZXNzKGFkZHJlc3MpfX1tb2R1bGUuZXhwb3J0cz1XYWxsZXR9KS5jYWxsKHRoaXMsX2RlcmVxXyhcIkZXYUFTSFwiKSl9LHtcIi4vY29udmVydFwiOjU3LFwiLi9oZHdhbGxldC5qc1wiOjYwLFwiLi90cmFuc2FjdGlvblwiOjY5LEZXYUFTSDoxNSxcInNlY3VyZS1yYW5kb21cIjo1M31dfSx7fSxbNjFdKSg2MSl9KTsiLCIvKiEgcGVlcmpzIGJ1aWxkOjAuMy4xMywgZGV2ZWxvcG1lbnQuIENvcHlyaWdodChjKSAyMDEzIE1pY2hlbGxlIEJ1IDxtaWNoZWxsZUBtaWNoZWxsZWJ1LmNvbT4gKi8oZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cy5SVENTZXNzaW9uRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIHx8XG5cdHdpbmRvdy5tb3pSVENTZXNzaW9uRGVzY3JpcHRpb247XG5tb2R1bGUuZXhwb3J0cy5SVENQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fFxuXHR3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24gfHwgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uO1xubW9kdWxlLmV4cG9ydHMuUlRDSWNlQ2FuZGlkYXRlID0gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fFxuXHR3aW5kb3cubW96UlRDSWNlQ2FuZGlkYXRlO1xuXG59LHt9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpO1xudmFyIE5lZ290aWF0b3IgPSByZXF1aXJlKCcuL25lZ290aWF0b3InKTtcbnZhciBSZWxpYWJsZSA9IHJlcXVpcmUoJ3JlbGlhYmxlJyk7XG5cbi8qKlxuICogV3JhcHMgYSBEYXRhQ2hhbm5lbCBiZXR3ZWVuIHR3byBQZWVycy5cbiAqL1xuZnVuY3Rpb24gRGF0YUNvbm5lY3Rpb24ocGVlciwgcHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERhdGFDb25uZWN0aW9uKSkgcmV0dXJuIG5ldyBEYXRhQ29ubmVjdGlvbihwZWVyLCBwcm92aWRlciwgb3B0aW9ucyk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICBzZXJpYWxpemF0aW9uOiAnYmluYXJ5JyxcbiAgICByZWxpYWJsZTogZmFsc2VcbiAgfSwgb3B0aW9ucyk7XG5cbiAgLy8gQ29ubmVjdGlvbiBpcyBub3Qgb3BlbiB5ZXQuXG4gIHRoaXMub3BlbiA9IGZhbHNlO1xuICB0aGlzLnR5cGUgPSAnZGF0YSc7XG4gIHRoaXMucGVlciA9IHBlZXI7XG4gIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcblxuICB0aGlzLmlkID0gdGhpcy5vcHRpb25zLmNvbm5lY3Rpb25JZCB8fCBEYXRhQ29ubmVjdGlvbi5faWRQcmVmaXggKyB1dGlsLnJhbmRvbVRva2VuKCk7XG5cbiAgdGhpcy5sYWJlbCA9IHRoaXMub3B0aW9ucy5sYWJlbCB8fCB0aGlzLmlkO1xuICB0aGlzLm1ldGFkYXRhID0gdGhpcy5vcHRpb25zLm1ldGFkYXRhO1xuICB0aGlzLnNlcmlhbGl6YXRpb24gPSB0aGlzLm9wdGlvbnMuc2VyaWFsaXphdGlvbjtcbiAgdGhpcy5yZWxpYWJsZSA9IHRoaXMub3B0aW9ucy5yZWxpYWJsZTtcblxuICAvLyBEYXRhIGNoYW5uZWwgYnVmZmVyaW5nLlxuICB0aGlzLl9idWZmZXIgPSBbXTtcbiAgdGhpcy5fYnVmZmVyaW5nID0gZmFsc2U7XG4gIHRoaXMuYnVmZmVyU2l6ZSA9IDA7XG5cbiAgLy8gRm9yIHN0b3JpbmcgbGFyZ2UgZGF0YS5cbiAgdGhpcy5fY2h1bmtlZERhdGEgPSB7fTtcblxuICBpZiAodGhpcy5vcHRpb25zLl9wYXlsb2FkKSB7XG4gICAgdGhpcy5fcGVlckJyb3dzZXIgPSB0aGlzLm9wdGlvbnMuX3BheWxvYWQuYnJvd3NlcjtcbiAgfVxuXG4gIE5lZ290aWF0b3Iuc3RhcnRDb25uZWN0aW9uKFxuICAgIHRoaXMsXG4gICAgdGhpcy5vcHRpb25zLl9wYXlsb2FkIHx8IHtcbiAgICAgIG9yaWdpbmF0b3I6IHRydWVcbiAgICB9XG4gICk7XG59XG5cbnV0aWwuaW5oZXJpdHMoRGF0YUNvbm5lY3Rpb24sIEV2ZW50RW1pdHRlcik7XG5cbkRhdGFDb25uZWN0aW9uLl9pZFByZWZpeCA9ICdkY18nO1xuXG4vKiogQ2FsbGVkIGJ5IHRoZSBOZWdvdGlhdG9yIHdoZW4gdGhlIERhdGFDaGFubmVsIGlzIHJlYWR5LiAqL1xuRGF0YUNvbm5lY3Rpb24ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihkYykge1xuICB0aGlzLl9kYyA9IHRoaXMuZGF0YUNoYW5uZWwgPSBkYztcbiAgdGhpcy5fY29uZmlndXJlRGF0YUNoYW5uZWwoKTtcbn1cblxuRGF0YUNvbm5lY3Rpb24ucHJvdG90eXBlLl9jb25maWd1cmVEYXRhQ2hhbm5lbCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh1dGlsLnN1cHBvcnRzLnNjdHApIHtcbiAgICB0aGlzLl9kYy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgfVxuICB0aGlzLl9kYy5vbm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgICB1dGlsLmxvZygnRGF0YSBjaGFubmVsIGNvbm5lY3Rpb24gc3VjY2VzcycpO1xuICAgIHNlbGYub3BlbiA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdvcGVuJyk7XG4gIH1cblxuICAvLyBVc2UgdGhlIFJlbGlhYmxlIHNoaW0gZm9yIG5vbiBGaXJlZm94IGJyb3dzZXJzXG4gIGlmICghdXRpbC5zdXBwb3J0cy5zY3RwICYmIHRoaXMucmVsaWFibGUpIHtcbiAgICB0aGlzLl9yZWxpYWJsZSA9IG5ldyBSZWxpYWJsZSh0aGlzLl9kYywgdXRpbC5kZWJ1Zyk7XG4gIH1cblxuICBpZiAodGhpcy5fcmVsaWFibGUpIHtcbiAgICB0aGlzLl9yZWxpYWJsZS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgICAgIHNlbGYuZW1pdCgnZGF0YScsIG1zZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9kYy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICBzZWxmLl9oYW5kbGVEYXRhTWVzc2FnZShlKTtcbiAgICB9O1xuICB9XG4gIHRoaXMuX2RjLm9uY2xvc2UgPSBmdW5jdGlvbihlKSB7XG4gICAgdXRpbC5sb2coJ0RhdGFDaGFubmVsIGNsb3NlZCBmb3I6Jywgc2VsZi5wZWVyKTtcbiAgICBzZWxmLmNsb3NlKCk7XG4gIH07XG59XG5cbi8vIEhhbmRsZXMgYSBEYXRhQ2hhbm5lbCBtZXNzYWdlLlxuRGF0YUNvbm5lY3Rpb24ucHJvdG90eXBlLl9oYW5kbGVEYXRhTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgdmFyIGRhdGF0eXBlID0gZGF0YS5jb25zdHJ1Y3RvcjtcbiAgaWYgKHRoaXMuc2VyaWFsaXphdGlvbiA9PT0gJ2JpbmFyeScgfHwgdGhpcy5zZXJpYWxpemF0aW9uID09PSAnYmluYXJ5LXV0ZjgnKSB7XG4gICAgaWYgKGRhdGF0eXBlID09PSBCbG9iKSB7XG4gICAgICAvLyBEYXRhdHlwZSBzaG91bGQgbmV2ZXIgYmUgYmxvYlxuICAgICAgdXRpbC5ibG9iVG9BcnJheUJ1ZmZlcihkYXRhLCBmdW5jdGlvbihhYikge1xuICAgICAgICBkYXRhID0gdXRpbC51bnBhY2soYWIpO1xuICAgICAgICBzZWxmLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoZGF0YXR5cGUgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICBkYXRhID0gdXRpbC51bnBhY2soZGF0YSk7XG4gICAgfSBlbHNlIGlmIChkYXRhdHlwZSA9PT0gU3RyaW5nKSB7XG4gICAgICAvLyBTdHJpbmcgZmFsbGJhY2sgZm9yIGJpbmFyeSBkYXRhIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgYmluYXJ5IHlldFxuICAgICAgdmFyIGFiID0gdXRpbC5iaW5hcnlTdHJpbmdUb0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgZGF0YSA9IHV0aWwudW5wYWNrKGFiKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5zZXJpYWxpemF0aW9uID09PSAnanNvbicpIHtcbiAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHdlJ3ZlIGNodW5rZWQtLWlmIHNvLCBwaWVjZSB0aGluZ3MgYmFjayB0b2dldGhlci5cbiAgLy8gV2UncmUgZ3VhcmFudGVlZCB0aGF0IHRoaXMgaXNuJ3QgMC5cbiAgaWYgKGRhdGEuX19wZWVyRGF0YSkge1xuICAgIHZhciBpZCA9IGRhdGEuX19wZWVyRGF0YTtcbiAgICB2YXIgY2h1bmtJbmZvID0gdGhpcy5fY2h1bmtlZERhdGFbaWRdIHx8IHtkYXRhOiBbXSwgY291bnQ6IDAsIHRvdGFsOiBkYXRhLnRvdGFsfTtcblxuICAgIGNodW5rSW5mby5kYXRhW2RhdGEubl0gPSBkYXRhLmRhdGE7XG4gICAgY2h1bmtJbmZvLmNvdW50ICs9IDE7XG5cbiAgICBpZiAoY2h1bmtJbmZvLnRvdGFsID09PSBjaHVua0luZm8uY291bnQpIHtcbiAgICAgIC8vIENsZWFuIHVwIGJlZm9yZSBtYWtpbmcgdGhlIHJlY3Vyc2l2ZSBjYWxsIHRvIGBfaGFuZGxlRGF0YU1lc3NhZ2VgLlxuICAgICAgZGVsZXRlIHRoaXMuX2NodW5rZWREYXRhW2lkXTtcblxuICAgICAgLy8gV2UndmUgcmVjZWl2ZWQgYWxsIHRoZSBjaHVua3MtLXRpbWUgdG8gY29uc3RydWN0IHRoZSBjb21wbGV0ZSBkYXRhLlxuICAgICAgZGF0YSA9IG5ldyBCbG9iKGNodW5rSW5mby5kYXRhKTtcbiAgICAgIHRoaXMuX2hhbmRsZURhdGFNZXNzYWdlKHtkYXRhOiBkYXRhfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2h1bmtlZERhdGFbaWRdID0gY2h1bmtJbmZvO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpO1xufVxuXG4vKipcbiAqIEV4cG9zZWQgZnVuY3Rpb25hbGl0eSBmb3IgdXNlcnMuXG4gKi9cblxuLyoqIEFsbG93cyB1c2VyIHRvIGNsb3NlIGNvbm5lY3Rpb24uICovXG5EYXRhQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLm9wZW4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5vcGVuID0gZmFsc2U7XG4gIE5lZ290aWF0b3IuY2xlYW51cCh0aGlzKTtcbiAgdGhpcy5lbWl0KCdjbG9zZScpO1xufVxuXG4vKiogQWxsb3dzIHVzZXIgdG8gc2VuZCBkYXRhLiAqL1xuRGF0YUNvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhLCBjaHVua2VkKSB7XG4gIGlmICghdGhpcy5vcGVuKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ29ubmVjdGlvbiBpcyBub3Qgb3Blbi4gWW91IHNob3VsZCBsaXN0ZW4gZm9yIHRoZSBgb3BlbmAgZXZlbnQgYmVmb3JlIHNlbmRpbmcgbWVzc2FnZXMuJykpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodGhpcy5fcmVsaWFibGUpIHtcbiAgICAvLyBOb3RlOiByZWxpYWJsZSBzaGltIHNlbmRpbmcgd2lsbCBtYWtlIGl0IHNvIHRoYXQgeW91IGNhbm5vdCBjdXN0b21pemVcbiAgICAvLyBzZXJpYWxpemF0aW9uLlxuICAgIHRoaXMuX3JlbGlhYmxlLnNlbmQoZGF0YSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuc2VyaWFsaXphdGlvbiA9PT0gJ2pzb24nKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRTZW5kKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgfSBlbHNlIGlmICh0aGlzLnNlcmlhbGl6YXRpb24gPT09ICdiaW5hcnknIHx8IHRoaXMuc2VyaWFsaXphdGlvbiA9PT0gJ2JpbmFyeS11dGY4Jykge1xuICAgIHZhciBibG9iID0gdXRpbC5wYWNrKGRhdGEpO1xuXG4gICAgLy8gRm9yIENocm9tZS1GaXJlZm94IGludGVyb3BlcmFiaWxpdHksIHdlIG5lZWQgdG8gbWFrZSBGaXJlZm94IFwiY2h1bmtcIlxuICAgIC8vIHRoZSBkYXRhIGl0IHNlbmRzIG91dC5cbiAgICB2YXIgbmVlZHNDaHVua2luZyA9IHV0aWwuY2h1bmtlZEJyb3dzZXJzW3RoaXMuX3BlZXJCcm93c2VyXSB8fCB1dGlsLmNodW5rZWRCcm93c2Vyc1t1dGlsLmJyb3dzZXJdO1xuICAgIGlmIChuZWVkc0NodW5raW5nICYmICFjaHVua2VkICYmIGJsb2Iuc2l6ZSA+IHV0aWwuY2h1bmtlZE1UVSkge1xuICAgICAgdGhpcy5fc2VuZENodW5rcyhibG9iKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEYXRhQ2hhbm5lbCBjdXJyZW50bHkgb25seSBzdXBwb3J0cyBzdHJpbmdzLlxuICAgIGlmICghdXRpbC5zdXBwb3J0cy5zY3RwKSB7XG4gICAgICB1dGlsLmJsb2JUb0JpbmFyeVN0cmluZyhibG9iLCBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgc2VsZi5fYnVmZmVyZWRTZW5kKHN0cik7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCF1dGlsLnN1cHBvcnRzLmJpbmFyeUJsb2IpIHtcbiAgICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBpZiB3ZSByZWFsbHkgbmVlZCB0byAoZS5nLiBibG9icyBhcmUgbm90IHN1cHBvcnRlZCksXG4gICAgICAvLyBiZWNhdXNlIHRoaXMgY29udmVyc2lvbiBpcyBjb3N0bHkuXG4gICAgICB1dGlsLmJsb2JUb0FycmF5QnVmZmVyKGJsb2IsIGZ1bmN0aW9uKGFiKSB7XG4gICAgICAgIHNlbGYuX2J1ZmZlcmVkU2VuZChhYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYnVmZmVyZWRTZW5kKGJsb2IpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9idWZmZXJlZFNlbmQoZGF0YSk7XG4gIH1cbn1cblxuRGF0YUNvbm5lY3Rpb24ucHJvdG90eXBlLl9idWZmZXJlZFNlbmQgPSBmdW5jdGlvbihtc2cpIHtcbiAgaWYgKHRoaXMuX2J1ZmZlcmluZyB8fCAhdGhpcy5fdHJ5U2VuZChtc2cpKSB7XG4gICAgdGhpcy5fYnVmZmVyLnB1c2gobXNnKTtcbiAgICB0aGlzLmJ1ZmZlclNpemUgPSB0aGlzLl9idWZmZXIubGVuZ3RoO1xuICB9XG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2VuZCBzdWNjZWVkcy5cbkRhdGFDb25uZWN0aW9uLnByb3RvdHlwZS5fdHJ5U2VuZCA9IGZ1bmN0aW9uKG1zZykge1xuICB0cnkge1xuICAgIHRoaXMuX2RjLnNlbmQobXNnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMuX2J1ZmZlcmluZyA9IHRydWU7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIC8vIFRyeSBhZ2Fpbi5cbiAgICAgIHNlbGYuX2J1ZmZlcmluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5fdHJ5QnVmZmVyKCk7XG4gICAgfSwgMTAwKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIFRyeSB0byBzZW5kIHRoZSBmaXJzdCBtZXNzYWdlIGluIHRoZSBidWZmZXIuXG5EYXRhQ29ubmVjdGlvbi5wcm90b3R5cGUuX3RyeUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtc2cgPSB0aGlzLl9idWZmZXJbMF07XG5cbiAgaWYgKHRoaXMuX3RyeVNlbmQobXNnKSkge1xuICAgIHRoaXMuX2J1ZmZlci5zaGlmdCgpO1xuICAgIHRoaXMuYnVmZmVyU2l6ZSA9IHRoaXMuX2J1ZmZlci5sZW5ndGg7XG4gICAgdGhpcy5fdHJ5QnVmZmVyKCk7XG4gIH1cbn1cblxuRGF0YUNvbm5lY3Rpb24ucHJvdG90eXBlLl9zZW5kQ2h1bmtzID0gZnVuY3Rpb24oYmxvYikge1xuICB2YXIgYmxvYnMgPSB1dGlsLmNodW5rKGJsb2IpO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBibG9icy5sZW5ndGg7IGkgPCBpaTsgaSArPSAxKSB7XG4gICAgdmFyIGJsb2IgPSBibG9ic1tpXTtcbiAgICB0aGlzLnNlbmQoYmxvYiwgdHJ1ZSk7XG4gIH1cbn1cblxuRGF0YUNvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIHZhciBwYXlsb2FkID0gbWVzc2FnZS5wYXlsb2FkO1xuXG4gIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgY2FzZSAnQU5TV0VSJzpcbiAgICAgIHRoaXMuX3BlZXJCcm93c2VyID0gcGF5bG9hZC5icm93c2VyO1xuXG4gICAgICAvLyBGb3J3YXJkIHRvIG5lZ290aWF0b3JcbiAgICAgIE5lZ290aWF0b3IuaGFuZGxlU0RQKG1lc3NhZ2UudHlwZSwgdGhpcywgcGF5bG9hZC5zZHApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQ0FORElEQVRFJzpcbiAgICAgIE5lZ290aWF0b3IuaGFuZGxlQ2FuZGlkYXRlKHRoaXMsIHBheWxvYWQuY2FuZGlkYXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB1dGlsLndhcm4oJ1VucmVjb2duaXplZCBtZXNzYWdlIHR5cGU6JywgbWVzc2FnZS50eXBlLCAnZnJvbSBwZWVyOicsIHRoaXMucGVlcik7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFDb25uZWN0aW9uO1xuXG59LHtcIi4vbmVnb3RpYXRvclwiOjUsXCIuL3V0aWxcIjo4LFwiZXZlbnRlbWl0dGVyM1wiOjksXCJyZWxpYWJsZVwiOjEyfV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gIGlmKHR5cGVvZiB3aW5kb3cgPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcbndpbmRvdy5Tb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xud2luZG93Lk1lZGlhQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vbWVkaWFjb25uZWN0aW9uJyk7XG53aW5kb3cuRGF0YUNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL2RhdGFjb25uZWN0aW9uJyk7XG53aW5kb3cuUGVlciA9IHJlcXVpcmUoJy4vcGVlcicpO1xud2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9hZGFwdGVyJykuUlRDUGVlckNvbm5lY3Rpb247XG53aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uID0gcmVxdWlyZSgnLi9hZGFwdGVyJykuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uO1xud2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA9IHJlcXVpcmUoJy4vYWRhcHRlcicpLlJUQ0ljZUNhbmRpZGF0ZTtcbndpbmRvdy5OZWdvdGlhdG9yID0gcmVxdWlyZSgnLi9uZWdvdGlhdG9yJyk7XG53aW5kb3cudXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xud2luZG93LkJpbmFyeVBhY2sgPSByZXF1aXJlKCdqcy1iaW5hcnlwYWNrJyk7XG5cbn0se1wiLi9hZGFwdGVyXCI6MSxcIi4vZGF0YWNvbm5lY3Rpb25cIjoyLFwiLi9tZWRpYWNvbm5lY3Rpb25cIjo0LFwiLi9uZWdvdGlhdG9yXCI6NSxcIi4vcGVlclwiOjYsXCIuL3NvY2tldFwiOjcsXCIuL3V0aWxcIjo4LFwianMtYmluYXJ5cGFja1wiOjEwfV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKTtcbnZhciBOZWdvdGlhdG9yID0gcmVxdWlyZSgnLi9uZWdvdGlhdG9yJyk7XG5cbi8qKlxuICogV3JhcHMgdGhlIHN0cmVhbWluZyBpbnRlcmZhY2UgYmV0d2VlbiB0d28gUGVlcnMuXG4gKi9cbmZ1bmN0aW9uIE1lZGlhQ29ubmVjdGlvbihwZWVyLCBwcm92aWRlciwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWVkaWFDb25uZWN0aW9uKSkgcmV0dXJuIG5ldyBNZWRpYUNvbm5lY3Rpb24ocGVlciwgcHJvdmlkZXIsIG9wdGlvbnMpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgb3B0aW9ucyk7XG5cbiAgdGhpcy5vcGVuID0gZmFsc2U7XG4gIHRoaXMudHlwZSA9ICdtZWRpYSc7XG4gIHRoaXMucGVlciA9IHBlZXI7XG4gIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgdGhpcy5tZXRhZGF0YSA9IHRoaXMub3B0aW9ucy5tZXRhZGF0YTtcbiAgdGhpcy5sb2NhbFN0cmVhbSA9IHRoaXMub3B0aW9ucy5fc3RyZWFtO1xuXG4gIHRoaXMuaWQgPSB0aGlzLm9wdGlvbnMuY29ubmVjdGlvbklkIHx8IE1lZGlhQ29ubmVjdGlvbi5faWRQcmVmaXggKyB1dGlsLnJhbmRvbVRva2VuKCk7XG4gIGlmICh0aGlzLmxvY2FsU3RyZWFtKSB7XG4gICAgTmVnb3RpYXRvci5zdGFydENvbm5lY3Rpb24oXG4gICAgICB0aGlzLFxuICAgICAge19zdHJlYW06IHRoaXMubG9jYWxTdHJlYW0sIG9yaWdpbmF0b3I6IHRydWV9XG4gICAgKTtcbiAgfVxufTtcblxudXRpbC5pbmhlcml0cyhNZWRpYUNvbm5lY3Rpb24sIEV2ZW50RW1pdHRlcik7XG5cbk1lZGlhQ29ubmVjdGlvbi5faWRQcmVmaXggPSAnbWNfJztcblxuTWVkaWFDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbihyZW1vdGVTdHJlYW0pIHtcbiAgdXRpbC5sb2coJ1JlY2VpdmluZyBzdHJlYW0nLCByZW1vdGVTdHJlYW0pO1xuXG4gIHRoaXMucmVtb3RlU3RyZWFtID0gcmVtb3RlU3RyZWFtO1xuICB0aGlzLmVtaXQoJ3N0cmVhbScsIHJlbW90ZVN0cmVhbSk7IC8vIFNob3VsZCB3ZSBjYWxsIHRoaXMgYG9wZW5gP1xuXG59O1xuXG5NZWRpYUNvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIHZhciBwYXlsb2FkID0gbWVzc2FnZS5wYXlsb2FkO1xuXG4gIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgY2FzZSAnQU5TV0VSJzpcbiAgICAgIC8vIEZvcndhcmQgdG8gbmVnb3RpYXRvclxuICAgICAgTmVnb3RpYXRvci5oYW5kbGVTRFAobWVzc2FnZS50eXBlLCB0aGlzLCBwYXlsb2FkLnNkcCk7XG4gICAgICB0aGlzLm9wZW4gPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQ0FORElEQVRFJzpcbiAgICAgIE5lZ290aWF0b3IuaGFuZGxlQ2FuZGlkYXRlKHRoaXMsIHBheWxvYWQuY2FuZGlkYXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB1dGlsLndhcm4oJ1VucmVjb2duaXplZCBtZXNzYWdlIHR5cGU6JywgbWVzc2FnZS50eXBlLCAnZnJvbSBwZWVyOicsIHRoaXMucGVlcik7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5NZWRpYUNvbm5lY3Rpb24ucHJvdG90eXBlLmFuc3dlciA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICBpZiAodGhpcy5sb2NhbFN0cmVhbSkge1xuICAgIHV0aWwud2FybignTG9jYWwgc3RyZWFtIGFscmVhZHkgZXhpc3RzIG9uIHRoaXMgTWVkaWFDb25uZWN0aW9uLiBBcmUgeW91IGFuc3dlcmluZyBhIGNhbGwgdHdpY2U/Jyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5vcHRpb25zLl9wYXlsb2FkLl9zdHJlYW0gPSBzdHJlYW07XG5cbiAgdGhpcy5sb2NhbFN0cmVhbSA9IHN0cmVhbTtcbiAgTmVnb3RpYXRvci5zdGFydENvbm5lY3Rpb24oXG4gICAgdGhpcyxcbiAgICB0aGlzLm9wdGlvbnMuX3BheWxvYWRcbiAgKVxuICAvLyBSZXRyaWV2ZSBsb3N0IG1lc3NhZ2VzIHN0b3JlZCBiZWNhdXNlIFBlZXJDb25uZWN0aW9uIG5vdCBzZXQgdXAuXG4gIHZhciBtZXNzYWdlcyA9IHRoaXMucHJvdmlkZXIuX2dldE1lc3NhZ2VzKHRoaXMuaWQpO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBtZXNzYWdlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAxKSB7XG4gICAgdGhpcy5oYW5kbGVNZXNzYWdlKG1lc3NhZ2VzW2ldKTtcbiAgfVxuICB0aGlzLm9wZW4gPSB0cnVlO1xufTtcblxuLyoqXG4gKiBFeHBvc2VkIGZ1bmN0aW9uYWxpdHkgZm9yIHVzZXJzLlxuICovXG5cbi8qKiBBbGxvd3MgdXNlciB0byBjbG9zZSBjb25uZWN0aW9uLiAqL1xuTWVkaWFDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMub3Blbikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLm9wZW4gPSBmYWxzZTtcbiAgTmVnb3RpYXRvci5jbGVhbnVwKHRoaXMpO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWVkaWFDb25uZWN0aW9uO1xuXG59LHtcIi4vbmVnb3RpYXRvclwiOjUsXCIuL3V0aWxcIjo4LFwiZXZlbnRlbWl0dGVyM1wiOjl9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgUlRDUGVlckNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL2FkYXB0ZXInKS5SVENQZWVyQ29ubmVjdGlvbjtcbnZhciBSVENTZXNzaW9uRGVzY3JpcHRpb24gPSByZXF1aXJlKCcuL2FkYXB0ZXInKS5SVENTZXNzaW9uRGVzY3JpcHRpb247XG52YXIgUlRDSWNlQ2FuZGlkYXRlID0gcmVxdWlyZSgnLi9hZGFwdGVyJykuUlRDSWNlQ2FuZGlkYXRlO1xuXG4vKipcbiAqIE1hbmFnZXMgYWxsIG5lZ290aWF0aW9ucyBiZXR3ZWVuIFBlZXJzLlxuICovXG52YXIgTmVnb3RpYXRvciA9IHtcbiAgcGNzOiB7XG4gICAgZGF0YToge30sXG4gICAgbWVkaWE6IHt9XG4gIH0sIC8vIHR5cGUgPT4ge3BlZXJJZDoge3BjX2lkOiBwY319LlxuICAvL3Byb3ZpZGVyczoge30sIC8vIHByb3ZpZGVyJ3MgaWQgPT4gcHJvdmlkZXJzICh0aGVyZSBtYXkgYmUgbXVsdGlwbGUgcHJvdmlkZXJzL2NsaWVudC5cbiAgcXVldWU6IFtdIC8vIGNvbm5lY3Rpb25zIHRoYXQgYXJlIGRlbGF5ZWQgZHVlIHRvIGEgUEMgYmVpbmcgaW4gdXNlLlxufVxuXG5OZWdvdGlhdG9yLl9pZFByZWZpeCA9ICdwY18nO1xuXG4vKiogUmV0dXJucyBhIFBlZXJDb25uZWN0aW9uIG9iamVjdCBzZXQgdXAgY29ycmVjdGx5IChmb3IgZGF0YSwgbWVkaWEpLiAqL1xuTmVnb3RpYXRvci5zdGFydENvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25uZWN0aW9uLCBvcHRpb25zKSB7XG4gIHZhciBwYyA9IE5lZ290aWF0b3IuX2dldFBlZXJDb25uZWN0aW9uKGNvbm5lY3Rpb24sIG9wdGlvbnMpO1xuXG4gIGlmIChjb25uZWN0aW9uLnR5cGUgPT09ICdtZWRpYScgJiYgb3B0aW9ucy5fc3RyZWFtKSB7XG4gICAgLy8gQWRkIHRoZSBzdHJlYW0uXG4gICAgcGMuYWRkU3RyZWFtKG9wdGlvbnMuX3N0cmVhbSk7XG4gIH1cblxuICAvLyBTZXQgdGhlIGNvbm5lY3Rpb24ncyBQQy5cbiAgY29ubmVjdGlvbi5wYyA9IGNvbm5lY3Rpb24ucGVlckNvbm5lY3Rpb24gPSBwYztcbiAgLy8gV2hhdCBkbyB3ZSBuZWVkIHRvIGRvIG5vdz9cbiAgaWYgKG9wdGlvbnMub3JpZ2luYXRvcikge1xuICAgIGlmIChjb25uZWN0aW9uLnR5cGUgPT09ICdkYXRhJykge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBkYXRhY2hhbm5lbC5cbiAgICAgIHZhciBjb25maWcgPSB7fTtcbiAgICAgIC8vIERyb3BwaW5nIHJlbGlhYmxlOmZhbHNlIHN1cHBvcnQsIHNpbmNlIGl0IHNlZW1zIHRvIGJlIGNyYXNoaW5nXG4gICAgICAvLyBDaHJvbWUuXG4gICAgICAvKmlmICh1dGlsLnN1cHBvcnRzLnNjdHAgJiYgIW9wdGlvbnMucmVsaWFibGUpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBjYW5vbmljYWwgcmVsaWFibGUgc3VwcG9ydC4uLlxuICAgICAgICBjb25maWcgPSB7bWF4UmV0cmFuc21pdHM6IDB9O1xuICAgICAgfSovXG4gICAgICAvLyBGYWxsYmFjayB0byBlbnN1cmUgb2xkZXIgYnJvd3NlcnMgZG9uJ3QgY3Jhc2guXG4gICAgICBpZiAoIXV0aWwuc3VwcG9ydHMuc2N0cCkge1xuICAgICAgICBjb25maWcgPSB7cmVsaWFibGU6IG9wdGlvbnMucmVsaWFibGV9O1xuICAgICAgfVxuICAgICAgdmFyIGRjID0gcGMuY3JlYXRlRGF0YUNoYW5uZWwoY29ubmVjdGlvbi5sYWJlbCwgY29uZmlnKTtcbiAgICAgIGNvbm5lY3Rpb24uaW5pdGlhbGl6ZShkYyk7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsLnN1cHBvcnRzLm9ubmVnb3RpYXRpb25uZWVkZWQpIHtcbiAgICAgIE5lZ290aWF0b3IuX21ha2VPZmZlcihjb25uZWN0aW9uKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgTmVnb3RpYXRvci5oYW5kbGVTRFAoJ09GRkVSJywgY29ubmVjdGlvbiwgb3B0aW9ucy5zZHApO1xuICB9XG59XG5cbk5lZ290aWF0b3IuX2dldFBlZXJDb25uZWN0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgb3B0aW9ucykge1xuICBpZiAoIU5lZ290aWF0b3IucGNzW2Nvbm5lY3Rpb24udHlwZV0pIHtcbiAgICB1dGlsLmVycm9yKGNvbm5lY3Rpb24udHlwZSArICcgaXMgbm90IGEgdmFsaWQgY29ubmVjdGlvbiB0eXBlLiBNYXliZSB5b3Ugb3ZlcnJvZGUgdGhlIGB0eXBlYCBwcm9wZXJ0eSBzb21ld2hlcmUuJyk7XG4gIH1cblxuICBpZiAoIU5lZ290aWF0b3IucGNzW2Nvbm5lY3Rpb24udHlwZV1bY29ubmVjdGlvbi5wZWVyXSkge1xuICAgIE5lZ290aWF0b3IucGNzW2Nvbm5lY3Rpb24udHlwZV1bY29ubmVjdGlvbi5wZWVyXSA9IHt9O1xuICB9XG4gIHZhciBwZWVyQ29ubmVjdGlvbnMgPSBOZWdvdGlhdG9yLnBjc1tjb25uZWN0aW9uLnR5cGVdW2Nvbm5lY3Rpb24ucGVlcl07XG5cbiAgdmFyIHBjO1xuICAvLyBOb3QgbXVsdGlwbGV4aW5nIHdoaWxlIEZGIGFuZCBDaHJvbWUgaGF2ZSBub3QtZ3JlYXQgc3VwcG9ydCBmb3IgaXQuXG4gIC8qaWYgKG9wdGlvbnMubXVsdGlwbGV4KSB7XG4gICAgaWRzID0gT2JqZWN0LmtleXMocGVlckNvbm5lY3Rpb25zKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBpZHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMSkge1xuICAgICAgcGMgPSBwZWVyQ29ubmVjdGlvbnNbaWRzW2ldXTtcbiAgICAgIGlmIChwYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ3N0YWJsZScpIHtcbiAgICAgICAgYnJlYWs7IC8vIFdlIGNhbiBnbyBhaGVhZCBhbmQgdXNlIHRoaXMgUEMuXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgKi9cbiAgaWYgKG9wdGlvbnMucGMpIHsgLy8gU2ltcGxlc3QgY2FzZTogUEMgaWQgYWxyZWFkeSBwcm92aWRlZCBmb3IgdXMuXG4gICAgcGMgPSBOZWdvdGlhdG9yLnBjc1tjb25uZWN0aW9uLnR5cGVdW2Nvbm5lY3Rpb24ucGVlcl1bb3B0aW9ucy5wY107XG4gIH1cblxuICBpZiAoIXBjIHx8IHBjLnNpZ25hbGluZ1N0YXRlICE9PSAnc3RhYmxlJykge1xuICAgIHBjID0gTmVnb3RpYXRvci5fc3RhcnRQZWVyQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gcGM7XG59XG5cbi8qXG5OZWdvdGlhdG9yLl9hZGRQcm92aWRlciA9IGZ1bmN0aW9uKHByb3ZpZGVyKSB7XG4gIGlmICgoIXByb3ZpZGVyLmlkICYmICFwcm92aWRlci5kaXNjb25uZWN0ZWQpIHx8ICFwcm92aWRlci5zb2NrZXQub3Blbikge1xuICAgIC8vIFdhaXQgZm9yIHByb3ZpZGVyIHRvIG9idGFpbiBhbiBJRC5cbiAgICBwcm92aWRlci5vbignb3BlbicsIGZ1bmN0aW9uKGlkKSB7XG4gICAgICBOZWdvdGlhdG9yLl9hZGRQcm92aWRlcihwcm92aWRlcik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgTmVnb3RpYXRvci5wcm92aWRlcnNbcHJvdmlkZXIuaWRdID0gcHJvdmlkZXI7XG4gIH1cbn0qL1xuXG5cbi8qKiBTdGFydCBhIFBDLiAqL1xuTmVnb3RpYXRvci5fc3RhcnRQZWVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgdXRpbC5sb2coJ0NyZWF0aW5nIFJUQ1BlZXJDb25uZWN0aW9uLicpO1xuXG4gIHZhciBpZCA9IE5lZ290aWF0b3IuX2lkUHJlZml4ICsgdXRpbC5yYW5kb21Ub2tlbigpO1xuICB2YXIgb3B0aW9uYWwgPSB7fTtcblxuICBpZiAoY29ubmVjdGlvbi50eXBlID09PSAnZGF0YScgJiYgIXV0aWwuc3VwcG9ydHMuc2N0cCkge1xuICAgIG9wdGlvbmFsID0ge29wdGlvbmFsOiBbe1J0cERhdGFDaGFubmVsczogdHJ1ZX1dfTtcbiAgfSBlbHNlIGlmIChjb25uZWN0aW9uLnR5cGUgPT09ICdtZWRpYScpIHtcbiAgICAvLyBJbnRlcm9wIHJlcSBmb3IgY2hyb21lLlxuICAgIG9wdGlvbmFsID0ge29wdGlvbmFsOiBbe0R0bHNTcnRwS2V5QWdyZWVtZW50OiB0cnVlfV19O1xuICB9XG5cbiAgdmFyIHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKGNvbm5lY3Rpb24ucHJvdmlkZXIub3B0aW9ucy5jb25maWcsIG9wdGlvbmFsKTtcbiAgTmVnb3RpYXRvci5wY3NbY29ubmVjdGlvbi50eXBlXVtjb25uZWN0aW9uLnBlZXJdW2lkXSA9IHBjO1xuXG4gIE5lZ290aWF0b3IuX3NldHVwTGlzdGVuZXJzKGNvbm5lY3Rpb24sIHBjLCBpZCk7XG5cbiAgcmV0dXJuIHBjO1xufVxuXG4vKiogU2V0IHVwIHZhcmlvdXMgV2ViUlRDIGxpc3RlbmVycy4gKi9cbk5lZ290aWF0b3IuX3NldHVwTGlzdGVuZXJzID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgcGMsIHBjX2lkKSB7XG4gIHZhciBwZWVySWQgPSBjb25uZWN0aW9uLnBlZXI7XG4gIHZhciBjb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uLmlkO1xuICB2YXIgcHJvdmlkZXIgPSBjb25uZWN0aW9uLnByb3ZpZGVyO1xuXG4gIC8vIElDRSBDQU5ESURBVEVTLlxuICB1dGlsLmxvZygnTGlzdGVuaW5nIGZvciBJQ0UgY2FuZGlkYXRlcy4nKTtcbiAgcGMub25pY2VjYW5kaWRhdGUgPSBmdW5jdGlvbihldnQpIHtcbiAgICBpZiAoZXZ0LmNhbmRpZGF0ZSkge1xuICAgICAgdXRpbC5sb2coJ1JlY2VpdmVkIElDRSBjYW5kaWRhdGVzIGZvcjonLCBjb25uZWN0aW9uLnBlZXIpO1xuICAgICAgcHJvdmlkZXIuc29ja2V0LnNlbmQoe1xuICAgICAgICB0eXBlOiAnQ0FORElEQVRFJyxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIGNhbmRpZGF0ZTogZXZ0LmNhbmRpZGF0ZSxcbiAgICAgICAgICB0eXBlOiBjb25uZWN0aW9uLnR5cGUsXG4gICAgICAgICAgY29ubmVjdGlvbklkOiBjb25uZWN0aW9uLmlkXG4gICAgICAgIH0sXG4gICAgICAgIGRzdDogcGVlcklkXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHBjLmljZUNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgIHV0aWwubG9nKCdpY2VDb25uZWN0aW9uU3RhdGUgaXMgZGlzY29ubmVjdGVkLCBjbG9zaW5nIGNvbm5lY3Rpb25zIHRvICcgKyBwZWVySWQpO1xuICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgcGMub25pY2VjYW5kaWRhdGUgPSB1dGlsLm5vb3A7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcblxuICAvLyBGYWxsYmFjayBmb3Igb2xkZXIgQ2hyb21lIGltcGxzLlxuICBwYy5vbmljZWNoYW5nZSA9IHBjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlO1xuXG4gIC8vIE9OTkVHT1RJQVRJT05ORUVERUQgKENocm9tZSlcbiAgdXRpbC5sb2coJ0xpc3RlbmluZyBmb3IgYG5lZ290aWF0aW9ubmVlZGVkYCcpO1xuICBwYy5vbm5lZ290aWF0aW9ubmVlZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdXRpbC5sb2coJ2BuZWdvdGlhdGlvbm5lZWRlZGAgdHJpZ2dlcmVkJyk7XG4gICAgaWYgKHBjLnNpZ25hbGluZ1N0YXRlID09ICdzdGFibGUnKSB7XG4gICAgICBOZWdvdGlhdG9yLl9tYWtlT2ZmZXIoY29ubmVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwubG9nKCdvbm5lZ290aWF0aW9ubmVlZGVkIHRyaWdnZXJlZCB3aGVuIG5vdCBzdGFibGUuIElzIGFub3RoZXIgY29ubmVjdGlvbiBiZWluZyBlc3RhYmxpc2hlZD8nKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gREFUQUNPTk5FQ1RJT04uXG4gIHV0aWwubG9nKCdMaXN0ZW5pbmcgZm9yIGRhdGEgY2hhbm5lbCcpO1xuICAvLyBGaXJlZCBiZXR3ZWVuIG9mZmVyIGFuZCBhbnN3ZXIsIHNvIG9wdGlvbnMgc2hvdWxkIGFscmVhZHkgYmUgc2F2ZWRcbiAgLy8gaW4gdGhlIG9wdGlvbnMgaGFzaC5cbiAgcGMub25kYXRhY2hhbm5lbCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIHV0aWwubG9nKCdSZWNlaXZlZCBkYXRhIGNoYW5uZWwnKTtcbiAgICB2YXIgZGMgPSBldnQuY2hhbm5lbDtcbiAgICB2YXIgY29ubmVjdGlvbiA9IHByb3ZpZGVyLmdldENvbm5lY3Rpb24ocGVlcklkLCBjb25uZWN0aW9uSWQpO1xuICAgIGNvbm5lY3Rpb24uaW5pdGlhbGl6ZShkYyk7XG4gIH07XG5cbiAgLy8gTUVESUFDT05ORUNUSU9OLlxuICB1dGlsLmxvZygnTGlzdGVuaW5nIGZvciByZW1vdGUgc3RyZWFtJyk7XG4gIHBjLm9uYWRkc3RyZWFtID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgdXRpbC5sb2coJ1JlY2VpdmVkIHJlbW90ZSBzdHJlYW0nKTtcbiAgICB2YXIgc3RyZWFtID0gZXZ0LnN0cmVhbTtcbiAgICB2YXIgY29ubmVjdGlvbiA9IHByb3ZpZGVyLmdldENvbm5lY3Rpb24ocGVlcklkLCBjb25uZWN0aW9uSWQpO1xuICAgIC8vIDEwLzEwLzIwMTQ6IGxvb2tzIGxpa2UgaW4gQ2hyb21lIDM4LCBvbmFkZHN0cmVhbSBpcyB0cmlnZ2VyZWQgYWZ0ZXJcbiAgICAvLyBzZXR0aW5nIHRoZSByZW1vdGUgZGVzY3JpcHRpb24uIE91ciBjb25uZWN0aW9uIG9iamVjdCBpbiB0aGVzZSBjYXNlc1xuICAgIC8vIGlzIGFjdHVhbGx5IGEgREFUQSBjb25uZWN0aW9uLCBzbyBhZGRTdHJlYW0gZmFpbHMuXG4gICAgLy8gVE9ETzogVGhpcyBpcyBob3BlZnVsbHkganVzdCBhIHRlbXBvcmFyeSBmaXguIFdlIHNob3VsZCB0cnkgdG9cbiAgICAvLyB1bmRlcnN0YW5kIHdoeSB0aGlzIGlzIGhhcHBlbmluZy5cbiAgICBpZiAoY29ubmVjdGlvbi50eXBlID09PSAnbWVkaWEnKSB7XG4gICAgICBjb25uZWN0aW9uLmFkZFN0cmVhbShzdHJlYW0pO1xuICAgIH1cbiAgfTtcbn1cblxuTmVnb3RpYXRvci5jbGVhbnVwID0gZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICB1dGlsLmxvZygnQ2xlYW5pbmcgdXAgUGVlckNvbm5lY3Rpb24gdG8gJyArIGNvbm5lY3Rpb24ucGVlcik7XG5cbiAgdmFyIHBjID0gY29ubmVjdGlvbi5wYztcblxuICBpZiAoISFwYyAmJiAocGMucmVhZHlTdGF0ZSAhPT0gJ2Nsb3NlZCcgfHwgcGMuc2lnbmFsaW5nU3RhdGUgIT09ICdjbG9zZWQnKSkge1xuICAgIHBjLmNsb3NlKCk7XG4gICAgY29ubmVjdGlvbi5wYyA9IG51bGw7XG4gIH1cbn1cblxuTmVnb3RpYXRvci5fbWFrZU9mZmVyID0gZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICB2YXIgcGMgPSBjb25uZWN0aW9uLnBjO1xuICBwYy5jcmVhdGVPZmZlcihmdW5jdGlvbihvZmZlcikge1xuICAgIHV0aWwubG9nKCdDcmVhdGVkIG9mZmVyLicpO1xuXG4gICAgaWYgKCF1dGlsLnN1cHBvcnRzLnNjdHAgJiYgY29ubmVjdGlvbi50eXBlID09PSAnZGF0YScgJiYgY29ubmVjdGlvbi5yZWxpYWJsZSkge1xuICAgICAgb2ZmZXIuc2RwID0gUmVsaWFibGUuaGlnaGVyQmFuZHdpZHRoU0RQKG9mZmVyLnNkcCk7XG4gICAgfVxuXG4gICAgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlciwgZnVuY3Rpb24oKSB7XG4gICAgICB1dGlsLmxvZygnU2V0IGxvY2FsRGVzY3JpcHRpb246IG9mZmVyJywgJ2ZvcjonLCBjb25uZWN0aW9uLnBlZXIpO1xuICAgICAgY29ubmVjdGlvbi5wcm92aWRlci5zb2NrZXQuc2VuZCh7XG4gICAgICAgIHR5cGU6ICdPRkZFUicsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBzZHA6IG9mZmVyLFxuICAgICAgICAgIHR5cGU6IGNvbm5lY3Rpb24udHlwZSxcbiAgICAgICAgICBsYWJlbDogY29ubmVjdGlvbi5sYWJlbCxcbiAgICAgICAgICBjb25uZWN0aW9uSWQ6IGNvbm5lY3Rpb24uaWQsXG4gICAgICAgICAgcmVsaWFibGU6IGNvbm5lY3Rpb24ucmVsaWFibGUsXG4gICAgICAgICAgc2VyaWFsaXphdGlvbjogY29ubmVjdGlvbi5zZXJpYWxpemF0aW9uLFxuICAgICAgICAgIG1ldGFkYXRhOiBjb25uZWN0aW9uLm1ldGFkYXRhLFxuICAgICAgICAgIGJyb3dzZXI6IHV0aWwuYnJvd3NlclxuICAgICAgICB9LFxuICAgICAgICBkc3Q6IGNvbm5lY3Rpb24ucGVlclxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBjb25uZWN0aW9uLnByb3ZpZGVyLmVtaXRFcnJvcignd2VicnRjJywgZXJyKTtcbiAgICAgIHV0aWwubG9nKCdGYWlsZWQgdG8gc2V0TG9jYWxEZXNjcmlwdGlvbiwgJywgZXJyKTtcbiAgICB9KTtcbiAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgY29ubmVjdGlvbi5wcm92aWRlci5lbWl0RXJyb3IoJ3dlYnJ0YycsIGVycik7XG4gICAgdXRpbC5sb2coJ0ZhaWxlZCB0byBjcmVhdGVPZmZlciwgJywgZXJyKTtcbiAgfSwgY29ubmVjdGlvbi5vcHRpb25zLmNvbnN0cmFpbnRzKTtcbn1cblxuTmVnb3RpYXRvci5fbWFrZUFuc3dlciA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgdmFyIHBjID0gY29ubmVjdGlvbi5wYztcblxuICBwYy5jcmVhdGVBbnN3ZXIoZnVuY3Rpb24oYW5zd2VyKSB7XG4gICAgdXRpbC5sb2coJ0NyZWF0ZWQgYW5zd2VyLicpO1xuXG4gICAgaWYgKCF1dGlsLnN1cHBvcnRzLnNjdHAgJiYgY29ubmVjdGlvbi50eXBlID09PSAnZGF0YScgJiYgY29ubmVjdGlvbi5yZWxpYWJsZSkge1xuICAgICAgYW5zd2VyLnNkcCA9IFJlbGlhYmxlLmhpZ2hlckJhbmR3aWR0aFNEUChhbnN3ZXIuc2RwKTtcbiAgICB9XG5cbiAgICBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlciwgZnVuY3Rpb24oKSB7XG4gICAgICB1dGlsLmxvZygnU2V0IGxvY2FsRGVzY3JpcHRpb246IGFuc3dlcicsICdmb3I6JywgY29ubmVjdGlvbi5wZWVyKTtcbiAgICAgIGNvbm5lY3Rpb24ucHJvdmlkZXIuc29ja2V0LnNlbmQoe1xuICAgICAgICB0eXBlOiAnQU5TV0VSJyxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIHNkcDogYW5zd2VyLFxuICAgICAgICAgIHR5cGU6IGNvbm5lY3Rpb24udHlwZSxcbiAgICAgICAgICBjb25uZWN0aW9uSWQ6IGNvbm5lY3Rpb24uaWQsXG4gICAgICAgICAgYnJvd3NlcjogdXRpbC5icm93c2VyXG4gICAgICAgIH0sXG4gICAgICAgIGRzdDogY29ubmVjdGlvbi5wZWVyXG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGNvbm5lY3Rpb24ucHJvdmlkZXIuZW1pdEVycm9yKCd3ZWJydGMnLCBlcnIpO1xuICAgICAgdXRpbC5sb2coJ0ZhaWxlZCB0byBzZXRMb2NhbERlc2NyaXB0aW9uLCAnLCBlcnIpO1xuICAgIH0pO1xuICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICBjb25uZWN0aW9uLnByb3ZpZGVyLmVtaXRFcnJvcignd2VicnRjJywgZXJyKTtcbiAgICB1dGlsLmxvZygnRmFpbGVkIHRvIGNyZWF0ZSBhbnN3ZXIsICcsIGVycik7XG4gIH0pO1xufVxuXG4vKiogSGFuZGxlIGFuIFNEUC4gKi9cbk5lZ290aWF0b3IuaGFuZGxlU0RQID0gZnVuY3Rpb24odHlwZSwgY29ubmVjdGlvbiwgc2RwKSB7XG4gIHNkcCA9IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oc2RwKTtcbiAgdmFyIHBjID0gY29ubmVjdGlvbi5wYztcblxuICB1dGlsLmxvZygnU2V0dGluZyByZW1vdGUgZGVzY3JpcHRpb24nLCBzZHApO1xuICBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZHAsIGZ1bmN0aW9uKCkge1xuICAgIHV0aWwubG9nKCdTZXQgcmVtb3RlRGVzY3JpcHRpb246JywgdHlwZSwgJ2ZvcjonLCBjb25uZWN0aW9uLnBlZXIpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdPRkZFUicpIHtcbiAgICAgIE5lZ290aWF0b3IuX21ha2VBbnN3ZXIoY29ubmVjdGlvbik7XG4gICAgfVxuICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICBjb25uZWN0aW9uLnByb3ZpZGVyLmVtaXRFcnJvcignd2VicnRjJywgZXJyKTtcbiAgICB1dGlsLmxvZygnRmFpbGVkIHRvIHNldFJlbW90ZURlc2NyaXB0aW9uLCAnLCBlcnIpO1xuICB9KTtcbn1cblxuLyoqIEhhbmRsZSBhIGNhbmRpZGF0ZS4gKi9cbk5lZ290aWF0b3IuaGFuZGxlQ2FuZGlkYXRlID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgaWNlKSB7XG4gIHZhciBjYW5kaWRhdGUgPSBpY2UuY2FuZGlkYXRlO1xuICB2YXIgc2RwTUxpbmVJbmRleCA9IGljZS5zZHBNTGluZUluZGV4O1xuICBjb25uZWN0aW9uLnBjLmFkZEljZUNhbmRpZGF0ZShuZXcgUlRDSWNlQ2FuZGlkYXRlKHtcbiAgICBzZHBNTGluZUluZGV4OiBzZHBNTGluZUluZGV4LFxuICAgIGNhbmRpZGF0ZTogY2FuZGlkYXRlXG4gIH0pKTtcbiAgdXRpbC5sb2coJ0FkZGVkIElDRSBjYW5kaWRhdGUgZm9yOicsIGNvbm5lY3Rpb24ucGVlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTmVnb3RpYXRvcjtcblxufSx7XCIuL2FkYXB0ZXJcIjoxLFwiLi91dGlsXCI6OH1dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XG52YXIgU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbnZhciBNZWRpYUNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL21lZGlhY29ubmVjdGlvbicpO1xudmFyIERhdGFDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9kYXRhY29ubmVjdGlvbicpO1xuXG4vKipcbiAqIEEgcGVlciB3aG8gY2FuIGluaXRpYXRlIGNvbm5lY3Rpb25zIHdpdGggb3RoZXIgcGVlcnMuXG4gKi9cbmZ1bmN0aW9uIFBlZXIoaWQsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBlZXIpKSByZXR1cm4gbmV3IFBlZXIoaWQsIG9wdGlvbnMpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAvLyBEZWFsIHdpdGggb3ZlcmxvYWRpbmdcbiAgaWYgKGlkICYmIGlkLmNvbnN0cnVjdG9yID09IE9iamVjdCkge1xuICAgIG9wdGlvbnMgPSBpZDtcbiAgICBpZCA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChpZCkge1xuICAgIC8vIEVuc3VyZSBpZCBpcyBhIHN0cmluZ1xuICAgIGlkID0gaWQudG9TdHJpbmcoKTtcbiAgfVxuICAvL1xuXG4gIC8vIENvbmZpZ3VyaXplIG9wdGlvbnNcbiAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICBkZWJ1ZzogMCwgLy8gMTogRXJyb3JzLCAyOiBXYXJuaW5ncywgMzogQWxsIGxvZ3NcbiAgICBob3N0OiB1dGlsLkNMT1VEX0hPU1QsXG4gICAgcG9ydDogdXRpbC5DTE9VRF9QT1JULFxuICAgIGtleTogJ3BlZXJqcycsXG4gICAgcGF0aDogJy8nLFxuICAgIHRva2VuOiB1dGlsLnJhbmRvbVRva2VuKCksXG4gICAgY29uZmlnOiB1dGlsLmRlZmF1bHRDb25maWdcbiAgfSwgb3B0aW9ucyk7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIC8vIERldGVjdCByZWxhdGl2ZSBVUkwgaG9zdC5cbiAgaWYgKG9wdGlvbnMuaG9zdCA9PT0gJy8nKSB7XG4gICAgb3B0aW9ucy5ob3N0ID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICB9XG4gIC8vIFNldCBwYXRoIGNvcnJlY3RseS5cbiAgaWYgKG9wdGlvbnMucGF0aFswXSAhPT0gJy8nKSB7XG4gICAgb3B0aW9ucy5wYXRoID0gJy8nICsgb3B0aW9ucy5wYXRoO1xuICB9XG4gIGlmIChvcHRpb25zLnBhdGhbb3B0aW9ucy5wYXRoLmxlbmd0aCAtIDFdICE9PSAnLycpIHtcbiAgICBvcHRpb25zLnBhdGggKz0gJy8nO1xuICB9XG5cbiAgLy8gU2V0IHdoZXRoZXIgd2UgdXNlIFNTTCB0byBzYW1lIGFzIGN1cnJlbnQgaG9zdFxuICBpZiAob3B0aW9ucy5zZWN1cmUgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhvc3QgIT09IHV0aWwuQ0xPVURfSE9TVCkge1xuICAgIG9wdGlvbnMuc2VjdXJlID0gdXRpbC5pc1NlY3VyZSgpO1xuICB9XG4gIC8vIFNldCBhIGN1c3RvbSBsb2cgZnVuY3Rpb24gaWYgcHJlc2VudFxuICBpZiAob3B0aW9ucy5sb2dGdW5jdGlvbikge1xuICAgIHV0aWwuc2V0TG9nRnVuY3Rpb24ob3B0aW9ucy5sb2dGdW5jdGlvbik7XG4gIH1cbiAgdXRpbC5zZXRMb2dMZXZlbChvcHRpb25zLmRlYnVnKTtcbiAgLy9cblxuICAvLyBTYW5pdHkgY2hlY2tzXG4gIC8vIEVuc3VyZSBXZWJSVEMgc3VwcG9ydGVkXG4gIGlmICghdXRpbC5zdXBwb3J0cy5hdWRpb1ZpZGVvICYmICF1dGlsLnN1cHBvcnRzLmRhdGEgKSB7XG4gICAgdGhpcy5fZGVsYXllZEFib3J0KCdicm93c2VyLWluY29tcGF0aWJsZScsICdUaGUgY3VycmVudCBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViUlRDJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEVuc3VyZSBhbHBoYW51bWVyaWMgaWRcbiAgaWYgKCF1dGlsLnZhbGlkYXRlSWQoaWQpKSB7XG4gICAgdGhpcy5fZGVsYXllZEFib3J0KCdpbnZhbGlkLWlkJywgJ0lEIFwiJyArIGlkICsgJ1wiIGlzIGludmFsaWQnKTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gRW5zdXJlIHZhbGlkIGtleVxuICBpZiAoIXV0aWwudmFsaWRhdGVLZXkob3B0aW9ucy5rZXkpKSB7XG4gICAgdGhpcy5fZGVsYXllZEFib3J0KCdpbnZhbGlkLWtleScsICdBUEkgS0VZIFwiJyArIG9wdGlvbnMua2V5ICsgJ1wiIGlzIGludmFsaWQnKTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gRW5zdXJlIG5vdCB1c2luZyB1bnNlY3VyZSBjbG91ZCBzZXJ2ZXIgb24gU1NMIHBhZ2VcbiAgaWYgKG9wdGlvbnMuc2VjdXJlICYmIG9wdGlvbnMuaG9zdCA9PT0gJzAucGVlcmpzLmNvbScpIHtcbiAgICB0aGlzLl9kZWxheWVkQWJvcnQoJ3NzbC11bmF2YWlsYWJsZScsXG4gICAgICAnVGhlIGNsb3VkIHNlcnZlciBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCBIVFRQUy4gUGxlYXNlIHJ1biB5b3VyIG93biBQZWVyU2VydmVyIHRvIHVzZSBIVFRQUy4nKTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy9cblxuICAvLyBTdGF0ZXMuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIENvbm5lY3Rpb25zIGhhdmUgYmVlbiBraWxsZWRcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTsgLy8gQ29ubmVjdGlvbiB0byBQZWVyU2VydmVyIGtpbGxlZCBidXQgUDJQIGNvbm5lY3Rpb25zIHN0aWxsIGFjdGl2ZVxuICB0aGlzLm9wZW4gPSBmYWxzZTsgLy8gU29ja2V0cyBhbmQgc3VjaCBhcmUgbm90IHlldCBvcGVuLlxuICAvL1xuXG4gIC8vIFJlZmVyZW5jZXNcbiAgdGhpcy5jb25uZWN0aW9ucyA9IHt9OyAvLyBEYXRhQ29ubmVjdGlvbnMgZm9yIHRoaXMgcGVlci5cbiAgdGhpcy5fbG9zdE1lc3NhZ2VzID0ge307IC8vIHNyYyA9PiBbbGlzdCBvZiBtZXNzYWdlc11cbiAgLy9cblxuICAvLyBTdGFydCB0aGUgc2VydmVyIGNvbm5lY3Rpb25cbiAgdGhpcy5faW5pdGlhbGl6ZVNlcnZlckNvbm5lY3Rpb24oKTtcbiAgaWYgKGlkKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZShpZCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fcmV0cmlldmVJZCgpO1xuICB9XG4gIC8vXG59XG5cbnV0aWwuaW5oZXJpdHMoUGVlciwgRXZlbnRFbWl0dGVyKTtcblxuLy8gSW5pdGlhbGl6ZSB0aGUgJ3NvY2tldCcgKHdoaWNoIGlzIGFjdHVhbGx5IGEgbWl4IG9mIFhIUiBzdHJlYW1pbmcgYW5kXG4vLyB3ZWJzb2NrZXRzLilcblBlZXIucHJvdG90eXBlLl9pbml0aWFsaXplU2VydmVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc29ja2V0ID0gbmV3IFNvY2tldCh0aGlzLm9wdGlvbnMuc2VjdXJlLCB0aGlzLm9wdGlvbnMuaG9zdCwgdGhpcy5vcHRpb25zLnBvcnQsIHRoaXMub3B0aW9ucy5wYXRoLCB0aGlzLm9wdGlvbnMua2V5KTtcbiAgdGhpcy5zb2NrZXQub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgc2VsZi5faGFuZGxlTWVzc2FnZShkYXRhKTtcbiAgfSk7XG4gIHRoaXMuc29ja2V0Lm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgc2VsZi5fYWJvcnQoJ3NvY2tldC1lcnJvcicsIGVycm9yKTtcbiAgfSk7XG4gIHRoaXMuc29ja2V0Lm9uKCdkaXNjb25uZWN0ZWQnLCBmdW5jdGlvbigpIHtcbiAgICAvLyBJZiB3ZSBoYXZlbid0IGV4cGxpY2l0bHkgZGlzY29ubmVjdGVkLCBlbWl0IGVycm9yIGFuZCBkaXNjb25uZWN0LlxuICAgIGlmICghc2VsZi5kaXNjb25uZWN0ZWQpIHtcbiAgICAgIHNlbGYuZW1pdEVycm9yKCduZXR3b3JrJywgJ0xvc3QgY29ubmVjdGlvbiB0byBzZXJ2ZXIuJyk7XG4gICAgICBzZWxmLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH0pO1xuICB0aGlzLnNvY2tldC5vbignY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAvLyBJZiB3ZSBoYXZlbid0IGV4cGxpY2l0bHkgZGlzY29ubmVjdGVkLCBlbWl0IGVycm9yLlxuICAgIGlmICghc2VsZi5kaXNjb25uZWN0ZWQpIHtcbiAgICAgIHNlbGYuX2Fib3J0KCdzb2NrZXQtY2xvc2VkJywgJ1VuZGVybHlpbmcgc29ja2V0IGlzIGFscmVhZHkgY2xvc2VkLicpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKiogR2V0IGEgdW5pcXVlIElEIGZyb20gdGhlIHNlcnZlciB2aWEgWEhSLiAqL1xuUGVlci5wcm90b3R5cGUuX3JldHJpZXZlSWQgPSBmdW5jdGlvbihjYikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHZhciBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5zZWN1cmUgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nO1xuICB2YXIgdXJsID0gcHJvdG9jb2wgKyB0aGlzLm9wdGlvbnMuaG9zdCArICc6JyArIHRoaXMub3B0aW9ucy5wb3J0ICtcbiAgICB0aGlzLm9wdGlvbnMucGF0aCArIHRoaXMub3B0aW9ucy5rZXkgKyAnL2lkJztcbiAgdmFyIHF1ZXJ5U3RyaW5nID0gJz90cz0nICsgbmV3IERhdGUoKS5nZXRUaW1lKCkgKyAnJyArIE1hdGgucmFuZG9tKCk7XG4gIHVybCArPSBxdWVyeVN0cmluZztcblxuICAvLyBJZiB0aGVyZSdzIG5vIElEIHdlIG5lZWQgdG8gd2FpdCBmb3Igb25lIGJlZm9yZSB0cnlpbmcgdG8gaW5pdCBzb2NrZXQuXG4gIGh0dHAub3BlbignZ2V0JywgdXJsLCB0cnVlKTtcbiAgaHR0cC5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIHV0aWwuZXJyb3IoJ0Vycm9yIHJldHJpZXZpbmcgSUQnLCBlKTtcbiAgICB2YXIgcGF0aEVycm9yID0gJyc7XG4gICAgaWYgKHNlbGYub3B0aW9ucy5wYXRoID09PSAnLycgJiYgc2VsZi5vcHRpb25zLmhvc3QgIT09IHV0aWwuQ0xPVURfSE9TVCkge1xuICAgICAgcGF0aEVycm9yID0gJyBJZiB5b3UgcGFzc2VkIGluIGEgYHBhdGhgIHRvIHlvdXIgc2VsZi1ob3N0ZWQgUGVlclNlcnZlciwgJyArXG4gICAgICAgICd5b3VcXCdsbCBhbHNvIG5lZWQgdG8gcGFzcyBpbiB0aGF0IHNhbWUgcGF0aCB3aGVuIGNyZWF0aW5nIGEgbmV3ICcgK1xuICAgICAgICAnUGVlci4nO1xuICAgIH1cbiAgICBzZWxmLl9hYm9ydCgnc2VydmVyLWVycm9yJywgJ0NvdWxkIG5vdCBnZXQgYW4gSUQgZnJvbSB0aGUgc2VydmVyLicgKyBwYXRoRXJyb3IpO1xuICB9O1xuICBodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChodHRwLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGh0dHAuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIGh0dHAub25lcnJvcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLl9pbml0aWFsaXplKGh0dHAucmVzcG9uc2VUZXh0KTtcbiAgfTtcbiAgaHR0cC5zZW5kKG51bGwpO1xufTtcblxuLyoqIEluaXRpYWxpemUgYSBjb25uZWN0aW9uIHdpdGggdGhlIHNlcnZlci4gKi9cblBlZXIucHJvdG90eXBlLl9pbml0aWFsaXplID0gZnVuY3Rpb24oaWQpIHtcbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLnNvY2tldC5zdGFydCh0aGlzLmlkLCB0aGlzLm9wdGlvbnMudG9rZW4pO1xufTtcblxuLyoqIEhhbmRsZXMgbWVzc2FnZXMgZnJvbSB0aGUgc2VydmVyLiAqL1xuUGVlci5wcm90b3R5cGUuX2hhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIHZhciB0eXBlID0gbWVzc2FnZS50eXBlO1xuICB2YXIgcGF5bG9hZCA9IG1lc3NhZ2UucGF5bG9hZDtcbiAgdmFyIHBlZXIgPSBtZXNzYWdlLnNyYztcbiAgdmFyIGNvbm5lY3Rpb247XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnT1BFTic6IC8vIFRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaXMgb3Blbi5cbiAgICAgIHRoaXMuZW1pdCgnb3BlbicsIHRoaXMuaWQpO1xuICAgICAgdGhpcy5vcGVuID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0VSUk9SJzogLy8gU2VydmVyIGVycm9yLlxuICAgICAgdGhpcy5fYWJvcnQoJ3NlcnZlci1lcnJvcicsIHBheWxvYWQubXNnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0lELVRBS0VOJzogLy8gVGhlIHNlbGVjdGVkIElEIGlzIHRha2VuLlxuICAgICAgdGhpcy5fYWJvcnQoJ3VuYXZhaWxhYmxlLWlkJywgJ0lEIGAnICsgdGhpcy5pZCArICdgIGlzIHRha2VuJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdJTlZBTElELUtFWSc6IC8vIFRoZSBnaXZlbiBBUEkga2V5IGNhbm5vdCBiZSBmb3VuZC5cbiAgICAgIHRoaXMuX2Fib3J0KCdpbnZhbGlkLWtleScsICdBUEkgS0VZIFwiJyArIHRoaXMub3B0aW9ucy5rZXkgKyAnXCIgaXMgaW52YWxpZCcpO1xuICAgICAgYnJlYWs7XG5cbiAgICAvL1xuICAgIGNhc2UgJ0xFQVZFJzogLy8gQW5vdGhlciBwZWVyIGhhcyBjbG9zZWQgaXRzIGNvbm5lY3Rpb24gdG8gdGhpcyBwZWVyLlxuICAgICAgdXRpbC5sb2coJ1JlY2VpdmVkIGxlYXZlIG1lc3NhZ2UgZnJvbScsIHBlZXIpO1xuICAgICAgdGhpcy5fY2xlYW51cFBlZXIocGVlcik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ0VYUElSRSc6IC8vIFRoZSBvZmZlciBzZW50IHRvIGEgcGVlciBoYXMgZXhwaXJlZCB3aXRob3V0IHJlc3BvbnNlLlxuICAgICAgdGhpcy5lbWl0RXJyb3IoJ3BlZXItdW5hdmFpbGFibGUnLCAnQ291bGQgbm90IGNvbm5lY3QgdG8gcGVlciAnICsgcGVlcik7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdPRkZFUic6IC8vIHdlIHNob3VsZCBjb25zaWRlciBzd2l0Y2hpbmcgdGhpcyB0byBDQUxML0NPTk5FQ1QsIGJ1dCB0aGlzIGlzIHRoZSBsZWFzdCBicmVha2luZyBvcHRpb24uXG4gICAgICB2YXIgY29ubmVjdGlvbklkID0gcGF5bG9hZC5jb25uZWN0aW9uSWQ7XG4gICAgICBjb25uZWN0aW9uID0gdGhpcy5nZXRDb25uZWN0aW9uKHBlZXIsIGNvbm5lY3Rpb25JZCk7XG5cbiAgICAgIGlmIChjb25uZWN0aW9uKSB7XG4gICAgICAgIHV0aWwud2FybignT2ZmZXIgcmVjZWl2ZWQgZm9yIGV4aXN0aW5nIENvbm5lY3Rpb24gSUQ6JywgY29ubmVjdGlvbklkKTtcbiAgICAgICAgLy9jb25uZWN0aW9uLmhhbmRsZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY29ubmVjdGlvbi5cbiAgICAgICAgaWYgKHBheWxvYWQudHlwZSA9PT0gJ21lZGlhJykge1xuICAgICAgICAgIGNvbm5lY3Rpb24gPSBuZXcgTWVkaWFDb25uZWN0aW9uKHBlZXIsIHRoaXMsIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogY29ubmVjdGlvbklkLFxuICAgICAgICAgICAgX3BheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZC5tZXRhZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX2FkZENvbm5lY3Rpb24ocGVlciwgY29ubmVjdGlvbik7XG4gICAgICAgICAgdGhpcy5lbWl0KCdjYWxsJywgY29ubmVjdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZC50eXBlID09PSAnZGF0YScpIHtcbiAgICAgICAgICBjb25uZWN0aW9uID0gbmV3IERhdGFDb25uZWN0aW9uKHBlZXIsIHRoaXMsIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogY29ubmVjdGlvbklkLFxuICAgICAgICAgICAgX3BheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZC5tZXRhZGF0YSxcbiAgICAgICAgICAgIGxhYmVsOiBwYXlsb2FkLmxhYmVsLFxuICAgICAgICAgICAgc2VyaWFsaXphdGlvbjogcGF5bG9hZC5zZXJpYWxpemF0aW9uLFxuICAgICAgICAgICAgcmVsaWFibGU6IHBheWxvYWQucmVsaWFibGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9hZGRDb25uZWN0aW9uKHBlZXIsIGNvbm5lY3Rpb24pO1xuICAgICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbicsIGNvbm5lY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHV0aWwud2FybignUmVjZWl2ZWQgbWFsZm9ybWVkIGNvbm5lY3Rpb24gdHlwZTonLCBwYXlsb2FkLnR5cGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIG1lc3NhZ2VzLlxuICAgICAgICB2YXIgbWVzc2FnZXMgPSB0aGlzLl9nZXRNZXNzYWdlcyhjb25uZWN0aW9uSWQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBtZXNzYWdlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAxKSB7XG4gICAgICAgICAgY29ubmVjdGlvbi5oYW5kbGVNZXNzYWdlKG1lc3NhZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICghcGF5bG9hZCkge1xuICAgICAgICB1dGlsLndhcm4oJ1lvdSByZWNlaXZlZCBhIG1hbGZvcm1lZCBtZXNzYWdlIGZyb20gJyArIHBlZXIgKyAnIG9mIHR5cGUgJyArIHR5cGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpZCA9IHBheWxvYWQuY29ubmVjdGlvbklkO1xuICAgICAgY29ubmVjdGlvbiA9IHRoaXMuZ2V0Q29ubmVjdGlvbihwZWVyLCBpZCk7XG5cbiAgICAgIGlmIChjb25uZWN0aW9uICYmIGNvbm5lY3Rpb24ucGMpIHtcbiAgICAgICAgLy8gUGFzcyBpdCBvbi5cbiAgICAgICAgY29ubmVjdGlvbi5oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIGlmIChpZCkge1xuICAgICAgICAvLyBTdG9yZSBmb3IgcG9zc2libGUgbGF0ZXIgdXNlXG4gICAgICAgIHRoaXMuX3N0b3JlTWVzc2FnZShpZCwgbWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1dGlsLndhcm4oJ1lvdSByZWNlaXZlZCBhbiB1bnJlY29nbml6ZWQgbWVzc2FnZTonLCBtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKiogU3RvcmVzIG1lc3NhZ2VzIHdpdGhvdXQgYSBzZXQgdXAgY29ubmVjdGlvbiwgdG8gYmUgY2xhaW1lZCBsYXRlci4gKi9cblBlZXIucHJvdG90eXBlLl9zdG9yZU1lc3NhZ2UgPSBmdW5jdGlvbihjb25uZWN0aW9uSWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCF0aGlzLl9sb3N0TWVzc2FnZXNbY29ubmVjdGlvbklkXSkge1xuICAgIHRoaXMuX2xvc3RNZXNzYWdlc1tjb25uZWN0aW9uSWRdID0gW107XG4gIH1cbiAgdGhpcy5fbG9zdE1lc3NhZ2VzW2Nvbm5lY3Rpb25JZF0ucHVzaChtZXNzYWdlKTtcbn07XG5cbi8qKiBSZXRyaWV2ZSBtZXNzYWdlcyBmcm9tIGxvc3QgbWVzc2FnZSBzdG9yZSAqL1xuUGVlci5wcm90b3R5cGUuX2dldE1lc3NhZ2VzID0gZnVuY3Rpb24oY29ubmVjdGlvbklkKSB7XG4gIHZhciBtZXNzYWdlcyA9IHRoaXMuX2xvc3RNZXNzYWdlc1tjb25uZWN0aW9uSWRdO1xuICBpZiAobWVzc2FnZXMpIHtcbiAgICBkZWxldGUgdGhpcy5fbG9zdE1lc3NhZ2VzW2Nvbm5lY3Rpb25JZF07XG4gICAgcmV0dXJuIG1lc3NhZ2VzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgRGF0YUNvbm5lY3Rpb24gdG8gdGhlIHNwZWNpZmllZCBwZWVyLiBTZWUgZG9jdW1lbnRhdGlvbiBmb3IgYVxuICogY29tcGxldGUgbGlzdCBvZiBvcHRpb25zLlxuICovXG5QZWVyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24ocGVlciwgb3B0aW9ucykge1xuICBpZiAodGhpcy5kaXNjb25uZWN0ZWQpIHtcbiAgICB1dGlsLndhcm4oJ1lvdSBjYW5ub3QgY29ubmVjdCB0byBhIG5ldyBQZWVyIGJlY2F1c2UgeW91IGNhbGxlZCAnICtcbiAgICAgICcuZGlzY29ubmVjdCgpIG9uIHRoaXMgUGVlciBhbmQgZW5kZWQgeW91ciBjb25uZWN0aW9uIHdpdGggdGhlICcgK1xuICAgICAgJ3NlcnZlci4gWW91IGNhbiBjcmVhdGUgYSBuZXcgUGVlciB0byByZWNvbm5lY3QsIG9yIGNhbGwgcmVjb25uZWN0ICcgK1xuICAgICAgJ29uIHRoaXMgcGVlciBpZiB5b3UgYmVsaWV2ZSBpdHMgSUQgdG8gc3RpbGwgYmUgYXZhaWxhYmxlLicpO1xuICAgIHRoaXMuZW1pdEVycm9yKCdkaXNjb25uZWN0ZWQnLCAnQ2Fubm90IGNvbm5lY3QgdG8gbmV3IFBlZXIgYWZ0ZXIgZGlzY29ubmVjdGluZyBmcm9tIHNlcnZlci4nKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNvbm5lY3Rpb24gPSBuZXcgRGF0YUNvbm5lY3Rpb24ocGVlciwgdGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuX2FkZENvbm5lY3Rpb24ocGVlciwgY29ubmVjdGlvbik7XG4gIHJldHVybiBjb25uZWN0aW9uO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgTWVkaWFDb25uZWN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgcGVlci4gU2VlIGRvY3VtZW50YXRpb24gZm9yIGFcbiAqIGNvbXBsZXRlIGxpc3Qgb2Ygb3B0aW9ucy5cbiAqL1xuUGVlci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uKHBlZXIsIHN0cmVhbSwgb3B0aW9ucykge1xuICBpZiAodGhpcy5kaXNjb25uZWN0ZWQpIHtcbiAgICB1dGlsLndhcm4oJ1lvdSBjYW5ub3QgY29ubmVjdCB0byBhIG5ldyBQZWVyIGJlY2F1c2UgeW91IGNhbGxlZCAnICtcbiAgICAgICcuZGlzY29ubmVjdCgpIG9uIHRoaXMgUGVlciBhbmQgZW5kZWQgeW91ciBjb25uZWN0aW9uIHdpdGggdGhlICcgK1xuICAgICAgJ3NlcnZlci4gWW91IGNhbiBjcmVhdGUgYSBuZXcgUGVlciB0byByZWNvbm5lY3QuJyk7XG4gICAgdGhpcy5lbWl0RXJyb3IoJ2Rpc2Nvbm5lY3RlZCcsICdDYW5ub3QgY29ubmVjdCB0byBuZXcgUGVlciBhZnRlciBkaXNjb25uZWN0aW5nIGZyb20gc2VydmVyLicpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXN0cmVhbSkge1xuICAgIHV0aWwuZXJyb3IoJ1RvIGNhbGwgYSBwZWVyLCB5b3UgbXVzdCBwcm92aWRlIGEgc3RyZWFtIGZyb20geW91ciBicm93c2VyXFwncyBgZ2V0VXNlck1lZGlhYC4nKTtcbiAgICByZXR1cm47XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgdmFyIGNhbGwgPSBuZXcgTWVkaWFDb25uZWN0aW9uKHBlZXIsIHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLl9hZGRDb25uZWN0aW9uKHBlZXIsIGNhbGwpO1xuICByZXR1cm4gY2FsbDtcbn07XG5cbi8qKiBBZGQgYSBkYXRhL21lZGlhIGNvbm5lY3Rpb24gdG8gdGhpcyBwZWVyLiAqL1xuUGVlci5wcm90b3R5cGUuX2FkZENvbm5lY3Rpb24gPSBmdW5jdGlvbihwZWVyLCBjb25uZWN0aW9uKSB7XG4gIGlmICghdGhpcy5jb25uZWN0aW9uc1twZWVyXSkge1xuICAgIHRoaXMuY29ubmVjdGlvbnNbcGVlcl0gPSBbXTtcbiAgfVxuICB0aGlzLmNvbm5lY3Rpb25zW3BlZXJdLnB1c2goY29ubmVjdGlvbik7XG59O1xuXG4vKiogUmV0cmlldmUgYSBkYXRhL21lZGlhIGNvbm5lY3Rpb24gZm9yIHRoaXMgcGVlci4gKi9cblBlZXIucHJvdG90eXBlLmdldENvbm5lY3Rpb24gPSBmdW5jdGlvbihwZWVyLCBpZCkge1xuICB2YXIgY29ubmVjdGlvbnMgPSB0aGlzLmNvbm5lY3Rpb25zW3BlZXJdO1xuICBpZiAoIWNvbm5lY3Rpb25zKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29ubmVjdGlvbnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGlmIChjb25uZWN0aW9uc1tpXS5pZCA9PT0gaWQpIHtcbiAgICAgIHJldHVybiBjb25uZWN0aW9uc1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5QZWVyLnByb3RvdHlwZS5fZGVsYXllZEFib3J0ID0gZnVuY3Rpb24odHlwZSwgbWVzc2FnZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHV0aWwuc2V0WmVyb1RpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICBzZWxmLl9hYm9ydCh0eXBlLCBtZXNzYWdlKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBQZWVyIGFuZCBlbWl0cyBhbiBlcnJvciBtZXNzYWdlLlxuICogVGhlIFBlZXIgaXMgbm90IGRlc3Ryb3llZCBpZiBpdCdzIGluIGEgZGlzY29ubmVjdGVkIHN0YXRlLCBpbiB3aGljaCBjYXNlXG4gKiBpdCByZXRhaW5zIGl0cyBkaXNjb25uZWN0ZWQgc3RhdGUgYW5kIGl0cyBleGlzdGluZyBjb25uZWN0aW9ucy5cbiAqL1xuUGVlci5wcm90b3R5cGUuX2Fib3J0ID0gZnVuY3Rpb24odHlwZSwgbWVzc2FnZSkge1xuICB1dGlsLmVycm9yKCdBYm9ydGluZyEnKTtcbiAgaWYgKCF0aGlzLl9sYXN0U2VydmVySWQpIHtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICB0aGlzLmVtaXRFcnJvcih0eXBlLCBtZXNzYWdlKTtcbn07XG5cbi8qKiBFbWl0cyBhIHR5cGVkIGVycm9yIG1lc3NhZ2UuICovXG5QZWVyLnByb3RvdHlwZS5lbWl0RXJyb3IgPSBmdW5jdGlvbih0eXBlLCBlcnIpIHtcbiAgdXRpbC5lcnJvcignRXJyb3I6JywgZXJyKTtcbiAgaWYgKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSB7XG4gICAgZXJyID0gbmV3IEVycm9yKGVycik7XG4gIH1cbiAgZXJyLnR5cGUgPSB0eXBlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIFBlZXI6IGNsb3NlcyBhbGwgYWN0aXZlIGNvbm5lY3Rpb25zIGFzIHdlbGwgYXMgdGhlIGNvbm5lY3Rpb25cbiAqICB0byB0aGUgc2VydmVyLlxuICogV2FybmluZzogVGhlIHBlZXIgY2FuIG5vIGxvbmdlciBjcmVhdGUgb3IgYWNjZXB0IGNvbm5lY3Rpb25zIGFmdGVyIGJlaW5nXG4gKiAgZGVzdHJveWVkLlxuICovXG5QZWVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG59O1xuXG5cbi8qKiBEaXNjb25uZWN0cyBldmVyeSBjb25uZWN0aW9uIG9uIHRoaXMgcGVlci4gKi9cblBlZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNvbm5lY3Rpb25zKSB7XG4gICAgdmFyIHBlZXJzID0gT2JqZWN0LmtleXModGhpcy5jb25uZWN0aW9ucyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGVlcnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgdGhpcy5fY2xlYW51cFBlZXIocGVlcnNbaV0pO1xuICAgIH1cbiAgfVxuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuXG4vKiogQ2xvc2VzIGFsbCBjb25uZWN0aW9ucyB0byB0aGlzIHBlZXIuICovXG5QZWVyLnByb3RvdHlwZS5fY2xlYW51cFBlZXIgPSBmdW5jdGlvbihwZWVyKSB7XG4gIHZhciBjb25uZWN0aW9ucyA9IHRoaXMuY29ubmVjdGlvbnNbcGVlcl07XG4gIGZvciAodmFyIGogPSAwLCBqaiA9IGNvbm5lY3Rpb25zLmxlbmd0aDsgaiA8IGpqOyBqICs9IDEpIHtcbiAgICBjb25uZWN0aW9uc1tqXS5jbG9zZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIERpc2Nvbm5lY3RzIHRoZSBQZWVyJ3MgY29ubmVjdGlvbiB0byB0aGUgUGVlclNlcnZlci4gRG9lcyBub3QgY2xvc2UgYW55XG4gKiAgYWN0aXZlIGNvbm5lY3Rpb25zLlxuICogV2FybmluZzogVGhlIHBlZXIgY2FuIG5vIGxvbmdlciBjcmVhdGUgb3IgYWNjZXB0IGNvbm5lY3Rpb25zIGFmdGVyIGJlaW5nXG4gKiAgZGlzY29ubmVjdGVkLiBJdCBhbHNvIGNhbm5vdCByZWNvbm5lY3QgdG8gdGhlIHNlcnZlci5cbiAqL1xuUGVlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHV0aWwuc2V0WmVyb1RpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICBpZiAoIXNlbGYuZGlzY29ubmVjdGVkKSB7XG4gICAgICBzZWxmLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICBzZWxmLm9wZW4gPSBmYWxzZTtcbiAgICAgIGlmIChzZWxmLnNvY2tldCkge1xuICAgICAgICBzZWxmLnNvY2tldC5jbG9zZSgpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbWl0KCdkaXNjb25uZWN0ZWQnLCBzZWxmLmlkKTtcbiAgICAgIHNlbGYuX2xhc3RTZXJ2ZXJJZCA9IHNlbGYuaWQ7XG4gICAgICBzZWxmLmlkID0gbnVsbDtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqIEF0dGVtcHRzIHRvIHJlY29ubmVjdCB3aXRoIHRoZSBzYW1lIElELiAqL1xuUGVlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmRpc2Nvbm5lY3RlZCAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcbiAgICB1dGlsLmxvZygnQXR0ZW1wdGluZyByZWNvbm5lY3Rpb24gdG8gc2VydmVyIHdpdGggSUQgJyArIHRoaXMuX2xhc3RTZXJ2ZXJJZCk7XG4gICAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0aWFsaXplU2VydmVyQ29ubmVjdGlvbigpO1xuICAgIHRoaXMuX2luaXRpYWxpemUodGhpcy5fbGFzdFNlcnZlcklkKTtcbiAgfSBlbHNlIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBwZWVyIGNhbm5vdCByZWNvbm5lY3QgdG8gdGhlIHNlcnZlci4gSXQgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWQuJyk7XG4gIH0gZWxzZSBpZiAoIXRoaXMuZGlzY29ubmVjdGVkICYmICF0aGlzLm9wZW4pIHtcbiAgICAvLyBEbyBub3RoaW5nLiBXZSdyZSBzdGlsbCBjb25uZWN0aW5nIHRoZSBmaXJzdCB0aW1lLlxuICAgIHV0aWwuZXJyb3IoJ0luIGEgaHVycnk/IFdlXFwncmUgc3RpbGwgdHJ5aW5nIHRvIG1ha2UgdGhlIGluaXRpYWwgY29ubmVjdGlvbiEnKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BlZXIgJyArIHRoaXMuaWQgKyAnIGNhbm5vdCByZWNvbm5lY3QgYmVjYXVzZSBpdCBpcyBub3QgZGlzY29ubmVjdGVkIGZyb20gdGhlIHNlcnZlciEnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSBsaXN0IG9mIGF2YWlsYWJsZSBwZWVyIElEcy4gSWYgeW91J3JlIHJ1bm5pbmcgeW91ciBvd24gc2VydmVyLCB5b3UnbGxcbiAqIHdhbnQgdG8gc2V0IGFsbG93X2Rpc2NvdmVyeTogdHJ1ZSBpbiB0aGUgUGVlclNlcnZlciBvcHRpb25zLiBJZiB5b3UncmUgdXNpbmdcbiAqIHRoZSBjbG91ZCBzZXJ2ZXIsIGVtYWlsIHRlYW1AcGVlcmpzLmNvbSB0byBnZXQgdGhlIGZ1bmN0aW9uYWxpdHkgZW5hYmxlZCBmb3JcbiAqIHlvdXIga2V5LlxuICovXG5QZWVyLnByb3RvdHlwZS5saXN0QWxsUGVlcnMgPSBmdW5jdGlvbihjYikge1xuICBjYiA9IGNiIHx8IGZ1bmN0aW9uKCkge307XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgdmFyIHByb3RvY29sID0gdGhpcy5vcHRpb25zLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLyc7XG4gIHZhciB1cmwgPSBwcm90b2NvbCArIHRoaXMub3B0aW9ucy5ob3N0ICsgJzonICsgdGhpcy5vcHRpb25zLnBvcnQgK1xuICAgIHRoaXMub3B0aW9ucy5wYXRoICsgdGhpcy5vcHRpb25zLmtleSArICcvcGVlcnMnO1xuICB2YXIgcXVlcnlTdHJpbmcgPSAnP3RzPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSArICcnICsgTWF0aC5yYW5kb20oKTtcbiAgdXJsICs9IHF1ZXJ5U3RyaW5nO1xuXG4gIC8vIElmIHRoZXJlJ3Mgbm8gSUQgd2UgbmVlZCB0byB3YWl0IGZvciBvbmUgYmVmb3JlIHRyeWluZyB0byBpbml0IHNvY2tldC5cbiAgaHR0cC5vcGVuKCdnZXQnLCB1cmwsIHRydWUpO1xuICBodHRwLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgc2VsZi5fYWJvcnQoJ3NlcnZlci1lcnJvcicsICdDb3VsZCBub3QgZ2V0IHBlZXJzIGZyb20gdGhlIHNlcnZlci4nKTtcbiAgICBjYihbXSk7XG4gIH07XG4gIGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGh0dHAucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaHR0cC5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgdmFyIGhlbHBmdWxFcnJvciA9ICcnO1xuICAgICAgaWYgKHNlbGYub3B0aW9ucy5ob3N0ICE9PSB1dGlsLkNMT1VEX0hPU1QpIHtcbiAgICAgICAgaGVscGZ1bEVycm9yID0gJ0l0IGxvb2tzIGxpa2UgeW91XFwncmUgdXNpbmcgdGhlIGNsb3VkIHNlcnZlci4gWW91IGNhbiBlbWFpbCAnICtcbiAgICAgICAgICAndGVhbUBwZWVyanMuY29tIHRvIGVuYWJsZSBwZWVyIGxpc3RpbmcgZm9yIHlvdXIgQVBJIGtleS4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVscGZ1bEVycm9yID0gJ1lvdSBuZWVkIHRvIGVuYWJsZSBgYWxsb3dfZGlzY292ZXJ5YCBvbiB5b3VyIHNlbGYtaG9zdGVkICcgK1xuICAgICAgICAgICdQZWVyU2VydmVyIHRvIHVzZSB0aGlzIGZlYXR1cmUuJztcbiAgICAgIH1cbiAgICAgIGNiKFtdKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSXQgZG9lc25cXCd0IGxvb2sgbGlrZSB5b3UgaGF2ZSBwZXJtaXNzaW9uIHRvIGxpc3QgcGVlcnMgSURzLiAnICsgaGVscGZ1bEVycm9yKTtcbiAgICB9IGVsc2UgaWYgKGh0dHAuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIGNiKFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoSlNPTi5wYXJzZShodHRwLnJlc3BvbnNlVGV4dCkpO1xuICAgIH1cbiAgfTtcbiAgaHR0cC5zZW5kKG51bGwpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQZWVyO1xuXG59LHtcIi4vZGF0YWNvbm5lY3Rpb25cIjoyLFwiLi9tZWRpYWNvbm5lY3Rpb25cIjo0LFwiLi9zb2NrZXRcIjo3LFwiLi91dGlsXCI6OCxcImV2ZW50ZW1pdHRlcjNcIjo5fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKTtcblxuLyoqXG4gKiBBbiBhYnN0cmFjdGlvbiBvbiB0b3Agb2YgV2ViU29ja2V0cyBhbmQgWEhSIHN0cmVhbWluZyB0byBwcm92aWRlIGZhc3Rlc3RcbiAqIHBvc3NpYmxlIGNvbm5lY3Rpb24gZm9yIHBlZXJzLlxuICovXG5mdW5jdGlvbiBTb2NrZXQoc2VjdXJlLCBob3N0LCBwb3J0LCBwYXRoLCBrZXkpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHNlY3VyZSwgaG9zdCwgcG9ydCwgcGF0aCwga2V5KTtcblxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAvLyBEaXNjb25uZWN0ZWQgbWFudWFsbHkuXG4gIHRoaXMuZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuX3F1ZXVlID0gW107XG5cbiAgdmFyIGh0dHBQcm90b2NvbCA9IHNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLyc7XG4gIHZhciB3c1Byb3RvY29sID0gc2VjdXJlID8gJ3dzczovLycgOiAnd3M6Ly8nO1xuICB0aGlzLl9odHRwVXJsID0gaHR0cFByb3RvY29sICsgaG9zdCArICc6JyArIHBvcnQgKyBwYXRoICsga2V5O1xuICB0aGlzLl93c1VybCA9IHdzUHJvdG9jb2wgKyBob3N0ICsgJzonICsgcG9ydCArIHBhdGggKyAncGVlcmpzP2tleT0nICsga2V5O1xufVxuXG51dGlsLmluaGVyaXRzKFNvY2tldCwgRXZlbnRFbWl0dGVyKTtcblxuXG4vKiogQ2hlY2sgaW4gd2l0aCBJRCBvciBnZXQgb25lIGZyb20gc2VydmVyLiAqL1xuU29ja2V0LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGlkLCB0b2tlbikge1xuICB0aGlzLmlkID0gaWQ7XG5cbiAgdGhpcy5faHR0cFVybCArPSAnLycgKyBpZCArICcvJyArIHRva2VuO1xuICB0aGlzLl93c1VybCArPSAnJmlkPScgKyBpZCArICcmdG9rZW49JyArIHRva2VuO1xuXG4gIHRoaXMuX3N0YXJ0WGhyU3RyZWFtKCk7XG4gIHRoaXMuX3N0YXJ0V2ViU29ja2V0KCk7XG59XG5cblxuLyoqIFN0YXJ0IHVwIHdlYnNvY2tldCBjb21tdW5pY2F0aW9ucy4gKi9cblNvY2tldC5wcm90b3R5cGUuX3N0YXJ0V2ViU29ja2V0ID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9zb2NrZXQgPSBuZXcgV2ViU29ja2V0KHRoaXMuX3dzVXJsKTtcblxuICB0aGlzLl9zb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgdXRpbC5sb2coJ0ludmFsaWQgc2VydmVyIG1lc3NhZ2UnLCBldmVudC5kYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5fc29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHV0aWwubG9nKCdTb2NrZXQgY2xvc2VkLicpO1xuICAgIHNlbGYuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2Rpc2Nvbm5lY3RlZCcpO1xuICB9O1xuXG4gIC8vIFRha2UgY2FyZSBvZiB0aGUgcXVldWUgb2YgY29ubmVjdGlvbnMgaWYgbmVjZXNzYXJ5IGFuZCBtYWtlIHN1cmUgUGVlciBrbm93c1xuICAvLyBzb2NrZXQgaXMgb3Blbi5cbiAgdGhpcy5fc29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLl90aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoc2VsZi5fdGltZW91dCk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgIHNlbGYuX2h0dHAuYWJvcnQoKTtcbiAgICAgICAgc2VsZi5faHR0cCA9IG51bGw7XG4gICAgICB9LCA1MDAwKTtcbiAgICB9XG4gICAgc2VsZi5fc2VuZFF1ZXVlZE1lc3NhZ2VzKCk7XG4gICAgdXRpbC5sb2coJ1NvY2tldCBvcGVuJyk7XG4gIH07XG59XG5cbi8qKiBTdGFydCBYSFIgc3RyZWFtaW5nLiAqL1xuU29ja2V0LnByb3RvdHlwZS5fc3RhcnRYaHJTdHJlYW0gPSBmdW5jdGlvbihuKSB7XG4gIHRyeSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX2h0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB0aGlzLl9odHRwLl9pbmRleCA9IDE7XG4gICAgdGhpcy5faHR0cC5fc3RyZWFtSW5kZXggPSBuIHx8IDA7XG4gICAgdGhpcy5faHR0cC5vcGVuKCdwb3N0JywgdGhpcy5faHR0cFVybCArICcvaWQ/aT0nICsgdGhpcy5faHR0cC5fc3RyZWFtSW5kZXgsIHRydWUpO1xuICAgIHRoaXMuX2h0dHAub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gSWYgd2UgZ2V0IGFuIGVycm9yLCBsaWtlbHkgc29tZXRoaW5nIHdlbnQgd3JvbmcuXG4gICAgICAvLyBTdG9wIHN0cmVhbWluZy5cbiAgICAgIGNsZWFyVGltZW91dChzZWxmLl90aW1lb3V0KTtcbiAgICAgIHNlbGYuZW1pdCgnZGlzY29ubmVjdGVkJyk7XG4gICAgfVxuICAgIHRoaXMuX2h0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09IDIgJiYgdGhpcy5vbGQpIHtcbiAgICAgICAgdGhpcy5vbGQuYWJvcnQoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMub2xkO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnJlYWR5U3RhdGUgPiAyICYmIHRoaXMuc3RhdHVzID09PSAyMDAgJiYgdGhpcy5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgc2VsZi5faGFuZGxlU3RyZWFtKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5faHR0cC5zZW5kKG51bGwpO1xuICAgIHRoaXMuX3NldEhUVFBUaW1lb3V0KCk7XG4gIH0gY2F0Y2goZSkge1xuICAgIHV0aWwubG9nKCdYTUxIdHRwUmVxdWVzdCBub3QgYXZhaWxhYmxlOyBkZWZhdWx0aW5nIHRvIFdlYlNvY2tldHMnKTtcbiAgfVxufVxuXG5cbi8qKiBIYW5kbGVzIG9ucmVhZHlzdGF0ZWNoYW5nZSByZXNwb25zZSBhcyBhIHN0cmVhbS4gKi9cblNvY2tldC5wcm90b3R5cGUuX2hhbmRsZVN0cmVhbSA9IGZ1bmN0aW9uKGh0dHApIHtcbiAgLy8gMyBhbmQgNCBhcmUgbG9hZGluZy9kb25lIHN0YXRlLiBBbGwgb3RoZXJzIGFyZSBub3QgcmVsZXZhbnQuXG4gIHZhciBtZXNzYWdlcyA9IGh0dHAucmVzcG9uc2VUZXh0LnNwbGl0KCdcXG4nKTtcblxuICAvLyBDaGVjayB0byBzZWUgaWYgYW55dGhpbmcgbmVlZHMgdG8gYmUgcHJvY2Vzc2VkIG9uIGJ1ZmZlci5cbiAgaWYgKGh0dHAuX2J1ZmZlcikge1xuICAgIHdoaWxlIChodHRwLl9idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGluZGV4ID0gaHR0cC5fYnVmZmVyLnNoaWZ0KCk7XG4gICAgICB2YXIgYnVmZmVyZWRNZXNzYWdlID0gbWVzc2FnZXNbaW5kZXhdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYnVmZmVyZWRNZXNzYWdlID0gSlNPTi5wYXJzZShidWZmZXJlZE1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGh0dHAuX2J1ZmZlci5zaGlmdChpbmRleCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgYnVmZmVyZWRNZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbWVzc2FnZSA9IG1lc3NhZ2VzW2h0dHAuX2luZGV4XTtcbiAgaWYgKG1lc3NhZ2UpIHtcbiAgICBodHRwLl9pbmRleCArPSAxO1xuICAgIC8vIEJ1ZmZlcmluZy0tdGhpcyBtZXNzYWdlIGlzIGluY29tcGxldGUgYW5kIHdlJ2xsIGdldCB0byBpdCBuZXh0IHRpbWUuXG4gICAgLy8gVGhpcyBjaGVja3MgaWYgdGhlIGh0dHBSZXNwb25zZSBlbmRlZCBpbiBhIGBcXG5gLCBpbiB3aGljaCBjYXNlIHRoZSBsYXN0XG4gICAgLy8gZWxlbWVudCBvZiBtZXNzYWdlcyBzaG91bGQgYmUgdGhlIGVtcHR5IHN0cmluZy5cbiAgICBpZiAoaHR0cC5faW5kZXggPT09IG1lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgaWYgKCFodHRwLl9idWZmZXIpIHtcbiAgICAgICAgaHR0cC5fYnVmZmVyID0gW107XG4gICAgICB9XG4gICAgICBodHRwLl9idWZmZXIucHVzaChodHRwLl9pbmRleCAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBtZXNzYWdlID0gSlNPTi5wYXJzZShtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICB1dGlsLmxvZygnSW52YWxpZCBzZXJ2ZXIgbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cblxuU29ja2V0LnByb3RvdHlwZS5fc2V0SFRUUFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICB2YXIgb2xkID0gc2VsZi5faHR0cDtcbiAgICBpZiAoIXNlbGYuX3dzT3BlbigpKSB7XG4gICAgICBzZWxmLl9zdGFydFhoclN0cmVhbShvbGQuX3N0cmVhbUluZGV4ICsgMSk7XG4gICAgICBzZWxmLl9odHRwLm9sZCA9IG9sZDtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkLmFib3J0KCk7XG4gICAgfVxuICB9LCAyNTAwMCk7XG59XG5cbi8qKiBJcyB0aGUgd2Vic29ja2V0IGN1cnJlbnRseSBvcGVuPyAqL1xuU29ja2V0LnByb3RvdHlwZS5fd3NPcGVuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9zb2NrZXQgJiYgdGhpcy5fc29ja2V0LnJlYWR5U3RhdGUgPT0gMTtcbn1cblxuLyoqIFNlbmQgcXVldWVkIG1lc3NhZ2VzLiAqL1xuU29ja2V0LnByb3RvdHlwZS5fc2VuZFF1ZXVlZE1lc3NhZ2VzID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSA8IGlpOyBpICs9IDEpIHtcbiAgICB0aGlzLnNlbmQodGhpcy5fcXVldWVbaV0pO1xuICB9XG59XG5cbi8qKiBFeHBvc2VkIHNlbmQgZm9yIERDICYgUGVlci4gKi9cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgaWYgKHRoaXMuZGlzY29ubmVjdGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgd2UgZGlkbid0IGdldCBhbiBJRCB5ZXQsIHdlIGNhbid0IHlldCBzZW5kIGFueXRoaW5nIHNvIHdlIHNob3VsZCBxdWV1ZVxuICAvLyB1cCB0aGVzZSBtZXNzYWdlcy5cbiAgaWYgKCF0aGlzLmlkKSB7XG4gICAgdGhpcy5fcXVldWUucHVzaChkYXRhKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWRhdGEudHlwZSkge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCAnSW52YWxpZCBtZXNzYWdlJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgaWYgKHRoaXMuX3dzT3BlbigpKSB7XG4gICAgdGhpcy5fc29ja2V0LnNlbmQobWVzc2FnZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB2YXIgdXJsID0gdGhpcy5faHR0cFVybCArICcvJyArIGRhdGEudHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIGh0dHAub3BlbigncG9zdCcsIHVybCwgdHJ1ZSk7XG4gICAgaHR0cC5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIGh0dHAuc2VuZChtZXNzYWdlKTtcbiAgfVxufVxuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5kaXNjb25uZWN0ZWQgJiYgdGhpcy5fd3NPcGVuKCkpIHtcbiAgICB0aGlzLl9zb2NrZXQuY2xvc2UoKTtcbiAgICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cbn0se1wiLi91dGlsXCI6OCxcImV2ZW50ZW1pdHRlcjNcIjo5fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZGVmYXVsdENvbmZpZyA9IHsnaWNlU2VydmVycyc6IFt7ICd1cmwnOiAnc3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMicgfV19O1xudmFyIGRhdGFDb3VudCA9IDE7XG5cbnZhciBCaW5hcnlQYWNrID0gcmVxdWlyZSgnanMtYmluYXJ5cGFjaycpO1xudmFyIFJUQ1BlZXJDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9hZGFwdGVyJykuUlRDUGVlckNvbm5lY3Rpb247XG5cbnZhciB1dGlsID0ge1xuICBub29wOiBmdW5jdGlvbigpIHt9LFxuXG4gIENMT1VEX0hPU1Q6ICcwLnBlZXJqcy5jb20nLFxuICBDTE9VRF9QT1JUOiA5MDAwLFxuXG4gIC8vIEJyb3dzZXJzIHRoYXQgbmVlZCBjaHVua2luZzpcbiAgY2h1bmtlZEJyb3dzZXJzOiB7J0Nocm9tZSc6IDF9LFxuICBjaHVua2VkTVRVOiAxNjMwMCwgLy8gVGhlIG9yaWdpbmFsIDYwMDAwIGJ5dGVzIHNldHRpbmcgZG9lcyBub3Qgd29yayB3aGVuIHNlbmRpbmcgZGF0YSBmcm9tIEZpcmVmb3ggdG8gQ2hyb21lLCB3aGljaCBpcyBcImN1dCBvZmZcIiBhZnRlciAxNjM4NCBieXRlcyBhbmQgZGVsaXZlcmVkIGluZGl2aWR1YWxseS5cblxuICAvLyBMb2dnaW5nIGxvZ2ljXG4gIGxvZ0xldmVsOiAwLFxuICBzZXRMb2dMZXZlbDogZnVuY3Rpb24obGV2ZWwpIHtcbiAgICB2YXIgZGVidWdMZXZlbCA9IHBhcnNlSW50KGxldmVsLCAxMCk7XG4gICAgaWYgKCFpc05hTihwYXJzZUludChsZXZlbCwgMTApKSkge1xuICAgICAgdXRpbC5sb2dMZXZlbCA9IGRlYnVnTGV2ZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXkgYXJlIHVzaW5nIHRydXRoeS9mYWxzeSB2YWx1ZXMgZm9yIGRlYnVnXG4gICAgICB1dGlsLmxvZ0xldmVsID0gbGV2ZWwgPyAzIDogMDtcbiAgICB9XG4gICAgdXRpbC5sb2cgPSB1dGlsLndhcm4gPSB1dGlsLmVycm9yID0gdXRpbC5ub29wO1xuICAgIGlmICh1dGlsLmxvZ0xldmVsID4gMCkge1xuICAgICAgdXRpbC5lcnJvciA9IHV0aWwuX3ByaW50V2l0aCgnRVJST1InKTtcbiAgICB9XG4gICAgaWYgKHV0aWwubG9nTGV2ZWwgPiAxKSB7XG4gICAgICB1dGlsLndhcm4gPSB1dGlsLl9wcmludFdpdGgoJ1dBUk5JTkcnKTtcbiAgICB9XG4gICAgaWYgKHV0aWwubG9nTGV2ZWwgPiAyKSB7XG4gICAgICB1dGlsLmxvZyA9IHV0aWwuX3ByaW50O1xuICAgIH1cbiAgfSxcbiAgc2V0TG9nRnVuY3Rpb246IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKGZuLmNvbnN0cnVjdG9yICE9PSBGdW5jdGlvbikge1xuICAgICAgdXRpbC53YXJuKCdUaGUgbG9nIGZ1bmN0aW9uIHlvdSBwYXNzZWQgaW4gaXMgbm90IGEgZnVuY3Rpb24uIERlZmF1bHRpbmcgdG8gcmVndWxhciBsb2dzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLl9wcmludCA9IGZuO1xuICAgIH1cbiAgfSxcblxuICBfcHJpbnRXaXRoOiBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29weSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBjb3B5LnVuc2hpZnQocHJlZml4KTtcbiAgICAgIHV0aWwuX3ByaW50LmFwcGx5KHV0aWwsIGNvcHkpO1xuICAgIH07XG4gIH0sXG4gIF9wcmludDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBlcnIgPSBmYWxzZTtcbiAgICB2YXIgY29weSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgY29weS51bnNoaWZ0KCdQZWVySlM6ICcpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29weS5sZW5ndGg7IGkgPCBsOyBpKyspe1xuICAgICAgaWYgKGNvcHlbaV0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBjb3B5W2ldID0gJygnICsgY29weVtpXS5uYW1lICsgJykgJyArIGNvcHlbaV0ubWVzc2FnZTtcbiAgICAgICAgZXJyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXJyID8gY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBjb3B5KSA6IGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGNvcHkpO1xuICB9LFxuICAvL1xuXG4gIC8vIFJldHVybnMgYnJvd3Nlci1hZ25vc3RpYyBkZWZhdWx0IGNvbmZpZ1xuICBkZWZhdWx0Q29uZmlnOiBkZWZhdWx0Q29uZmlnLFxuICAvL1xuXG4gIC8vIFJldHVybnMgdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAgYnJvd3NlcjogKGZ1bmN0aW9uKCkge1xuICAgIGlmICh3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAgIHJldHVybiAnRmlyZWZveCc7XG4gICAgfSBlbHNlIGlmICh3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAgIHJldHVybiAnQ2hyb21lJztcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgICAgcmV0dXJuICdTdXBwb3J0ZWQnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ1Vuc3VwcG9ydGVkJztcbiAgICB9XG4gIH0pKCksXG4gIC8vXG5cbiAgLy8gTGlzdHMgd2hpY2ggZmVhdHVyZXMgYXJlIHN1cHBvcnRlZFxuICBzdXBwb3J0czogKGZ1bmN0aW9uKCkge1xuICAgIGlmICh0eXBlb2YgUlRDUGVlckNvbm5lY3Rpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB0cnVlO1xuICAgIHZhciBhdWRpb1ZpZGVvID0gdHJ1ZTtcblxuICAgIHZhciBiaW5hcnlCbG9iID0gZmFsc2U7XG4gICAgdmFyIHNjdHAgPSBmYWxzZTtcbiAgICB2YXIgb25uZWdvdGlhdGlvbm5lZWRlZCA9ICEhd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uO1xuXG4gICAgdmFyIHBjLCBkYztcbiAgICB0cnkge1xuICAgICAgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oZGVmYXVsdENvbmZpZywge29wdGlvbmFsOiBbe1J0cERhdGFDaGFubmVsczogdHJ1ZX1dfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGF0YSA9IGZhbHNlO1xuICAgICAgYXVkaW9WaWRlbyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChkYXRhKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYyA9IHBjLmNyZWF0ZURhdGFDaGFubmVsKCdfUEVFUkpTVEVTVCcpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkYXRhID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIC8vIEJpbmFyeSB0ZXN0XG4gICAgICB0cnkge1xuICAgICAgICBkYy5iaW5hcnlUeXBlID0gJ2Jsb2InO1xuICAgICAgICBiaW5hcnlCbG9iID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cblxuICAgICAgLy8gUmVsaWFibGUgdGVzdC5cbiAgICAgIC8vIFVuZm9ydHVuYXRlbHkgQ2hyb21lIGlzIGEgYml0IHVucmVsaWFibGUgYWJvdXQgd2hldGhlciBvciBub3QgdGhleVxuICAgICAgLy8gc3VwcG9ydCByZWxpYWJsZS5cbiAgICAgIHZhciByZWxpYWJsZVBDID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKGRlZmF1bHRDb25maWcsIHt9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZWxpYWJsZURDID0gcmVsaWFibGVQQy5jcmVhdGVEYXRhQ2hhbm5lbCgnX1BFRVJKU1JFTElBQkxFVEVTVCcsIHt9KTtcbiAgICAgICAgc2N0cCA9IHJlbGlhYmxlREMucmVsaWFibGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgICByZWxpYWJsZVBDLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgLy8gRklYTUU6IG5vdCByZWFsbHkgdGhlIGJlc3QgY2hlY2suLi5cbiAgICBpZiAoYXVkaW9WaWRlbykge1xuICAgICAgYXVkaW9WaWRlbyA9ICEhcGMuYWRkU3RyZWFtO1xuICAgIH1cblxuICAgIC8vIEZJWE1FOiB0aGlzIGlzIG5vdCBncmVhdCBiZWNhdXNlIGluIHRoZW9yeSBpdCBkb2Vzbid0IHdvcmsgZm9yXG4gICAgLy8gYXYtb25seSBicm93c2VycyAoPykuXG4gICAgaWYgKCFvbm5lZ290aWF0aW9ubmVlZGVkICYmIGRhdGEpIHtcbiAgICAgIC8vIHN5bmMgZGVmYXVsdCBjaGVjay5cbiAgICAgIHZhciBuZWdvdGlhdGlvblBDID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKGRlZmF1bHRDb25maWcsIHtvcHRpb25hbDogW3tSdHBEYXRhQ2hhbm5lbHM6IHRydWV9XX0pO1xuICAgICAgbmVnb3RpYXRpb25QQy5vbm5lZ290aWF0aW9ubmVlZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG9ubmVnb3RpYXRpb25uZWVkZWQgPSB0cnVlO1xuICAgICAgICAvLyBhc3luYyBjaGVjay5cbiAgICAgICAgaWYgKHV0aWwgJiYgdXRpbC5zdXBwb3J0cykge1xuICAgICAgICAgIHV0aWwuc3VwcG9ydHMub25uZWdvdGlhdGlvbm5lZWRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBuZWdvdGlhdGlvblBDLmNyZWF0ZURhdGFDaGFubmVsKCdfUEVFUkpTTkVHT1RJQVRJT05URVNUJyk7XG5cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG5lZ290aWF0aW9uUEMuY2xvc2UoKTtcbiAgICAgIH0sIDEwMDApO1xuICAgIH1cblxuICAgIGlmIChwYykge1xuICAgICAgcGMuY2xvc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW9WaWRlbzogYXVkaW9WaWRlbyxcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBiaW5hcnlCbG9iOiBiaW5hcnlCbG9iLFxuICAgICAgYmluYXJ5OiBzY3RwLCAvLyBkZXByZWNhdGVkOyBzY3RwIGltcGxpZXMgYmluYXJ5IHN1cHBvcnQuXG4gICAgICByZWxpYWJsZTogc2N0cCwgLy8gZGVwcmVjYXRlZDsgc2N0cCBpbXBsaWVzIHJlbGlhYmxlIGRhdGEuXG4gICAgICBzY3RwOiBzY3RwLFxuICAgICAgb25uZWdvdGlhdGlvbm5lZWRlZDogb25uZWdvdGlhdGlvbm5lZWRlZFxuICAgIH07XG4gIH0oKSksXG4gIC8vXG5cbiAgLy8gRW5zdXJlIGFscGhhbnVtZXJpYyBpZHNcbiAgdmFsaWRhdGVJZDogZnVuY3Rpb24oaWQpIHtcbiAgICAvLyBBbGxvdyBlbXB0eSBpZHNcbiAgICByZXR1cm4gIWlkIHx8IC9eW0EtWmEtejAtOV8tXSsoPzpbIF8tXVtBLVphLXowLTldKykqJC8uZXhlYyhpZCk7XG4gIH0sXG5cbiAgdmFsaWRhdGVLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgIC8vIEFsbG93IGVtcHR5IGtleXNcbiAgICByZXR1cm4gIWtleSB8fCAvXltBLVphLXowLTlfLV0rKD86WyBfLV1bQS1aYS16MC05XSspKiQvLmV4ZWMoa2V5KTtcbiAgfSxcblxuXG4gIGRlYnVnOiBmYWxzZSxcblxuICBpbmhlcml0czogZnVuY3Rpb24oY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBleHRlbmQ6IGZ1bmN0aW9uKGRlc3QsIHNvdXJjZSkge1xuICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgZGVzdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9LFxuICBwYWNrOiBCaW5hcnlQYWNrLnBhY2ssXG4gIHVucGFjazogQmluYXJ5UGFjay51bnBhY2ssXG5cbiAgbG9nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHV0aWwuZGVidWcpIHtcbiAgICAgIHZhciBlcnIgPSBmYWxzZTtcbiAgICAgIHZhciBjb3B5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGNvcHkudW5zaGlmdCgnUGVlckpTOiAnKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29weS5sZW5ndGg7IGkgPCBsOyBpKyspe1xuICAgICAgICBpZiAoY29weVtpXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgY29weVtpXSA9ICcoJyArIGNvcHlbaV0ubmFtZSArICcpICcgKyBjb3B5W2ldLm1lc3NhZ2U7XG4gICAgICAgICAgZXJyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXJyID8gY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBjb3B5KSA6IGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGNvcHkpO1xuICAgIH1cbiAgfSxcblxuICBzZXRaZXJvVGltZW91dDogKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAgIHZhciB0aW1lb3V0cyA9IFtdO1xuICAgIHZhciBtZXNzYWdlTmFtZSA9ICd6ZXJvLXRpbWVvdXQtbWVzc2FnZSc7XG5cbiAgICAvLyBMaWtlIHNldFRpbWVvdXQsIGJ1dCBvbmx5IHRha2VzIGEgZnVuY3Rpb24gYXJndW1lbnQuXHQgVGhlcmUnc1xuICAgIC8vIG5vIHRpbWUgYXJndW1lbnQgKGFsd2F5cyB6ZXJvKSBhbmQgbm8gYXJndW1lbnRzICh5b3UgaGF2ZSB0b1xuICAgIC8vIHVzZSBhIGNsb3N1cmUpLlxuICAgIGZ1bmN0aW9uIHNldFplcm9UaW1lb3V0UG9zdE1lc3NhZ2UoZm4pIHtcbiAgICAgIHRpbWVvdXRzLnB1c2goZm4pO1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VOYW1lLCAnKicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5zb3VyY2UgPT0gZ2xvYmFsICYmIGV2ZW50LmRhdGEgPT0gbWVzc2FnZU5hbWUpIHtcbiAgICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lb3V0cy5sZW5ndGgpIHtcbiAgICAgICAgICB0aW1lb3V0cy5zaGlmdCgpKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29ubWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0WmVyb1RpbWVvdXRQb3N0TWVzc2FnZTtcbiAgfSh3aW5kb3cpKSxcblxuICAvLyBCaW5hcnkgc3R1ZmZcblxuICAvLyBjaHVua3MgYSBibG9iLlxuICBjaHVuazogZnVuY3Rpb24oYmwpIHtcbiAgICB2YXIgY2h1bmtzID0gW107XG4gICAgdmFyIHNpemUgPSBibC5zaXplO1xuICAgIHZhciBzdGFydCA9IGluZGV4ID0gMDtcbiAgICB2YXIgdG90YWwgPSBNYXRoLmNlaWwoc2l6ZSAvIHV0aWwuY2h1bmtlZE1UVSk7XG4gICAgd2hpbGUgKHN0YXJ0IDwgc2l6ZSkge1xuICAgICAgdmFyIGVuZCA9IE1hdGgubWluKHNpemUsIHN0YXJ0ICsgdXRpbC5jaHVua2VkTVRVKTtcbiAgICAgIHZhciBiID0gYmwuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICAgIHZhciBjaHVuayA9IHtcbiAgICAgICAgX19wZWVyRGF0YTogZGF0YUNvdW50LFxuICAgICAgICBuOiBpbmRleCxcbiAgICAgICAgZGF0YTogYixcbiAgICAgICAgdG90YWw6IHRvdGFsXG4gICAgICB9O1xuXG4gICAgICBjaHVua3MucHVzaChjaHVuayk7XG5cbiAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgaW5kZXggKz0gMTtcbiAgICB9XG4gICAgZGF0YUNvdW50ICs9IDE7XG4gICAgcmV0dXJuIGNodW5rcztcbiAgfSxcblxuICBibG9iVG9BcnJheUJ1ZmZlcjogZnVuY3Rpb24oYmxvYiwgY2Ipe1xuICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZnIub25sb2FkID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBjYihldnQudGFyZ2V0LnJlc3VsdCk7XG4gICAgfTtcbiAgICBmci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgfSxcbiAgYmxvYlRvQmluYXJ5U3RyaW5nOiBmdW5jdGlvbihibG9iLCBjYil7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGNiKGV2dC50YXJnZXQucmVzdWx0KTtcbiAgICB9O1xuICAgIGZyLnJlYWRBc0JpbmFyeVN0cmluZyhibG9iKTtcbiAgfSxcbiAgYmluYXJ5U3RyaW5nVG9BcnJheUJ1ZmZlcjogZnVuY3Rpb24oYmluYXJ5KSB7XG4gICAgdmFyIGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGJpbmFyeS5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBieXRlQXJyYXlbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKSAmIDB4ZmY7XG4gICAgfVxuICAgIHJldHVybiBieXRlQXJyYXkuYnVmZmVyO1xuICB9LFxuICByYW5kb21Ub2tlbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMik7XG4gIH0sXG4gIC8vXG5cbiAgaXNTZWN1cmU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdXRpbDtcblxufSx7XCIuL2FkYXB0ZXJcIjoxLFwianMtYmluYXJ5cGFja1wiOjEwfV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgRXZlbnRFbWl0dGVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEV2ZW50IGhhbmRsZXIgdG8gYmUgY2FsbGVkLlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBDb250ZXh0IGZvciBmdW5jdGlvbiBleGVjdXRpb24uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSBlbWl0IG9uY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogTWluaW1hbCBFdmVudEVtaXR0ZXIgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIEV2ZW50RW1pdHRlciBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7IC8qIE5vdGhpbmcgdG8gc2V0ICovIH1cblxuLyoqXG4gKiBIb2xkcyB0aGUgYXNzaWduZWQgRXZlbnRFbWl0dGVycyBieSBuYW1lLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5cbi8qKlxuICogUmV0dXJuIGEgbGlzdCBvZiBhc3NpZ25lZCBldmVudCBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudHMgdGhhdCBzaG91bGQgYmUgbGlzdGVkLlxuICogQHJldHVybnMge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1tldmVudF0pIHJldHVybiBbXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2V2ZW50c1tldmVudF0ubGVuZ3RoLCBlZSA9IFtdOyBpIDwgbDsgaSsrKSB7XG4gICAgZWUucHVzaCh0aGlzLl9ldmVudHNbZXZlbnRdW2ldLmZuKTtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogRW1pdCBhbiBldmVudCB0byBhbGwgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBuYW1lIG9mIHRoZSBldmVudC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJbmRpY2F0aW9uIGlmIHdlJ3ZlIGVtaXR0ZWQgYW4gZXZlbnQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1tldmVudF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2ZW50XVxuICAgICwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgZWUgPSBsaXN0ZW5lcnNbMF1cbiAgICAsIGFyZ3NcbiAgICAsIGksIGo7XG5cbiAgaWYgKDEgPT09IGxlbmd0aCkge1xuICAgIGlmIChlZS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBlZS5mbiwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gZWUuZm4uY2FsbChlZS5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGVlLmZuLmNhbGwoZWUuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gZWUuZm4uY2FsbChlZS5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gZWUuZm4uY2FsbChlZS5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGVlLmZuLmNhbGwoZWUuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gZWUuZm4uY2FsbChlZS5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBlZS5mbi5hcHBseShlZS5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIG5ldyBFdmVudExpc3RlbmVyIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IE5hbWUgb2YgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtGdW5jdG9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRleHQgVGhlIGNvbnRleHQgb2YgdGhlIGZ1bmN0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG4gIGlmICghdGhpcy5fZXZlbnRzW2V2ZW50XSkgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IFtdO1xuICB0aGlzLl9ldmVudHNbZXZlbnRdLnB1c2gobmV3IEVFKCBmbiwgY29udGV4dCB8fCB0aGlzICkpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gRXZlbnRMaXN0ZW5lciB0aGF0J3Mgb25seSBjYWxsZWQgb25jZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgTmFtZSBvZiB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRleHQgVGhlIGNvbnRleHQgb2YgdGhlIGZ1bmN0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuICBpZiAoIXRoaXMuX2V2ZW50c1tldmVudF0pIHRoaXMuX2V2ZW50c1tldmVudF0gPSBbXTtcbiAgdGhpcy5fZXZlbnRzW2V2ZW50XS5wdXNoKG5ldyBFRShmbiwgY29udGV4dCB8fCB0aGlzLCB0cnVlICkpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnQgd2Ugd2FudCB0byByZW1vdmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgdGhhdCB3ZSBuZWVkIHRvIGZpbmQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25jZSBsaXN0ZW5lcnMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBvbmNlKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbZXZlbnRdKSByZXR1cm4gdGhpcztcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2ZW50XVxuICAgICwgZXZlbnRzID0gW107XG5cbiAgaWYgKGZuKSBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gJiYgbGlzdGVuZXJzW2ldLm9uY2UgIT09IG9uY2UpIHtcbiAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgLy9cbiAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAvL1xuICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IGV2ZW50cztcbiAgZWxzZSB0aGlzLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb3Igb25seSB0aGUgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnQgd2FudCB0byByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKGV2ZW50KSB0aGlzLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgZWxzZSB0aGlzLl9ldmVudHMgPSB7fTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBkb2Vzbid0IGFwcGx5IGFueW1vcmUuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyMiA9IEV2ZW50RW1pdHRlcjtcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIzID0gRXZlbnRFbWl0dGVyO1xuXG5pZiAoJ29iamVjdCcgPT09IHR5cGVvZiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG5cbn0se31dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBCdWZmZXJCdWlsZGVyID0gcmVxdWlyZSgnLi9idWZmZXJidWlsZGVyJykuQnVmZmVyQnVpbGRlcjtcbnZhciBiaW5hcnlGZWF0dXJlcyA9IHJlcXVpcmUoJy4vYnVmZmVyYnVpbGRlcicpLmJpbmFyeUZlYXR1cmVzO1xuXG52YXIgQmluYXJ5UGFjayA9IHtcbiAgdW5wYWNrOiBmdW5jdGlvbihkYXRhKXtcbiAgICB2YXIgdW5wYWNrZXIgPSBuZXcgVW5wYWNrZXIoZGF0YSk7XG4gICAgcmV0dXJuIHVucGFja2VyLnVucGFjaygpO1xuICB9LFxuICBwYWNrOiBmdW5jdGlvbihkYXRhKXtcbiAgICB2YXIgcGFja2VyID0gbmV3IFBhY2tlcigpO1xuICAgIHBhY2tlci5wYWNrKGRhdGEpO1xuICAgIHZhciBidWZmZXIgPSBwYWNrZXIuZ2V0QnVmZmVyKCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCaW5hcnlQYWNrO1xuXG5mdW5jdGlvbiBVbnBhY2tlciAoZGF0YSl7XG4gIC8vIERhdGEgaXMgQXJyYXlCdWZmZXJcbiAgdGhpcy5pbmRleCA9IDA7XG4gIHRoaXMuZGF0YUJ1ZmZlciA9IGRhdGE7XG4gIHRoaXMuZGF0YVZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGFCdWZmZXIpO1xuICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YUJ1ZmZlci5ieXRlTGVuZ3RoO1xufVxuXG5VbnBhY2tlci5wcm90b3R5cGUudW5wYWNrID0gZnVuY3Rpb24oKXtcbiAgdmFyIHR5cGUgPSB0aGlzLnVucGFja191aW50OCgpO1xuICBpZiAodHlwZSA8IDB4ODApe1xuICAgIHZhciBwb3NpdGl2ZV9maXhudW0gPSB0eXBlO1xuICAgIHJldHVybiBwb3NpdGl2ZV9maXhudW07XG4gIH0gZWxzZSBpZiAoKHR5cGUgXiAweGUwKSA8IDB4MjApe1xuICAgIHZhciBuZWdhdGl2ZV9maXhudW0gPSAodHlwZSBeIDB4ZTApIC0gMHgyMDtcbiAgICByZXR1cm4gbmVnYXRpdmVfZml4bnVtO1xuICB9XG4gIHZhciBzaXplO1xuICBpZiAoKHNpemUgPSB0eXBlIF4gMHhhMCkgPD0gMHgwZil7XG4gICAgcmV0dXJuIHRoaXMudW5wYWNrX3JhdyhzaXplKTtcbiAgfSBlbHNlIGlmICgoc2l6ZSA9IHR5cGUgXiAweGIwKSA8PSAweDBmKXtcbiAgICByZXR1cm4gdGhpcy51bnBhY2tfc3RyaW5nKHNpemUpO1xuICB9IGVsc2UgaWYgKChzaXplID0gdHlwZSBeIDB4OTApIDw9IDB4MGYpe1xuICAgIHJldHVybiB0aGlzLnVucGFja19hcnJheShzaXplKTtcbiAgfSBlbHNlIGlmICgoc2l6ZSA9IHR5cGUgXiAweDgwKSA8PSAweDBmKXtcbiAgICByZXR1cm4gdGhpcy51bnBhY2tfbWFwKHNpemUpO1xuICB9XG4gIHN3aXRjaCh0eXBlKXtcbiAgICBjYXNlIDB4YzA6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIDB4YzE6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNhc2UgMHhjMjpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXNlIDB4YzM6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlIDB4Y2E6XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfZmxvYXQoKTtcbiAgICBjYXNlIDB4Y2I6XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfZG91YmxlKCk7XG4gICAgY2FzZSAweGNjOlxuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX3VpbnQ4KCk7XG4gICAgY2FzZSAweGNkOlxuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX3VpbnQxNigpO1xuICAgIGNhc2UgMHhjZTpcbiAgICAgIHJldHVybiB0aGlzLnVucGFja191aW50MzIoKTtcbiAgICBjYXNlIDB4Y2Y6XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfdWludDY0KCk7XG4gICAgY2FzZSAweGQwOlxuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX2ludDgoKTtcbiAgICBjYXNlIDB4ZDE6XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfaW50MTYoKTtcbiAgICBjYXNlIDB4ZDI6XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfaW50MzIoKTtcbiAgICBjYXNlIDB4ZDM6XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfaW50NjQoKTtcbiAgICBjYXNlIDB4ZDQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNhc2UgMHhkNTpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY2FzZSAweGQ2OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjYXNlIDB4ZDc6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNhc2UgMHhkODpcbiAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MTYoKTtcbiAgICAgIHJldHVybiB0aGlzLnVucGFja19zdHJpbmcoc2l6ZSk7XG4gICAgY2FzZSAweGQ5OlxuICAgICAgc2l6ZSA9IHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX3N0cmluZyhzaXplKTtcbiAgICBjYXNlIDB4ZGE6XG4gICAgICBzaXplID0gdGhpcy51bnBhY2tfdWludDE2KCk7XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfcmF3KHNpemUpO1xuICAgIGNhc2UgMHhkYjpcbiAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MzIoKTtcbiAgICAgIHJldHVybiB0aGlzLnVucGFja19yYXcoc2l6ZSk7XG4gICAgY2FzZSAweGRjOlxuICAgICAgc2l6ZSA9IHRoaXMudW5wYWNrX3VpbnQxNigpO1xuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX2FycmF5KHNpemUpO1xuICAgIGNhc2UgMHhkZDpcbiAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MzIoKTtcbiAgICAgIHJldHVybiB0aGlzLnVucGFja19hcnJheShzaXplKTtcbiAgICBjYXNlIDB4ZGU6XG4gICAgICBzaXplID0gdGhpcy51bnBhY2tfdWludDE2KCk7XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tfbWFwKHNpemUpO1xuICAgIGNhc2UgMHhkZjpcbiAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MzIoKTtcbiAgICAgIHJldHVybiB0aGlzLnVucGFja19tYXAoc2l6ZSk7XG4gIH1cbn1cblxuVW5wYWNrZXIucHJvdG90eXBlLnVucGFja191aW50OCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBieXRlID0gdGhpcy5kYXRhVmlld1t0aGlzLmluZGV4XSAmIDB4ZmY7XG4gIHRoaXMuaW5kZXgrKztcbiAgcmV0dXJuIGJ5dGU7XG59O1xuXG5VbnBhY2tlci5wcm90b3R5cGUudW5wYWNrX3VpbnQxNiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBieXRlcyA9IHRoaXMucmVhZCgyKTtcbiAgdmFyIHVpbnQxNiA9XG4gICAgKChieXRlc1swXSAmIDB4ZmYpICogMjU2KSArIChieXRlc1sxXSAmIDB4ZmYpO1xuICB0aGlzLmluZGV4ICs9IDI7XG4gIHJldHVybiB1aW50MTY7XG59XG5cblVucGFja2VyLnByb3RvdHlwZS51bnBhY2tfdWludDMyID0gZnVuY3Rpb24oKXtcbiAgdmFyIGJ5dGVzID0gdGhpcy5yZWFkKDQpO1xuICB2YXIgdWludDMyID1cbiAgICAgKChieXRlc1swXSAgKiAyNTYgK1xuICAgICAgIGJ5dGVzWzFdKSAqIDI1NiArXG4gICAgICAgYnl0ZXNbMl0pICogMjU2ICtcbiAgICAgICBieXRlc1szXTtcbiAgdGhpcy5pbmRleCArPSA0O1xuICByZXR1cm4gdWludDMyO1xufVxuXG5VbnBhY2tlci5wcm90b3R5cGUudW5wYWNrX3VpbnQ2NCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBieXRlcyA9IHRoaXMucmVhZCg4KTtcbiAgdmFyIHVpbnQ2NCA9XG4gICAoKCgoKChieXRlc1swXSAgKiAyNTYgK1xuICAgICAgIGJ5dGVzWzFdKSAqIDI1NiArXG4gICAgICAgYnl0ZXNbMl0pICogMjU2ICtcbiAgICAgICBieXRlc1szXSkgKiAyNTYgK1xuICAgICAgIGJ5dGVzWzRdKSAqIDI1NiArXG4gICAgICAgYnl0ZXNbNV0pICogMjU2ICtcbiAgICAgICBieXRlc1s2XSkgKiAyNTYgK1xuICAgICAgIGJ5dGVzWzddO1xuICB0aGlzLmluZGV4ICs9IDg7XG4gIHJldHVybiB1aW50NjQ7XG59XG5cblxuVW5wYWNrZXIucHJvdG90eXBlLnVucGFja19pbnQ4ID0gZnVuY3Rpb24oKXtcbiAgdmFyIHVpbnQ4ID0gdGhpcy51bnBhY2tfdWludDgoKTtcbiAgcmV0dXJuICh1aW50OCA8IDB4ODAgKSA/IHVpbnQ4IDogdWludDggLSAoMSA8PCA4KTtcbn07XG5cblVucGFja2VyLnByb3RvdHlwZS51bnBhY2tfaW50MTYgPSBmdW5jdGlvbigpe1xuICB2YXIgdWludDE2ID0gdGhpcy51bnBhY2tfdWludDE2KCk7XG4gIHJldHVybiAodWludDE2IDwgMHg4MDAwICkgPyB1aW50MTYgOiB1aW50MTYgLSAoMSA8PCAxNik7XG59XG5cblVucGFja2VyLnByb3RvdHlwZS51bnBhY2tfaW50MzIgPSBmdW5jdGlvbigpe1xuICB2YXIgdWludDMyID0gdGhpcy51bnBhY2tfdWludDMyKCk7XG4gIHJldHVybiAodWludDMyIDwgTWF0aC5wb3coMiwgMzEpICkgPyB1aW50MzIgOlxuICAgIHVpbnQzMiAtIE1hdGgucG93KDIsIDMyKTtcbn1cblxuVW5wYWNrZXIucHJvdG90eXBlLnVucGFja19pbnQ2NCA9IGZ1bmN0aW9uKCl7XG4gIHZhciB1aW50NjQgPSB0aGlzLnVucGFja191aW50NjQoKTtcbiAgcmV0dXJuICh1aW50NjQgPCBNYXRoLnBvdygyLCA2MykgKSA/IHVpbnQ2NCA6XG4gICAgdWludDY0IC0gTWF0aC5wb3coMiwgNjQpO1xufVxuXG5VbnBhY2tlci5wcm90b3R5cGUudW5wYWNrX3JhdyA9IGZ1bmN0aW9uKHNpemUpe1xuICBpZiAoIHRoaXMubGVuZ3RoIDwgdGhpcy5pbmRleCArIHNpemUpe1xuICAgIHRocm93IG5ldyBFcnJvcignQmluYXJ5UGFja0ZhaWx1cmU6IGluZGV4IGlzIG91dCBvZiByYW5nZSdcbiAgICAgICsgJyAnICsgdGhpcy5pbmRleCArICcgJyArIHNpemUgKyAnICcgKyB0aGlzLmxlbmd0aCk7XG4gIH1cbiAgdmFyIGJ1ZiA9IHRoaXMuZGF0YUJ1ZmZlci5zbGljZSh0aGlzLmluZGV4LCB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gIHRoaXMuaW5kZXggKz0gc2l6ZTtcblxuICAgIC8vYnVmID0gdXRpbC5idWZmZXJUb1N0cmluZyhidWYpO1xuXG4gIHJldHVybiBidWY7XG59XG5cblVucGFja2VyLnByb3RvdHlwZS51bnBhY2tfc3RyaW5nID0gZnVuY3Rpb24oc2l6ZSl7XG4gIHZhciBieXRlcyA9IHRoaXMucmVhZChzaXplKTtcbiAgdmFyIGkgPSAwLCBzdHIgPSAnJywgYywgY29kZTtcbiAgd2hpbGUoaSA8IHNpemUpe1xuICAgIGMgPSBieXRlc1tpXTtcbiAgICBpZiAoIGMgPCAxMjgpe1xuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICBpKys7XG4gICAgfSBlbHNlIGlmICgoYyBeIDB4YzApIDwgMzIpe1xuICAgICAgY29kZSA9ICgoYyBeIDB4YzApIDw8IDYpIHwgKGJ5dGVzW2krMV0gJiA2Myk7XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgIGkgKz0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSA9ICgoYyAmIDE1KSA8PCAxMikgfCAoKGJ5dGVzW2krMV0gJiA2MykgPDwgNikgfFxuICAgICAgICAoYnl0ZXNbaSsyXSAmIDYzKTtcbiAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgaSArPSAzO1xuICAgIH1cbiAgfVxuICB0aGlzLmluZGV4ICs9IHNpemU7XG4gIHJldHVybiBzdHI7XG59XG5cblVucGFja2VyLnByb3RvdHlwZS51bnBhY2tfYXJyYXkgPSBmdW5jdGlvbihzaXplKXtcbiAgdmFyIG9iamVjdHMgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplIDsgaSsrKXtcbiAgICBvYmplY3RzW2ldID0gdGhpcy51bnBhY2soKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0cztcbn1cblxuVW5wYWNrZXIucHJvdG90eXBlLnVucGFja19tYXAgPSBmdW5jdGlvbihzaXplKXtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZSA7IGkrKyl7XG4gICAgdmFyIGtleSAgPSB0aGlzLnVucGFjaygpO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudW5wYWNrKCk7XG4gICAgbWFwW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gbWFwO1xufVxuXG5VbnBhY2tlci5wcm90b3R5cGUudW5wYWNrX2Zsb2F0ID0gZnVuY3Rpb24oKXtcbiAgdmFyIHVpbnQzMiA9IHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICB2YXIgc2lnbiA9IHVpbnQzMiA+PiAzMTtcbiAgdmFyIGV4cCAgPSAoKHVpbnQzMiA+PiAyMykgJiAweGZmKSAtIDEyNztcbiAgdmFyIGZyYWN0aW9uID0gKCB1aW50MzIgJiAweDdmZmZmZiApIHwgMHg4MDAwMDA7XG4gIHJldHVybiAoc2lnbiA9PSAwID8gMSA6IC0xKSAqXG4gICAgZnJhY3Rpb24gKiBNYXRoLnBvdygyLCBleHAgLSAyMyk7XG59XG5cblVucGFja2VyLnByb3RvdHlwZS51bnBhY2tfZG91YmxlID0gZnVuY3Rpb24oKXtcbiAgdmFyIGgzMiA9IHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICB2YXIgbDMyID0gdGhpcy51bnBhY2tfdWludDMyKCk7XG4gIHZhciBzaWduID0gaDMyID4+IDMxO1xuICB2YXIgZXhwICA9ICgoaDMyID4+IDIwKSAmIDB4N2ZmKSAtIDEwMjM7XG4gIHZhciBoZnJhYyA9ICggaDMyICYgMHhmZmZmZiApIHwgMHgxMDAwMDA7XG4gIHZhciBmcmFjID0gaGZyYWMgKiBNYXRoLnBvdygyLCBleHAgLSAyMCkgK1xuICAgIGwzMiAgICogTWF0aC5wb3coMiwgZXhwIC0gNTIpO1xuICByZXR1cm4gKHNpZ24gPT0gMCA/IDEgOiAtMSkgKiBmcmFjO1xufVxuXG5VbnBhY2tlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKGxlbmd0aCl7XG4gIHZhciBqID0gdGhpcy5pbmRleDtcbiAgaWYgKGogKyBsZW5ndGggPD0gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhVmlldy5zdWJhcnJheShqLCBqICsgbGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpbmFyeVBhY2tGYWlsdXJlOiByZWFkIGluZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFBhY2tlcigpe1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIgPSBuZXcgQnVmZmVyQnVpbGRlcigpO1xufVxuXG5QYWNrZXIucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLmJ1ZmZlckJ1aWxkZXIuZ2V0QnVmZmVyKCk7XG59XG5cblBhY2tlci5wcm90b3R5cGUucGFjayA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHR5cGUgPSB0eXBlb2YodmFsdWUpO1xuICBpZiAodHlwZSA9PSAnc3RyaW5nJyl7XG4gICAgdGhpcy5wYWNrX3N0cmluZyh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PSAnbnVtYmVyJyl7XG4gICAgaWYgKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSl7XG4gICAgICB0aGlzLnBhY2tfaW50ZWdlcih2YWx1ZSk7XG4gICAgfSBlbHNle1xuICAgICAgdGhpcy5wYWNrX2RvdWJsZSh2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nKXtcbiAgICBpZiAodmFsdWUgPT09IHRydWUpe1xuICAgICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgweGMzKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBmYWxzZSl7XG4gICAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4YzIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09ICd1bmRlZmluZWQnKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4YzApO1xuICB9IGVsc2UgaWYgKHR5cGUgPT0gJ29iamVjdCcpe1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCl7XG4gICAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4YzApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChjb25zdHJ1Y3RvciA9PSBBcnJheSl7XG4gICAgICAgIHRoaXMucGFja19hcnJheSh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yID09IEJsb2IgfHwgY29uc3RydWN0b3IgPT0gRmlsZSkge1xuICAgICAgICB0aGlzLnBhY2tfYmluKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uc3RydWN0b3IgPT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgaWYoYmluYXJ5RmVhdHVyZXMudXNlQXJyYXlCdWZmZXJWaWV3KSB7XG4gICAgICAgICAgdGhpcy5wYWNrX2JpbihuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFja19iaW4odmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCdCWVRFU19QRVJfRUxFTUVOVCcgaW4gdmFsdWUpe1xuICAgICAgICBpZihiaW5hcnlGZWF0dXJlcy51c2VBcnJheUJ1ZmZlclZpZXcpIHtcbiAgICAgICAgICB0aGlzLnBhY2tfYmluKG5ldyBVaW50OEFycmF5KHZhbHVlLmJ1ZmZlcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFja19iaW4odmFsdWUuYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb25zdHJ1Y3RvciA9PSBPYmplY3Qpe1xuICAgICAgICB0aGlzLnBhY2tfb2JqZWN0KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uc3RydWN0b3IgPT0gRGF0ZSl7XG4gICAgICAgIHRoaXMucGFja19zdHJpbmcodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0JpbmFyeVBhY2sgPT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQodmFsdWUudG9CaW5hcnlQYWNrKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeXBlIFwiJyArIGNvbnN0cnVjdG9yLnRvU3RyaW5nKCkgKyAnXCIgbm90IHlldCBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUeXBlIFwiJyArIHR5cGUgKyAnXCIgbm90IHlldCBzdXBwb3J0ZWQnKTtcbiAgfVxuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuZmx1c2goKTtcbn1cblxuXG5QYWNrZXIucHJvdG90eXBlLnBhY2tfYmluID0gZnVuY3Rpb24oYmxvYil7XG4gIHZhciBsZW5ndGggPSBibG9iLmxlbmd0aCB8fCBibG9iLmJ5dGVMZW5ndGggfHwgYmxvYi5zaXplO1xuICBpZiAobGVuZ3RoIDw9IDB4MGYpe1xuICAgIHRoaXMucGFja191aW50OCgweGEwICsgbGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZGEpIDtcbiAgICB0aGlzLnBhY2tfdWludDE2KGxlbmd0aCk7XG4gIH0gZWxzZSBpZiAobGVuZ3RoIDw9IDB4ZmZmZmZmZmYpe1xuICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkYik7XG4gICAgdGhpcy5wYWNrX3VpbnQzMihsZW5ndGgpO1xuICB9IGVsc2V7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxlbmd0aCcpO1xuICB9XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoYmxvYik7XG59XG5cblBhY2tlci5wcm90b3R5cGUucGFja19zdHJpbmcgPSBmdW5jdGlvbihzdHIpe1xuICB2YXIgbGVuZ3RoID0gdXRmOExlbmd0aChzdHIpO1xuXG4gIGlmIChsZW5ndGggPD0gMHgwZil7XG4gICAgdGhpcy5wYWNrX3VpbnQ4KDB4YjAgKyBsZW5ndGgpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA8PSAweGZmZmYpe1xuICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkOCkgO1xuICAgIHRoaXMucGFja191aW50MTYobGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmZmZmZil7XG4gICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgweGQ5KTtcbiAgICB0aGlzLnBhY2tfdWludDMyKGxlbmd0aCk7XG4gIH0gZWxzZXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGVuZ3RoJyk7XG4gIH1cbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZChzdHIpO1xufVxuXG5QYWNrZXIucHJvdG90eXBlLnBhY2tfYXJyYXkgPSBmdW5jdGlvbihhcnkpe1xuICB2YXIgbGVuZ3RoID0gYXJ5Lmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA8PSAweDBmKXtcbiAgICB0aGlzLnBhY2tfdWludDgoMHg5MCArIGxlbmd0aCk7XG4gIH0gZWxzZSBpZiAobGVuZ3RoIDw9IDB4ZmZmZil7XG4gICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgweGRjKVxuICAgIHRoaXMucGFja191aW50MTYobGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmZmZmZil7XG4gICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgweGRkKTtcbiAgICB0aGlzLnBhY2tfdWludDMyKGxlbmd0aCk7XG4gIH0gZWxzZXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGVuZ3RoJyk7XG4gIH1cbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbmd0aCA7IGkrKyl7XG4gICAgdGhpcy5wYWNrKGFyeVtpXSk7XG4gIH1cbn1cblxuUGFja2VyLnByb3RvdHlwZS5wYWNrX2ludGVnZXIgPSBmdW5jdGlvbihudW0pe1xuICBpZiAoIC0weDIwIDw9IG51bSAmJiBudW0gPD0gMHg3Zil7XG4gICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZChudW0gJiAweGZmKTtcbiAgfSBlbHNlIGlmICgweDAwIDw9IG51bSAmJiBudW0gPD0gMHhmZil7XG4gICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgweGNjKTtcbiAgICB0aGlzLnBhY2tfdWludDgobnVtKTtcbiAgfSBlbHNlIGlmICgtMHg4MCA8PSBudW0gJiYgbnVtIDw9IDB4N2Ype1xuICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkMCk7XG4gICAgdGhpcy5wYWNrX2ludDgobnVtKTtcbiAgfSBlbHNlIGlmICggMHgwMDAwIDw9IG51bSAmJiBudW0gPD0gMHhmZmZmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4Y2QpO1xuICAgIHRoaXMucGFja191aW50MTYobnVtKTtcbiAgfSBlbHNlIGlmICgtMHg4MDAwIDw9IG51bSAmJiBudW0gPD0gMHg3ZmZmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZDEpO1xuICAgIHRoaXMucGFja19pbnQxNihudW0pO1xuICB9IGVsc2UgaWYgKCAweDAwMDAwMDAwIDw9IG51bSAmJiBudW0gPD0gMHhmZmZmZmZmZil7XG4gICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgweGNlKTtcbiAgICB0aGlzLnBhY2tfdWludDMyKG51bSk7XG4gIH0gZWxzZSBpZiAoLTB4ODAwMDAwMDAgPD0gbnVtICYmIG51bSA8PSAweDdmZmZmZmZmKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZDIpO1xuICAgIHRoaXMucGFja19pbnQzMihudW0pO1xuICB9IGVsc2UgaWYgKC0weDgwMDAwMDAwMDAwMDAwMDAgPD0gbnVtICYmIG51bSA8PSAweDdGRkZGRkZGRkZGRkZGRkYpe1xuICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkMyk7XG4gICAgdGhpcy5wYWNrX2ludDY0KG51bSk7XG4gIH0gZWxzZSBpZiAoMHgwMDAwMDAwMDAwMDAwMDAwIDw9IG51bSAmJiBudW0gPD0gMHhGRkZGRkZGRkZGRkZGRkZGKXtcbiAgICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4Y2YpO1xuICAgIHRoaXMucGFja191aW50NjQobnVtKTtcbiAgfSBlbHNle1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlZ2VyJyk7XG4gIH1cbn1cblxuUGFja2VyLnByb3RvdHlwZS5wYWNrX2RvdWJsZSA9IGZ1bmN0aW9uKG51bSl7XG4gIHZhciBzaWduID0gMDtcbiAgaWYgKG51bSA8IDApe1xuICAgIHNpZ24gPSAxO1xuICAgIG51bSA9IC1udW07XG4gIH1cbiAgdmFyIGV4cCAgPSBNYXRoLmZsb29yKE1hdGgubG9nKG51bSkgLyBNYXRoLkxOMik7XG4gIHZhciBmcmFjMCA9IG51bSAvIE1hdGgucG93KDIsIGV4cCkgLSAxO1xuICB2YXIgZnJhYzEgPSBNYXRoLmZsb29yKGZyYWMwICogTWF0aC5wb3coMiwgNTIpKTtcbiAgdmFyIGIzMiAgID0gTWF0aC5wb3coMiwgMzIpO1xuICB2YXIgaDMyID0gKHNpZ24gPDwgMzEpIHwgKChleHArMTAyMykgPDwgMjApIHxcbiAgICAgIChmcmFjMSAvIGIzMikgJiAweDBmZmZmZjtcbiAgdmFyIGwzMiA9IGZyYWMxICUgYjMyO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4Y2IpO1xuICB0aGlzLnBhY2tfaW50MzIoaDMyKTtcbiAgdGhpcy5wYWNrX2ludDMyKGwzMik7XG59XG5cblBhY2tlci5wcm90b3R5cGUucGFja19vYmplY3QgPSBmdW5jdGlvbihvYmope1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA8PSAweDBmKXtcbiAgICB0aGlzLnBhY2tfdWludDgoMHg4MCArIGxlbmd0aCk7XG4gIH0gZWxzZSBpZiAobGVuZ3RoIDw9IDB4ZmZmZil7XG4gICAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgweGRlKTtcbiAgICB0aGlzLnBhY2tfdWludDE2KGxlbmd0aCk7XG4gIH0gZWxzZSBpZiAobGVuZ3RoIDw9IDB4ZmZmZmZmZmYpe1xuICAgIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkZik7XG4gICAgdGhpcy5wYWNrX3VpbnQzMihsZW5ndGgpO1xuICB9IGVsc2V7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxlbmd0aCcpO1xuICB9XG4gIGZvcih2YXIgcHJvcCBpbiBvYmope1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpe1xuICAgICAgdGhpcy5wYWNrKHByb3ApO1xuICAgICAgdGhpcy5wYWNrKG9ialtwcm9wXSk7XG4gICAgfVxuICB9XG59XG5cblBhY2tlci5wcm90b3R5cGUucGFja191aW50OCA9IGZ1bmN0aW9uKG51bSl7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQobnVtKTtcbn1cblxuUGFja2VyLnByb3RvdHlwZS5wYWNrX3VpbnQxNiA9IGZ1bmN0aW9uKG51bSl7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQobnVtID4+IDgpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKG51bSAmIDB4ZmYpO1xufVxuXG5QYWNrZXIucHJvdG90eXBlLnBhY2tfdWludDMyID0gZnVuY3Rpb24obnVtKXtcbiAgdmFyIG4gPSBudW0gJiAweGZmZmZmZmZmO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChuICYgMHhmZjAwMDAwMCkgPj4+IDI0KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobiAmIDB4MDBmZjAwMDApID4+PiAxNik7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKG4gJiAweDAwMDBmZjAwKSA+Pj4gIDgpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChuICYgMHgwMDAwMDBmZikpO1xufVxuXG5QYWNrZXIucHJvdG90eXBlLnBhY2tfdWludDY0ID0gZnVuY3Rpb24obnVtKXtcbiAgdmFyIGhpZ2ggPSBudW0gLyBNYXRoLnBvdygyLCAzMik7XG4gIHZhciBsb3cgID0gbnVtICUgTWF0aC5wb3coMiwgMzIpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChoaWdoICYgMHhmZjAwMDAwMCkgPj4+IDI0KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgoaGlnaCAmIDB4MDBmZjAwMDApID4+PiAxNik7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGhpZ2ggJiAweDAwMDBmZjAwKSA+Pj4gIDgpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChoaWdoICYgMHgwMDAwMDBmZikpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChsb3cgICYgMHhmZjAwMDAwMCkgPj4+IDI0KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobG93ICAmIDB4MDBmZjAwMDApID4+PiAxNik7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGxvdyAgJiAweDAwMDBmZjAwKSA+Pj4gIDgpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChsb3cgICYgMHgwMDAwMDBmZikpO1xufVxuXG5QYWNrZXIucHJvdG90eXBlLnBhY2tfaW50OCA9IGZ1bmN0aW9uKG51bSl7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQobnVtICYgMHhmZik7XG59XG5cblBhY2tlci5wcm90b3R5cGUucGFja19pbnQxNiA9IGZ1bmN0aW9uKG51bSl7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKG51bSAmIDB4ZmYwMCkgPj4gOCk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQobnVtICYgMHhmZik7XG59XG5cblBhY2tlci5wcm90b3R5cGUucGFja19pbnQzMiA9IGZ1bmN0aW9uKG51bSl7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKG51bSA+Pj4gMjQpICYgMHhmZik7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKG51bSAmIDB4MDBmZjAwMDApID4+PiAxNik7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKG51bSAmIDB4MDAwMGZmMDApID4+PiA4KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobnVtICYgMHgwMDAwMDBmZikpO1xufVxuXG5QYWNrZXIucHJvdG90eXBlLnBhY2tfaW50NjQgPSBmdW5jdGlvbihudW0pe1xuICB2YXIgaGlnaCA9IE1hdGguZmxvb3IobnVtIC8gTWF0aC5wb3coMiwgMzIpKTtcbiAgdmFyIGxvdyAgPSBudW0gJSBNYXRoLnBvdygyLCAzMik7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGhpZ2ggJiAweGZmMDAwMDAwKSA+Pj4gMjQpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChoaWdoICYgMHgwMGZmMDAwMCkgPj4+IDE2KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgoaGlnaCAmIDB4MDAwMGZmMDApID4+PiAgOCk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGhpZ2ggJiAweDAwMDAwMGZmKSk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGxvdyAgJiAweGZmMDAwMDAwKSA+Pj4gMjQpO1xuICB0aGlzLmJ1ZmZlckJ1aWxkZXIuYXBwZW5kKChsb3cgICYgMHgwMGZmMDAwMCkgPj4+IDE2KTtcbiAgdGhpcy5idWZmZXJCdWlsZGVyLmFwcGVuZCgobG93ICAmIDB4MDAwMGZmMDApID4+PiAgOCk7XG4gIHRoaXMuYnVmZmVyQnVpbGRlci5hcHBlbmQoKGxvdyAgJiAweDAwMDAwMGZmKSk7XG59XG5cbmZ1bmN0aW9uIF91dGY4UmVwbGFjZShtKXtcbiAgdmFyIGNvZGUgPSBtLmNoYXJDb2RlQXQoMCk7XG5cbiAgaWYoY29kZSA8PSAweDdmZikgcmV0dXJuICcwMCc7XG4gIGlmKGNvZGUgPD0gMHhmZmZmKSByZXR1cm4gJzAwMCc7XG4gIGlmKGNvZGUgPD0gMHgxZmZmZmYpIHJldHVybiAnMDAwMCc7XG4gIGlmKGNvZGUgPD0gMHgzZmZmZmZmKSByZXR1cm4gJzAwMDAwJztcbiAgcmV0dXJuICcwMDAwMDAnO1xufVxuXG5mdW5jdGlvbiB1dGY4TGVuZ3RoKHN0cil7XG4gIGlmIChzdHIubGVuZ3RoID4gNjAwKSB7XG4gICAgLy8gQmxvYiBtZXRob2QgZmFzdGVyIGZvciBsYXJnZSBzdHJpbmdzXG4gICAgcmV0dXJuIChuZXcgQmxvYihbc3RyXSkpLnNpemU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXlxcdTAwMDAtXFx1MDA3Rl0vZywgX3V0ZjhSZXBsYWNlKS5sZW5ndGg7XG4gIH1cbn1cblxufSx7XCIuL2J1ZmZlcmJ1aWxkZXJcIjoxMX1dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBiaW5hcnlGZWF0dXJlcyA9IHt9O1xuYmluYXJ5RmVhdHVyZXMudXNlQmxvYkJ1aWxkZXIgPSAoZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICBuZXcgQmxvYihbXSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0pKCk7XG5cbmJpbmFyeUZlYXR1cmVzLnVzZUFycmF5QnVmZmVyVmlldyA9ICFiaW5hcnlGZWF0dXJlcy51c2VCbG9iQnVpbGRlciAmJiAoZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gKG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbXSldKSkuc2l6ZSA9PT0gMDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cy5iaW5hcnlGZWF0dXJlcyA9IGJpbmFyeUZlYXR1cmVzO1xudmFyIEJsb2JCdWlsZGVyID0gbW9kdWxlLmV4cG9ydHMuQmxvYkJ1aWxkZXI7XG5pZiAodHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJykge1xuICBCbG9iQnVpbGRlciA9IG1vZHVsZS5leHBvcnRzLkJsb2JCdWlsZGVyID0gd2luZG93LldlYktpdEJsb2JCdWlsZGVyIHx8XG4gICAgd2luZG93Lk1vekJsb2JCdWlsZGVyIHx8IHdpbmRvdy5NU0Jsb2JCdWlsZGVyIHx8IHdpbmRvdy5CbG9iQnVpbGRlcjtcbn1cblxuZnVuY3Rpb24gQnVmZmVyQnVpbGRlcigpe1xuICB0aGlzLl9waWVjZXMgPSBbXTtcbiAgdGhpcy5fcGFydHMgPSBbXTtcbn1cblxuQnVmZmVyQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICBpZih0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLl9waWVjZXMucHVzaChkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gICAgdGhpcy5fcGFydHMucHVzaChkYXRhKTtcbiAgfVxufTtcblxuQnVmZmVyQnVpbGRlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3BpZWNlcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMuX3BpZWNlcyk7XG4gICAgaWYoIWJpbmFyeUZlYXR1cmVzLnVzZUFycmF5QnVmZmVyVmlldykge1xuICAgICAgYnVmID0gYnVmLmJ1ZmZlcjtcbiAgICB9XG4gICAgdGhpcy5fcGFydHMucHVzaChidWYpO1xuICAgIHRoaXMuX3BpZWNlcyA9IFtdO1xuICB9XG59O1xuXG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5mbHVzaCgpO1xuICBpZihiaW5hcnlGZWF0dXJlcy51c2VCbG9iQnVpbGRlcikge1xuICAgIHZhciBidWlsZGVyID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gICAgZm9yKHZhciBpID0gMCwgaWkgPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBidWlsZGVyLmFwcGVuZCh0aGlzLl9wYXJ0c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBidWlsZGVyLmdldEJsb2IoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEJsb2IodGhpcy5fcGFydHMpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CdWZmZXJCdWlsZGVyID0gQnVmZmVyQnVpbGRlcjtcblxufSx7fV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLyoqXG4gKiBSZWxpYWJsZSB0cmFuc2ZlciBmb3IgQ2hyb21lIENhbmFyeSBEYXRhQ2hhbm5lbCBpbXBsLlxuICogQXV0aG9yOiBAbWljaGVsbGVidVxuICovXG5mdW5jdGlvbiBSZWxpYWJsZShkYywgZGVidWcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlbGlhYmxlKSkgcmV0dXJuIG5ldyBSZWxpYWJsZShkYyk7XG4gIHRoaXMuX2RjID0gZGM7XG5cbiAgdXRpbC5kZWJ1ZyA9IGRlYnVnO1xuXG4gIC8vIE1lc3NhZ2VzIHNlbnQvcmVjZWl2ZWQgc28gZmFyLlxuICAvLyBpZDogeyBhY2s6IG4sIGNodW5rczogWy4uLl0gfVxuICB0aGlzLl9vdXRnb2luZyA9IHt9O1xuICAvLyBpZDogeyBhY2s6IFsnYWNrJywgaWQsIG5dLCBjaHVua3M6IFsuLi5dIH1cbiAgdGhpcy5faW5jb21pbmcgPSB7fTtcbiAgdGhpcy5fcmVjZWl2ZWQgPSB7fTtcblxuICAvLyBXaW5kb3cgc2l6ZS5cbiAgdGhpcy5fd2luZG93ID0gMTAwMDtcbiAgLy8gTVRVLlxuICB0aGlzLl9tdHUgPSA1MDA7XG4gIC8vIEludGVydmFsIGZvciBzZXRJbnRlcnZhbC4gSW4gbXMuXG4gIHRoaXMuX2ludGVydmFsID0gMDtcblxuICAvLyBNZXNzYWdlcyBzZW50LlxuICB0aGlzLl9jb3VudCA9IDA7XG5cbiAgLy8gT3V0Z29pbmcgbWVzc2FnZSBxdWV1ZS5cbiAgdGhpcy5fcXVldWUgPSBbXTtcblxuICB0aGlzLl9zZXR1cERDKCk7XG59O1xuXG4vLyBTZW5kIGEgbWVzc2FnZSByZWxpYWJseS5cblJlbGlhYmxlLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obXNnKSB7XG4gIC8vIERldGVybWluZSBpZiBjaHVua2luZyBpcyBuZWNlc3NhcnkuXG4gIHZhciBibCA9IHV0aWwucGFjayhtc2cpO1xuICBpZiAoYmwuc2l6ZSA8IHRoaXMuX210dSkge1xuICAgIHRoaXMuX2hhbmRsZVNlbmQoWydubycsIGJsXSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fb3V0Z29pbmdbdGhpcy5fY291bnRdID0ge1xuICAgIGFjazogMCxcbiAgICBjaHVua3M6IHRoaXMuX2NodW5rKGJsKVxuICB9O1xuXG4gIGlmICh1dGlsLmRlYnVnKSB7XG4gICAgdGhpcy5fb3V0Z29pbmdbdGhpcy5fY291bnRdLnRpbWVyID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gIC8vIFNlbmQgcHJlbGltIHdpbmRvdy5cbiAgdGhpcy5fc2VuZFdpbmRvd2VkQ2h1bmtzKHRoaXMuX2NvdW50KTtcbiAgdGhpcy5fY291bnQgKz0gMTtcbn07XG5cbi8vIFNldCB1cCBpbnRlcnZhbCBmb3IgcHJvY2Vzc2luZyBxdWV1ZS5cblJlbGlhYmxlLnByb3RvdHlwZS5fc2V0dXBJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICAvLyBUT0RPOiBmYWlsIGdyYWNlZnVsbHkuXG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl90aW1lb3V0ID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgLy8gRklYTUU6IFN0cmluZyBzdHVmZiBtYWtlcyB0aGluZ3MgdGVycmlibHkgYXN5bmMuXG4gICAgdmFyIG1zZyA9IHNlbGYuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKG1zZy5fbXVsdGlwbGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG1zZy5sZW5ndGg7IGkgPCBpaTsgaSArPSAxKSB7XG4gICAgICAgIHNlbGYuX2ludGVydmFsU2VuZChtc2dbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl9pbnRlcnZhbFNlbmQobXNnKTtcbiAgICB9XG4gIH0sIHRoaXMuX2ludGVydmFsKTtcbn07XG5cblJlbGlhYmxlLnByb3RvdHlwZS5faW50ZXJ2YWxTZW5kID0gZnVuY3Rpb24obXNnKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgbXNnID0gdXRpbC5wYWNrKG1zZyk7XG4gIHV0aWwuYmxvYlRvQmluYXJ5U3RyaW5nKG1zZywgZnVuY3Rpb24oc3RyKSB7XG4gICAgc2VsZi5fZGMuc2VuZChzdHIpO1xuICB9KTtcbiAgaWYgKHNlbGYuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgIGNsZWFyVGltZW91dChzZWxmLl90aW1lb3V0KTtcbiAgICBzZWxmLl90aW1lb3V0ID0gbnVsbDtcbiAgICAvL3NlbGYuX3Byb2Nlc3NBY2tzKCk7XG4gIH1cbn07XG5cbi8vIEdvIHRocm91Z2ggQUNLcyB0byBzZW5kIG1pc3NpbmcgcGllY2VzLlxuUmVsaWFibGUucHJvdG90eXBlLl9wcm9jZXNzQWNrcyA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpZCBpbiB0aGlzLl9vdXRnb2luZykge1xuICAgIGlmICh0aGlzLl9vdXRnb2luZy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIHRoaXMuX3NlbmRXaW5kb3dlZENodW5rcyhpZCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBIYW5kbGUgc2VuZGluZyBhIG1lc3NhZ2UuXG4vLyBGSVhNRTogRG9uJ3Qgd2FpdCBmb3IgaW50ZXJ2YWwgdGltZSBmb3IgYWxsIG1lc3NhZ2VzLi4uXG5SZWxpYWJsZS5wcm90b3R5cGUuX2hhbmRsZVNlbmQgPSBmdW5jdGlvbihtc2cpIHtcbiAgdmFyIHB1c2ggPSB0cnVlO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkgPCBpaTsgaSArPSAxKSB7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLl9xdWV1ZVtpXTtcbiAgICBpZiAoaXRlbSA9PT0gbXNnKSB7XG4gICAgICBwdXNoID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpdGVtLl9tdWx0aXBsZSAmJiBpdGVtLmluZGV4T2YobXNnKSAhPT0gLTEpIHtcbiAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHB1c2gpIHtcbiAgICB0aGlzLl9xdWV1ZS5wdXNoKG1zZyk7XG4gICAgaWYgKCF0aGlzLl90aW1lb3V0KSB7XG4gICAgICB0aGlzLl9zZXR1cEludGVydmFsKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBTZXQgdXAgRGF0YUNoYW5uZWwgaGFuZGxlcnMuXG5SZWxpYWJsZS5wcm90b3R5cGUuX3NldHVwREMgPSBmdW5jdGlvbigpIHtcbiAgLy8gSGFuZGxlIHZhcmlvdXMgbWVzc2FnZSB0eXBlcy5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9kYy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG1zZyA9IGUuZGF0YTtcbiAgICB2YXIgZGF0YXR5cGUgPSBtc2cuY29uc3RydWN0b3I7XG4gICAgLy8gRklYTUU6IG1zZyBpcyBTdHJpbmcgdW50aWwgYmluYXJ5IGlzIHN1cHBvcnRlZC5cbiAgICAvLyBPbmNlIHRoYXQgaGFwcGVucywgdGhpcyB3aWxsIGhhdmUgdG8gYmUgc21hcnRlci5cbiAgICBpZiAoZGF0YXR5cGUgPT09IFN0cmluZykge1xuICAgICAgdmFyIGFiID0gdXRpbC5iaW5hcnlTdHJpbmdUb0FycmF5QnVmZmVyKG1zZyk7XG4gICAgICBtc2cgPSB1dGlsLnVucGFjayhhYik7XG4gICAgICBzZWxmLl9oYW5kbGVNZXNzYWdlKG1zZyk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gSGFuZGxlcyBhbiBpbmNvbWluZyBtZXNzYWdlLlxuUmVsaWFibGUucHJvdG90eXBlLl9oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gIHZhciBpZCA9IG1zZ1sxXTtcbiAgdmFyIGlkYXRhID0gdGhpcy5faW5jb21pbmdbaWRdO1xuICB2YXIgb2RhdGEgPSB0aGlzLl9vdXRnb2luZ1tpZF07XG4gIHZhciBkYXRhO1xuICBzd2l0Y2ggKG1zZ1swXSkge1xuICAgIC8vIE5vIGNodW5raW5nIHdhcyBkb25lLlxuICAgIGNhc2UgJ25vJzpcbiAgICAgIHZhciBtZXNzYWdlID0gaWQ7XG4gICAgICBpZiAoISFtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMub25tZXNzYWdlKHV0aWwudW5wYWNrKG1lc3NhZ2UpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIC8vIFJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbWVzc2FnZS5cbiAgICBjYXNlICdlbmQnOlxuICAgICAgZGF0YSA9IGlkYXRhO1xuXG4gICAgICAvLyBJbiBjYXNlIGVuZCBjb21lcyBmaXJzdC5cbiAgICAgIHRoaXMuX3JlY2VpdmVkW2lkXSA9IG1zZ1syXTtcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hY2soaWQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYWNrJzpcbiAgICAgIGRhdGEgPSBvZGF0YTtcbiAgICAgIGlmICghIWRhdGEpIHtcbiAgICAgICAgdmFyIGFjayA9IG1zZ1syXTtcbiAgICAgICAgLy8gVGFrZSB0aGUgbGFyZ2VyIEFDSywgZm9yIG91dCBvZiBvcmRlciBtZXNzYWdlcy5cbiAgICAgICAgZGF0YS5hY2sgPSBNYXRoLm1heChhY2ssIGRhdGEuYWNrKTtcblxuICAgICAgICAvLyBDbGVhbiB1cCB3aGVuIGFsbCBjaHVua3MgYXJlIEFDS2VkLlxuICAgICAgICBpZiAoZGF0YS5hY2sgPj0gZGF0YS5jaHVua3MubGVuZ3RoKSB7XG4gICAgICAgICAgdXRpbC5sb2coJ1RpbWU6ICcsIG5ldyBEYXRlKCkgLSBkYXRhLnRpbWVyKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fb3V0Z29pbmdbaWRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Byb2Nlc3NBY2tzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIElmICFkYXRhLCBqdXN0IGlnbm9yZS5cbiAgICAgIGJyZWFrO1xuICAgIC8vIFJlY2VpdmVkIGEgY2h1bmsgb2YgZGF0YS5cbiAgICBjYXNlICdjaHVuayc6XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgZW50cnkgaWYgbm9uZSBleGlzdHMuXG4gICAgICBkYXRhID0gaWRhdGE7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuX3JlY2VpdmVkW2lkXTtcbiAgICAgICAgaWYgKGVuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgYWNrOiBbJ2FjaycsIGlkLCAwXSxcbiAgICAgICAgICBjaHVua3M6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2luY29taW5nW2lkXSA9IGRhdGE7XG4gICAgICB9XG5cbiAgICAgIHZhciBuID0gbXNnWzJdO1xuICAgICAgdmFyIGNodW5rID0gbXNnWzNdO1xuICAgICAgZGF0YS5jaHVua3Nbbl0gPSBuZXcgVWludDhBcnJheShjaHVuayk7XG5cbiAgICAgIC8vIElmIHdlIGdldCB0aGUgY2h1bmsgd2UncmUgbG9va2luZyBmb3IsIEFDSyBmb3IgbmV4dCBtaXNzaW5nLlxuICAgICAgLy8gT3RoZXJ3aXNlLCBBQ0sgdGhlIHNhbWUgTiBhZ2Fpbi5cbiAgICAgIGlmIChuID09PSBkYXRhLmFja1syXSkge1xuICAgICAgICB0aGlzLl9jYWxjdWxhdGVOZXh0QWNrKGlkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FjayhpZCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gU2hvdWxkbid0IGhhcHBlbiwgYnV0IHdvdWxkIG1ha2Ugc2Vuc2UgZm9yIG1lc3NhZ2UgdG8ganVzdCBnb1xuICAgICAgLy8gdGhyb3VnaCBhcyBpcy5cbiAgICAgIHRoaXMuX2hhbmRsZVNlbmQobXNnKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vLyBDaHVua3MgQkwgaW50byBzbWFsbGVyIG1lc3NhZ2VzLlxuUmVsaWFibGUucHJvdG90eXBlLl9jaHVuayA9IGZ1bmN0aW9uKGJsKSB7XG4gIHZhciBjaHVua3MgPSBbXTtcbiAgdmFyIHNpemUgPSBibC5zaXplO1xuICB2YXIgc3RhcnQgPSAwO1xuICB3aGlsZSAoc3RhcnQgPCBzaXplKSB7XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHNpemUsIHN0YXJ0ICsgdGhpcy5fbXR1KTtcbiAgICB2YXIgYiA9IGJsLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIHZhciBjaHVuayA9IHtcbiAgICAgIHBheWxvYWQ6IGJcbiAgICB9XG4gICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgIHN0YXJ0ID0gZW5kO1xuICB9XG4gIHV0aWwubG9nKCdDcmVhdGVkJywgY2h1bmtzLmxlbmd0aCwgJ2NodW5rcy4nKTtcbiAgcmV0dXJuIGNodW5rcztcbn07XG5cbi8vIFNlbmRzIEFDSyBOLCBleHBlY3RpbmcgTnRoIGJsb2IgY2h1bmsgZm9yIG1lc3NhZ2UgSUQuXG5SZWxpYWJsZS5wcm90b3R5cGUuX2FjayA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBhY2sgPSB0aGlzLl9pbmNvbWluZ1tpZF0uYWNrO1xuXG4gIC8vIGlmIGFjayBpcyB0aGUgZW5kIHZhbHVlLCB0aGVuIGNhbGwgX2NvbXBsZXRlLlxuICBpZiAodGhpcy5fcmVjZWl2ZWRbaWRdID09PSBhY2tbMl0pIHtcbiAgICB0aGlzLl9jb21wbGV0ZShpZCk7XG4gICAgdGhpcy5fcmVjZWl2ZWRbaWRdID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2hhbmRsZVNlbmQoYWNrKTtcbn07XG5cbi8vIENhbGN1bGF0ZXMgdGhlIG5leHQgQUNLIG51bWJlciwgZ2l2ZW4gY2h1bmtzLlxuUmVsaWFibGUucHJvdG90eXBlLl9jYWxjdWxhdGVOZXh0QWNrID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9pbmNvbWluZ1tpZF07XG4gIHZhciBjaHVua3MgPSBkYXRhLmNodW5rcztcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gY2h1bmtzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDEpIHtcbiAgICAvLyBUaGlzIGNodW5rIGlzIG1pc3NpbmchISEgQmV0dGVyIEFDSyBmb3IgaXQuXG4gICAgaWYgKGNodW5rc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkYXRhLmFja1syXSA9IGk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGRhdGEuYWNrWzJdID0gY2h1bmtzLmxlbmd0aDtcbn07XG5cbi8vIFNlbmRzIHRoZSBuZXh0IHdpbmRvdyBvZiBjaHVua3MuXG5SZWxpYWJsZS5wcm90b3R5cGUuX3NlbmRXaW5kb3dlZENodW5rcyA9IGZ1bmN0aW9uKGlkKSB7XG4gIHV0aWwubG9nKCdzZW5kV2luZG93ZWRDaHVua3MgZm9yOiAnLCBpZCk7XG4gIHZhciBkYXRhID0gdGhpcy5fb3V0Z29pbmdbaWRdO1xuICB2YXIgY2ggPSBkYXRhLmNodW5rcztcbiAgdmFyIGNodW5rcyA9IFtdO1xuICB2YXIgbGltaXQgPSBNYXRoLm1pbihkYXRhLmFjayArIHRoaXMuX3dpbmRvdywgY2gubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IGRhdGEuYWNrOyBpIDwgbGltaXQ7IGkgKz0gMSkge1xuICAgIGlmICghY2hbaV0uc2VudCB8fCBpID09PSBkYXRhLmFjaykge1xuICAgICAgY2hbaV0uc2VudCA9IHRydWU7XG4gICAgICBjaHVua3MucHVzaChbJ2NodW5rJywgaWQsIGksIGNoW2ldLnBheWxvYWRdKTtcbiAgICB9XG4gIH1cbiAgaWYgKGRhdGEuYWNrICsgdGhpcy5fd2luZG93ID49IGNoLmxlbmd0aCkge1xuICAgIGNodW5rcy5wdXNoKFsnZW5kJywgaWQsIGNoLmxlbmd0aF0pXG4gIH1cbiAgY2h1bmtzLl9tdWx0aXBsZSA9IHRydWU7XG4gIHRoaXMuX2hhbmRsZVNlbmQoY2h1bmtzKTtcbn07XG5cbi8vIFB1dHMgdG9nZXRoZXIgYSBtZXNzYWdlIGZyb20gY2h1bmtzLlxuUmVsaWFibGUucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uKGlkKSB7XG4gIHV0aWwubG9nKCdDb21wbGV0ZWQgY2FsbGVkIGZvcicsIGlkKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2h1bmtzID0gdGhpcy5faW5jb21pbmdbaWRdLmNodW5rcztcbiAgdmFyIGJsID0gbmV3IEJsb2IoY2h1bmtzKTtcbiAgdXRpbC5ibG9iVG9BcnJheUJ1ZmZlcihibCwgZnVuY3Rpb24oYWIpIHtcbiAgICBzZWxmLm9ubWVzc2FnZSh1dGlsLnVucGFjayhhYikpO1xuICB9KTtcbiAgZGVsZXRlIHRoaXMuX2luY29taW5nW2lkXTtcbn07XG5cbi8vIFVwcyBiYW5kd2lkdGggbGltaXQgb24gU0RQLiBNZWFudCB0byBiZSBjYWxsZWQgZHVyaW5nIG9mZmVyL2Fuc3dlci5cblJlbGlhYmxlLmhpZ2hlckJhbmR3aWR0aFNEUCA9IGZ1bmN0aW9uKHNkcCkge1xuICAvLyBBUyBzdGFuZHMgZm9yIEFwcGxpY2F0aW9uLVNwZWNpZmljIE1heGltdW0uXG4gIC8vIEJhbmR3aWR0aCBudW1iZXIgaXMgaW4ga2lsb2JpdHMgLyBzZWMuXG4gIC8vIFNlZSBSRkMgZm9yIG1vcmUgaW5mbzogaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMjMyNy50eHRcblxuICAvLyBDaHJvbWUgMzErIGRvZXNuJ3Qgd2FudCB1cyBtdW5naW5nIHRoZSBTRFAsIHNvIHdlJ2xsIGxldCB0aGVtIGhhdmUgdGhlaXJcbiAgLy8gd2F5LlxuICB2YXIgdmVyc2lvbiA9IG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKC9DaHJvbWVcXC8oLio/KSAvKTtcbiAgaWYgKHZlcnNpb24pIHtcbiAgICB2ZXJzaW9uID0gcGFyc2VJbnQodmVyc2lvblsxXS5zcGxpdCgnLicpLnNoaWZ0KCkpO1xuICAgIGlmICh2ZXJzaW9uIDwgMzEpIHtcbiAgICAgIHZhciBwYXJ0cyA9IHNkcC5zcGxpdCgnYj1BUzozMCcpO1xuICAgICAgdmFyIHJlcGxhY2UgPSAnYj1BUzoxMDI0MDAnOyAvLyAxMDAgTWJwc1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzWzBdICsgcmVwbGFjZSArIHBhcnRzWzFdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBPdmVyd3JpdHRlbiwgdHlwaWNhbGx5LlxuUmVsaWFibGUucHJvdG90eXBlLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge307XG5cbm1vZHVsZS5leHBvcnRzLlJlbGlhYmxlID0gUmVsaWFibGU7XG5cbn0se1wiLi91dGlsXCI6MTN9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgQmluYXJ5UGFjayA9IHJlcXVpcmUoJ2pzLWJpbmFyeXBhY2snKTtcblxudmFyIHV0aWwgPSB7XG4gIGRlYnVnOiBmYWxzZSxcbiAgXG4gIGluaGVyaXRzOiBmdW5jdGlvbihjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGV4dGVuZDogZnVuY3Rpb24oZGVzdCwgc291cmNlKSB7XG4gICAgZm9yKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZihzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBkZXN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH0sXG4gIHBhY2s6IEJpbmFyeVBhY2sucGFjayxcbiAgdW5wYWNrOiBCaW5hcnlQYWNrLnVucGFjayxcbiAgXG4gIGxvZzogZnVuY3Rpb24gKCkge1xuICAgIGlmICh1dGlsLmRlYnVnKSB7XG4gICAgICB2YXIgY29weSA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29weVtpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIH1cbiAgICAgIGNvcHkudW5zaGlmdCgnUmVsaWFibGU6ICcpO1xuICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgY29weSk7XG4gICAgfVxuICB9LFxuXG4gIHNldFplcm9UaW1lb3V0OiAoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICAgdmFyIHRpbWVvdXRzID0gW107XG4gICAgdmFyIG1lc3NhZ2VOYW1lID0gJ3plcm8tdGltZW91dC1tZXNzYWdlJztcblxuICAgIC8vIExpa2Ugc2V0VGltZW91dCwgYnV0IG9ubHkgdGFrZXMgYSBmdW5jdGlvbiBhcmd1bWVudC5cdCBUaGVyZSdzXG4gICAgLy8gbm8gdGltZSBhcmd1bWVudCAoYWx3YXlzIHplcm8pIGFuZCBubyBhcmd1bWVudHMgKHlvdSBoYXZlIHRvXG4gICAgLy8gdXNlIGEgY2xvc3VyZSkuXG4gICAgZnVuY3Rpb24gc2V0WmVyb1RpbWVvdXRQb3N0TWVzc2FnZShmbikge1xuICAgICAgdGltZW91dHMucHVzaChmbik7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZU5hbWUsICcqJyk7XG4gICAgfVx0XHRcblxuICAgIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5zb3VyY2UgPT0gZ2xvYmFsICYmIGV2ZW50LmRhdGEgPT0gbWVzc2FnZU5hbWUpIHtcbiAgICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lb3V0cy5sZW5ndGgpIHtcbiAgICAgICAgICB0aW1lb3V0cy5zaGlmdCgpKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29ubWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0WmVyb1RpbWVvdXRQb3N0TWVzc2FnZTtcbiAgfSh0aGlzKSksXG4gIFxuICBibG9iVG9BcnJheUJ1ZmZlcjogZnVuY3Rpb24oYmxvYiwgY2Ipe1xuICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZnIub25sb2FkID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBjYihldnQudGFyZ2V0LnJlc3VsdCk7XG4gICAgfTtcbiAgICBmci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgfSxcbiAgYmxvYlRvQmluYXJ5U3RyaW5nOiBmdW5jdGlvbihibG9iLCBjYil7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGNiKGV2dC50YXJnZXQucmVzdWx0KTtcbiAgICB9O1xuICAgIGZyLnJlYWRBc0JpbmFyeVN0cmluZyhibG9iKTtcbiAgfSxcbiAgYmluYXJ5U3RyaW5nVG9BcnJheUJ1ZmZlcjogZnVuY3Rpb24oYmluYXJ5KSB7XG4gICAgdmFyIGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGJpbmFyeS5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBieXRlQXJyYXlbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKSAmIDB4ZmY7XG4gICAgfVxuICAgIHJldHVybiBieXRlQXJyYXkuYnVmZmVyO1xuICB9LFxuICByYW5kb21Ub2tlbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdXRpbDtcblxufSx7XCJqcy1iaW5hcnlwYWNrXCI6MTB9XX0se30sWzNdKTsiLCIvKiBodHRwczovL2dpdGh1Yi5jb20vamFrZWFyY2hpYmFsZC9lczYtcHJvbWlzZSAqL1xuIWZ1bmN0aW9uKCl7dmFyIGEsYixjLGQ7IWZ1bmN0aW9uKCl7dmFyIGU9e30sZj17fTthPWZ1bmN0aW9uKGEsYixjKXtlW2FdPXtkZXBzOmIsY2FsbGJhY2s6Y319LGQ9Yz1iPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGMoYil7aWYoXCIuXCIhPT1iLmNoYXJBdCgwKSlyZXR1cm4gYjtmb3IodmFyIGM9Yi5zcGxpdChcIi9cIiksZD1hLnNwbGl0KFwiL1wiKS5zbGljZSgwLC0xKSxlPTAsZj1jLmxlbmd0aDtmPmU7ZSsrKXt2YXIgZz1jW2VdO2lmKFwiLi5cIj09PWcpZC5wb3AoKTtlbHNle2lmKFwiLlwiPT09Zyljb250aW51ZTtkLnB1c2goZyl9fXJldHVybiBkLmpvaW4oXCIvXCIpfWlmKGQuX2Vha19zZWVuPWUsZlthXSlyZXR1cm4gZlthXTtpZihmW2FdPXt9LCFlW2FdKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIG1vZHVsZSBcIithKTtmb3IodmFyIGcsaD1lW2FdLGk9aC5kZXBzLGo9aC5jYWxsYmFjayxrPVtdLGw9MCxtPWkubGVuZ3RoO20+bDtsKyspXCJleHBvcnRzXCI9PT1pW2xdP2sucHVzaChnPXt9KTprLnB1c2goYihjKGlbbF0pKSk7dmFyIG49ai5hcHBseSh0aGlzLGspO3JldHVybiBmW2FdPWd8fG59fSgpLGEoXCJwcm9taXNlL2FsbFwiLFtcIi4vdXRpbHNcIixcImV4cG9ydHNcIl0sZnVuY3Rpb24oYSxiKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBjKGEpe3ZhciBiPXRoaXM7aWYoIWQoYSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gYWxsLlwiKTtyZXR1cm4gbmV3IGIoZnVuY3Rpb24oYixjKXtmdW5jdGlvbiBkKGEpe3JldHVybiBmdW5jdGlvbihiKXtmKGEsYil9fWZ1bmN0aW9uIGYoYSxjKXtoW2FdPWMsMD09PS0taSYmYihoKX12YXIgZyxoPVtdLGk9YS5sZW5ndGg7MD09PWkmJmIoW10pO2Zvcih2YXIgaj0wO2o8YS5sZW5ndGg7aisrKWc9YVtqXSxnJiZlKGcudGhlbik/Zy50aGVuKGQoaiksYyk6ZihqLGcpfSl9dmFyIGQ9YS5pc0FycmF5LGU9YS5pc0Z1bmN0aW9uO2IuYWxsPWN9KSxhKFwicHJvbWlzZS9hc2FwXCIsW1wiZXhwb3J0c1wiXSxmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKCl7cmV0dXJuIGZ1bmN0aW9uKCl7cHJvY2Vzcy5uZXh0VGljayhlKX19ZnVuY3Rpb24gYygpe3ZhciBhPTAsYj1uZXcgaShlKSxjPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO3JldHVybiBiLm9ic2VydmUoYyx7Y2hhcmFjdGVyRGF0YTohMH0pLGZ1bmN0aW9uKCl7Yy5kYXRhPWE9KythJTJ9fWZ1bmN0aW9uIGQoKXtyZXR1cm4gZnVuY3Rpb24oKXtqLnNldFRpbWVvdXQoZSwxKX19ZnVuY3Rpb24gZSgpe2Zvcih2YXIgYT0wO2E8ay5sZW5ndGg7YSsrKXt2YXIgYj1rW2FdLGM9YlswXSxkPWJbMV07YyhkKX1rPVtdfWZ1bmN0aW9uIGYoYSxiKXt2YXIgYz1rLnB1c2goW2EsYl0pOzE9PT1jJiZnKCl9dmFyIGcsaD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzp7fSxpPWguTXV0YXRpb25PYnNlcnZlcnx8aC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyLGo9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6dm9pZCAwPT09dGhpcz93aW5kb3c6dGhpcyxrPVtdO2c9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHByb2Nlc3MmJlwiW29iamVjdCBwcm9jZXNzXVwiPT09e30udG9TdHJpbmcuY2FsbChwcm9jZXNzKT9iKCk6aT9jKCk6ZCgpLGEuYXNhcD1mfSksYShcInByb21pc2UvY29uZmlnXCIsW1wiZXhwb3J0c1wiXSxmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGEsYil7cmV0dXJuIDIhPT1hcmd1bWVudHMubGVuZ3RoP2NbYV06KGNbYV09Yix2b2lkIDApfXZhciBjPXtpbnN0cnVtZW50OiExfTthLmNvbmZpZz1jLGEuY29uZmlndXJlPWJ9KSxhKFwicHJvbWlzZS9wb2x5ZmlsbFwiLFtcIi4vcHJvbWlzZVwiLFwiLi91dGlsc1wiLFwiZXhwb3J0c1wiXSxmdW5jdGlvbihhLGIsYyl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZCgpe3ZhciBhO2E9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93LmRvY3VtZW50P3dpbmRvdzpzZWxmO3ZhciBiPVwiUHJvbWlzZVwiaW4gYSYmXCJyZXNvbHZlXCJpbiBhLlByb21pc2UmJlwicmVqZWN0XCJpbiBhLlByb21pc2UmJlwiYWxsXCJpbiBhLlByb21pc2UmJlwicmFjZVwiaW4gYS5Qcm9taXNlJiZmdW5jdGlvbigpe3ZhciBiO3JldHVybiBuZXcgYS5Qcm9taXNlKGZ1bmN0aW9uKGEpe2I9YX0pLGYoYil9KCk7Ynx8KGEuUHJvbWlzZT1lKX12YXIgZT1hLlByb21pc2UsZj1iLmlzRnVuY3Rpb247Yy5wb2x5ZmlsbD1kfSksYShcInByb21pc2UvcHJvbWlzZVwiLFtcIi4vY29uZmlnXCIsXCIuL3V0aWxzXCIsXCIuL2FsbFwiLFwiLi9yYWNlXCIsXCIuL3Jlc29sdmVcIixcIi4vcmVqZWN0XCIsXCIuL2FzYXBcIixcImV4cG9ydHNcIl0sZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGEpe2lmKCF2KGEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yXCIpO2lmKCEodGhpcyBpbnN0YW5jZW9mIGkpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7dGhpcy5fc3Vic2NyaWJlcnM9W10saihhLHRoaXMpfWZ1bmN0aW9uIGooYSxiKXtmdW5jdGlvbiBjKGEpe28oYixhKX1mdW5jdGlvbiBkKGEpe3EoYixhKX10cnl7YShjLGQpfWNhdGNoKGUpe2QoZSl9fWZ1bmN0aW9uIGsoYSxiLGMsZCl7dmFyIGUsZixnLGgsaT12KGMpO2lmKGkpdHJ5e2U9YyhkKSxnPSEwfWNhdGNoKGope2g9ITAsZj1qfWVsc2UgZT1kLGc9ITA7bihiLGUpfHwoaSYmZz9vKGIsZSk6aD9xKGIsZik6YT09PUQ/byhiLGUpOmE9PT1FJiZxKGIsZSkpfWZ1bmN0aW9uIGwoYSxiLGMsZCl7dmFyIGU9YS5fc3Vic2NyaWJlcnMsZj1lLmxlbmd0aDtlW2ZdPWIsZVtmK0RdPWMsZVtmK0VdPWR9ZnVuY3Rpb24gbShhLGIpe2Zvcih2YXIgYyxkLGU9YS5fc3Vic2NyaWJlcnMsZj1hLl9kZXRhaWwsZz0wO2c8ZS5sZW5ndGg7Zys9MyljPWVbZ10sZD1lW2crYl0sayhiLGMsZCxmKTthLl9zdWJzY3JpYmVycz1udWxsfWZ1bmN0aW9uIG4oYSxiKXt2YXIgYyxkPW51bGw7dHJ5e2lmKGE9PT1iKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuXCIpO2lmKHUoYikmJihkPWIudGhlbix2KGQpKSlyZXR1cm4gZC5jYWxsKGIsZnVuY3Rpb24oZCl7cmV0dXJuIGM/ITA6KGM9ITAsYiE9PWQ/byhhLGQpOnAoYSxkKSx2b2lkIDApfSxmdW5jdGlvbihiKXtyZXR1cm4gYz8hMDooYz0hMCxxKGEsYiksdm9pZCAwKX0pLCEwfWNhdGNoKGUpe3JldHVybiBjPyEwOihxKGEsZSksITApfXJldHVybiExfWZ1bmN0aW9uIG8oYSxiKXthPT09Yj9wKGEsYik6bihhLGIpfHxwKGEsYil9ZnVuY3Rpb24gcChhLGIpe2EuX3N0YXRlPT09QiYmKGEuX3N0YXRlPUMsYS5fZGV0YWlsPWIsdC5hc3luYyhyLGEpKX1mdW5jdGlvbiBxKGEsYil7YS5fc3RhdGU9PT1CJiYoYS5fc3RhdGU9QyxhLl9kZXRhaWw9Yix0LmFzeW5jKHMsYSkpfWZ1bmN0aW9uIHIoYSl7bShhLGEuX3N0YXRlPUQpfWZ1bmN0aW9uIHMoYSl7bShhLGEuX3N0YXRlPUUpfXZhciB0PWEuY29uZmlnLHU9KGEuY29uZmlndXJlLGIub2JqZWN0T3JGdW5jdGlvbiksdj1iLmlzRnVuY3Rpb24sdz0oYi5ub3csYy5hbGwpLHg9ZC5yYWNlLHk9ZS5yZXNvbHZlLHo9Zi5yZWplY3QsQT1nLmFzYXA7dC5hc3luYz1BO3ZhciBCPXZvaWQgMCxDPTAsRD0xLEU9MjtpLnByb3RvdHlwZT17Y29uc3RydWN0b3I6aSxfc3RhdGU6dm9pZCAwLF9kZXRhaWw6dm9pZCAwLF9zdWJzY3JpYmVyczp2b2lkIDAsdGhlbjpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZD1uZXcgdGhpcy5jb25zdHJ1Y3RvcihmdW5jdGlvbigpe30pO2lmKHRoaXMuX3N0YXRlKXt2YXIgZT1hcmd1bWVudHM7dC5hc3luYyhmdW5jdGlvbigpe2soYy5fc3RhdGUsZCxlW2MuX3N0YXRlLTFdLGMuX2RldGFpbCl9KX1lbHNlIGwodGhpcyxkLGEsYik7cmV0dXJuIGR9LFwiY2F0Y2hcIjpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy50aGVuKG51bGwsYSl9fSxpLmFsbD13LGkucmFjZT14LGkucmVzb2x2ZT15LGkucmVqZWN0PXosaC5Qcm9taXNlPWl9KSxhKFwicHJvbWlzZS9yYWNlXCIsW1wiLi91dGlsc1wiLFwiZXhwb3J0c1wiXSxmdW5jdGlvbihhLGIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGMoYSl7dmFyIGI9dGhpcztpZighZChhKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLlwiKTtyZXR1cm4gbmV3IGIoZnVuY3Rpb24oYixjKXtmb3IodmFyIGQsZT0wO2U8YS5sZW5ndGg7ZSsrKWQ9YVtlXSxkJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBkLnRoZW4/ZC50aGVuKGIsYyk6YihkKX0pfXZhciBkPWEuaXNBcnJheTtiLnJhY2U9Y30pLGEoXCJwcm9taXNlL3JlamVjdFwiLFtcImV4cG9ydHNcIl0sZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihhKXt2YXIgYj10aGlzO3JldHVybiBuZXcgYihmdW5jdGlvbihiLGMpe2MoYSl9KX1hLnJlamVjdD1ifSksYShcInByb21pc2UvcmVzb2x2ZVwiLFtcImV4cG9ydHNcIl0sZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihhKXtpZihhJiZcIm9iamVjdFwiPT10eXBlb2YgYSYmYS5jb25zdHJ1Y3Rvcj09PXRoaXMpcmV0dXJuIGE7dmFyIGI9dGhpcztyZXR1cm4gbmV3IGIoZnVuY3Rpb24oYil7YihhKX0pfWEucmVzb2x2ZT1ifSksYShcInByb21pc2UvdXRpbHNcIixbXCJleHBvcnRzXCJdLGZ1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYSl7cmV0dXJuIGMoYSl8fFwib2JqZWN0XCI9PXR5cGVvZiBhJiZudWxsIT09YX1mdW5jdGlvbiBjKGEpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGF9ZnVuY3Rpb24gZChhKXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSl9dmFyIGU9RGF0ZS5ub3d8fGZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBEYXRlKS5nZXRUaW1lKCl9O2Eub2JqZWN0T3JGdW5jdGlvbj1iLGEuaXNGdW5jdGlvbj1jLGEuaXNBcnJheT1kLGEubm93PWV9KSxiKFwicHJvbWlzZS9wb2x5ZmlsbFwiKS5wb2x5ZmlsbCgpfSgpOyIsIi8qXHJcbkNvcHlyaWdodCAoQykgMjAxMSBQYXRyaWNrIEdpbGxlc3BpZSwgaHR0cDovL3BhdG9yamsuY29tL1xyXG5cclxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG5USEUgU09GVFdBUkUuXHJcbiovXHJcblxyXG4vKlxyXG4gICAgRXh0ZW5kaWJsZSBCQkNvZGUgUGFyc2VyIHYxLjAuMFxyXG4gICAgQnkgUGF0cmljayBHaWxsZXNwaWUgKHBhdG9yamtAZ21haWwuY29tKVxyXG4gICAgV2Vic2l0ZTogaHR0cDovL3BhdG9yamsuY29tL1xyXG5cclxuICAgIFRoaXMgbW9kdWxlIGFsbG93cyB5b3UgdG8gcGFyc2UgQkJDb2RlIGFuZCB0byBleHRlbmQgdG8gdGhlIG1hcmstdXAgbGFuZ3VhZ2VcclxuICAgIHRvIGFkZCBpbiB5b3VyIG93biB0YWdzLlxyXG4qL1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgWEJCQ09ERSA9IChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gU2V0IHVwIHByaXZhdGUgdmFyaWFibGVzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgIHZhciBtZSA9IHt9LFxyXG4gICAgICAgIHVybFBhdHRlcm4gPSAvXig/Omh0dHBzP3xmaWxlfGMpOig/OlxcL3sxLDN9fFxcXFx7MX0pWy1hLXpBLVowLTk6QCMlJigpfl8/XFwrPVxcL1xcXFxcXC5dKiQvLFxyXG4gICAgICAgIGNvbG9yTmFtZVBhdHRlcm4gPSAvXig/OnJlZHxncmVlbnxibHVlfG9yYW5nZXx5ZWxsb3d8YmxhY2t8d2hpdGV8YnJvd258Z3JheXxzaWx2ZXJ8cHVycGxlfG1hcm9vbnxmdXNoc2lhfGxpbWV8b2xpdmV8bmF2eXx0ZWFsfGFxdWEpJC8sXHJcbiAgICAgICAgY29sb3JDb2RlUGF0dGVybiA9IC9eIz9bYS1mQS1GMC05XXs2fSQvLFxyXG4gICAgICAgIHRhZ3MsXHJcbiAgICAgICAgdGFnTGlzdCxcclxuICAgICAgICB0YWdzTm9QYXJzZUxpc3QgPSBbXSxcclxuICAgICAgICBiYlJlZ0V4cCxcclxuICAgICAgICBwYmJSZWdFeHAsXHJcbiAgICAgICAgcGJiUmVnRXhwMixcclxuICAgICAgICBvcGVuVGFncyxcclxuICAgICAgICBjbG9zZVRhZ3M7XHJcbiAgICAgICAgXHJcbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICogdGFnc1xyXG4gICAgICogVGhpcyBvYmplY3QgY29udGFpbnMgYSBsaXN0IG9mIHRhZ3MgdGhhdCB5b3VyIGNvZGUgd2lsbCBiZSBhYmxlIHRvIHVuZGVyc3RhbmQuXHJcbiAgICAgKiBFYWNoIHRhZyBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgICAqXHJcbiAgICAgKiAgIG9wZW5UYWcgLSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgaW4gdGhlIHRhZydzIHBhcmFtZXRlcnMgKGlmIGFueSkgYW5kIGl0c1xyXG4gICAgICogICAgICAgICAgICAgY29udGVudHMsIGFuZCByZXR1cm5zIHdoYXQgaXRzIEhUTUwgb3BlbiB0YWcgc2hvdWxkIGJlLiBcclxuICAgICAqICAgICAgICAgICAgIEV4YW1wbGU6IFtjb2xvcj1yZWRddGVzdFsvY29sb3JdIHdvdWxkIHRha2UgaW4gXCI9cmVkXCIgYXMgYVxyXG4gICAgICogICAgICAgICAgICAgcGFyYW1ldGVyIGlucHV0LCBhbmQgXCJ0ZXN0XCIgYXMgYSBjb250ZW50IGlucHV0LlxyXG4gICAgICogICAgICAgICAgICAgSXQgc2hvdWxkIGJlIG5vdGVkIHRoYXQgYW55IEJCQ29kZSBpbnNpZGUgb2YgXCJjb250ZW50XCIgd2lsbCBoYXZlIFxyXG4gICAgICogICAgICAgICAgICAgYmVlbiBwcm9jZXNzZWQgYnkgdGhlIHRpbWUgaXQgZW50ZXIgdGhlIG9wZW5UYWcgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogICBjbG9zZVRhZyAtIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBpbiB0aGUgdGFnJ3MgcGFyYW1ldGVycyAoaWYgYW55KSBhbmQgaXRzXHJcbiAgICAgKiAgICAgICAgICAgICAgY29udGVudHMsIGFuZCByZXR1cm5zIHdoYXQgaXRzIEhUTUwgY2xvc2UgdGFnIHNob3VsZCBiZS5cclxuICAgICAqXHJcbiAgICAgKiAgIGRpc3BsYXlDb250ZW50IC0gRGVmYXVsdHMgdG8gdHJ1ZS4gSWYgZmFsc2UsIHRoZSBjb250ZW50IGZvciB0aGUgdGFnIHdpbGxcclxuICAgICAqICAgICAgICAgICAgICAgICAgICBub3QgYmUgZGlzcGxheWVkLiBUaGlzIGlzIHVzZWZ1bCBmb3IgdGFncyBsaWtlIElNRyB3aGVyZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgIGl0cyBjb250ZW50cyBhcmUgYWN0dWFsbHkgYSBwYXJhbWV0ZXIgaW5wdXQuXHJcbiAgICAgKlxyXG4gICAgICogICByZXN0cmljdENoaWxkcmVuVG8gLSBBIGxpc3Qgb2YgQkJDb2RlIHRhZ3Mgd2hpY2ggYXJlIGFsbG93ZWQgdG8gYmUgbmVzdGVkXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhpbiB0aGlzIEJCQ29kZSB0YWcuIElmIHRoaXMgcHJvcGVydHkgaXMgb21pdHRlZCxcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgYW55IEJCQ29kZSB0YWcgbWF5IGJlIG5lc3RlZCB3aXRoaW4gdGhlIHRhZy5cclxuICAgICAqXHJcbiAgICAgKiAgIHJlc3RyaWN0UGFyZW50c1RvIC0gQSBsaXN0IG9mIEJCQ29kZSB0YWdzIHdoaWNoIGFyZSBhbGxvd2VkIHRvIGJlIHBhcmVudHMgb2ZcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB0aGlzIEJCQ29kZSB0YWcuIElmIHRoaXMgcHJvcGVydHkgaXMgb21pdHRlZCwgYW55IEJCQ29kZSBcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB0YWcgbWF5IGJlIGEgcGFyZW50IG9mIHRoZSB0YWcuXHJcbiAgICAgKlxyXG4gICAgICogICBub1BhcnNlIC0gdHJ1ZSBvciBmYWxzZS4gSWYgdHJ1ZSwgbm9uZSBvZiB0aGUgY29udGVudCBXSVRISU4gdGhpcyB0YWcgd2lsbCBiZVxyXG4gICAgICogICAgICAgICAgICAgcGFyc2VkIGJ5IHRoZSBYQkJDb2RlIHBhcnNlci5cclxuICAgICAqICAgICAgIFxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBMSU1JVElPTlMgb24gYWRkaW5nIE5FVyBUQUdTOlxyXG4gICAgICogIC0gVGFnIG5hbWVzIHNob3VsZCBiZSBhbHBoYW51bWVyaWMgKGluY2x1ZGluZyB1bmRlcnNjb3JlcykgYW5kIGFsbCB0YWdzIHNob3VsZCBoYXZlIGFuIG9wZW5pbmcgdGFnXHJcbiAgICAgKiAgICBhbmQgYSBjbG9zaW5nIHRhZy4gXHJcbiAgICAgKiAgICBUaGUgWypdIHRhZyBpcyBhbiBleGNlcHRpb24gYmVjYXVzZSBpdCB3YXMgYWxyZWFkeSBhIHN0YW5kYXJkXHJcbiAgICAgKiAgICBiYmNvZGUgdGFnLiBUZWNobmVjaWFsbHkgdGFncyBkb24ndCAqaGF2ZSogdG8gYmUgYWxwaGFudW1lcmljLCBidXQgc2luY2UgXHJcbiAgICAgKiAgICByZWd1bGFyIGV4cHJlc3Npb25zIGFyZSB1c2VkIHRvIHBhcnNlIHRoZSB0ZXh0LCBpZiB5b3UgdXNlIGEgbm9uLWFscGhhbnVtZXJpYyBcclxuICAgICAqICAgIHRhZyBuYW1lcywganVzdCBtYWtlIHN1cmUgdGhlIHRhZyBuYW1lIGdldHMgZXNjYXBlZCBwcm9wZXJseSAoaWYgbmVlZGVkKS5cclxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgICAgIFxyXG4gICAgdGFncyA9IHtcclxuICAgICAgICBcImJcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cInhiYmNvZGUtYlwiPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L3NwYW4+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLypcclxuICAgICAgICAgICAgVGhpcyB0YWcgZG9lcyBub3RoaW5nIGFuZCBpcyBoZXJlIG1vc3RseSB0byBiZSB1c2VkIGFzIGEgY2xhc3NpZmljYXRpb24gZm9yXHJcbiAgICAgICAgICAgIHRoZSBiYmNvZGUgaW5wdXQgd2hlbiBldmFsdWF0aW5nIHBhcmVudC1jaGlsZCB0YWcgcmVsYXRpb25zaGlwc1xyXG4gICAgICAgICovXHJcbiAgICAgICAgXCJiYmNvZGVcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJjb2RlXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCJ4YmJjb2RlLWNvZGVcIj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC9zcGFuPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG5vUGFyc2U6IHRydWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiY29sb3JcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHZhciBjb2xvckNvZGUgPSBwYXJhbXMuc3Vic3RyKDEpIHx8IFwiYmxhY2tcIjtcclxuICAgICAgICAgICAgICAgIGNvbG9yTmFtZVBhdHRlcm4ubGFzdEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbG9yQ29kZVBhdHRlcm4ubGFzdEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICggIWNvbG9yTmFtZVBhdHRlcm4udGVzdCggY29sb3JDb2RlICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhY29sb3JDb2RlUGF0dGVybi50ZXN0KCBjb2xvckNvZGUgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JDb2RlID0gXCJibGFja1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xvckNvZGUuc3Vic3RyKDAsMSkgIT09IFwiI1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvckNvZGUgPSBcIiNcIiArIGNvbG9yQ29kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxzcGFuIHN0eWxlPVwiY29sb3I6JyArIGNvbG9yQ29kZSArICdcIj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC9zcGFuPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiaVwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwieGJiY29kZS1pXCI+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImltZ1wiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIG15VXJsID0gY29udGVudDtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdXJsUGF0dGVybi5sYXN0SW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhdXJsUGF0dGVybi50ZXN0KCBteVVybCApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIG15VXJsID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxpbWcgc3JjPVwiJyArIG15VXJsICsgJ1wiIC8+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRpc3BsYXlDb250ZW50OiBmYWxzZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJsaXN0XCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHVsPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L3VsPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc3RyaWN0Q2hpbGRyZW5UbzogW1wiKlwiLCBcImxpXCJdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIm5vcGFyc2VcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbm9QYXJzZTogdHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJwaHBcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cInhiYmNvZGUtY29kZVwiPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L3NwYW4+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbm9QYXJzZTogdHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJxdW90ZVwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxibG9ja3F1b3RlIGNsYXNzPVwieGJiY29kZS1ibG9ja3F1b3RlXCI+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvYmxvY2txdW90ZT4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInNcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cInhiYmNvZGUtc1wiPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L3NwYW4+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzaXplXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgbXlTaXplID0gcGFyc2VJbnQocGFyYW1zLnN1YnN0cigxKSwxMCkgfHwgMDtcclxuICAgICAgICAgICAgICAgIGlmIChteVNpemUgPCA0IHx8IG15U2l6ZSA+IDQwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbXlTaXplID0gMTQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cInhiYmNvZGUtc2l6ZS0nICsgbXlTaXplICsgJ1wiPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L3NwYW4+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0YWJsZVwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzx0YWJsZSBjbGFzcz1cInhiYmNvZGUtdGFibGVcIj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC90YWJsZT4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXN0cmljdENoaWxkcmVuVG86IFtcInRib2R5XCIsXCJ0aGVhZFwiLCBcInRmb290XCIsIFwidHJcIl1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidGJvZHlcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8dGJvZHk+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvdGJvZHk+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVzdHJpY3RDaGlsZHJlblRvOiBbXCJ0clwiXSxcclxuICAgICAgICAgICAgcmVzdHJpY3RQYXJlbnRzVG86IFtcInRhYmxlXCJdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInRmb290XCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHRmb290Pic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L3Rmb290Pic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc3RyaWN0Q2hpbGRyZW5UbzogW1widHJcIl0sXHJcbiAgICAgICAgICAgIHJlc3RyaWN0UGFyZW50c1RvOiBbXCJ0YWJsZVwiXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0aGVhZFwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzx0aGVhZCBjbGFzcz1cInhiYmNvZGUtdGhlYWRcIj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC90aGVhZD4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXN0cmljdENoaWxkcmVuVG86IFtcInRyXCJdLFxyXG4gICAgICAgICAgICByZXN0cmljdFBhcmVudHNUbzogW1widGFibGVcIl1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidGRcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJ4YmJjb2RlLXRkXCI+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2VUYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzwvdGQ+JztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVzdHJpY3RQYXJlbnRzVG86IFtcInRyXCJdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInRoXCI6IHtcclxuICAgICAgICAgICAgb3BlblRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwieGJiY29kZS10aFwiPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L3RkPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc3RyaWN0UGFyZW50c1RvOiBbXCJ0clwiXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ0clwiOiB7XHJcbiAgICAgICAgICAgIG9wZW5UYWc6IGZ1bmN0aW9uKHBhcmFtcyxjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzx0ciBjbGFzcz1cInhiYmNvZGUtdHJcIj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC90cj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXN0cmljdENoaWxkcmVuVG86IFtcInRkXCIsXCJ0aFwiXSxcclxuICAgICAgICAgICAgcmVzdHJpY3RQYXJlbnRzVG86IFtcInRhYmxlXCIsXCJ0Ym9keVwiLFwidGZvb3RcIixcInRoZWFkXCJdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInVcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cInhiYmNvZGUtdVwiPic7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8L3NwYW4+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ1cmxcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHZhciBteVVybDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG15VXJsID0gY29udGVudC5yZXBsYWNlKC88Lio/Pi9nLFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBteVVybCA9IHBhcmFtcy5zdWJzdHIoMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHVybFBhdHRlcm4ubGFzdEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICggIXVybFBhdHRlcm4udGVzdCggbXlVcmwgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBteVVybCA9IFwiI1wiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPGEgaHJlZj1cIicgKyBteVVybCArICdcIj4nO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPC9hPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICAgIFRoZSBbKl0gdGFnIGlzIHNwZWNpYWwgc2luY2UgdGhlIHVzZXIgZG9lcyBub3QgZGVmaW5lIGEgY2xvc2luZyBbLypdIHRhZyB3aGVuIHdyaXRpbmcgdGhlaXIgYmJjb2RlLlxyXG4gICAgICAgICAgICBJbnN0ZWFkIHRoaXMgbW9kdWxlIHBhcnNlcyB0aGUgY29kZSBhbmQgYWRkcyB0aGUgY2xvc2luZyBbLypdIHRhZyBpbiBmb3IgdGhlbS4gTm9uZSBvZiB0aGUgdGFncyB5b3VcclxuICAgICAgICAgICAgYWRkIHdpbGwgYWN0IGxpa2UgdGhpcyBhbmQgdGhpcyB0YWcgaXMgYW4gZXhjZXB0aW9uIHRvIHRoZSBvdGhlcnMuXHJcbiAgICAgICAgKi9cclxuICAgICAgICBcIipcIjoge1xyXG4gICAgICAgICAgICBvcGVuVGFnOiBmdW5jdGlvbihwYXJhbXMsY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiPGxpPlwiO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbG9zZVRhZzogZnVuY3Rpb24ocGFyYW1zLGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIjwvbGk+XCI7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc3RyaWN0UGFyZW50c1RvOiBbXCJsaXN0XCJdXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy8gY3JlYXRlIHRhZyBsaXN0IGFuZCBsb29rdXAgZmllbGRzXHJcbiAgICB0YWdMaXN0ID0gW107XHJcbiAgICAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHByb3AsXHJcbiAgICAgICAgICAgIGlpLFxyXG4gICAgICAgICAgICBsZW47XHJcbiAgICAgICAgZm9yIChwcm9wIGluIHRhZ3MpIHtcclxuICAgICAgICAgICAgaWYgKHRhZ3MuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSBcIipcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhZ0xpc3QucHVzaChcIlxcXFxcIiArIHByb3ApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0YWdMaXN0LnB1c2gocHJvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0YWdzW3Byb3BdLm5vUGFyc2UgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3NOb1BhcnNlTGlzdC5wdXNoKHByb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdGFnc1twcm9wXS52YWxpZENoaWxkTG9va3VwID0ge307XHJcbiAgICAgICAgICAgICAgICB0YWdzW3Byb3BdLnZhbGlkUGFyZW50TG9va3VwID0ge307XHJcbiAgICAgICAgICAgICAgICB0YWdzW3Byb3BdLnJlc3RyaWN0UGFyZW50c1RvID0gdGFnc1twcm9wXS5yZXN0cmljdFBhcmVudHNUbyB8fCBbXTtcclxuICAgICAgICAgICAgICAgIHRhZ3NbcHJvcF0ucmVzdHJpY3RDaGlsZHJlblRvID0gdGFnc1twcm9wXS5yZXN0cmljdENoaWxkcmVuVG8gfHwgW107XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGxlbiA9IHRhZ3NbcHJvcF0ucmVzdHJpY3RDaGlsZHJlblRvLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAoaWkgPSAwOyBpaSA8IGxlbjsgaWkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhZ3NbcHJvcF0udmFsaWRDaGlsZExvb2t1cFsgdGFnc1twcm9wXS5yZXN0cmljdENoaWxkcmVuVG9baWldIF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGVuID0gdGFnc1twcm9wXS5yZXN0cmljdFBhcmVudHNUby5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGlpID0gMDsgaWkgPCBsZW47IGlpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0YWdzW3Byb3BdLnZhbGlkUGFyZW50TG9va3VwWyB0YWdzW3Byb3BdLnJlc3RyaWN0UGFyZW50c1RvW2lpXSBdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pKCk7XHJcbiAgICBcclxuICAgIGJiUmVnRXhwID0gbmV3IFJlZ0V4cChcIjxiYmNsPShbMC05XSspIChcIiArIHRhZ0xpc3Quam9pbihcInxcIikgKyBcIikoWyA9XVtePl0qPyk/PigoPzoufFtcXFxcclxcXFxuXSkqPyk8YmJjbD1cXFxcMSAvXFxcXDI+XCIsIFwiZ2lcIik7IFxyXG4gICAgcGJiUmVnRXhwID0gbmV3IFJlZ0V4cChcIlxcXFxbKFwiICsgdGFnTGlzdC5qb2luKFwifFwiKSArIFwiKShbID1dW15cXFxcXV0qPyk/XFxcXF0oW15cXFxcW10qPylcXFxcWy9cXFxcMVxcXFxdXCIsIFwiZ2lcIik7IFxyXG4gICAgcGJiUmVnRXhwMiA9IG5ldyBSZWdFeHAoXCJcXFxcWyhcIiArIHRhZ3NOb1BhcnNlTGlzdC5qb2luKFwifFwiKSArIFwiKShbID1dW15cXFxcXV0qPyk/XFxcXF0oW1xcXFxzXFxcXFNdKj8pXFxcXFsvXFxcXDFcXFxcXVwiLCBcImdpXCIpOyAgICBcclxuXHJcbiAgICAvLyBjcmVhdGUgdGhlIHJlZ2V4IGZvciBlc2NhcGluZyBbJ3MgdGhhdCBhcmVuJ3QgYXBhcnQgb2YgdGFnc1xyXG4gICAgKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBjbG9zZVRhZ0xpc3QgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdGFnTGlzdC5sZW5ndGg7IGlpKyspIHtcclxuICAgICAgICAgICAgaWYgKCB0YWdMaXN0W2lpXSAhPT0gXCJcXFxcKlwiICkgeyAvLyB0aGUgKiB0YWcgZG9lc24ndCBoYXZlIGFuIG9mZmljYWwgY2xvc2luZyB0YWdcclxuICAgICAgICAgICAgICAgIGNsb3NlVGFnTGlzdC5wdXNoICggXCIvXCIgKyB0YWdMaXN0W2lpXSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvcGVuVGFncyA9IG5ldyBSZWdFeHAoXCIoXFxcXFspKCg/OlwiICsgdGFnTGlzdC5qb2luKFwifFwiKSArIFwiKSg/OlsgPV1bXlxcXFxdXSo/KT8pKFxcXFxdKVwiLCBcImdpXCIpOyBcclxuICAgICAgICBjbG9zZVRhZ3MgPSBuZXcgUmVnRXhwKFwiKFxcXFxbKShcIiArIGNsb3NlVGFnTGlzdC5qb2luKFwifFwiKSArIFwiKShcXFxcXSlcIiwgXCJnaVwiKTsgXHJcbiAgICB9KSgpO1xyXG4gICAgXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gcHJpdmF0ZSBmdW5jdGlvbnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGNoZWNrUGFyZW50Q2hpbGRSZXN0cmljdGlvbnMocGFyZW50VGFnLCBiYmNvZGUsIGJiY29kZUxldmVsLCB0YWdOYW1lLCB0YWdQYXJhbXMsIHRhZ0NvbnRlbnRzLCBlcnJRdWV1ZSkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGVyclF1ZXVlID0gZXJyUXVldWUgfHwgW107XHJcbiAgICAgICAgYmJjb2RlTGV2ZWwrKztcclxuICAgICAgICBcclxuICAgICAgICAvLyBnZXQgYSBsaXN0IG9mIGFsbCBvZiB0aGUgY2hpbGQgdGFncyB0byB0aGlzIHRhZ1xyXG4gICAgICAgIHZhciByZVRhZ05hbWVzID0gbmV3IFJlZ0V4cChcIig8YmJjbD1cIiArIGJiY29kZUxldmVsICsgXCIgKShcIiArIHRhZ0xpc3Quam9pbihcInxcIikgKyBcIikoWyA9Pl0pXCIsXCJnaVwiKSxcclxuICAgICAgICAgICAgcmVUYWdOYW1lc1BhcnRzID0gbmV3IFJlZ0V4cChcIig8YmJjbD1cIiArIGJiY29kZUxldmVsICsgXCIgKShcIiArIHRhZ0xpc3Quam9pbihcInxcIikgKyBcIikoWyA9Pl0pXCIsXCJpXCIpLFxyXG4gICAgICAgICAgICBtYXRjaGluZ1RhZ3MgPSB0YWdDb250ZW50cy5tYXRjaChyZVRhZ05hbWVzKSB8fCBbXSxcclxuICAgICAgICAgICAgY0luZm8sXHJcbiAgICAgICAgICAgIGVyclN0cixcclxuICAgICAgICAgICAgaWksXHJcbiAgICAgICAgICAgIGNoaWxkVGFnLFxyXG4gICAgICAgICAgICBwSW5mbyA9IHRhZ3NbcGFyZW50VGFnXSB8fCB7fTtcclxuICAgICAgICBcclxuICAgICAgICByZVRhZ05hbWVzLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCFtYXRjaGluZ1RhZ3MpIHtcclxuICAgICAgICAgICAgdGFnQ29udGVudHMgPSBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBmb3IgKGlpID0gMDsgaWkgPCBtYXRjaGluZ1RhZ3MubGVuZ3RoOyBpaSsrKSB7XHJcbiAgICAgICAgICAgIHJlVGFnTmFtZXNQYXJ0cy5sYXN0SW5kZXggPSAwO1xyXG4gICAgICAgICAgICBjaGlsZFRhZyA9IChtYXRjaGluZ1RhZ3NbaWldLm1hdGNoKHJlVGFnTmFtZXNQYXJ0cykpWzJdLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoIHBJbmZvLnJlc3RyaWN0Q2hpbGRyZW5Uby5sZW5ndGggPiAwICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhcEluZm8udmFsaWRDaGlsZExvb2t1cFtjaGlsZFRhZ10gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gXCJUaGUgdGFnIFxcXCJcIiArIGNoaWxkVGFnICsgXCJcXFwiIGlzIG5vdCBhbGxvd2VkIGFzIGEgY2hpbGQgb2YgdGhlIHRhZyBcXFwiXCIgKyBwYXJlbnRUYWcgKyBcIlxcXCIuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyUXVldWUucHVzaChlcnJTdHIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNJbmZvID0gdGFnc1tjaGlsZFRhZ10gfHwge307XHJcbiAgICAgICAgICAgIGlmICggY0luZm8ucmVzdHJpY3RQYXJlbnRzVG8ubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgICAgIGlmICggIWNJbmZvLnZhbGlkUGFyZW50TG9va3VwW3BhcmVudFRhZ10gKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gXCJUaGUgdGFnIFxcXCJcIiArIHBhcmVudFRhZyArIFwiXFxcIiBpcyBub3QgYWxsb3dlZCBhcyBhIHBhcmVudCBvZiB0aGUgdGFnIFxcXCJcIiArIGNoaWxkVGFnICsgXCJcXFwiLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGVyclF1ZXVlLnB1c2goZXJyU3RyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGFnQ29udGVudHMgPSB0YWdDb250ZW50cy5yZXBsYWNlKGJiUmVnRXhwLCBmdW5jdGlvbihtYXRjaFN0ciwgYmJjb2RlTGV2ZWwsIHRhZ05hbWUsIHRhZ1BhcmFtcywgdGFnQ29udGVudHMgKSB7XHJcbiAgICAgICAgICAgIGVyclF1ZXVlID0gY2hlY2tQYXJlbnRDaGlsZFJlc3RyaWN0aW9ucyh0YWdOYW1lLCBtYXRjaFN0ciwgYmJjb2RlTGV2ZWwsIHRhZ05hbWUsIHRhZ1BhcmFtcywgdGFnQ29udGVudHMsIGVyclF1ZXVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoU3RyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBlcnJRdWV1ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLypcclxuICAgICAgICBUaGlzIGZ1bmN0aW9uIHVwZGF0ZXMgb3IgYWRkcyBhIHBpZWNlIG9mIG1ldGFkYXRhIHRvIGVhY2ggdGFnIGNhbGxlZCBcImJiY2xcIiB3aGljaCBcclxuICAgICAgICBpbmRpY2F0ZXMgaG93IGRlZXBseSBuZXN0ZWQgYSBwYXJ0aWN1bGFyIHRhZyB3YXMgaW4gdGhlIGJiY29kZS4gVGhpcyBwcm9wZXJ0eSBpcyByZW1vdmVkXHJcbiAgICAgICAgZnJvbSB0aGUgSFRNTCBjb2RlIHRhZ3MgYXQgdGhlIGVuZCBvZiB0aGUgcHJvY2Vzc2luZy5cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVUYWdEZXB0aHModGFnQ29udGVudHMpIHtcclxuICAgICAgICB0YWdDb250ZW50cyA9IHRhZ0NvbnRlbnRzLnJlcGxhY2UoL1xcPChbXlxcPl1bXlxcPl0qPylcXD4vZ2ksIGZ1bmN0aW9uKG1hdGNoU3RyLCBzdWJNYXRjaFN0cikge1xyXG4gICAgICAgICAgICB2YXIgYmJDb2RlTGV2ZWwgPSBzdWJNYXRjaFN0ci5tYXRjaCgvXmJiY2w9KFswLTldKykgLyk7XHJcbiAgICAgICAgICAgIGlmIChiYkNvZGVMZXZlbCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiPGJiY2w9MCBcIiArIHN1Yk1hdGNoU3RyICsgXCI+XCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCI8XCIgKyBzdWJNYXRjaFN0ci5yZXBsYWNlKC9eKGJiY2w9KShbMC05XSspLywgZnVuY3Rpb24obWF0Y2hTdHIsIG0xLCBtMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtMSArIChwYXJzZUludChtMiwgMTApICsgMSk7XHJcbiAgICAgICAgICAgICAgICB9KSArIFwiPlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRhZ0NvbnRlbnRzO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKlxyXG4gICAgICAgIFRoaXMgZnVuY3Rpb24gcmVtb3ZlcyB0aGUgbWV0YWRhdGEgYWRkZWQgYnkgdGhlIHVwZGF0ZVRhZ0RlcHRocyBmdW5jdGlvblxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIHVucHJvY2Vzcyh0YWdDb250ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRhZ0NvbnRlbnQucmVwbGFjZSgvPGJiY2w9WzAtOV0rIFxcL1xcKj4vZ2ksXCJcIikucmVwbGFjZSgvPGJiY2w9WzAtOV0rIC9naSxcIiYjOTE7XCIpLnJlcGxhY2UoLz4vZ2ksXCImIzkzO1wiKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIHJlcGxhY2VGdW5jdCA9IGZ1bmN0aW9uKG1hdGNoU3RyLCBiYmNvZGVMZXZlbCwgdGFnTmFtZSwgdGFnUGFyYW1zLCB0YWdDb250ZW50cykge1xyXG4gICAgXHJcbiAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgdmFyIHByb2Nlc3NlZENvbnRlbnQgPSB0YWdzW3RhZ05hbWVdLm5vUGFyc2UgPyB1bnByb2Nlc3ModGFnQ29udGVudHMpIDogdGFnQ29udGVudHMucmVwbGFjZShiYlJlZ0V4cCwgcmVwbGFjZUZ1bmN0KSxcclxuICAgICAgICAgICAgb3BlblRhZyA9IHRhZ3NbdGFnTmFtZV0ub3BlblRhZyh0YWdQYXJhbXMscHJvY2Vzc2VkQ29udGVudCksXHJcbiAgICAgICAgICAgIGNsb3NlVGFnID0gdGFnc1t0YWdOYW1lXS5jbG9zZVRhZyh0YWdQYXJhbXMscHJvY2Vzc2VkQ29udGVudCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIGlmICggdGFnc1t0YWdOYW1lXS5kaXNwbGF5Q29udGVudCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcHJvY2Vzc2VkQ29udGVudCA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBvcGVuVGFnICsgcHJvY2Vzc2VkQ29udGVudCArIGNsb3NlVGFnO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZShjb25maWcpIHtcclxuICAgICAgICB2YXIgb3V0cHV0ID0gY29uZmlnLnRleHQ7XHJcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoYmJSZWdFeHAsIHJlcGxhY2VGdW5jdCk7XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLypcclxuICAgICAgICBUaGUgc3RhciB0YWcgWypdIGlzIHNwZWNpYWwgaW4gdGhhdCBpdCBkb2VzIG5vdCB1c2UgYSBjbG9zaW5nIHRhZy4gU2luY2UgdGhpcyBwYXJzZXIgcmVxdWlyZXMgdGhhdCB0YWdzIHRvIGhhdmUgYSBjbG9zaW5nXHJcbiAgICAgICAgdGFnLCB3ZSBtdXN0IHByZS1wcm9jZXNzIHRoZSBpbnB1dCBhbmQgYWRkIGluIGNsb3NpbmcgdGFncyBbLypdIGZvciB0aGUgc3RhciB0YWcuXHJcbiAgICAgICAgV2UgaGF2ZSBhIGxpdHRsZSBsZXZhcmlkZ2UgaW4gdGhhdCB3ZSBrbm93IHRoZSB0ZXh0IHdlJ3JlIHByb2Nlc3Npbmcgd29udCBjb250YWluIHRoZSA8PiBjaGFyYWN0ZXJzICh0aGV5IGhhdmUgYmVlblxyXG4gICAgICAgIGNoYW5nZWQgaW50byB0aGVpciBIVE1MIGVudGl0eSBmb3JtIHRvIHByZXZlbnQgWFNTIGFuZCBjb2RlIGluamVjdGlvbiksIHNvIHdlIGNhbiB1c2UgdGhvc2UgY2hhcmFjdGVycyBhcyBtYXJrZXJzIHRvXHJcbiAgICAgICAgaGVscCB1cyBkZWZpbmUgYm91bmRhcmllcyBhbmQgZmlndXJlIG91dCB3aGVyZSB0byBwbGFjZSB0aGUgWy8qXSB0YWdzLlxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIGZpeFN0YXJUYWcodGV4dCkge1xyXG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcWyg/IVxcKlsgPVxcXV18bGlzdChbID1dW15cXF1dKik/XFxdfFxcL2xpc3RbXFxdXSkvaWcsIFwiPFwiKTtcclxuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXFsoPz1saXN0KFsgPV1bXlxcXV0qKT9cXF18XFwvbGlzdFtcXF1dKS9pZywgXCI+XCIpO1xyXG5cclxuICAgICAgICB3aGlsZSAodGV4dCAhPT0gKHRleHQgPSB0ZXh0LnJlcGxhY2UoLz5saXN0KFsgPV1bXlxcXV0qKT9cXF0oW14+XSo/KSg+XFwvbGlzdF0pL2dpLCBmdW5jdGlvbihtYXRjaFN0cixjb250ZW50cyxlbmRUYWcpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBpbm5lckxpc3RUeHQgPSBtYXRjaFN0cjtcclxuICAgICAgICAgICAgd2hpbGUgKGlubmVyTGlzdFR4dCAhPT0gKGlubmVyTGlzdFR4dCA9IGlubmVyTGlzdFR4dC5yZXBsYWNlKC9cXFtcXCpcXF0oW15cXFtdKj8pKFxcW1xcKlxcXXw+XFwvbGlzdF0pL2ksIGZ1bmN0aW9uKG1hdGNoU3RyLGNvbnRlbnRzLGVuZFRhZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVuZFRhZyA9PT0gXCI+L2xpc3RdXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRUYWcgPSBcIjwvKl08L2xpc3RdXCI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZFRhZyA9IFwiPC8qXVsqXVwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IFwiPCpdXCIgKyBjb250ZW50cyArIGVuZFRhZztcclxuICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XHJcbiAgICAgICAgICAgIH0pKSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpbm5lckxpc3RUeHQgPSBpbm5lckxpc3RUeHQucmVwbGFjZSgvPi9nLCBcIjxcIik7ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiBpbm5lckxpc3RUeHQ7XHJcbiAgICAgICAgfSkpKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBhZGQgWydzIGZvciBvdXIgdGFncyBiYWNrIGluXHJcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvPC9nLCBcIltcIik7XHJcbiAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBhZGRCYmNvZGVMZXZlbHModGV4dCkge1xyXG4gICAgICAgIHdoaWxlICggdGV4dCAhPT0gKHRleHQgPSB0ZXh0LnJlcGxhY2UocGJiUmVnRXhwLCBmdW5jdGlvbihtYXRjaFN0ciwgdGFnTmFtZSwgdGFnUGFyYW1zLCB0YWdDb250ZW50cykge1xyXG4gICAgICAgICAgICBtYXRjaFN0ciA9IG1hdGNoU3RyLnJlcGxhY2UoL1xcWy9nLCBcIjxcIik7XHJcbiAgICAgICAgICAgIG1hdGNoU3RyID0gbWF0Y2hTdHIucmVwbGFjZSgvXFxdL2csIFwiPlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVRhZ0RlcHRocyhtYXRjaFN0cik7XHJcbiAgICAgICAgfSkpICk7XHJcbiAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBwdWJsaWMgZnVuY3Rpb25zXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgXHJcbiAgICBtZS5wcm9jZXNzID0gZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICBcclxuICAgICAgICB2YXIgcmV0ID0ge2h0bWw6IFwiXCIsIGVycm9yOiBmYWxzZX0sXHJcbiAgICAgICAgICAgIGVyclF1ZXVlID0gW107XHJcblxyXG4gICAgICAgIGNvbmZpZy50ZXh0ID0gY29uZmlnLnRleHQucmVwbGFjZSgvPC9nLCBcIiZsdDtcIik7IC8vIGVzY2FwZSBIVE1MIHRhZyBicmFja2V0c1xyXG4gICAgICAgIGNvbmZpZy50ZXh0ID0gY29uZmlnLnRleHQucmVwbGFjZSgvPi9nLCBcIiZndDtcIik7IC8vIGVzY2FwZSBIVE1MIHRhZyBicmFja2V0c1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbmZpZy50ZXh0ID0gY29uZmlnLnRleHQucmVwbGFjZShvcGVuVGFncywgZnVuY3Rpb24obWF0Y2hTdHIsIG9wZW5CLCBjb250ZW50cywgY2xvc2VCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIjxcIiArIGNvbnRlbnRzICsgXCI+XCI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uZmlnLnRleHQgPSBjb25maWcudGV4dC5yZXBsYWNlKGNsb3NlVGFncywgZnVuY3Rpb24obWF0Y2hTdHIsIG9wZW5CLCBjb250ZW50cywgY2xvc2VCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIjxcIiArIGNvbnRlbnRzICsgXCI+XCI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uZmlnLnRleHQgPSBjb25maWcudGV4dC5yZXBsYWNlKC9cXFsvZywgXCImIzkxO1wiKTsgLy8gZXNjYXBlIFsncyB0aGF0IGFyZW4ndCBhcGFydCBvZiB0YWdzXHJcbiAgICAgICAgY29uZmlnLnRleHQgPSBjb25maWcudGV4dC5yZXBsYWNlKC9cXF0vZywgXCImIzkzO1wiKTsgLy8gZXNjYXBlIFsncyB0aGF0IGFyZW4ndCBhcGFydCBvZiB0YWdzXHJcbiAgICAgICAgY29uZmlnLnRleHQgPSBjb25maWcudGV4dC5yZXBsYWNlKC88L2csIFwiW1wiKTsgLy8gZXNjYXBlIFsncyB0aGF0IGFyZW4ndCBhcGFydCBvZiB0YWdzXHJcbiAgICAgICAgY29uZmlnLnRleHQgPSBjb25maWcudGV4dC5yZXBsYWNlKC8+L2csIFwiXVwiKTsgLy8gZXNjYXBlIFsncyB0aGF0IGFyZW4ndCBhcGFydCBvZiB0YWdzXHJcblxyXG4gICAgICAgIC8vIHByb2Nlc3MgdGFncyB0aGF0IGRvbid0IGhhdmUgdGhlaXIgY29udGVudCBwYXJzZWRcclxuICAgICAgICB3aGlsZSAoIGNvbmZpZy50ZXh0ICE9PSAoY29uZmlnLnRleHQgPSBjb25maWcudGV4dC5yZXBsYWNlKHBiYlJlZ0V4cDIsIGZ1bmN0aW9uKG1hdGNoU3RyLCB0YWdOYW1lLCB0YWdQYXJhbXMsIHRhZ0NvbnRlbnRzKSB7XHJcbiAgICAgICAgICAgIHRhZ0NvbnRlbnRzID0gdGFnQ29udGVudHMucmVwbGFjZSgvXFxbL2csIFwiJiM5MTtcIik7XHJcbiAgICAgICAgICAgIHRhZ0NvbnRlbnRzID0gdGFnQ29udGVudHMucmVwbGFjZSgvXFxdL2csIFwiJiM5MztcIik7XHJcbiAgICAgICAgICAgIHRhZ1BhcmFtcyA9IHRhZ1BhcmFtcyB8fCBcIlwiO1xyXG4gICAgICAgICAgICB0YWdDb250ZW50cyA9IHRhZ0NvbnRlbnRzIHx8IFwiXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBcIltcIiArIHRhZ05hbWUgKyB0YWdQYXJhbXMgKyBcIl1cIiArIHRhZ0NvbnRlbnRzICsgXCJbL1wiICsgdGFnTmFtZSArIFwiXVwiO1xyXG4gICAgICAgIH0pKSApO1xyXG5cclxuICAgICAgICBjb25maWcudGV4dCA9IGZpeFN0YXJUYWcoY29uZmlnLnRleHQpOyAvLyBhZGQgaW4gY2xvc2luZyB0YWdzIGZvciB0aGUgWypdIHRhZ1xyXG4gICAgICAgIGNvbmZpZy50ZXh0ID0gYWRkQmJjb2RlTGV2ZWxzKGNvbmZpZy50ZXh0KTsgLy8gYWRkIGluIGxldmVsIG1ldGFkYXRhXHJcblxyXG4gICAgICAgIGVyclF1ZXVlID0gY2hlY2tQYXJlbnRDaGlsZFJlc3RyaWN0aW9ucyhcImJiY29kZVwiLCBjb25maWcudGV4dCwgLTEsIFwiXCIsIFwiXCIsIGNvbmZpZy50ZXh0KTtcclxuICAgICAgICBcclxuICAgICAgICByZXQuaHRtbCA9IHBhcnNlKGNvbmZpZyk7XHJcblxyXG4gICAgICAgIGlmICggcmV0Lmh0bWwuaW5kZXhPZihcIltcIikgIT09IC0xIHx8IHJldC5odG1sLmluZGV4T2YoXCJdXCIpICE9PSAtMSkge1xyXG4gICAgICAgICAgICBlcnJRdWV1ZS5wdXNoKFwiU29tZSB0YWdzIGFwcGVhciB0byBiZSBtaXNhbGlnbmVkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBpZiAoY29uZmlnLnJlbW92ZU1pc2FsaWduZWRUYWdzKSB7XHJcbiAgICAgICAgICAgIHJldC5odG1sID0gcmV0Lmh0bWwucmVwbGFjZSgvXFxbLio/XFxdL2csXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb25maWcuYWRkSW5MaW5lQnJlYWtzKSB7XHJcbiAgICAgICAgICAgIHJldC5odG1sID0gcmV0Lmh0bWwucmVwbGFjZSgvXFxyXFxuL2csIFwiXFxuXCIpO1xyXG4gICAgICAgICAgICByZXQuaHRtbCA9IHJldC5odG1sLnJlcGxhY2UoLyhcXHJ8XFxuKS9nLCBcIiQxPGJyLz5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgcmV0Lmh0bWwgPSByZXQuaHRtbC5yZXBsYWNlKFwiJiM5MTtcIiwgXCJbXCIpOyAvLyBwdXQgWydzIGJhY2sgaW5cclxuICAgICAgICByZXQuaHRtbCA9IHJldC5odG1sLnJlcGxhY2UoXCImIzkzO1wiLCBcIl1cIik7IC8vIHB1dCBbJ3MgYmFjayBpblxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldC5lcnJvciA9IChlcnJRdWV1ZS5sZW5ndGggPT09IDApID8gZmFsc2UgOiB0cnVlO1xyXG4gICAgICAgIHJldC5lcnJvclF1ZXVlID0gZXJyUXVldWU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIG1lO1xyXG59KSgpOyIsIi8qXG4gICAgYm9yb246IHNvbWUgdXRpbGl0aWVzIGZvciBpbW11dGFiaWxpdHlcbiovXG5cblxuQm9yb24gPSB7fVxuXG5Cb3Jvbi5wZXJzaXN0ZW50X21lcmdlID0gZnVuY3Rpb24ocHJvcHMsIGRhdGEpIHtcbiAgICAvLy8gbWVyZ2VzIGEgJ2ZsYXR0ZW5lZCcgZGF0YSBhcnJheSBpbnRvIHByb3BzIGluIGEgcGVyc2lzdGVudCBmYXNoaW9uXG4gICAgLy8vIHRoZSBuZXcgb2JqZWN0IHJldXNlcyBvbGQgZGF0YSB3aGVyZSBwb3NzaWJsZSwgc28gcmVxdWlyZXMgfmxvZyBOIGFkZGl0aW9uYWwgc3BhY2VcbiAgICBcbiAgICAvLy8gZ2l2ZW4gcHJvcHMge2Z1bjoge3lheToxMjMsIG9rOjEyM30sIGNhdDp7ZG9nOjEyM319ICAgIFxuICAgIC8vLyAgIGFuZCAgZGF0YSB7J2Z1bi55YXknOjAsICdjYXQuYW50LmJlYXInOjB9fSAgICAgICAgICBcbiAgICAvLy8gICAgIHJldHVybnMge2Z1bjoge3lheTowLCBvazoxMjN9LCBjYXQ6e2FudDp7YmVhcjowfX19XG4gICAgXG4gICAgZGF0YSA9IGRhdGEgfHwgW11cbiAgICBcbiAgICBpZihBcnJheS5pc0FycmF5KGRhdGEpIHx8IEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgLy8gVEhJTks6IHdoYXQgZG8gd2UgZG8gd2l0aCBhcnJheXM/XG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkoZGF0YSkgIT09IEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgICAgICAgICAvLyBUSElOSzogaG93IHRvIGRlYWwgd2l0aCBhcnJheSAvIG9iamVjdCBtaXNtYXRjaD9cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBUSElOSzogd2hhdCBhYm91dCB3aGVuIGRhdGEgaXMge2NhdDp7J2FudC5iZWFyJzowfX0gP1xuICAgIFxuICAgIHJldHVybiBPYmplY3Qua2V5cyhkYXRhKS5yZWR1Y2UoZnVuY3Rpb24ocHJvcHMsIGtleSkgeyAgICAgICAgICAgICAgLy8gT1BUOiBjb21iaW5lIHRoZXNlIGluc3RlYWQgb2YgZG9pbmcgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHJldHVybiBCb3Jvbi5zZXRfZGVlcF92YWx1ZShwcm9wcywga2V5LCBkYXRhW2tleV0pXG4gICAgfSwgcHJvcHMpXG59XG5cbkJvcm9uLnNldF9kZWVwX3ZhbHVlID0gZnVuY3Rpb24ocHJvcHMsIHBhdGgsIHZhbHVlKSB7XG4gICAgLy8vIHNldCBhIHZhbHVlIGZyb20gYSBmbGF0dGVuZWQgcGF0aFxuICAgIFxuICAgIC8vLyBnaXZlbiBwcm9wcyB7ZnVuOiB7eWF5OjEyMywgb2s6MTIzfSwgY2F0Ontkb2c6MTIzfX1cbiAgICAvLy8gICBhbmQgIHBhdGggJ2Z1bi5vaycgXG4gICAgLy8vICAgYW5kIHZhbHVlIDQ1NlxuICAgIC8vLyAgICAgcmV0dXJucyB7ZnVuOiB7eWF5OjEyMywgb2s6NDU2fSwgY2F0Ontkb2c6MTIzfX1cbiAgICBcbiAgICAvLyB2YXIgc2VncyA9IHBhdGguc3BsaXQoJy4nKVxuICAgIC8vIFRISU5LOiB0aGlzIGlzIHZhZ3VlbHkgYXdmdWwsIGJ1dCB3aXRob3V0IGxvb2tiZWhpbmQgaXQncyBoYXJkIHRvIHNheSBcIm9ubHkgc3BsaXQgb24gZG90cyB0aGF0IGFyZW4ndCBzbGFzaGVkXCJcbiAgICAvLyB2YXIgc2VncyA9IHBhdGguc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKVxuICAgIC8vICAgICAgICAgICAgICAgIC5zcGxpdCgvXFwuKD8hXFxcXCkvKS5yZXZlcnNlKClcbiAgICAvLyAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGNodW5rKSB7cmV0dXJuIGNodW5rLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyl9KVxuICAgIC8vICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oY2h1bmspIHtyZXR1cm4gY2h1bmsucmVwbGFjZSgvW1xcXFxdJC8sICcnKX0pXG4gICAgXG4gICAgLy8gVEhJTks6IHRoaXMgaXMgdmFndWVseSBhd2Z1bGxlciwgYnV0IHdvcmtzIGFuZCBpcyBmYWlybHkgZmFzdCBhbmQgcmVhZGFibGUuIFxuICAgIHZhciBtYWdpYyA9IFwiX19fTUFHSUNfX19cIlxuICAgIHZhciBtYWdpY19yZWdleCA9IG5ldyBSZWdFeHAobWFnaWMsICdnJyk7XG4gICAgdmFyIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcXFxcXC4vZywgbWFnaWMpXG4gICAgdmFyIHNlZ3MgPSBwYXRoLnNwbGl0KCcuJykubWFwKGZ1bmN0aW9uKGNodW5rKSB7cmV0dXJuIGNodW5rLnJlcGxhY2UobWFnaWNfcmVnZXgsICcuJyl9KVxuICAgIFxuICAgIHZhciBsYXN0ID0gc2Vncy5wb3AoKVxuICAgIHZhciBuZXh0XG4gICAgdmFyIGZpbmFsID0gbmV4dCA9IEJvcm9uLnNoYWxsb3dfY29weShwcm9wcylcblxuICAgIHNlZ3MuZm9yRWFjaChmdW5jdGlvbihzZWcpIHtcbiAgICAgICAgbmV4dFtzZWddID0gQm9yb24uc2hhbGxvd19jb3B5KG5leHRbc2VnXSlcbiAgICAgICAgbmV4dCA9IG5leHRbc2VnXVxuICAgIH0pXG5cbiAgICBuZXh0W2xhc3RdID0gdmFsdWVcbiAgICByZXR1cm4gZmluYWxcbn1cblxuQm9yb24uc2hhbGxvd19jb3B5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYoQXJyYXkuaXNBcnJheShvYmopKSByZXR1cm4gb2JqLnNsaWNlKClcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqIHx8IHt9KS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBrZXkpIHthY2Nba2V5XSA9IG9ialtrZXldOyByZXR1cm4gYWNjfSwge30pXG59XG5cbkJvcm9uLnNoYWxsb3dfZGlmZiA9IGZ1bmN0aW9uKG9sZE9iaiwgbmV3T2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdHMgY29tZSBmcm9tIG5ld09ialxuICAgIHJldHVybiBPYmplY3Qua2V5cyhvbGRPYmopLnJlZHVjZShmdW5jdGlvbihhY2MsIGtleSkge1xuICAgICAgICBpZihKU09OLnN0cmluZ2lmeShvbGRPYmpba2V5XSkgIT0gSlNPTi5zdHJpbmdpZnkobmV3T2JqW2tleV0pKVxuICAgICAgICAgICAgYWNjW2tleV0gPSBuZXdPYmpba2V5XSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBwb2ludGVyIGNvcGllcyBkZWVwIGRhdGFcbiAgICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIG9sZE9iai5jb25zdHJ1Y3RvcigpKVxufVxuXG5Cb3Jvbi5kZWVwX2RpZmYgPSBmdW5jdGlvbihvbGRPYmosIG5ld09iaikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHRzIGNvbWUgZnJvbSBuZXdPYmpcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobmV3T2JqKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBrZXkpIHtcbiAgICAgICAgdmFyIG9sZHR5cGUgPSB0eXBlb2Ygb2xkT2JqW2tleV1cbiAgICAgICAgdmFyIG5ld3R5cGUgPSB0eXBlb2YgbmV3T2JqW2tleV1cbiAgICAgICAgXG4gICAgICAgIGlmKG9sZHR5cGUgIT0gbmV3dHlwZSkge1xuICAgICAgICAgICAgYWNjW2tleV0gPSBuZXdPYmpba2V5XSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBwb2ludGVyIGNvcGllcyBkZWVwIGRhdGFcbiAgICAgICAgICAgIHJldHVybiBhY2NcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYob2xkdHlwZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBCb3Jvbi5kZWVwX2RpZmYob2xkT2JqW2tleV0sIG5ld09ialtrZXldKVxuICAgICAgICAgICAgaWYoT2JqZWN0LmtleXMoZGlmZikubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGFjY1trZXldID0gZGlmZlxuICAgICAgICAgICAgcmV0dXJuIGFjY1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihvbGRPYmpba2V5XSAhPT0gbmV3T2JqW2tleV0pXG4gICAgICAgICAgICBhY2Nba2V5XSA9IG5ld09ialtrZXldXG4gICAgICAgIHJldHVybiBhY2NcbiAgICB9LCBuZXdPYmouY29uc3RydWN0b3IoKSlcbn1cblxuQm9yb24uZmxhdHRlbiA9IGZ1bmN0aW9uKG9iaiwgcHJlZml4KSB7XG4gICAgLy8vIGNvbnZlcnQge2Z1bjoge3lheTogMTIzfX0gaW50byB7J2Z1bi55YXknOiAxMjN9XG4gICAgXG4gICAgaWYoIUJvcm9uLnByb3Blcl9vYmplY3Qob2JqKSkgcmV0dXJuIHt9XG4gICAgXG4gICAgdmFyIG5ld29iaiA9IHt9XG4gICAgcHJlZml4ID0gcHJlZml4ID8gcHJlZml4ICsgJy4nIDogJydcbiAgICBcbiAgICBmb3IodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYoIUJvcm9uLnByb3Blcl9vYmplY3Qob2JqW2tleV0pKSB7XG4gICAgICAgICAgICBuZXdvYmpbcHJlZml4K2tleV0gPSBvYmpba2V5XVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3b2JqID0gQm9yb24uZXh0ZW5kKG5ld29iaiwgQm9yb24uZmxhdHRlbihvYmpba2V5XSwgcHJlZml4K2tleSkpIC8vIE9QVDogbG90c2EgR0MgaGVyZVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBuZXdvYmpcbn1cblxuQm9yb24udW5mbGF0dGVuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgLy8vIGNvbnZlcnQgeydmdW4ueWF5JzogMTIzfSBpbnRvIHtmdW46IHt5YXk6IDEyM319XG4gICAgXG4gICAgcmV0dXJuIEJvcm9uLnBlcnNpc3RlbnRfbWVyZ2Uoe30sIG9iaikgLy8gT1BUOiBHQ1xuICAgIC8vIHJldHVybiBPYmplY3Qua2V5cyhvYmp8fHt9KS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBrZXkpIHtyZXR1cm4gQm9yb24uc2V0X2RlZXBfdmFsdWUoYWNjLCBrZXksIG9ialtrZXldKX0sIHt9KSAvLyBPUFQ6IEdDXG59XG5cbkJvcm9uLnByb3Blcl9vYmplY3QgPSBmdW5jdGlvbihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmogPT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob2JqKSAmJiAhIW9ian0gXG5cbkJvcm9uLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vLyBnaXZlbiAoe2Z1bjoxMjMsIHlheToxMjN9LCB7eWF5OjQ1Niwgb2s6Nzg5fSkgYXMgYXJncywgcmV0dXJucyBhIG5ldyBvYmplY3Qge2Z1bjoxMjMsIHlheTo0NTYsIG9rOjc4OX1cbiAgICBcbiAgICB2YXIgbmV3b2JqID0ge31cbiAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmZvckVhY2goZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIGZvcih2YXIgcHJvcCBpbiBhcmcpIHtcbiAgICAgICAgICAgIG5ld29ialtwcm9wXSA9IGFyZ1twcm9wXSB9IH0pXG4gICAgcmV0dXJuIG5ld29ialxufVxuXG5cbkJvcm9uLm1lbW9pemUgPSBmdW5jdGlvbihmKSB7XG4gICAgdmFyIHRhYmxlID0ge31cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgICB2YXIga2V5ID0gYXJncy50b1N0cmluZygpXG4gICAgICAgIHJldHVybiB0YWJsZVtrZXldID8gdGFibGVba2V5XSA6ICh0YWJsZVtrZXldID0gZi5hcHBseShudWxsLCBhcmdzKSlcbiAgICB9IFxufVxuIiwiRmlsZUZpbGUgPSB7fVxuXG5GaWxlRmlsZS5vbGRGaWxlID0gbnVsbFxuXG5GaWxlRmlsZS5wcmVwQmxvYiA9IGZ1bmN0aW9uKHN0ciwgdHlwZSkge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9ICdzdHJpbmcnKVxuICAgICAgICBzdHIgPSBKU09OLnN0cmluZ2lmeShzdHIpXG5cbiAgICB2YXIgYmxvYlxuXG4gICAgaWYgKHR5cGUgPT0gJ2ZpbGUnKVxuICAgICAgICBibG9iID0gRmlsZUZpbGUuZGF0YVVSSXRvQmxvYihzdHIpXG4gICAgZWxzZVxuICAgICAgICBibG9iID0gbmV3IEJsb2IoW3N0cl0sIHt0eXBlOiAndGV4dC9wbGFpbid9KVxuXG4gICAgaWYgKG5hdmlnYXRvci5hcHBWZXJzaW9uLnRvU3RyaW5nKCkuaW5kZXhPZignLk5FVCcpID4gMCkgICAgICAgICAgICAvLyBJRSBuZWVkcyB0byBkaXJlY3RseSBzYXZlIHRoZSBibG9iIG9iamVjdFxuICAgICAgICByZXR1cm4gYmxvYlxuXG4gICAgaWYoRmlsZUZpbGUub2xkRmlsZSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmV2ZW50cyBvbGQgYmxvYnMgZnJvbSBjYXVzaW5nIG1lbSBsZWFrc1xuICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKEZpbGVGaWxlLm9sZEZpbGUpXG5cbiAgICBGaWxlRmlsZS5vbGRGaWxlID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcblxuICAgIHJldHVybiBGaWxlRmlsZS5vbGRGaWxlXG59XG5cbkZpbGVGaWxlLm9wZW5QdWZmRmlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHsgICAgICAgICAgICAgICAgXG4gICAgcmV0dXJuIEZpbGVGaWxlLmhhbmRsZUZpbGVPcGVuKGVsZW1lbnQpXG59XG5cbkZpbGVGaWxlLm9wZW5UZXh0RmlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHsgICAgICAgICAgICAgICAgXG4gICAgcmV0dXJuIEZpbGVGaWxlLmhhbmRsZUZpbGVPcGVuKGVsZW1lbnQpXG59XG5cbkZpbGVGaWxlLm9wZW5CaW5hcnlGaWxlID0gZnVuY3Rpb24oZWxlbWVudCkgeyAgICAgICAgICAgICAgICBcbiAgICByZXR1cm4gRmlsZUZpbGUuaGFuZGxlRmlsZU9wZW4oZWxlbWVudCwgJ2FzRGF0YVVSSScpXG59XG5cbkZpbGVGaWxlLmhhbmRsZUZpbGVPcGVuID0gZnVuY3Rpb24oZWxlbWVudCwgYXNEYXRhVVJJKSB7ICAgICAgICAgICAgICAgIFxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcblxuICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHJlYWRlcilcbiAgICAgICAgICAgIHZhciBkYXRhVVJJQ29udGVudCA9IGV2ZW50LnRhcmdldC5yZXN1bHRcbiAgICAgICAgICAgIC8vIHZhciBibG9iID0gRmlsZUZpbGUuZGF0YVVSSXRvQmxvYihkYXRhVVJJQ29udGVudClcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YVVSSUNvbnRlbnQpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKCFlbGVtZW50LmZpbGVzWzBdKSAvLyBUSElOSzogaXMgZmFsc2UgdGhlIHJpZ2h0IHJlc3BvbnNlP1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgnTm8gZmlsZSBzZWxlY3RlZCcpXG4gICAgICAgICAgICBcbiAgICAgICAgaWYoYXNEYXRhVVJJKVxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZWxlbWVudC5maWxlc1swXSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZWxlbWVudC5maWxlc1swXSlcbiAgICB9KVxufVxuXG5GaWxlRmlsZS5kYXRhVVJJdG9CbG9iID0gZnVuY3Rpb24oZGF0YVVSSSkge1xuICAgIC8vIGNvbnZlcnQgYmFzZTY0L1VSTEVuY29kZWQgZGF0YSBjb21wb25lbnQgdG8gcmF3IGJpbmFyeSBkYXRhIGhlbGQgaW4gYSBCbG9iXG4gICAgLy8gdmlhIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk5ODkwOC9jb252ZXJ0LWRhdGEtdXJpLXRvLWZpbGUtdGhlbi1hcHBlbmQtdG8tZm9ybWRhdGFcbiAgICB2YXIgYnl0ZVN0cmluZ1xuICAgIFxuICAgIGlmIChkYXRhVVJJLnNwbGl0KCcsJylbMF0uaW5kZXhPZignYmFzZTY0JykgPj0gMClcbiAgICAgICAgYnl0ZVN0cmluZyA9IGF0b2IoZGF0YVVSSS5zcGxpdCgnLCcpWzFdKVxuICAgIGVsc2VcbiAgICAgICAgYnl0ZVN0cmluZyA9IHVuZXNjYXBlKGRhdGFVUkkuc3BsaXQoJywnKVsxXSlcblxuICAgIC8vIHNlcGFyYXRlIG91dCB0aGUgbWltZSBjb21wb25lbnRcbiAgICB2YXIgbWltZVN0cmluZyA9IGRhdGFVUkkuc3BsaXQoJywnKVswXS5zcGxpdCgnOicpWzFdLnNwbGl0KCc7JylbMF1cblxuICAgIC8vIHdyaXRlIHRoZSBieXRlcyBvZiB0aGUgc3RyaW5nIHRvIGEgdHlwZWQgYXJyYXlcbiAgICB2YXIgaWEgPSBuZXcgVWludDhBcnJheShieXRlU3RyaW5nLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWFbaV0gPSBieXRlU3RyaW5nLmNoYXJDb2RlQXQoaSlcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJsb2IoW2lhXSwge3R5cGU6bWltZVN0cmluZ30pXG59XG4iLCIvKlxuICAgIGV2ZW50czogYSBwdWIvc3ViIHN5c3RlbSB3aXRoIHdpbGRjYXJkIHBhdGhzXG4qL1xuXG5cbkV2ZW50cyA9IHt9XG5FdmVudHMuc3VicyA9IHt9XG5cbkV2ZW50cy5wdWIgPSBmdW5jdGlvbihwYXRoLCBkYXRhKSB7XG4gICAgcmV0dXJuIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtFdmVudHMuc3RhcnRfcHViKHBhdGgsIGRhdGEpfSkgICAgICAgICAgICAgIC8vIGRvIGl0IG5leHQgdGlja1xufVxuXG5FdmVudHMuc3ViID0gZnVuY3Rpb24ocGF0aCwgaGFuZGxlcikge1xuICAgIHBhdGggPSBFdmVudHMuc2NydWJfcGF0aChwYXRoKS5qb2luKCcvJylcbiAgICBpZighRXZlbnRzLnN1YnNbcGF0aF0pIEV2ZW50cy5zdWJzW3BhdGhdID0gW11cbiAgICBFdmVudHMuc3Vic1twYXRoXS5wdXNoKGhhbmRsZXIpXG59XG5cbkV2ZW50cy51bnN1YiA9IGZ1bmN0aW9uKHBhdGgsIGhhbmRsZXIpIHtcbiAgICBwYXRoID0gRXZlbnRzLnNjcnViX3BhdGgocGF0aCkuam9pbignLycpXG5cbiAgICB2YXIgc3VicyA9IEV2ZW50cy5zdWJzW3BhdGhdXG4gICAgaWYoIXN1YnMpIHJldHVybiBmYWxzZVxuXG4gICAgdmFyIGluZGV4ID0gc3Vicy5pbmRleE9mKGhhbmRsZXIpXG4gICAgaWYoaW5kZXggPT0gLTEpIHJldHVybiBmYWxzZVxuXG4gICAgc3Vicy5zcGxpY2UoaW5kZXgsIDEpXG59XG5cbkV2ZW50cy5zdGFydF9wdWIgPSBmdW5jdGlvbihwYXRoLCBkYXRhKSB7XG4gICAgLy8vLyBwdWIgdG8gKiBhdCBlYWNoIGxldmVsIGFuZCB0aGVuIHRvIHBhdGggaXRzZWxmXG4gICAgdmFyIHBhdGhsaXN0ID0gRXZlbnRzLnNjcnViX3BhdGgocGF0aClcbiAgICB2YXIgcmVhbHBhdGggPSBwYXRobGlzdC5qb2luKCcvJylcblxuICAgIEV2ZW50cy50cnlfcHViKCcqJywgZGF0YSwgcmVhbHBhdGgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnbG9iYWwgY2F0Y2hhbGxcblxuICAgIHBhdGhsaXN0LnJlZHVjZShmdW5jdGlvbihhY2MsIHNlZykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFubmVsIGNhdGNoYWxsc1xuICAgICAgICB2YXIgbmV3YWNjID0gYWNjICsgc2VnICsgJy8nXG4gICAgICAgIEV2ZW50cy50cnlfcHViKG5ld2FjYyArICcqJywgZGF0YSwgcmVhbHBhdGgpXG4gICAgICAgIHJldHVybiBuZXdhY2NcbiAgICB9LCAnJylcblxuICAgIEV2ZW50cy50cnlfcHViKHJlYWxwYXRoLCBkYXRhLCByZWFscGF0aCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhY3R1YWwgY2hhbm5lbFxufVxuXG5FdmVudHMudHJ5X3B1YiA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIHJlYWxwYXRoKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gRXZlbnRzLnN1YnNbcGF0aF1cbiAgICBpZighaGFuZGxlcnMgfHwgIWhhbmRsZXJzLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG4gICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7aGFuZGxlcihkYXRhLCByZWFscGF0aCl9KVxuICAgIC8vIFRISU5LOiB1c2Ugc2V0SW1tZWRpYXRlIGhlcmU/XG59XG5cblxuRXZlbnRzLnNjcnViX3BhdGggPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXlteXFx3Ki1dKy8sICcnKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmltIGxlYWRpbmcgc2xhc2hlcyBldGNcbiAgICAgICAgLnJlcGxhY2UoL1teXFx3Ki1dKyQvLCAnJykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyaW0gdHJhaWxpbmcgZ3Vua1xuICAgICAgICAuc3BsaXQoJy8nKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBicmVhayBvdXQgdGhlIHBhdGggc2VnbWVudHNcbiAgICAgICAgLm1hcChmdW5jdGlvbihpdGVtKSB7cmV0dXJuIGl0ZW0ucmVwbGFjZSgvW15cXHcqLV0vZywgJycpfSkgICAgICAgICAgICAgIC8vIHNjcnViIGVhY2ggc2VnbWVudFxufVxuXG5cbi8vIG1heWJlIGxhdGVyXG4vLyBldmVudGxvZyA9IFtdXG4vLyBFdmVudHMuc3ViKCcqJywgZnVuY3Rpb24oZGF0YSwgcGF0aCkge1xuLy8gICAgIGV2ZW50bG9nLnB1c2goW3BhdGgsIGRhdGFdKVxuLy8gfSlcblxuIiwiLypcbiAgICBncmlkYm94OiBhIHNpbXBsZSBzeXN0ZW0gZm9yIHB1dHRpbmcgdGhpbmdzIGluIHBsYWNlc1xuKi9cblxuR3JpZGJveCA9IHt9XG5cbkdyaWRib3guZ2V0R3JpZENvb3JkQm94ID0gZnVuY3Rpb24ocm93cywgY29scywgb3V0ZXJ3aWR0aCwgb3V0ZXJoZWlnaHQsIHZlcnRpY2FsUGFkZGluZykge1xuICAgIHZhciBtaW4gPSBmdW5jdGlvbihhLCBiKSB7cmV0dXJuIE1hdGgubWluKGEsIGIpfVxuICAgIHZhciBtYXggPSBmdW5jdGlvbihhLCBiKSB7cmV0dXJuIE1hdGgubWF4KGEsIGIpfVxuICAgIHZhciBncmlkd2lkdGggID0gb3V0ZXJ3aWR0aCAgLyBjb2xzXG4gICAgdmFyIGdyaWRoZWlnaHQgPSBvdXRlcmhlaWdodCAvIHJvd3NcbiAgICB2YXIgZXEgPSBmdW5jdGlvbihhLCBiKSB7cmV0dXJuIGEgPT0gYn1cbiAgICB2YXIgZ3JpZCA9IEFycmF5LmFwcGx5KDAsIEFycmF5KHJvd3MpKVxuICAgICAgICAubWFwKGZ1bmN0aW9uKCkge3JldHVybiBBcnJheS5hcHBseSgwLCBBcnJheShjb2xzKSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oKSB7cmV0dXJuIDB9KX0pIC8vIGJ1aWxkIDJEIGFycmF5XG5cbiAgICByZXR1cm4geyBnZXQ6IGZ1bmN0aW9uKCkge3JldHVybiBncmlkfVxuICAgICAgICAsIHNldF9lcTogZnVuY3Rpb24obmV3X2VxKSB7ZXEgPSBuZXdfZXF9XG4gICAgICAgICwgYWRkOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBtaW55LCBtaW54LCBtYXh5LCBtYXh4LCBwb2ludGVyKSB7XG4gICAgICAgICAgICBtYXh5ID0gbWluKG1heHl8fHJvd3MtaGVpZ2h0LCByb3dzLWhlaWdodCksIG1heHggPSBtaW4obWF4eHx8Y29scy13aWR0aCwgY29scy13aWR0aClcbiAgICAgICAgICAgIG1pbnkgPSBtaW4obWlueXx8MCwgbWF4eSksIG1pbnggPSBtaW4obWlueHx8MCwgbWF4eClcbiAgICAgICAgICAgIGlmKG1heHg8MCB8fCBtYXh5PDApIHJldHVybiBQQi5vbkVycm9yKCdCbG9jayBpcyB0b28gYmlnIGZvciB0aGUgZ3JpZCcpXG5cbiAgICAgICAgICAgIHRvcDogZm9yKHZhciB5ID0gbWlueTsgeSA8PSBtYXh5OyB5KyspIHtcbiAgICAgICAgICAgICAgICBib3Q6IGZvcih2YXIgeCA9IG1pbng7IHggPD0gbWF4eDsgIHgrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGR5ID0gMDsgZHkgPCBoZWlnaHQ7IGR5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgZHggPSAwOyBkeCA8IHdpZHRoOyBkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZ3JpZFt5K2R5XVt4K2R4XSkgY29udGludWUgYm90IH19XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcCB9fVxuICAgICAgICAgICAgaWYoeCA9PSBtYXh4KzEgJiYgeSA9PSBtYXh5KzEpIHJldHVybiBQQi5vbkVycm9yKCdObyByb29tIGluIHRoZSBncmlkJylcbiAgICAgICAgICAgIGlmKHggPT0gbnVsbCB8fCB5ID09IG51bGwpIHJldHVybiBQQi5vbkVycm9yKCdCbG9jayB0b28gYmlnIGZvciB0aGUgZ3JpZCcpXG4gICAgICAgICAgICBmb3IodmFyIGR5ID0gMDsgZHkgPCBoZWlnaHQ7IGR5KyspIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGR4ID0gMDsgZHggPCB3aWR0aDsgZHgrKykge1xuICAgICAgICAgICAgICAgICAgICBncmlkW3krZHldW3grZHhdID0gcG9pbnRlciB8fCAxIH0gfVxuICAgICAgICAgICAgcmV0dXJuIHt3aWR0aDogd2lkdGgqZ3JpZHdpZHRoLCBoZWlnaHQ6IGhlaWdodCpncmlkaGVpZ2h0LCB4OiB4KmdyaWR3aWR0aCwgeTogeSpncmlkaGVpZ2h0Kyh2ZXJ0aWNhbFBhZGRpbmcvMS41KX0gLy8gVEhJTks6IGdlbmVyYWxpemUgdmVydGljYWxQYWRkaW5nIFxuICAgICAgICB9XG4gICAgfVxufVxuXG5HcmlkYm94LmZpbmROZWlnaGJvciA9IGZ1bmN0aW9uKGdyaWQsIHBvaW50ZXIsIGRpcikge1xuICAgIHZhciBib3hDb29yZHMgPSBHcmlkYm94LmZpbmRCb3hJbkdyaWQoZ3JpZCwgcG9pbnRlcilcbiAgICBpZighYm94Q29vcmRzKSByZXR1cm4gZmFsc2VcblxuICAgIC8vIFRPRE86IG5lZWQgdG8gaW5kaWNhdGUgaWYgZGlyQm94IGlzIG91dHNpZGUgb2YgZ3JpZCwgdmVyc3VzIHBvaW50ZXIgbm90IGZvdW5kXG5cbiAgICB2YXIgZGlyQm94ID0gR3JpZGJveC5tYWtlRGlyQm94KGJveENvb3JkcywgZGlyKVxuICAgIGlmKCFkaXJCb3gpIHJldHVybiBmYWxzZVxuXG4gICAgcmV0dXJuIEdyaWRib3guZmlyc3RUaGluZ0luQm94KGdyaWQsIGRpckJveFswXSwgZGlyQm94WzFdKVxufVxuXG5HcmlkYm94LmZpbmRCb3hJbkdyaWQgPSBmdW5jdGlvbihncmlkLCB0YXJnZXQsIGVxKSB7XG4gICAgLy8vIGZpbmQgc29tZXRoaW5nIGluIGEgZ3JpZCBib3ggYW5kIHJldHVybiBjb29yZHNcbiAgICAvLy8gTk9URTogdGhpcyBhc3N1bWVzIHJlY3RpbGluZWFyIHNoYXBlc1xuICAgIGVxID0gZXEgfHwgZnVuY3Rpb24oYSwgYikge3JldHVybiBhID09PSBifVxuICAgIGVxID0gZnVuY3Rpb24oYSwgYikge3JldHVybiBhLnNpZyA9PT0gYi5zaWd9IC8vIFRPRE86IGVuY2Fwc3VsYXRlIGVxIGluIGdyaWRCb3ggLy8gT1BUOiBkb24ndCBsb29rIGluc2lkZVxuXG4gICAgdG9wOiBmb3IodmFyIHkgPSAwLCBseSA9IGdyaWQubGVuZ3RoOyB5IDwgbHk7IHkrKylcbiAgICAgICAgZm9yKHZhciB4ID0gMCwgbHggPSBncmlkW3ldLmxlbmd0aDsgeCA8IGx4OyB4KyspXG4gICAgICAgICAgICBpZihlcShncmlkW3ldW3hdLCB0YXJnZXQpKSBicmVhayB0b3AgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHRvcCBhbmQgbGVmdCBjb29yZHNcblxuICAgIGlmKHkgPT0gZ3JpZC5sZW5ndGggJiYgeCA9PSBncmlkWzBdLmxlbmd0aCkgcmV0dXJuIGZhbHNlICAgICAgICAgICAgLy8gdGFyZ2V0IG5vdCBpbiBib3hcblxuICAgIGZvcih2YXIgZHkgPSAwLCBseSA9IGdyaWQubGVuZ3RoLXk7IGR5IDwgbHk7IGR5KyspXG4gICAgICAgIGlmKCFlcShncmlkW3krZHldW3hdLCB0YXJnZXQpKSBicmVhayAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIGJvdHRvbSBjb29yZFxuXG4gICAgZm9yKHZhciBkeCA9IDAsIGx4ID0gZ3JpZFt5XS5sZW5ndGgteDsgZHggPCBseDsgZHgrKylcbiAgICAgICAgaWYoIWVxKGdyaWRbeV1beCtkeF0sIHRhcmdldCkpIGJyZWFrICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgcmlnaHQgY29vcmRcblxuICAgIHJldHVybiBbW3gsIHldLCBbeCtkeC0xLCB5K2R5LTFdXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWludXMgb25lIGJlY2F1c2UgZGVsdGFzIGFsd2F5cyBvdmVyc2hvb3Rcbn1cblxuR3JpZGJveC5maXJzdFRoaW5nSW5Cb3ggPSBmdW5jdGlvbihncmlkLCB0b3BsZWZ0LCBib3RyaWdodCkge1xuICAgIGZvcih2YXIgeSA9IE1hdGgubWF4KHRvcGxlZnRbMV0sIDApLCBseSA9IE1hdGgubWluKGJvdHJpZ2h0WzFdLCBncmlkLmxlbmd0aC0xKTsgeSA8PSBseTsgeSsrKVxuICAgICAgICBmb3IodmFyIHggPSBNYXRoLm1heCh0b3BsZWZ0WzBdLCAwKSwgbHggPSBNYXRoLm1pbihib3RyaWdodFswXSwgZ3JpZFswXS5sZW5ndGgtMSk7IHggPD0gbHg7IHgrKylcbiAgICAgICAgICAgIGlmKGdyaWRbeV1beF0pIHJldHVybiBncmlkW3ldW3hdICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGx0ZXEgYmVjYXVzZSBvdXIgYm94ZXMgYXJlIGluY2x1c2l2ZTtcbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvdW5kYXJpZXMgYXJlIGJ1aWx0IGluLlxuXG5HcmlkYm94Lm1ha2VEaXJCb3ggPSBmdW5jdGlvbihib3hDb29yZHMsIGRpcikge1xuICAgIHZhciB0b3AgICA9IGJveENvb3Jkc1swXVsxXVxuICAgIHZhciBsZWZ0ICA9IGJveENvb3Jkc1swXVswXVxuICAgIHZhciBib3QgICA9IGJveENvb3Jkc1sxXVsxXVxuICAgIHZhciByaWdodCA9IGJveENvb3Jkc1sxXVswXVxuXG4gICAgaWYoZGlyID09ICd1cCcpICAgIHJldHVybiBbW2xlZnQsIHRvcC0xXSwgIFtyaWdodCwgdG9wLTFdXVxuICAgIGlmKGRpciA9PSAnZG93bicpICByZXR1cm4gW1tsZWZ0LCBib3QrMV0sICBbcmlnaHQsIGJvdCsxXV1cbiAgICBpZihkaXIgPT0gJ2xlZnQnKSAgcmV0dXJuIFtbbGVmdC0xLCB0b3BdLCAgW2xlZnQtMSwgYm90XV1cbiAgICBpZihkaXIgPT0gJ3JpZ2h0JykgcmV0dXJuIFtbcmlnaHQrMSwgdG9wXSwgW3JpZ2h0KzEsIGJvdF1dXG59XG4iLCIvKlxuICAgICBfX19fICBfX19fXyBfX19fXyBfX19fXyBfX19fXyBfX19fXyBcbiAgICB8ICAgIFxcfCAgXyAgfCAgIF9ffCAgICAgfCBfXyAgfCAgXyAgfFxuICAgIHwgIHwgIHwgICAgIHwgIHwgIHwgIHwgIHwgX18gLXwgICAgIHxcbiAgICB8X19fXy98X198X198X19fX198X19fX198X19fX198X198X198XG4gICAgXG4gICAgZGFnb2JhOiBhIHRpbnkgaW4tbWVtb3J5IGdyYXBoIGRhdGFiYXNlXG5cbiAgICBleDogXG4gICAgViA9IFsge25hbWU6ICdhbGljZSd9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGljZSBnZXRzIGF1dG8tX2lkIChwcm9sbHkgMSlcbiAgICAgICAgLCB7X2lkOiAxMCwgbmFtZTogJ2JvYicsIGhvYmJpZXM6IFsnYXNkZicsIHt4OjN9XX1dIFxuICAgIEUgPSBbIHtfb3V0OiAxLCBfaW46IDEwLCBfbGFiZWw6ICdrbm93cyd9IF1cbiAgICBnID0gRGFnb2JhLmdyYXBoKFYsIEUpXG4gICAgXG4gICAgZy5hZGRWZXJ0ZXgoe25hbWU6ICdjaGFybGllJywgX2lkOiAnY2hhcmxpZSd9KSAgICAgICAgICAgICAgICAvLyBzdHJpbmcgaWRzIGFyZSBmaW5lXG4gICAgZy5hZGRWZXJ0ZXgoe25hbWU6ICdkZWx0YScsIF9pZDogJzMwJ30pICAgICAgICAgICAgICAgICAgICAgICAvLyBhY3R1YWxseSB0aGV5J3JlIGFsbCBzdHJpbmdzXG5cbiAgICBnLmFkZEVkZ2Uoe19vdXQ6IDEwLCBfaW46IDMwLCBfbGFiZWw6ICdwYXJlbnQnfSlcbiAgICBnLmFkZEVkZ2Uoe19vdXQ6IDEwLCBfaW46ICdjaGFybGllJywgX2xhYmVsOiAna25vd3MnfSlcblxuICAgIGcudigxKS5vdXQoJ2tub3dzJykub3V0KCkucnVuKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBbY2hhcmxpZSwgZGVsdGFdXG4gICAgXG4gICAgcSA9IGcudigxKS5vdXQoJ2tub3dzJykub3V0KCkudGFrZSgxKVxuICAgIHEucnVuKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBbY2hhcmxpZV1cbiAgICBxLnJ1bigpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgW2RlbHRhXSAgICAoYnV0IGRvbid0IHJlbHkgb24gcmVzdWx0IG9yZGVyISlcbiAgICBxLnJ1bigpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgW11cbiovXG5cblxuRGFnb2JhID0ge30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5hbWVzcGFjZVxuXG5EYWdvYmEuRyA9IHt9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcHJvdG90eXBlXG5cbkRhZ29iYS5ncmFwaCA9IGZ1bmN0aW9uKFYsIEUpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmYWN0b3J5XG4gIHZhciBncmFwaCA9IE9iamVjdC5jcmVhdGUoIERhZ29iYS5HIClcbiAgZ3JhcGgudmVydGljZXMgPSBbXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyZXNoIGNvcGllcyBzbyB0aGV5J3JlIG5vdCBzaGFyZWRcbiAgZ3JhcGguZWRnZXMgPSBbXVxuICBncmFwaC52ZXJ0ZXhJbmRleCA9IHt9XG4gIGlmKFYgJiYgQXJyYXkuaXNBcnJheShWKSkgZ3JhcGguYWRkVmVydGljZXMoVikgICAgICAgICAgICAgICAgICAvLyBhcnJheXMgb25seSwgYmVjYXVzZSB5b3Ugd291bGRuJ3RcbiAgaWYoRSAmJiBBcnJheS5pc0FycmF5KEUpKSBncmFwaC5hZGRFZGdlcyhFKSAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgdGhpcyB3aXRoIHNpbmd1bGFyIFYgYW5kIEVcbiAgcmV0dXJuIGdyYXBoXG59XG5cbkRhZ29iYS5HLnYgPSBmdW5jdGlvbigpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgcXVlcnkgaW5pdGlhbGl6ZXI6IGcudigpIC0+IHF1ZXJ5XG4gIHZhciBxdWVyeSA9IERhZ29iYS5xdWVyeSh0aGlzKVxuICBxdWVyeS5hZGQoWyd2ZXJ0ZXgnXS5jb25jYXQoIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSApKVxuICByZXR1cm4gcXVlcnlcbn1cblxuRGFnb2JhLkcuYWRkVmVydGV4ID0gZnVuY3Rpb24odmVydGV4KSB7XG4gIGlmKCF2ZXJ0ZXguX2lkKSBcbiAgICB2ZXJ0ZXguX2lkID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgrMVxuICAvLyBUT0RPOiBlbnN1cmUgdW5pcXVlIF9pZFxuICB0aGlzLnZlcnRpY2VzLnB1c2godmVydGV4KSAvLyBUSElOSzogdGhlIHVzZXIgbWF5IHJldGFpbiBhIHBvaW50ZXIgdG8gdmVydGV4LCB3aGljaCB0aGV5IG1pZ2h0IG11dGF0ZSBsYXRlciA+LjxcbiAgLy8gY2FuIHRha2UgYXdheSB1c2VyJ3MgYWJpbGl0eSB0byBzZXQgX2lkIGFuZCBsb3NlIHRoZSBpbmRleCBjYWNoZSBoYXNoLCBiZWNhdXNlIGJ1aWxkaW5nIGl0IGNhdXNlcyBiaWcgcmViYWxhbmNpbmcgc2xvd2Rvd25zIGFuZCBydW5zIHRoZSBHQyBoYXJkLiAob3IgZG9lcyBpdD8pIFt0aGlzIHdhcyB3aXRoIGEgbWlsbGlvbiBpdGVtcywgaW5kZXhlZCBieSBjb25zZWN1dGl2ZSBpbnRzLiBnZW5lcmFsbHkgd2UgbmVlZCBzZXR0YWJsZSBfaWQgYmVjYXVzZSB3ZSBuZWVkIHRvIGdyYWIgdmVydGljZXMgcXVpY2tseSBieSBleHRlcm5hbCBrZXldXG4gIHRoaXMudmVydGV4SW5kZXhbdmVydGV4Ll9pZF0gPSB2ZXJ0ZXhcbiAgdmVydGV4Ll9vdXQgPSBbXTsgdmVydGV4Ll9pbiA9IFtdXG59XG5cbkRhZ29iYS5HLmFkZEVkZ2UgPSBmdW5jdGlvbihlZGdlKSB7XG4gIGlmKCFlZGdlLl9sYWJlbCkgcmV0dXJuIGZhbHNlXG4gIGVkZ2UuX2luICA9IHRoaXMuZmluZFZlcnRleEJ5SWQoZWRnZS5faW4pXG4gIGVkZ2UuX291dCA9IHRoaXMuZmluZFZlcnRleEJ5SWQoZWRnZS5fb3V0KVxuICBpZighKGVkZ2UuX2luICYmIGVkZ2UuX291dCkpIHJldHVybiBmYWxzZVxuICBlZGdlLl9vdXQuX291dC5wdXNoKGVkZ2UpXG4gIGVkZ2UuX2luLl9pbi5wdXNoKGVkZ2UpXG4gIHRoaXMuZWRnZXMucHVzaChlZGdlKVxufVxuXG5EYWdvYmEuRy5hZGRWZXJ0aWNlcyA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7IHZlcnRpY2VzLmZvckVhY2godGhpcy5hZGRWZXJ0ZXguYmluZCh0aGlzKSkgfVxuRGFnb2JhLkcuYWRkRWRnZXMgICAgPSBmdW5jdGlvbihlZGdlcykgICAgeyBlZGdlcyAgIC5mb3JFYWNoKHRoaXMuYWRkRWRnZSAgLmJpbmQodGhpcykpIH1cblxuRGFnb2JhLkcuZmluZFZlcnRleEJ5SWQgPSBmdW5jdGlvbih2ZXJ0ZXhfaWQpIHtcbiAgcmV0dXJuIHRoaXMudmVydGV4SW5kZXhbdmVydGV4X2lkXSB9XG5cbkRhZ29iYS5HLmZpbmRWZXJ0aWNlc0J5SWRzID0gZnVuY3Rpb24oaWRzKSB7XG4gIHJldHVybiBpZHMubGVuZ3RoID09IDEgPyBbXS5jb25jYXQoIHRoaXMuZmluZFZlcnRleEJ5SWQoaWRzWzBdKSB8fCBbXSApXG4gICAgICAgOiBpZHMubWFwKCB0aGlzLmZpbmRWZXJ0ZXhCeUlkLmJpbmQodGhpcykgKS5maWx0ZXIoQm9vbGVhbikgfVxuXG5EYWdvYmEuRy5maW5kVmVydGljZXMgPSBmdW5jdGlvbihpZHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBpZHNbMF0gPT0gJ29iamVjdCcgPyB0aGlzLnNlYXJjaFZlcnRpY2VzKGlkc1swXSlcbiAgICAgICA6IGlkcy5sZW5ndGggPT0gMCA/IHRoaXMudmVydGljZXMuc2xpY2UoKSAgICAgICAgICAgICAgICAgIC8vIE9QVDogZG8gd2UgbmVlZCB0aGUgc2xpY2U/XG4gICAgICAgOiB0aGlzLmZpbmRWZXJ0aWNlc0J5SWRzKGlkcykgfVxuXG5EYWdvYmEuRy5zZWFyY2hWZXJ0aWNlcyA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdGhpcy52ZXJ0aWNlcy5maWx0ZXIoXG4gICAgZnVuY3Rpb24odmVydGV4KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoXG4gICAgICAgIGZ1bmN0aW9uKGFjYywga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGFjYyAmJiBvYmpba2V5XSA9PSB2ZXJ0ZXhba2V5XSB9LCB0cnVlICkgfSApIH1cblxuRGFnb2JhLkcuZmluZEVkZ2VCeUlkID0gZnVuY3Rpb24oZWRnZV9pZCkge1xuICByZXR1cm4gRGFnb2JhLmZpbmQodGhpcy5lZGdlcywgZnVuY3Rpb24oZWRnZSkge3JldHVybiBlZGdlLl9pZCA9PSBlZGdlX2lkfSApIH1cblxuRGFnb2JhLkcuZmluZE91dEVkZ2VzID0gZnVuY3Rpb24odmVydGV4KSB7IHJldHVybiB2ZXJ0ZXguX291dDsgfVxuRGFnb2JhLkcuZmluZEluRWRnZXMgID0gZnVuY3Rpb24odmVydGV4KSB7IHJldHVybiB2ZXJ0ZXguX2luOyAgfVxuXG5EYWdvYmEuRy50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraWRzLCBkb24ndCBoYW5kIGNvZGUgSlNPTlxuICByZXR1cm4gJ3tcIlZcIjonICsgSlNPTi5zdHJpbmdpZnkodGhpcy52ZXJ0aWNlcywgRGFnb2JhLmNsZWFudmVydGV4KVxuICAgICAgICsgJyxcIkVcIjonICsgSlNPTi5zdHJpbmdpZnkodGhpcy5lZGdlcywgICAgRGFnb2JhLmNsZWFuZWRnZSkgXG4gICAgICAgKyAnfScgfVxuXG5EYWdvYmEuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbm90aGVyIGdyYXBoIGNvbnN0cnVjdG9yXG4gIHZhciBvYmogPSBKU09OLnBhcnNlKHN0cilcbiAgcmV0dXJuIERhZ29iYS5ncmFwaChvYmouViwgb2JqLkUpIFxufVxuXG5cblxuRGFnb2JhLlEgPSB7fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvdG90eXBlXG5cbkRhZ29iYS5xdWVyeSA9IGZ1bmN0aW9uKGdyYXBoKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhY3RvcnkgKG9ubHkgY2FsbGVkIGJ5IGEgZ3JhcGgncyBxdWVyeSBpbml0aWFsaXplcnMpXG4gIHZhciBxdWVyeSA9IE9iamVjdC5jcmVhdGUoIERhZ29iYS5RIClcbiAgXG4gIHF1ZXJ5LiAgIGdyYXBoID0gZ3JhcGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZ3JhcGggaXRzZWxmXG4gIHF1ZXJ5LiAgIHN0YXRlID0gW10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGF0ZSBmb3IgZWFjaCBzdGVwXG4gIHF1ZXJ5LiBwcm9ncmFtID0gW10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIHN0ZXBzIHRvIHRha2UgIFxuICBxdWVyeS5ncmVtbGlucyA9IFtdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ3JlbWxpbnMgZm9yIGVhY2ggc3RlcFxuICBcbiAgcmV0dXJuIHF1ZXJ5XG59XG5cbkRhZ29iYS5RLnJ1biA9IGZ1bmN0aW9uKCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtYWdpYyBsaXZlcyBoZXJlXG4gIFxuICB2YXIgZ3JhcGggPSB0aGlzLmdyYXBoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2UgYXJlIGNsb3NlZCBvdmVyIGluIHRoZSBoZWxwZXJzXG4gIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBnaXZlIHRoZW0gYSBzcG90IGluIHRoZSBmcmFtZVxuICB2YXIgcHJvZ3JhbSAgPSB0aGlzLnByb2dyYW1cbiAgdmFyIGdyZW1saW5zID0gdGhpcy5ncmVtbGluc1xuXG4gIHZhciBtYXggPSBwcm9ncmFtLmxlbmd0aC0xICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3b3JrIGJhY2t3YXJkc1xuICB2YXIgcGMgPSBtYXggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvZ3JhbSBjb3VudGVyXG4gIHZhciBkb25lID0gLTEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiZWhpbmR3aGljaCB0aGluZ3MgaGF2ZSBmaW5pc2hlZFxuICB2YXIgcmVzdWx0cyA9IFtdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0cyBmb3IgdGhpcyBydW5cbiAgdmFyIG1heWJlX2dyZW1saW4gPSBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgbXl0aGljYWwgYmVhc3RcblxuICBpZighcHJvZ3JhbS5sZW5ndGgpIHJldHVybiBbXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgYm90aGVyXG4gIFxuICBcbiAgLy8gZHJpdmVyIGxvb3BcbiAgd2hpbGUoZG9uZSA8IG1heCkge1xuICAgIG1heWJlX2dyZW1saW4gPSB0cnlfc3RlcChwYywgbWF5YmVfZ3JlbWxpbikgICAgICAgICAgICAgICAgICAgLy8gbWF5YmVfZ3JlbWxpbiBpcyBhIGdyZW1saW4gb3IgKHN0cmluZyB8IGZhbHNlKVxuICAgIFxuICAgIGlmKG1heWJlX2dyZW1saW4gPT0gJ3B1bGwnKSB7XG4gICAgICBtYXliZV9ncmVtbGluID0gZmFsc2VcbiAgICAgIGlmKHBjLTEgPiBkb25lKSB7XG4gICAgICAgIHBjLS1cbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUgPSBwY1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZihtYXliZV9ncmVtbGluID09ICdkb25lJykge1xuICAgICAgZG9uZSA9IHBjXG4gICAgICBtYXliZV9ncmVtbGluID0gZmFsc2VcbiAgICB9XG4gICAgXG4gICAgcGMrK1xuICAgIFxuICAgIGlmKHBjID4gbWF4KSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBncmVtbGluIGlzIHBvcHBpbmcgb3V0IG9mIHRoZSBwaXBlbGluZS4gY2F0Y2ggaXQhXG4gICAgICBpZihtYXliZV9ncmVtbGluKVxuICAgICAgICByZXN1bHRzLnB1c2gobWF5YmVfZ3JlbWxpbilcbiAgICAgIG1heWJlX2dyZW1saW4gPSBmYWxzZVxuICAgICAgcGMtLVxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IGRlYWwgd2l0aCBncmVtbGluIHBhdGhzIC8gaGlzdG9yeSBhbmQgZ3JlbWxpbiBcImNvbGxpc2lvbnNcIlxuICBcbiAgcmVzdWx0cyA9IHJlc3VsdHMubWFwKGZ1bmN0aW9uKGdyZW1saW4pIHsgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgdGhpcyBhIHF1ZXJ5IGNvbXBvbmVudCAob3IgcG9zdGhvb2spXG4gICAgcmV0dXJuIGdyZW1saW4ucmVzdWx0ID8gZ3JlbWxpbi5yZXN1bHQgOiBncmVtbGluLnZlcnRleCB9IClcblxuICByZXN1bHRzID0gRGFnb2JhLmZpcmVob29rcygncG9zdHF1ZXJ5JywgdGhpcywgcmVzdWx0cylbMF0gXG4gIFxuICByZXR1cm4gcmVzdWx0c1xuICBcbiAgLy8gTkFNRUQgSEVMUEVSU1xuICBcbiAgZnVuY3Rpb24gdHJ5X3N0ZXAocGMsIG1heWJlX2dyZW1saW4pIHtcbiAgICB2YXIgc3RlcCA9IHByb2dyYW1bcGNdXG4gICAgdmFyIG15X3N0YXRlID0gKHN0YXRlW3BjXSA9IHN0YXRlW3BjXSB8fCB7fSlcbiAgICBpZighRGFnb2JhLlFGdW5zW3N0ZXBbMF1dKSByZXR1cm4gRGFnb2JhLm9uRXJyb3IoJ1VucmVjb2duaXplZCBmdW5jdGlvbiBjYWxsOiAnICsgc3RlcFswXSkgfHwgbWF5YmVfZ3JlbWxpbiB8fCAncHVsbCdcbiAgICByZXR1cm4gRGFnb2JhLlFGdW5zW3N0ZXBbMF1dKGdyYXBoLCBzdGVwLnNsaWNlKDEpIHx8IHt9LCBtYXliZV9ncmVtbGluLCBteV9zdGF0ZSlcbiAgfVxuICAgIFxuICBmdW5jdGlvbiBncmVtbGluX2JveGVyKHN0ZXBfaW5kZXgpIHsgcmV0dXJuIGZ1bmN0aW9uKGdyZW1saW4pIHsgcmV0dXJuIFtzdGVwX2luZGV4LCBncmVtbGluXSB9IH1cbiAgXG4gIGZ1bmN0aW9uIHN0ZXBwZXIoc3RlcF9pbmRleCwgZ3JlbWxpbikge1xuICAgIHZhciBzdGVwID0gcHJvZ3JhbVtzdGVwX2luZGV4XVxuICAgIGlmKCFEYWdvYmEuUUZ1bnNbc3RlcFswXV0pIHJldHVybiBEYWdvYmEub25FcnJvcignVW5yZWNvZ25pemVkIGZ1bmN0aW9uIGNhbGw6ICcgKyBzdGVwWzBdKSB8fCB7fVxuICAgIHJldHVybiBEYWdvYmEuUUZ1bnNbc3RlcFswXV0oZ3JhcGgsIHN0ZXAuc2xpY2UoMSkgfHwge30sIGdyZW1saW4gfHwge30sIHN0YXRlW3N0ZXBfaW5kZXhdIHx8IHt9KVxuICB9XG4gIFxuICBmdW5jdGlvbiBlYXRfZ3JlbWxpbnMoZ3JlbWxpbnMsIHN0ZXBfaW5kZXgsIHJlc3VsdCkge1xuICAgIHJldHVybiBncmVtbGlucy5jb25jYXQoIChyZXN1bHQuc3RheSB8fCBbXSkubWFwKGdyZW1saW5fYm94ZXIoc3RlcF9pbmRleCkpICAgKVxuICAgICAgICAgICAgICAgICAgIC5jb25jYXQoIChyZXN1bHQuZ28gICB8fCBbXSkubWFwKGdyZW1saW5fYm94ZXIoc3RlcF9pbmRleCsxKSkgKSB9XG4gIFxuICBmdW5jdGlvbiBzZXRiYW5nX2dyZW1saW5zKHN0ZXBfaW5kZXgsIHJlc3VsdCkge2dyZW1saW5zID0gZWF0X2dyZW1saW5zKGdyZW1saW5zLCBzdGVwX2luZGV4LCByZXN1bHQpfVxufVxuXG5cbkRhZ29iYS5RLmFkZCA9IGZ1bmN0aW9uKGxpc3QpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGEgbmV3IHRyYXZlcnNhbCB0byB0aGUgcXVlcnlcbiAgdGhpcy5wcm9ncmFtLnB1c2gobGlzdClcbiAgcmV0dXJuIHRoaXNcbn1cblxuRGFnb2JhLmFkZFFGdW4gPSBmdW5jdGlvbihuYW1lLCBmdW4pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGEgbmV3IHRyYXZlcnNhbCB0eXBlXG4gIERhZ29iYS5RRnVuc1tuYW1lXSA9IGZ1blxuICBEYWdvYmEuUVtuYW1lXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5hZGQoW25hbWVdLmNvbmNhdChbXS5zbGljZS5hcHBseShhcmd1bWVudHMpKSkgfSBcbiAgLy8gVE9ETzogYWNjZXB0IHN0cmluZyBmdW4gYW5kIGFsbG93IGV4dHJhIHBhcmFtcywgZm9yIGJ1aWxkaW5nIHF1aWNrIGFsaWFzZXMgbGlrZVxuICAvLyAgICAgICBEYWdvYmEuYWRkUUZ1bignY2hpbGRyZW4nLCAnb3V0JykgPC0tIGlmIGFsbCBvdXQgZWRnZXMgYXJlIGtpZHNcbiAgLy8gICAgICAgRGFnb2JhLmFkZFFGdW4oJ250aEdHUCcsICdpbk4nLCAncGFyZW50JylcbiAgLy8gdmFyIG1ldGhvZHMgPSBbJ291dCcsICdpbicsICd0YWtlJywgJ3Byb3BlcnR5JywgJ291dEFsbE4nLCAnaW5BbGxOJywgJ3VuaXF1ZScsICdmaWx0ZXInLCAnb3V0VicsICdvdXRFJywgJ2luVicsICdpbkUnLCAnYm90aCcsICdib3RoVicsICdib3RoRSddXG59XG5cblxuRGFnb2JhLlFGdW5zID0ge30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIHRyYXZlcnNhbCB0eXBlc1xuXG5EYWdvYmEuYWRkUUZ1bigndmVydGV4JywgZnVuY3Rpb24oZ3JhcGgsIGFyZ3MsIGdyZW1saW4sIHN0YXRlKSB7XG4gIGlmKCFzdGF0ZS52ZXJ0aWNlcykgc3RhdGUudmVydGljZXMgPSBncmFwaC5maW5kVmVydGljZXMoYXJncylcbiAgaWYoIXN0YXRlLnZlcnRpY2VzLmxlbmd0aCkgcmV0dXJuICdkb25lJ1xuICB2YXIgdmVydGV4ID0gc3RhdGUudmVydGljZXMucG9wKCkgXG4gIHJldHVybiBEYWdvYmEubWFrZV9ncmVtbGluKHZlcnRleClcbn0pXG4gIFxuRGFnb2JhLmFkZFFGdW4oJ291dCcsIGZ1bmN0aW9uKGdyYXBoLCBhcmdzLCBncmVtbGluLCBzdGF0ZSkge1xuICBpZighZ3JlbWxpbiAmJiAoIXN0YXRlLmVkZ2VzIHx8ICFzdGF0ZS5lZGdlcy5sZW5ndGgpKSByZXR1cm4gJ3B1bGwnXG4gIGlmKCFzdGF0ZS5lZGdlcyB8fCAhc3RhdGUuZWRnZXMubGVuZ3RoKSBcbiAgICBzdGF0ZS5lZGdlcyA9IGdyYXBoLmZpbmRPdXRFZGdlcyhncmVtbGluLnZlcnRleCkuZmlsdGVyKERhZ29iYS5maWx0ZXJUaGluZ3MoYXJnc1swXSkpXG4gIGlmKCFzdGF0ZS5lZGdlcy5sZW5ndGgpIHJldHVybiAncHVsbCdcbiAgdmFyIHZlcnRleCA9IHN0YXRlLmVkZ2VzLnBvcCgpLl9pbiAvLyB3aGF0P1xuICB2YXIgY2xvbmUgPSBEYWdvYmEubWFrZV9ncmVtbGluKHZlcnRleCkgLy8gd2UgbG9zZSBoaXN0b3J5IGhlcmU6IHVzZSBjbG9uZV9ncmVtbGluKGdyZW1saW4pLmdvdG8odmVydGV4KSBpbnN0ZWFkXG4gIHJldHVybiBjbG9uZVxufSlcblxuRGFnb2JhLmFkZFFGdW4oJ291dEFsbE4nLCBmdW5jdGlvbihncmFwaCwgYXJncywgZ3JlbWxpbiwgc3RhdGUpIHtcbiAgdmFyIGZpbHRlciA9IGFyZ3NbMF1cbiAgdmFyIGxpbWl0ID0gYXJnc1sxXS0xXG4gIFxuICBpZighc3RhdGUuZWRnZUxpc3QpIHsgLy8gaW5pdGlhbGl6ZVxuICAgIGlmKCFncmVtbGluKSByZXR1cm4gJ3B1bGwnXG4gICAgc3RhdGUuZWRnZUxpc3QgPSBbXVxuICAgIHN0YXRlLmN1cnJlbnQgPSAwXG4gICAgc3RhdGUuZWRnZUxpc3RbMF0gPSBncmFwaC5maW5kT3V0RWRnZXMoZ3JlbWxpbi52ZXJ0ZXgpLmZpbHRlcihEYWdvYmEuZmlsdGVyVGhpbmdzKGZpbHRlcikpXG4gIH1cbiAgXG4gIGlmKCFzdGF0ZS5lZGdlTGlzdFtzdGF0ZS5jdXJyZW50XS5sZW5ndGgpIHsgLy8gZmluaXNoZWQgdGhpcyByb3VuZFxuICAgIGlmKHN0YXRlLmN1cnJlbnQgPj0gbGltaXQgfHwgIXN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0gICAvLyB0b3RhbGx5IGRvbmUsIG9yIHRoZSBuZXh0IHJvdW5kIGhhcyBubyBpdGVtc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgIXN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0ubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5lZGdlTGlzdCA9IGZhbHNlXG4gICAgICByZXR1cm4gJ3B1bGwnXG4gICAgfVxuICAgIHN0YXRlLmN1cnJlbnQrKyAvLyBnbyB0byBuZXh0IHJvdW5kXG4gICAgc3RhdGUuZWRnZUxpc3Rbc3RhdGUuY3VycmVudCsxXSA9IFtdIFxuICB9XG4gIFxuICB2YXIgdmVydGV4ID0gc3RhdGUuZWRnZUxpc3Rbc3RhdGUuY3VycmVudF0ucG9wKCkuX2luXG4gIFxuICBpZihzdGF0ZS5jdXJyZW50IDwgbGltaXQpIHsgLy8gYWRkIGFsbCBvdXIgbWF0Y2hpbmcgZWRnZXMgdG8gdGhlIG5leHQgbGV2ZWxcbiAgICBpZighc3RhdGUuZWRnZUxpc3Rbc3RhdGUuY3VycmVudCsxXSkgc3RhdGUuZWRnZUxpc3Rbc3RhdGUuY3VycmVudCsxXSA9IFtdXG4gICAgc3RhdGUuZWRnZUxpc3Rbc3RhdGUuY3VycmVudCsxXSA9IHN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0uY29uY2F0KFxuICAgICAgZ3JhcGguZmluZE91dEVkZ2VzKHZlcnRleCkuZmlsdGVyKERhZ29iYS5maWx0ZXJUaGluZ3MoZmlsdGVyKSlcbiAgICApXG4gIH1cbiAgXG4gIHZhciBjbG9uZSA9IERhZ29iYS5tYWtlX2dyZW1saW4odmVydGV4KSAvLyB3ZSBsb3NlIGhpc3RvcnkgaGVyZTogdXNlIGNsb25lX2dyZW1saW4oZ3JlbWxpbikuZ290byh2ZXJ0ZXgpIGluc3RlYWRcbiAgcmV0dXJuIGNsb25lXG59KVxuICBcbkRhZ29iYS5hZGRRRnVuKCdpbkFsbE4nLCBmdW5jdGlvbihncmFwaCwgYXJncywgZ3JlbWxpbiwgc3RhdGUpIHtcbiAgdmFyIGZpbHRlciA9IGFyZ3NbMF1cbiAgdmFyIGxpbWl0ID0gYXJnc1sxXS0xXG4gIFxuICBpZighc3RhdGUuZWRnZUxpc3QpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgIGlmKCFncmVtbGluKSByZXR1cm4gJ3B1bGwnXG4gICAgc3RhdGUuZWRnZUxpc3QgPSBbXVxuICAgIHN0YXRlLmN1cnJlbnQgPSAwXG4gICAgc3RhdGUuZWRnZUxpc3RbMF0gPSBncmFwaC5maW5kSW5FZGdlcyhncmVtbGluLnZlcnRleCkuZmlsdGVyKERhZ29iYS5maWx0ZXJUaGluZ3MoZmlsdGVyKSlcbiAgfVxuICBcbiAgaWYoIXN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnRdLmxlbmd0aCkgeyAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmlzaGVkIHRoaXMgcm91bmRcbiAgICBpZihzdGF0ZS5jdXJyZW50ID49IGxpbWl0IHx8ICFzdGF0ZS5lZGdlTGlzdFtzdGF0ZS5jdXJyZW50KzFdIC8vIHRvdGFsbHkgZG9uZSwgb3IgdGhlIG5leHQgcm91bmQgaGFzIG5vIGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAhc3RhdGUuZWRnZUxpc3Rbc3RhdGUuY3VycmVudCsxXS5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmVkZ2VMaXN0ID0gZmFsc2VcbiAgICAgIHJldHVybiAncHVsbCdcbiAgICB9XG4gICAgc3RhdGUuY3VycmVudCsrICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnbyB0byBuZXh0IHJvdW5kXG4gICAgc3RhdGUuZWRnZUxpc3Rbc3RhdGUuY3VycmVudCsxXSA9IFtdIFxuICB9XG4gIFxuICB2YXIgdmVydGV4ID0gc3RhdGUuZWRnZUxpc3Rbc3RhdGUuY3VycmVudF0ucG9wKCkuX291dFxuICBcbiAgaWYoc3RhdGUuY3VycmVudCA8IGxpbWl0KSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhbGwgb3VyIG1hdGNoaW5nIGVkZ2VzIHRvIHRoZSBuZXh0IGxldmVsXG4gICAgaWYoIXN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0pIHN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0gPSBbXVxuICAgIHN0YXRlLmVkZ2VMaXN0W3N0YXRlLmN1cnJlbnQrMV0gPSBzdGF0ZS5lZGdlTGlzdFtzdGF0ZS5jdXJyZW50KzFdLmNvbmNhdChcbiAgICAgIGdyYXBoLmZpbmRJbkVkZ2VzKHZlcnRleCkuZmlsdGVyKERhZ29iYS5maWx0ZXJUaGluZ3MoZmlsdGVyKSlcbiAgICApXG4gIH1cbiAgXG4gIHZhciBjbG9uZSA9IERhZ29iYS5tYWtlX2dyZW1saW4odmVydGV4KSAvLyB3ZSBsb3NlIGhpc3RvcnkgaGVyZTogdXNlIGNsb25lX2dyZW1saW4oZ3JlbWxpbikuZ290byh2ZXJ0ZXgpIGluc3RlYWRcbiAgcmV0dXJuIGNsb25lXG59KVxuICBcbkRhZ29iYS5hZGRRRnVuKCdpbicsIGZ1bmN0aW9uKGdyYXBoLCBhcmdzLCBncmVtbGluLCBzdGF0ZSkge1xuICBpZighZ3JlbWxpbiAmJiAoIXN0YXRlLmVkZ2VzIHx8ICFzdGF0ZS5lZGdlcy5sZW5ndGgpKSByZXR1cm4gJ3B1bGwnXG4gIGlmKCFzdGF0ZS5lZGdlcyB8fCAhc3RhdGUuZWRnZXMubGVuZ3RoKSBcbiAgICBzdGF0ZS5lZGdlcyA9IGdyYXBoLmZpbmRJbkVkZ2VzKGdyZW1saW4udmVydGV4KS5maWx0ZXIoRGFnb2JhLmZpbHRlclRoaW5ncyhhcmdzWzBdKSlcbiAgaWYoIXN0YXRlLmVkZ2VzLmxlbmd0aCkgcmV0dXJuICdwdWxsJ1xuICB2YXIgdmVydGV4ID0gc3RhdGUuZWRnZXMucG9wKCkuX291dCAvLyB3aGF0PyAvLyBhbHNvLCBhYnN0cmFjdCB0aGlzLi4uXG4gIHZhciBjbG9uZSA9IERhZ29iYS5tYWtlX2dyZW1saW4odmVydGV4KSAvLyB3ZSBsb3NlIGhpc3RvcnkgaGVyZTogdXNlIGNsb25lX2dyZW1saW4oZ3JlbWxpbikuZ290byh2ZXJ0ZXgpIGluc3RlYWRcbiAgcmV0dXJuIGNsb25lXG59KVxuICBcbkRhZ29iYS5hZGRRRnVuKCdwcm9wZXJ0eScsIGZ1bmN0aW9uKGdyYXBoLCBhcmdzLCBncmVtbGluLCBzdGF0ZSkge1xuICBpZighZ3JlbWxpbikgcmV0dXJuICdwdWxsJ1xuICBncmVtbGluLnJlc3VsdCA9IGdyZW1saW4udmVydGV4W2FyZ3NbMF1dXG4gIHJldHVybiBncmVtbGluXG59KVxuICBcbkRhZ29iYS5hZGRRRnVuKCd1bmlxdWUnLCBmdW5jdGlvbihncmFwaCwgYXJncywgZ3JlbWxpbiwgc3RhdGUpIHtcbiAgaWYoIWdyZW1saW4pIHJldHVybiAncHVsbCdcbiAgaWYoc3RhdGVbZ3JlbWxpbi52ZXJ0ZXguX2lkXSkgcmV0dXJuICdwdWxsJyAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3ZlIHNlZW4gdGhpcyBncmVtbGluLCBzbyBnZXQgYW5vdGhlciBpbnN0ZWFkXG4gIHN0YXRlW2dyZW1saW4udmVydGV4Ll9pZF0gPSB0cnVlXG4gIHJldHVybiBncmVtbGluXG59KVxuICBcbkRhZ29iYS5hZGRRRnVuKCdmaWx0ZXInLCBmdW5jdGlvbihncmFwaCwgYXJncywgZ3JlbWxpbiwgc3RhdGUpIHtcbiAgaWYoIWdyZW1saW4pIHJldHVybiAncHVsbCdcbiAgaWYodHlwZW9mIGFyZ3NbMF0gIT0gJ2Z1bmN0aW9uJykgcmV0dXJuIERhZ29iYS5vbkVycm9yKCdGaWx0ZXIgYXJnIGlzIG5vdCBhIGZ1bmN0aW9uOiAnICsgYXJnc1swXSkgfHwgZ3JlbWxpblxuICBpZighYXJnc1swXShncmVtbGluLnZlcnRleCkpIHJldHVybiAncHVsbCcgICAgICAgICAgICAgICAgICAgICAgLy8gZ3JlbWxpbiBmYWlscyBmaWx0ZXIgZnVuY3Rpb24gXG4gIC8vIFRISU5LOiB3b3VsZCB3ZSBldmVyIHdhbnQgdG8gZmlsdGVyIGJ5IG90aGVyIHBhcnRzIG9mIHRoZSBncmVtbGluP1xuICByZXR1cm4gZ3JlbWxpblxufSlcbiAgXG5EYWdvYmEuYWRkUUZ1bigndGFrZScsIGZ1bmN0aW9uKGdyYXBoLCBhcmdzLCBncmVtbGluLCBzdGF0ZSkge1xuICBzdGF0ZS50YWtlbiA9IHN0YXRlLnRha2VuID8gc3RhdGUudGFrZW4gOiAwXG4gIGlmKHN0YXRlLnRha2VuID09IGFyZ3NbMF0pIHtcbiAgICBzdGF0ZS50YWtlbiA9IDBcbiAgICByZXR1cm4gJ2RvbmUnXG4gIH1cbiAgaWYoIWdyZW1saW4pIHJldHVybiAncHVsbCdcbiAgc3RhdGUudGFrZW4rKyAvLyBUSElOSzogbXV0YXRpbmcgc3RhdGVcbiAgcmV0dXJuIGdyZW1saW5cbn0pXG5cblxuXG4vLyBoaSEgXG4vLyAtIHR1bmUgZ3JlbWxpbnMgKGNvbGxpc2lvbnMsIGhpc3RvcnksIGV0Yylcbi8vIC0gaW50ZXJmYWNlOiBzaG93IHF1ZXJ5IHBpZWNlcyBhbmQgcGFyYW1zLFxuLy8gLSBpbnRlcmZhY2U6IHJlc3VtYWJsZSBxdWVyaWVzXG4vLyAtIGdlbmVyYXRpb25hbCBxdWVyaWVzXG4vLyAtIGludGVyc2VjdGlvbnNcbi8vIC0gYWR2ZXJic1xuLy8gLSB5b3UgYXJlIGdyZWF0IVxuXG5cblxuRGFnb2JhLmhvb2tzID0ge31cblxuRGFnb2JhLmFkZGhvb2sgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaykge1xuICBpZighRGFnb2JhLmhvb2tzW3R5cGVdKSBEYWdvYmEuaG9va3NbdHlwZV0gPSBbXVxuICBEYWdvYmEuaG9va3NbdHlwZV0ucHVzaChjYWxsYmFjaylcbn1cblxuRGFnb2JhLmZpcmVob29rcyA9IGZ1bmN0aW9uKHR5cGUsIHF1ZXJ5KSB7XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpXG4gIHJldHVybiAoKERhZ29iYS5ob29rcyB8fCB7fSlbdHlwZV0gfHwgW10pLnJlZHVjZShmdW5jdGlvbihhY2MsIGNhbGxiYWNrKSB7cmV0dXJuIGNhbGxiYWNrLmFwcGx5KHF1ZXJ5LCBhY2MpfSwgYXJncylcbn1cblxuRGFnb2JhLm1ha2VfZ3JlbWxpbiA9IGZ1bmN0aW9uKHZlcnRleCwgc3RhdGUpIHsgcmV0dXJuIHt2ZXJ0ZXg6IHZlcnRleCwgc3RhdGU6IHN0YXRlfSB9XG5cbkRhZ29iYS5maWx0ZXJUaGluZ3MgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuICFhcmcgPyB0cnVlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZyBpcyB0cnVlXG4gICAgICAgICA6IGFyZysnJyA9PT0gYXJnID8gdGhpbmcuX2xhYmVsID09IGFyZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIGxhYmVsXG4gICAgICAgICA6IEFycmF5LmlzQXJyYXkoYXJnKSA/ICEhfmFyZy5pbmRleE9mKHRoaW5nLl9sYWJlbCkgOiBEYWdvYmEub2JqRmlsdGVyKHRoaW5nLCBhcmcpIH0gfSAgLy8gb3IgYSBsaXN0IG9mIGxhYmVsc1xuXG5EYWdvYmEub2JqRmlsdGVyID0gZnVuY3Rpb24odGhpbmcsIG9iaikge1xuICBmb3IodmFyIGtleSBpbiBvYmopXG4gICAgaWYodGhpbmdba2V5XSAhPSBvYmpba2V5XSlcbiAgICAgIHJldHVybiBmYWxzZTsgcmV0dXJuIHRydWUgfVxuXG5EYWdvYmEuZmluZCA9IGZ1bmN0aW9uKGFyciwgZnVuKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspXG4gICAgaWYoZnVuKGFycltpXSwgaSwgYXJyKSlcbiAgICAgIHJldHVybiBhcnJbaV0gfVxuXG5EYWdvYmEuY2xlYW52ZXJ0ZXggPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7cmV0dXJuIChrZXkgPT0gJ19pbicgfHwga2V5ID09ICdfb3V0JykgPyB1bmRlZmluZWQgOiB2YWx1ZX0gLy8gZm9yIEpTT04uc3RyaW5naWZ5XG5EYWdvYmEuY2xlYW5lZGdlICAgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7cmV0dXJuIGtleSA9PSAnX2luJyA/IHZhbHVlLl9pZCA6IGtleSA9PSAnX291dCcgPyB2YWx1ZS5faWQgOiB2YWx1ZX1cblxuRGFnb2JhLnVuaXF1ZWlmeSA9IGZ1bmN0aW9uIChyZXN1bHRzKSB7IC8vIE9QVDogZG8gdGhpcyBpbiB0aGUgcXVlcnkgdmlhIGdyZW1saW4gY29sbGlzaW9uIGNvdW50aW5nXG4gIHJldHVybiBbcmVzdWx0cy5maWx0ZXIoZnVuY3Rpb24oaXRlbSwgaW5kZXgsIGFycmF5KSB7cmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSkgPT0gaW5kZXh9KV19XG5cbkRhZ29iYS5jbGVhbmNsb25lID0gZnVuY3Rpb24gKHJlc3VsdHMpIHsgLy8gcmVtb3ZlIGFsbCBfLXByZWZpeGVkIHByb3BlcnRpZXNcbiByZXR1cm4gW3Jlc3VsdHMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpdGVtLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7cmV0dXJuIGtleVswXT09J18nID8gdW5kZWZpbmVkIDogdmFsdWV9KSl9KV19XG5cbi8vIE5PVEU6IGFkZCB0aGVzZSBob29rcyBpZiB5b3UgbmVlZCB0aGVtLiAob3VyIHZlcnRleCBwYXlsb2FkcyBhcmUgaW1tdXRhYmxlLCBhbmQgd2UgdW5pcXVlaWZ5IHByaW9yIHRvIHRha2luZy4pXG5cbi8vIERhZ29iYS5hZGRob29rKCdwb3N0cXVlcnknLCBEYWdvYmEudW5pcXVlaWZ5KVxuLy8gRGFnb2JhLmFkZGhvb2soJ3Bvc3RxdWVyeScsIERhZ29iYS5jbGVhbmNsb25lKVxuXG4vLyBUSElOSzogdGhlIHVuaXF1aWZ5IGhvb2sgaGFwcGVucyBhZnRlciB0aGUgdGFrZSBjb21wb25lbnQgc28gaXQgc211c2hlcyByZXN1bHRzIGRvd24sIHBvc3NpYmx5IHJldHVybmluZyBmZXdlciB0aGFuIHlvdSB3YW50ZWQuLi5cbiAgXG5EYWdvYmEub25FcnJvciA9IGZ1bmN0aW9uKG1zZykge1xuICBjb25zb2xlLmxvZyhtc2cpXG4gIHJldHVybiBmYWxzZSBcbn0iLCIvKlxuICAgICAgIF9fX19fX18gIF9fICAgX18gIF9fX19fX18gIF9fX19fX18gIF9fX19fX18gIF9fX19fX18gIF9fXyAgICAgIF9fXyAgICAgXG4gICAgICB8ICAgICAgIHx8ICB8IHwgIHx8ICAgICAgIHx8ICAgICAgIHx8ICBfICAgIHx8ICAgXyAgIHx8ICAgfCAgICB8ICAgfCAgICBcbiAgICAgIHwgICAgXyAgfHwgIHwgfCAgfHwgICAgX19ffHwgICAgX19ffHwgfF98ICAgfHwgIHxffCAgfHwgICB8ICAgIHwgICB8ICAgIFxuICAgICAgfCAgIHxffCB8fCAgfF98ICB8fCAgIHxfX18gfCAgIHxfX18gfCAgICAgICB8fCAgICAgICB8fCAgIHwgICAgfCAgIHwgICAgXG4gICAgICB8ICAgIF9fX3x8ICAgICAgIHx8ICAgIF9fX3x8ICAgIF9fX3x8ICBfICAgfCB8ICAgICAgIHx8ICAgfF9fXyB8ICAgfF9fXyBcbiAgICAgIHwgICB8ICAgIHwgICAgICAgfHwgICB8ICAgIHwgICB8ICAgIHwgfF98ICAgfHwgICBfICAgfHwgICAgICAgfHwgICAgICAgfFxuICAgICAgfF9fX3wgICAgfF9fX19fX198fF9fX3wgICAgfF9fX3wgICAgfF9fX19fX198fF9ffCB8X198fF9fX19fX198fF9fX19fX198XG5cblxuICAgIFRoZSBtYWluIGludGVyZmFjZSBmb3IgdGhlIEV2ZXJ5Qml0IHBsYXRmb3JtLlxuXG4gICAgTW9zdCBjYWxscyB0byB0aGUgcGxhdGZvcm0gc2hvdWxkIGdvIHRocm91Z2ggaGVyZSxcbiAgICByYXRoZXIgdGhhbiBhY2Nlc3NpbmcgY29yZSBzeXN0ZW1zIGxpa2UgUEIuRGF0YSBhbmQgUEIuQ3J5cHRvIGRpcmVjdGx5LlxuXG4gICAgSW4gYWRkaXRpb24gdG8gdGhlIHB1YmxpYy1mYWNpbmcgQVBJIG1hbnkgZ2VuZXJhbCBoZWxwZXIgZnVuY3Rpb25zXG4gICAgYXJlIGVzdGFibGlzaGVkIGhlcmUgZm9yIHVzZSBieSB0aGUgZGVlcGVyIGxheWVycy5cblxuICAgIENvcHlyaWdodCAyMDE0IEV2ZXJ5Qml0LiBTZWUgUkVBRE1FIGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG4qL1xuXG5pZih0eXBlb2YgUEIgPT09ICd1bmRlZmluZWQnKSBQQiA9IHt9ICAgICAgICAgICAgICAgICAgIC8vIHdlIG1pZ2h0IGxvYWQgY29uZmlnLmpzIGZpcnN0XG5pZighUEIuQ09ORklHKSBQQi5DT05GSUcgPSB7fSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIHdlIG1pZ2h0IG5vdFxuXG5QQi5Nb2R1bGVzID0ge30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1cHBsZW1lbnRhcnkgZXh0ZW5zaW9ucyBsaXZlIGhlcmVcblBCLk0gPSBQQi5Nb2R1bGVzXG5cblBCLnZlcnNpb24gPSAnMC43LjMnXG5cbi8vLy8vLy8vLy8vLy8vIFNUQU5EQVJEIEFQSSBGVU5DVElPTlMgLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuUEIuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAvLy8vIGluaXRpYWxpemVzIGFsbCBhdmFpbGFibGUgbW9kdWxlcyBhbmQgdGhlIHBsYXRmb3JtIHN1YnN5c3RlbXMuXG4gICAgLy8vLyBvcHRpb25zIGlzIGFuIG9iamVjdCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnMgdGhhdCBpcyBwYXNzZWQgdG8gZWFjaCBtb2R1bGUgYW5kIHN1YnN5c3RlbS5cbiAgICBcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIFxuICAgIC8vIEJFR0lOIENPTkZJRyBBTkQgT1BUSU9OUyAvL1xuICAgIFxuICAgIHNldERlZmF1bHQoJ3pvbmUnLCAnJylcbiAgICBzZXREZWZhdWx0KCdwdWZmQXBpJywgJ2h0dHBzOi8vaS5jeC9hcGkvcHVmZnMvYXBpLnBocCcpXG4gICAgc2V0RGVmYXVsdCgndXNlckFwaScsICdodHRwczovL2kuY3gvYXBpL3VzZXJzL2FwaS5waHAnKVxuICAgIHNldERlZmF1bHQoJ2V2ZW50c0FwaScsICdodHRwczovL2kuY3gvYXBpL3B1ZmZzL2FwaS5waHAnKVxuICAgIHNldERlZmF1bHQoJ2VuYWJsZVAyUCcsIGZhbHNlKVxuICAgIHNldERlZmF1bHQoJ3BhZ2VCYXRjaFNpemUnLCAxMClcbiAgICBzZXREZWZhdWx0KCdpbml0TG9hZEdpdmV1cCcsIDIwMClcbiAgICBzZXREZWZhdWx0KCduZXR3b3JrVGltZW91dCcsIDIwMDAwKSAgICAgICAgIC8vIHR3ZW50eSBzZWNvbmQgdGltZW91dFxuICAgIHNldERlZmF1bHQoJ25vTG9jYWxTdG9yYWdlJywgZmFsc2UpXG4gICAgc2V0RGVmYXVsdCgnbmV0YmxvY2tTdWZmaXgnLCAnbG9jYWwnKVxuICAgIHNldERlZmF1bHQoJ2NyeXB0b3dvcmtlclVSTCcsICcnKSAgICAgICAgICAgLy8gcG9pbnQgdG8gY3J5cHRvd29ya2VyLmpzIHRvIGVuYWJsZSB3b3JrZXIgdGhyZWFkXG4gICAgc2V0RGVmYXVsdCgnZXBoZW1lcmFsS2V5Y2hhaW4nLCBmYWxzZSkgICAgICAvLyBwcmV2ZW50cyBrZXljaGFpbiBmcm9tIGJlaW5nIHNhdmVkIHRvIGxvY2FsU3RvcmFnZVxuICAgIHNldERlZmF1bHQoJ2luaXRMb2FkQmF0Y2hTaXplJywgMjApXG4gICAgc2V0RGVmYXVsdCgnaW5NZW1vcnlTaGVsbExpbWl0JywgMTAwMDApICAgICAvLyBzaGVsbHMgYXJlIHJlbW92ZWQgdG8gY29tcGVuc2F0ZVxuICAgIHNldERlZmF1bHQoJ2dsb2JhbEJpZ0JhdGNoTGltaXQnLCAyMDAwKSAgICAgLy8gbWF4aW11bSBudW1iZXIgb2Ygc2hlbGxzIHRvIHJlY2VpdmUgYXQgb25jZSAvLyBUT0RPOiBhbGlnbiB3aXRoIEFQSVxuICAgIHNldERlZmF1bHQoJ2luTWVtb3J5TWVtb3J5TGltaXQnLCAzMDBFNikgICAgLy8gfjMwME1CXG4gICAgc2V0RGVmYXVsdCgnYW5vblByaXZhdGVBZG1pbktleScsICc1S2RWalF3amhNY2hyWnVkRlZmZVJpaVBNZHJONnJjNENvdU5oN0tQWm1oOGlIRWlXTXgnKSAvLyBmb3IgcmVnaXN0ZXJpbmcgYW5vbiB1c2Vyc1xuICAgIHNldERlZmF1bHQoJ2Rpc2FibGVTZW5kVG9TZXJ2ZXInLCBmYWxzZSkgICAgLy8gc28geW91IGNhbiB3b3JrIGxvY2FsbHlcbiAgICBzZXREZWZhdWx0KCdkaXNhYmxlUmVjZWl2ZVB1YmxpYycsIGZhbHNlKSAgIC8vIG5vIHB1YmxpYyBwdWZmcyBleGNlcHQgcHJvZmlsZXNcbiAgICBzZXREZWZhdWx0KCdkaXNhYmxlQ2xvdWRJZGVudGl0eScsIGZhbHNlKSAgIC8vIGRvbid0IHN0b3JlIGVuY3J5cHRlZCBpZGVudGl0eSBpbiB0aGUgY2xvdWRcbiAgICBzZXREZWZhdWx0KCdzdXBwb3J0ZWRDb250ZW50VHlwZXMnLCBmYWxzZSkgIC8vIHdoaXRlbGlzdCBvZiBjb250ZXh0IHR5cGVzOyBmYWxzZSBsb2FkcyBhbGxcbiAgICBzZXREZWZhdWx0KCdzaGVsbENvbnRlbnRUaHJlc2hvbGQnLCAxMDAwKSAgIC8vIHNpemUgb2YgdW5jb21wYWN0ZWQgY29udGVudFxuICAgIHNldERlZmF1bHQoJ2xvY2FsU3RvcmFnZVNoZWxsTGltaXQnLCAxMDAwKSAgLy8gbWF4aW11bSBudW1iZXIgb2Ygc2hlbGxzXG4gICAgc2V0RGVmYXVsdCgnbG9jYWxTdG9yYWdlTWVtb3J5TGltaXQnLCAzRTYpICAvLyB+M01CXG4gICAgXG4gICAgZnVuY3Rpb24gc2V0RGVmYXVsdChrZXksIHZhbCkge1xuICAgICAgICBQQi5DT05GSUdba2V5XSA9IG9wdGlvbnNba2V5XSB8fCBQQi5DT05GSUdba2V5XSB8fCB2YWxcbiAgICB9XG4gICAgXG4gICAgLy8gRU5EIENPTkZJRyBBTkQgT1BUSU9OUyAvL1xuICAgICAgICBcbiAgICBQQi5Vc2Vycy5pbml0KG9wdGlvbnMpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgdXNlciByZWNvcmQgc3Vic3lzdGVtXG4gICAgUEIuRGF0YS5pbml0KG9wdGlvbnMpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemUgdGhlIGRhdGEgc3Vic3lzdGVtXG4gICAgUEIuTmV0LmluaXQob3B0aW9ucykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemUgdGhlIG5ldHdvcmsgc3Vic3lzdGVtXG4gICAgXG4gICAgdmFyIG1vZHVsZUtleXMgPSBPYmplY3Qua2V5cyhQQi5NKVxuICAgIG1vZHVsZUtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHsgICAgICAgICAgICAgICAgICAvLyBjYWxsIGFsbCBtb2R1bGUgaW5pdGlhbGl6ZXJzXG4gICAgICAgIGlmKFBCLk1ba2V5XS5pbml0KSBcbiAgICAgICAgICAgIFBCLk1ba2V5XS5pbml0KG9wdGlvbnMpXG4gICAgfSlcbiAgICBcbiAgICBwb3BNb2RzKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmbGF0ZSBhbnkgbWFjaGluZSBwcmVmc1xuICAgIGZ1bmN0aW9uIHBvcE1vZHMoKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUSElOSzogbWF5YmUgbW92ZSB0aGlzIHRvIFBCLlBlcnNpc3QuaW5pdFxuICAgICAgICB2YXIgbW9kcyA9IFBCLlBlcnNpc3QuZ2V0KCdDT05GSUcnKVxuICAgICAgICBpZighbW9kcykgcmV0dXJuIGZhbHNlXG4gICAgXG4gICAgICAgIFBCLkNPTkZJRy5tb2RzID0gbW9kc1xuICAgICAgICBPYmplY3Qua2V5cyhQQi5DT05GSUcubW9kcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHsgUEIuQ09ORklHW2tleV0gPSBtb2RzW2tleV0gfSlcbiAgICB9XG4gICAgXG4gICAgUEIuYnVpbGRDcnlwdG93b3JrZXIob3B0aW9ucylcbn1cblxuXG5QQi5nZXRQdWZmQnlTaWcgPSBmdW5jdGlvbihzaWcpIHtcbiAgICAvLy8vIGdldCBhIHBhcnRpY3VsYXIgcHVmZlxuICAgIHZhciBzaGVsbCA9IFBCLkRhdGEuZ2V0Q2FjaGVkU2hlbGxCeVNpZyhzaWcpICAgICAgICAvLyBjaGVjayBpbiByZWd1bGFyIGNhY2hlXG4gICAgXG4gICAgaWYoIXNoZWxsKVxuICAgICAgICBzaGVsbCA9IFBCLkRhdGEuZ2V0RGVjcnlwdGVkTGV0dGVyQnlTaWcoc2lnKSAgICAvLyBjaGVjayBpbiBwcml2YXRlIGNhY2hlXG4gICAgXG4gICAgaWYoc2hlbGwpXG4gICAgICAgIHJldHVybiBQQi5EYXRhLmdldFB1ZmZGcm9tU2hlbGwoc2hlbGwpICAgICAgICAgIC8vIGdldCBhIHB1ZmYgZnJvbSB0aGUgc2hlbGxcbiAgICAgICAgXG4gICAgcmV0dXJuIFBCLkRhdGEuZ2V0UHVmZkJ5U2lnKHNpZykgICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgcHVmZlxufVxuXG5QQi5wb3N0UHVibGljTWVzc2FnZSA9IGZ1bmN0aW9uKGNvbnRlbnQsIHR5cGUpIHtcbiAgICAvLy8vIHBvc3QgYSBwdWJsaWMgcHVmZi4gdHlwZSBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gJ3RleHQnXG4gICAgdHlwZSA9IHR5cGUgfHwgJ3RleHQnXG4gICAgXG4gICAgdmFyIG15VXNlcm5hbWUgPSBQQi5nZXRDdXJyZW50VXNlcm5hbWUoKVxuICAgIGlmKCFteVVzZXJuYW1lKVxuICAgICAgICByZXR1cm4gUEIuZW1wdHlQcm9taXNlKCdZb3UgbXVzdCBoYXZlIGEgY3VycmVudCBpZGVudGl0eSB0byBwb3N0IGEgcHVibGljIG1lc3NhZ2UnKVxuICAgIFxuICAgIHZhciBwdWZmID0gUEIuc2ltcGxlQnVpbGRQdWZmKHR5cGUsIGNvbnRlbnQpXG4gICAgcmV0dXJuIFBCLmFkZFB1ZmZUb1N5c3RlbShwdWZmKVxufVxuXG5QQi5wb3N0UHJpdmF0ZU1lc3NhZ2UgPSBmdW5jdGlvbihjb250ZW50LCB1c2VybmFtZXMsIHR5cGUpIHtcbiAgICAvLy8vIHBvc3QgYW4gZW5jcnlwdGVkIHB1ZmYuIHR5cGUgaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvICd0ZXh0Jy4gdXNlcm5hbWVzIGlzIGFuIGFycmF5IG9mIHVzZXJuYW1lcy5cbiAgICB0eXBlID0gdHlwZSB8fCAndGV4dCdcblxuICAgIHZhciBteVVzZXJuYW1lID0gUEIuZ2V0Q3VycmVudFVzZXJuYW1lKClcbiAgICBpZighbXlVc2VybmFtZSlcbiAgICAgICAgcmV0dXJuIFBCLmVtcHR5UHJvbWlzZSgnWW91IG11c3QgaGF2ZSBhIGN1cnJlbnQgaWRlbnRpdHkgdG8gcG9zdCBhIHByaXZhdGUgbWVzc2FnZScpXG4gICAgXG4gICAgdXNlcm5hbWVzID0gdXNlcm5hbWVzIHx8IFtdXG4gICAgaWYoIUFycmF5LmlzQXJyYXkodXNlcm5hbWVzKSlcbiAgICAgICAgdXNlcm5hbWVzID0gW3VzZXJuYW1lc11cbiAgICBcbiAgICB1c2VybmFtZXMucHVzaChteVVzZXJuYW1lKVxuICAgIHVzZXJuYW1lcyA9IFBCLnVuaXF1aWZ5KHVzZXJuYW1lcylcbiAgICB2YXIgcHJvbSA9IFBCLlVzZXJzLnVzZXJuYW1lc1RvVXNlclJlY29yZHNQcm9taXNlKHVzZXJuYW1lcylcbiAgICBcbiAgICByZXR1cm4gcHJvbS50aGVuKGZ1bmN0aW9uKHVzZXJSZWNvcmRzKSB7ICAgICAgICBcbiAgICAgICAgdmFyIHB1ZmYgPSBQQi5zaW1wbGVCdWlsZFB1ZmYodHlwZSwgY29udGVudCwgbnVsbCwgdXNlcm5hbWVzLCB1c2VyUmVjb3JkcylcbiAgICAgICAgcmV0dXJuIFBCLmFkZFB1ZmZUb1N5c3RlbShwdWZmKVxuICAgIH0pXG4gICAgXG4gICAgcmV0dXJuIHByb21cbn1cblxuUEIucG9zdEFub255bW91c1ByaXZhdGVNZXNzYWdlID0gZnVuY3Rpb24oY29udGVudCwgdXNlcm5hbWVzLCB0eXBlKSB7fVxuUEIucG9zdFBhcmFub2lkUHJpdmF0ZU1lc3NhZ2UgPSBmdW5jdGlvbihjb250ZW50LCB1c2VybmFtZXMsIHR5cGUpIHt9XG5cblxuUEIuY3JlYXRlUHJpdmF0ZVB1ZmYgPSBmdW5jdGlvbihjb250ZW50LCB0eXBlKSB7XG4gICAgdmFyIHBheWxvYWQgPSB7fVxuICAgIFxuICAgIHZhciB0eXBlICAgPSB0eXBlIHx8ICdmaWxlJ1xuICAgIHZhciByb3V0ZXMgPSBbJ2xvY2FsJ11cblxuICAgIHZhciB1c2VyUmVjb3JkID0gUEIuZ2V0Q3VycmVudFVzZXJSZWNvcmQoKVxuICAgIHZhciB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHQgPSBbdXNlclJlY29yZF1cbiAgICB2YXIgcHJldmlvdXMsIHB1ZmZcbiAgICBcbiAgICBwdWZmID0gUEIuc2ltcGxlQnVpbGRQdWZmKHR5cGUsIGNvbnRlbnQsIHBheWxvYWQsIHJvdXRlcywgdXNlclJlY29yZHNGb3JXaG9tVG9FbmNyeXB0KVxuICAgIFxuICAgIHJldHVybiBwdWZmXG59XG5cblxuUEIuZ2V0TXlNZXNzYWdlcyA9IHRydWVcblxuUEIuY3JlYXRlSWRlbnRpdHkgPSBmdW5jdGlvbih1c2VybmFtZSwgcGFzc3BocmFzZSkge1xuICAgIC8vIFRPRE86IHZhbGlkYXRpb25zIGFuZCBlcnJvciBoYW5kbGluZyAobG90cyBvZiBpdClcbiAgICBcbiAgICB2YXIgcHJlcGVuZGVkUGFzc3BocmFzZSA9IHVzZXJuYW1lICsgcGFzc3BocmFzZVxuICAgICAgICB2YXIgcHJpdmF0ZUtleSA9IFBCLkNyeXB0by5wYXNzcGhyYXNlVG9Qcml2YXRlS2V5V2lmKHByZXBlbmRlZFBhc3NwaHJhc2UpXG4gICAgXG4gICAgdmFyIHByb20gPSBQQi5yZWdpc3RlclRvcExldmVsVXNlcih1c2VybmFtZSwgcHJpdmF0ZUtleSwgcHJpdmF0ZUtleSwgcHJpdmF0ZUtleSlcbiAgICBcbiAgICBwcm9tLnRoZW4oZnVuY3Rpb24odXNlclJlY29yZCkge1xuICAgICAgICB2YXIgY2FwYSA9IDEgLy8gVEhJTks6IGRvZXMgY2FwYSBhbHdheXMgc3RhcnQgYXQgMT8gd2hlcmUgc2hvdWxkIHRoYXQga25vd2xlZGdlIGxpdmU/XG4gICAgICAgIFBCLmFkZEFsaWFzKHVzZXJuYW1lLCB1c2VybmFtZSwgY2FwYSwgcHJpdmF0ZUtleSwgcHJpdmF0ZUtleSwgcHJpdmF0ZUtleSwge3Bhc3NwaHJhc2U6IHBhc3NwaHJhc2V9KVxuICAgICAgICBQQi5zd2l0Y2hJZGVudGl0eVRvKHVzZXJuYW1lKVxuICAgIH0pXG4gICAgXG4gICAgLy8gVE9ETzogb24gc3dpdGNoSWRlbnRpdHlUbyBmYWxzZSBjaGFuZ2UgdW5kZWZpbmVkIHRvICcnXG4gICAgXG4gICAgcmV0dXJuIHByb21cbn1cblxuUEIucmVnaXN0ZXJUb3BMZXZlbFVzZXIgPSBmdW5jdGlvbih1c2VybmFtZSwgcHJpdmF0ZVJvb3RLZXksIHByaXZhdGVBZG1pbktleSwgcHJpdmF0ZURlZmF1bHRLZXkpIHtcbiAgICAvLy8vIGNyZWF0ZSBhIGJyYW5kIG5ldyB0b3AtbGV2ZWwgdXNlclxuXG4gICAgLy8gT1BUOiBwcml2YXRlVG9QdWJsaWMgaXMgZXhwZW5zaXZlIC0tIHdlIGNvdWxkIHJlZHVjZSB0aGUgbnVtYmVyIG9mIGNhbGxzIGlmIHRoZSBwcml2YXRlIGtleXMgYXJlIGlkZW50aWNhbFxuICAgIHZhciByb290S2V5UHVibGljICAgID0gUEIuQ3J5cHRvLnByaXZhdGVUb1B1YmxpYyhwcml2YXRlUm9vdEtleSlcbiAgICB2YXIgYWRtaW5LZXlQdWJsaWMgICA9IFBCLkNyeXB0by5wcml2YXRlVG9QdWJsaWMocHJpdmF0ZUFkbWluS2V5KVxuICAgIHZhciBkZWZhdWx0S2V5UHVibGljID0gUEIuQ3J5cHRvLnByaXZhdGVUb1B1YmxpYyhwcml2YXRlRGVmYXVsdEtleSlcblxuICAgIHZhciBwYXlsb2FkID0geyByZXF1ZXN0ZWRVc2VybmFtZTogdXNlcm5hbWVcbiAgICAgICAgICAgICAgICAgICwgICAgICAgICAgIHJvb3RLZXk6IHJvb3RLZXlQdWJsaWNcbiAgICAgICAgICAgICAgICAgICwgICAgICAgICAgYWRtaW5LZXk6IGFkbWluS2V5UHVibGljXG4gICAgICAgICAgICAgICAgICAsICAgICAgICBkZWZhdWx0S2V5OiBkZWZhdWx0S2V5UHVibGljXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICB2YXIgcm91dGVzICA9IFtdXG4gICAgdmFyIGNvbnRlbnQgPSAncmVxdWVzdFVzZXJuYW1lJ1xuICAgIHZhciB0eXBlICAgID0gJ3VwZGF0ZVVzZXJSZWNvcmQnXG5cbiAgICB2YXIgcHVmZiA9IFBCLmJ1aWxkUHVmZih1c2VybmFtZSwgcHJpdmF0ZUFkbWluS2V5LCByb3V0ZXMsIHR5cGUsIGNvbnRlbnQsIHBheWxvYWQpXG4gICAgXG4gICAgdmFyIHByb20gPSBQQi5OZXQudXBkYXRlVXNlclJlY29yZChwdWZmKVxuICAgIFxuICAgIHJldHVybiBwcm9tXG59XG5cbi8qKlxuICogcmVnaXN0ZXIgYSBzdWJ1c2VyIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBpZGVudGl0eVxuICogQHBhcmFtICB7c3RyaW5nfSBuZXdVc2VybmFtZSAgICAgZGVzaXJlZCBuZXcgc3VidXNlciBuYW1lXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RLZXkgICAgICAgICBwdWJsaWMgcm9vdCBrZXkgZm9yIHRoZSBuZXcgc3VidXNlclxuICogQHBhcmFtICB7c3RyaW5nfSBhZG1pbktleSAgICAgICAgcHVibGljIGFkbWluIGtleSBmb3IgdGhlIG5ldyBzdWJ1c2VyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGRlZmF1bHRLZXkgICAgICBwdWJsaWMgZGVmYXVsdCBrZXkgZm9yIHRoZSBuZXcgc3VidXNlclxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICAgdXNlciByZWNvcmQgZm9yIHRoZSBuZXdseSBjcmVhdGVkIHN1YnVzZXJcbiAqL1xuUEIucmVnaXN0ZXJTdWJ1c2VyID0gZnVuY3Rpb24obmV3VXNlcm5hbWUsIHJvb3RLZXksIGFkbWluS2V5LCBkZWZhdWx0S2V5KSB7XG4gICAgLy8vLyByZWdpc3RlcnMgYSBzdWJ1c2VyIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBpZGVudGl0eVxuICAgIFxuICAgIHZhciBzaWduaW5nVXNlcm5hbWUgPSBQQi5nZXRDdXJyZW50VXNlcm5hbWUoKVxuICAgIHZhciBwcm9tXG4gICAgXG4gICAgUEIudXNlU2VjdXJlSW5mbyhmdW5jdGlvbihfLCBfLCBfLCBwcml2YXRlQWRtaW5LZXksIF8pIHtcbiAgICAgICAgcHJvbSA9IFBCLnJlZ2lzdGVyU3VidXNlckZvclVzZXIoc2lnbmluZ1VzZXJuYW1lLCBwcml2YXRlQWRtaW5LZXksIG5ld1VzZXJuYW1lLCByb290S2V5LCBhZG1pbktleSwgZGVmYXVsdEtleSlcbiAgICB9KVxuICAgIFxuICAgIHJldHVybiBwcm9tXG59XG5cblxuUEIudXBkYXRlUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKGtleVRvTW9kaWZ5LCBuZXdQcml2YXRlS2V5LCBzZWNyZXRzKSB7XG4gICAgLy8vLyBhdHRlbXB0cyB0byB1cGRhdGUgYSBwcml2YXRlIGtleSBmb3IgdGhlIGN1cnJlbnQgdXNlci4gXG4gICAgLy8vLyBpZiBzdWNjZXNzZnVsIGl0IGFkZHMgdGhlIG5ldyBhbGlhcyB0byB0aGUgY3VycmVudCBpZGVudGl0eS5cbiAgICAvLy8vIHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgbmV3IHVzZXJSZWNvcmQuXG4gICAgXG4gICAgdmFyIHVzZXJuYW1lID0gUEIuZ2V0Q3VycmVudFVzZXJuYW1lKClcbiAgICB2YXIgbmV3UHVibGljS2V5ID0gUEIuQ3J5cHRvLnByaXZhdGVUb1B1YmxpYyhuZXdQcml2YXRlS2V5KVxuXG4gICAgaWYoWydkZWZhdWx0S2V5JywgJ2FkbWluS2V5JywgJ3Jvb3RLZXknXS5pbmRleE9mKGtleVRvTW9kaWZ5KSA9PSAtMSlcbiAgICAgICAgcmV0dXJuIFBCLmVtcHR5UHJvbWlzZSgnVGhhdCBpcyBub3QgYSB2YWxpZCBrZXkgdG8gbW9kaWZ5JylcblxuICAgIHZhciBwYXlsb2FkID0ge31cbiAgICB2YXIgcm91dGVzICA9IFtdXG4gICAgdmFyIGNvbnRlbnQgPSAnbW9kaWZ5VXNlcktleSdcbiAgICB2YXIgdHlwZSAgICA9ICd1cGRhdGVVc2VyUmVjb3JkJ1xuXG4gICAgcGF5bG9hZC5rZXlUb01vZGlmeSA9IGtleVRvTW9kaWZ5XG4gICAgcGF5bG9hZC5uZXdLZXkgPSBuZXdQdWJsaWNLZXlcbiAgICBwYXlsb2FkLnRpbWUgPSBEYXRlLm5vdygpXG5cbiAgICB2YXIgcHJvbSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcHVmZlxuXG4gICAgICAgIFBCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oXywgXywgcHJpdmF0ZVJvb3RLZXksIHByaXZhdGVBZG1pbktleSwgcHJpdmF0ZURlZmF1bHRLZXkpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IHB1ZmYgbGVha3MsIGJ1dCBvbmx5IGNvbnRhaW5zIHB1YmxpY2x5IGFjY2Vzc2libGUgZGF0YVxuICAgICAgICBcbiAgICAgICAgICAgIHZhciBzaWduaW5nVXNlcktleSA9ICdwcml2YXRlUm9vdEtleScgICAgICAgLy8gY2hhbmdpbmcgYWRtaW4gb3Igcm9vdCBrZXlzIHJlcXVpcmVzIHJvb3QgcHJpdmlsZWdlc1xuICAgICAgICAgICAgdmFyIHByaXZhdGVLZXkgPSBwcml2YXRlUm9vdEtleVxuXG4gICAgICAgICAgICBpZiAoa2V5VG9Nb2RpZnkgPT0gJ2RlZmF1bHRLZXknKSB7IFxuICAgICAgICAgICAgICAgIHNpZ25pbmdVc2VyS2V5ID0gJ3ByaXZhdGVBZG1pbktleScgICAgICAvLyBjaGFuZ2luZyB0aGUgZGVmYXVsdCBrZXkgb25seSByZXF1aXJlcyBhZG1pbiBwcml2aWxlZ2VzXG4gICAgICAgICAgICAgICAgcHJpdmF0ZUtleSA9IHByaXZhdGVBZG1pbktleVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighcHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoUEIubWFrZUVycm9yKFwiWW91IG5lZWQgdGhlIFwiICsgc2lnbmluZ1VzZXJLZXkgKyBcIiB0byBjaGFuZ2UgdGhlIFwiICsga2V5VG9Nb2RpZnkgKyBcIiBrZXkuXCIpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdWZmID0gUEIuYnVpbGRQdWZmKHVzZXJuYW1lLCBwcml2YXRlS2V5LCByb3V0ZXMsIHR5cGUsIGNvbnRlbnQsIHBheWxvYWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgdmFyIHVzZXJSZWNvcmRQcm9taXNlID0gUEIuTmV0LnVwZGF0ZVVzZXJSZWNvcmQocHVmZilcblxuICAgICAgICB1c2VyUmVjb3JkUHJvbWlzZS50aGVuKGZ1bmN0aW9uKHVzZXJSZWNvcmQpIHtcbiAgICAgICAgICAgIGlmKGtleVRvTW9kaWZ5ID09ICdkZWZhdWx0S2V5Jykge1xuICAgICAgICAgICAgICAgIFBCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oXywgdXNlcm5hbWUsIHByaXZhdGVSb290S2V5LCBwcml2YXRlQWRtaW5LZXksIF8pIHtcbiAgICAgICAgICAgICAgICAgICAgUEIuYWRkQWxpYXModXNlcm5hbWUsIHVzZXJuYW1lLCB1c2VyUmVjb3JkLmNhcGEsIHByaXZhdGVSb290S2V5LCBwcml2YXRlQWRtaW5LZXksIG5ld1ByaXZhdGVLZXksIHNlY3JldHMpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoa2V5VG9Nb2RpZnkgPT0gJ2FkbWluS2V5Jykge1xuICAgICAgICAgICAgICAgIFBCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oXywgdXNlcm5hbWUsIHByaXZhdGVSb290S2V5LCBfLCBwcml2YXRlRGVmYXVsdEtleSkge1xuICAgICAgICAgICAgICAgICAgICBQQi5hZGRBbGlhcyh1c2VybmFtZSwgdXNlcm5hbWUsIHVzZXJSZWNvcmQuY2FwYSwgcHJpdmF0ZVJvb3RLZXksIG5ld1ByaXZhdGVLZXksIHByaXZhdGVEZWZhdWx0S2V5LCBzZWNyZXRzKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGtleVRvTW9kaWZ5ID09ICdyb290S2V5Jykge1xuICAgICAgICAgICAgICAgIFBCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oXywgdXNlcm5hbWUsIF8sIHByaXZhdGVBZG1pbktleSwgcHJpdmF0ZURlZmF1bHRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgUEIuYWRkQWxpYXModXNlcm5hbWUsIHVzZXJuYW1lLCB1c2VyUmVjb3JkLmNhcGEsIG5ld1ByaXZhdGVLZXksIHByaXZhdGVBZG1pbktleSwgIHByaXZhdGVEZWZhdWx0S2V5LCBzZWNyZXRzKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHVzZXJSZWNvcmQpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoUEIubWFrZUVycm9yKGVycikpXG4gICAgICAgIH0pXG4gICAgfSlcblxuICAgIHJldHVybiBwcm9tXG59XG5cblBCLmdldFByb2ZpbGVQdWZmID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICB2YXIgY2FjaGVkX3Byb2ZpbGUgPSBQQi5EYXRhLnByb2ZpbGVzW3VzZXJuYW1lXVxuICAgIFxuICAgIGlmKGNhY2hlZF9wcm9maWxlKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZF9wcm9maWxlKVxuXG4gICAgdmFyIHByb20gPSBQQi5OZXQuZ2V0UHJvZmlsZVB1ZmYodXNlcm5hbWUpXG5cbiAgICBwcm9tID0gcHJvbS50aGVuKGZ1bmN0aW9uKHB1ZmZzKSB7XG4gICAgICAgIHZhciBwdWZmID0gcHVmZnNbMF1cbiAgICBcbiAgICAgICAgLy8gTk9URTogU2V0dGluZyB0aGlzIHByZXZlbnRzIHVzIGZyb20gcmUtdHJ5aW5nIHRvIGNvbGxlY3QgcHJvZmlsZXMgZnJvbSB1c2VycyB3aG8gZG9uJ3QgaGF2ZSB0aGVtLlxuICAgICAgICAvLyAgICAgICBUaGlzIGlzIGdvb2QsIGJlY2F1c2UgaXQgcHJldmVudHMgbmV0d29yayBub2lzZSwgYnV0IHJlcXVpcmVzIGEgcmVmcmVzaCB0byBzZWUgbmV3IHByb2ZpbGUgaW5mby5cbiAgICAgICAgaWYoIXB1ZmYpXG4gICAgICAgICAgICBwdWZmID0ge3BheWxvYWQ6e319IC8vIFRPRE86IGdldCBhIHByb3BlciBlbXB0eSBwdWZmIGZyb20gc29tZXdoZXJlXG4gICAgICAgIFxuICAgICAgICBQQi5EYXRhLnByb2ZpbGVzW1BCLlVzZXJzLmp1c3RVc2VybmFtZShwdWZmLnVzZXJuYW1lIHx8IHVzZXJuYW1lKV0gPSBwdWZmXG4gICAgXG4gICAgICAgIHJldHVybiBwdWZmXG4gICAgfSlcblxuICAgIHJldHVybiBwcm9tXG59XG5cblxuLy8vLy8vLy8vLy8vLy8gRU5EIFNUQU5EQVJEIEFQSSAvLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4vLy8vLy8vLy8vLy8vLyBIYW5kbGVyIEhhbmRsZXJzIC8vLy8vLy8vLy8vLy8vLy8vL1xuXG5QQi5oYW5kbGVycyA9IHt9XG5cblBCLmFkZEhhbmRsZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaykge1xuICBpZighUEIuaGFuZGxlcnNbdHlwZV0pIFBCLmhhbmRsZXJzW3R5cGVdID0gW11cbiAgUEIuaGFuZGxlcnNbdHlwZV0ucHVzaChjYWxsYmFjaylcbn1cblxuUEIucnVuSGFuZGxlcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gIHJldHVybiAoUEIuaGFuZGxlcnNbdHlwZV0gfHwgW10pLnJlZHVjZShcbiAgICAgIGZ1bmN0aW9uKGFjYywgY2FsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYWNjID09IG51bGwgPyBhcmdzIDogQXJyYXkuaXNBcnJheShhY2MpID8gYWNjIDogW2FjY10pfSwgYXJncylcbn1cblxuUEIubWFrZUhhbmRsZXJIYW5kbGVyID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge3JldHVybiBQQi5hZGRIYW5kbGVyKHR5cGUsIGNhbGxiYWNrKX1cbn1cblxuLy8gVVNFRlVMIEhBTkRMRVJTOlxuXG5QQi5hZGRFcnJvckhhbmRsZXIgICAgICAgICAgID0gUEIubWFrZUhhbmRsZXJIYW5kbGVyKCdlcnJvcicpICAgICAgICAgICAvLyByZWNlaXZlcyBhbGwgZXJyb3IgbWVzc2FnZXNcblxuUEIuYWRkTmV3UHVmZkhhbmRsZXIgICAgICAgICA9IFBCLm1ha2VIYW5kbGVySGFuZGxlcignbmV3UHVmZnMnKSAgICAgICAgLy8gY2FsbGVkIHdoZW4gbmV3IHB1ZmZzIGFyZSBhdmFpbGFibGVcblxuUEIuYWRkREhURXJyb3JIYW5kbGVyICAgICAgICA9IFBCLm1ha2VIYW5kbGVySGFuZGxlcignREhURXJyb3InKSAgICAgICAgLy8gcmVjZWl2ZXMgREhUIGVycm9yIG1lc3NhZ2VzXG5cblBCLmFkZFJlbGF0aW9uc2hpcEhhbmRsZXIgICAgPSBQQi5tYWtlSGFuZGxlckhhbmRsZXIoJ3JlbGF0aW9uc2hpcCcpICAgIC8vIG1hbmFnZSByZWxhdGlvbnNoaXBzIGJldHdlZW4gcHVmZnNcblxuUEIuYWRkVGltZW91dEVycm9ySGFuZGxlciAgICA9IFBCLm1ha2VIYW5kbGVySGFuZGxlcigndGltZW91dEVycm9yJykgICAgLy8gcmVjZWl2ZXMgdGltZW91dCBlcnJvciBtZXNzYWdlc1xuXG5QQi5hZGROZXR3b3JrRXJyb3JIYW5kbGVyICAgID0gUEIubWFrZUhhbmRsZXJIYW5kbGVyKCduZXR3b3JrRXJyb3InKSAgICAvLyByZWNlaXZlcyBuZXR3b3JrIGVycm9yIG1lc3NhZ2VzXG5cblBCLmFkZE5ld1B1ZmZSZXBvcnRIYW5kbGVyICAgPSBQQi5tYWtlSGFuZGxlckhhbmRsZXIoJ25ld1B1ZmZSZXBvcnQnKSAgIC8vIGhhbmRsZXMgcmVwb3J0cyBvbiBpbmNvbWluZyBwdWZmc1xuXG5QQi5hZGRJZGVudGl0eVVwZGF0ZUhhbmRsZXIgID0gUEIubWFrZUhhbmRsZXJIYW5kbGVyKCdpZGVudGl0eVVwZGF0ZScpICAvLyBnZW5lcmFsIEdVSSB1cGRhdGUgdHJpZ2dlclxuXG5QQi5hZGROZXR3b3JrUmVzcG9uc2VIYW5kbGVyID0gUEIubWFrZUhhbmRsZXJIYW5kbGVyKCduZXR3b3JrcmVzcG9uc2UnKSAvLyByZWNlaXZlcyBhbGwgbmV0d29yayByZXNwb25zZVxuXG5QQi5hZGRQYXlsb2FkTW9kaWZpZXJIYW5kbGVyID0gUEIubWFrZUhhbmRsZXJIYW5kbGVyKCdwYXlsb2FkTW9kaWZpZXInKSAvLyBkZWNvcmF0ZSBwdWZmIHBheWxvYWRzIFxuXG4vLyBQQi5hZGRDbGVhclB1ZmZDYWNoZUhhbmRsZXIgPSBQQi5tYWtlSGFuZGxlckhhbmRsZXIoJ2NsZWFycHVmZmNhY2hlJylcblxuLy8gYmVmb3JlU3dpdGNoSWRlbnRpdHkgaXMgY2FsbGVkIHByaW9yIHRvIHN3aXRjaElkZW50aXR5IGFuZCByZW1vdmVJZGVudGl0eSwgd2hpbGUgdGhlIG9sZCBpZGVudGl0eSBpcyBhY3RpdmVcbi8vIGFmdGVyU3dpdGNoSWRlbnRpdHkgIGlzIGNhbGxlZCBhZnRlciBzd2l0Y2hJZGVudGl0eSwgb25jZSB0aGUgbmV3IGlkZW50aXR5IGlzIGFjdGl2ZVxuUEIuYWRkQmVmb3JlU3dpdGNoSWRlbnRpdHlIYW5kbGVyID0gUEIubWFrZUhhbmRsZXJIYW5kbGVyKCdiZWZvcmVTd2l0Y2hJZGVudGl0eScpXG5QQi5hZGRBZnRlclN3aXRjaElkZW50aXR5SGFuZGxlciAgPSBQQi5tYWtlSGFuZGxlckhhbmRsZXIoJ2FmdGVyU3dpdGNoSWRlbnRpdHknKVxuXG4vLy8vLy8vLy8vLy8vLyBFbmQgSGFuZGxlciBIYW5kbGVycyAvLy8vLy8vLy8vLy8vL1xuXG5cblxuXG4vLy8vIFBVRkYgSEVMUEVSUyAvLy8vXG5cblxuUEIuc2ltcGxlQnVpbGRQdWZmID0gZnVuY3Rpb24odHlwZSwgY29udGVudCwgcGF5bG9hZCwgcm91dGVzLCB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHQsIHByaXZhdGVFbnZlbG9wZUFsaWFzKSB7XG4gICAgLy8vLyBidWlsZCBhIHB1ZmYgZm9yIHRoZSAnY3VycmVudCB1c2VyJywgYXMgZGV0ZXJtaW5lZCBieSB0aGUga2V5IG1hbmFnZXIgKGJ5IGRlZmF1bHQgUEIuTS5XYXJkcm9iZSlcbiAgICB2YXIgcHVmZiBcblxuICAgIHBheWxvYWQgPSBQQi5ydW5IYW5kbGVycygncGF5bG9hZE1vZGlmaWVyJywgcGF5bG9hZClcblxuICAgIFBCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oaWRlbnRpdGllcywgY3VycmVudFVzZXJuYW1lLCBwcml2YXRlUm9vdEtleSwgcHJpdmF0ZUFkbWluS2V5LCBwcml2YXRlRGVmYXVsdEtleSkge1xuICAgICAgICAvLyBUSElOSzogc2hvdWxkIHdlIGNvbmZpcm0gdGhhdCBvdXIgbG9jYWwgY2FwYSBtYXRjaGVzIHRoZSBESFQncyBsYXRlc3QgY2FwYSBmb3IgdGhlIGN1cnJlbnQgdXNlciBoZXJlPyBpdCB0dXJucyB0aGUgb3V0cHV0IGludG8gYSBwcm9taXNlLi4uXG4gICAgICAgIHZhciBwcmV2aW91cyA9IGZhbHNlIC8vIFRPRE86IGdldCB0aGUgc2lnIG9mIHRoaXMgdXNlcidzIGxhdGVzdCBwdWZmXG4gICAgICAgIHZhciB2ZXJzaW9uZWRVc2VybmFtZSA9IFBCLmdldEN1cnJlbnRWZXJzaW9uZWRVc2VybmFtZSgpXG4gICAgICAgIFxuICAgICAgICBwdWZmID0gUEIuYnVpbGRQdWZmKHZlcnNpb25lZFVzZXJuYW1lLCBwcml2YXRlRGVmYXVsdEtleSwgcm91dGVzLCB0eXBlLCBjb250ZW50LCBwYXlsb2FkLCBwcmV2aW91cywgdXNlclJlY29yZHNGb3JXaG9tVG9FbmNyeXB0LCBwcml2YXRlRW52ZWxvcGVBbGlhcylcbiAgICB9KVxuICAgIFxuICAgIHJldHVybiBwdWZmXG59XG5cblxuLyoqXG4gKiBidWlsZCBhIG5ldyBwdWZmIG9iamVjdCBiYXNlZCBvbiB0aGUgcGFyYW1ldGVycyAgXG4gKiBkb2VzIG5vdCBoaXQgdGhlIG5ldHdvcmssIGhlbmNlIGRvZXMgbm8gcmVhbCB2ZXJpZmljYXRpb24gd2hhdHNvZXZlclxuICogQHBhcmFtICB7c3RyaW5nfSB1c2VybmFtZSAgICAgICAgICAgICAgICAgICAgdXNlciB3aG8gc2lnbiB0aGUgcHVmZlxuICogQHBhcmFtICB7c3RyaW5nfSBwcml2YXRlS2V5ICAgICAgICAgICAgICAgICAgcHJpdmF0ZSBkZWZhdWx0IGtleSBmb3IgdGhlIHVzZXJcbiAqIEBwYXJhbSAge3N0cmluZ30gcm91dGVzICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcyBvZiB0aGUgcHVmZlxuICogQHBhcmFtICB7c3RyaW5nfSB0eXBlICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSBvZiB0aGUgcHVmZlxuICogQHBhcmFtICB7c3RyaW5nfSBjb250ZW50ICAgICAgICAgICAgICAgICAgICAgY29udGVudCBvZiB0aGUgcHVmZlxuICogQHBhcmFtICB7b2JqZWN0fSBwYXlsb2FkICAgICAgICAgICAgICAgICAgICAgb3RoZXIgcGF5bG9hZCBpbmZvcm1hdGlvbiBmb3IgdGhlIHB1ZmZcbiAqIEBwYXJhbSAge3N0cmluZ30gcHJldmlvdXMgICAgICAgICAgICAgICAgICAgIG1vc3QgcmVjZW50bHkgcHVibGlzaGVkIGNvbnRlbnQgYnkgdGhlIHVzZXJcbiAqIEBwYXJhbSAge29iamVjdH0gdXNlclJlY29yZHNGb3JXaG9tVG9FbmNyeXB0XG4gKiBAcGFyYW0gIHtvYmplY3R9IHByaXZhdGVFbnZlbG9wZUFsaWFzXG4gKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmV3IHB1ZmYgb2JqZWN0XG4gKi9cblBCLmJ1aWxkUHVmZiA9IGZ1bmN0aW9uKHZlcnNpb25lZFVzZXJuYW1lLCBwcml2YXRlS2V5LCByb3V0ZXMsIHR5cGUsIGNvbnRlbnQsIHBheWxvYWQsIHByZXZpb3VzLCB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHQsIHByaXZhdGVFbnZlbG9wZUFsaWFzKSB7XG4gICAgdmFyIHB1ZmYgPSBQQi5EYXRhLnBhY2thZ2VQdWZmU3RydWN0dXJlKHZlcnNpb25lZFVzZXJuYW1lLCByb3V0ZXMsIHR5cGUsIGNvbnRlbnQsIHBheWxvYWQsIHByZXZpb3VzKVxuXG4gICAgcHVmZi5zaWcgPSBQQi5DcnlwdG8uc2lnblB1ZmYocHVmZiwgcHJpdmF0ZUtleSlcbiAgICBcbiAgICBpZih1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHQpIHtcbiAgICAgICAgcHVmZiA9IFBCLkRhdGEuZW5jcnlwdFB1ZmYocHVmZiwgcHJpdmF0ZUtleSwgdXNlclJlY29yZHNGb3JXaG9tVG9FbmNyeXB0LCBwcml2YXRlRW52ZWxvcGVBbGlhcylcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHB1ZmZcbn1cblxuXG4vKipcbiAqIGhhbmRsZSBhIG5ld2x5IGNyZWF0ZWQgcHVmZjogYWRkIHRvIG91ciBsb2NhbCBjYWNoZSBhbmQgZmlyZSBuZXcgY29udGVudCBjYWxsYmFja3NcbiAqIEBwYXJhbSB7b2JqZWN0fSBwdWZmXG4gKi9cblBCLmFkZFB1ZmZUb1N5c3RlbSA9IGZ1bmN0aW9uKHB1ZmYpIHtcbiAgICBpZihQQi5EYXRhLmdldENhY2hlZFNoZWxsQnlTaWcocHVmZi5zaWcpKSByZXR1cm4gZmFsc2VcbiAgICBcbiAgICBQQi5EYXRhLmFkZFNoZWxsc1RoZW5NYWtlQXZhaWxhYmxlKHB1ZmYpXG5cbiAgICBQQi5OZXQuZGlzdHJpYnV0ZVB1ZmYocHVmZilcbiAgICBcbiAgICByZXR1cm4gcHVmZlxufVxuXG5cblBCLmRlY3J5cHRQdWZmRm9yUmVhbHMgPSBmdW5jdGlvbihlbnZlbG9wZSwgeW91clB1YmxpY1dpZiwgbXlWZXJzaW9uZWRVc2VybmFtZSwgbXlQcml2YXRlV2lmKSB7XG4gICAgLy8vLyBpbnRlcmZhY2Ugd2l0aCBQQi5DcnlwdG8gZm9yIGRlY3J5cHRpbmcgYSBtZXNzYWdlXG4gICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgaW4gUEIuRGF0YSwgYnV0IGlzIGluIFBCIGZvciBjcnlwdG93b3JrZXIncyBzYWtlXG4gICAgaWYoIWVudmVsb3BlLmtleXMpIHJldHVybiBmYWxzZVxuICAgIHZhciBrZXlGb3JNZSA9IGVudmVsb3BlLmtleXNbbXlWZXJzaW9uZWRVc2VybmFtZV1cbiAgICB2YXIgcHVmZmtleSAgPSBQQi5DcnlwdG8uZGVjcnlwdFByaXZhdGVNZXNzYWdlKGtleUZvck1lLCB5b3VyUHVibGljV2lmLCBteVByaXZhdGVXaWYpXG4gICAgdmFyIGxldHRlckNpcGhlciA9IGVudmVsb3BlLnBheWxvYWQuY29udGVudFxuICAgIHZhciBsZXR0ZXJTdHJpbmcgPSBQQi5DcnlwdG8uZGVjcnlwdFdpdGhBRVMobGV0dGVyQ2lwaGVyLCBwdWZma2V5KVxuICAgIHZhciBiZXR0ZXJTdHJpbmcgPSBQQi50cnlEZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGxldHRlclN0cmluZykpICAgLy8gdHJ5IGRlY29kaW5nXG4gICAgcmV0dXJuIFBCLnBhcnNlSlNPTihiZXR0ZXJTdHJpbmcpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkgcGFyc2luZ1xufVxuXG5cblxuLy8vLyBJRCBGSUxFIChMT0dJTiArIEZPUk1BVCkgLy8vL1xuXG5cblBCLmxvZ2luID0gZnVuY3Rpb24odXNlcm5hbWUsIHByaXZhdGVLZXkpIHtcbiAgICAvLy8vIHByaXZhdGVLZXkgaXMgdGhlIGtleSBmb3IgeW91ciBpZGVudGl0eSBmaWxlXG4gICAgXG4gICAgLy8gVE9ETzogaGFuZGxlIG9mZmxpbmUgY2FzZS4uLlxuICAgIC8vIFRPRE86IGVuY3J5cHRlZCBsb2NhbFN0b3JhZ2UgaWRlbnRpdHkgZmlsZXNcbiAgICAvLyBUT0RPOiBjYWNoZSBlbmNyeXB0ZWQgcHVmZnMgaW4gbG9jYWxTdG9yYWdlXG4gICAgLy8gVE9ETzogZ3JhYiB0aGUgdXNlciByZWNvcmQgZnJvbSBQQi5sb2dpbldpdGhQYXNzcGhyYXNlXG4gICAgXG4gICAgdXNlcnByb20gPSBQQi5Vc2Vycy5nZXRVc2VyUmVjb3JkTm9DYWNoZSh1c2VybmFtZSlcbiAgICBcbiAgICByZXR1cm4gdXNlcnByb20udGhlbihmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgICAgIGlmKCF1c2VyUmVjb3JkKVxuICAgICAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ0NvdWxkIG5vdCBhY2Nlc3MgdXNlciByZWNvcmQnKVxuICAgICAgICBcbiAgICAgICAgdmFyIGlkZW50aXR5U2lnID0gdXNlclJlY29yZC5pZGVudGl0eVxuICAgICAgICBcbiAgICAgICAgaWYoaWRlbnRpdHlTaWcpIHtcbiAgICAgICAgICAgIHZhciBkZWNyeXB0cHJvbSA9IFBCLlVzZXJzLmdldElkZW50aXR5UHVmZih1c2VyUmVjb3JkLCBwcml2YXRlS2V5KVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gZGVjcnlwdHByb20udGhlbihmdW5jdGlvbihsZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZihsZXR0ZXIgJiYgbGV0dGVyLnBheWxvYWQgJiYgbGV0dGVyLnBheWxvYWQuY29udGVudClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBCLmxvZ2luV2l0aElkZW50aXR5RmlsZShsZXR0ZXIucGF5bG9hZC5jb250ZW50KVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBCLnRocm93RXJyb3IoJ0ludmFsaWQgcGFzc3dvcmQnKSAvLyBUSElOSzogdGhpcyBjb3VsZCBoYXBwZW4gZm9yIG90aGVyIHJlYXNvbnNcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBQQi5jYXRjaEVycm9yKCdDb3VsZCBub3QgYWNjZXNzIGlkZW50aXR5IGZpbGUnKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gbm8gaWRlbnRpdHkgcHVmZiwgc28gdHJ5IGl0IHRoZSBvbGQgZmFzaGlvbmVkIHdheVxuICAgICAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgaW4gdG8gYSBoZWxwZXIgZnVuY3Rpb25cbiAgICAgICAgdmFyIHB1YmxpY0tleSA9IFBCLkNyeXB0by5wcml2YXRlVG9QdWJsaWMocHJpdmF0ZUtleSlcbiAgICAgICAgXG4gICAgICAgIGlmKCAodXNlclJlY29yZC5kZWZhdWx0S2V5ICE9IHB1YmxpY0tleSkgXG4gICAgICAgICAmJiAodXNlclJlY29yZC5hZG1pbktleSAgICE9IHB1YmxpY0tleSkgXG4gICAgICAgICAmJiAodXNlclJlY29yZC5yb290S2V5ICAgICE9IHB1YmxpY0tleSkgKVxuICAgICAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ1RoYXQgdXNlciByZWNvcmQgaGFzIG5vIGlkZW50aXR5IGZpbGUsIGFuZCB0aGUgcHVibGljIGtleSBwcm92aWRlZCBkb2VzIG5vdCBtYXRjaCcpXG4gICAgXG4gICAgICAgIHZhciBzZWNyZXRzID0ge30gLy8ge3Bhc3NwaHJhc2U6IHBhc3NwaHJhc2V9IC8vIFRISU5LOiBtYXliZSBtb3ZlIHRoaXMgdXAgYSBsZXZlbCB0byBsb2dpbldpdGhQYXNzcGhyYXNlXG4gICAgICAgIFBCLmFkZEFsaWFzKHVzZXJuYW1lLCB1c2VybmFtZSwgdXNlclJlY29yZC5jYXBhLCBwcml2YXRlS2V5LCBwcml2YXRlS2V5LCBwcml2YXRlS2V5LCBzZWNyZXRzKVxuXG4gICAgICAgIFBCLnN3aXRjaElkZW50aXR5VG8odXNlcm5hbWUpXG4gICAgICAgIFxuICAgICAgICBQQi5zdG9yZUlkZW50aXR5RmlsZUluQ2xvdWQoKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxufVxuXG5QQi5sb2dpbldpdGhJZGVudGl0eUZpbGUgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAvLy8vIHRha2VzIGEgY2Fub25pY2FsIGlkZW50aXR5IGZpbGUgb2JqZWN0LCBhZGRzIGl0IHRvIHRoZSB3YXJkcm9iZSwgYW5kIHNpZ25zIHlvdSBpblxuICAgIFxuICAgIHZhciB1c2VybmFtZSA9IG9iamVjdC51c2VybmFtZVxuICAgIHZhciBhbGlhc2VzICA9IG9iamVjdC5hbGlhc2VzXG4gICAgdmFyIHByZWZlcmVuY2VzID0gb2JqZWN0LnByZWZlcmVuY2VzXG4gICAgXG4gICAgaWYoIXVzZXJuYW1lIHx8ICFhbGlhc2VzIHx8ICFwcmVmZXJlbmNlcylcbiAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ1RoYXQgaXMgbm90IGEgdmFsaWQgaWRlbnRpdHkgb2JqZWN0JylcbiAgICBcbiAgICBQQi5jdXJyZW50SWRlbnRpdHlIYXNoID0gUEIuQ3J5cHRvLmNyZWF0ZU1lc3NhZ2VIYXNoKEpTT04uc3RyaW5naWZ5KG9iamVjdCkpXG4gICAgXG4gICAgUEIuYWRkSWRlbnRpdHkodXNlcm5hbWUsIGFsaWFzZXMsIHByZWZlcmVuY2VzKVxuICAgIFxuICAgIHJldHVybiBQQi5zd2l0Y2hJZGVudGl0eVRvKHVzZXJuYW1lKVxufVxuXG5QQi5sb2dpbldpdGhQYXNzcGhyYXNlID0gZnVuY3Rpb24odXNlcm5hbWUsIHBhc3NwaHJhc2UsIGxlZ2FjeSkge1xuICAgIC8vIEZpcnN0IGF0dGVtcHQgdG8gcHJlcGVuZCB1c2VybmFtZSB0byBwYXNzcGhyYXNlXG4gICAgLy8gSWYgZmFpbHMsIHRoZW4gdHJ5IGp1c3QgdXNpbmcgdGhlIHBhc3NwaHJhc2VcbiAgICB2YXIgcGFzcyA9IGxlZ2FjeSA/IHBhc3NwaHJhc2UgOiB1c2VybmFtZSArIHBhc3NwaHJhc2VcblxuICAgIHZhciBwcml2YXRlS2V5ID0gUEIuQ3J5cHRvLnBhc3NwaHJhc2VUb1ByaXZhdGVLZXlXaWYocGFzcylcbiAgICB2YXIgcHVibGljS2V5ID0gUEIuQ3J5cHRvLnByaXZhdGVUb1B1YmxpYyhwcml2YXRlS2V5KVxuXG4gICAgdmFyIHVzZXJwcm9tID0gUEIuVXNlcnMuZ2V0VXNlclJlY29yZE5vQ2FjaGUodXNlcm5hbWUpXG5cbiAgICByZXR1cm4gdXNlcnByb20udGhlbihmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgICAgIGlmKCF1c2VyUmVjb3JkKVxuICAgICAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ0NvdWxkIG5vdCBhY2Nlc3MgdXNlciByZWNvcmQnKVxuICAgICAgICBcbiAgICAgICAgaWYoICh1c2VyUmVjb3JkLmRlZmF1bHRLZXkgIT0gcHVibGljS2V5KSBcbiAgICAgICAgICYmICh1c2VyUmVjb3JkLmFkbWluS2V5ICAgIT0gcHVibGljS2V5KSBcbiAgICAgICAgICYmICh1c2VyUmVjb3JkLnJvb3RLZXkgICAgIT0gcHVibGljS2V5KSApXG4gICAgICAgICAgICByZXR1cm4gKGxlZ2FjeSkgPyBmYWxzZSA6IFBCLmxvZ2luV2l0aFBhc3NwaHJhc2UodXNlcm5hbWUsIHBhc3NwaHJhc2UsIHRydWUpXG5cbiAgICAgICAgcmV0dXJuIFBCLmxvZ2luKHVzZXJuYW1lLCBwcml2YXRlS2V5KVxuICAgIH0pXG59XG5cblxuUEIuc3RvcmVJZGVudGl0eUZpbGVJbkNsb3VkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYoIVBCLmN1cnJlbnRJZGVudGl0eUhhc2gpIHtcbiAgICAgICAgLy8gVEhJTks6IHVzZXIgZGlkIG5vdCBsb2cgaW4gd2l0aCBpZGVudGl0eSBmaWxlLi4uIHNvIHdoYXQgc2hvdWxkIHdlIGRvIGhlcmU/XG4gICAgfVxuXG4gICAgLy8gZ2V0IGlkZW50aXR5IGZpbGVcbiAgICB2YXIgY29udGVudCA9IFBCLmZvcm1hdElkZW50aXR5RmlsZSgpXG4gICAgaWYoIWNvbnRlbnQpIHJldHVybiBmYWxzZVxuICAgIFxuICAgIC8vIGNoZWNrIGFnYWluc3QgbGF0ZXN0XG4gICAgdmFyIG5ld0lkZW50aXR5SGFzaCA9IFBCLkNyeXB0by5jcmVhdGVNZXNzYWdlSGFzaChKU09OLnN0cmluZ2lmeShjb250ZW50KSlcbiAgICBpZihQQi5jdXJyZW50SWRlbnRpdHlIYXNoID09IG5ld0lkZW50aXR5SGFzaCkgcmV0dXJuIGZhbHNlXG4gICAgUEIuY3VycmVudElkZW50aXR5SGFzaCA9IG5ld0lkZW50aXR5SGFzaFxuICAgIFxuICAgIC8vIHBhY2thZ2UgYXMgZW5jcnlwdGVkIHB1ZmZcbiAgICB2YXIgcGF5bG9hZCA9IHt9XG4gICAgdmFyIHJvdXRlcyAgPSBbXVxuICAgIHZhciB0eXBlICAgID0gJ2lkZW50aXR5J1xuICAgICAgICBcbiAgICB2YXIgdXNlclJlY29yZCA9IFBCLmdldEN1cnJlbnRVc2VyUmVjb3JkKClcbiAgICB2YXIgdXNlclJlY29yZHNGb3JXaG9tVG9FbmNyeXB0ID0gW3VzZXJSZWNvcmRdXG5cbiAgICBpZighdXNlclJlY29yZCkgcmV0dXJuIGZhbHNlXG5cbiAgICAvLyBUSElOSzogdXNpbmcgc2ltcGxlQnVpbGRQdWZmIHB1dHMgYSB0aW1lc3RhbXAgaW4gdGhlIGlkZW50aXR5IGZpbGUuLi5cbiAgICB2YXIgcHVmZiA9IFBCLnNpbXBsZUJ1aWxkUHVmZih0eXBlLCBjb250ZW50LCBwYXlsb2FkLCByb3V0ZXMsIHVzZXJSZWNvcmRzRm9yV2hvbVRvRW5jcnlwdClcbiAgICBcbiAgICBpZighcHVmZikgcmV0dXJuIGZhbHNlXG4gICAgICAgIFxuICAgIC8vIGlmKHB1ZmYuc2lnID09IHVzZXJSZWNvcmQuaWRlbnRpdHkpIHJldHVybiBmYWxzZSAvLyBhbHdheXMgZmFsc2UsIGJlY2F1c2Ugb2YgdGhlIHRpbWVzdGFtcCAtLSBpZiB5b3UgcmVtb3ZlIGl0LCBhZGQgdGhpcyBiYWNrXG4gICAgXG4gICAgUEIuTmV0LmRpc3RyaWJ1dGVQdWZmKHB1ZmYpICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbmQgaXQgdG8gdGhlIHNlcnZlclxuICAgIFxuICAgIC8vIHVwZGF0ZSB1c2VyIHJlY29yZFxuICAgIHZhciBwYXlsb2FkID0ge30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiB0aGUgZG91YmxlIFwidmFyXCJzIGRvbid0IGh1cnQsIGFuZCBoZWxwIGtlZXAgdXMgZm9jdXNlZFxuICAgIHZhciByb3V0ZXMgID0gW11cbiAgICB2YXIgdHlwZSAgICA9ICd1cGRhdGVVc2VyUmVjb3JkJ1xuICAgIHZhciBjb250ZW50ID0gJ3NldElkZW50aXR5J1xuICAgIHZhciB1cGRhdGVfcHVmZlxuXG4gICAgcGF5bG9hZC5pZGVudGl0eSA9IHB1ZmYuc2lnXG5cbiAgICBQQi51c2VTZWN1cmVJbmZvKGZ1bmN0aW9uKF8sIGN1cnJlbnRVc2VybmFtZSwgXywgcHJpdmF0ZUFkbWluS2V5LCBfKSB7XG4gICAgICAgIGlmKCFwcml2YXRlQWRtaW5LZXkpXG4gICAgICAgICAgICByZXR1cm4gUEIub25FcnJvcignWW91IG11c3QgaGF2ZSBhbiBhZG1pbmlzdHJhdGl2ZSBrZXkgdG8gdXBsb2FkIHlvdXIgaWRlbnRpdHkgZmlsZScpXG4gICAgICAgIFxuICAgICAgICB1cGRhdGVfcHVmZiA9IFBCLmJ1aWxkUHVmZihjdXJyZW50VXNlcm5hbWUsIHByaXZhdGVBZG1pbktleSwgcm91dGVzLCB0eXBlLCBjb250ZW50LCBwYXlsb2FkKVxuICAgIH0pXG4gICAgXG4gICAgaWYoIXVwZGF0ZV9wdWZmKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICBcbiAgICB2YXIgdXBkYXRlX3Byb20gPSBQQi5OZXQudXBkYXRlVXNlclJlY29yZCh1cGRhdGVfcHVmZilcbiAgICAgICAgXG4gICAgcmV0dXJuIHVwZGF0ZV9wcm9tXG59XG5cblBCLmZvcm1hdElkZW50aXR5RmlsZSA9IGZ1bmN0aW9uKHVzZXJuYW1lKSB7XG4gICAgLy8gVEhJTks6IGNvbnNpZGVyIHBhc3NwaHJhc2UgcHJvdGVjdGluZyB0aGUgaWRlbnRpdHkgZmlsZSBieSBkZWZhdWx0XG4gICAgLy8gVE9ETzogYWRkIGF1dGhGcm9tSWRGaWxlIC0tIG5lZWQgY29uc2lzdGVuY3kgYm90aCB3YXlzXG4gICAgXG4gICAgdXNlcm5hbWUgPSB1c2VybmFtZSB8fCBQQi5nZXRDdXJyZW50VXNlcm5hbWUoKVxuICAgIFxuICAgIGlmKCF1c2VybmFtZSkgcmV0dXJuIGZhbHNlXG5cbiAgICB2YXIgaWRGaWxlID0ge31cblxuICAgIFBCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oaWRlbnRpdGllcywgY3VycmVudFVzZXJuYW1lLCBwcml2YXRlUm9vdEtleSwgcHJpdmF0ZUFkbWluS2V5LCBwcml2YXRlRGVmYXVsdEtleSkge1xuICAgICAgICAvLyB0aGlzIGxlYWtzIGFsbCBvZiB0aGUgaWRlbnRpdHkgaW5mb3JtYXRpb24gYmFjayB0byB0aGUgY2FsbGVyXG4gICAgICAgIC8vIGlmIHdlIHBhc3NwaHJhc2UgcHJvdGVjdCB0aGUgZmlsZSwgZG8gaXQgaGVyZSB0byBwcmV2ZW50IHRoYXQgbGVha2FnZVxuXG4gICAgICAgIHZhciBpZGVudGl0eSA9IGlkZW50aXRpZXNbdXNlcm5hbWVdXG5cbiAgICAgICAgLy8gYXNzZW1ibGUgaWRGaWxlIG1hbnVhbGx5IHRvIGtlZXAgZXZlcnl0aGluZyBpbiB0aGUgcmlnaHQgb3JkZXJcbiAgICAgICAgLy8gaWRGaWxlLmNvbW1lbnQgPSBcIlRoaXMgZmlsZSBjb250YWlucyB5b3VyIHByaXZhdGUgcGFzc3BocmFzZS4gSXQgd2FzIGdlbmVyYXRlZCBhdCBpLmN4LiBUaGUgaW5mb3JtYXRpb24gaGVyZSBjYW4gYmUgdXNlZCB0byBsb2dpbiB0byB3ZWJzaXRlcyBvbiB0aGUgcHVmZmJhbGwuaW8gcGxhdGZvcm0uIEtlZXAgdGhpcyBmaWxlIHNhZmUgYW5kIHNlY3VyZSFcIlxuXG4gICAgICAgIGlkRmlsZS51c2VybmFtZSA9IHVzZXJuYW1lXG4gICAgICAgIC8vIGlkRmlsZS5wcmltYXJ5ICA9IGlkZW50aXR5LnByaW1hcnkgLy8gTk9URTogcHJpbWFyeSBpcyBhdXRvbWF0aWNhbGx5IGdhdGhlcmVkIGZyb20gYWxpYXNlc1xuICAgICAgICBpZEZpbGUuYWxpYXNlcyAgPSBpZGVudGl0eS5hbGlhc2VzXG4gICAgICAgIGlkRmlsZS5wcmVmZXJlbmNlcyA9IGlkZW50aXR5LnByZWZlcmVuY2VzXG4gICAgICAgIGlkRmlsZS52ZXJzaW9uICA9IFwiMS4xXCJcbiAgICB9KVxuXG4gICAgcmV0dXJuIGlkRmlsZVxufVxuXG5cblxuLy8vLyBVU0VSIENSRUFUSU9OIC8vLy9cblxuLyoqXG4gKiByZWdpc3RlciBhIHN1YnVzZXJcbiAqIEBwYXJhbSAge3N0cmluZ30gc2lnbmluZ1VzZXJuYW1lIHVzZXJuYW1lIG9mIGV4aXN0ZWQgdXNlclxuICogQHBhcmFtICB7c3RyaW5nfSBwcml2YXRlQWRtaW5LZXkgcHJpdmF0ZSBhZG1pbiBrZXkgZm9yIGV4aXN0ZWQgdXNlclxuICogQHBhcmFtICB7c3RyaW5nfSBuZXdVc2VybmFtZSAgICAgZGVzaXJlZCBuZXcgc3VidXNlciBuYW1lXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RLZXkgICAgICAgICBwdWJsaWMgcm9vdCBrZXkgZm9yIHRoZSBuZXcgc3VidXNlclxuICogQHBhcmFtICB7c3RyaW5nfSBhZG1pbktleSAgICAgICAgcHVibGljIGFkbWluIGtleSBmb3IgdGhlIG5ldyBzdWJ1c2VyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGRlZmF1bHRLZXkgICAgICBwdWJsaWMgZGVmYXVsdCBrZXkgZm9yIHRoZSBuZXcgc3VidXNlclxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICB1c2VyIHJlY29yZCBmb3IgdGhlIG5ld2x5IGNyZWF0ZWQgc3VidXNlclxuICovXG5QQi5yZWdpc3RlclN1YnVzZXJGb3JVc2VyID0gZnVuY3Rpb24oc2lnbmluZ1VzZXJuYW1lLCBwcml2YXRlQWRtaW5LZXksIG5ld1VzZXJuYW1lLCByb290S2V5LCBhZG1pbktleSwgZGVmYXVsdEtleSkge1xuXG4gICAgLy8gYnVpbGQgb3VyIERIVCB1cGRhdGUgcHVmZlxuICAgIHZhciBwYXlsb2FkID0geyByZXF1ZXN0ZWRVc2VybmFtZTogbmV3VXNlcm5hbWVcbiAgICAgICAgICAgICAgICAgICwgICAgICAgIGRlZmF1bHRLZXk6IGRlZmF1bHRLZXlcbiAgICAgICAgICAgICAgICAgICwgICAgICAgICAgYWRtaW5LZXk6IGFkbWluS2V5XG4gICAgICAgICAgICAgICAgICAsICAgICAgICAgICByb290S2V5OiByb290S2V5XG4gICAgICAgICAgICAgICAgICAsICAgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICB2YXIgcm91dGluZyA9IFtdIC8vIFRISU5LOiBESFQ/XG4gICAgdmFyIGNvbnRlbnQgPSAncmVxdWVzdFVzZXJuYW1lJ1xuICAgIHZhciB0eXBlICAgID0gJ3VwZGF0ZVVzZXJSZWNvcmQnXG5cbiAgICB2YXIgcHVmZiA9IFBCLmJ1aWxkUHVmZihzaWduaW5nVXNlcm5hbWUsIHByaXZhdGVBZG1pbktleSwgcm91dGluZywgdHlwZSwgY29udGVudCwgcGF5bG9hZClcbiAgICAvLyBOT1RFOiB3ZSdyZSBza2lwcGluZyBwcmV2aW91cywgYmVjYXVzZSByZXF1ZXN0VXNlcm5hbWUtc3R5bGUgcHVmZnMgZG9uJ3QgdXNlIGl0LlxuXG4gICAgcmV0dXJuIFBCLk5ldC51cGRhdGVVc2VyUmVjb3JkKHB1ZmYpXG59XG5cblxuXG5cbi8vLy8gQlVJTEQgQ1JZUFRPIFdPUktFUiAvLy8vXG5cblBCLmJ1aWxkQ3J5cHRvd29ya2VyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBjcnlwdG93b3JrZXJVUkwgPSBvcHRpb25zLmNyeXB0b3dvcmtlclVSTCB8fCBQQi5DT05GSUcuY3J5cHRvd29ya2VyVVJMIC8vIHx8ICdjcnlwdG93b3JrZXIuanMnXG4gICAgXG4gICAgaWYoIWNyeXB0b3dvcmtlclVSTCkgcmV0dXJuIGZhbHNlXG4gICAgXG4gICAgUEIuY3J5cHRvd29ya2VyID0gbmV3IFdvcmtlcihjcnlwdG93b3JrZXJVUkwpXG4gICAgUEIuY3J5cHRvd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIFBCLndvcmtlcnJlY2VpdmUpXG59XG5cblBCLndvcmtlcnF1ZXVlID0gW11cblBCLndvcmtlcmF1dG9pZCA9IDBcblxuUEIud29ya2VycmVjZWl2ZSA9IGZ1bmN0aW9uKG1zZykge1xuICAgIHZhciBpZCA9IG1zZy5kYXRhLmlkXG4gICAgaWYoIWlkKSByZXR1cm4gZmFsc2UgLy8gVE9ETzogYWRkIG9uRXJyb3IgaGVyZVxuXG4gICAgdmFyIGZ1biA9IFBCLndvcmtlcnF1ZXVlW2lkXVxuICAgIGlmKCFmdW4pIHJldHVybiBmYWxzZSAvLyBUT0RPOiBhZGQgb25FcnJvciBoZXJlXG5cbiAgICBmdW4obXNnLmRhdGEuZXZhbHVhdGVkKVxuXG4gICAgZGVsZXRlIFBCLndvcmtlcnF1ZXVlW2lkXSAvLyBUSElOSzogdGhpcyBsZWF2ZXMgYSBzcGFyc2UgYXJyYXksIGJ1dCBpcyBwcm9iYWJseSBmYXN0ZXIgdGhhbiBzcGxpY2luZ1xufVxuXG5QQi53b3JrZXJzZW5kID0gZnVuY3Rpb24oZnVuc3RyLCBhcmdzLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICBQQi53b3JrZXJhdXRvaWQgKz0gMVxuICAgIFBCLndvcmtlcnF1ZXVlW1BCLndvcmtlcmF1dG9pZF0gPSByZXNvbHZlXG4gICAgaWYoIUFycmF5LmlzQXJyYXkoYXJncykpXG4gICAgICAgIGFyZ3MgPSBbYXJnc11cbiAgICBQQi5jcnlwdG93b3JrZXIucG9zdE1lc3NhZ2Uoe2Z1bjogZnVuc3RyLCBhcmdzOiBhcmdzLCBpZDogUEIud29ya2VyYXV0b2lkfSlcbn1cblxuLy8vLyBFTkQgQlVJTEQgQ1JZUFRPIFdPUktFUiAvLy8vXG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vIFNFQ1VSRSBJTkZPUk1BVElPTiBJTlRFUkZBQ0UgLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuUEIuaW1wbGVtZW50U2VjdXJlSW50ZXJmYWNlID0gZnVuY3Rpb24odXNlU2VjdXJlSW5mbywgYWRkSWRlbnRpdHksIGFkZEFsaWFzLCBzZXRQcmltYXJ5QWxpYXMsIHNldFByZWZlcmVuY2UsIHN3aXRjaElkZW50aXR5VG8sIHJlbW92ZUlkZW50aXR5KSB7XG4gICAgLy8gdXNlU2VjdXJlSW5mbyAgICA9IGZ1bmN0aW9uKCBmdW5jdGlvbihpZGVudGl0aWVzLCB1c2VybmFtZSwgcHJpdmF0ZVJvb3RLZXksIHByaXZhdGVBZG1pbktleSwgcHJpdmF0ZURlZmF1bHRLZXkpIClcbiAgICAvLyBhZGRJZGVudGl0eSAgICAgID0gZnVuY3Rpb24odXNlcm5hbWUsIGFsaWFzZXMsIHByZWZlcmVuY2VzKVxuICAgIC8vIGFkZEFsaWFzICAgICAgICAgPSBmdW5jdGlvbihpZGVudGl0eVVzZXJuYW1lLCBhbGlhc1VzZXJuYW1lLCBjYXBhLCBwcml2YXRlUm9vdEtleSwgcHJpdmF0ZUFkbWluS2V5LCBwcml2YXRlRGVmYXVsdEtleSwgc2VjcmV0cylcbiAgICAvLyBzZXRQcmltYXJ5QWxpYXMgID0gZnVuY3Rpb24oaWRlbnRpdHlVc2VybmFtZSwgYWxpYXNVc2VybmFtZSlcbiAgICAvLyByZW1vdmVJZGVudGl0eSAgID0gZnVuY3Rpb24odXNlcm5hbWUpXG4gICAgLy8gc2V0UHJlZmVyZW5jZSAgICA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIC8vIGZvciBjdXJyZW50IGlkZW50aXR5XG4gICAgLy8gc3dpdGNoSWRlbnRpdHlUbyA9IGZ1bmN0aW9uKHVzZXJuYW1lKVxuXG4gICAgLy8gVEhJTks6IGNvbnNpZGVyIGVuc3VyaW5nIGFsbCBmdW5jdGlvbnMgYXJlIHByZXNlbnQgZmlyc3QsIHNvIGl0J3MgaGFyZGVyIHRvIG1peCBhbmQgbWF0Y2ggd2FyZHJvYmUgaW1wbGVtZW50YXRpb25zXG4gICAgXG4gICAgaWYodHlwZW9mIHVzZVNlY3VyZUluZm8gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBQQi51c2VTZWN1cmVJbmZvID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IHVzZVNlY3VyZUluZm8gcmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGEgY3VycmVudCBpZGVudGl0eSwgYW5kIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgICAgcmV0dXJuIHVzZVNlY3VyZUluZm8oIGZ1bmN0aW9uKGlkZW50aXRpZXMsIHVzZXJuYW1lLCBwcml2YXRlUm9vdEtleSwgcHJpdmF0ZUFkbWluS2V5LCBwcml2YXRlRGVmYXVsdEtleSkge1xuICAgICAgICAgICAgICAgIHZhciBjbG9uZWRJZGVudGl0aWVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpZGVudGl0aWVzKSkgLy8gcHJldmVudCBhY2NpZGVudGFsIG11dGF0aW9uXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY2xvbmVkSWRlbnRpdGllcywgdXNlcm5hbWUsIHByaXZhdGVSb290S2V5LCBwcml2YXRlQWRtaW5LZXksIHByaXZhdGVEZWZhdWx0S2V5KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZih0eXBlb2YgYWRkSWRlbnRpdHkgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgUEIuYWRkSWRlbnRpdHkgPSBhZGRJZGVudGl0eVxuICAgICAgICBcbiAgICBpZih0eXBlb2YgYWRkQWxpYXMgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgUEIuYWRkQWxpYXMgPSBhZGRBbGlhc1xuICAgICAgICBcbiAgICBpZih0eXBlb2Ygc2V0UHJpbWFyeUFsaWFzID09ICdmdW5jdGlvbicpXG4gICAgICAgIFBCLnNldFByaW1hcnlBbGlhcyA9IHNldFByaW1hcnlBbGlhc1xuICAgICAgICBcbiAgICBpZih0eXBlb2Ygc2V0UHJlZmVyZW5jZSA9PSAnZnVuY3Rpb24nKVxuICAgICAgICBQQi5zZXRQcmVmZXJlbmNlID0gc2V0UHJlZmVyZW5jZVxuICAgICAgICBcbiAgICBpZih0eXBlb2Ygc3dpdGNoSWRlbnRpdHlUbyA9PSAnZnVuY3Rpb24nKVxuICAgICAgICBQQi5zd2l0Y2hJZGVudGl0eVRvID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAgICAgICAgIFBCLnJ1bkhhbmRsZXJzKCdiZWZvcmVTd2l0Y2hJZGVudGl0eScsIHVzZXJuYW1lKVxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHN3aXRjaElkZW50aXR5VG8odXNlcm5hbWUpXG4gICAgICAgICAgICBQQi5ydW5IYW5kbGVycygnYWZ0ZXJTd2l0Y2hJZGVudGl0eScsIHVzZXJuYW1lKVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICB9XG4gICAgICAgIFxuICAgIGlmKHR5cGVvZiByZW1vdmVJZGVudGl0eSA9PSAnZnVuY3Rpb24nKVxuICAgICAgICBQQi5yZW1vdmVJZGVudGl0eSA9IHJlbW92ZUlkZW50aXR5XG4gICAgICAgIFxuICAgIFBCLmdldEN1cnJlbnRVc2VybmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyB5ZXMsIHRoaXMgdGVjaG5pcXVlIGFsbG93cyB5b3UgdG8gbGVhayBkYXRhIG91dCBvZiB1c2VTZWN1cmVJbmZvLiBubywgeW91IHNob3VsZCBub3QgdXNlIGl0LlxuICAgICAgICB2YXIgb3V0cHV0XG4gICAgICAgIFBCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oaWRlbnRpdGllcywgdXNlcm5hbWUpIHsgb3V0cHV0ID0gdXNlcm5hbWUgfSlcbiAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgIH1cbiAgICBcbiAgICBQQi5nZXRDdXJyZW50Q2FwYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyB5ZXMsIHRoaXMgdGVjaG5pcXVlIGFsbG93cyB5b3UgdG8gbGVhayBkYXRhIG91dCBvZiB1c2VTZWN1cmVJbmZvLiBubywgeW91IHNob3VsZCBub3QgdXNlIGl0LlxuICAgICAgICB2YXIgb3V0cHV0XG4gICAgICAgIFBCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oaWRlbnRpdGllcywgdXNlcm5hbWUpIHsgb3V0cHV0ID0gKChpZGVudGl0aWVzW3VzZXJuYW1lXXx8e30pLnByaW1hcnl8fHt9KS5jYXBhfHwwIH0pXG4gICAgICAgIHJldHVybiBvdXRwdXRcbiAgICB9XG4gICAgXG4gICAgUEIuZ2V0Q3VycmVudFZlcnNpb25lZFVzZXJuYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1c2VybmFtZSA9IFBCLmdldEN1cnJlbnRVc2VybmFtZSgpXG4gICAgICAgIGlmKCF1c2VybmFtZSlcbiAgICAgICAgICAgIHJldHVybiBQQi5vbkVycm9yKCdObyBjdXJyZW50IHVzZXIgaW4gd2FyZHJvYmUnKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIFBCLlVzZXJzLm1ha2VWZXJzaW9uZWQodXNlcm5hbWUsIFBCLmdldEN1cnJlbnRDYXBhKCkpXG4gICAgfVxuICAgIFxuICAgIFBCLmdldEN1cnJlbnRVc2VyUmVjb3JkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ZXJzaW9uZWRVc2VybmFtZSA9IFBCLmdldEN1cnJlbnRWZXJzaW9uZWRVc2VybmFtZSgpXG4gICAgICAgIGlmKCF2ZXJzaW9uZWRVc2VybmFtZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBcbiAgICAgICAgLy8gVEhJTks6IGl0J3Mgd2VpcmQgdG8gaGl0IHRoZSBjYWNoZSBkaXJlY3RseSBmcm9tIGhlcmUsIGJ1dCBpZiB3ZSBkb24ndCB0aGVuIHdlIGFsd2F5cyBnZXQgYSBwcm9taXNlLFxuICAgICAgICAvLyAgICAgICAgZXZlbiBpZiB3ZSBoaXQgdGhlIGNhY2hlLCBhbmQgdGhpcyBzaG91bGQgcmV0dXJuIGEgcHJvcGVyIHVzZXJSZWNvcmQsIG5vdCBhIHByb21pc2UsIFxuICAgICAgICAvLyAgICAgICAgc2luY2UgYWZ0ZXIgYWxsIHdlIGhhdmUgc3RvcmVkIHRoZSB1c2VyUmVjb3JkIGluIG91ciB3YXJkcm9iZSwgaGF2ZW4ndCB3ZT9cbiAgICBcbiAgICAgICAgdmFyIHVzZXJSZWNvcmQgPSBQQi5Vc2Vycy5yZWNvcmRzW3ZlcnNpb25lZFVzZXJuYW1lXVxuICAgICAgICBpZighdXNlclJlY29yZClcbiAgICAgICAgICAgIHJldHVybiBQQi5vbkVycm9yKCdUaGF0IHVzZXIgZG9lcyBub3QgZXhpc3QgaW4gb3VyIHJlY29yZHMnKVxuICAgIFxuICAgICAgICByZXR1cm4gdXNlclJlY29yZFxuICAgIH1cblxuICAgIFBCLmdldEFsbElkZW50aXR5VXNlcm5hbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHllcywgdGhpcyB0ZWNobmlxdWUgYWxsb3dzIHlvdSB0byBsZWFrIGRhdGEgb3V0IG9mIHVzZVNlY3VyZUluZm8uIG5vLCB5b3Ugc2hvdWxkIG5vdCB1c2UgaXQuXG4gICAgICAgIHZhciBvdXRwdXRcbiAgICAgICAgUEIudXNlU2VjdXJlSW5mbyhmdW5jdGlvbihpZGVudGl0aWVzLCB1c2VybmFtZSkgeyBvdXRwdXQgPSBPYmplY3Qua2V5cyhpZGVudGl0aWVzKSB9KVxuICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgfVxuICAgIFxufVxuXG4vLy8vLy8vLy8vLy8vLyBFTkQgU0VDVVJFIElORk9STUFUSU9OIFpPTkUgLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5cblxuXG5cbi8vLy8gVkFMSURBVElPTlNcblxuLy8gVE9ETzogbWVyZ2UgdGhlc2UgaW50byBQQi5TcGVjXG5cbi8qKlxuICogY2hlY2sgaWYgYSB1c2VybmFtZSBpcyB2YWxpZFxuICogICAgIGEgdXNlcm5hbWUgbXVzdCBiZSBzaG9ydGVyIHRoYW4gMjU2IGNoYXJhY3RlcnMsIGFsbCBsb3dlcmNhc2UgYW5kIGNvbnRhaW5zIG9ubHkgYWxwaGFudW1lcmljIGFuZCAuIHNpZ25cbiAqIEBwYXJhbSAge3N0cmluZ30gdXNlcm5hbWUgdGhlIHN0cmluZyB0byBiZSBjaGVja1xuICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgICAgcmV0dXJuIHRydWUgaWYgIHRoZSBwYXJhbWV0ZXIgc3RyaW5nIGlzIGEgdmFsaWQgdXNlcm5hbWUsIG90aGVyd2lzZSB0aHJvdyBlcnJvclxuICovXG5QQi52YWxpZGF0ZVVzZXJuYW1lID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICBpZighdXNlcm5hbWUpIFxuICAgICAgICByZXR1cm4gUEIub25FcnJvcignVXNlcm5hbWUgaXMgcmVxdWlyZWQnLCB1c2VybmFtZSlcblxuICAgIGlmKHVzZXJuYW1lLmxlbmd0aCA+IDI1NikgXG4gICAgICAgIHJldHVybiBQQi5vbkVycm9yKCdVc2VybmFtZXMgbXVzdCBiZSBzaG9ydGVyIHRoYW4gMjU2IGNoYXJhY3RlcnMnLCB1c2VybmFtZSlcblxuICAgIGlmKHVzZXJuYW1lICE9IHVzZXJuYW1lLnRvTG93ZXJDYXNlKCkpIFxuICAgICAgICByZXR1cm4gUEIub25FcnJvcignVXNlcm5hbWVzIG11c3QgYmUgbG93ZXJjYXNlJywgdXNlcm5hbWUpXG4gICAgXG4gICAgaWYoIS9eWzAtOWEtei5dKyQvLnRlc3QodXNlcm5hbWUpKVxuICAgICAgICByZXR1cm4gUEIub25FcnJvcignVXNlcm5hbWVzIG11c3QgYmUgYWxwaGFudW1lcmljJywgdXNlcm5hbWUpXG4gICAgXG4gICAgcmV0dXJuIHRydWVcbn1cblxuXG4vKipcbiAqIGRldGVybWluZSBpZiBpdCBpcyBhIGdvb2Qgc2hlbGwsIGNoZWNrcyBmb3IgdGhlIGV4aXN0ZW5jZSBvZiByZXF1aXJlZCBmaWVsZHNcbiAqIEBwYXJhbSB7U2hlbGxbXX1cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5QQi5pc1ZhbGlkU2hlbGwgPSBmdW5jdGlvbihzaGVsbCkge1xuICAgIC8vLy8gdGhpcyBqdXN0IGNoZWNrcyBmb3IgdGhlIGV4aXN0ZW5jZSBvZiByZXF1aXJlZCBmaWVsZHNcbiAgICBpZighc2hlbGwuc2lnKSByZXR1cm4gZmFsc2VcbiAgICBpZighc2hlbGwucm91dGVzKSByZXR1cm4gZmFsc2VcbiAgICBpZighc2hlbGwudXNlcm5hbWUpIHJldHVybiBmYWxzZVxuICAgIGlmKHR5cGVvZiBzaGVsbC5wYXlsb2FkICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2VcbiAgICBpZighc2hlbGwucGF5bG9hZC50eXBlKSByZXR1cm4gZmFsc2VcbiAgICAgICAgXG4gICAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiB0byB2ZXJpZnkgYSBwdWZmXG4gKiBAcGFyYW0gIHtvYmplY3R9IHB1ZmZcbiAqIEByZXR1cm4geyhzdHJpbmd8Ym9vbGVhbil9XG4gKi9cblBCLmlzR29vZFB1ZmYgPSBmdW5jdGlvbihwdWZmKSB7XG4gICAgLy8gQ1VSUkVOVExZIFVOVVNFRFxuICAgIC8vIFRPRE86IGNoZWNrIHByZXZpb3VzIHNpZywgbWF5YmVcbiAgICAvLyBUT0RPOiBjaGVjayBmb3Igd2VsbC1mb3JtZWQtbmVzc1xuICAgIC8vIFRPRE86IHVzZSB0aGlzIHRvIHZlcmlmeSBpbmNvbWluZyBwdWZmc1xuICAgIC8vIFRPRE86IGlmIHByb20gZG9lc24ndCBtYXRjaCwgdHJ5IGFnYWluIHdpdGggZ2V0VXNlclJlY29yZE5vQ2FjaGVcbiAgICBcbiAgICAvLyBUT0RPOiByZXdyaXRlIHRoaXMgZnVuY3Rpb24gdG8gZ2l2ZSBhIGNvbnNpc3RlbnQgcmV0dXJuIHZhbHVlXG4gICAgXG4gICAgaWYgKCFQQi5NLkZvcnVtLmNvbnRlbnRUeXBlc1tzaGVsbC5wYXlsb2FkLnR5cGVdKSB7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgbmVlZHMgdG8gaW5jbHVkZSAnZW5jcnlwdGVkcHVmZicgYXMgYSB2YWxpZCB0eXBlXG4gICAgICAgIEV2ZW50cy5wdWIoJ3RyYWNrL3Vuc3VwcG9ydGVkLWNvbnRlbnQtdHlwZScsIHt0eXBlOiBzaGVsbC5wYXlsb2FkLnR5cGUsIHNpZzogc2hlbGwuc2lnfSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIFxuICAgIHZhciBwcm9tID0gUEIuVXNlcnMuZ2V0VXNlclJlY29yZFByb21pc2UocHVmZi51c2VybmFtZSkgLy8gTk9URTogdmVyc2lvbmVkVXNlcm5hbWVcbiAgICBcbiAgICByZXR1cm4gcHJvbS50aGVuKGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIFBCLkNyeXB0by52ZXJpZnlQdWZmU2lnKHB1ZmYsIHVzZXIuZGVmYXVsdEtleSlcbiAgICB9KVxufVxuXG5cblxuLy8vLyBFUlJPUiBIRUxQRVJTXG5cbi8vIFRPRE86IGJ1aWxkIGEgbW9yZSBnZW5lcmFsIGVycm9yIGhhbmRsaW5nIHN5c3RlbSBmb3IgR1VJIGludGVncmF0aW9uXG5cblBCLm9uRXJyb3IgPSBmdW5jdGlvbihtc2csIG9iaiwgdHJpZ2dlcikge1xuICAgIC8vLy8gb3ZlcnJpZGUgdGhpcyBmb3IgY3VzdG9tIGVycm9yIGJlaGF2aW9yXG4gICAgXG4gICAgdmFyIGNvbXBvc2l0ZSA9IHttc2c6IG1zZywgb2JqOiBvYmp9XG5cbiAgICBQQi5ydW5IYW5kbGVycygnZXJyb3InLCBjb21wb3NpdGUpXG4gICAgXG4gICAgaWYodHJpZ2dlcilcbiAgICAgICAgUEIucnVuSGFuZGxlcnModHJpZ2dlciwgY29tcG9zaXRlKVxuICAgICAgICBcbiAgICAvLyBmb3IgZGVidWdnaW5nIGhlbHAsIHJ1biB0aGlzIGluIHRoZSBjb25zb2xlOlxuICAgIC8vIFBCLmFkZEVycm9ySGFuZGxlcihmdW5jdGlvbihjb21wb3NpdGUpIHtjb25zb2xlLmxvZyhjb21wb3NpdGUpfSlcblxuICAgIHJldHVybiBmYWxzZVxufVxuXG5QQi5jYXRjaEVycm9yID0gZnVuY3Rpb24obXNnKSB7XG4gICAgLy8vLyBleDogcHJvbS5jYXRjaCggUEIuY2F0Y2hFcnJvcignaW52YWxpZCBmb28nKSApLnRoZW4oZnVuY3Rpb24oZm9vKSB7Li4ufSlcbiAgICByZXR1cm4gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIFBCLm9uRXJyb3IobXNnLCBlcnIpXG4gICAgICAgIHRocm93IGVyclxuICAgIH1cbn1cblxuUEIudGhyb3dFcnJvciA9IGZ1bmN0aW9uKG1zZywgZXJybXNnKSB7XG4gICAgLy8vLyBleDogcHJvbS50aGVuKGZ1bmN0aW9uKGZvbykge2lmKCFmb28pIFBCLnRocm93RXJyb3IoJ25vIGZvbycpOyAuLi59KVxuICAgIHZhciBlcnIgPSBlcnJtc2cgPyBFcnJvcihlcnJtc2cpIDogJydcbiAgICB0aHJvdyBQQi5tYWtlRXJyb3IobXNnLCBlcnIpXG59XG5cblBCLm1ha2VFcnJvciA9IGZ1bmN0aW9uKG1zZywgZXJyLCB0cmlnZ2VyKSB7XG4gICAgLy8vLyBleDogbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7IGlmKCFmb28pIHJlamVjdCggUEIubWFrZUVycm9yKCdubyBmb28nKSApIC4uLiB9KVxuICAgIFBCLm9uRXJyb3IobXNnLCBlcnIsIHRyaWdnZXIpXG4gICAgcmV0dXJuIEVycm9yKG1zZylcbn1cblxuUEIuZW1wdHlQcm9taXNlID0gZnVuY3Rpb24obXNnKSB7XG4gICAgLy8vLyBleDogZnVuY3Rpb24oZm9vKSB7IGlmKCFmb28pIHJldHVybiBQQi5lbXB0eVByb21pc2UoJ25vIGZvbycpOyByZXR1cm4gZ2V0Rm9vUHJvbWlzZShmb28pIH1cbiAgICBpZihtc2cpIFBCLm9uRXJyb3IobXNnKVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChtc2cpXG59XG5cblBCLnRocm93TmV0RXJyb3IgPSBmdW5jdGlvbihtc2csIGVycm1zZykge1xuICAgIC8vLy8gbGlrZSB0aHJvdyBlcnJvciBidXQgdHJpZ2dlcnMgdGhlIG5ldHdvcmtFcnJvciBoYW5kbGVyXG4gICAgdmFyIHRyaWdnZXIgPSAnbmV0d29ya0Vycm9yJ1xuICAgIHZhciBlcnIgPSBlcnJtc2cgPyBFcnJvcihlcnJtc2cpIDogJydcbiAgICB0aHJvdyBQQi5tYWtlRXJyb3IobXNnLCBlcnIsIHRyaWdnZXIpXG59XG5cblBCLnRocm93REhURXJyb3IgPSBmdW5jdGlvbihtc2csIGVycm1zZykge1xuICAgIC8vLy8gbGlrZSB0aHJvdyBlcnJvciBidXQgdHJpZ2dlcnMgdGhlIERIVEVycm9yIGhhbmRsZXJcbiAgICB2YXIgdHJpZ2dlciA9ICdESFRFcnJvcidcbiAgICB2YXIgZXJyID0gZXJybXNnID8gRXJyb3IoZXJybXNnKSA6ICcnXG4gICAgdGhyb3cgUEIubWFrZUVycm9yKG1zZywgZXJyLCB0cmlnZ2VyKVxufVxuXG5cbi8vLy8gRXhjZXB0aW9uYWwgQVBJIHdyYXBwZXJzXG5cblBCLnBhcnNlSlNPTiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIC8vLy8gSlNPTi5wYXJzZSB0aHJvd3MsIHNvIHdlIGNhdGNoIGl0LiB0aHJvdy9jYXRjaCBib3JrcyB0aGUgSlMgVk0gb3B0aW1pemVyLCBzbyB3ZSBib3ggaXQuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIHJldHVybiBQQi5vbkVycm9yKCdJbnZhbGlkIEpTT04gc3RyaW5nJywgZXJyKVxuICAgIH1cbn1cblxuUEIuc3RyaW5naWZ5SlNPTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIC8vLy8gSlNPTi5zdHJpbmdpZnkgdGhyb3dzIG9uIGR1bWIgRE9NIG9iamVjdHMsIHNvIHdlIGNhdGNoIGl0LiB0aHJvdy9jYXRjaCBib3JrcyB0aGUgSlMgVk0gb3B0aW1pemVyLCBzbyB3ZSBib3ggaXQuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iailcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICByZXR1cm4gUEIub25FcnJvcignSW52YWxpZCBvYmplY3QnLCBlcnIpXG4gICAgfVxufVxuXG5QQi50cnlEZWNvZGVVUklDb21wb25lbnQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAvLy8vIGRlY29kZVVSSUNvbXBvbmVudCB0aHJvd3MsIHNvIHdlIHdyYXAgaXQuIHRyeS9jYXRjaCBraWxscyB0aGUgb3B0aW1pemVyLCBzbyB3ZSBpc29sYXRlIGl0LlxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIHJldHVybiBQQi5vbkVycm9yKCdJbnZhbGlkIFVSSSBzdHJpbmcnLCBlcnIpXG4gICAgfVxufVxuXG5cbi8vLy8gc29tZXRoaW5nIGRpZmZlcmVudFxuXG5QQi5wcm9taXNlc1BlbmRpbmcgPSB7fVxuXG4vLyBNYWpvciBqdWppdHN1IGhlcmVcblBCLnByb21pc2VNZW1vaXplID0gZnVuY3Rpb24oZnVuLCBvaGJveSkge1xuICAgIGlmKCFvaGJveSkgb2hib3kgPSBQQi5yZW1vdmVQcm9taXNlUGVuZGluZ1xuICAgIFxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGtleSA9IEpTT04uc3RyaW5naWZ5KFtmdW4udG9TdHJpbmcoKSxhcmd1bWVudHNdKVxuICAgICAgICBcbiAgICAgICAgaWYoUEIucHJvbWlzZXNQZW5kaW5nW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gUEIucHJvbWlzZXNQZW5kaW5nW2tleV1cbiAgICAgICAgXG4gICAgICAgIHZhciBwcm9tID0gZnVuLmFwcGx5KGZ1biwgYXJndW1lbnRzKVxuICAgICAgICBwcm9tID0gcHJvbS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBvaGJveShrZXksIHZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlbGl2ZXIgc3VjY2Vzc2VzXG4gICAgICAgIH0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBvaGJveShrZXksIHZhbHVlKVxuICAgICAgICAgICAgdGhyb3cgdmFsdWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSBmYWlsdXJlc1xuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgUEIucHJvbWlzZXNQZW5kaW5nW2tleV0gPSBwcm9tXG4gICAgICAgIHJldHVybiBwcm9tXG4gICAgfVxufVxuXG5QQi5yZW1vdmVQcm9taXNlUGVuZGluZyA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGRlbGV0ZSBQQi5wcm9taXNlc1BlbmRpbmdba2V5XVxufVxuXG4vLy8vIFRJTUlORyBIRUxQRVJTXG5cblxuLy8gVE9ETzogbW92ZSB0aGVzZSBpbnRvIGEgbGlicmFyeVxuXG5+ZnVuY3Rpb24oKSB7XG4gICAgLy8vLyBwb3N0cG9uZSB1bnRpbCBuZXh0IHRpY2tcbiAgICAvLyBpbnNwaXJlZCBieSBodHRwOi8vZGJhcm9uLm9yZy9sb2cvMjAxMDAzMDktZmFzdGVyLXRpbWVvdXRzXG4gICAgdmFyIGxhdGVyID0gW11cbiAgICB2YXIgbWVzc2FnZU5hbWUgPSAxMjM0NVxuICAgIHZhciBnaW1tZV9hX3RpY2sgPSB0cnVlXG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZnVuKSB7XG4gICAgICAgIGxhdGVyLnB1c2goZnVuKVxuICAgICAgICBcbiAgICAgICAgaWYoZ2ltbWVfYV90aWNrKSB7XG4gICAgICAgICAgICBnaW1tZV9hX3RpY2sgPSBmYWxzZVxuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2VOYW1lLCBcIipcIilcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldmVudCkge1xuICAgICAgICBpZihldmVudC5kYXRhICE9IG1lc3NhZ2VOYW1lKSByZXR1cm4gZmFsc2VcblxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICBnaW1tZV9hX3RpY2sgPSB0cnVlXG5cbiAgICAgICAgdmFyIG5vdyA9IGxhdGVyXG4gICAgICAgIGxhdGVyID0gW11cblxuICAgICAgICBmb3IodmFyIGk9MCwgbD1ub3cubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgbm93W2ldKClcbiAgICB9XG4gIFxuICAgIGlmKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVNZXNzYWdlLCB0cnVlKVxuICAgICAgICB3aW5kb3cuc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlXG4gICAgfVxufSgpXG5cblBCLnF1ZXVlciA9IGZ1bmN0aW9uKCkge1xuICAgIC8vLy8gZG8gc29tZXRoaW5nIGFmdGVyIHNvbWUgb3RoZXIgdGhpbmdzXG4gICAgdmFyIHF1ZXVlID0gW11cbiAgICBcbiAgICB2YXIgbmV4dHRpbWUgPSBmdW5jdGlvbihpbnZva2VyKSB7XG4gICAgICAgIGludm9rZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZighcXVldWUubGVuZ3RoKSByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIHF1ZXVlLnNoaWZ0KCkoKVxuICAgICAgICAgICAgbmV4dHRpbWUoaW52b2tlcilcbiAgICAgICAgfSlcbiAgICB9XG4gICAgICAgICAgICBcbiAgICB2YXIgcXVldWVyID0gZnVuY3Rpb24oaW52b2tlciwgZnVuKSB7XG4gICAgICAgIHF1ZXVlLnB1c2goZnVuKVxuICAgICAgICBpZihxdWV1ZS5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2UgLy8gVEhJTks6IHBvc3NpYmxlIHJhY2UgY29uZGl0aW9uXG4gICAgICAgIG5leHR0aW1lKGludm9rZXIpIFxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcXVldWVyXG59XG5cblBCLm9uY2UgPSBmdW5jdGlvbigpIHtcbiAgICAvLy8vIGRvIHNvbWV0aGluZyBsYXRlciwgYnV0IG9ubHkgb25jZVxuICAgIHZhciBsYXRlciA9IFtdXG5cbiAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gbGF0ZXJcbiAgICAgICAgbGF0ZXIgPSBbXVxuICAgICAgICBmb3IodmFyIGk9MCwgbD1ub3cubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgbm93W2ldKClcbiAgICB9XG4gICAgICAgICAgICBcbiAgICB2YXIgb25jZSA9IGZ1bmN0aW9uKGludm9rZXIsIGZ1bikge1xuICAgICAgICBpZih+bGF0ZXIuaW5kZXhPZihmdW4pKSByZXR1cm4gZmFsc2VcbiAgICAgICAgbGF0ZXIucHVzaChmdW4pXG4gICAgICAgIGlmKGxhdGVyLmxlbmd0aCA+IDEpIHJldHVybiBmYWxzZSAvLyBUSElOSzogcG9zc2libGUgcmFjZSBjb25kaXRpb25cbiAgICAgICAgaW52b2tlcihzdGVwKSBcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG9uY2Vcbn1cblxufmZ1bmN0aW9uKCkge1xuICAgIGlmKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2luZG93LnF1ZXVlSW1tZWRpYXRlID0gUEIucXVldWVyKCkuYmluZChudWxsLCBzZXRJbW1lZGlhdGUpXG4gICAgICAgIHdpbmRvdy5vbmNlSW1tZWRpYXRlICA9IFBCLm9uY2UoKS5iaW5kKG51bGwsIHNldEltbWVkaWF0ZSlcbiAgICAgICAgd2luZG93LnF1ZXVlUkFGID0gUEIucXVldWVyKCkuYmluZChudWxsLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXG4gICAgICAgIHdpbmRvdy5vbmNlUkFGICA9IFBCLm9uY2UoKS5iaW5kKG51bGwsIHJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICBcbiAgICAgICAgdmFyIHRpbWVmdW5iaW5kID0ge31cbiAgICAgICAgd2luZG93Lm9uY2VJbkF3aGlsZSA9IGZ1bmN0aW9uKGZ1biwgdGltZSkge1xuICAgICAgICAgICAgLy8vLyBOT1RFOiBkb24ndCB1c2UgdGhlIHNhbWUgZnVuIHdpdGggZGlmZmVyZW50IHRpbWVzXG4gICAgICAgICAgICBpZih0aW1lZnVuYmluZFtmdW5dKSByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIHRpbWVmdW5iaW5kW2Z1bl0gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge2Z1bigpOyB0aW1lZnVuYmluZFtmdW5dID0gZmFsc2V9LCB0aW1lKVxuICAgICAgICB9XG4gICAgfVxufSgpXG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vIEEgZmV3IHNtYWxsIGhlbHBlcnMgZm9yIGJ1aWxkaW5nIGZ1bmN0aW9uYWwgcGlwZWxpbmVzIC8vLy8vLy8vLy8vLy8vL1xuXG5QQi5wcm9wID0gZnVuY3Rpb24ocCwgb2JqKSB7IC8vIFRISU5LOiBjb25zaWRlciBpbXBvcnRpbmcgYWxsIG9mIFJhbWJkYS5qc1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9ialtwXTsgfSA6IG9ialtwXVxufVxuXG5QQi51bmlxdWlmeSA9IGZ1bmN0aW9uKGxpc3QpIHtcbiAgICByZXR1cm4gbGlzdC5maWx0ZXIoUEIudW5pcXVlKVxufVxuXG5QQi51bmlxdWUgPSBmdW5jdGlvbihpdGVtLCBpbmRleCwgYXJyYXkpIHtyZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKSA9PSBpbmRleH1cbiIsIi8qXG5cbiAgICBOZXR3b3JrIGxpYnJhcnkgZm9yIHRoZSBFdmVyeUJpdCBwbGF0Zm9ybS5cblxuICAgIENvbnRhaW5zIGEgcGVlci5qcy1iYXNlZCBwMnAgbGF5ZXIsIGEgcHJvbWlzZS1iYXNlZCBYSFIgaW1wbGVtZW50YXRpb24sIFxuICAgIGhlbHBlciBmdW5jdGlvbnMgZm9yIGFjY2Vzc2luZyB2YXJpb3VzIHNlcnZlci1iYXNlZCBBUElzLCBcbiAgICBhbmQgaGVscGVyIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgcHVmZiBkaXN0cmlidXRpb24gYW5kIGFjcXVpc2l0aW9uLlxuXG4gICAgQ29weXJpZ2h0IDIwMTQgRXZlcnlCaXQuIFNlZSBSRUFETUUgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbiAqL1xuXG5QQi5OZXQgPSB7fVxuXG4vKipcbiAqIEZpcmUgdXAgbmV0d29ya3MgKGN1cnJlbnRseSBqdXN0IHRoZSBwZWVyIGNvbm5lY3Rpb25zKVxuICovXG5QQi5OZXQuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIFBCLk5ldC5QMlAuaW5pdCgpXG59XG5cbi8qKlxuICogR2l2ZW4gYSBzaWduYXR1cmUsIHJldHVybiBwdWZmIHdpdGggdGhhdCBzaWduYXR1cmVcbiAqIEBwYXJhbSAge3N0cmluZ30gc2lnIHNpZ25hdHVyZSBvZiBhIHB1ZmZcbiAqIEByZXR1cm4ge29iamVjdH0gICAgIHB1ZmYgY29ycmVzcG9uZHMgdG8gdGhlIHNwZWNpZmllZCBzaWduYXR1cmVcbiAqL1xuUEIuTmV0LmdldFB1ZmZCeVNpZyA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHZhciB1cmwgID0gUEIuQ09ORklHLnB1ZmZBcGlcbiAgICB2YXIgZGF0YSA9IHt0eXBlOiAnZ2V0UHVmZkJ5U2lnJywgc2lnOiBzaWd9XG4gICAgXG4gICAgcmV0dXJuIFBCLk5ldC5QQmdldEpTT04odXJsLCBkYXRhKVxufVxuXG5QQi5OZXQuZ2V0S2lkU2lncyA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHZhciB1cmwgID0gUEIuQ09ORklHLnB1ZmZBcGlcbiAgICB2YXIgZGF0YSA9IHt0eXBlOiAnZ2V0Q2hpbGRyZW5CeVNpZycsIHNpZzogc2lnfVxuICAgIFxuICAgIHJldHVybiBQQi5OZXQuUEJnZXRKU09OKHVybCwgZGF0YSlcbn1cblxuUEIuTmV0LmdldEtpZFNpZ3MgPSBCb3Jvbi5tZW1vaXplKFBCLk5ldC5nZXRLaWRTaWdzKSAvLyBUSElOSzogdGhpcyBhc3N1bWVzIHdlJ2xsIGdldCBhbGwgbmV3IHRoaW5ncyBvdmVyIHRoZSBQMlAgbmV0d29yaywgd2hpY2ggd29uJ3QgYWx3YXlzIGJlIHRydWUuXG5cblxuXG5QQi5OZXQuZ2V0U3RhclNoZWxscyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB1cmwgID0gUEIuQ09ORklHLnB1ZmZBcGlcbiAgICB2YXIgZGF0YSA9IHt0eXBlOiAnZ2V0UHVmZnMnLCBjb250ZW50VHlwZTogJ3N0YXInLCBudW1iOiBQQi5DT05GSUcuZ2xvYmFsQmlnQmF0Y2hMaW1pdH1cbiAgICBcbiAgICByZXR1cm4gUEIuTmV0LlBCZ2V0SlNPTih1cmwsIGRhdGEpXG59XG5cblBCLk5ldC5nZXRDb252ZXJzYXRpb25QdWZmcyA9IGZ1bmN0aW9uKGNvbnZvSWQsIGJhdGNoc2l6ZSwgb2Zmc2V0LCBmdWxsT3JTaGVsbCkge1xuICAgIGNvbnZvSWQgID0gY29udm9JZC5yZXBsYWNlKCcmJywnLCcpXG5cbiAgICB2YXIgdXJsICA9IFBCLkNPTkZJRy5wdWZmQXBpXG4gICAgdmFyIGRhdGEgPSB7IHR5cGU6ICdnZXRQdWZmcycsIGNvbnRlbnRUeXBlOiAnZW5jcnlwdGVkcHVmZidcbiAgICAgICAgICAgICAgICwgY29udmVyc2F0aW9uUGFydG5lcnM6IGNvbnZvSWRcbiAgICAgICAgICAgICAgICwgbnVtYjogYmF0Y2hzaXplXG4gICAgICAgICAgICAgICAsIG9mZnNldDogb2Zmc2V0XG4gICAgICAgICAgICAgICB9XG4gICAgXG4gICAgcmV0dXJuIFBCLk5ldC5QQmdldEpTT04odXJsLCBkYXRhKVxufVxuXG5QQi5OZXQuZ2V0TXlQcml2YXRlUHVmZnMgPSBmdW5jdGlvbih1c2VybmFtZSwgYmF0Y2hzaXplLCBvZmZzZXQsIGZ1bGxPclNoZWxsKSB7XG4gICAgaWYoIXVzZXJuYW1lKSByZXR1cm4gUEIuZW1wdHlQcm9taXNlKClcbiAgICBiYXRjaHNpemUgPSBiYXRjaHNpemUgfHwgUEIuQ09ORklHLmdsb2JhbEJpZ0JhdGNoTGltaXRcbiAgICBcbiAgICB2YXIgdXJsICA9IFBCLkNPTkZJRy5wdWZmQXBpXG4gICAgdmFyIGRhdGEgPSB7IHJvdXRlOiB1c2VybmFtZSwgdXNlcm5hbWU6IHVzZXJuYW1lLCBmcm9tQW5kVG86IDFcbiAgICAgICAgICAgICAgICwgdHlwZTogJ2dldFB1ZmZzJywgY29udGVudFR5cGU6ICdlbmNyeXB0ZWRwdWZmJ1xuICAgICAgICAgICAgICAgLCBmdWxsT3JTaGVsbDogZnVsbE9yU2hlbGwgfHwgJ2Z1bGwnXG4gICAgICAgICAgICAgICAsIG51bWI6IGJhdGNoc2l6ZVxuICAgICAgICAgICAgICAgLCBvZmZzZXQ6IG9mZnNldFxuICAgICAgICAgICAgICAgfVxuICAgIFxuICAgIHJldHVybiBQQi5OZXQuUEJnZXRKU09OKHVybCwgZGF0YSlcbiAgICBcbi8qXG5cbiAgICBTbyBzb21ldGhpbmcgbGlrZTpcblxuICAgIFBCLmdldFNvbWVQdWZmcyhxdWVyeSwgbGltaXQsIGV0YylcblxuICAgIGhlbHBlci5qczpcbiAgICB0cnlHZXR0aW5nTW9yZVB1ZmZzKHZpc2libGVMaW1pdCkge1xuICAgICAgICAvLyBmaWd1cmUgb3V0IGhvdyBtYW55IHdlJ3ZlIHJlcXVlc3RlZCBhbHJlYWR5IChJQ1guY3VycmVudE9mZnNldClcbiAgICAgICAgLy8gZmlndXJlIG91dCBob3cgbWFueSB3ZSBhY3R1YWxseSBoYXZlIChQQi5EYXRhLmdldERlY3J5cHRlZFB1ZmZzKVxuICAgICAgICB2YXIgZGVsdGEgPSB2aXNpYmxlTGltaXQgLSBQQi5EYXRhLmdldERlY3J5cHRlZFB1ZmZzKCkubGVuZ3RoXG4gICAgICAgIElDWC5jdXJyZW50T2Zmc2V0ICs9IGRlbHRhXG4gICAgICAgIHJldHVybiBQQi5nZXRTb21lUHVmZnMocXVlcnksIElDWC5jdXJyZW50T2Zmc2V0KVxuICAgIH1cblxuXG4qLyBcblxuICAgIC8vIFRPRE86IGNoYWluIHRoaXMgaW4gdG8gdGhlIHRhYmxlIHZpZXdcbiAgICBcbn1cblxuXG5QQi5OZXQuZ2V0UHJvZmlsZVB1ZmYgPSBmdW5jdGlvbih1c2VybmFtZSkge1xuICAgIHZhciB1cmwgID0gUEIuQ09ORklHLnB1ZmZBcGlcbiAgICB2YXIgZGF0YSA9IHsgdXNlcm5hbWU6IHVzZXJuYW1lXG4gICAgICAgICAgICAgICAsIGZ1bGxPclNoZWxsOiAnZnVsbCdcbiAgICAgICAgICAgICAgICwgY29udGVudFR5cGU6ICdwcm9maWxlJ1xuICAgICAgICAgICAgICAgLCB0eXBlOiAnZ2V0UHVmZnMnXG4gICAgICAgICAgICAgICAsIHNvcnQ6ICdERVNDJ1xuICAgICAgICAgICAgICAgLCBudW1iOiAxXG4gICAgICAgICAgICAgICB9XG4gICAgXG4gICAgcmV0dXJuIFBCLk5ldC5QQmdldEpTT04odXJsLCBkYXRhKVxufVxuUEIuTmV0LmdldFByb2ZpbGVQdWZmID0gUEIucHJvbWlzZU1lbW9pemUoUEIuTmV0LmdldFByb2ZpbGVQdWZmKVxuXG4vKipcbiAqIHRvIGdldCBzb21lIHNoZWxsc1xuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7U2hlbGxbXX1cbiAqL1xuUEIuTmV0LmdldFNvbWVTaGVsbHMgPSBmdW5jdGlvbihxdWVyeSwgZmlsdGVycywgbGltaXQsIG9mZnNldCkge1xuICAgIC8vIFRPRE86IHN3aXRjaGluZyBieSBxdWVyeSAnbW9kZScgd2lsbCBuZWVkIHRvIGJlIGNoYW5nZWQgd2hlbiB0aGUgbmV0d29yayBhcGkgbWF0Y2hlcyBvdXIgbG9jYWwgYXBpIChpLmUuIG9uY2Ugd2UgdXNlIGJyb3dzZXIgcDJwICYgaGVhZGxlc3MgY2xpZW50cyB0byBzZXJ2aWNlIHJlcXVlc3RzKVxuICAgIFxuICAgIHZhciBtb2RlID0gcXVlcnkubW9kZVxuICAgIGlmKG1vZGUgPT0gJ2FuY2VzdG9ycycpICAgcmV0dXJuIFBCLk5ldC5nZXRBbmNlc3RvcnMgIChbcXVlcnkuZm9jdXNdLCBsaW1pdClcbiAgICBpZihtb2RlID09ICdkZXNjZW5kYW50cycpIHJldHVybiBQQi5OZXQuZ2V0RGVzY2VuZGFudHMoW3F1ZXJ5LmZvY3VzXSwgbGltaXQpXG4gICAgLy8gaWYobW9kZSA9PSAnc2libGluZ3MnKSAgICByZXR1cm4gUEIuTmV0LmdldFNpYmxpbmdzICAgKFtxdWVyeS5mb2N1c10sIGxpbWl0KVxuXG4gICAgLy8gXCJub3JtYWxcIiBtb2RlIChqdXN0IGFzayBmb3Igc2hlbGxzIGZyb20gbGlzdHMgb3Igc29tZXRoaW5nKVxuICAgIHZhciB1cmwgID0gUEIuQ09ORklHLnB1ZmZBcGlcblxuICAgIC8vICBpZihmaWx0ZXJzLnR5cGVzKSAgIGRhdGEudHlwZSAgICAgICA9IGZpbHRlcnMudHlwZXMgICAgICAvLyBmaWx0ZXIgYnkgdHlwZXNcblxuICAgIHZhciBkYXRhID0ge3R5cGU6ICdnZXRQdWZmcycsIGNvbnRlbnRUeXBlOiAncGxhaW4nfVxuICAgIC8vIHZhciBkYXRhID0ge3R5cGU6ICdnZXRQdWZmcycsIGNvbnRlbnRUeXBlOiAnW1wiaW1hZ2VcIl0nfVxuXG5cbiAgICBpZihsaW1pdCkgIGRhdGEubnVtYiAgICA9IGxpbWl0ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHRzIHRvIDIwIG9uIHRoZSBzZXJ2ZXJcbiAgICBpZihvZmZzZXQpIGRhdGEub2Zmc2V0ICA9IG9mZnNldCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHRzIHRvIDAsIHdoaWNoIGlzIGxhdGVzdFxuICAgIFxuICAgIGlmKHF1ZXJ5LnNvcnQpICAgICAgZGF0YS5zb3J0ICAgICAgICA9IHF1ZXJ5LnNvcnQgICAgICAgLy8gQVNDIG9yIERFU0NcbiAgICBpZihmaWx0ZXJzLnVzZXJzKSAgIGRhdGEudXNlcm5hbWUgICAgPSBmaWx0ZXJzLnVzZXJzICAgIC8vIGZpbHRlciBieSB1c2VybmFtZVxuICAgIGlmKGZpbHRlcnMucm91dGVzKSAgZGF0YS5yb3V0ZSAgICAgICA9IGZpbHRlcnMucm91dGVzICAgLy8gZmlsdGVyIGJ5IHJvdXRlXG4gICAgaWYoZmlsdGVycy50YWdzKSAgICBkYXRhLnRhZ3MgICAgICAgID0gZmlsdGVycy50YWdzICAgICAvLyBmaWx0ZXIgYnkgdGFnc1xuICAgIGlmKGZpbHRlcnMudHlwZXMpICAgZGF0YS5jb250ZW50VHlwZSA9IGZpbHRlcnMudHlwZXMgICAgLy8gZmlsdGVyIGJ5IHR5cGVzXG4gICAgaWYocXVlcnkuYW5jZXN0b3JzKSBkYXRhLm1heFBhcmVudHMgID0gcXVlcnkuYW5jZXN0b3JzICAvLyBkZWZhdWx0cyB0byBhbGwgc2hlbGxzIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCBpcyByb290cywgMSBpcyBzaW5nbGUgcGFyZW50LCBldGNcbiAgICAvLyBkYXRhLmZsYWdnZWQgPSBmYWxzZVxuICAgIFxuICAgIC8vIGRhdGEuZm9jdXNcbiAgICAvLyBkYXRhLmFuY2VzdG9yc1xuICAgIC8vIGRhdGEuZGVzY2VuZGFudHNcbiAgICBcbiAgICB2YXIgZmlsdGVyc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZmlsdGVycy50eXBlcylcbiAgICB2YXIgcHJvZmlsZV9yZXF1ZXN0ID0gKGZpbHRlcnN0cmluZyA9PSAnW1wicHJvZmlsZVwiXScpXG4gICAgXG4gICAgaWYoUEIuQ09ORklHLmRpc2FibGVSZWNlaXZlUHVibGljICYmICFwcm9maWxlX3JlcXVlc3QpXG4gICAgICAgIHJldHVybiBQQi5lbXB0eVByb21pc2UoKVxuICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtyZXR1cm4gW119KVxuICAgIFxuICAgIHJldHVybiBQQi5OZXQuUEJnZXRKU09OKHVybCwgZGF0YSkgICAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIHJldHVybnMgYSB2YWxpZCBhcnJheVxuICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbih4KSB7cmV0dXJuIHggfHwgW119LCBmdW5jdGlvbigpIHtyZXR1cm4gW119KVxufVxuXG5cblBCLk5ldC5nZXRBbmNlc3RvcnMgPSBmdW5jdGlvbihzdGFydCwgbGltaXQpIHtcbiAgICBnZXRFbShzdGFydCwgW10sIGxpbWl0KVxuICAgIHJldHVybiBQQi5lbXB0eVByb21pc2UoKVxuICAgIFxuICAgIGZ1bmN0aW9uIGdldEVtKHRvZG8sIGRvbmUsIHJlbWFpbmluZykge1xuICAgICAgICBpZighdG9kby5sZW5ndGgpIHJldHVybiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIGRvbmVcbiAgICAgICAgaWYoIXJlbWFpbmluZykgcmV0dXJuIGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBkb25lXG4gICAgXG4gICAgICAgIHZhciBzaWcgPSB0b2RvWzBdXG4gICAgXG4gICAgICAgIGlmKH5kb25lLmluZGV4T2Yoc2lnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEVtKHRvZG8uc2xpY2UoMSksIGRvbmUsIHJlbWFpbmluZykgICAgLy8gd2UndmUgYWxyZWFkeSBkb25lIHRoaXMgb25lXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFRPRE86IHNldCBhIGNhbGxiYWNrIGluIFBCLk5ldCBpbnN0ZWFkIG9mIGNhbGxpbmcgUEIuRGF0YSBkaXJlY3RseVxuICAgICAgICB2YXIgcHVmZiA9IFBCLkRhdGEuZ2V0UHVmZkJ5U2lnKHNpZykgICAgICAgICAgICAgICAgLy8gZWZmZWN0ZnVsXG4gICAgXG4gICAgICAgIGlmKHB1ZmYpIFxuICAgICAgICAgICAgcmV0dXJuIGdldEVtKHRvZG8uc2xpY2UoMSkuY29uY2F0KHB1ZmYucGF5bG9hZC5wYXJlbnRzKSwgZG9uZS5jb25jYXQoc2lnKSwgcmVtYWluaW5nKVxuXG4gICAgICAgIC8vIG5vIHB1ZmY/IHRoYXQncyBvay4gYXR0YWNoIGEgdGhlbiBjbGF1c2UgdG8gaXRzIHBlbmRpbmcgcHJvbWlzZS5cbiAgICAgICAgLy8gVE9ETzogZmluZCBiZXR0ZXIgbWV0aG9kIHRvIGRvIHRoaXNcbiAgICAgICAgcmVtYWluaW5nLS0gLy8gYmVjYXVzZSB3ZSdyZSBhZGRpbmcgYSBuZXcgcHVmZiwgb3IgYXQgbGVhc3QgbmV3IGNvbnRlbnRcbiAgICAgICAgdmFyIHByb20gPSBQQi5EYXRhLnBlbmRpbmdQdWZmUHJvbWlzZXNbc2lnXVxuICAgICAgICBwcm9tLnRoZW4oZnVuY3Rpb24ocHVmZnMpIHtcbiAgICAgICAgICAgIGdldEVtKHRvZG8uc2xpY2UoMSkuY29uY2F0KCgocHVmZnNbMF18fHt9KS5wYXlsb2FkfHx7fSkucGFyZW50cyksIGRvbmUuY29uY2F0KHNpZyksIHJlbWFpbmluZylcbiAgICAgICAgfSlcbiAgICB9XG4gICAgXG4gICAgLy9cbiAgICAvLyBpZighdG9kby5sZW5ndGgpXG4gICAgLy8gICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0cykgICAgICAgICAgICAgLy8gYWxsIGRvbmVcbiAgICAvLyBpZihyZXN1bHRzLmxlbmd0aCA+PSBsaW1pdClcbiAgICAvLyAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRzKSAgICAgICAgICAgICAvLyBhbGwgZG9uZVxuICAgIC8vXG4gICAgLy8gdmFyIHNpZyA9IHRvZG9bMF1cbiAgICAvLyB2YXIgc2hlbGwgPSBQQi5EYXRhLmdldENhY2hlZFNoZWxsQnlTaWcoc2lnKSAgIC8vIFRPRE86IHNldCBhIGNhbGxiYWNrIGluIFBCLk5ldCBpbnN0ZWFkIG9mIGNhbGxpbmcgdGhpcyBkaXJlY3RseVxuICAgIC8vICAgICAgICAgIHx8IHJlc3VsdHMuZmlsdGVyKGZ1bmN0aW9uKHJlc3VsdCkge3JldHVybiByZXN1bHQuc2lnID09IHNpZ30pWzBdXG4gICAgLy9cbiAgICAvLyAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBwdWZmIGZvciBzaWcsIHRoZW4gd2UganVzdCBuZWVkIHRvIHB1dCBpdHMgcGFyZW50cyBvbiB0aGUgdG9kbyBzdGFja1xuICAgIC8vIGlmKHNoZWxsKSB7XG4gICAgLy8gICAgIHRvZG8uc2hpZnQoKSAvLyB0YWtlIG9mZiB0aGUgc2hlbGwgd2UganVzdCB3b3JrZWQgb25cbiAgICAvLyAgICAgcmV0dXJuIFBCLk5ldC5nZXRBbmNlc3RvcnModG9kby5jb25jYXQoc2hlbGwucGF5bG9hZC5wYXJlbnRzKSwgbGltaXQsIHJlc3VsdHMpXG4gICAgLy8gfVxuICAgIC8vXG4gICAgLy8gLy8gb3RoZXJ3aXNlLCBnZXQgYSBwcm9taXNlIGZvciB0aGUgc2hlbGwsIHRoZW4gYWRkIGl0IHRvIHJlc3VsdHNcbiAgICAvLyB2YXIgcHJvbSA9IFBCLk5ldC5nZXRQdWZmQnlTaWcoc2lnKVxuICAgIC8vIHJldHVybiBwcm9tLnRoZW4oZnVuY3Rpb24ocHVmZnMpIHtcbiAgICAvLyAgICAgcmV0dXJuIFBCLk5ldC5nZXRBbmNlc3RvcnModG9kbywgbGltaXQsIHJlc3VsdHMuY29uY2F0KHB1ZmZzKSlcbiAgICAvLyB9KVxufVxuXG5QQi5OZXQuZ2V0RGVzY2VuZGFudHMgPSBmdW5jdGlvbihzdGFydCwgbGltaXQpIHtcbiAgICBnZXRFbShzdGFydCwgW10sIGxpbWl0KVxuICAgIHJldHVybiBQQi5lbXB0eVByb21pc2UoKVxuICAgIFxuICAgIGZ1bmN0aW9uIGdldEVtKHRvZG8sIGRvbmUsIHJlbWFpbmluZykge1xuICAgICAgICBpZighdG9kby5sZW5ndGgpIHJldHVybiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIGRvbmVcbiAgICAgICAgaWYoIXJlbWFpbmluZykgcmV0dXJuIGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBkb25lXG4gICAgICAgIFxuICAgICAgICB2YXIgc2lnID0gdG9kb1swXVxuICAgICAgICBcbiAgICAgICAgaWYofmRvbmUuaW5kZXhPZihzaWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RW0odG9kby5zbGljZSgxKSwgZG9uZSwgcmVtYWluaW5nKSAgICAvLyB3ZSd2ZSBhbHJlYWR5IGRvbmUgdGhpcyBvbmVcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVE9ETzogc2V0IGEgY2FsbGJhY2sgaW4gUEIuTmV0IGluc3RlYWQgb2YgY2FsbGluZyBQQi5EYXRhIGRpcmVjdGx5XG4gICAgICAgIHZhciBoYXZlU2hlbGwgPSBQQi5EYXRhLmdldENhY2hlZFNoZWxsQnlTaWcoc2lnKSBcbiAgICAgICAgXG4gICAgICAgIGlmKCFoYXZlU2hlbGwpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIHRoZSBzaGVsbCB5ZXQsIHNvIGdvIGdldCBpdFxuICAgICAgICAgICAgLy8gVE9ETzogdXNlIGFib3ZlIGNhbGxiYWNrIHRvIFBCLkRhdGFcbiAgICAgICAgICAgIFBCLkRhdGEuZ2V0UHVmZkJ5U2lnKHNpZykgICAgICAgICAgICAgICAgICAgICAgIC8vIGVmZmVjdGZ1bFxuICAgICAgICAgICAgcmVtYWluaW5nLS1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGtpZHNpZ3Byb20gPSBQQi5OZXQuZ2V0S2lkU2lncyhzaWcpICAgICAgICAgICAgIC8vIGdldCBhbGwgaXRzIGNoaWxkcmVuXG4gICAgICAgIHJldHVybiBraWRzaWdwcm9tLnRoZW4oZnVuY3Rpb24oa2lkc2lncykge1xuICAgICAgICAgICAgZ2V0RW0odG9kby5zbGljZSgxKS5jb25jYXQoa2lkc2lncyksIGRvbmUuY29uY2F0KHNpZyksIHJlbWFpbmluZylcbiAgICAgICAgfSlcbiAgICB9XG59XG5cblBCLk5ldC5nZXRTaWJsaW5ncyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHRoaXMgY2FzZSBpcyB1Z2x5LCBzbyB3ZSdyZSBsZWF2aW5nIGl0IHVudGlsIHRoZSBjbGllbnQgYXBpIGNhbiBhbnN3ZXIgcXVlc3Rpb25zIGZvciB1c1xuICAgIHJldHVybiBQQi5lbXB0eVByb21pc2UoKSBcbn1cblxuLyoqXG4gKiBhZGQgcHVmZiB0byB0aGUgc2VydmVyIGFuZCBicm9hZGNhc3QgdG8gcGVlcnNcbiAqIEBwYXJhbSAge29iamVjdH0gcHVmZiB0aGUgcHVmZiB0byBiZSBhZGRlZCB0byB0aGUgc2VydmVyXG4gKi9cblBCLk5ldC5kaXN0cmlidXRlUHVmZiA9IGZ1bmN0aW9uKHB1ZmYpIHtcbiAgICAvLy8vIGRpc3RyaWJ1dGUgYSBwdWZmIHRvIHRoZSBuZXR3b3JrXG5cbiAgICBpZihQQi5DT05GSUcuZGlzYWJsZVNlbmRUb1NlcnZlcikgcmV0dXJuIGZhbHNlICAgICAgICAgIC8vIHNvIHlvdSBjYW4gd29yayBsb2NhbGx5XG5cbiAgICBpZihQQi5DT05GSUcubmV0YmxvY2tTdWZmaXgpIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJsb2NrIGRpc3RyaWJ1dGlvbiBvZiBsb2NhbCBwdWZmc1xuICAgICAgICB2YXIgdXNlcm5hbWVzID0gW3B1ZmYudXNlcm5hbWVdXG4gICAgICAgIGlmKHB1ZmYua2V5cylcbiAgICAgICAgICAgIHVzZXJuYW1lcyA9IHVzZXJuYW1lcy5jb25jYXQoT2JqZWN0LmtleXMocHVmZi5rZXlzKSlcblxuICAgICAgICB1c2VybmFtZXMgPSB1c2VybmFtZXMubWFwKFBCLlVzZXJzLmp1c3RVc2VybmFtZSlcbiAgICAgICAgdmFyIHN1ZmZpeGVzID0gdXNlcm5hbWVzLm1hcChmdW5jdGlvbih1c2VybmFtZSkge1xuICAgICAgICAgICAgdmFyIGNodW5rcyA9IHVzZXJuYW1lLnNwbGl0KCcuJylcbiAgICAgICAgICAgIHJldHVybiBjaHVua3NbY2h1bmtzLmxlbmd0aC0xXVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgaWYoc3VmZml4ZXMuaW5kZXhPZihQQi5DT05GSUcubmV0YmxvY2tTdWZmaXgpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBQQi5OZXQuc2VuZFB1ZmZUb1NlcnZlcihwdWZmKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpdCB0byB0aGUgc2VydmVyJ3MgcHVmZmxpc3RcblxuICAgIFBCLk5ldC5QMlAuc2VuZFB1ZmZUb1BlZXJzKHB1ZmYpICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJvYWRjYXN0IGl0IHRvIHBlZXJzXG59XG5cbi8qKlxuICogYWRkIGEgcHVmZiB0byB0aGUgc2VydmVyJ3MgcHVmZmxpc3RcbiAqIEBwYXJhbSAge29iamVjdH0gcHVmZlxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5QQi5OZXQuc2VuZFB1ZmZUb1NlcnZlciA9IGZ1bmN0aW9uKHB1ZmYpIHtcbiAgICAvLyBUSElOSzogdGhpcyBpcyBmaXJlLWFuZC1mb3JnZXQsIGJ1dCB3ZSBzaG91bGQgZG8gc29tZXRoaW5nIHNtYXJ0IGlmIHRoZSBuZXR3b3JrIGlzIG9mZmxpbmUgb3IgaXQgb3RoZXJ3aXNlIGZhaWxzLiBcbiAgICAvLyAgICAgICAgb24gdGhlIG90aGVyIGhhbmQsIHdlJ2xsIHByb2JhYmx5IHdhbnQgdG8gZG8gdGhpcyB3aXRoIHNvY2tldHMgaW5zdGVhZCBvZiBhamF4IHVsdGltYXRlbHkuLi5cbiAgICAvLyAgICAgICAgb3IgbWFuYWdlIGl0IGVudGlyZWx5IHdpdGggcm91dGluZywgZXZlbiBmb3Igc2VydmVyLXNlbnQgcHVmZnM/XG4gICAgXG4gICAgdmFyIGRhdGEgPSB7IHR5cGU6ICdhZGRQdWZmJ1xuICAgICAgICAgICAgICAgLCBwdWZmOiBKU09OLnN0cmluZ2lmeShwdWZmKSB9XG4gICAgICAgICAgICAgICBcbiAgICByZXR1cm4gUEIuTmV0LlBCcG9zdChQQi5DT05GSUcucHVmZkFwaSwgZGF0YSlcbiAgICAgICAgICAgICAgICAgLmNhdGNoKFBCLmNhdGNoRXJyb3IoJ0NvdWxkIG5vdCBzZW5kIHB1ZmYgdG8gc2VydmVyJykpXG59XG5cbi8qKlxuICogZmV0Y2ggYSBwYXJ0aWN1bGFyIHVzZXJSZWNvcmRcbiAqIEBwYXJhbSAge3N0cmluZ30gIHVzZXJuYW1lIFxuICogQHBhcmFtICB7c3RyaW5nfSAgY2FwYSBcbiAqIEByZXR1cm4ge3Byb21pc2V9IG9uIGZ1bGZpbGxlZCBwYXNzZXMgdGhlIHVzZXIgcmVjb3JkIGFzIG9iamVjdCwgb3RoZXJ3aXNlIHJlLXRocm93IGVycm9yXG4gKi9cblBCLk5ldC5nZXRVc2VyUmVjb3JkID0gZnVuY3Rpb24odXNlcm5hbWUsIGNhcGEpIHtcbiAgICB2YXIgdXJsICAgPSBQQi5DT05GSUcudXNlckFwaVxuICAgIFxuICAgIHZhciB2ZXJzaW9uZWRVc2VybmFtZSA9IFBCLlVzZXJzLm1ha2VWZXJzaW9uZWQodXNlcm5hbWUsIGNhcGEpXG4gICAgdXNlcm5hbWUgPSBQQi5Vc2Vycy5qdXN0VXNlcm5hbWUodmVyc2lvbmVkVXNlcm5hbWUpXG4gICAgXG4gICAgaWYoY2FwYSAhPT0gMCkgLy8gMCBzaWduYWxzIHRoYXQgd2UgbmVlZCB0byBmZXRjaCB0aGUgbGF0ZXN0IHVzZXJSZWNvcmRcbiAgICAgICAgY2FwYSA9IFBCLlVzZXJzLmp1c3RDYXBhKHZlcnNpb25lZFVzZXJuYW1lKVxuICAgIFxuICAgIHZhciBkYXRhICA9IHsgdHlwZTogJ2dldFVzZXInXG4gICAgICAgICAgICAgICAgLCB1c2VybmFtZTogdXNlcm5hbWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICBpZihjYXBhKVxuICAgICAgICBkYXRhLmNhcGEgPSBjYXBhXG5cbiAgICByZXR1cm4gUEIuTmV0LlBCZ2V0SlNPTih1cmwsIGRhdGEpXG59XG5cblxuLyoqXG4gKiBtb2RpZnkgYSB1c2VyIHJlY29yZFxuICogQHBhcmFtICB7cHVmZn0gICBwdWZmIGEgc2lnbmVkIHB1ZmYgY29udGFpbmluZyBpbmZvcm1hdGlvbiBvZiBtb2RpZmllZCB1c2VyIHJlY29yZFxuICogQHJldHVybiB7b2JqZWN0fSBwcm9taXNlIGZvciBuZXcgdXNlclJlY29yZCBvciBlcnJvciB3aGVuIHRoZSB1cGRhdGUgZmFpbHNcbiAqL1xuUEIuTmV0LnVwZGF0ZVVzZXJSZWNvcmQgPSBmdW5jdGlvbihwdWZmKSB7XG4gICAgdmFyIGRhdGEgPSB7IHR5cGU6ICd1cGRhdGVVc2luZ1B1ZmYnXG4gICAgICAgICAgICAgICAsIHB1ZmY6IHB1ZmZcbiAgICAgICAgICAgICAgIH1cblxuICAgIHZhciBwcm9tID0gUEIuTmV0LlBCcG9zdChQQi5DT05GSUcudXNlckFwaSwgZGF0YSlcbiAgICBcbiAgICByZXR1cm4gcHJvbS5jYXRjaChQQi5jYXRjaEVycm9yKCdTZW5kaW5nIHVzZXIgcmVjb3JkIG1vZGlmaWNhdGlvbiBwdWZmIGZhaWxlZCcpKVxuICAgICAgICAgICAgICAgLnRoZW4oSlNPTi5wYXJzZSkgLy8gVEhJTks6IHRoaXMgdGhyb3dzIG9uIGludmFsaWQgSlNPTlxuICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24odXNlclJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgIHJldHVybiBQQi5Vc2Vycy5wcm9jZXNzKHVzZXJSZWNvcmQpXG4gICAgICAgICAgICAgICAgICAgICAgIHx8IFBCLnRocm93RXJyb3IoJ0ludmFsaWQgdXNlciByZWNvcmQnLCBKU09OLnN0cmluZ2lmeSh1c2VyUmVjb3JkKSlcbiAgICAgICAgICAgICAgIH0pXG59XG5cblxuXG4vKipcbiAqIFBCLk5ldCBwcm9taXNlLWJhc2VkIFhIUiBsYXllclxuICogXG4gKiBXZSB1c2UgcHJvbWlzZXMgYXMgb3VyIGRlZmF1bHQgY29uY3VycmVuY3kgY29uc3RydWN0LCBcbiAqIGJlY2F1c2UgdWx0aW1hdGVseSB0aGlzIHBsYXRmb3JtIGlzIGNvbXBvc2VkIG9mIGEgXG4gKiBodWdlIHNldCBvZiBpbnRlcmRlcGVuZGVudCBhc3luYyBjYWxscyB3aGljaCBtb3N0bHkgXG4gKiBlYWNoIHJlc29sdmUgdG8gYSBzaW5nbGUgaW1tdXRhYmxlIGVudGl0eSBcbiAqIC0tIGFrYSB0aGUgcHJvbWlzZSBzd2VldCBzcG90LlxuICogXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVybCAgICAgcmVxdWVzdGVkIHVybFxuICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zIFxuICogQHBhcmFtICB7b2JqZWN0fSBkYXRhICAgIFxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5QQi5OZXQueGhyID0gZnVuY3Rpb24odXJsLCBvcHRpb25zLCBkYXRhKSB7XG4gICAgLy8vLyB2ZXJ5IHNpbXBsZSBwcm9taXNlLWJhc2VkIFhIUiBpbXBsZW1lbnRhdGlvblxuICAgIFxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gICAgICAgIHJlcS5vcGVuKG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLCB1cmwpXG4gICAgICAgIFxuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zLmhlYWRlcnMgfHwge30pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBvcHRpb25zLmhlYWRlcnNba2V5XSlcbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIHZhciBmb3JtZGF0YSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgICAgIE9iamVjdC5rZXlzKGRhdGEgfHwge30pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIGRhdHVtID0gdHlwZW9mIGRhdGFba2V5XSA9PSAnb2JqZWN0JyA/IFBCLnN0cmluZ2lmeUpTT04oZGF0YVtrZXldKSA6IGRhdGFba2V5XVxuICAgICAgICAgICAgZm9ybWRhdGEuYXBwZW5kKGtleSwgZGF0dW0pXG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICBpZihvcHRpb25zICYmIG9wdGlvbnMudHlwZSlcbiAgICAgICAgICAgIHJlcS5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnR5cGVcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgcmVxLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYocmVxLnN0YXR1cyAhPSAyMDApIC8vIHNpbGx5IHNhZmFyaVxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoUEIubWFrZUVycm9yKHJlcS5zdGF0dXNUZXh0KSlcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYocmVxLnJlc3BvbnNlVHlwZSA9PSAnanNvbicgJiYgcmVxLnJlc3BvbnNlID09PSBudWxsKSAvLyBOT1RFOiB0cmFwcyBKU09OaWZpZWQgJ251bGwnIHJlc3BvbnNlcyBhbHNvOiB1c2UgZW1wdHkgc3RyaW5nIG9yIFtdIHRvIGluZGljYXRlIGFuIGVtcHR5IHJlc3VsdFxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoUEIubWFrZUVycm9yKFwiSW52YWxpZCBKU09OIGluIHJlc3BvbnNlXCIsIHJlcS5yZXNwb25zZSkpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJlc29sdmUoIChyZXEucmVzcG9uc2VUeXBlICE9IG9wdGlvbnMudHlwZSkgLy8gbWFudWFsbHkgY29udmVydCBqc29uIGZvciBvbGQgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICAgICYmIG9wdGlvbnMudHlwZSA9PSAnanNvbicgPyBQQi5wYXJzZUpTT04ocmVxLnJlc3BvbnNlKSA6IHJlcS5yZXNwb25zZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHJlamVjdChQQi5tYWtlRXJyb3IoXCJOZXR3b3JrIEVycm9yXCIsIGV2ZW50LCAnbmV0d29ya0Vycm9yJykpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJlcS5vbnRpbWVvdXQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgcmVqZWN0KFBCLm1ha2VFcnJvcihcIlRpbWVvdXQgRXJyb3JcIiwgZXZlbnQsICd0aW1lb3V0RXJyb3InKSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmVxLnRpbWVvdXQgPSBQQi5DT05GSUcubmV0d29ya1RpbWVvdXRcblxuICAgICAgICByZXEuc2VuZChmb3JtZGF0YSlcbiAgICB9KVxufVxuXG4vKipcbiAqIHJlcXVlc3QgYW4gdXJsLCBnZXQgcmVzdWx0IGluIEpTT05cbiAqIEBwYXJhbSAge3N0cmluZ30gdXJsICAgIFxuICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbXMgXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cblBCLk5ldC5nZXRKU09OID0gZnVuY3Rpb24odXJsLCBwYXJhbXMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHsgaGVhZGVyczogeyAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgICAgICAgICwgIG1ldGhvZDogJ0dFVCdcbiAgICAgICAgICAgICAgICAgICwgICAgdHlwZTogJ2pzb24nXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICB2YXIgcGFyYW1zID0gcGFyYW1zIHx8IHt9XG4gICAgdmFyIGVuYyA9IGZ1bmN0aW9uKHBhcmFtKSB7cmV0dXJuICFwYXJhbSAmJiBwYXJhbSE9PTAgPyAnJyA6IGVuY29kZVVSSUNvbXBvbmVudChwYXJhbSl9XG4gICAgdmFyIHFzdHJpbmcgPSBPYmplY3Qua2V5cyhwYXJhbXMpLnJlZHVjZShmdW5jdGlvbihhY2MsIGtleSkge3JldHVybiBhY2MgKyBlbmMoa2V5KSArJz0nKyBlbmMocGFyYW1zW2tleV0pICsnJid9LCAnPycpXG5cbiAgICByZXR1cm4gUEIuTmV0Lnhocih1cmwgKyBxc3RyaW5nLCBvcHRpb25zKSBcbn1cblxuXG4vKipcbiAqIHNlbmQgYSBwb3N0IHJlcXVlc3RcbiAqIEBwYXJhbSAge3N0cmluZ30gdXJsICByZXF1ZXN0ZWQgdXJsXG4gKiBAcGFyYW0gIHtvYmplY3R9IGRhdGEgXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cblBCLk5ldC5wb3N0ID0gZnVuY3Rpb24odXJsLCBkYXRhKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7IGhlYWRlcnM6IHsgICBcbi8vICAgICAgICAgJ0NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnIFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAsICdDb250ZW50LWxlbmd0aCc6IHBhcmFtcy5sZW5ndGhcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgLCAgICAgJ0Nvbm5lY3Rpb24nOiAnY2xvc2UnICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLCAgbWV0aG9kOiAnUE9TVCdcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgIHJldHVybiBQQi5OZXQueGhyKHVybCwgb3B0aW9ucywgZGF0YSlcbn1cblxuXG5cbi8qKlxuICogQSBjdXN0b21pemVkIHdyYXBwZXIgZm9yIHRoZSBFdmVyeUJpdCBzZXJ2ZXIgb3ZlciB0aGUgYmFzZSBYSFIgcHJvbWlzZSB3cmFwcGVyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVybCAgICBcbiAqIEBwYXJhbSAge29iamVjdH0gcGFyYW1zIFxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5QQi5OZXQuUEJ4aHIgPSBmdW5jdGlvbih1cmwsIG9wdGlvbnMsIGRhdGEpIHtcbiAgICB2YXIgcHJvbSA9IFBCLk5ldC54aHIodXJsLCBvcHRpb25zLCBkYXRhKVxuICAgICAgICBcbiAgICByZXR1cm4gcHJvbS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmKHJlc3BvbnNlLkZBSUwpXG4gICAgICAgICAgICByZXR1cm4gUEIudGhyb3dESFRFcnJvcihyZXNwb25zZS5GQUlMKVxuXG4gICAgICAgIGlmKHR5cGVvZiByZXNwb25zZSA9PSAnc3RyaW5nJyAmJiByZXNwb25zZS5zbGljZSgwLDYpID09ICd7XCJGQUlMJylcbiAgICAgICAgICAgIHJldHVybiBQQi50aHJvd0RIVEVycm9yKChQQi5wYXJzZUpTT04ocmVzcG9uc2UpfHx7fSkuRkFJTClcblxuICAgICAgICBQQi5ydW5IYW5kbGVycygnbmV0d29ya3Jlc3BvbnNlJywgcmVzcG9uc2UpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzcG9uc2VcbiAgICB9KVxufVxuXG5QQi5OZXQuUEJwb3N0ID0gZnVuY3Rpb24odXJsLCBkYXRhKSB7XG4gICAgLy8vLyBUaGlzIGlzIHRoZSBFdmVyeUJpdCBzZXJ2ZXIgdmVyc2lvbiBvZiBQQi5OZXQuZ2V0SlNPTiAtLSB1c2UgdGhhdCBmdW5jdGlvbiBpZiB5b3UncmUgbm90IGFjY2Vzc2luZyB0aGUgRXZlcnlCaXQgc2VydmVyXG4gICAgLy8gVEhJTks6IHNob3VsZCB3ZSBwYXJhbWV0cml6ZSBvdmVyIHRoZSBkaXNwYXRjaCBmdW5jdGlvbj9cbiAgICB2YXIgb3B0aW9ucyA9IHsgaGVhZGVyczoge31cbiAgICAgICAgICAgICAgICAgICwgIG1ldGhvZDogJ1BPU1QnXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBcbiAgICByZXR1cm4gUEIuTmV0LlBCeGhyKHVybCwgb3B0aW9ucywgZGF0YSlcbn1cblxuUEIuTmV0LlBCZ2V0SlNPTiA9IGZ1bmN0aW9uKHVybCwgcGFyYW1zKSB7XG4gICAgLy8vLyBUaGlzIGlzIHRoZSBFdmVyeUJpdCBzZXJ2ZXIgdmVyc2lvbiBvZiBQQi5OZXQuZ2V0SlNPTiAtLSB1c2UgdGhhdCBmdW5jdGlvbiBpZiB5b3UncmUgbm90IGFjY2Vzc2luZyB0aGUgRXZlcnlCaXQgc2VydmVyXG4gICAgLy8gVEhJTks6IHNob3VsZCB3ZSBwYXJhbWV0cml6ZSBvdmVyIHRoZSBkaXNwYXRjaCBmdW5jdGlvbj9cbiAgICB2YXIgb3B0aW9ucyA9IHsgaGVhZGVyczogeyAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgICAgICAgICAgICAgICwgIG1ldGhvZDogJ0dFVCdcbiAgICAgICAgICAgICAgICAgICwgICAgdHlwZTogJ2pzb24nXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICB2YXIgcGFyYW1zID0gcGFyYW1zIHx8IHt9XG4gICAgdmFyIGVuYyA9IGZ1bmN0aW9uKHBhcmFtKSB7cmV0dXJuICFwYXJhbSAmJiBwYXJhbSE9PTAgPyAnJyA6IGVuY29kZVVSSUNvbXBvbmVudChwYXJhbSl9XG4gICAgdmFyIHFzdHJpbmcgPSBPYmplY3Qua2V5cyhwYXJhbXMpLnJlZHVjZShmdW5jdGlvbihhY2MsIGtleSkge3JldHVybiBhY2MgKyBlbmMoa2V5KSArJz0nKyBlbmMocGFyYW1zW2tleV0pICsnJid9LCAnPycpXG5cbiAgICByZXR1cm4gUEIuTmV0LlBCeGhyKHVybCArIHFzdHJpbmcsIG9wdGlvbnMpIFxufVxuXG5cblxuXG5cblxuXG5cbi8qXG5cbiAgICBQQi5OZXQgUGVlci10by1QZWVyIGxheWVyXG5cbiAgICBXZSdyZSBjdXJyZW50bHkgdXNpbmcgcGVlci5qcyB0byBuZWdvdGlhdGUgdGhlIFdlYlJUQyBjb25uZWN0aW9uLiBUaGVyZSdzIGEgbG90IG9mIHdvcmsgbGVmdCB0byBiZSBkb25lIGhlcmUuXG5cbiovXG5cblxuUEIuTmV0LlAyUCA9IHt9XG5QQi5OZXQuUDJQLnBlZXJzID0ge31cblxuLyoqXG4gKiBpbml0aWFsaXplIHRoZSBwZWVyLXRvLXBlZXIgbGF5ZXJcbiAqL1xuUEIuTmV0LlAyUC5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gTk9URTogeW91IGhhdmUgdG8gbWFudWFsbHkgZW5hYmxlIHRoZSBQMlAgbGF5ZXIgdmlhIGNvbmZpZyBvciBpbml0IG9wdGlvbnNcbiAgICAvLyBlLmcuIFBCLmluaXQoe2VuYWJsZVAyUDogdHJ1ZX0pXG4gICAgLy8gb3IgICBQQi5DT05GSUcuZW5hYmxlUDJQID0gdHJ1ZVxuICAgIGlmKCFQQi5DT05GSUcuZW5hYmxlUDJQKSByZXR1cm4gZmFsc2VcbiAgICBcbiAgICBQQi5OZXQuUDJQLlBlZXIgPSBuZXcgUGVlcih7IGhvc3Q6ICAnMTYyLjIxOS4xNjIuNTYnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBwb3J0OiAgOTAwMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgcGF0aDogICcvJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgZGVidWc6IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgIFxuICAgIFBCLk5ldC5QMlAuUGVlci5vbignb3BlbicsIFBCLk5ldC5QMlAub3BlblBlZXJDb25uZWN0aW9uKVxuICAgIFBCLk5ldC5QMlAuUGVlci5vbignY29ubmVjdGlvbicsIFBCLk5ldC5QMlAuY29ubmVjdGlvbilcbn1cblxuLyoqXG4gKiB0byByZWxvYWQgcGVlcnNcbiAqIEByZXR1cm4ge29iamVjdH0gXG4gKi9cblBCLk5ldC5QMlAucmVsb2FkUGVlcnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUEIuTmV0LlAyUC5QZWVyLmxpc3RBbGxQZWVycyhQQi5OZXQuUDJQLmhhbmRsZVBlZXJzKVxufVxuXG4vKipcbiAqIG9wZW4gcGVlciBjb25uZWN0aW9uXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGlkIFxuICogQHJldHVybiB7b2JqZWN0W119XG4gKi9cblBCLk5ldC5QMlAub3BlblBlZXJDb25uZWN0aW9uID0gZnVuY3Rpb24oaWQpIHtcbiAgICAvLyBPUFQ6IGRvIHdlIHJlYWxseSBuZWVkIHRoaXM/IFxuICAgIC8vIFRISU5LOiB3aHkgbm90IGp1c3QgY2FsbCBQQi5OZXQuUDJQLnJlbG9hZFBlZXJzP1xuICAgIHJldHVybiBQQi5OZXQuUDJQLlBlZXIubGlzdEFsbFBlZXJzKFBCLk5ldC5QMlAuaGFuZGxlUGVlcnMpXG59XG5cbi8qKlxuICogY29ubmVjdGlvblxuICogQHBhcmFtIGNvbm5lY3Rpb25cbiAqIEByZXR1cm5zIHsqfVxuICovXG5QQi5OZXQuUDJQLmNvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgUEIuTmV0LlAyUC5yZWxvYWRQZWVycygpIC8vIE9QVDogZG8gd2UgcmVhbGx5IG5lZWQgdGhpcz8gXG5cbiAgICByZXR1cm4gY29ubmVjdGlvbi5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgUEIuRGF0YS5hZGRTaGVsbHNUaGVuTWFrZUF2YWlsYWJsZShkYXRhKSAvLyBUT0RPOiBwYXNzIGEgY2FsbGJhY2sgaW4gdG8gUEIuTmV0IGluc3RlYWQgb2YgY2FsbGluZyB0aGlzIGRpcmVjdGx5XG4gICAgfSlcbn1cblxuLyoqXG4gKiB0byBoYW5kbGUgcGVlcnNcbiAqIEBwYXJhbSAge29iamVjdH0gcGVlcnMgXG4gKiBAcmV0dXJuIHtib29sZWFufSAgIFxuICovXG5QQi5OZXQuUDJQLmhhbmRsZVBlZXJzID0gZnVuY3Rpb24ocGVlcnMpIHtcbiAgICBwZWVycy5mb3JFYWNoKGZ1bmN0aW9uKHBlZXIpIHtcbiAgICAgICAgaWYoUEIuTmV0LlAyUC5wZWVyc1twZWVyXSkgXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgUEIuTmV0LlAyUC5wZWVyc1twZWVyXSA9IFBCLk5ldC5QMlAuUGVlci5jb25uZWN0KHBlZXIpXG4gICAgfSlcbn1cblxuLyoqXG4gKiB0byBzZW5kIHB1ZmYgdG8gcGVlcnNcbiAqIEBwYXJhbSAge29iamVjdH0gcHVmZlxuICovXG5QQi5OZXQuUDJQLnNlbmRQdWZmVG9QZWVycyA9IGZ1bmN0aW9uKHB1ZmYpIHtcbiAgICBmb3IodmFyIHBlZXIgaW4gUEIuTmV0LlAyUC5wZWVycykge1xuICAgICAgICBQQi5OZXQuUDJQLnBlZXJzW3BlZXJdLnNlbmQocHVmZilcbiAgICB9XG59IiwiLypcblxuICAgIERhdGEgbWFuYWdlbWVudCBmb3IgdGhlIEV2ZXJ5Qml0IHBsYXRmb3JtLlxuICAgIFxuICAgIEFsbCBwdWZmLXJlbGF0ZWQgZGF0YSBmbG93cyB0aHJvdWdoIGhlcmU6XG4gICAgY2FjaGluZywgcGVyc2lzdGVuY2UsIG9wdGltaXphdGlvbnMgYW5kIG5ldHdvcmsgYWNjZXNzIGFyZSBtYW5hZ2VkIHRocm91Z2ggdGhpcyBtb2R1bGUuXG5cbiAgICBDb3B5cmlnaHQgMjAxNCBFdmVyeUJpdC4gU2VlIFJFQURNRSBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuICovXG5cblBCLkRhdGEgPSB7fVxuLy8gUEIuRGF0YS5wdWZmcyA9IFtdXG5QQi5EYXRhLmJvbmlpID0ge31cblBCLkRhdGEuc2hlbGxzID0gW11cblBCLkRhdGEuc2hlbGxTb3J0ID0ge31cbi8vIFBCLkRhdGEuc2hlbGYgPSBbXVxuUEIuRGF0YS5wZW5kaW5nUHVmZlByb21pc2VzID0ge31cblxuUEIuRGF0YS5wcm9maWxlcyA9IHt9XG5cblBCLkRhdGEuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAvLyBUSElOSzogZGlzYWJsaW5nIHByZWxvYWRpbmcgbWF5IGFmZmVjdCBvbGRlciBFQiBleGFtcGxlIGNvZGVcbiAgICAvLyBpZighb3B0aW9ucy5kaXNhYmxlUHVibGljUHVmZnMpXG4gICAgLy8gICAgIFBCLkRhdGEuaW1wb3J0U2hlbGxzKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmVsb2FkIHJlbGV2YW50IHNoZWxsc1xuICAgIFBCLmFkZEJlZm9yZVN3aXRjaElkZW50aXR5SGFuZGxlcihQQi5EYXRhLnJlbW92ZUFsbFByaXZhdGVTaGVsbHMpICAgLy8gY2xlYXIgcHJpdmF0ZSBjYWNoZXNcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLyBuZXcgZ3JhcGggc3R1ZmYgLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuUEIuRGF0YS5hZGRTaWdBc1ZlcnRleCA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHZhciBtYXRjaGVzID0gUEIuRGF0YS5ncmFwaC52KHNpZykucnVuKClcbiAgICBcbiAgICBpZihtYXRjaGVzLmxlbmd0aCkgcmV0dXJuIGZhbHNlICAgICAgICAgLy8gcmV0dXJucyBmYWxzZSBpZiBub3RoaW5nIGhhcHBlbnNcbiAgICBcbiAgICByZXR1cm4gUEIuRGF0YS5ncmFwaC5hZGRWZXJ0ZXgoe19pZDogc2lnLCBuYW1lOiBzaWcsIHR5cGU6ICdzaGVsbCd9KSB8fCB0cnVlXG59XG5cblBCLkRhdGEuYWRkU2hlbGxBc1ZlcnRleCA9IGZ1bmN0aW9uKHNoZWxsKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBQQi5EYXRhLmdyYXBoLnYoc2hlbGwuc2lnKS5ydW4oKVxuICAgIFxuICAgIGlmKCFtYXRjaGVzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFBCLkRhdGEuZ3JhcGguYWRkVmVydGV4KHsgX2lkOiBzaGVsbC5zaWcsIG5hbWU6IHNoZWxsLnNpZywgc2hlbGw6IHNoZWxsLCB0eXBlOiAnc2hlbGwnIH0pIHx8IHRydWVcbiAgICBcbiAgICB2YXIgdmVydGV4ID0gbWF0Y2hlc1swXVxuICAgIGlmKHZlcnRleC5zaGVsbCkgcmV0dXJuIGZhbHNlICAgICAgICAgICAvLyBOT1RFOiByZXR1cm5zIGZhbHNlIGlmIGl0IGRvZXMgbm90aGluZ1xuICAgIFxuICAgIHJldHVybiB2ZXJ0ZXguc2hlbGwgPSBzaGVsbCAgICAgICAgICAgICAvLyBOT1RFOiBtdXRhdGlvbiAmIHBvaW50ZXIgc2V0dGluZ1xufVxuXG5QQi5EYXRhLmFkZFNoZWxsVXNlcm5hbWVBc1ZlcnRleCA9IGZ1bmN0aW9uKHNoZWxsKSB7XG4gICAgLy8vLyBhZGQgc2hlbGwudXNlcm5hbWUgdG8gZ3JhcGggYW5kIGNvbm5lY3QgdGhlbSB1cFxuICAgIFxuICAgIHZhciB1c2VybmFtZSA9IHNoZWxsLnVzZXJuYW1lXG4gICAgdmFyIG1hdGNoZXMgPSBQQi5EYXRhLmdyYXBoLnYodXNlcm5hbWUpLnJ1bigpXG4gICAgdmFyIHZlcnRleCA9IG1hdGNoZXNbMF1cbiAgICBcbiAgICBpZighdmVydGV4KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVEhJTks6IG1ha2UgdXNlcm5hbWVzIHVuaXF1ZSBsaWtlIFVTRVJOQU1FOjo8dXNlcm5hbWU+IG9yIHNvbWV0aGluZ1xuICAgICAgICB2ZXJ0ZXggPSBQQi5EYXRhLmdyYXBoLmFkZFZlcnRleCh7IF9pZDogdXNlcm5hbWUsIG5hbWU6IHVzZXJuYW1lLCB0eXBlOiAndXNlcm5hbWUnIH0pXG4gICAgZWxzZVxuICAgICAgICBpZihQQi5EYXRhLmdyYXBoLnYoc2hlbGwuc2lnKS5vdXQoJ2F1dGhvcicpLnByb3BlcnR5KCduYW1lJykucnVuKClbMF0gPT0gdXNlcm5hbWUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgXG4gICAgLy8gVE9ETzogYWRkIGVhc3kgZmlsdGVyaW5nIGJ5IHZlcnRleCB0eXBlIGZvciBib3RoICd2JyBhbmQgYWxzbyBvdXRWIGV0Y1xuICAgIFBCLkRhdGEuZ3JhcGguYWRkRWRnZSh7IF9vdXQ6IHNoZWxsLnNpZywgX2luOiBzaGVsbC51c2VybmFtZSwgX2xhYmVsOiAnYXV0aG9yJ30pXG59XG5cblBCLkRhdGEuZ3JhcGggPSBEYWdvYmEuZ3JhcGgoKVxuXG5QQi5EYXRhLmFkZFRvR3JhcGggPSBmdW5jdGlvbihzaGVsbHMpIHtcbiAgICBzaGVsbHMuZm9yRWFjaChQQi5EYXRhLmFkZFNoZWxsQXNWZXJ0ZXgpXG4gICAgc2hlbGxzLmZvckVhY2goUEIuRGF0YS5hZGRTaGVsbFVzZXJuYW1lQXNWZXJ0ZXgpXG4gICAgUEIucnVuSGFuZGxlcnMoJ3JlbGF0aW9uc2hpcCcsIHNoZWxscylcbn1cblxuLy8gVE9ETzogYWxpYXMgY2hpbGRyZW4oKSBhcyAuaW4oJ3BhcmVudCcpIGFuZCBwYXJlbnRzKCkgYXMgLm91dCgncGFyZW50JykgYW5kIHVzZSB0aG9zZSBpbnN0ZWFkIChoYWx2ZXMgIyBvZiBlZGdlcylcblxuLy8vLy8vLy8vLy8vLy8vLy8gZW5kIG5ldyBncmFwaCBzdHVmZiAvLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cblxuUEIuRGF0YS5nZXRBbGxNeVNoZWxscyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwdWJsaWNTaGVsbHMgPSBQQi5EYXRhLmdldFB1YmxpY1NoZWxscygpXG4gICAgdmFyIHByaXZhdGVTaGVsbHMgPSBQQi5EYXRhLmdldEN1cnJlbnREZWNyeXB0ZWRMZXR0ZXJzKClcbiAgICByZXR1cm4gcHVibGljU2hlbGxzLmNvbmNhdChwcml2YXRlU2hlbGxzKVxufVxuXG5cbi8qKlxuICogZ2V0IGFsbCBjdXJyZW50bHkga25vd24gc2hlbGxzXG4gKiBAcmV0dXJuIHtTaGVsbFtdfVxuICovXG5QQi5EYXRhLmdldFNoZWxscyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vLy8gR2V0IGFsbCBjdXJyZW50bHkga25vd24gc2hlbGxzXG4gICAgLy8gTk9URTogYWx3YXlzIHVzZSB0aGlzIGFjY2Vzc29yIGluc3RlYWQgb2YgcmVmZXJlbmNpbmcgUEIuRGF0YS5zaGVsbHMgZGlyZWN0bHksIGFzIHdoYXQgdGhpcyBmdW5jdGlvbiBkb2VzIHdpbGwgY2hhbmdlLlxuICAgIHJldHVybiBQQi5EYXRhLnNoZWxsc1xufVxuXG4vKipcbiAqIGdldCBhbGwgcHVibGljIHNoZWxsc1xuICogQHJldHVybnMge1NoZWxsW119XG4gKi9cblBCLkRhdGEuZ2V0UHVibGljU2hlbGxzID0gZnVuY3Rpb24oKSB7XG4gICAgLy8vLyBHZXQgYWxsIHB1YmxpYyBzaGVsbHNcbiAgICB2YXIgc2hlbGxzID0gUEIuRGF0YS5nZXRTaGVsbHMoKVxuICAgIHJldHVybiBzaGVsbHMuZmlsdGVyKGZ1bmN0aW9uKHNoZWxsKSB7cmV0dXJuICFzaGVsbC5rZXlzfSlcbn1cblxuLyoqXG4gKiBHZXQgY2FjaGVkIHNoZWxscyBieSBzaWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaWdcbiAqIEByZXR1cm5zIHtzaGVsbFtdfVxuICovXG5QQi5EYXRhLmdldENhY2hlZFNoZWxsQnlTaWcgPSBmdW5jdGlvbihzaWcpIHtcbiAgICByZXR1cm4gUEIuRGF0YS5zaGVsbFNvcnRbc2lnXVxuICAgIC8vIHJldHVybiBQQi5EYXRhLmdldFNoZWxscygpLmZpbHRlcihmdW5jdGlvbihzaGVsbCkgeyByZXR1cm4gc2lnID09PSBzaGVsbC5zaWcgfSlbMF1cbn1cblxuLyoqXG4gKiBhZGRzIGJvbnVzXG4gKiBAcGFyYW0ge29iamVjdH0gcHVmZlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cblBCLkRhdGEuYWRkQm9udXMgPSBmdW5jdGlvbihwdWZmLCBrZXksIHZhbHVlKSB7XG4gICAgLy8vLyB0aGlzIHNpbXVsYXRlcyBhIFdlYWtNYXBcbiAgICAvLyBUSElOSzogd2UnbGwgbmVlZCB0byBwcm92aWRlIHNvbWUgR0MgaGVyZVxuICAgIHZhciBpZCA9IHB1ZmYuc2lnXG4gICAgXG4gICAgaWYoIVBCLkRhdGEuYm9uaWlbaWRdKVxuICAgICAgICBQQi5EYXRhLmJvbmlpW2lkXSA9IHt9XG4gICAgXG4gICAgUEIuRGF0YS5ib25paVtpZF1ba2V5XSA9IHZhbHVlXG59XG5cbi8qKlxuICogZ2V0cyBib251c1xuICogQHBhcmFtIHB1ZmZcbiAqIEBwYXJhbSBrZXlcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblBCLkRhdGEuZ2V0Qm9udXMgPSBmdW5jdGlvbihwdWZmLCBrZXkpIHtcbiAgICAvLy8vIHB1bGwgZnJvbSBvdXIgRmF1eFdlYWtNYXBcbiAgICB2YXIgaWQgPSBwdWZmLnNpZ1xuICAgIHZhciBwdWZmQm9uaWkgPSBQQi5EYXRhLmJvbmlpW2lkXVxuICAgIHJldHVybiBwdWZmQm9uaWkgJiYgcHVmZkJvbmlpW2tleV1cbn1cblxuXG5cblxuXG5cblxuXG5QQi5EYXRhLmFkZFN0YXIgPSBmdW5jdGlvbihzaWcsIHVzZXJuYW1lLCBzdGFyc2lnKSB7XG4gICAgLy8gVE9ETzogY29uc2lkZXIgbW92aW5nIHRoaXMgdG8gYSBtb2R1bGVcbiAgICBcbiAgICB2YXIgZmF1eHNoZWxsID0ge3NpZzogc2lnfSAvLyBUSElOSzogY2FuIHdlIGZvcm1hbGl6ZSB0aGlzP1xuICAgIHZhciBzdGFyU3RhdHMgPSBQQi5EYXRhLmdldEJvbnVzKGZhdXhzaGVsbCwgJ3N0YXJTdGF0cycpIHx8IHtzY29yZTogMCwgZnJvbToge319XG4gICAgXG4gICAgc3RhclN0YXRzLmZyb21bdXNlcm5hbWVdID0gc3RhcnNpZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZG1pdHRlZGx5IHN0cmFuZ2UsIGJ1dCBoZWxwZnVsIHdoZW4gdW5zdGFycmluZ1xuICAgIHN0YXJTdGF0cy5zY29yZSA9IFBCLkRhdGEuc2NvcmVTdGFycyhPYmplY3Qua2V5cyhzdGFyU3RhdHMuZnJvbSkpICAvLyBPUFQ6IE8obl4yKSBpbiBzdGFycy1wZXItcHVmZlxuICAgIFxuICAgIFBCLkRhdGEuYWRkQm9udXMoZmF1eHNoZWxsLCAnc3RhclN0YXRzJywgc3RhclN0YXRzKVxufVxuXG5QQi5EYXRhLnJlbW92ZVN0YXIgPSBmdW5jdGlvbihzaWcsIHVzZXJuYW1lKSB7XG4gICAgLy8gVE9ETzogY29uc2lkZXIgbW92aW5nIHRoaXMgdG8gYSBtb2R1bGVcbiAgICBcbiAgICB2YXIgZmF1eHNoZWxsID0ge3NpZzogc2lnfSAvLyBUSElOSzogeWUgZ2FkcyBpcyB0aGlzIHVnbHlcbiAgICB2YXIgc3RhclN0YXRzID0gUEIuRGF0YS5nZXRCb251cyhmYXV4c2hlbGwsICdzdGFyU3RhdHMnKSB8fCB7c2NvcmU6IDAsIGZyb206IHt9fVxuICAgIFxuICAgIGRlbGV0ZSBzdGFyU3RhdHMuZnJvbVt1c2VybmFtZV1cbiAgICBcbiAgICBzdGFyU3RhdHMuc2NvcmUgPSBQQi5EYXRhLnNjb3JlU3RhcnMoT2JqZWN0LmtleXMoc3RhclN0YXRzLmZyb20pKSAgLy8gT1BUOiBPKG5eMikgaW4gc3RhcnMtcGVyLXB1ZmZcbiAgICBcbiAgICBQQi5EYXRhLmFkZEJvbnVzKGZhdXhzaGVsbCwgJ3N0YXJTdGF0cycsIHN0YXJTdGF0cylcbn1cblxuUEIuRGF0YS5zY29yZVN0YXJzID0gZnVuY3Rpb24odXNlcm5hbWVzKSB7XG4gICAgXG4gICAgcmV0dXJuIDBcbiAgICBcbiAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgaW50byBhIG1vZHVsZVxuICAgIC8qXG4gICAgdmFyIHRsdVNjb3JlID0gMDtcbiAgICB2YXIgc3VTY29yZSA9IDA7XG4gICAgdmFyIHNjb3JlUHJlZiA9IEJvcm9uLnNoYWxsb3dfY29weShwdWZmd29ybGRwcm9wcy52aWV3LnNjb3JlKTtcbiAgICBmb3IgKHZhciBrIGluIHNjb3JlUHJlZikge1xuICAgICAgICBpZiAoc2NvcmVQcmVmW2tdKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHBhcnNlRmxvYXQoc2NvcmVQcmVmW2tdKTtcbiAgICAgICAgICAgIGlmIChpc05hTihzKSlcbiAgICAgICAgICAgICAgICBzID0gcGFyc2VGbG9hdChwdWZmd29ybGRkZWZhdWx0cy52aWV3LnNjb3JlW2tdKTtcbiAgICAgICAgICAgIHNjb3JlUHJlZltrXSA9IHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdXNlcm5hbWVzLmZvckVhY2goZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAgICAgaWYgKHVzZXJuYW1lLmluZGV4T2YoJy4nKSA9PSAtMSkge1xuICAgICAgICAgICAgdGx1U2NvcmUgKz0gc2NvcmVQcmVmLnRsdVZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VTY29yZSArPSBzY29yZVByZWYuc3VWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgXG4gICAgdmFyIHNjb3JlID0gdGx1U2NvcmUgKyBNYXRoLm1pbihzY29yZVByZWYubWF4U3VWYWx1ZSwgc3VTY29yZSk7XG4gICAgc2NvcmUgPSBzY29yZS50b0ZpeGVkKDEpO1xuICAgIGlmIChzY29yZSA9PSBwYXJzZUludChzY29yZSkpIHNjb3JlID0gcGFyc2VJbnQoc2NvcmUpO1xuICAgIHJldHVybiBzY29yZVxuICAgICovXG59XG5cblxuXG5cblxuXG5cblxuLypcbiAgICBTb21lIG5ldyBzaGVsbCBoYW5kbGluZyBlcXVpcG1lbnQuIE5lZWQgdG8gaW50ZWdyYXRlIHRoaXMgbW9yZSBkZWVwbHkgYW5kIGNsZWFuIGFuZCB0ZXN0LlxuKi9cblxuUEIuRGF0YS5hZGRTaGVsbHNUaGVuTWFrZUF2YWlsYWJsZSA9IGZ1bmN0aW9uKHNoZWxscykge1xuICAgIC8vLy8gYWRkcyBzaGVsbHMgdG8gdGhlIHN5c3RlbSwgdGhlbiByZXR1cm5zIGEgcmVwb3J0IG9uIGl0cyBwcm9ncmVzc1xuICAgIFxuICAgIC8vIHJlcG9ydC5kZWxpdmVyZWQ6IDEwXG4gICAgLy8gcmVwb3J0LnZhbGlkOiA4XG4gICAgLy8gcmVwb3J0Lm5ld19zaGVsbHM6IDdcbiAgICAvLyByZXBvcnQubmV3X3B1ZmZzOiA1XG4gICAgLy8gcmVwb3J0LkdDOiAwXG4gICAgXG4gICAgLy8gcmVwb3J0LnB1YmxpYzogMlxuICAgIC8vIHJlcG9ydC5zdGFyczogMFxuICAgIFxuICAgIC8vIHJlcG9ydC5wcml2YXRlX3Byb21pc2U6IHtzaWdzOltdLCBmYWlsZWQ6IH1cbiAgICBcbiAgICAvLyByZXBvcnQucHVibGljX3B1ZmZfc2lnczogW11cbiAgICBcbiAgICBmdW5jdGlvbiBub3QoZnVuKSB7cmV0dXJuIGZ1bmN0aW9uKHgpIHtyZXR1cm4gIWZ1bih4KX19XG4gICAgXG4gICAgdmFyIHJlcG9ydCA9IHtjb3VudHM6IHt9fVxuICAgIFxuICAgIHNoZWxscyA9IEFycmF5LmlzQXJyYXkoc2hlbGxzKSA/IHNoZWxscyA6IFtzaGVsbHNdXG4gICAgcmVwb3J0LmNvdW50cy5kZWxpdmVyZWQgPSBzaGVsbHMubGVuZ3RoXG4gICAgXG4gICAgc2hlbGxzID0gc2hlbGxzLmZpbHRlcihQQi5pc1ZhbGlkU2hlbGwpXG4gICAgcmVwb3J0LmNvdW50cy52YWxpZCA9IHNoZWxscy5sZW5ndGhcbiAgICBcbiAgICByZXBvcnQubWV0YSA9IFBCLkRhdGEuaGFuZGxlTWV0YVB1ZmZzKHNoZWxscylcbiAgICBcbiAgICBzaGVsbHMgPSBzaGVsbHMuZmlsdGVyKG5vdChQQi5EYXRhLmlzTWV0YVB1ZmYpKVxuICAgIHJlcG9ydC5jb3VudHMubm9ubWV0YSA9IHNoZWxscy5sZW5ndGhcbiAgICBcbiAgICByZXBvcnQucHJpdmF0ZV9wcm9taXNlID0gUEIuRGF0YS5oYW5kbGVQcml2YXRlUHVmZnMoc2hlbGxzKVxuICAgIFxuICAgIHNoZWxscyA9IHNoZWxscy5maWx0ZXIobm90KFBCLkRhdGEuaXNQcml2YXRlUHVmZikpXG4gICAgcmVwb3J0LmNvdW50cy5wdWJsaWMgPSBzaGVsbHMubGVuZ3RoXG4gICAgXG4gICAgc2hlbGxzID0gUEIuRGF0YS5oYW5kbGVBbmRGaWx0ZXJFeGlzdGluZ1NoZWxscyhzaGVsbHMpXG4gICAgcmVwb3J0LmNvdW50cy5uZXdfcHVibGljID0gcmVwb3J0LmNvdW50cy5wdWJsaWMgLSBzaGVsbHMubGVuZ3RoXG4gICAgXG4gICAgUEIuRGF0YS5oYW5kbGVOZXdQdWJsaWNTaGVsbHMoc2hlbGxzKVxuICAgIFxuICAgIHNoZWxscyA9IFBCLkRhdGEuaGFuZGxlQW5kRmlsdGVyQnlHQyhzaGVsbHMpXG4gICAgcmVwb3J0LmNvdW50cy5nYyA9IHJlcG9ydC5jb3VudHMubmV3X3B1YmxpYyAtIHNoZWxscy5sZW5ndGhcblxuICAgIHJlcG9ydC5wdWJsaWNfcHVmZl9zaWdzID0gc2hlbGxzLm1hcChQQi5wcm9wKCdzaWcnKSlcbiAgICBcbiAgICBQQi5ydW5IYW5kbGVycygnbmV3UHVmZnMnLCBzaGVsbHMpXG4gICAgUEIucnVuSGFuZGxlcnMoJ25ld1B1ZmZSZXBvcnQnLCByZXBvcnQpXG4gICAgXG4gICAgcmV0dXJuIHJlcG9ydFxufVxuXG5cblBCLkRhdGEuaGFuZGxlTWV0YVB1ZmZzID0gZnVuY3Rpb24oc2hlbGxzKSB7XG4gICAgLy8gVE9ETzogbW92ZSB0aGlzIHRvIGEgbW9kdWxlXG4gICAgdmFyIG1ldGFwdWZmcyA9IHNoZWxscy5maWx0ZXIoUEIuRGF0YS5pc01ldGFQdWZmKVxuICAgIFxuICAgIG1ldGFwdWZmcy5mb3JFYWNoKGZ1bmN0aW9uKHNoZWxsKSB7XG4gICAgICAgIHZhciBzaWcgPSBzaGVsbC5wYXlsb2FkLmNvbnRlbnRcbiAgICAgICAgUEIuRGF0YS5hZGRTdGFyKHNpZywgc2hlbGwudXNlcm5hbWUsIHNoZWxsLnNpZylcbiAgICB9KVxuICAgIFxuICAgIHJldHVybiB7c3RhcnM6IG1ldGFwdWZmcy5sZW5ndGh9XG59XG5cblBCLkRhdGEuaXNNZXRhUHVmZiA9IGZ1bmN0aW9uKHNoZWxsKSB7XG4gICAgLy8gVE9ETzogbW92ZSB0aGlzIHRvIGEgbW9kdWxlXG4gICAgcmV0dXJuIHNoZWxsLnBheWxvYWQudHlwZSA9PSAnc3RhcicgICAgXG59XG5cblxuUEIuRGF0YS5oYW5kbGVQcml2YXRlUHVmZnMgPSBmdW5jdGlvbihzaGVsbHMpIHtcbiAgICB2YXIgcHJpdmF0ZXB1ZmZzID0gc2hlbGxzLmZpbHRlcihQQi5EYXRhLmlzUHJpdmF0ZVB1ZmYpICAgIFxuICAgIHJldHVybiBQQi5EYXRhLmluZ2VzdEVuY3J5cHRlZFNoZWxscyhwcml2YXRlcHVmZnMpIC8vIFRPRE86IHRoaXMgcmV0dXJucyBvdXIgcHJvbWlzZSByZXBvcnRcbn1cblxuXG5QQi5EYXRhLmlzUHJpdmF0ZVB1ZmYgPSBmdW5jdGlvbihzaGVsbCkge1xuICAgIHJldHVybiBzaGVsbC5wYXlsb2FkLnR5cGUgPT0gJ2VuY3J5cHRlZHB1ZmYnXG59XG5cblxuUEIuRGF0YS5oYW5kbGVBbmRGaWx0ZXJFeGlzdGluZ1NoZWxscyA9IGZ1bmN0aW9uKHNoZWxscykge1xuICAgIC8vIFRISU5LOiB0aGlzIGNhbid0IGFuc3dlciB0aGUgcXVlc3Rpb24gb2YgXCJkaWQgd2UgdXBkYXRlZCBhbiBleGlzdGluZyBzaGVsbCB3aXRoIGNvbnRlbnRcIj9cbiAgICByZXR1cm4gc2hlbGxzLmZpbHRlcihmdW5jdGlvbihzaGVsbCkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBQQi5EYXRhLmdldENhY2hlZFNoZWxsQnlTaWcoc2hlbGwuc2lnKVxuXG4gICAgICAgIGlmKCFleGlzdGluZykgcmV0dXJuIHRydWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBuZXdcbiAgICAgICAgaWYoZXhpc3RpbmcucGF5bG9hZC5jb250ZW50KSByZXR1cm4gZmFsc2UgICAgICAgICAgICAgICAvLyBpdCdzIGtub3duXG5cbiAgICAgICAgaWYoc2hlbGwucGF5bG9hZC5jb250ZW50ID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZSAgICAvLyBpdCdzIGFuIGVtcHR5IHNoZWxsLFxuICAgICAgICBleGlzdGluZy5wYXlsb2FkLmNvbnRlbnQgPSBzaGVsbC5wYXlsb2FkLmNvbnRlbnQgICAgICAgIC8vIHNvIGFkZCB0aGUgbWlzc2luZyBjb250ZW50XG4gICAgICAgIHJldHVybiB0cnVlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBiZWNhdXNlIHdlIGNoYW5nZWQgaXRcbiAgICB9KVxufVxuXG5cblBCLkRhdGEuaGFuZGxlTmV3UHVibGljU2hlbGxzID0gZnVuY3Rpb24oc2hlbGxzKSB7XG4gICAgc2hlbGxzLmZvckVhY2goZnVuY3Rpb24oc2hlbGwpIHtcbiAgICAgICAgUEIuRGF0YS5zaGVsbHMucHVzaChzaGVsbClcbiAgICAgICAgUEIuRGF0YS5zaGVsbFNvcnRbc2hlbGwuc2lnXSA9IHNoZWxsXG4gICAgfSlcblxuICAgIFBCLkRhdGEuYWRkVG9HcmFwaChzaGVsbHMpXG4gICAgUEIuRGF0YS5yYXRlU29tZVB1ZmZzKHNoZWxscylcbiAgICBQQi5EYXRhLnBlcnNpc3RTaGVsbHMoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcm9wIG5ldyBzdHVmZiBpbnRvIGxvY2FsU3RvcmFnZVxufVxuXG5cblBCLkRhdGEuaGFuZGxlQW5kRmlsdGVyQnlHQyA9IGZ1bmN0aW9uKHNoZWxscykge1xuICAgIHZhciBjb21wYWN0ZWQgPSBQQi5EYXRhLmdhcmJhZ2VDb21wYWN0b3IoKSAgICAgICAgICAgICAgICAgIC8vIE9QVDogY2FsbCB0aGlzIGVhcmxpZXJcbiAgICBpZighY29tcGFjdGVkKSByZXR1cm4gc2hlbGxzXG4gICAgXG4gICAgcmV0dXJuIHNoZWxscy5tYXAoUEIucHJvcCgnc2lnJykpICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIEdDIGVhdHMgcHVmZnMgdGhpcyBzcGl0cyB0aGVtIG91dFxuICAgICAgICAgICAgICAgICAubWFwKFBCLkRhdGEuZ2V0Q2FjaGVkU2hlbGxCeVNpZylcbiAgICAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxufVxuXG5cbi8qKlxuICogdG8gcGVyc2lzdCBzaGVsbHNcbiAqIEBwYXJhbSB7U2hlbGxbXX1cbiAqIEByZXR1cm5zIHsoYm9vbGVhbnwqKX1cbiAqL1xuUEIuRGF0YS5wZXJzaXN0U2hlbGxzID0gZnVuY3Rpb24oc2hlbGxzKSB7XG4gICAgaWYoUEIuQ09ORklHLm5vTG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2UgICAgICAgICAgICAgICAgICAgICAgLy8gVEhJTks6IHRoaXMgaXMgb25seSBmb3IgZGVidWdnaW5nIGFuZCBkZXZlbG9wbWVudFxuICAgIFxuICAgIC8vIFRISU5LOiB3aGVuIHdlIHJlY2VpdmUgc2hlbGxzIGRpcmVjdGx5IHdlIHNob3VsZCBjb21wYWN0IHRoZW0gdG9vXG4gICAgaWYoIXNoZWxscykgXG4gICAgICAgIHNoZWxscyA9IGZ1bmN0aW9uKCkge3JldHVybiBQQi5EYXRhLmdldFNoZWxsc0ZvckxvY2FsU3RvcmFnZSgpfSAvLyB0aHVua2VkIGZvciBwZXJmXG4gICAgXG4gICAgLy8gd2hlbiB5b3Ugc2F2ZSBzaGVsbHMsIEdDIG9sZGVyIFwidW5pbnRlcmVzdGluZ1wiIHNoZWxscyBhbmQganVzdCBzYXZlIHRoZSBsYXRlc3Qgb25lc1xuICAgIC8vIFRISU5LOiBpcyB0aGlzIG15IHB1ZmY/IHRoZW4gc2F2ZSBpdC4gb3RoZXJ3aXNlLCBpZiB0aGUgY29udGVudCBpcyA+MWsgc3RyaXAgaXQgZG93bi5cbiAgICAvLyBUSElOSzogd2UgbmVlZCBrbm93bGVkZ2Ugb2Ygb3VyIHVzZXIgcmVjb3JkcyBoZXJlLi4uIGhvdyBkbyB3ZSBnZXQgdGhhdD8gXG4gICAgLy8gUEIuRGF0YS5pbnRlcmVzdGluZ191c2VybmFtZXM/XG4gICAgXG4gICAgLy8gc2hlbGxzID0gc2hlbGxzLmZpbHRlcihmdW5jdGlvbihzaGVsbCkgeyByZXR1cm4gIXNoZWxsLnBheWxvYWQuY29udGVudCB8fCAoc2hlbGwucGF5bG9hZC5jb250ZW50Lmxlbmd0aCA8IDEwMDApIH0pXG4gICAgXG4gICAgUEIuUGVyc2lzdC5zYXZlKCdzaGVsbHMnLCBzaGVsbHMpXG59XG5cblxuXG5QQi5EYXRhLmdldENvbnZlcnNhdGlvblB1ZmZzID0gZnVuY3Rpb24oY29udm9JZCwgb2Zmc2V0LCBiYXRjaHNpemUpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICAgIGJhdGNoc2l6ZSA9IGJhdGNoc2l6ZSB8fCBQQi5DT05GSUcucGFnZUJhdGNoU2l6ZSB8fCAxMFxuICAgIFxuICAgIHZhciBwcm9tXG4gICAgcHJvbSA9IFBCLk5ldC5nZXRDb252ZXJzYXRpb25QdWZmcyhjb252b0lkLCBiYXRjaHNpemUsIG9mZnNldClcbiAgICBwcm9tID0gcHJvbS50aGVuKFBCLkRhdGEuYWRkU2hlbGxzVGhlbk1ha2VBdmFpbGFibGUpXG4gICAgcmV0dXJuIHByb21cbn1cblxuUEIuRGF0YS5nZXRDb252ZXJzYXRpb25QdWZmcyA9IFBCLnByb21pc2VNZW1vaXplKFBCLkRhdGEuZ2V0Q29udmVyc2F0aW9uUHVmZnMsIGZ1bmN0aW9uKGtleSwgcmVwb3J0KSB7XG4gICAgcmVwb3J0LnByaXZhdGVfcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBQQi5yZW1vdmVQcm9taXNlUGVuZGluZyhrZXkpXG4gICAgfSlcbn0pXG5cblxuLyoqXG4gKiB0byBpbXBvcnQgc2hlbGxzIGZyb20gbG9jYWwgYW5kIHJlbW90ZSBzb3VyY2VzXG4gKi9cblBCLkRhdGEuaW1wb3J0U2hlbGxzID0gZnVuY3Rpb24oKSB7XG4gICAgLy8vLyBmZXRjaCBzaGVsbHMgZnJvbSBsb2NhbCBhbmQgcmVtb3RlIHNvdXJjZXNcbiAgICBcbiAgICAvLyBUSElOSzogdGhpcyBzaG91bGQgdGFrZSBhIHNldCBvZiByb3V0ZXMgc28gd2UgY2FuIHBhc3MgdGhlbSB0byBpbXBvcnRSZW1vdGVTaGVsbHNcbiAgICBcbiAgICAvLyBncmFiIHRoZSBsb2NhbCBzaGVsbHMgYW5kIGFkZCB0aGVtIHRvIHRoZSBzeXN0ZW1cbiAgICAvLyB0aGVuIGdyYWIgc29tZSByZW1vdGUgc2hlbGxzIChsYXRlc3QgMTAwKSBhbmQgY29tcGFyZSB0aGVtXG4gICAgLy8gZ28gYmFjayB1bnRpbCB3ZSBmaWxsIGluIHRoZSBnYXBzLCBvciBoaXQgdGhlIHRocmVzaG9sZCAoNTAwPylcbiAgICBcbiAgICAvLyB3aGVuIHlvdSB3YW50IHRvIGxvb2sgYXQgc2hlbGxzIHRoYXQgZG9uJ3QgZXhpc3QsIGxpa2Ugd2hlbiBzY3JvbGxpbmcsIGdyYWIgdGhlbSBhcyBhIGJhdGNoXG4gICAgXG4gICAgUEIuRGF0YS5pbXBvcnRMb2NhbFNoZWxscygpXG4gICAgLy8gUEIuRGF0YS5nZXRNb3JlU2hlbGxzKClcbiAgICBQQi5EYXRhLmltcG9ydFJlbW90ZVNoZWxscygpXG4gICAgLy8gUEIuRGF0YS5pbXBvcnRBbGxTdGFycygpXG59XG5cbi8qKlxuICogdG8gaW1wb3J0IGxvY2FsIHNoZWxsc1xuICovXG5QQi5EYXRhLmltcG9ydExvY2FsU2hlbGxzID0gZnVuY3Rpb24oKSB7ICAgLy8gY2FsbGJhY2spIHtcbiAgICAvLyBQQi5EYXRhLnNoZWxscyA9IFBCLlBlcnNpc3QuZ2V0KCdzaGVsbHMnKSB8fCBbXVxuICAgIHZhciBsb2NhbFNoZWxscyA9IFBCLlBlcnNpc3QuZ2V0KCdzaGVsbHMnKSB8fCBbXVxuICAgIFxuICAgIFBCLkRhdGEuYWRkU2hlbGxzVGhlbk1ha2VBdmFpbGFibGUobG9jYWxTaGVsbHMpXG59XG5cblxuUEIuRGF0YS5pbXBvcnRBbGxTdGFycyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRPRE86IGNvbnNpZGVyIG1vdmluZyB0aGlzIHRvIGEgbW9kdWxlXG4gICAgdmFyIHByb20gPSBQQi5OZXQuZ2V0U3RhclNoZWxscygpXG4gICAgcHJvbS50aGVuKFBCLkRhdGEuYWRkU2hlbGxzVGhlbk1ha2VBdmFpbGFibGUpXG59XG5cblxuUEIuRGF0YS5ob3JyaWRTdGFzaCA9IHt9XG5cblBCLkRhdGEuaXNCYWRFbnZlbG9wZSA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHJldHVybiBQQi5EYXRhLmhvcnJpZFN0YXNoW3NpZ11cbn1cblxuUEIuRGF0YS5hZGRCYWRFbnZlbG9wZSA9IGZ1bmN0aW9uKHNpZykge1xuICAgIFBCLkRhdGEuaG9ycmlkU3Rhc2hbc2lnXSA9IHRydWVcbn1cblxuXG5QQi5EYXRhLmN1cnJlbnREZWNyeXB0ZWRMZXR0ZXJzID0gW11cblBCLkRhdGEuY3VycmVudERlY3J5cHRlZExldHRlck1hcCA9IHt9XG5cblBCLkRhdGEuZ2V0Q3VycmVudERlY3J5cHRlZExldHRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAvLy8vIE5PVEU6IGFsd2F5cyB1c2UgdGhpcyBpbnN0ZWFkIG9mIGhpdHRpbmcgY3VycmVudERlY3J5cHRlZExldHRlcnMgZGlyZWN0bHksIGFzIHRoaXMgZnVuY3Rpb24gbWF5IGNoYW5nZVxuICAgIHJldHVybiBQQi5EYXRhLmN1cnJlbnREZWNyeXB0ZWRMZXR0ZXJzXG59XG5cblBCLkRhdGEuZ2V0RGVjcnlwdGVkTGV0dGVyQnlTaWcgPSBmdW5jdGlvbihzaWcpIHtcbiAgICBpZihQQi5EYXRhLmN1cnJlbnREZWNyeXB0ZWRMZXR0ZXJNYXBbc2lnXSlcbiAgICAgICAgcmV0dXJuIFBCLkRhdGEuY3VycmVudERlY3J5cHRlZExldHRlck1hcFtzaWddXG59XG5cblxuUEIuRGF0YS5hZGREZWNyeXB0ZWRMZXR0ZXIgPSBmdW5jdGlvbihsZXR0ZXIsIGVudmVsb3BlKSB7XG4gICAgLy8gVEhJTks6IGhvdyBjYW4gd2UgYXZvaWQgZG9pbmcgdGhpcyAnZXhpc3RpbmcgbGV0dGVyJyBjaGVjayB0d2ljZT9cbiAgICB2YXIgbWF5YmVMZXR0ZXIgPSBQQi5EYXRhLmdldERlY3J5cHRlZExldHRlckJ5U2lnKGVudmVsb3BlLnNpZylcbiAgICBpZihtYXliZUxldHRlcikgcmV0dXJuIGZhbHNlXG4gICAgXG4gICAgaWYobGV0dGVyLnBheWxvYWQudHlwZSA9PSAnaWRlbnRpdHknKSByZXR1cm4gZmFsc2UgICAgICAgICAgICAgLy8gVEhJTks6IHdoZXJlIHNob3VsZCB0aGlzIGxpdmU/XG4gICAgXG4gICAgUEIuRGF0YS5jdXJyZW50RGVjcnlwdGVkTGV0dGVycy5wdXNoKGxldHRlcilcbiAgICBcbiAgICBQQi5EYXRhLmN1cnJlbnREZWNyeXB0ZWRMZXR0ZXJNYXBbZW52ZWxvcGUuc2lnXSA9IGxldHRlciAgICAgICAvLyBsZXR0ZXIgaXMgYSBwdWZmIHRvb1xuICAgIFBCLkRhdGEuY3VycmVudERlY3J5cHRlZExldHRlck1hcFtsZXR0ZXIuc2lnXSA9IGxldHRlciAgICAgICAgIC8vIHN0YXNoIGl0IGJvdGggd2F5c1xuICAgIFBCLkRhdGEuYWRkQm9udXMobGV0dGVyLCAnZW52ZWxvcGUnLCBlbnZlbG9wZSkgICAgICAgICAgICAgICAgIC8vIG1hcmsgaXQgZm9yIGxhdGVyXG4gICAgXG4gICAgUEIuRGF0YS5hZGRUb0dyYXBoKFtsZXR0ZXJdKVxuXG4gICAgcmV0dXJuIHRydWVcbn1cblxuUEIuRGF0YS5yZW1vdmVBbGxQcml2YXRlU2hlbGxzID0gZnVuY3Rpb24oKSB7XG4gICAgUEIuRGF0YS5jdXJyZW50RGVjcnlwdGVkTGV0dGVycy5mb3JFYWNoKGZ1bmN0aW9uKHNoZWxsKSB7XG4gICAgICAgIFBCLkRhdGEucmVtb3ZlU2hlbGxGcm9tQ2FjaGUoc2hlbGwuc2lnKVxuICAgIH0pXG4gICAgXG4gICAgUEIuRGF0YS5jdXJyZW50RGVjcnlwdGVkTGV0dGVyTWFwID0ge31cbiAgICBQQi5EYXRhLmN1cnJlbnREZWNyeXB0ZWRMZXR0ZXJzID0gW10gXG59XG5cblxuXG5QQi5EYXRhLmVuY3J5cHRQdWZmID0gZnVuY3Rpb24obGV0dGVyLCBteVByaXZhdGVXaWYsIHVzZXJSZWNvcmRzLCBwcml2YXRlRW52ZWxvcGVBbGlhcykge1xuICAgIC8vLy8gc3RpY2sgYSBsZXR0ZXIgaW4gYW4gZW52ZWxvcGUuIHVzZXJSZWNvcmRzIG11c3QgYmUgZnVsbHkgaW5zdGFudGlhdGVkLlxuICAgIHZhciBwdWZma2V5ID0gUEIuQ3J5cHRvLmdldFJhbmRvbUtleSgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCBhIG5ldyByYW5kb20ga2V5XG4gICAgXG4gICAgdmFyIGxldHRlckNpcGhlciA9IFBCLkNyeXB0by5lbmNyeXB0V2l0aEFFUyhKU09OLnN0cmluZ2lmeShsZXR0ZXIpLCBwdWZma2V5KSAgLy8gZW5jcnlwdCB0aGUgbGV0dGVyXG4gICAgdmFyIHZlcnNpb25lZFVzZXJuYW1lID0gbGV0dGVyLnVzZXJuYW1lXG4gICAgXG4gICAgaWYocHJpdmF0ZUVudmVsb3BlQWxpYXMpIHtcbiAgICAgICAgbXlQcml2YXRlV2lmID0gcHJpdmF0ZUVudmVsb3BlQWxpYXMuZGVmYXVsdFxuICAgICAgICB2ZXJzaW9uZWRVc2VybmFtZSA9IFBCLlVzZXJzLm1ha2VWZXJzaW9uZWQocHJpdmF0ZUVudmVsb3BlQWxpYXMudXNlcm5hbWUsIHByaXZhdGVFbnZlbG9wZUFsaWFzLmNhcGEpXG4gICAgfVxuICAgIFxuICAgIHZhciBlbnZlbG9wZSA9IFBCLkRhdGEucGFja2FnZVB1ZmZTdHJ1Y3R1cmUodmVyc2lvbmVkVXNlcm5hbWUsIGxldHRlci5yb3V0ZXMgIC8vIGVudmVsb3BlIGlzIGFsc28gYSBwdWZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAsICdlbmNyeXB0ZWRwdWZmJywgbGV0dGVyQ2lwaGVyLCB7fSwgbGV0dGVyLnByZXZpb3VzKSAgLy8gaXQgaW5jbHVkZXMgdGhlIGxldHRlclxuICAgIFxuICAgIGVudmVsb3BlLmtleXMgPSBQQi5DcnlwdG8uY3JlYXRlS2V5UGFpcnMocHVmZmtleSwgbXlQcml2YXRlV2lmLCB1c2VyUmVjb3JkcykgIC8vIGFkZCBkZWNyeXB0aW9uIGtleXNcbiAgICBlbnZlbG9wZS5zaWcgPSBQQi5DcnlwdG8uc2lnblB1ZmYoZW52ZWxvcGUsIG15UHJpdmF0ZVdpZikgICAgICAgICAgICAgICAgICAgICAvLyBzaWduIHRoZSBlbnZlbG9wZVxuICAgIFxuICAgIHJldHVybiBlbnZlbG9wZVxufVxuXG5QQi5EYXRhLmV4dHJhY3RMZXR0ZXJGcm9tRW52ZWxvcGUgPSBmdW5jdGlvbihlbnZlbG9wZSkgeyAgICAgICAgICAgICAgICAvLyB0aGUgZW52ZWxvcGUgaXMgYSBwdWZmXG4gICAgaWYoUEIuRGF0YS5pc0JhZEVudmVsb3BlKGVudmVsb3BlLnNpZykpIFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0JhZCBlbnZlbG9wZScpICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmxhZ2dlZCBhcyBpbnZhbGlkIGVudmVsb3BlXG5cbiAgICB2YXIgbWF5YmVMZXR0ZXIgPSBQQi5EYXRhLmdldERlY3J5cHRlZExldHRlckJ5U2lnKGVudmVsb3BlLnNpZykgICAgIC8vIGhhdmUgd2UgYWxyZWFkeSBvcGVuZWQgaXQ/XG4gICAgXG4gICAgaWYobWF5YmVMZXR0ZXIpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWF5YmVMZXR0ZXIpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlIHRvIGV4aXN0aW5nIGxldHRlclxuICAgIFxuICAgIHZhciBwcm9tID0gUEIuRGF0YS5nZXREZWNyeXB0ZWRQdWZmUHJvbWlzZShlbnZlbG9wZSkgICAgICAgICAgICAgICAgLy8gZG8gdGhlIGRlY3J5cHRpb25cbiAgICBcbiAgICByZXR1cm4gcHJvbS5jYXRjaChmdW5jdGlvbihlcnIpIHsgcmV0dXJuIGZhbHNlIH0pXG4gICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihsZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICBpZighbGV0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIFBCLkRhdGEuYWRkQmFkRW52ZWxvcGUoZW52ZWxvcGUuc2lnKSAgICAgICAgICAgICAvLyBkZWNyeXB0aW9uIGZhaWxlZDogZmxhZyBlbnZlbG9wZVxuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUEIudGhyb3dFcnJvcignSW52YWxpZCBlbnZlbG9wZScpICAgICAgICAgLy8gdGhlbiBiYWlsIG91dFxuICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgIHJldHVybiBsZXR0ZXJcbiAgICAgICAgICAgICAgIH0pXG4gICAgXG59XG5cblBCLkRhdGEuZ2V0RGVjcnlwdGVkUHVmZlByb21pc2UgPSBmdW5jdGlvbihlbnZlbG9wZSkge1xuICAgIC8vLy8gcHVsbCBhIGxldHRlciBvdXQgb2YgdGhlIGVudmVsb3BlIC0tIHJldHVybnMgYSBwcm9taXNlIVxuXG4gICAgaWYoIWVudmVsb3BlIHx8ICFlbnZlbG9wZS5rZXlzKSBcbiAgICAgICAgcmV0dXJuIFBCLmVtcHR5UHJvbWlzZSgnRW52ZWxvcGUgZG9lcyBub3QgY29udGFpbiBhbiBlbmNyeXB0ZWQgbGV0dGVyJylcbiAgICBcbiAgICB2YXIgc2VuZGVyVmVyc2lvbmVkVXNlcm5hbWUgPSBlbnZlbG9wZS51c2VybmFtZVxuICAgIHZhciB1c2VyUHJvbSA9IFBCLlVzZXJzLmdldFVzZXJSZWNvcmRQcm9taXNlKHNlbmRlclZlcnNpb25lZFVzZXJuYW1lKVxuICAgIFxuICAgIHZhciBwdWZmcHJvbSA9IHVzZXJQcm9tXG4gICAgLmNhdGNoKFBCLmNhdGNoRXJyb3IoJ1VzZXIgcmVjb3JkIGFjcXVpc2l0aW9uIGZhaWxlZCcpKVxuICAgIC50aGVuKGZ1bmN0aW9uKHNlbmRlclZlcnNpb25lZFVzZXJSZWNvcmQpIHtcbiAgICAgICAgdmFyIHByb20gLy8gdXNlZCBmb3IgbGVha2luZyBzZWN1cmUgcHJvbWlzZVxuXG4gICAgICAgIFBCLnVzZVNlY3VyZUluZm8oZnVuY3Rpb24oaWRlbnRpdGllcywgY3VycmVudFVzZXJuYW1lKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBsZWFrcyBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdW5lbmNyeXB0ZWQgcHVmZlxuICAgICAgICBcbiAgICAgICAgICAgIHZhciBpZGVudGl0eSA9IGlkZW50aXRpZXNbY3VycmVudFVzZXJuYW1lXVxuICAgICAgICAgICAgdmFyIGFsaWFzZXMgID0gaWRlbnRpdHkuYWxpYXNlc1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nVXNlcm5hbWUgPSAnJ1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdG9wOiBmb3IodmFyIGtleWtleSBpbiBlbnZlbG9wZS5rZXlzKSB7ICAgICAgICAgICAgIC8vIG1hdGNoIG91ciBhbGlhc2VzIGFnYWluc3QgYWxsIHJlY2lwaWVudHNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsaWFzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsaWFzID0gYWxpYXNlc1tpXVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoYWxpYXMudXNlcm5hbWUgPT0ga2V5a2V5KSB7ICAgICAgICAgICAgICAvLyBvbmx5IGZvciBvbGQsIHVudmVyc2lvbmVkIHVzZXJuYW1lc1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdVc2VybmFtZSA9IGFsaWFzLnVzZXJuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayB0b3BcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnNpb25Vc2VybmFtZSA9IFBCLlVzZXJzLm1ha2VWZXJzaW9uZWQoYWxpYXMudXNlcm5hbWUsIGFsaWFzLmNhcGEpXG4gICAgICAgICAgICAgICAgICAgIGlmKHZlcnNpb25Vc2VybmFtZSA9PSBrZXlrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nVXNlcm5hbWUgPSB2ZXJzaW9uVXNlcm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighbWF0Y2hpbmdVc2VybmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUEIudGhyb3dFcnJvcignTm8ga2V5IGZvdW5kIGZvciBjdXJyZW50IHVzZXInKVxuXG4gICAgICAgICAgICB2YXIgcmVjaXBpZW50UHJpdmF0ZUtleSA9IGFsaWFzLnByaXZhdGVEZWZhdWx0S2V5XG4gICAgICAgICAgICB2YXIgc2VuZGVyUHVibGljS2V5ID0gc2VuZGVyVmVyc2lvbmVkVXNlclJlY29yZC5kZWZhdWx0S2V5XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHByb20gPSBQQi5EYXRhLmRlY3J5cHRQdWZmQWxtb3N0Rm9yUmVhbHMoZW52ZWxvcGUsIHNlbmRlclB1YmxpY0tleSwgbWF0Y2hpbmdVc2VybmFtZSwgcmVjaXBpZW50UHJpdmF0ZUtleSlcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gcHJvbVxuICAgIH0pXG4gICAgXG4gICAgcmV0dXJuIHB1ZmZwcm9tXG59XG5cblBCLkRhdGEuZGVjcnlwdFB1ZmZBbG1vc3RGb3JSZWFscyA9IGZ1bmN0aW9uKGVudmVsb3BlLCBzZW5kZXJQdWJsaWNLZXksIHJlY2lwaWVudFVzZXJuYW1lLCByZWNpcGllbnRQcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZXR1cm4gUEIuY3J5cHRvd29ya2VyXG4gICAgICAgICAgICAgPyBQQi53b3JrZXJzZW5kKCAnZGVjcnlwdFB1ZmZGb3JSZWFscydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIFsgZW52ZWxvcGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgc2VuZGVyUHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHJlY2lwaWVudFVzZXJuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHJlY2lwaWVudFByaXZhdGVLZXkgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgcmVzb2x2ZSwgcmVqZWN0IClcbiAgICAgICAgICAgICA6IHJlc29sdmUoIFBCLmRlY3J5cHRQdWZmRm9yUmVhbHMoIGVudmVsb3BlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBzZW5kZXJQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHJlY2lwaWVudFVzZXJuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCByZWNpcGllbnRQcml2YXRlS2V5ICkgKVxuICAgIH0pXG59XG5cblxuUEIuRGF0YS5wYWNrYWdlUHVmZlN0cnVjdHVyZSA9IGZ1bmN0aW9uKHZlcnNpb25lZFVzZXJuYW1lLCByb3V0ZXMsIHR5cGUsIGNvbnRlbnQsIHBheWxvYWQsIHByZXZpb3VzKSB7XG4gICAgLy8vLyBwYWNrIGFsbCB0aGUgcGFyYW1ldGVycyBpbnRvIGFuIG9iamVjdCB3aXRoIHB1ZmYgc3RydWN0dXJlICh3aXRob3V0IHNpZ25hdHVyZSlcbiAgICBcbiAgICBwYXlsb2FkID0gcGF5bG9hZCB8fCB7fSAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGNoZWNrIGFsbCBvZiB0aGVzZSB2YWx1ZXMgbW9yZSBjYXJlZnVsbHlcbiAgICBwYXlsb2FkLmNvbnRlbnQgPSBjb250ZW50XG4gICAgcGF5bG9hZC50eXBlID0gdHlwZVxuXG4gICAgcm91dGVzID0gcm91dGVzIHx8IFtdXG4gICAgcHJldmlvdXMgPSBwcmV2aW91cyB8fCBmYWxzZSAgICAgICAgICAgICAgICAvLyBmYWxzZSBmb3IgREhUIHJlcXVlc3RzIGFuZCBiZWdpbm5pbmcgb2YgYmxvY2tjaGFpbiwgZWxzZSB2YWxpZCBzaWdcblxuICAgIHZhciBwdWZmID0geyB1c2VybmFtZTogdmVyc2lvbmVkVXNlcm5hbWVcbiAgICAgICAgICAgICAgICwgICByb3V0ZXM6IHJvdXRlc1xuICAgICAgICAgICAgICAgLCBwcmV2aW91czogcHJldmlvdXNcbiAgICAgICAgICAgICAgICwgIHZlcnNpb246ICcwLjEuMCcgICAgICAgICAgICAgIC8vIHZlcnNpb24gYWNjb3VudHMgZm9yIGNyeXB0byB0eXBlIGFuZCBwdWZmIHNoYXBlXG4gICAgICAgICAgICAgICAsICBwYXlsb2FkOiBwYXlsb2FkICAgICAgICAgICAgICAvLyBlYXJseSB2ZXJzaW9ucyB3aWxsIGJlIGFnZ3Jlc3NpdmVseSBkZXByZWNhdGVkIGFuZCB1bnN1cHBvcnRlZFxuICAgICAgICAgICAgICAgfVxuICAgIFxuICAgIHJldHVybiBwdWZmXG59XG5cblxuXG5cblxuXG5cblxuXG5cblxuUEIuRGF0YS5nZXRNb3JlUHJpdmF0ZVB1ZmZzID0gZnVuY3Rpb24odXNlcm5hbWUsIG9mZnNldCwgYmF0Y2hzaXplKSB7XG4gICAgLy8gVEhJTks6IHJhY2UgY29uZGl0aW9uIHdoaWxlIHRvZ2dsaW5nIGlkZW50aXRpZXM/IHVzZXJuYW1lIGlzbid0IHVzZWQgYmVsb3cuXG4gICAgaWYoIXVzZXJuYW1lKSB1c2VybmFtZSA9IFBCLmdldEN1cnJlbnRVc2VybmFtZSgpXG4gICAgXG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDBcbiAgICAvLyBvZmZzZXQgPSBvZmZzZXQgfHwgUEIuQ09ORklHLmluaXRMb2FkQmF0Y2hTaXplIHx8IDIwXG4gICAgYmF0Y2hzaXplID0gYmF0Y2hzaXplIHx8IFBCLkNPTkZJRy5wYWdlQmF0Y2hTaXplIHx8IDEwXG4gICAgXG4gICAgdmFyIHByb21cbiAgICBwcm9tID0gUEIuTmV0LmdldE15UHJpdmF0ZVB1ZmZzKFBCLmdldEN1cnJlbnRVc2VybmFtZSgpLCBiYXRjaHNpemUsIG9mZnNldCkgLy8gVEhJTks6IHdoeSBzd2l0Y2hlZCBwYXJhbSBvcmRlcj9cbiAgICBwcm9tID0gcHJvbS50aGVuKFBCLkRhdGEuYWRkU2hlbGxzVGhlbk1ha2VBdmFpbGFibGUpXG4gICAgcmV0dXJuIHByb21cbn1cblxuXG5QQi5EYXRhLnVwZGF0ZVByaXZhdGVTaGVsbHMgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICB2YXIgdXNlcm5hbWUgPSBQQi5nZXRDdXJyZW50VXNlcm5hbWUoKVxuICAgIHZhciBiYXRjaHNpemUgPSAxXG4gICAgdmFyIGZ1bGxPclNoZWxsID0gJ2Z1bGwnIC8vIE9QVDoganVzdCBnYXRoZXIgdGhlIHNoZWxsIChvciBzaWcpIGhlcmUgd2hlbiBjaGVja2luZyBsYXRlc3RcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMCAgICAgLy8gICAgICBhY3R1YWxseS4uLiB3ZSBuZWVkIGEgbGlzdCBvZiBhbGwgc2lncyB3ZSd2ZSBlbmNvdW50ZXJlZCAobm90IGp1c3QgZ29vZCBvbmVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgIG90aGVyd2lzZSBiYWQgZW52ZWxvcGVzIChldGMpIGNvdWxkIGJsb2NrIHByaW9yIGdvb2QgY29udGVudC5cblxuICAgIFBCLk5ldC5nZXRNeVByaXZhdGVQdWZmcyh1c2VybmFtZSwgYmF0Y2hzaXplLCBvZmZzZXQsIGZ1bGxPclNoZWxsKVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHNoZWxscykge1xuICAgICAgICAgICAgICB2YXIgc2hlbGwgPSBzaGVsbHNbMF1cbiAgICAgICAgICAgICAgaWYoIXNoZWxsKSByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHZhciBwcm9tID0gUEIuRGF0YS5pbmdlc3RBbkVuY3J5cHRlZFNoZWxsKHNoZWxsKSAvLyBtYW51YWwgYmVjYXVzZSB3ZSBuZWVkIHRoZSBkZWNyeXB0aW9uIHByb21pc2VcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHByb20udGhlbihmdW5jdGlvbihmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgaWYoZnJlc2gpXG4gICAgICAgICAgICAgICAgICAgICAgUEIuRGF0YS51cGRhdGVQcml2YXRlU2hlbGxzKDErb2Zmc2V0KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG59XG5cblxuUEIuRGF0YS5pbmdlc3RFbmNyeXB0ZWRTaGVsbHMgPSBmdW5jdGlvbihzaGVsbHMpIHtcbiAgICB2YXIgcHJvbXMgPSBzaGVsbHMubWFwKFBCLkRhdGEuaW5nZXN0QW5FbmNyeXB0ZWRTaGVsbClcbiAgICBcbiAgICAvLyBOT1RFOiBQcm9taXNlLmFsbCByZWplY3RzIGltbWVkaWF0ZWx5IHVwb24gYW55IHJlamVjdGlvbiwgc28gd2UgaGF2ZSB0byBkbyB0aGlzIG1hbnVhbGx5XG4gICAgXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gcHJvbXMubGVuZ3RoXG4gICAgICAgIHZhciByZXBvcnQgPSB7Z29vZDogMCwgYmFkOiAwLCBnb29kc2lnczogW119XG4gICAgICAgIFxuICAgICAgICAvLyBUT0RPOiBhZGQgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IHdlbnQgd3JvbmcgdG8gdGhlIHJlcG9ydFxuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gdW5oYXBweV9wYXRoKCkge1xuICAgICAgICAgICAgcmVwb3J0LmJhZCsrXG4gICAgICAgICAgICBpZighLS1yZW1haW5pbmcpIHJlc29sdmUocmVwb3J0KVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBwcm9tcy5mb3JFYWNoKGZ1bmN0aW9uKHByb20pIHtcbiAgICAgICAgICAgIHByb20udGhlbihmdW5jdGlvbihsZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZighbGV0dGVyKSByZXR1cm4gdW5oYXBweV9wYXRoKCkgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhdGNoZXMgb2xkIG9yIHdlaXJkIHB1ZmZzIFxuICAgICAgICAgICAgICAgIHJlcG9ydC5nb29kKysgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGlmZmVyZW50aWF0ZSBhYm92ZSBjYXNlc1xuICAgICAgICAgICAgICAgIHJlcG9ydC5nb29kc2lncy5wdXNoKGxldHRlci5zaWcpXG4gICAgICAgICAgICAgICAgaWYoIS0tcmVtYWluaW5nKSByZXNvbHZlKHJlcG9ydClcbiAgICAgICAgICAgIH0sIHVuaGFwcHlfcGF0aCApICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhdGNoZXMgZGVjcnlwdGlvbiBlcnJvcnNcbiAgICAgICAgfSlcbiAgICB9KVxufVxuXG5cblBCLkRhdGEuaW5nZXN0QW5FbmNyeXB0ZWRTaGVsbCA9IGZ1bmN0aW9uKGVudmVsb3BlKSB7XG4gICAgdmFyIHByb20gPSBQQi5EYXRhLmV4dHJhY3RMZXR0ZXJGcm9tRW52ZWxvcGUoZW52ZWxvcGUpXG5cbiAgICBwcm9tID0gcHJvbS50aGVuKGZ1bmN0aW9uKGxldHRlcikge1xuICAgICAgICBpZighbGV0dGVyKSByZXR1cm4gZmFsc2VcbiAgICAgICAgXG4gICAgICAgIHZhciBmcmVzaCA9IFBCLkRhdGEuYWRkRGVjcnlwdGVkTGV0dGVyKGxldHRlciwgZW52ZWxvcGUpICAgICAgICAvLyBhZGQgdGhlIGxldHRlciB0byBvdXIgc3lzdGVtXG4gICAgICAgIGlmKCFmcmVzaCkgcmV0dXJuIGZhbHNlXG4gICAgICAgIFxuICAgICAgICBQQi5ydW5IYW5kbGVycygnbmV3UHVmZnMnLCBbbGV0dGVyXSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIHJlY2VpdmVzIGFuIGFycmF5IG9mIHB1ZmZzXG4gICAgICAgIHJldHVybiBsZXR0ZXJcbiAgICB9KVxuICAgIFxuICAgIHJldHVybiBwcm9tXG4gICAgXG4gICAgLy8gTk9URTogdGhpcyBkb2Vzbid0IGFwcGVhciB0byBkbyBtdWNoLCBtb3N0bHkgYmVjYXVzZSBleHRyYWN0TGV0dGVyRnJvbUVudmVsb3BlIGlzIHF1aXRlIGVmZmVjdGZ1bC5cbiAgICAvLyAgICAgICBpdCBjYWxscyBQQi5EYXRhLmFkZERlY3J5cHRlZExldHRlciBhcyBwYXJ0IG9mIGl0cyBwcm9jZXNzaW5nLCB3aGljaCBkb2VzIGFsbCB0aGUgcmVhbCB3b3JrLlxuICAgIFxuICAgIC8vIFRISU5LOiBjb25zaWRlciBhZGRpbmcgdGhpcyBiYWNrIGluLCB0aG91Z2ggcmVtZW1iZXIgdGhhdCBlYWNoIGRlY3J5cHRpb24gcHVzaGVzIGl0cyBvd24gZXJyb3JzLi4uXG4gICAgLy8gaWYgKGxldHRlcnMubGVuZ3RoICE9IHByaXZhdGVTaGVsbHMubGVuZ3RoKSB7XG4gICAgLy8gICAgIEV2ZW50cy5wdWIoJ3RyYWNrL2RlY3J5cHQvc29tZS1kZWNyeXB0LWZhaWxzJyxcbiAgICAvLyAgICAgICAgICAgICAgICAge2xldHRlcnM6IGxldHRlcnMubWFwKGZ1bmN0aW9uKHApe3JldHVybiBwLnNpZ30pLFxuICAgIC8vICAgICAgICAgICAgICAgICAgcHJpdmF0ZVNoZWxsczogcHJpdmF0ZVNoZWxscy5tYXAoZnVuY3Rpb24ocCl7cmV0dXJuIHAuc2lnfSl9KVxuICAgIC8vIH1cbn1cblxuXG5cblxuLy8gdGhlIHNsb3QgbG9ja2VyIGNvbnRhaW5zIGluZm9ybWF0aW9uIG9uIHF1ZXJpZXMgbWFkZSB0byBmaWxsIHNsb3RzLiBcbi8vIGluIHBhcnRpY3VsYXIgaXQgaG9sZHMgdGhlIG9mZnNldCwgd2hpY2ggd2lsbCBiZSAtMSB3aGVuIFtdIGlzIHJldHVybmVkLlxuLy8gaXQga2VlcHMgcXVlcmllcyBmcm9tIHJlLXJlcXVlc3RpbmcgdGhlIHNhbWUgc2hlbGxzIG92ZXIgYW5kIG92ZXIsIFxuLy8gYW5kIHByb3ZpZGVzIHNvbWUgY29uY3VycmVuY3kgLyBmbG93IGNvbnRyb2wgYnkgYWxsb3dpbmcgYSBxdWVyeVxuLy8gdG8gc2V0IGl0IHRvIC0xIHdoZW4gaXQgaXMgcnVubmluZyBhbmQgdGhlbiByZXBsYWNlIGl0IHdoZW4gZG9uZS5cblBCLkRhdGEuc2xvdExvY2tlciA9IHt9XG5cbi8vIFRISU5LOiB3ZSdyZSBjYWxsaW5nIHRoaXMgZnJvbSB0aGUgJ3JlZnJlc2gnIGJ1dHRvbiBub3cuLi5cblxuXG5QQi5EYXRhLmltcG9ydFJlbW90ZVNoZWxscyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vLy8gb25seSBjYWxsZWQgZHVyaW5nIGluaXRpYWwgYXBwbGljYXRpb24gYm9vdHVwLiBoYW5kbGVzIGJvdGggY29sZCBsb2FkcyBhbmQgaG90IGxvYWRzLlxuICAgIFxuICAgIHZhciBvZmZzZXQgPSAwXG4gICAgdmFyIGdpdmV1cCA9IFBCLkNPTkZJRy5pbml0TG9hZEdpdmV1cFxuICAgIHZhciBsaW1pdCAgPSBQQi5DT05GSUcuaW5pdExvYWRCYXRjaFNpemVcbiAgICB2YXIgbmV3X3NoZWxscyA9IFtdXG4gICAgdmFyIGtlZXBfZ29pbmcgPSB0cnVlXG4gICAgXG4gICAgdmFyIGtleSA9ICdbe1wic29ydFwiOlwiREVTQ1wifSx7XCJ0YWdzXCI6W10sXCJ0eXBlc1wiOltdLFwidXNlcnNcIjpbXSxcInJvdXRlc1wiOltdfV0nIC8vIFRPRE86IHVwZ3JhZGUgdGhpcyBkZWZhdWx0IHF1ZXJ5XG4gICAgUEIuRGF0YS5zbG90TG9ja2VyW2tleV0gPSAtMVxuICAgIFxuICAgIC8vIFRPRE86IGluZGV4IGJ5IHVzZXJuYW1lXG4gICAgLy8gVE9ETzogaWYgZHVwbGljYXRlIGNoZWNrIHVwZGF0ZSB0aW1lcyBmb3IgbGF0ZXN0XG4gICAgLy8gVE9ETzogcGVyc2lzdCB0byBMUyAobWF5YmUgb25seSBzb21ldGltZXM/IG9udW5sb2FkPyBwcm9iYWJpbGlzdGljPylcbiAgICAgICAgIFxuICAgIGZ1bmN0aW9uIGdldE1lU29tZVNoZWxscyhwdWZmcykge1xuICAgICAgICBpZihwdWZmcykge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gUEIuRGF0YS5hZGRTaGVsbHNUaGVuTWFrZUF2YWlsYWJsZShwdWZmcylcbiAgICAgICAgICAgIC8vIG5ld19zaGVsbHMgPSBuZXdfc2hlbGxzLmNvbmNhdChteV9uZXdfc2hlbGxzKVxuICAgICAgICAgICAgLy8gdmFyIGRlbHRhID0gbXlfbmV3X3NoZWxscy5sZW5ndGhcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoZGVsdGEgIT0gbGltaXQpIC8vIHNvbWUgc2hlbGxzIHdlcmUgYWxyZWFkeSBpbiBvdXIgY2FjaGVcbiAgICAgICAgICAgICAgICBrZWVwX2dvaW5nID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYob2Zmc2V0ID4gZ2l2ZXVwKVxuICAgICAgICAgICAga2VlcF9nb2luZyA9IGZhbHNlXG5cbiAgICAgICAgaWYoIWtlZXBfZ29pbmcpIHtcbiAgICAgICAgICAgIFBCLkRhdGEuc2xvdExvY2tlcltrZXldID0gMVxuICAgICAgICAgICAgLy8gUEIuRGF0YS5zdHVwaWRIb3JyaWJsZUdsb2JhbFRoaW5nID0gdHJ1ZVxuICAgICAgICAgICAgLy8gUEIuRGF0YS5tYWtlU2hlbGxzQXZhaWxhYmxlKG5ld19zaGVsbHMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHByb20gPSBQQi5OZXQuZ2V0U29tZVNoZWxscyh7fSwge30sIGxpbWl0LCBvZmZzZXQpXG4gICAgICAgIHByb20udGhlbihnZXRNZVNvbWVTaGVsbHMpXG5cbiAgICAgICAgb2Zmc2V0ICs9IGxpbWl0XG4gICAgfVxuICAgIFxuICAgIGdldE1lU29tZVNoZWxscygpXG59XG5cblxuLyoqXG4gKiB0byBmaWxsIHNvbWUgc2xvdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWVkXG4gKiBAcGFyYW0ge251bWJlcn0gaGF2ZVxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsdGVyc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblBCLkRhdGEuZmlsbFNvbWVTbG90c1BsZWFzZSA9IGZ1bmN0aW9uKG5lZWQsIGhhdmUsIHF1ZXJ5LCBmaWx0ZXJzKSB7XG4gICAgLy8vLyB3ZSBoYXZlIGVtcHR5IHNsb3RzIG9uIHNjcmVlbi4gZmlsbCB0aGVtIHdpdGggcHVmZnMuXG4gICAgXG4gICAgaWYoaGF2ZSA+PSBuZWVkKSByZXR1cm4gZmFsc2VcbiAgICBcbiAgICAvLyAtLSByZWRyYXcgc2NyZWVuIG9uIG5ldyBwdWZmcyBiZWluZyBpbmdlc3RlZCAody9vIGxvb3BpbmcpXG4gICAgLy8gLS0gY3ljbGUgYWxsIG5ldyBwdWZmcyB0aHJvdWdoIGdyYXBoIHN0dWZmXG4gICAgLy8gLS0gY2FsbCBmaWxsU29tZVNsb3RzUGxlYXNlIGV2ZXJ5IHRpbWUgd2UgaGF2ZSBzbG90cyB0byBmaWxsXG4gICAgLy8gLS0gZ2V0IGZvY3VzZWQgcHVmZiBpbW1lZGlhdGVseVxuICAgIFxuICAgIC8vIC0gcGVyZm9ybSBHQyBvbiBpbi1tZW1vcnkgcHVmZnMgKGNhbiByZW1vdmUgY29udGVudCBhbHNvKVxuICAgIC8vIC0gdXNlIEdDIGZ1bnMgZm9yIHBlcnNpc3Rpbmcgc2hlbGxzXG4gICAgLy8gLSBzdG9yZSBzaXplIG9mIGVhY2ggc2hlbGwvcHVmZiBmb3IgR0NcbiAgICAvLyAtIG1hbmFnZSBlbXB0eSB2ZXJ0aWNlcyBiZXR0ZXIgKGRpZmZlcmVudCB0eXBlPylcblxuICAgIHZhciBhcmdzID0gW3F1ZXJ5LCBmaWx0ZXJzXVxuICAgIC8vIHZhciBhcmdzID0gW3F1ZXJ5LCBmaWx0ZXJzLCBuZWVkXVxuICAgIC8vIGlmKCFxdWVyeS5tb2RlKSBhcmdzLnB1c2goaGF2ZSkgLy8gaGFjayBmb3IgYWx0ZXJuYXRlIHF1ZXJ5IG1vZGVzXG5cbiAgICB2YXIga2V5ID0gSlNPTi5zdHJpbmdpZnkoYXJncylcbiAgICB2YXIgbXlfb2Zmc2V0ID0gUEIuRGF0YS5zbG90TG9ja2VyW2tleV0gfHwgMFxuICAgIFxuICAgIGlmKG15X29mZnNldCA8IDApXG4gICAgICAgIHJldHVybiBmYWxzZSAvLyBzbG90IGlzIGxvY2tlZCwgZ28gZWxzZXdoZXJlXG4gICAgXG4gICAgUEIuRGF0YS5zbG90TG9ja2VyW2tleV0gPSAtMSAvLyBwcmV2ZW50IGNvbmN1cnJlbnQgdmVyc2lvbnMgb2YgdGhlIHNhbWUgcmVxdWVzdFxuICAgIFxuICAgIC8vLy8vL1xuXG4gICAgLy8gdmFyIGxpbWl0ID0gbmVlZCAtIGhhdmUgKyAzIC8vIDMgZm9yIGx1Y2tcbiAgICBcbiAgICB2YXIgbGltaXQgPSBuZWVkIC8vIHNvLi4uIGlmIHdlIG9ubHkgZG8gdGhpcyBvbmNlLCBhbmQgd2UgaGF2ZSBoYWxmIHRoZSBwdWZmcyBhbHJlYWR5LCB3ZSBtaWdodCBvbmx5IGdyYWIgdGhhdCBoYWxmIGFnYWluLiB0aGlzIGlzIHRydWUgZXZlbiBpZiB3ZSBzZW5kIGFuIG9mZnNldCBvZiAnaGF2ZScgdG8gdGhlIHNlcnZlciwgYmVjYXVzZSB3aGF0IHdlIGhhdmUgbWlnaHQgbWFwIHRvIHRoYXQgc2xpY2UgKG9yIHRvIGFueXRoaW5nIGVsc2UgLS0gb3VyIG9mZnNldHMgYXJlIHRvdGFsbHkgZGlmZmVyZW50IHRoYW4gdGhlIHNlcnZlcnMpLiBzbyB3ZSBoYXZlIHRvIGdyYWIgZW5vdWdoIHRvIGNvdmVyIHRoZSBkaWZmZXJlbmNlLCB3aGljaCBtZWFucyBncmFiYmluZyB0aGUgc2FtZSBzaGVsbHMgbXVsdGlwbGUgdGltZXMuLi4gKGJ1dCBvbmx5IGVtcHR5IHNoZWxscywgZm9ydHVuYXRlbHkuIGJ1dCBzdGlsbC4pXG4gICAgXG4gICAgLy8gdmFyIHJlY2VpdmVkX3NoZWxscyA9IDBcbiAgICBcbiAgICB2YXIgcHJvbSA9IFBCLk5ldC5nZXRTb21lU2hlbGxzKHF1ZXJ5LCBmaWx0ZXJzLCBsaW1pdCwgcXVlcnkub2Zmc2V0KVxuICAgIC8vIHByb20udGhlbihmdW5jdGlvbihzaGVsbHMpIHtyZWNlaXZlZF9zaGVsbHMgPSBzaGVsbHMubGVuZ3RoOyByZXR1cm4gc2hlbGxzfSlcbiAgICBwcm9tLnRoZW4oUEIuRGF0YS5hZGRTaGVsbHNUaGVuTWFrZUF2YWlsYWJsZSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGVsdGEpIHsgXG4gICAgICAgICAgICBQQi5EYXRhLnNsb3RMb2NrZXJba2V5XSA9IGRlbHRhID8gMSA6IC0xfSkgXG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVxdWVzdCBpcyBmcnVpdGZ1bCwgdW5sb2NrIGl0IChidXQgYmUgY2FyZWZ1bCBvZiBvZmZzZXRzIGhlcmUpLlxuICAgICAgICAgICAgLy8gYWxzbywgdGhpcyBsb2NrcyB3aGVuIHdlIHJlY2VpdmVkIGRhdGEgYnV0IGNob3NlIG5vdCB0byBrZWVwIGl0IChlaXRoZXIgZHVwcyBvciBHQyksXG4gICAgICAgICAgICAvLyBzbyB3ZSBjb3VsZCBoYXZlIGFuIGlzc3VlIHdpdGggbG9ja2VkIHF1ZXJpZXMgdGhhdCB3b3VsZCBiZSBmcnVpdGZ1bCB3LyBkaWZmZXJlbnQgb2Zmc2V0IC8gbGltaXRzLi4uXG4gICAgXG4gICAgXG4gICAgLy8gVE9ETzogdGhlIHNsb3RMb2NrZXIgcmVhbGx5IHNob3VsZCBrZWVwIHRyYWNrIG9mIHdoYXQgJ3NsaWNlcycgb2YgdGhlIHNlcnZlciB5b3UndmUgc2Vlbiwgc28gd2Uga25vdyBub3QgdG8gcmUtcmVxdWVzdCB0aG9zZSBvdmVyIGFuZCBvdmVyLiB0aGlzIGlzLi4uIGNvbXBsaWNhdGVkLiBcbiAgICAvLyAgICAgICBzbyBzZW5kIHF1ZXJ5Lm9mZnNldCtoYXZlIHRvIGdldFNvbWVTaGVsbHMsIGFuZCBzdG9yZSB0aGF0IHNhbWUgb2Zmc2V0IGFzIHBhcnQgb2YgdGhlIHNsb3RMb2NrZXIuXG4gICAgLy8gICAgICAgdGhlbiB5b3UgY2FuIHRyYWNrIGhvdyBtdWNoIG9mIHNvbWUgdHlwZSBvZiBzdHVmZiBpcyBvbiB0aGUgc2VydmVyLi4uIGV4Y2VwdCB0aGF0IGRvZXNuJ3Qgd29yayBmb3IgdGhlIFAyUCBuZXR3b3JrLlxuICAgIFxuICAgIHJldHVybiB0cnVlXG4gICAgXG4gICAgLy8vLy8vXG5cblxuICAgIC8vIE9MRCBTVFVGRiBTQVZFIEZPUiBSRUZFUkVOQ0VcblxuICAgIC8vIHZhciBiYXRjaFNpemUgPSBQQi5DT05GSUcuZmlsbFNsb3RzQmF0Y2hTaXplXG4gICAgLy8gdmFyIGdpdmV1cCA9IFBCLkNPTkZJRy5maWxsU2xvdHNHaXZldXBcbiAgICAvLyB2YXIgbmV3X3NoZWxscyA9IFtdXG4gICAgLy9cbiAgICAvLyBnaXZldXAgPSBnaXZldXAgKyBteV9vZmZzZXRcbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uIGdldE1lU29tZVNoZWxscyhwdWZmcykge1xuICAgIC8vICAgICBpZihwdWZmcykge1xuICAgIC8vICAgICAgICAgdmFyIG15X25ld19zaGVsbHMgPSBQQi5EYXRhLmhlcmVIYXZlU29tZU5ld1NoZWxscyhwdWZmcylcbiAgICAvLyAgICAgICAgIG5ld19zaGVsbHMgPSBuZXdfc2hlbGxzLmNvbmNhdChteV9uZXdfc2hlbGxzKVxuICAgIC8vICAgICAgICAgdmFyIGRlbHRhID0gbXlfbmV3X3NoZWxscy5sZW5ndGhcbiAgICAvLyAgICAgICAgIC8vIFRISU5LOiBidXQgZG8gdGhleSBwYXNzIHRoZSBmaWx0ZXI/XG4gICAgLy8gICAgICAgICAvLyBUT0RPOiBjYW4gd2UgbWFrZSBhdmFpbGFibGUgaGVyZSBub3cgdGhhdCB3ZSdyZSBsb2NraW5nP1xuICAgIC8vICAgICAgICAgaGF2ZSArPSBkZWx0YSB8fCAwXG4gICAgLy8gICAgIH1cbiAgICAvL1xuICAgIC8vICAgICBpZihoYXZlID49IG5lZWQgfHwgbXlfb2Zmc2V0ID4gZ2l2ZXVwIHx8IChxdWVyeS5tb2RlICYmIChteV9vZmZzZXQgLSBnaXZldXAgPCAwKSkpIHtcbiAgICAvLyAgICAgICAgIFBCLkRhdGEubWFrZVNoZWxsc0F2YWlsYWJsZShuZXdfc2hlbGxzKVxuICAgIC8vICAgICAgICAgUEIuRGF0YS5zbG90TG9ja2VyW2tleV0gPSBteV9vZmZzZXQtbGltaXRcbiAgICAvLyAgICAgICAgIHJldHVybiBmYWxzZVxuICAgIC8vICAgICB9XG4gICAgLy9cbiAgICAvLyAgICAgdmFyIGxpbWl0ID0gbmVlZCAtIGhhdmVcbiAgICAvLyAgICAgLy8gaWYoIXF1ZXJ5Lm1vZGUpIGxpbWl0ICs9IDUwIC8vIGdyYWIgYSBmZXcgZXh0cmFzIHRvIGhlbHAgd29yayB0aHJvdWdoIGJhcmUgcGF0Y2hlc1xuICAgIC8vXG4gICAgLy8gICAgIHZhciBwcm9tID0gUEIuTmV0LmdldFNvbWVTaGVsbHMocXVlcnksIGZpbHRlcnMsIGxpbWl0LCBteV9vZmZzZXQpXG4gICAgLy8gICAgIHByb20udGhlbihnZXRNZVNvbWVTaGVsbHMpXG4gICAgLy9cbiAgICAvLyAgICAgbXlfb2Zmc2V0ICs9IGxpbWl0XG4gICAgLy8gfVxuICAgIC8vXG4gICAgLy8gZ2V0TWVTb21lU2hlbGxzKClcbn1cblxuXG4vKlxuICAgIEVuZCBzaGVsbCBjb2xsZWN0aW9uIGludGFrZSBlcXVpcG1lbnRcbiovXG5cblxuLyoqXG4gKiByZXR1cm5zIGEgcHVmZiBmcm9tIGEgc2hlbGxcbiAqIEBwYXJhbSAgeyhzdHJpbmd8b2JqZWN0KX0gc2hlbGwgXG4gKiBAcmV0dXJuIHtvYmplY3R9IHJldHVybnMgYSBwdWZmIGJhc2VkIG9uIHRoZSBzaGVsbDsgcmV0dXJucyBmYWxzZSBpZiB0aGUgc2hlbGwgaXMgZW1wdHlcbiAqL1xuUEIuRGF0YS5nZXRQdWZmRnJvbVNoZWxsID0gZnVuY3Rpb24oc2hlbGwpIHtcbiAgICBpZighc2hlbGwpXG4gICAgICAgIHJldHVybiBmYWxzZSAvLyBzbyB3ZSBjYW4gZmlsdGVyIGVtcHR5IHNoZWxscyBvdXQgZWFzaWx5LCB3aGlsZSBzdGlsbCBsb2FkaW5nIHRoZW0gb24gZGVtYW5kXG4gICAgXG4gICAgaWYoc2hlbGwucGF5bG9hZCAmJiBzaGVsbC5wYXlsb2FkLmNvbnRlbnQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHNoZWxsIC8vIGl0J3MgYWN0dWFsbHkgYSBmdWxsIGJsb3duIHB1ZmZcbiAgICBcbiAgICByZXR1cm4gUEIuRGF0YS5nZXRQdWZmQnlTaWcoc2hlbGwuc2lnKSAvLyByZXR1cm5zIGEgcHVmZiwgb3IgYXNrcyB0aGUgbmV0d29yayBhbmQgcmV0dXJucyBmYWxzZVxufVxuXG4vKipcbiAqIHRvIGdldCBwdWZmIGJ5IGl0cyBzaWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaWdcbiAqIEByZXR1cm5zIHsob2JqZWN0fGZhbHNlKX1cbiAqL1xuUEIuRGF0YS5nZXRQdWZmQnlTaWcgPSBmdW5jdGlvbihzaWcpIHtcbiAgICB2YXIgc2hlbGwgPSBQQi5EYXRhLmdldENhY2hlZFNoZWxsQnlTaWcoc2lnKSAvLyBPUFQ6IHRoaXMgaGFwcGVucyB0d2ljZSBhbG1vc3QgYWx3YXlzXG4gICAgXG4gICAgaWYoc2hlbGwgJiYgc2hlbGwucGF5bG9hZCAmJiB0eXBlb2Ygc2hlbGwucGF5bG9hZC5jb250ZW50ICE9ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gc2hlbGxcbiAgICBcbiAgICBpZihQQi5EYXRhLnBlbmRpbmdQdWZmUHJvbWlzZXNbc2lnXSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIFxuICAgIC8vIGxvY2FsbHkgY2FjaGVkIHNoZWxscyB0aGF0IGFyZSBtaXNzaW5nIGNvbnRlbnQgb24gdGhlIG5ldHdvcmsgcHJldmVudCBzbG90ZmlsbHMgZnJvbSByZXNvbHZpbmcsXG4gICAgLy8gc28gd2UgY2xlYXIgaXQgZnJvbSBvdXIgY2FjaGUgaWYgd2UgY2FuJ3QgZmluZCBpdC5cbiAgICBmdW5jdGlvbiBiYWRTaGVsbENsZWFyQ2FjaGUoc2hlbGxzKSB7XG4gICAgICAgIGlmKCFzaGVsbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZmF1eHNoZWxsID0ge3NpZzogc2lnfVxuICAgICAgICAgICAgaWYoIVBCLkRhdGEuZ2V0Qm9udXMoZmF1eHNoZWxsLCAnZW52ZWxvcGUnKSkge1xuICAgICAgICAgICAgICAgIFBCLkRhdGEucmVtb3ZlU2hlbGxGcm9tQ2FjaGUoc2lnKVxuICAgICAgICAgICAgICAgIHJldHVybiBQQi5vbkVycm9yKFwiQ29udGVudCBjYW4gbm90IGJlIGZvdW5kIGZvciBzaGVsbCAnXCIgKyBzaWcgKyBcIidcIikgLy8gVEhJTks6IHdoeSB3YXMgdGhpcyB0aHJvd0Vycm9yP1xuICAgICAgICAgICAgICAgIC8vIFRISU5LOiB1bmxvY2sgUEIuRGF0YS5wZW5kaW5nUHVmZlByb21pc2VzW3NpZ10/IHByb2JhYmx5IG5vdCwgYnV0IGl0IG1pZ2h0IHJlLWFwcGVhciBsYXRlci4uLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGVsbHNcbiAgICB9XG4gICAgXG4gICAgUEIuRGF0YS5wZW5kaW5nUHVmZlByb21pc2VzW3NpZ10gPSBQQi5OZXQuZ2V0UHVmZkJ5U2lnKHNpZykgICAgICAvLyBUT0RPOiBkcm9wIHRoaXMgZG93biBpbiB0byBQQi5OZXQgaW5zdGVhZFxuICAgIFBCLkRhdGEucGVuZGluZ1B1ZmZQcm9taXNlc1tzaWddLnRoZW4oYmFkU2hlbGxDbGVhckNhY2hlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oUEIuRGF0YS5hZGRTaGVsbHNUaGVuTWFrZUF2YWlsYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlbGF5IEdDIHRvIHN0b3AgcnVuYXdheSBuZXR3b3JrIHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgZGVsZXRlIFBCLkRhdGEucGVuZGluZ1B1ZmZQcm9taXNlc1tzaWddIH0sIDEwMDAwKSB9KVxuICAgIFxuICAgIHJldHVybiBmYWxzZVxufVxuXG5QQi5EYXRhLnJlbW92ZVNoZWxsRnJvbUNhY2hlID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgLy8gcmVtb3ZlIGZyb20gUEIuRGF0YS5zaGVsbHNcbiAgICB2YXIgc2hlbGwgPSBQQi5EYXRhLmdldENhY2hlZFNoZWxsQnlTaWcoc2lnKVxuICAgIFBCLkRhdGEuc2hlbGxzLnNwbGljZSggUEIuRGF0YS5zaGVsbHMuaW5kZXhPZihzaGVsbCksIDEgKVxuICAgIFxuICAgIC8vIHJlbW92ZSBmcm9tIFBCLkRhdGEuc2hlbGxTb3J0XG4gICAgZGVsZXRlIFBCLkRhdGEuc2hlbGxTb3J0W3NpZ11cbiAgICBcbiAgICAvLyByZW1vdmUgc2hlbGwncyBib25paVxuICAgIGRlbGV0ZSBQQi5EYXRhLmJvbmlpW3NpZ11cbiAgICBcbiAgICBQQi5EYXRhLnB1cmdlU2hlbGxGcm9tR3JhcGgoc2lnKVxuICAgIFxuICAgIFBCLkRhdGEucmVtb3ZlQ2FjaGVkUHVmZlNjb3JlKHNoZWxsKVxufVxuXG5QQi5EYXRhLnB1cmdlU2hlbGxGcm9tR3JhcGggPSBmdW5jdGlvbihzaWcpIHtcbiAgICAvLyBjaGFuZ2UgZ3JhcGggdmVydGV4IHRvICdwc2V1ZG8tc2hlbGwnIHR5cGUgKG9yICdwdXJnZWQnIHR5cGU/KVxuICAgIC8vICAgYW5kIHJlbW92ZSB0aGUgY29udGVudCBvZiB0aGUgJ3NoZWxsJyBwcm9wZXJ0eVxuICAgIC8vIFRPRE86IHRoaXMgaXMgaWNreSBtYWtlIGl0IGJldHRlclxuICAgIHZhciB2ZXJ0ZXggPSBQQi5EYXRhLmdyYXBoLnYoc2lnKS5ydW4oKVswXVxuICAgIGlmKHZlcnRleCkge1xuICAgICAgICB2ZXJ0ZXgudHlwZSA9ICdwdXJnZWQnXG4gICAgICAgIHZlcnRleC5zaGVsbCA9IHVuZGVmaW5lZFxuICAgIH1cbn1cblxuXG4vKipcbiAqIHRvIGdldCBteSBwdWZmIGNoYWluXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVzZXJuYW1lIFxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5QQi5EYXRhLmdldE15UHVmZkNoYWluID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAvLyBDVVJSRU5UTFkgVU5VU0VEXG4gICAgLy8gVE9ETzogdGhpcyBzaG91bGQgZ3JhYiBteSBwdWZmcyBmcm9tIGEgZmlsZSBvciBsb2NhbFN0b3JhZ2Ugb3Igd2hlcmV2ZXIgbXkgaWRlbnRpdHkncyBwdWZmcyBnZXQgc3RvcmVkXG4gICAgLy8gVE9ETzogdGhhdCBjb2xsZWN0aW9uIHNob3VsZCBiZSB1cGRhdGVkIGF1dG9tYXRpY2FsbHkgd2l0aCBuZXcgcHVmZnMgY3JlYXRlZCB0aHJvdWdoIG90aGVyIGRldmljZXNcbiAgICAvLyBUT0RPOiB0aGUgcHVmZmNoYWluIHNob3VsZCBhbHNvIGJlIHNvcnRlZCBpbiBjaGFpbiBvcmRlciwgbm90IGdlbmVyYWwgY29sbGVjdGlvbiBvcmRlclxuICAgIFxuICAgIHZhciBzaGVsbHMgPSBQQi5EYXRhLmdldFNoZWxscygpXG4gICAgXG4gICAgcmV0dXJuIHNoZWxscy5maWx0ZXIoZnVuY3Rpb24ocHVmZikgeyByZXR1cm4gcHVmZiAmJiBwdWZmLnVzZXJuYW1lID09IHVzZXJuYW1lIH0pIC8vIFRPRE86IHVzZSB0aGUgZ3JhcGhcbiAgICAvLyByZXR1cm4gUEIuTS5Gb3J1bS5nZXRCeVVzZXIodXNlcm5hbWUpIC8vIFRPRE86IHRlc3QgdGhpcyBcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbi8vICAgICAgIEdhcmJhZ2UgQ29sbGVjdG9yIFRoaW5nICAgICAgICAgLy9cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5cblBCLkRhdGEucnVubmluZ1NpemVUYWxseSA9IDBcblBCLkRhdGEuc2NvcmVTb3J0ID0ge31cblxuUEIuRGF0YS5oZXVyaXN0aWNzID0gW11cblBCLkRhdGEuYWRkSGV1cmlzdGljcyA9IGZ1bmN0aW9uKGZ1bikge1xuICAgIFBCLkRhdGEuaGV1cmlzdGljcy5wdXNoKGZ1bilcbn1cblxuUEIuRGF0YS5hZGRIZXVyaXN0aWNzKGZ1bmN0aW9uKHNoZWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoIChQQi5EYXRhLmdldEJvbnVzKHNoZWxsLCAnc3RhclN0YXRzJykgfHwge30pLnNjb3JlIHx8IDAgKSAqIDEwMFxufSlcblxuLy8gVE9ETzogYWRkIGhldXJpc3RpY3MgZm9yOiBteSBwdWZmcyAod2hpY2ggZ28gZWxzZXdoZXJlLCB1bHRpbWF0ZWx5KSwgcmVwbGllcyB0byBteSBwdWZmcywgbXkgcHVmZidzIHBhcmVudHMsIFxuLy8gICAgICAgZnJpZW5kJ3MgcHVmZnMgKHdoYXRldmVyIHRoYXQgbWVhbnMpLCBwdWZmIGZyZXNobmVzcywgbGFzdCBzZWVuLCBldGNcblxuXG5QQi5EYXRhLnJhdGVNeVB1ZmYgPSBmdW5jdGlvbihwdWZmKSB7XG4gICAgdmFyIHNjb3JlcyA9IFBCLkRhdGEuaGV1cmlzdGljcy5tYXAoZnVuY3Rpb24oaCkge3JldHVybiBoKHB1ZmYpfSkgICAgICAgICAgIC8vIGFwcGx5IGhldXJpc3RpY3NcbiAgICB2YXIgdG90YWwgID0gc2NvcmVzLnJlZHVjZShmdW5jdGlvbihhY2MsIHNjb3JlKSB7cmV0dXJuIGFjYysoc2NvcmV8fDApfSwgMCkgLy8gZ2V0IHRvdGFsIC8vIFRPRE86IGltcHJvdmUgYWxnb1xuICAgIHJldHVybiB0b3RhbFxufVxuXG5QQi5EYXRhLnJhdGVTb21lUHVmZnMgPSBmdW5jdGlvbihwdWZmcykge1xuICAgIHB1ZmZzLmZvckVhY2goZnVuY3Rpb24ocHVmZikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByYXRlIGVhY2ggcHVmZlxuICAgICAgICB2YXIgc2NvcmUgPSBQQi5EYXRhLnJhdGVNeVB1ZmYocHVmZilcbiAgICAgICAgUEIuRGF0YS5kb1N0dWZmV2l0aFNjb3JlKHB1ZmYsIHNjb3JlKVxuICAgICAgICBQQi5EYXRhLmRvU3R1ZmZXaXRoUHVmZiAocHVmZilcbiAgICB9KVxuICAgIC8vIFRISU5LOiBzb21lIGhldXJpc3RpY3MgcmVseSBvbiBzY29yZXMgb2YgcmVsYXRlZCBwdWZmcy4uLiBwb3NzaWJsZSBmZWVkYmFjayBsb29wPyB0b3BvbG9naWNhbCBvcmRlcmluZz9cbiAgICAvLyAgICAgICAgYSB0b3Bvc29ydCBpcyBlYXN5LWlzaCB3LyBncmFwaCBkYi4uLlxufVxuXG4vLyBUT0RPOiB3aGVuIHlvdSBzd2l0Y2ggaWRlbnRpdGllcywgcmVzY29yZSB0aGUgcHVmZnNcblxuXG5QQi5EYXRhLmRvU3R1ZmZXaXRoU2NvcmUgPSBmdW5jdGlvbihwdWZmLCBzY29yZSkge1xuICAgIFBCLkRhdGEucmVtb3ZlQ2FjaGVkUHVmZlNjb3JlKHB1ZmYpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBoYXMgdG8gY29tZSBiZWZvcmUgYm9uaWlcbiAgICBQQi5EYXRhLmFkZEJvbnVzKHB1ZmYsICdyYXRpbmcnLCBzY29yZSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHJhdGluZyB0byBib25paVxuICAgIFBCLkRhdGEuY2FjaGVQdWZmU2NvcmUocHVmZiwgc2NvcmUpICAgIFxuICAgIC8vIE9QVDogY2FjaGUgc29ydGVkIHZlcnNpb25cbiAgICAvLyBtYXliZSBiaW5zW3Njb3JlLmZsb29yXS5wdXNoKHB1ZmYpIG9yIHNvbWV0aGluZy4uLlxufVxuXG5QQi5EYXRhLmRvU3R1ZmZXaXRoUHVmZiA9IGZ1bmN0aW9uKHB1ZmYpIHtcbiAgICB2YXIgcHVmZnNpemUgPSBKU09OLnN0cmluZ2lmeShwdWZmKS5sZW5ndGhcbiAgICBQQi5EYXRhLmFkZEJvbnVzKHB1ZmYsICdzaXplJywgcHVmZnNpemUpXG4gICAgUEIuRGF0YS5ydW5uaW5nU2l6ZVRhbGx5ICs9IHB1ZmZzaXplIHx8IDAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmxvY2sgTmFOc1xufVxuXG5QQi5EYXRhLmNhY2hlUHVmZlNjb3JlID0gZnVuY3Rpb24ocHVmZiwgc2NvcmUpIHtcbiAgICB2YXIga2V5ID0gUEIuRGF0YS5jb252ZXJ0U2NvcmVUb0tleShzY29yZSlcbiAgICBQQi5EYXRhLnNjb3JlU29ydFtrZXldID0gUEIuRGF0YS5zY29yZVNvcnRba2V5XSB8fCBbXVxuICAgIFBCLkRhdGEuc2NvcmVTb3J0W2tleV0ucHVzaChwdWZmKVxufVxuXG5QQi5EYXRhLnJlbW92ZUNhY2hlZFB1ZmZTY29yZSA9IGZ1bmN0aW9uKHB1ZmYpIHtcbiAgICBpZighcHVmZikgcmV0dXJuIGZhbHNlXG4gICAgXG4gICAgdmFyIHNjb3JlID0gUEIuRGF0YS5nZXRCb251cyhwdWZmLCAnc2NvcmUnKVxuICAgIHZhciBrZXkgPSBQQi5EYXRhLmNvbnZlcnRTY29yZVRvS2V5KHNjb3JlKVxuICAgIHZhciBiaW4gPSBQQi5EYXRhLnNjb3JlU29ydFtrZXldXG4gICAgaWYoIWJpbikgcmV0dXJuIGZhbHNlXG4gICAgaWYoIWJpbi5sZW5ndGgpIHJldHVybiBmYWxzZVxuICAgIFxuICAgIGZvcih2YXIgaSA9IGJpbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZihiaW5baV0uc2lnID09IHB1ZmYuc2lnKSB7XG4gICAgICAgICAgICBiaW4uc3BsaWNlKGksIDEpXG4gICAgICAgICAgICB2YXIgcHVmZnNpemUgPSBQQi5EYXRhLmdldEJvbnVzKHB1ZmYsICdzaXplJylcbiAgICAgICAgICAgIFBCLkRhdGEucnVubmluZ1NpemVUYWxseSAtPSBwdWZmc2l6ZSB8fCAwICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBibG9jayBOYU5zXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cbn1cblxuUEIuRGF0YS5nZXRDYWNoZWRQdWZmcyA9IGZ1bmN0aW9uKGxpbWl0LCBib3R0b20pIHtcbiAgICB2YXIgc2VlbiA9IDBcbiAgICB2YXIgcmVzdWx0ID0gW11cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKFBCLkRhdGEuc2NvcmVTb3J0KS5tYXAocGFyc2VGbG9hdCkuc29ydCgpXG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldXG4gICAgICAgIHZhciBwdWZmcyA9IFBCLkRhdGEuc2NvcmVTb3J0W2tleV0gLy8gT1BUOiBzaG9ydC1jaXJjdWl0IG9uICFib3R0b21cbiAgICAgICAgXG4gICAgICAgIHB1ZmZzLnJlZHVjZShmdW5jdGlvbihzZWVuLCBwdWZmKSB7XG4gICAgICAgICAgICBpZihzZWVuID4gbGltaXQgPT0gISFib3R0b20pIHJlc3VsdC5wdXNoKHB1ZmYpXG4gICAgICAgICAgICByZXR1cm4gc2VlbisxXG4gICAgICAgIH0sIDApXG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZXN1bHRcbn1cblxuUEIuRGF0YS5jb252ZXJ0U2NvcmVUb0tleSA9IGZ1bmN0aW9uKHNjb3JlKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3Ioc2NvcmUgLyAxMCkgfHwgMCAvLyBUT0RPOiBtYWtlIHRoaXMgc21hcnRlclxufVxuXG5cblBCLkRhdGEuZ2V0VG9wUHVmZnMgPSBmdW5jdGlvbihsaW1pdCkge1xuICAgIHJldHVybiBQQi5EYXRhLmdldENhY2hlZFB1ZmZzKGxpbWl0KVxufVxuXG5QQi5EYXRhLmdldE5vdFRvcFB1ZmZzID0gZnVuY3Rpb24obGltaXQpIHtcbiAgICAvLyBncmFiIHRoZSBwdWZmcyBiZWxvdyB0aGUgbGltaXQgdGhyZXNob2xkICh3LyAzMDAgcHVmZnMgYW5kIGxpbWl0PTEwMCB0aGlzIHJldHVybnMgdGhlIDIwMCB3b3JzdCBwdWZmcylcbiAgICByZXR1cm4gUEIuRGF0YS5nZXRDYWNoZWRQdWZmcyhsaW1pdCwgJ2JvdHRvbScpXG59XG5cbi8vIFBCLkRhdGEuZ2V0VG9wUHVmZnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4vLyAgICAgdmFyIG51bWJlckxpbWl0ID0gIG9wdGlvbnMubnVtYmVyIHx8IDBcbi8vICAgICB2YXIgc2l6ZUxpbWl0ICAgPSAgICBvcHRpb25zLnNpemUgfHwgMFxuLy8gICAgIHZhciBjb21wYWN0ICAgICA9IG9wdGlvbnMuY29tcGFjdCB8fCBmYWxzZSAgLy8gd2hldGhlciB0byBhbGxvdyBjb21wYWN0aW9uIG9mIHJldHVybmVkIHB1ZmZzXG4vLyAgICAgdmFyIHJldmVyc2UgICAgID0gb3B0aW9ucy5yZXZlcnNlIHx8IGZhbHNlICAvLyByZXR1cm4gYm90dG9tIHB1ZmZzIGluc3RlYWQgb2YgdG9wIHB1ZmZzXG4vLyB9XG5cblBCLkRhdGEuZ2FyYmFnZUNvbXBhY3RvciA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGFyZSB3ZSBvdmVyIHRoZSBsaW1pdHM/XG4gICAgdmFyIGxpbWl0ICAgICA9IFBCLkNPTkZJRy5pbk1lbW9yeVNoZWxsTGltaXRcbiAgICB2YXIgbWVtbGltaXQgID0gUEIuQ09ORklHLmluTWVtb3J5TWVtb3J5TGltaXRcbiAgICB2YXIgc2l6ZWxpbWl0ID0gUEIuQ09ORklHLnNoZWxsQ29udGVudFRocmVzaG9sZFxuICAgIHZhciBkaWRTdHVmZiAgPSBmYWxzZVxuXG4gICAgaWYoUEIuRGF0YS5zaGVsbHMubGVuZ3RoID4gbGltaXQpIHtcbiAgICAgICAgZGlkU3R1ZmYgPSB0cnVlXG4gICAgICAgIFBCLkRhdGEuc2hlbGxzLnNsaWNlKGxpbWl0KS5tYXAoUEIucHJvcCgnc2lnJykpLmZvckVhY2goUEIuRGF0YS5yZW1vdmVTaGVsbEZyb21DYWNoZSlcbiAgICB9XG4gICAgXG4gICAgaWYoUEIuRGF0YS5ydW5uaW5nU2l6ZVRhbGx5ID4gbWVtbGltaXQpIHtcbiAgICAgICAgZGlkU3R1ZmYgPSB0cnVlXG4gICAgICAgIGZvciAodmFyIGkgPSBQQi5EYXRhLnNoZWxscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIHNoZWxsID0gUEIuRGF0YS5zaGVsbHNbaV1cbiAgICAgICAgICAgIHZhciBjb250ZW50X3NpemUgPSAoc2hlbGwucGF5bG9hZC5jb250ZW50fHxcIlwiKS50b1N0cmluZygpLmxlbmd0aCAvLyBUSElOSzogbm9uLWZsYXQgY29udGVudCBib3JrcyB0aGlzXG4gICAgICAgICAgICBpZiAoY29udGVudF9zaXplID4gc2l6ZWxpbWl0KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNoZWxsLnBheWxvYWQuY29udGVudCAvLyBUSElOSzogdGhpcyBpcyBoYXJkY29yZVxuICAgICAgICAgICAgICAgIHRvdGFsIC09IGNvbnRlbnRfc2l6ZSArIDEzIC8vIE5PVEU6IG1hZ2ljIG51bWJlciA9PSAnXCJjb250ZW50XCI6XCJcIiwnLmxlbmd0aFxuICAgICAgICAgICAgICAgIGlmKHRvdGFsIDw9IG1lbWxpbWl0KSBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBkaWRTdHVmZlxufVxuXG5cblBCLkRhdGEuZ2V0U2hlbGxzRm9yTG9jYWxTdG9yYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxpbWl0ICAgICA9IFBCLkNPTkZJRy5sb2NhbFN0b3JhZ2VTaGVsbExpbWl0XG4gICAgdmFyIG1lbWxpbWl0ICA9IFBCLkNPTkZJRy5sb2NhbFN0b3JhZ2VNZW1vcnlMaW1pdFxuICAgIHZhciBzaXplbGltaXQgPSBQQi5DT05GSUcuc2hlbGxDb250ZW50VGhyZXNob2xkXG4gICAgXG4gICAgdmFyIHNoZWxscyA9IFBCLkRhdGEuZ2V0VG9wUHVmZnMobGltaXQpXG4gICAgdmFyIHRvdGFsID0gc2hlbGxzLnJlZHVjZShmdW5jdGlvbihzaXplLCBzaGVsbCkge1xuICAgICAgICByZXR1cm4gc2l6ZSArIChQQi5EYXRhLmdldEJvbnVzKHNoZWxsLCAnc2l6ZScpIHx8IDApXG4gICAgfSwgMClcbiAgICBcbiAgICBpZiAodG90YWwgPD0gbWVtbGltaXQpIHJldHVybiBzaGVsbHNcbiAgICBcbiAgICAvLyBjb21wYWN0IHRoZSBwdWZmc1xuICAgIGZvciAodmFyIGkgPSBzaGVsbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHNoZWxsID0gc2hlbGxzW2ldXG4gICAgICAgIHZhciBjb250ZW50X3NpemUgPSAoc2hlbGwucGF5bG9hZC5jb250ZW50fHxcIlwiKS50b1N0cmluZygpLmxlbmd0aCAvLyBUSElOSzogbm9uLWZsYXQgY29udGVudCBib3JrcyB0aGlzXG4gICAgICAgIGlmIChjb250ZW50X3NpemUgPiBzaXplbGltaXQpIHtcbiAgICAgICAgICAgIHZhciBuZXdfc2hlbGwgPSBQQi5EYXRhLmNvbXBhY3RQdWZmKHNoZWxsKVxuICAgICAgICAgICAgc2hlbGxzW2ldID0gbmV3X3NoZWxsXG4gICAgICAgICAgICB0b3RhbCAtPSBjb250ZW50X3NpemUgKyAxMyAvLyBOT1RFOiBtYWdpYyBudW1iZXIgPT0gJ1wiY29udGVudFwiOlwiXCIsJy5sZW5ndGhcbiAgICAgICAgICAgIGlmKHRvdGFsIDw9IG1lbWxpbWl0KSBicmVha1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmICh0b3RhbCA8PSBtZW1saW1pdCkgcmV0dXJuIHNoZWxsc1xuICAgIFxuICAgIC8vIHJlbW92ZSBzaGVsbHMgdW50aWwgdW5kZXIgbWVtbGltaXRcbiAgICBmb3IgKHZhciBpID0gc2hlbGxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjb250ZW50X3NpemUgPSBKU09OLnN0cmluZ2lmeShzaGVsbCkubGVuZ3RoXG4gICAgICAgIHRvdGFsIC09IGNvbnRlbnRfc2l6ZVxuICAgICAgICBpZih0b3RhbCA8PSBtZW1saW1pdCkgYnJlYWtcbiAgICB9XG4gICAgXG4gICAgc2hlbGxzID0gc2hlbGxzLnNsaWNlKDAsIE1hdGgubWF4KGksIDEpKSAvLyBwcmV2ZW50IC0xIFxuICAgIFxuICAgIHJldHVybiBzaGVsbHNcbn1cblxuXG5QQi5EYXRhLmNvbXBhY3RQdWZmID0gZnVuY3Rpb24ocHVmZikge1xuICAgIC8vIFRISU5LOiBpbnN0ZWFkIG9mIHJlYnVpbGRpbmcgdGhlIHB1ZmYsIHVzZSBhIEpTT04uc3RyaW5naWZ5IHJlZHVjZXIgdGhhdCBzdHJpcHMgb3V0IHRoZSBjb250ZW50XG4gICAgdmFyIG5ld19zaGVsbCA9IEJvcm9uLmV4dGVuZChwdWZmKVxuICAgIHZhciBuZXdfcGF5bG9hZCA9IHt9XG4gICAgZm9yKHZhciBwcm9wIGluIHB1ZmYucGF5bG9hZClcbiAgICAgICAgaWYocHJvcCAhPSAnY29udGVudCcpXG4gICAgICAgICAgICBuZXdfcGF5bG9hZFtwcm9wXSA9IHB1ZmYucGF5bG9hZFtwcm9wXSBcblxuICAgIG5ld19zaGVsbC5wYXlsb2FkID0gbmV3X3BheWxvYWRcbiAgICByZXR1cm4gbmV3X3NoZWxsXG59XG4iLCIvKlxuXG4gICAgVXNlciBtYW5hZ2VtZW50IGZvciB0aGUgRXZlcnlCaXQgcGxhdGZvcm0uXG5cbiAgICBNb3N0IGZ1bmN0aW9ucyByZWxhdGVkIHRvIHVzZXJSZWNvcmRzIGxpdmUgaGVyZS5cbiAgICBOb3RlIHRoYXQgdXNlclJlY29yZHMgYXJlIGVudGlyZWx5IHB1YmxpYztcbiAgICBwcml2YXRlIGtleSBpZGVudGl0aWVzIGFyZSBoYW5kbGVkIGVsc2V3aGVyZS5cblxuICAgIENvcHlyaWdodCAyMDE0IEV2ZXJ5Qml0LiBTZWUgUkVBRE1FIGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuXG4gKi9cblxuUEIuVXNlcnMgPSB7fVxuXG5QQi5Vc2Vycy5yZWNvcmRzICA9IHt9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFwcyB2ZXJzaW9uZWQgdXNlcm5hbWUgdG8gYW4gYXJyYXkgb2YgREhUIHVzZXJSZWNvcmRzXG5QQi5Vc2Vycy5wcm9taXNlcyA9IHt9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGVuZGluZyB1c2VyUmVjb3JkIHJlcXVlc3RzXG5cblxuUEIuVXNlcnMuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBQQi5Vc2Vycy5kZXBlcnNpc3QoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3AgdXNlclJlY29yZHMgb3V0IG9mIGxvY2FsU3RvcmFnZVxufVxuXG5cblBCLlVzZXJzLnByb2Nlc3MgPSBmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgLy8vLyBQcm9jZXNzZXMgYWxsIGluY29taW5nIHVzZXJSZWNvcmRzXG4gICAgXG4gICAgdXNlclJlY29yZCA9IFBCLlVzZXJzLmJ1aWxkKCB1c2VyUmVjb3JkLnVzZXJuYW1lLCB1c2VyUmVjb3JkLmRlZmF1bHRLZXksIHVzZXJSZWNvcmQuYWRtaW5LZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHVzZXJSZWNvcmQucm9vdEtleSwgIHVzZXJSZWNvcmQubGF0ZXN0LCAgICAgdXNlclJlY29yZC5jcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCB1c2VyUmVjb3JkLnVwZGF0ZWQsICB1c2VyUmVjb3JkLnByb2ZpbGUsICAgIHVzZXJSZWNvcmQuaWRlbnRpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHVzZXJSZWNvcmQuY2FwYSApXG4gICAgXG4gICAgaWYoIXVzZXJSZWNvcmQpXG4gICAgICAgIHJldHVybiBQQi5vbkVycm9yKCdUaGF0IGlzIG5vdCBhbiBhY2NlcHRhYmxlIHVzZXIgcmVjb3JkJywgdXNlclJlY29yZClcbiAgICBcbiAgICBQQi5Vc2Vycy5jYWNoZSh1c2VyUmVjb3JkKVxuICAgIFxuICAgIHJldHVybiB1c2VyUmVjb3JkXG59XG5cblxuUEIuVXNlcnMuZ2V0Q2FjaGVkVXNlclJlY29yZCA9IGZ1bmN0aW9uKHVzZXJuYW1lKSB7XG4gICAgaWYoUEIuVXNlcnMubWFrZVZlcnNpb25lZCh1c2VybmFtZSkgPT0gdXNlcm5hbWUpICAgIC8vIHVzZXJuYW1lIGlzIHZlcnNpb25lZFxuICAgICAgICByZXR1cm4gUEIuVXNlcnMucmVjb3Jkc1t1c2VybmFtZV1cbiAgICBcbiAgICByZXR1cm4gUEIuVXNlcnMuZmluZEZyZXNoZXN0KHVzZXJuYW1lKSAgICAgICAgICAgICAgLy8gdXNlcm5hbWUgaXNuJ3QgdmVyc2lvbmVkXG59XG5cblxuLyoqXG4gKiBDaGVja3MgdGhlIGNhY2hlLCBhbmQgYWx3YXlzIHJldHVybnMgYSBwcm9taXNlXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWVcbiAqIEBwYXJhbSB7aW50fSBjYXBhIGlzIHRoZSB2ZXJzaW9uIG9mIHRoZSB1c2VybmFtZSBrZXlzXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBQcm9taXNlIGZvciBhIHVzZXIgcmVjb3JkXG4gKiBMb29rcyBmaXJzdCBpbiB0aGUgY2FjaGUsIHRoZW4gZ3JhYnMgZnJvbSB0aGUgbmV0d29ya1xuICovXG5QQi5Vc2Vycy5nZXRVc2VyUmVjb3JkUHJvbWlzZSA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBjYXBhKSB7XG4gICAgLy8vLyBUaGlzIGFsd2F5cyBjaGVja3MgdGhlIGNhY2hlLCBhbmQgYWx3YXlzIHJldHVybnMgYSBwcm9taXNlXG4gICAgXG4gICAgdmFyIHZlcnNpb25lZFVzZXJuYW1lID0gUEIuVXNlcnMubWFrZVZlcnNpb25lZCh1c2VybmFtZSwgY2FwYSlcbiAgICBcbiAgICB2YXIgdXNlclJlY29yZCA9IFBCLlVzZXJzLmdldENhY2hlZFVzZXJSZWNvcmQodmVyc2lvbmVkVXNlcm5hbWUpXG4gICAgXG4gICAgaWYodXNlclJlY29yZClcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1c2VyUmVjb3JkKVxuICAgIFxuICAgIHZhciB1c2VyUHJvbWlzZSA9IFBCLlVzZXJzLnByb21pc2VzW3ZlcnNpb25lZFVzZXJuYW1lXVxuICAgIFxuICAgIGlmKHVzZXJQcm9taXNlKVxuICAgICAgICByZXR1cm4gdXNlclByb21pc2VcbiAgICBcbiAgICByZXR1cm4gUEIuVXNlcnMuZ2V0VXNlclJlY29yZE5vQ2FjaGUodmVyc2lvbmVkVXNlcm5hbWUpXG59XG5cblxuLyoqXG4gKiBGb3JjZXMgYSByZXF1ZXN0IHRvIHRoZSBuZXR3b3JrLCBpZ25vcmVzIGNhY2hlZFxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lXG4gKiBAcGFyYW0ge2ludH0gY2FwYSBpcyB0aGUgdmVyc2lvbiBvZiB0aGUgdXNlcm5hbWUga2V5c1xuICogQHJldHVybnMge29iamVjdH0gUHJvbWlzZSBmb3IgYSB1c2VyIHJlY29yZFxuICovXG5QQi5Vc2Vycy5nZXRVc2VyUmVjb3JkTm9DYWNoZSA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBjYXBhKSB7XG4gICAgLy8vLyBUaGlzIG5ldmVyIGNoZWNrcyB0aGUgY2FjaGVcbiAgICBcbiAgICBjYXBhID0gY2FwYSB8fCAwIC8vIDAgc2lnbmFscyBQQi5OZXQuZ2V0VXNlclJlY29yZCB0byBnZXQgdGhlIGxhdGVzdCB1c2VyUmVjb3JkXG4gICAgXG4gICAgdmFyIHByb20gPSBQQi5OZXQuZ2V0VXNlclJlY29yZCh1c2VybmFtZSwgY2FwYSkgXG4gICAgXG4gICAgcHJvbSA9IHByb20udGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1c2VyUmVjb3JkID0gUEIuVXNlcnMucHJvY2Vzcyh1c2VyUmVjb3JkKVxuICAgICAgICAgICAgICAgICAgICBpZighdXNlclJlY29yZCkgIFBCLnRocm93RXJyb3IoJ0ludmFsaWQgdXNlciByZWNvcmQgcmV0dXJuZWQnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNlclJlY29yZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAsIFBCLmNhdGNoRXJyb3IoJ1VuYWJsZSB0byBhY2Nlc3MgdXNlciBpbmZvcm1hdGlvbiBmcm9tIHRoZSBESFQnKSlcbiAgICBcbiAgICB2YXIgdmVyc2lvbmVkVXNlcm5hbWUgPSBQQi5Vc2Vycy5tYWtlVmVyc2lvbmVkKHVzZXJuYW1lLCBjYXBhKVxuICAgIFBCLlVzZXJzLnByb21pc2VzW3ZlcnNpb25lZFVzZXJuYW1lXSA9IHByb21cbiAgICBcbiAgICByZXR1cm4gcHJvbVxufVxuXG5QQi5Vc2Vycy5kb2VzVXNlckV4aXN0ID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICByZXR1cm4gUEIuTmV0LmdldFVzZXJSZWNvcmQodXNlcm5hbWUpLnRoZW4oXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24odXNlclJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICBpZighdXNlclJlY29yZCB8fCB1c2VyUmVjb3JkLkZBSUwpIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1VzZXIgZG9lcyBub3QgZXhpc3QnXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICwgUEIuY2F0Y2hFcnJvcignVW5hYmxlIHRvIGFjY2VzcyB1c2VyIGluZm9ybWF0aW9uIGZyb20gdGhlIERIVCcpKVxufVxuXG5cbi8vXG4vLyBVU0VSTkFNRSBIRUxQRVJTXG4vL1xuXG5QQi5Vc2Vycy51c2VyUmVjb3JkVG9WZXJzaW9uZWRVc2VybmFtZSA9IGZ1bmN0aW9uKHVzZXJSZWNvcmQpIHtcbiAgICByZXR1cm4gUEIuVXNlcnMubWFrZVZlcnNpb25lZCh1c2VyUmVjb3JkLnVzZXJuYW1lLCB1c2VyUmVjb3JkLmNhcGEpXG59XG5cblBCLlVzZXJzLmp1c3RVc2VybmFtZSA9IGZ1bmN0aW9uKHZlcnNpb25lZFVzZXJuYW1lKSB7XG4gICAgdmFyIHVjID0gUEIuVXNlcnMuYnJlYWtWZXJzaW9uZWRVc2VybmFtZSh2ZXJzaW9uZWRVc2VybmFtZSlcbiAgICByZXR1cm4gdWMudXNlcm5hbWVcbn1cblxuUEIuVXNlcnMuanVzdENhcGEgPSBmdW5jdGlvbih2ZXJzaW9uZWRVc2VybmFtZSkge1xuICAgIHZhciB1YyA9IFBCLlVzZXJzLmJyZWFrVmVyc2lvbmVkVXNlcm5hbWUodmVyc2lvbmVkVXNlcm5hbWUpXG4gICAgcmV0dXJuIHVjLmNhcGFcbn1cblxuUEIuVXNlcnMubWFrZVZlcnNpb25lZCA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBjYXBhKSB7XG4gICAgaWYoIXVzZXJuYW1lIHx8ICF1c2VybmFtZS5pbmRleE9mKVxuICAgICAgICByZXR1cm4gJydcbiAgICBcbiAgICBpZihjYXBhKVxuICAgICAgICByZXR1cm4gYWN0dWFsbHlWZXJzaW9uVGhpc1VzZXJuYW1lT2theSh1c2VybmFtZSwgY2FwYSlcbiAgICBcbiAgICBpZih1c2VybmFtZS5pbmRleE9mKCc6JykgPiAwKVxuICAgICAgICByZXR1cm4gdXNlcm5hbWVcbiAgICBcbiAgICByZXR1cm4gYWN0dWFsbHlWZXJzaW9uVGhpc1VzZXJuYW1lT2theSh1c2VybmFtZSlcbiAgICBcbiAgICBmdW5jdGlvbiBhY3R1YWxseVZlcnNpb25UaGlzVXNlcm5hbWVPa2F5KHVzZXJuYW1lLCBjYXBhKSB7XG4gICAgICAgIGNhcGEgPSBjYXBhIHx8IDEgLy8gTk9URTogZGVmYXVsdCBjYXBhXG4gICAgICAgIHJldHVybiB1c2VybmFtZSArICc6JyArIGNhcGFcbiAgICB9XG59XG5cblBCLlVzZXJzLmJyZWFrVmVyc2lvbmVkVXNlcm5hbWUgPSBmdW5jdGlvbih2ZXJzaW9uZWRVc2VybmFtZSkge1xuICAgIHZhciBsaXN0ID0gKHZlcnNpb25lZFVzZXJuYW1lfHwnJykuc3BsaXQoJzonKVxuXG4gICAgcmV0dXJuIHsgdXNlcm5hbWU6IGxpc3RbMF1cbiAgICAgICAgICAgLCBjYXBhOiAgICAgbGlzdFsxXSB8fCAxIC8vIE5PVEU6IGRlZmF1bHQgY2FwYVxuICAgICAgICAgICB9XG59XG5cblxuLy9cbi8vIEdFTkVSQUwgSEVMUEVSU1xuLy9cblxuXG5QQi5Vc2Vycy5idWlsZCA9IGZ1bmN0aW9uKHVzZXJuYW1lLCBkZWZhdWx0S2V5LCBhZG1pbktleSwgcm9vdEtleSwgbGF0ZXN0LCBjcmVhdGVkLCB1cGRhdGVkLCBwcm9maWxlLCBpZGVudGl0eSwgY2FwYSkge1xuICAgIC8vLy8gcmV0dXJucyBhIGNhbm9uaWNhbCB1c2VyIG9iamVjdDogdXNlIHRoaXMgZXZlcnl3aGVyZSB1c2VyIG9iamVjdHMgYXJlIG5lZWRlZCAoREhULCBpZGVudGl0aWVzLCBldGMpXG5cbiAgICBsYXRlc3QgICA9IGxhdGVzdCAgIHx8IFwiXCIgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpZ25hdHVyZSBvZiB0aGUgbW9zdCByZWNlbnQgcHVmZiBwdWJsaXNoZWQgYnkgdGhlIHVzZXJcbiAgICB1cGRhdGVkICA9IHVwZGF0ZWQgIHx8IFwiXCIgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGUgb2YgdGhlIG1vc3QgcmVjZW50IHVwZGF0ZSB0byB0aGUgdXNlcm5hbWVcbiAgICBwcm9maWxlICA9IHByb2ZpbGUgIHx8IFwiXCIgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2ZpbGUgcHVmZiBzaWduYXR1cmVcbiAgICBpZGVudGl0eSA9IGlkZW50aXR5IHx8IFwiXCIgICAgICAgICAgICAgICAgICAgICAgIC8vIGlkZW50aXR5IHB1ZmYgc2lnbmF0dXJlXG4gICAgY2FwYSAgICAgPSBjYXBhICAgICB8fCAxICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmVyc2lvbiBvZiB0aGUgdXNlcm5hbWVcbiAgICBcbiAgICAvLyBUSElOSzogc2hvdWxkIHdlIGNoZWNrIGZvciB2YWxpZCBrZXlzPyB2YWxpZCB0aW1lc3RhbXAgZm9yIHVwZGF0ZWQ/IHdoYXQgaWYgeW91IHdhbnQgYSBwYXJ0aWFsbHkgaW52YWxpZCB1c2VyIGxpa2UgYW5vbj9cbiAgICBcbiAgICAvLyBUSElOSzogc3BsaXQgdXNlcm5hbWUgYW5kIGNhcGEgaWYgaXQncyBhIHZlcnNpb25lZFVzZXJuYW1lP1xuXG4gICAgaWYoIVBCLnZhbGlkYXRlVXNlcm5hbWUodXNlcm5hbWUpKVxuICAgICAgICByZXR1cm4gZmFsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVycm9yIGlzIGxvZ2dlZCBpbnNpZGUgUEIudmFsaWRhdGVVc2VybmFtZVxuICAgIFxuICAgIHJldHVybiB7ICAgdXNlcm5hbWU6IHVzZXJuYW1lICAgICAgICAgICAgICAgICAgIC8vIHVudmVyc2lvbmVkIHVzZXJuYW1lXG4gICAgICAgICAgICwgICAgICAgY2FwYTogY2FwYVxuICAgICAgICAgICAsICAgIHJvb3RLZXk6IHJvb3RLZXkgICAgICAgICAgICAgICAgICAgIC8vIHB1YmxpYyByb290IGtleVxuICAgICAgICAgICAsICAgYWRtaW5LZXk6IGFkbWluS2V5ICAgICAgICAgICAgICAgICAgIC8vIHB1YmxpYyBhZG1pbiBrZXlcbiAgICAgICAgICAgLCBkZWZhdWx0S2V5OiBkZWZhdWx0S2V5ICAgICAgICAgICAgICAgICAvLyBwdWJsaWMgZGVmYXVsdCBrZXlcbiAgICAgICAgICAgLCAgICBjcmVhdGVkOiBjcmVhdGVkICAgICAgICAgICAgICAgICAgICAvLyBEYXRlIHRoZSByZWNvcmQgd2FzIGNyZWF0ZWRcbiAgICAgICAgICAgLCAgICAgbGF0ZXN0OiBsYXRlc3RcbiAgICAgICAgICAgLCAgICB1cGRhdGVkOiB1cGRhdGVkXG4gICAgICAgICAgICwgICAgcHJvZmlsZTogcHJvZmlsZVxuICAgICAgICAgICAsICAgaWRlbnRpdHk6IGlkZW50aXR5XG4gICAgICAgICAgIH1cbn1cblxuXG5QQi5Vc2Vycy51c2VybmFtZXNUb1VzZXJSZWNvcmRzUHJvbWlzZSA9IGZ1bmN0aW9uKHVzZXJuYW1lcykge1xuICAgIC8vLy8gcmV0dXJucyBhIHByb21pc2Ugb2YgdXNlclJlY29yZHMuIHRoYW5rcyB0byBjYXBhIHdlIHVzdWFsbHkgZG9uJ3QgbmVlZCB0aGUgbGF0ZXN0IGFuZCBjYW4gdXNlIGNhY2hlZCB2ZXJzaW9ucy5cbiAgICBpZighdXNlcm5hbWVzIHx8ICF1c2VybmFtZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKVxuICAgIFxuICAgIGlmKCFBcnJheS5pc0FycmF5KHVzZXJuYW1lcykpXG4gICAgICAgIHVzZXJuYW1lcyA9IFt1c2VybmFtZXNdXG4gICAgICAgIFxuICAgIHZhciB1c2VyUmVjb3JkcyA9IHVzZXJuYW1lcy5tYXAoUEIuVXNlcnMuZ2V0Q2FjaGVkVXNlclJlY29yZCkuZmlsdGVyKEJvb2xlYW4pXG4gICAgXG4gICAgaWYgKHVzZXJSZWNvcmRzLmxlbmd0aCA9PSB1c2VybmFtZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVzZXJSZWNvcmRzKSAvLyBnb3QgJ2VtIGFsbCFcbiAgICBcbiAgICB2YXIgcHJvbSA9IFByb21pc2UucmVzb2x2ZSgpIC8vIGEgcHJvbWlzZSB3ZSB1c2UgdG8gc3RyaW5nIGV2ZXJ5dGhpbmcgYWxvbmdcblxuICAgIHZhciB1c2VyUmVjb3JkVXNlcm5hbWVzID0gdXNlclJlY29yZHMubWFwKGZ1bmN0aW9uICh1c2VyUmVjb3JkKSB7XG4gICAgICAgIHJldHVybiB1c2VyUmVjb3JkLnVzZXJuYW1lXG4gICAgfSlcbiAgICBcbiAgICB1c2VybmFtZXMuZm9yRWFjaChmdW5jdGlvbiAodXNlcm5hbWUpIHtcbiAgICAgICAgaWYgKCF+dXNlclJlY29yZFVzZXJuYW1lcy5pbmRleE9mKHVzZXJuYW1lKSkgeyAvLyB3ZSBuZWVkIHRoaXMgb25lXG4gICAgICAgICAgICBwcm9tID0gcHJvbS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQQi5Vc2Vycy5nZXRVc2VyUmVjb3JkTm9DYWNoZSh1c2VybmFtZSkudGhlbihmdW5jdGlvbiAodXNlclJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICB1c2VyUmVjb3Jkcy5wdXNoKHVzZXJSZWNvcmQpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIHJldHVybiBwcm9tLnRoZW4oZnVuY3Rpb24oKSB7IHJldHVybiB1c2VyUmVjb3JkcyB9KSAvLyB3aGVuIGl0J3MgYWxsIGRvbmUsIGdpdmUgYmFjayB0aGUgdXNlclJlY29yZHNcbn1cblxuUEIuVXNlcnMuY2FjaGUgPSBmdW5jdGlvbih1c2VyUmVjb3JkKSB7XG4gICAgLy8vLyBUaGlzIGNhY2hlcyB3aXRoIG5vIHZhbGlkYXRpb246IHVzZSBQQi5Vc2Vycy5wcm9jZXNzIGluc3RlYWRcbiAgICBcbiAgICB2YXIgdmVyc2lvbmVkVXNlcm5hbWUgPSBQQi5Vc2Vycy51c2VyUmVjb3JkVG9WZXJzaW9uZWRVc2VybmFtZSh1c2VyUmVjb3JkKVxuICAgIFxuICAgIFBCLlVzZXJzLnJlY29yZHNbdmVyc2lvbmVkVXNlcm5hbWVdID0gdXNlclJlY29yZFxuICAgIFxuICAgIGRlbGV0ZSBQQi5Vc2Vycy5wcm9taXNlc1t2ZXJzaW9uZWRVc2VybmFtZV1cbiAgICBcbiAgICBQQi5QZXJzaXN0LnNhdmUoJ3VzZXJSZWNvcmRzJywgUEIuVXNlcnMucmVjb3JkcylcbiAgICBcbiAgICByZXR1cm4gdXNlclJlY29yZFxufVxuXG5QQi5Vc2Vycy5kZXBlcnNpc3QgPSBmdW5jdGlvbigpIHtcbiAgICAvLy8vIGdyYWIgdXNlclJlY29yZHMgZnJvbSBsb2NhbCBzdG9yYWdlLiB0aGlzIHNtYXNoZXMgdGhlIGN1cnJlbnQgdXNlclJlY29yZHMgaW4gbWVtb3J5LCBzbyBkb24ndCBjYWxsIGl0IGFmdGVyIGluaXQhXG4gICAgUEIuVXNlcnMucmVjb3JkcyA9IFBCLlBlcnNpc3QuZ2V0KCd1c2VyUmVjb3JkcycpIHx8IHt9XG59XG5cblxuUEIuVXNlcnMuZmluZEZyZXNoZXN0ID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICB1c2VybmFtZSA9IFBCLlVzZXJzLmp1c3RVc2VybmFtZSh1c2VybmFtZSlcbiAgICBcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKFBCLlVzZXJzLnJlY29yZHMpXG4gICAgdmFyIGNhcGEgPSAwXG4gICAgXG4gICAga2V5cy5maWx0ZXIoZnVuY3Rpb24odmVyc2lvbmVkVXNlcm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIFBCLlVzZXJzLmp1c3RVc2VybmFtZSh2ZXJzaW9uZWRVc2VybmFtZSkgPT0gdXNlcm5hbWVcbiAgICB9KS5mb3JFYWNoKCBmdW5jdGlvbih2ZXJzaW9uZWRVc2VybmFtZSkge1xuICAgICAgICB2YXIgdGhpc19jYXBhID0gK1BCLlVzZXJzLmp1c3RDYXBhKHZlcnNpb25lZFVzZXJuYW1lKVxuICAgICAgICBpZih0aGlzX2NhcGEgPiBjYXBhKVxuICAgICAgICAgICAgY2FwYSA9IHRoaXNfY2FwYVxuICAgIH0pXG4gICAgXG4gICAgdmFyIHZlcnNpb25lZFVzZXJuYW1lID0gUEIuVXNlcnMubWFrZVZlcnNpb25lZCh1c2VybmFtZSwgY2FwYSlcbiAgICByZXR1cm4gUEIuVXNlcnMucmVjb3Jkc1t2ZXJzaW9uZWRVc2VybmFtZV1cbn1cblxuXG5QQi5Vc2Vycy5nZXRJZGVudGl0eVB1ZmYgPSBmdW5jdGlvbih1c2VyUmVjb3JkLCBwcml2YXRlS2V5KSB7XG4gICAgLy8vLyB1c2VyUmVjb3JkIGlzIHRoZSB1c2VyJ3MgY2Fub25pY2FsIHVzZXIgcmVjb3JkXG4gICAgLy8vLyBwcml2YXRlS2V5IGlzIHRoZSB1c2VyJ3MgcHJpdmF0ZSBkZWZhdWx0IGtleVxuICAgIFxuICAgIGlmKCF1c2VyUmVjb3JkIHx8ICF1c2VyUmVjb3JkLmRlZmF1bHRLZXkgfHwgIXVzZXJSZWNvcmQudXNlcm5hbWUpXG4gICAgICAgIHJldHVybiBQQi5lbXB0eVByb21pc2UoJ0ludmFsaWQgdXNlciByZWNvcmQnKVxuICAgIFxuICAgIGlmKCF1c2VyUmVjb3JkLmlkZW50aXR5KVxuICAgICAgICByZXR1cm4gUEIuZW1wdHlQcm9taXNlKCdVc2VyIHJlY29yZCBoYXMgbm8gaWRlbnRpdHknKVxuICAgIFxuICAgIHB1ZmZwcm9tID0gUEIuTmV0LmdldFB1ZmZCeVNpZyh1c2VyUmVjb3JkLmlkZW50aXR5KVxuXG4gICAgcmV0dXJuIHB1ZmZwcm9tLnRoZW4oZnVuY3Rpb24ocHVmZnMpIHtcbiAgICAgICAgdmFyIGVudmVsb3BlID0gcHVmZnNbMF1cbiAgICAgICAgaWYoIWVudmVsb3BlIHx8ICFlbnZlbG9wZS5zaWcpXG4gICAgICAgICAgICByZXR1cm4gUEIudGhyb3dFcnJvcignSW52YWxpZCBpZGVudGl0eSBwdWZmJylcbiAgICAgICAgXG4gICAgICAgIHZhciBzZW5kZXJQdWJsaWNLZXkgPSB1c2VyUmVjb3JkLmRlZmF1bHRLZXlcbiAgICAgICAgdmFyIHJlY2lwaWVudFVzZXJuYW1lID0gUEIuVXNlcnMubWFrZVZlcnNpb25lZCh1c2VyUmVjb3JkLnVzZXJuYW1lLCB1c2VyUmVjb3JkLmNhcGEpXG4gICAgICAgIHZhciByZWNpcGllbnRQcml2YXRlS2V5ID0gcHJpdmF0ZUtleVxuXG4gICAgICAgIHJldHVybiBQQi5EYXRhLmRlY3J5cHRQdWZmQWxtb3N0Rm9yUmVhbHMoZW52ZWxvcGUsIHNlbmRlclB1YmxpY0tleSwgcmVjaXBpZW50VXNlcm5hbWUsIHJlY2lwaWVudFByaXZhdGVLZXkpXG4gICAgfSkgICAgICAgIFxufVxuXG5cblxuXG4vL1xuLy8gQ0xFQU5VUCBSRVFVSVJFRFxuLy9cblxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB1c2VyJ3MgREhUIHJlY29yZCwgb3IgY3JlYXRlIGEgbmV3IGFub24gdXNlciwgb3IgZGllIHRyeWluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5QQi5Vc2Vycy5nZXRVcFRvRGF0ZVVzZXJBdEFueUNvc3QgPSBmdW5jdGlvbigpIHtcbiAgICAvLy8vIEVpdGhlciBnZXQgdGhlIGN1cnJlbnQgdXNlcidzIERIVCByZWNvcmQsIG9yIGNyZWF0ZSBhIG5ldyBhbm9uIHVzZXIsIG9yIGRpZSB0cnlpbmdcblxuICAgIHZhciB1c2VybmFtZSA9IFBCLmdldEN1cnJlbnRVc2VybmFtZSgpXG5cbiAgICBpZih1c2VybmFtZSlcbiAgICAgICAgcmV0dXJuIFBCLlVzZXJzLmdldFVzZXJSZWNvcmROb0NhY2hlKHVzZXJuYW1lLCAwKSAvLyAwIHRlbGxzIFBCLk5ldC5nZXRVc2VyUmVjb3JkIHRvIGZldGNoIHRoZSBsYXRlc3RcbiAgICBcbiAgICB2YXIgcHJvbSA9IFBCLlVzZXJzLmFkZE5ld0Fub25Vc2VyKClcbiAgICBcbiAgICByZXR1cm4gcHJvbS50aGVuKGZ1bmN0aW9uKHVzZXJSZWNvcmQpIHtcbiAgICAgICAgUEIuc3dpdGNoSWRlbnRpdHlUbyh1c2VyUmVjb3JkLnVzZXJuYW1lKVxuICAgICAgICBjb25zb2xlLmxvZyhcIlNldHRpbmcgY3VycmVudCB1c2VyIHRvIFwiICsgdXNlclJlY29yZC51c2VybmFtZSlcbiAgICAgICAgcmV0dXJuIHVzZXJSZWNvcmRcbiAgICB9KVxufVxuXG5cbi8qKlxuICogR2VuZXJhdGUgYSByYW5kb20gdXNlcm5hbWVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuUEIuVXNlcnMuZ2VuZXJhdGVSYW5kb21Vc2VybmFtZSA9IGZ1bmN0aW9uKGxlbikge1xuXG4gICAgLy8gU2V0IGEgZGVmYXVsdCB2YWx1ZSBmb3IgbGVuZ3RoXG4gICAgaWYoIWxlbiB8fCBsZW4gIT0gTWF0aC5yb3VuZChsZW4pKVxuICAgICAgICBsZW49MTBcblxuICAgIHZhciBnZW5lcmF0ZWROYW1lID0gJydcbiAgICB2YXIgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5J1xuICAgIGZvcih2YXIgaT0wOyBpPDEwOyBpKyspIHtcbiAgICAgICAgZ2VuZXJhdGVkTmFtZSArPSBQQi5DcnlwdG8uZ2V0UmFuZG9tSXRlbShhbHBoYWJldClcbiAgICB9XG4gICAgcmV0dXJuIGdlbmVyYXRlZE5hbWVcbn1cblxuLyoqXG4gKlxuICogUmVnaXN0ZXIgYSBuZXcgYW5vbnltb3VzIHVzZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzcGhyYXNlIG9wdGlvbmFsIGlmIGluY2x1ZGVkIHRoZW4gdXNlZFxuICogQHBhcmFtIHtzdHJpbmd9IGF0dGFjaFRvVXNlcm5hbWVcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdXNlciByZWNvcmQgb3IgZmFpbHNcbiAqL1xuUEIuVXNlcnMuYWRkTmV3QW5vblVzZXIgPSBmdW5jdGlvbihwYXNzcGhyYXNlLCBhdHRhY2hUb1VzZXJuYW1lKSB7XG4gICAgLy8vLyBjcmVhdGUgYSBuZXcgYW5vbnltb3VzIGFsaWFzLiBpZiBhdHRhY2hUb1VzZXJuYW1lIGlzIHByb3ZpZGVkIGl0IGJlY29tZXMgYW4gYWxpYXMgZm9yIHRoYXQgaWRlbnRpdHkuXG4gICAgLy8vLyBpZiBhdHRhY2hUb1VzZXJuYW1lIGlzIGZhbHNlIHRoZSBhbGlhcyBiZWNvbWVzIHByaW1hcnkgZm9yIGl0cyBvd24gaWRlbnRpdHkuXG4gICAgLy8gVE9ETzogbWFrZSBhdHRhY2hUb1VzZXJuYW1lIHdvcmtcbiAgICAvLyBUSElOSzogRG9uJ3Qgd2FudCB0byBzd2l0Y2ggdG8gdGhpcyB1c2VyLCBidXQgd2hhdCBhYm91dCBhbGlhcyBpc3N1ZSBhbmQgc2F2aW5nIGJvbnVzIGluZm8/XG4gICAgLy8gVE9ETzogU3BsaXQgdGhpcyBpbnRvIHR3byBmdW5jdGlvbnMsIG9uZSB0aGF0IHJlZ2lzdGVycyBhbiBhbm9uIHVzZXIgYmFzZWQgb24gZ2l2ZW4gaW5mb1xuICAgIC8vIGFub3RoZXIgdGhhdCByZWdpc3RlcnMgYW5vbiB1c2VyIEFORCBzd2l0Y2hlcyBjdXJyZW50IHRvIHRoYXQgdXNlci4gT3IgZmxhZyBpbiBmdW5jdGlvbiB0byBzd2l0Y2ggdG8gdGhhdCB1c2VyLlxuXG4gICAgdmFyIG5ld1VzZXJuYW1lID0gJ2Fub24uJyArIFBCLlVzZXJzLmdlbmVyYXRlUmFuZG9tVXNlcm5hbWUoMTIpXG5cbiAgICBpZih0eXBlb2YgcGFzc3BocmFzZSAhPT0gdW5kZWZpbmVkICYmIHBhc3NwaHJhc2UpIHtcbiAgICAgICAgdmFyIHByZXBlbmRlZFBhc3NwaHJhc2UgPSBuZXdVc2VybmFtZSArIHBhc3NwaHJhc2VcbiAgICAgICAgdmFyIHByaXZhdGVLZXkgPSBQQi5DcnlwdG8ucGFzc3BocmFzZVRvUHJpdmF0ZUtleVdpZihwcmVwZW5kZWRQYXNzcGhyYXNlKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcml2YXRlS2V5ID0gUEIuQ3J5cHRvLmdlbmVyYXRlUHJpdmF0ZUtleSgpXG4gICAgfVxuXG4gICAgLy8gU2V0IHByaXZhdGUga2V5c1xuICAgIHZhciBwcml2YXRlUm9vdEtleSA9ICAgIHByaXZhdGVLZXlcbiAgICB2YXIgcHJpdmF0ZUFkbWluS2V5ID0gICBwcml2YXRlS2V5XG4gICAgdmFyIHByaXZhdGVEZWZhdWx0S2V5ID0gcHJpdmF0ZUtleVxuXG4gICAgLy8gR2VuZXJhdGUgcHVibGljIGtleXNcbiAgICB2YXIgcm9vdEtleSAgICA9IFBCLkNyeXB0by5wcml2YXRlVG9QdWJsaWMocHJpdmF0ZUtleSlcbiAgICB2YXIgYWRtaW5LZXkgICA9IFBCLkNyeXB0by5wcml2YXRlVG9QdWJsaWMocHJpdmF0ZUtleSlcbiAgICB2YXIgZGVmYXVsdEtleSA9IFBCLkNyeXB0by5wcml2YXRlVG9QdWJsaWMocHJpdmF0ZUtleSlcblxuICAgIC8vIGJ1aWxkIG91ciBESFQgdXBkYXRlIHB1ZmZcbiAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgICAgcmVxdWVzdGVkVXNlcm5hbWU6IG5ld1VzZXJuYW1lLFxuICAgICAgICBkZWZhdWx0S2V5OiBkZWZhdWx0S2V5LFxuICAgICAgICBhZG1pbktleTogYWRtaW5LZXksXG4gICAgICAgIHJvb3RLZXk6IHJvb3RLZXksXG4gICAgICAgIHRpbWU6IERhdGUubm93KClcbiAgICB9XG5cbiAgICB2YXIgcm91dGluZyA9IFtdIC8vIFRISU5LOiBESFQ/XG4gICAgdmFyIGNvbnRlbnQgPSAncmVxdWVzdFVzZXJuYW1lJ1xuICAgIHZhciB0eXBlICAgID0gJ3VwZGF0ZVVzZXJSZWNvcmQnXG5cbiAgICB2YXIgcHVmZiA9IFBCLmJ1aWxkUHVmZignYW5vbicsIFBCLkNPTkZJRy5hbm9uUHJpdmF0ZUFkbWluS2V5LCByb3V0aW5nLCB0eXBlLCBjb250ZW50LCBwYXlsb2FkKVxuXG4gICAgcmV0dXJuIFBCLk5ldC51cGRhdGVVc2VyUmVjb3JkKHB1ZmYpXG5cbn1cblxuUEIuVXNlcnMuY3JlYXRlQW5vblVzZXJBbmRNYWtlQ3VycmVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuZXdVc2VybmFtZSA9ICdhbm9uLicgKyBQQi5Vc2Vycy5nZW5lcmF0ZVJhbmRvbVVzZXJuYW1lKDEyKVxuICAgIHZhciBwYXNzcGhyYXNlID0gUEIuQ3J5cHRvLmdlbmVyYXRlUHJpdmF0ZUtleSgpLnNsaWNlKC0xMilcbiAgICB2YXIgcHJlcGVuZGVkUGFzc3BocmFzZSA9IG5ld1VzZXJuYW1lICsgcGFzc3BocmFzZVxuICAgIHZhciBwcml2YXRlS2V5ID0gUEIuQ3J5cHRvLnBhc3NwaHJhc2VUb1ByaXZhdGVLZXlXaWYocHJlcGVuZGVkUGFzc3BocmFzZSlcbiAgICB2YXIgcHVibGljS2V5ID0gUEIuQ3J5cHRvLnByaXZhdGVUb1B1YmxpYyhwcml2YXRlS2V5KVxuXG4gICAgLy8gQnVpbGQgcHVmZiB0byByZWdpc3RlciB0aGlzIHVzZXJcbiAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgICAgcmVxdWVzdGVkVXNlcm5hbWU6IG5ld1VzZXJuYW1lLFxuICAgICAgICBkZWZhdWx0S2V5OiBwdWJsaWNLZXksXG4gICAgICAgIGFkbWluS2V5OiBwdWJsaWNLZXksXG4gICAgICAgIHJvb3RLZXk6IHB1YmxpY0tleSxcbiAgICAgICAgdGltZTogRGF0ZS5ub3coKVxuICAgIH1cblxuICAgIHZhciByb3V0aW5nID0gW10gLy8gVEhJTks6IERIVD9cbiAgICB2YXIgY29udGVudCA9ICdyZXF1ZXN0VXNlcm5hbWUnXG4gICAgdmFyIHR5cGUgICAgPSAndXBkYXRlVXNlclJlY29yZCdcblxuICAgIHZhciBwdWZmID0gUEIuYnVpbGRQdWZmKCdhbm9uJywgUEIuQ09ORklHLmFub25Qcml2YXRlQWRtaW5LZXksIHJvdXRpbmcsIHR5cGUsIGNvbnRlbnQsIHBheWxvYWQpXG5cbiAgICB2YXIgcHJvbSA9IFBCLk5ldC51cGRhdGVVc2VyUmVjb3JkKHB1ZmYpXG5cbiAgICAvLyBXb3Jrcz9cbiAgICByZXR1cm4gcHJvbS50aGVuKGZ1bmN0aW9uKHVzZXJSZWNvcmQpIHtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHRoaXMgdXNlclxuICAgICAgICBQQi5hZGRBbGlhcyh1c2VyUmVjb3JkLnVzZXJuYW1lLCB1c2VyUmVjb3JkLnVzZXJuYW1lLCAxLCBwcml2YXRlS2V5LCBwcml2YXRlS2V5LCBwcml2YXRlS2V5LCB7cGFzc3BocmFzZTogcGFzc3BocmFzZX0pXG5cbiAgICAgICAgUEIuc3dpdGNoSWRlbnRpdHlUbyh1c2VyUmVjb3JkLnVzZXJuYW1lKVxuXG4gICAgICAgIHJldHVybiB1c2VyUmVjb3JkXG4gICAgfSlcbn1cblxuIiwiLypcbiAgICBDcnlwdG9ncmFwaGljIG1hbmFnZW1lbnQgZm9yIHRoZSBFdmVyeUJpdCBwbGF0Zm9ybS5cblxuICAgIENvbnRhaW5zIHZhcmlvdXMgZnVuY3Rpb25zIHRoYXQgcmVseSBvbiBiaXRjb2luLWxpYi5qcyBmb3IgdGhlaXIgY3J5cHRvZ3JhcGhpYyBmdW5jdGlvbmFsaXR5LFxuICAgIGFuIEVDREggaW1wbGVtZW50YXRpb24sIGEgcmFuZG9tIG51bWJlciBzaGltIGZvciBvbGRlciBicm93c2VycywgYW5kIHJhbmRvbSBoZWxwZXIgZnVuY3Rpb25zLlxuXG4gICAgQ29weXJpZ2h0IDIwMTQgRXZlcnlCaXQuIFNlZSBSRUFETUUgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbiovXG5cblBCLkNyeXB0byA9IHt9O1xuXG4vKipcbiAqIEdlbmVyYXRlIHByaXZhdGUga2V5XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFxuICovXG5QQi5DcnlwdG8uZ2VuZXJhdGVQcml2YXRlS2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gT1BUOiByZW1vdmUgdGhpcyB0ZXN0IG9uY2UgQml0Y29pbi5FQ0tleSBubyBsb25nZXIgZ2VuZXJhdGVzIGludmFsaWQga2V5cyAoYWJvdXQgMSBpbiAxLDAwMCByaWdodCBub3cpXG4gICAgdmFyIHByaWtleSA9IG5ldyBCaXRjb2luLkVDS2V5KCkudG9XaWYoKVxuICAgIGlmKFBCLkNyeXB0by53aWZUb1ByaUtleShwcmlrZXkpKVxuICAgICAgICByZXR1cm4gcHJpa2V5XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gUEIuQ3J5cHRvLmdlbmVyYXRlUHJpdmF0ZUtleSgpICAvLyBUSElOSzogdGhpcyBjb3VsZCBnZW5lcmF0ZSBhbiBldGVybmFsIGVycm9yIGV4cGxvc2lvblxufVxuXG5cbi8qKlxuICogQ29udmVydCBwdWJsaWMga2V5IGZyb20gcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSAge3N0cmluZ30gcHJpdmF0ZUtleVdJRlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5QQi5DcnlwdG8ucHJpdmF0ZVRvUHVibGljID0gZnVuY3Rpb24ocHJpdmF0ZUtleVdJRikge1xuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIHJldHVybiBmYWxzZSBpZiBzdHJpbmcgaXMgZW1wdHlcbiAgICBpZighcHJpdmF0ZUtleVdJRilcbiAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ1RoYXQgcHJpdmF0ZSBrZXkgY29udGFpbmVkIG5vIGRhdGEnKVxuICAgICAgICBcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gUEIuQ3J5cHRvLndpZlRvUHJpS2V5KHByaXZhdGVLZXlXSUYpLmdldFB1Yih0cnVlKS50b1dpZigpXG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXk6IGNvdWxkIG5vdCBjb252ZXJ0IHRvIHB1YmxpYyBrZXknLCBbcHJpdmF0ZUtleVdJRiwgZXJyXSlcbiAgICB9XG59XG5cblxuLyoqXG4gKiBTaWduIHRoZSBoYXNoIG9mIHNvbWUgZGF0YSB3aXRoIGEgcHJpdmF0ZSBrZXkgYW5kIHJldHVybiB0aGUgc2lnIGluIGJhc2UgNThcbiAqIEBwYXJhbSAge29iamVjdH0gdW5zaWduZWRQdWZmXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHByaXZhdGVLZXlXSUZcbiAqIEByZXR1cm4geyhib29sZWFufGVycm9yKX1cbiAqL1xuUEIuQ3J5cHRvLnNpZ25QdWZmID0gZnVuY3Rpb24odW5zaWduZWRQdWZmLCBwcml2YXRlS2V5V0lGKSB7XG4gICAgLy8vLyBzaWduIHRoZSBoYXNoIG9mIHNvbWUgZGF0YSB3aXRoIGEgcHJpdmF0ZSBrZXkgYW5kIHJldHVybiB0aGUgc2lnIGluIGJhc2UgNThcblxuICAgIHZhciBwcmlrZXkgPSBQQi5DcnlwdG8ud2lmVG9QcmlLZXkocHJpdmF0ZUtleVdJRilcbiAgICB2YXIgbWVzc2FnZSA9IFBCLkNyeXB0by5wdWZmVG9TaWdsZXNzU3RyaW5nKHVuc2lnbmVkUHVmZilcbiAgICB2YXIgbWVzc2FnZUhhc2ggPSBQQi5DcnlwdG8uY3JlYXRlTWVzc2FnZUhhc2gobWVzc2FnZSlcbiAgICBcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gQml0Y29pbi5iYXNlNTguZW5jb2RlKHByaWtleS5zaWduKG1lc3NhZ2VIYXNoKSlcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICByZXR1cm4gUEIub25FcnJvcignQ291bGQgbm90IHByb3Blcmx5IGVuY29kZSBzaWduYXR1cmUnLCBbcHJpa2V5LCBtZXNzYWdlSGFzaCwgZXJyXSlcbiAgICB9XG59XG5cblxuLyoqXG4gKiB0byB2ZXJpZnkgcHVmZiBzaWdcbiAqIEBwYXJhbSAge29iamVjdH0gcHVmZlxuICogQHBhcmFtICB7c3RyaW5nfSBkZWZhdWx0S2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5QQi5DcnlwdG8udmVyaWZ5UHVmZlNpZyA9IGZ1bmN0aW9uKHB1ZmYsIGRlZmF1bHRLZXkpIHtcbiAgICB2YXIgcHVmZlN0cmluZyA9IFBCLkNyeXB0by5wdWZmVG9TaWdsZXNzU3RyaW5nKHB1ZmYpO1xuICAgIHJldHVybiBQQi5DcnlwdG8udmVyaWZ5TWVzc2FnZShwdWZmU3RyaW5nLCBwdWZmLnNpZywgZGVmYXVsdEtleSk7XG59XG5cbi8qKlxuICogYWNjZXB0IGEgYmFzZSA1OCBzaWcsIGEgbWVzc2FnZSAobXVzdCBiZSBhIHN0cmluZykgYW5kIGEgYmFzZSA1OCBwdWJsaWMga2V5LiByZXR1cm5zIHRydWUgaWYgdGhleSBtYXRjaCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSAge3N0cmluZ30gc2lnXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHB1YmxpY0tleVdJRlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuUEIuQ3J5cHRvLnZlcmlmeU1lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlLCBzaWcsIHB1YmxpY0tleVdJRikge1xuICAgIC8vLy8gYWNjZXB0IGEgYmFzZSA1OCBzaWcsIGEgbWVzc2FnZSAobXVzdCBiZSBhIHN0cmluZykgYW5kIGEgYmFzZSA1OCBwdWJsaWMga2V5LiByZXR1cm5zIHRydWUgaWYgdGhleSBtYXRjaCwgZmFsc2Ugb3RoZXJ3aXNlXG4gIFxuICAgIHRyeSB7XG4gICAgICAgIHZhciBwdWJrZXkgPSBQQi5DcnlwdG8ud2lmVG9QdWJLZXkocHVibGljS2V5V0lGKVxuICAgICAgICBcbiAgICAgICAgdmFyIHNpZ0J5dGVzID0gQml0Y29pbi5iYXNlNTguZGVjb2RlKHNpZykudG9KU09OKClcbiAgICAgICAgc2lnQnl0ZXMgPSBzaWdCeXRlcy5kYXRhIHx8IHNpZ0J5dGVzXG4gICAgICAgIFxuICAgICAgICB2YXIgbWVzc2FnZUhhc2ggPSBQQi5DcnlwdG8uY3JlYXRlTWVzc2FnZUhhc2gobWVzc2FnZSlcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBwdWJrZXkudmVyaWZ5KG1lc3NhZ2VIYXNoLCBzaWdCeXRlcylcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICByZXR1cm4gUEIub25FcnJvcignSW52YWxpZCBrZXkgb3Igc2lnOiBjb3VsZCBub3QgdmVyaWZ5IG1lc3NhZ2UnLCBbbWVzc2FnZUhhc2gsIHNpZywgcHVibGljS2V5V0lGLCBlcnJdKVxuICAgIH1cbn1cblxuLyoqXG4gKiB0byBjcmVhdGUgbWVzc2FnZSBoYXNoXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuUEIuQ3J5cHRvLmNyZWF0ZU1lc3NhZ2VIYXNoID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHJldHVybiBCaXRjb2luLkNyeXB0by5TSEEyNTYobWVzc2FnZSkudG9TdHJpbmcoKVxufVxuXG4vKipcbiAqIGNyeXB0IHdpZiB0byBwcml2YXRlIGtleVxuICogQHBhcmFtICB7c3RyaW5nfSBwcml2YXRlS2V5V0lGXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5QQi5DcnlwdG8ud2lmVG9QcmlLZXkgPSBmdW5jdGlvbihwcml2YXRlS2V5V0lGKSB7XG4gICAgaWYoIXByaXZhdGVLZXlXSUYpXG4gICAgICAgIHJldHVybiBQQi5vbkVycm9yKCdUaGF0IHByaXZhdGUga2V5IHdpZiBjb250YWlucyBubyBkYXRhJylcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgQml0Y29pbi5FQ0tleShwcml2YXRlS2V5V0lGLCB0cnVlKVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIHJldHVybiBQQi5vbkVycm9yKCdJbnZhbGlkIHByaXZhdGUga2V5OiBhcmUgeW91IHN1cmUgaXQgaXMgcHJvcGVybHkgV0lGZmVkPycsIFtwcml2YXRlS2V5V0lGLCBlcnJdKVxuICAgIH1cbn1cblxuLyoqXG4gKiBjcnlwdCB3aWYgdG8gcHVibGljIHRyeVxuICogQHBhcmFtICB7c3RyaW5nfSBwdWJsaWNLZXlXSUZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblBCLkNyeXB0by53aWZUb1B1YktleSA9IGZ1bmN0aW9uKHB1YmxpY0tleVdJRikge1xuICAgIGlmKCFwdWJsaWNLZXlXSUYpXG4gICAgICAgIHJldHVybiBQQi5vbkVycm9yKCdUaGF0IHB1YmxpYyBrZXkgd2lmIGNvbnRhaW5zIG5vIGRhdGEnKVxuXG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHB1YmtleUJ5dGVzID0gQml0Y29pbi5iYXNlNThjaGVjay5kZWNvZGUocHVibGljS2V5V0lGKS5wYXlsb2FkLnRvSlNPTigpXG4gICAgICAgIHB1YmtleUJ5dGVzID0gcHVia2V5Qnl0ZXMuZGF0YSB8fCBwdWJrZXlCeXRlc1xuICAgICAgICByZXR1cm4gbmV3IEJpdGNvaW4uRUNQdWJLZXkocHVia2V5Qnl0ZXMsIHRydWUpXG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ0ludmFsaWQgcHVibGljIGtleTogYXJlIHlvdSBzdXJlIGl0IGlzIHByb3Blcmx5IFdJRmZlZD8nLCBbcHVibGljS2V5V0lGLCBlcnJdKVxuICAgIH1cbn1cblxuLyoqXG4gKiBjcnlwdCBwdWZmIHRvIHN0cmluZyB3aXRob3V0IHNpZ1xuICogQHBhcmFtICB7b2JqZWN0fSBwdWZmXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblBCLkNyeXB0by5wdWZmVG9TaWdsZXNzU3RyaW5nID0gZnVuY3Rpb24ocHVmZikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwdWZmLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7aWYoa2V5ID09ICdzaWcnKSByZXR1cm4gdW5kZWZpbmVkOyByZXR1cm4gdmFsdWV9KVxufVxuXG5cblBCLkNyeXB0by5wYXNzcGhyYXNlVG9Qcml2YXRlS2V5V2lmID0gZnVuY3Rpb24ocGFzc3BocmFzZSkge1xuICAgIHZhciBoYXNoU3RyID0gQml0Y29pbi5DcnlwdG8uU0hBMjU2KHBhc3NwaHJhc2UpLnRvU3RyaW5nKClcbiAgICB2YXIgaGFzaCA9IEJpdGNvaW4uY29udmVydC5oZXhUb0J5dGVzKGhhc2hTdHIpXG4gICAgcmV0dXJuIEJpdGNvaW4uRUNLZXkoaGFzaCkudG9XaWYoKVxufVxuXG5cbi8qKlxuICogdG8gZW5jcnlwdCB3aXRoIEFFU1xuICogQHBhcmFtICB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5QQi5DcnlwdG8uZW5jcnlwdFdpdGhBRVMgPSBmdW5jdGlvbihtZXNzYWdlLCBrZXkpIHtcbiAgICB2YXIgZW5jID0gQml0Y29pbi5DcnlwdG8uQUVTLmVuY3J5cHQobWVzc2FnZSwga2V5KVxuICAgIHJldHVybiBCaXRjb2luLkNyeXB0by5mb3JtYXQuT3BlblNTTC5zdHJpbmdpZnkoZW5jKVxufVxuXG4vKipcbiAqIHRvIGRlY3J5cHQgd2l0aCBBRVNcbiAqIEBwYXJhbSAge3N0cmluZ30gbWVzc2FnZVxuICogQHBhcmFtICB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuUEIuQ3J5cHRvLmRlY3J5cHRXaXRoQUVTID0gZnVuY3Rpb24oZW5jLCBrZXkpIHtcbiAgICBpZigha2V5IHx8ICFlbmMpIHJldHVybiBmYWxzZVxuICAgIHZhciBtZXNzYWdlID0gQml0Y29pbi5DcnlwdG8uZm9ybWF0Lk9wZW5TU0wucGFyc2UoZW5jKVxuICAgIHZhciB3b3JkcyA9IEJpdGNvaW4uQ3J5cHRvLkFFUy5kZWNyeXB0KG1lc3NhZ2UsIGtleSlcbiAgICB2YXIgYnl0ZXMgPSBCaXRjb2luLmNvbnZlcnQud29yZHNUb0J5dGVzKHdvcmRzLndvcmRzKSBcbiAgICAvLyB2YXIgdWdseVJlZ2V4ID0gL1tcXHUwMDAyXFx1MDAwNFxcdTAwMDdcXHUwMDBlXSskL2dcbiAgICB2YXIgdWdseVJlZ2V4ID0gL1tcXHUwMDAwLVxcdTAwMTBdKyQvZyAvLyBUT0RPOiBjb250YWluIEFFUyBwYWRkaW5nXG4gICAgcmV0dXJuIGJ5dGVzLm1hcChmdW5jdGlvbih4KSB7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoeCl9KS5qb2luKCcnKS5yZXBsYWNlKHVnbHlSZWdleCwgJycpXG59XG5cbi8qKlxuICogR2V0IHRoZSBzaGFyZWQgc2VjcmV0IG9mIHR3byB1c2Vyc1xuICogQHBhcmFtICB7c3RyaW5nfSB5b3VyUHVibGljV2lmXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG15UHJpdmF0ZVdpZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5QQi5DcnlwdG8uZ2V0T3VyU2hhcmVkU2VjcmV0ID0gZnVuY3Rpb24oeW91clB1YmxpY1dpZiwgbXlQcml2YXRlV2lmKSB7XG4gICAgLy8gVE9ETzogdW5pdCB0ZXN0aW5nIGZvciBFQ0RIIG1hdGhzXG4gICAgdmFyIHB1YmtleSA9IFBCLkNyeXB0by53aWZUb1B1YktleSh5b3VyUHVibGljV2lmKVxuICAgIHZhciBwcmlrZXkgPSBQQi5DcnlwdG8ud2lmVG9QcmlLZXkobXlQcml2YXRlV2lmKVxuICAgIGlmKCFwdWJrZXkgfHwgIXByaWtleSkgcmV0dXJuIGZhbHNlICBcbiAgICB2YXIgc2VjcmV0ID0gcHVia2V5Lm11bHRpcGx5KHByaWtleSkudG9XaWYoKVxuICAgIHZhciBrZXkgPSBCaXRjb2luLkNyeXB0by5TSEEyNTYoc2VjcmV0KS50b1N0cmluZygpXG4gICAgXG4gICAgcmV0dXJuIGtleVxufVxuXG4vKipcbiAqIEVuY29kZSBwcml2YXRlIG1lc3NhZ2VcbiAqIEBwYXJhbSAge3N0cmluZ30gcGxhaW50ZXh0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHlvdXJQdWJsaWNXaWZcbiAqIEBwYXJhbSAge3N0cmluZ30gbXlQcml2YXRlV2lmXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblBCLkNyeXB0by5lbmNyeXB0UHJpdmF0ZU1lc3NhZ2UgPSBmdW5jdGlvbihwbGFpbnRleHQsIHlvdXJQdWJsaWNXaWYsIG15UHJpdmF0ZVdpZikge1xuICAgIHZhciBrZXkgPSBQQi5DcnlwdG8uZ2V0T3VyU2hhcmVkU2VjcmV0KHlvdXJQdWJsaWNXaWYsIG15UHJpdmF0ZVdpZilcbiAgICBpZigha2V5KSByZXR1cm4gZmFsc2VcbiAgICB2YXIgY2lwaGVydGV4dCA9IFBCLkNyeXB0by5lbmNyeXB0V2l0aEFFUyhwbGFpbnRleHQsIGtleSlcbiAgICByZXR1cm4gY2lwaGVydGV4dFxufVxuXG4vKipcbiAqIHRvIGRlY29kZSBwcml2YXRlIG1lc3NhZ2VcbiAqIEBwYXJhbSAge3N0cmluZ30gcGxhaW50ZXh0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHlvdXJQdWJsaWNXaWZcbiAqIEBwYXJhbSAge3N0cmluZ30gbXlQcml2YXRlV2lmXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblBCLkNyeXB0by5kZWNyeXB0UHJpdmF0ZU1lc3NhZ2UgPSBmdW5jdGlvbihjaXBoZXJ0ZXh0LCB5b3VyUHVibGljV2lmLCBteVByaXZhdGVXaWYpIHtcbiAgICB2YXIga2V5ID0gUEIuQ3J5cHRvLmdldE91clNoYXJlZFNlY3JldCh5b3VyUHVibGljV2lmLCBteVByaXZhdGVXaWYpXG4gICAgaWYoIWtleSB8fCAhY2lwaGVydGV4dCkgcmV0dXJuIGZhbHNlXG4gICAgdmFyIHBsYWludGV4dCA9IFBCLkNyeXB0by5kZWNyeXB0V2l0aEFFUyhjaXBoZXJ0ZXh0LCBrZXkpXG4gICAgcmV0dXJuIHBsYWludGV4dCAvLyAucmVwbGFjZSgvXFxuKyQvZywgJycpXG59XG5cblxuUEIuQ3J5cHRvLnJhbmRvbSA9IGZ1bmN0aW9uKCkgeyAvLyBqdXN0IGxpa2UgTWF0aC5yYW5kb20sIGJ1dCBiZXR0ZXJcbiAgICAvLyB2aWEgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzY5NDYyNi9nZW5lcmF0aW5nLXJhbmRvbS1udW1iZXJzLTAtdG8tMS13aXRoLWNyeXB0by1nZW5lcmF0ZXZhbHVlc1xuXG4gICAgdmFyIGxpc3QgPSBQQi5DcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKDIsIDMyKVxuXG4gICAgLy8ga2VlcCBhbGwgMzIgYml0cyBvZiB0aGUgdGhlIGZpcnN0LCB0b3AgMjAgb2YgdGhlIHNlY29uZCBmb3IgNTIgcmFuZG9tIGJpdHNcbiAgICB2YXIgbWFudGlzc2EgPSAobGlzdFswXSAqIE1hdGgucG93KDIsMjApKSArIChsaXN0WzFdID4+IDEyKVxuXG4gICAgLy8gc2hpZnQgYWxsIDUyIGJpdHMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkZWNpbWFsIHBvaW50XG4gICAgdmFyIHJlc3VsdCA9IG1hbnRpc3NhICogTWF0aC5wb3coMiwtNTIpXG4gICAgXG4gICAgcmV0dXJuIHJlc3VsdFxuICAgIFxuICAgIC8vIHZhciBsb2cyID0gTWF0aC5sb2cobWF4KSAvIE1hdGguTE4yXG4gICAgLy8gdmFyIHNpemUgPSBNYXRoLmNlaWwobG9nMikgKyAxIC8vIE5PVEU6IHRoaXMgaXMgYWJvdXQgOCB0aW1lcyBoaWdoZXIgdGhhbiBuZWNlc3Nhcnlcbn1cblxuUEIuQ3J5cHRvLmdldFJhbmRvbUludGVnZXIgPSBmdW5jdGlvbihtYXgsIG1pbikgeyAvLyBOT1RFOiBtaW4gaXMgaW5jbHVzaXZlLCBtYXggaXMgZXhjbHVzaXZlXG4gICAgLy8gVE9ETzogZXJyb3IgaWYgbWF4IGFuZCBtaW4gYXJlIG5vdCBwcm9wZXIgKG5vbi1OYU4pIG51bWJlcnNcbiAgICBtaW4gPSBNYXRoLmZsb29yKG1pbiB8fCAwKVxuICAgIG1heCA9IE1hdGguZmxvb3IobWF4IHx8IDB4N2ZmZmZmZmYpIC8vIDB4N2ZmZmZmZmYgPT0gTWF0aC5wb3coMiwgMzEpIC0gMSAvLyB0aGUgbGFyZ2VzdCBiaXRvcCBzYWZlIGludFxuICAgIHZhciByYW5nZSA9IG1heCAtIG1pblxuICAgIHZhciByYW5kRmxvYXQgPSBQQi5DcnlwdG8ucmFuZG9tKClcbiAgICByZXR1cm4gTWF0aC5mbG9vcihyYW5kRmxvYXQqcmFuZ2UgKyBtaW4pXG59XG5cblBCLkNyeXB0by5nZXRSYW5kb21JdGVtID0gZnVuY3Rpb24obGlzdCkge1xuICAgIC8vIFRPRE86IGVycm9yIGlmIGxpc3QgaXMgbm90IGFuIGFycmF5IG9yIHN0cmluZ1xuICAgIHZhciBpbmRleCA9IFBCLkNyeXB0by5nZXRSYW5kb21JbnRlZ2VyKGxpc3QubGVuZ3RoKVxuICAgIHJldHVybiBsaXN0W2luZGV4XVxufVxuXG4vKipcbiAqIEdldCBhIG5ldyBBRVMga2V5XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGxlbiBMZW5ndGggaW4gYnl0ZXMgKGRlZmF1bHRzIHRvIDI1NiBiaXRzKVxuICogQHJldHVybiB7c3RyaW5nfSBBRVMga2V5XG4gKi9cblBCLkNyeXB0by5nZXRSYW5kb21LZXkgPSBmdW5jdGlvbihsZW4pIHtcbiAgICBsZW4gPSBsZW4gfHwgMjU2LzggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFFUyBrZXkgc2l6ZSBpcyAyNTYgYml0c1xuICAgIHZhciBieXRlcyA9IFBCLkNyeXB0by5nZXRSYW5kb21WYWx1ZXMobGVuLCA4KVxuICAgIC8vIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgLy8gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcylcbiAgICByZXR1cm4gQml0Y29pbi5jb252ZXJ0LmJ5dGVzVG9CYXNlNjQoYnl0ZXMpXG59XG5cblBCLkNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPSBmdW5jdGlvbihudW1iZXIsIHNpemUpIHtcbiAgICBpZih3aW5kb3cuY3J5cHRvICYmIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgIHZhciBieXRlc1xuICAgICAgICBpZihzaXplID09IDMyKVxuICAgICAgICAgICAgYnl0ZXMgPSBuZXcgVWludDMyQXJyYXkoc2l6ZSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgIFxuICAgICAgICByZXR1cm4gd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpXG4gICAgfVxuXG4gICAgcmV0dXJuIFBCLkNyeXB0by5nZXRSYW5kb21WYWx1ZXNTaGltKG51bWJlciwgc2l6ZSlcbn1cblxuUEIuQ3J5cHRvLmdldFJhbmRvbVZhbHVlc1NoaW0gPSBmdW5jdGlvbihudW1iZXIsIHNpemUpIHtcbiAgICAvLyB2aWEgaHR0cHM6Ly9naXRodWIuY29tL2V2YW52b3NiZXJnL2NyeXB0by1qcy9pc3N1ZXMvN1xuICAgIC8vIGZhbGxiYWNrIGZvciBvbGQgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGNyeXB0by5nZXRSYW5kb21WYWx1ZXNcbiAgICAvLyBiZXR0ZXIgdGhhbiBwbGFpbiBNYXRoLnJhbmRvbSgpLCB3b3JzZSB0aGFuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoKVxuICAgIHZhciB3b3JkcyA9IFtdO1xuXG4gICAgdmFyIHIgPSAoZnVuY3Rpb24gKG1fdykge1xuICAgICAgICB2YXIgbV93ID0gbV93O1xuICAgICAgICB2YXIgbV96ID0gMHgzYWRlNjhiMTtcbiAgICAgICAgdmFyIG1hc2sgPSAweGZmZmZmZmZmO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtX3ogPSAoMHg5MDY5ICogKG1feiAmIDB4RkZGRikgKyAobV96ID4+IDB4MTApKSAmIG1hc2s7XG4gICAgICAgICAgICBtX3cgPSAoMHg0NjUwICogKG1fdyAmIDB4RkZGRikgKyAobV93ID4+IDB4MTApKSAmIG1hc2s7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gKChtX3ogPDwgMHgxMCkgKyBtX3cpICYgbWFzaztcbiAgICAgICAgICAgIHJlc3VsdCAvPSAweDEwMDAwMDAwMDtcbiAgICAgICAgICAgIHJlc3VsdCArPSAwLjU7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKE1hdGgucmFuZG9tKCkgPiAuNSA/IDEgOiAtMSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCByY2FjaGU7IGkgPCBudW1iZXI7IGkgKz0gNCkge1xuICAgICAgICB2YXIgX3IgPSByKChyY2FjaGUgfHwgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwMDAwMCk7XG5cbiAgICAgICAgcmNhY2hlID0gX3IoKSAqIDB4M2FkZTY3Yjc7XG5cbiAgICAgICAgaWYoc2l6ZSA9PSAzMikge1xuICAgICAgICAgICAgd29yZHMucHVzaChNYXRoLmFicyggKF9yKCkgKiAweDEwMDAwMDAwMCkgfCAwICkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSB3YW50IGJ5dGVzIGluc3RlYWQgb2YgMzItYml0IGNodW5rc1xuICAgICAgICAgICAgdmFyIGludDMyID0gKF9yKCkgKiAweDEwMDAwMDAwMCkgfCAwO1xuICAgICAgICAgICAgd29yZHMucHVzaChNYXRoLmFicyhpbnQzMiAmIDB4RkYwMDAwMDApID4+IDI0KTtcbiAgICAgICAgICAgIHdvcmRzLnB1c2goTWF0aC5hYnMoaW50MzIgJiAweDAwRkYwMDAwKSA+PiAxNik7XG4gICAgICAgICAgICB3b3Jkcy5wdXNoKE1hdGguYWJzKGludDMyICYgMHgwMDAwRkYwMCkgPj4gOCk7XG4gICAgICAgICAgICB3b3Jkcy5wdXNoKE1hdGguYWJzKGludDMyICYgMHgwMDAwMDBGRikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmRzO1xufVxuXG5cbi8qKlxuICogdG8gY3JlYXRlIGtleSBwYWlyc1xuICogQHBhcmFtICB7c3RyaW5nfSBwdWZma2V5XG4gKiBAcGFyYW0gIHtzdHJpbmd9IG15UHJpdmF0ZVdpZlxuICogQHBhcmFtICB7b2JqZWN0fSB1c2VyUmVjb3Jkc1xuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5QQi5DcnlwdG8uY3JlYXRlS2V5UGFpcnMgPSBmdW5jdGlvbihwdWZma2V5LCBteVByaXZhdGVXaWYsIHVzZXJSZWNvcmRzKSB7XG4gICAgaWYoIUFycmF5LmlzQXJyYXkodXNlclJlY29yZHMpKVxuICAgICAgICByZXR1cm4gUEIudGhyb3dFcnJvcignSW52YWxpZCB1c2VyUmVjb3JkcycpXG4gICAgXG4gICAgcmV0dXJuIHVzZXJSZWNvcmRzLnJlZHVjZShmdW5jdGlvbihhY2MsIHVzZXJSZWNvcmQpIHtcbiAgICAgICAgdmFyIHZlcnNpb25lZFVzZXJuYW1lID0gUEIuVXNlcnMudXNlclJlY29yZFRvVmVyc2lvbmVkVXNlcm5hbWUodXNlclJlY29yZClcbiAgICAgICAgYWNjW3ZlcnNpb25lZFVzZXJuYW1lXSA9IFBCLkNyeXB0by5lbmNyeXB0UHJpdmF0ZU1lc3NhZ2UocHVmZmtleSwgdXNlclJlY29yZC5kZWZhdWx0S2V5LCBteVByaXZhdGVXaWYpXG4gICAgICAgIHJldHVybiBhY2NcbiAgICB9LCB7fSlcbn1cblxuXG4vLyBQQi5DcnlwdG8udmVyaWZ5QmxvY2sgPSBmdW5jdGlvbihibG9jaywgcHVibGljS2V5QmFzZTU4KSB7XG4vLyAgICAgcmV0dXJuIFBCLkNyeXB0by52ZXJpZnlNZXNzYWdlKGJsb2NrLmJsb2NrUGF5bG9hZCwgYmxvY2suYmxvY2tTaWcucmVwbGFjZSgvXFwqL2csIFwiXCIpLCBwdWJsaWNLZXlCYXNlNTgpO1xuLy8gfVxuXG4vLyBQQi5DcnlwdG8uc2lnbkJsb2NrID0gZnVuY3Rpb24oYmxvY2tQYXlsb2FkLCBwcml2YXRlS2V5V0lGKSB7XG4vLyAgICAgcmV0dXJuIFBCLkNyeXB0by5zaWduUGF5bG9hZChibG9ja1BheWxvYWQsIHByaXZhdGVLZXlXSUYpO1xuLy8gfVxuIiwiLypcblxuICAgIFBlcnNpc3RlbmNlIGxheWVyIGZvciB0aGUgRXZlcnlCaXQgcGxhdGZvcm0uXG5cbiAgICBJdCdzIGxpa2UgYSBuZXR3b3JrIG9uIHlvdXIgaGFyZCBkcml2ZS4uLiB3aGljaCBtZWFucyB0aGlzIGNvdWxkIGJlIHBhcnQgb2YgUEIuTmV0LlxuXG4gICAgQ29weXJpZ2h0IDIwMTQgRXZlcnlCaXQuIFNlZSBSRUFETUUgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbiAqL1xuXG5QQi5QZXJzaXN0ID0ge307XG5QQi5QZXJzaXN0LnRvZG8gPSB7fVxuUEIuUGVyc2lzdC50b2RvZmxhZyA9IGZhbHNlXG5cbi8qKlxuICogdG8gc2F2ZSBrZXkvdmFsdWVcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlXG4gKi9cblBCLlBlcnNpc3Quc2F2ZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBpZih2YWx1ZSA9PSBudWxsKVxuICAgICAgICB2YWx1ZSA9IGZhbHNlXG4gICAgUEIuUGVyc2lzdC50b2RvW2tleV0gPSB2YWx1ZVxuICAgIGlmKCFQQi5QZXJzaXN0LnRvZG9mbGFnKSB7XG4gICAgICAgIG9uY2VJbkF3aGlsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIFBCLlBlcnNpc3QudG9kbykge1xuICAgICAgICAgICAgICAgIHZhciByZWFsa2V5ID0gJ1BVRkY6OicgKyBrZXk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlcGVuZCBQVUZGOjogc28gd2UncmUgZ29vZCBuZWlnaGJvcnNcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBQQi5QZXJzaXN0LnRvZG9ba2V5XTtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGNhc2Ugd2UncmUgcGFzc2VkIGEgdGh1bmtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgICAgICAgICAgICAgIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHJlYWxrZXksIHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQQi5QZXJzaXN0LnRvZG8gPSB7fTtcbiAgICAgICAgICAgIFBCLlBlcnNpc3QudG9kb2ZsYWcgPSBmYWxzZTtcbiAgICAgICAgfSwgMTAwKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgYXQgbW9zdCBldmVyeSAxMDBtc1xuICAgIH1cbiAgICBQQi5QZXJzaXN0LnRvZG9mbGFnID0gdHJ1ZVxufVxuXG4vKipcbiAqIGdldCB0aGUgcGFyc2VkIEpTT04gaW5mbyBmcm9tIHRoZSBnaXZlbiBrZXlcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHthbnl0aGluZ31cbiAqL1xuUEIuUGVyc2lzdC5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAvLyBUT0RPOiByZXR1cm4gZW1wdHkgc3RyaW5nIGluc3RlYWQgb2YgZmFsc2VcblxuICAgIHZhciByZWFsa2V5ID0gJ1BVRkY6OicgKyBrZXk7XG4gICAgdmFyIHN0ciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHJlYWxrZXkpO1xuICAgIGlmKCFzdHIpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gUEIucGFyc2VKU09OKHN0cik7XG59XG5cbi8qKlxuICogdG8gcmVtb3ZlIHRoZSBpdGVtIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4ga2V5XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICovXG5QQi5QZXJzaXN0LnJlbW92ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciByZWFsa2V5ID0gJ1BVRkY6OicgKyBrZXk7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0ocmVhbGtleSk7XG59XG4iLCIvKlxuICAgIENvbXByZWhlbnNpdmUgKGluIHByb2dyZXNzISksIGNhbm9uaWNhbCBzZXQgb2YgZnVuY3Rpb25zIGRlZmluaW5nIGFuZCB2YWxpZGF0aW5nIGEgcHVmZi5cblxuICAgIEFsbCBvZiB0aGVzZSBhcmUgU1RSSUNUTFkgRk9STUFMIHZhbGlkYXRpb25zOiB0aGV5IGRvbid0IGRlcGVuZCBvbiB0aGUgc3RhdGUgb2YgdGhlIHVuaXZlcnNlLlxuXG4gICAgQ29weXJpZ2h0IDIwMTQgRXZlcnlCaXQuIFNlZSBSRUFETUUgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbiAqL1xuXG5cblBCLlNwZWMgPSB7fVxuXG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIHVzZXJuYW1lXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVzZXJuYW1lXG4gKi9cblBCLlNwZWMuaXNWYWxpZFVzZXJuYW1lID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAvKlxuICAgIFJVTEVTOlxuICAgIC0gTWluaW11bSBsZW5ndGggaXMgMVxuICAgIC0gTWF4aW11bSBsZW5ndGggb2YgZnVsbCB1c2VybmFtZSAoaW5jbHVkaW5nIHN1YnVzZXJzIGFuZCAuKSBpcyAyNTUgY2hhcmFjdGVyc1xuICAgIC0gT25seSBhbHBoYW51bWVyaWNcbiAgICAtIE9ubHkgbG93ZXJjYXNlXG4gICAgLSBDYW5ub3QgYmVnaW4gb3IgZW5kIHdpdGggYSAuXG4gICAgICovXG5cbiAgICBQQi5TcGVjLmlzVmFsaWRVc2VybmFtZS5ydWxlc1N0YXRlbWVudCA9ICdVc2VybmFtZXMgY2FuIG9ubHkgY29udGFpbiBsb3dlcmNhc2UgbGV0dGVycywgbnVtYmVycywgYW5kIHBlcmlvZHMuIFRoZXkgY2Fubm90ICcgK1xuICAgICAgICAnYmUgbG9uZ2VyIHRoYW4gMjU1IGNoYXJhY3RlcnMsIG9yIGJlZ2luIG9yIGVuZCB3aXRoIGEgcGVyaW9kLidcblxuICAgIGlmKCF1c2VybmFtZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICBpZih1c2VybmFtZS5sZW5ndGggPiAyNTUpXG4gICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgaWYoIXVzZXJuYW1lLm1hdGNoKC9eW2EtejAtOS5dKyQvKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICBpZih1c2VybmFtZS5zbGljZSgwLCAxKSA9PSAnLicpXG4gICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgaWYodXNlcm5hbWUuc2xpY2UoLTEpID09ICcuJylcbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICByZXR1cm4gdHJ1ZVxufVxuXG5cbi8qKlxuICogRG9lcyBldmVyeXRoaW5nIHBvc3NpYmxlIHRvIG1ha2UgYSB1c2VybmFtZSB2YWxpZFxuICogTm90ZTogVGhpcyBtYXkgaGF2ZSB1bmludGVuZGVkIGNvbnNlcXVlbmNlcyBmb3IgdGhlIHVzZXJcbiAqL1xuUEIuU3BlYy5zYW5pdGl6ZVVzZXJuYW1lID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAvKlxuICAgICBUUkFOU0ZPUk1BVElPTlM6XG4gICAgIC0gUmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlXG4gICAgIC0gQ29udmVydCB0byBsb3dlcmNhc2VcbiAgICAgLSBSZW1vdmUgYWxsIGlsbGVnYWwgY2hhcmFjdGVycywgaW5jbHVkaW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nIC5cbiAgICAgKi9cbiAgICB1c2VybmFtZSA9IHVzZXJuYW1lLnRyaW0oKVxuXG4gICAgdXNlcm5hbWUgPSB1c2VybmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICBpZih1c2VybmFtZS5zbGljZSgwLCAxKSA9PSAnLicpXG4gICAgICAgIHVzZXJuYW1lID0gdXNlcm5hbWUuc2xpY2UoMSlcblxuICAgIGlmKHVzZXJuYW1lLnNsaWNlKC0xKSA9PSAnLicpXG4gICAgICAgIHVzZXJuYW1lID0gdXNlcm5hbWUuc2xpY2UoMCwtMSlcblxuICAgIHVzZXJuYW1lID0gdXNlcm5hbWUucmVwbGFjZSgvW15hLXowLTkuXSsvZywgJycpXG5cbiAgICByZXR1cm4gdXNlcm5hbWVcbn1cblxuXG4vKipcbiAqIGNoZWNrIGlmIGl0IGlzIGEgdmFsaWQgcHVibGljIGtleVxuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0tleVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblBCLlNwZWMuaXNWYWxpZFB1YmxpY0tleSA9IGZ1bmN0aW9uKHB1YmxpY0tleSkge1xuICAgIC8vIFRPRE86IGRvIFwiY2hlY2tzdW1cIiB2YWxpZGF0aW9uXG5cbiAgICBpZighaXNzZXQocHVibGljS2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG59XG5cbi8qKlxuICogY2hlY2sgaWYgaXQgaXMgYSB2YWxpZCBwcml2YXRlIGtleVxuICogQHBhcmFtIHtzdHJpbmd9IHByaXZhdGVLZXlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5QQi5TcGVjLmlzVmFsaWRQcml2YXRlS2V5ID0gZnVuY3Rpb24ocHJpdmF0ZUtleSkge1xuICAgIC8vIFRPRE86IFZhbGlkYXRlIGJ5IHRlc3RpbmcgaWYgY2FuIGJlIGNvbnZlcnRlZCB0byBwdWJsaWMga2V5XG5cbiAgICBpZighaXNzZXQocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGlzIGEgdmFsaWQgY2FwYVxuICogQHBhcmFtIGNhcGFcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5QQi5TcGVjLmlzVmFsaWRDYXBhID0gZnVuY3Rpb24oY2FwYSkge1xuXG4gICAgLypcbiAgICAgUlVMRVM6XG4gICAgIC0gTXVzdCBiZSBhIG5hdHVyYWwgbnVtYmVyICgxIG9yIGdyZWF0ZXIpXG4gICAgICovXG5cbiAgICBQQi5TcGVjLmlzVmFsaWRDYXBhLnJ1bGVzU3RhdGVtZW50ID0gJ2NhcGEgbXVzdCBiZSBhIG5hdHVyYWwgbnVtYmVyLic7XG5cblxuICAgIGNhcGEgPSBjYXBhLnRvU3RyaW5nKCk7IC8vIENvbnZlcnQgdG8gc3RyaW5nXG4gICAgdmFyIG4xID0gTWF0aC5hYnMobik7XG4gICAgdmFyIG4yID0gcGFyc2VJbnQobiwgMTApO1xuXG4gICAgaWYobjIgPCAxKVxuICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgIHJldHVybiAhaXNOYU4objEpICYmIG4yID09PSBuMSAmJiBuMS50b1N0cmluZygpID09PSBuO1xufSIsIi8qIFxuICAgICAgICAgICAgICAgICAgIF9fX19fICBfX19fXyAgX19fX18gICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBfX19fX18gIF9fIF9fXy8gX19fX1xcLyBfX19fXFwvIF9fX19cXF9fX19fX19fX19fIF9fIF9fICBfX19fXyAgXG4gICAgXFxfX19fIFxcfCAgfCAgXFwgICBfX1xcXFwgICBfX1xcXFwgICBfX1xcLyAgXyBcXF8gIF9fIFxcICB8ICBcXC8gICAgIFxcIFxuICAgIHwgIHxfPiA+ICB8ICAvfCAgfCAgIHwgIHwgICB8ICB8ICggIDxfPiApICB8IFxcLyAgfCAgLyAgWSBZICBcXFxuICAgIHwgICBfXy98X19fXy8gfF9ffCAgIHxfX3wgICB8X198ICBcXF9fX18vfF9ffCAgfF9fX18vfF9ffF98ICAvXG4gICAgfF9ffCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcLyBcbiAgXG4gIFxuICBBIFB1ZmZiYWxsIG1vZHVsZSBmb3IgbWFuYWdpbmcgZm9ydW0tc3R5bGUgcHVmZnMuIFdyYXBzIHRoZSBjb3JlIFB1ZmZiYWxsIEFQSSBpbiBhIGZsdWZmeSBsYXllciBvZiBzeW50YWN0aWMgc3B1biBzdWdhci5cblxuICBVc2FnZSBleGFtcGxlOlxuICBQQi5NLkZvcnVtLmluaXQoKVxuICAuLi5cblxuKi9cblxuUEIuTS5Gb3J1bSA9IHt9O1xuXG5QQi5NLkZvcnVtLmNvbnRlbnRUeXBlcyA9IHt9XG5cblxuLyoqXG4gKiBCb290c3RyYXAgdGhlIGZvcnVtIG1vZHVsZVxuICovXG5QQi5NLkZvcnVtLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICBQQi5hZGRSZWxhdGlvbnNoaXBIYW5kbGVyKFBCLk0uRm9ydW0uYWRkRmFtaWxpYWxFZGdlcykgICAgICAgICAgICAgIC8vIG1hbmFnZXMgcGFyZW50LWNoaWxkIHJlbGF0aW9uc2hpcHNcbiAgICBQQi5hZGRCZWZvcmVTd2l0Y2hJZGVudGl0eUhhbmRsZXIoUEIuTS5Gb3J1bS5jbGVhclB1ZmZDb250ZW50U3Rhc2gpICAgIC8vIGNsZWFyIHByaXZhdGUgY2FjaGVzIFxuICAgIFBCLmFkZFBheWxvYWRNb2RpZmllckhhbmRsZXIoUEIuTS5Gb3J1bS5hZGRUaW1lc3RhbXApICAgICAgICAgICAgICAgLy8gYWRkIHRpbWVzdGFtcCB0byBhbGwgbmV3IHB1ZmZzXG59XG5cblxuLyoqXG4gKiBJbmplY3QgYSB0aW1lc3RhbXAgaW50byB0aGUgcGF5bG9hZFxuICogdGhlIFwidGltZVwiIGZpZWxkIGlzIG9wdGlvbmFsIGZvciBwdWZmcywgYnV0IG1hbmRhdG9yeSBmb3IgXCJmb3J1bSBzdHlsZVwiIHB1ZmZzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAqIEByZXR1cm5zIHtPYmplY3R8e319XG4gKi9cblBCLk0uRm9ydW0uYWRkVGltZXN0YW1wID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuICAgIHBheWxvYWQgPSBwYXlsb2FkIHx8IHt9XG4gICAgcGF5bG9hZC50aW1lID0gRGF0ZS5ub3coKVxuICAgIHJldHVybiBwYXlsb2FkXG59XG5cblxuLyoqXG4gKiBGaWx0ZXIgcHVmZnMgYnkgcHJvcCBmaWx0ZXJzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbHRlcnNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblBCLk0uRm9ydW0uZmlsdGVyQnlGaWx0ZXJzID0gZnVuY3Rpb24oZmlsdGVycykge1xuXG4gICAgaWYoIWZpbHRlcnMpIHJldHVybiBmdW5jdGlvbigpIHtyZXR1cm4gdHJ1ZX1cbiAgICBcbiAgICAvLy8vIGdldCBhIGZpbHRlcmluZyBmdW5jdGlvblxuICAgIHJldHVybiBmdW5jdGlvbihzaGVsbCkge1xuXG4gICAgICAgIC8vIFJPVVRFU1xuICAgICAgICBpZiAoZmlsdGVycy5yb3V0ZXMgJiYgZmlsdGVycy5yb3V0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHJvdXRlTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVycy5yb3V0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hlbGwucm91dGVzLmluZGV4T2YoZmlsdGVycy5yb3V0ZXNbaV0pID4gLTEpIHJvdXRlTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyb3V0ZU1hdGNoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUQUdTXG4gICAgICAgIGlmIChmaWx0ZXJzLnRhZ3MgJiYgZmlsdGVycy50YWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICghc2hlbGwucGF5bG9hZC50YWdzIHx8ICFzaGVsbC5wYXlsb2FkLnRhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRhZ01hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlcnMudGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzaGVsbC5wYXlsb2FkLnRhZ3MuaW5kZXhPZihmaWx0ZXJzLnRhZ3NbaV0pID4gLTEpIHRhZ01hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFnTWF0Y2gpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRZUEVTXG4gICAgICAgIGlmIChmaWx0ZXJzLnR5cGVzICYmIGZpbHRlcnMudHlwZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKCF+ZmlsdGVycy50eXBlcy5pbmRleE9mKHNoZWxsLnBheWxvYWQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhzaGVsbC50eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVVNFUlNcbiAgICAgICAgaWYoZmlsdGVycy51c2VycyAmJiBmaWx0ZXJzLnVzZXJzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBpZighfmZpbHRlcnMudXNlcnMuaW5kZXhPZihQQi5Vc2Vycy5qdXN0VXNlcm5hbWUoc2hlbGwudXNlcm5hbWUpKSkgcmV0dXJuIGZhbHNlXG5cblxuICAgICAgICBpZihmaWx0ZXJzLnJvb3RzKVxuICAgICAgICAgICAgaWYoKHNoZWxsLnBheWxvYWQucGFyZW50c3x8W10pLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgaWYoZmlsdGVycy5hbmNlc3RvcnMgJiYgZmlsdGVycy5mb2N1cykge1xuICAgICAgICAgICAgdmFyIGZvY3VzID0gUEIuZ2V0UHVmZkJ5U2lnKGZpbHRlcnMuZm9jdXMpIC8vIFRPRE86IGZpbmQgYmV0dGVyIHdheSB0byBkbyB0aGlzXG4gICAgICAgICAgICBpZihmb2N1cy5wYXlsb2FkICYmICF+Zm9jdXMucGF5bG9hZC5wYXJlbnRzLmluZGV4T2Yoc2hlbGwuc2lnKSkgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZihmaWx0ZXJzLmRlc2NlbmRhbnRzICYmIGZpbHRlcnMuZm9jdXMpXG4gICAgICAgICAgICBpZighfnNoZWxsLnBheWxvYWQucGFyZW50cy5pbmRleE9mKGZpbHRlcnMuZm9jdXMpKSByZXR1cm4gZmFsc2VcblxuICAgICAgICAvLyBUT0RPOiBkZXByZWNhdGUgdGhpcywgYXMgaXQncyBoYW5kbGVkIGFib3ZlOlxuICAgICAgICBpZiAoZmlsdGVycy50eXBlICYmIGZpbHRlcnMudHlwZS5sZW5ndGgpXG4gICAgICAgICAgICBpZiAoIX5maWx0ZXJzLnR5cGUuaW5kZXhPZihzaGVsbC5wYXlsb2FkLnR5cGUpKSByZXR1cm4gZmFsc2VcblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbn1cblxuXG5cbi8qKlxuICogSGVscGVyIGZvciBzb3J0aW5nIGJ5IHBheWxvYWQudGltZVxuICogQHBhcmFtICB7T2JqZWN0fSBhXG4gKiBAcGFyYW0gIHtvYmplY3R9IGJcbiAqIEByZXR1cm4ge251bWJlcn0gYmFzZWQgb24gZGVzaXJlZCBzb3J0aW5nIG9yZGVyXG4gKi9cblBCLk0uRm9ydW0uc29ydEJ5UGF5bG9hZCA9IGZ1bmN0aW9uKGEsYikge1xuICAgIC8vLy8gaGVscGVyIGZvciBzb3J0aW5nIGJ5IHBheWxvYWQudGltZVxuICAgIGlmKHB1ZmZ3b3JsZHByb3BzLnZpZXcucXVlcnkuc29ydCA9PSAnREVTQycpXG4gICAgICAgIHJldHVybiBiLnBheWxvYWQudGltZSAtIGEucGF5bG9hZC50aW1lO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGEucGF5bG9hZC50aW1lIC0gYi5wYXlsb2FkLnRpbWU7XG59XG5cblxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBwdWZmJ3MgcGFyZW50c1xuICogQHBhcmFtICB7T2JqZWN0fSBwdWZmXG4gKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgcGFyZW50c1xuICovXG5QQi5NLkZvcnVtLmdldFBhcmVudENvdW50ID0gZnVuY3Rpb24ocHVmZiwgcHJvcHMpIHtcbiAgICBpZighcHVmZikgcmV0dXJuIDBcbiAgICBcbiAgICB2YXIgc2lnID0gcHVmZi5zaWcgfHwgcHVmZlxuICAgIFxuICAgIHJldHVybiBQQi5EYXRhLmdyYXBoLnYoc2lnKS5vdXQoJ3BhcmVudCcpLnJ1bigpLmxlbmd0aFxufVxuXG5cbi8qKlxuICogR2V0IGEgY291bnQgb2YgdGhlIGN1cnJlbnQgcHVmZidzIGNoaWxkcmVuXG4gKiBAcGFyYW0gIHtPYmplY3R9IHB1ZmZcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlblxuICovXG5QQi5NLkZvcnVtLmdldENoaWxkQ291bnQgPSBmdW5jdGlvbihwdWZmKSB7XG4gICAgaWYoIXB1ZmYpIHJldHVybiAwXG4gICAgXG4gICAgdmFyIHNpZyA9IHB1ZmYuc2lnIHx8IHB1ZmZcbiAgICBcbiAgICByZXR1cm4gUEIuRGF0YS5ncmFwaC52KHNpZykub3V0KCdjaGlsZCcpLnJ1bigpLmxlbmd0aFxufVxuXG5cbi8qKlxuICogRmlsdGVyIHB1ZmZzIGFjY29yZGluZyB0byBjcml0ZXJpYVxuICogQHBhcmFtICB7c3RyaW5nfSBxdWVyeVxuICogQHBhcmFtICB7c3RyaW5nfSBmaWx0ZXJzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGxpbWl0XG4gKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgcHVmZnNcbiAqL1xuUEIuTS5Gb3J1bS5nZXRQdWZmTGlzdCA9IGZ1bmN0aW9uKHF1ZXJ5LCBmaWx0ZXJzLCBsaW1pdCkge1xuICAgIC8vLy8gcmV0dXJucyBhIGxpc3Qgb2YgcHVmZnNcblxuICAgIC8vIFRISU5LOiB0aGUgZ3JhcGggY2FuIGhlbHAgdXMgaGVyZSwgYnV0IG9ubHkgaWYgd2UncmUgbW9yZSBjbGV2ZXIgYWJvdXQgZm9ybWluZyByZWxhdGlvbnNoaXBzIGFuZCB1c2luZyB0aG9zZSBpbiBvdXIgZmlsdGVycy5cblxuICAgIGxpbWl0ID0gbGltaXQgfHwgSW5maW5pdHlcbiAgICB2YXIgb2Zmc2V0ID0gK3F1ZXJ5Lm9mZnNldHx8MFxuXG4gICAgLy8gdmFyIHNoZWxscyA9IFBCLk0uRm9ydW0uZ2V0U2hlbGxzKHF1ZXJ5LCBmaWx0ZXJzKVxuICAgIHZhciBzaGVsbHMgPSBQQi5EYXRhLmdldEFsbE15U2hlbGxzKClcbiAgICBcbiAgICB2YXIgZmlsdGVyZWRfc2hlbGxzID0gc2hlbGxzLmZpbHRlcihQQi5NLkZvcnVtLmZpbHRlckJ5RmlsdGVycyhCb3Jvbi5leHRlbmQoe30sIHF1ZXJ5LCBmaWx0ZXJzKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KFBCLk0uRm9ydW0uc29ydEJ5UGF5bG9hZCkgLy8gVE9ETzogc29ydCBieSBxdWVyeVxuXG4gICAgdmFyIHNsaWNlZF9zaGVsbHMgPSBmaWx0ZXJlZF9zaGVsbHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQrbGltaXQpXG4gICAgXG4gICAgdmFyIHB1ZmZzID0gc2xpY2VkX3NoZWxscy5tYXAoUEIuRGF0YS5nZXRQdWZmRnJvbVNoZWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG5cbiAgICB2YXIgaGF2ZSA9IHNsaWNlZF9zaGVsbHMubGVuZ3RoXG4gICAgLy8gdmFyIGhhdmUgPSBwdWZmcy5sZW5ndGhcbiAgICBpZihoYXZlID49IGxpbWl0KVxuICAgICAgICByZXR1cm4gcHVmZnMgIC8vIGFzIGxvbmcgYXMgd2UgaGF2ZSBlbm91Z2ggZmlsdGVyZWQgc2hlbGxzIHRoZSBwdWZmcyB3aWxsIGV2ZW50dWFsbHkgZmlsbCBpbiBlbXB0eSBzcG90c1xuXG4gICAgUEIuRGF0YS5maWxsU29tZVNsb3RzUGxlYXNlKGxpbWl0LCBoYXZlLCBxdWVyeSwgZmlsdGVycylcbiAgICBcbiAgICByZXR1cm4gcHVmZnM7XG59XG5cblxuLyoqXG4gKiBUYWtlcyBhIHN0cmluZyBvZiBjb250ZW50LCBjcmVhdGUgYSBwdWZmIGFuZCBwdXNoIGl0IGludG8gdGhlIHN5c3RlbVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcGFyYW0ge2FycmF5fSBwYXJlbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gbWV0YWRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nW119IHVzZXJSZWNvcmRzRm9yV2hvbVRvRW5jcnlwdFxuICogQHBhcmFtIHtzdHJpbmdbXX0gcHJpdmF0ZUVudmVsb3BlQWxpYXNcbiAqIEByZXR1cm5zIHtwcm9taXNlfVxuICovXG5QQi5NLkZvcnVtLmFkZFBvc3QgPSBmdW5jdGlvbih0eXBlLCBjb250ZW50LCBwYXJlbnRzLCBtZXRhZGF0YSwgdXNlclJlY29yZHNGb3JXaG9tVG9FbmNyeXB0LCBwcml2YXRlRW52ZWxvcGVBbGlhcykge1xuICAgIC8vLy8gR2l2ZW4gYSBzdHJpbmcgb2YgY29udGVudCwgY3JlYXRlIGEgcHVmZiBhbmQgcHVzaCBpdCBpbnRvIHRoZSBzeXN0ZW1cbiAgICBcbiAgICAvLyBlbnN1cmUgcGFyZW50cyBpcyBhbiBhcnJheVxuICAgIGlmKCFwYXJlbnRzKSBwYXJlbnRzID0gW11cbiAgICBpZighQXJyYXkuaXNBcnJheShwYXJlbnRzKSkgcGFyZW50cyA9IFtwYXJlbnRzXVxuICAgIFxuICAgIC8vIGVuc3VyZSBwYXJlbnRzIGNvbnRhaW5zIG9ubHkgcHVmZiBpZHNcbiAgICBpZihwYXJlbnRzLm1hcChQQi5nZXRQdWZmQnlTaWcpLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiB4ICE9IG51bGwgfSkubGVuZ3RoICE9IHBhcmVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gUEIuZW1wdHlQcm9taXNlKCdUaG9zZSBhcmUgbm90IGdvb2QgcGFyZW50cycpXG4gICAgXG4gICAgLy8gZW5zdXJlIHBhcmVudHMgYXJlIHVuaXF1ZVxuICAgIHBhcmVudHMgPSBQQi51bmlxdWlmeShwYXJlbnRzKVxuXG4gICAgLy8gZmluZCB0aGUgcm91dGVzIHVzaW5nIHBhcmVudHNcbiAgICB2YXIgcm91dGVzID0gcGFyZW50cy5tYXAoZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIFBCLmdldFB1ZmZCeVNpZyhpZCkudXNlcm5hbWVcbiAgICB9KTtcbiAgICBpZiAobWV0YWRhdGEucm91dGVzKSB7XG4gICAgICAgIHJvdXRlcyA9IG1ldGFkYXRhLnJvdXRlcyAvLyBUSElOSzogdGhpcyBzaG91bGQgcHJvYmFibHkgbWVyZ2Ugd2l0aCBhYm92ZSBpbnN0ZWFkIG9mIHJlcGxhY2luZyBpdC4uLlxuICAgICAgICBkZWxldGUgbWV0YWRhdGFbJ3JvdXRlcyddXG4gICAgfVxuICAgIFxuICAgIC8vIGVuc3VyZSBhbGwgcm91dGVzIGFyZSB1bmlxdWVcbiAgICByb3V0ZXMgPSBQQi51bmlxdWlmeShyb3V0ZXMpXG4gICAgXG4gICAgdmFyIHRha2VVc2VyTWFrZVB1ZmYgPSBQQi5NLkZvcnVtLnBhcnRpYWxseUFwcGx5UHVmZk1ha2VyKHR5cGUsIGNvbnRlbnQsIHBhcmVudHMsIG1ldGFkYXRhLCByb3V0ZXMsIHVzZXJSZWNvcmRzRm9yV2hvbVRvRW5jcnlwdCwgcHJpdmF0ZUVudmVsb3BlQWxpYXMpXG4gICAgXG4gICAgLy8gZ2V0IGEgdXNlciBwcm9taXNlXG4gICAgdmFyIHVzZXJwcm9tID0gUEIuVXNlcnMuZ2V0VXBUb0RhdGVVc2VyQXRBbnlDb3N0KClcbiAgICBcbiAgICB2YXIgcHJvbSA9IHVzZXJwcm9tLmNhdGNoKFBCLmNhdGNoRXJyb3IoJ0ZhaWxlZCB0byBhZGQgcG9zdDogY291bGQgbm90IGFjY2VzcyBvciBjcmVhdGUgYSB2YWxpZCB1c2VyJykpXG4gICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHRha2VVc2VyTWFrZVB1ZmYpXG4gICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChQQi5jYXRjaEVycm9yKCdQb3N0aW5nIGZhaWxlZCcpKVxuICAgIFxuICAgIHJldHVybiBwcm9tXG4gICAgXG4gICAgLy8gTk9URTogYW55IHB1ZmYgdGhhdCBoYXMgJ3RpbWUnIGFuZCAncGFyZW50cycgZmllbGRzIGZ1bGZpbGxzIHRoZSBmb3J1bSBpbnRlcmZhY2VcbiAgICAvLyBUT0RPOiBtYWtlIGFuIG9mZmljaWFsIGludGVyZmFjZSBmdWxmaWxsbWVudCB0aGluZ1xufVxuXG5cbi8qKlxuICogTWFrZSBhIHB1ZmYuLi4gZXhjZXB0IHRoZSBwYXJ0cyB0aGF0IHJlcXVpcmUgYSB1c2VyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7YXJyYXl9IHBhcmVudHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhZGF0YVxuICogQHBhcmFtIHthcnJheX0gcm91dGVzXG4gKiBAcGFyYW0ge2FycmF5fSB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHRcbiAqIEBwYXJhbSB7YXJyYXl9IHByaXZhdGVFbnZlbG9wZUFsaWFzXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cblBCLk0uRm9ydW0ucGFydGlhbGx5QXBwbHlQdWZmTWFrZXIgPSBmdW5jdGlvbih0eXBlLCBjb250ZW50LCBwYXJlbnRzLCBtZXRhZGF0YSwgcm91dGVzLCB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHQsIHByaXZhdGVFbnZlbG9wZUFsaWFzKSB7XG4gICAgLy8vLyBNYWtlIGEgcHVmZi4uLiBleGNlcHQgdGhlIHBhcnRzIHRoYXQgcmVxdWlyZSBhIHVzZXJcbiAgICBcbiAgICAvLyBUSElOSzogaWYgeW91IHVzZSB0aGUgc2FtZSBtZXRhZGF0YSBvYmplY3QgZm9yIG11bHRpcGxlIHB1ZmZzIHlvdXIgY2FjaGVkIHZlcnNpb24gb2YgdGhlIG9sZGVyIHB1ZmZzIHdpbGwgZ2V0IG1lc3NlZCB1cFxuICAgIFxuICAgIHZhciBwYXlsb2FkID0gbWV0YWRhdGEgfHwge30gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWV0YWRhdGEgYmVjb21lcyB0aGUgYmFzaXMgb2YgcGF5bG9hZFxuICAgIHBheWxvYWQucGFyZW50cyA9IHBheWxvYWQucGFyZW50cyB8fCBwYXJlbnRzICAgICAgICAgICAgLy8gaWRzIG9mIHRoZSBwYXJlbnQgcHVmZnNcbiAgICBwYXlsb2FkLnRpbWUgPSBtZXRhZGF0YS50aW1lIHx8IERhdGUubm93KCkgICAgICAgICAgICAgIC8vIHRpbWUgaXMgYWx3YXlzIGEgdW5peCB0aW1lc3RhbXBcbiAgICBwYXlsb2FkLnRhZ3MgPSBtZXRhZGF0YS50YWdzIHx8IFtdICAgICAgICAgICAgICAgICAgICAgIC8vIGFuIGFycmF5IG9mIHRhZ3MgLy8gVE9ETzogbWFrZSB0aGVzZSB3b3JrXG5cbiAgICB2YXIgdHlwZSAgPSB0eXBlIHx8ICd0ZXh0J1xuICAgIHZhciByb3V0ZXMgPSByb3V0ZXMgPyByb3V0ZXMgOiBbXTtcbiAgICByb3V0ZXMgPSByb3V0ZXMuY29uY2F0KFBCLkNPTkZJRy56b25lKTtcbiAgICBcbiAgICByZXR1cm4gZnVuY3Rpb24odXNlclJlY29yZCkge1xuICAgICAgICAvLyB1c2VyUmVjb3JkIGlzIGFsd2F5cyBhbiB1cC10by1kYXRlIHJlY29yZCBmcm9tIHRoZSBESFQsIHNvIHdlIGNhbiB1c2UgaXRzICdsYXRlc3QnIHZhbHVlIGhlcmUgXG5cbiAgICAgICAgdmFyIHByZXZpb3VzID0gdXNlclJlY29yZC5sYXRlc3RcbiAgICAgICAgdmFyIHB1ZmYgPSBQQi5zaW1wbGVCdWlsZFB1ZmYodHlwZSwgY29udGVudCwgcGF5bG9hZCwgcm91dGVzLCB1c2VyUmVjb3Jkc0Zvcldob21Ub0VuY3J5cHQsIHByaXZhdGVFbnZlbG9wZUFsaWFzKVxuXG4gICAgICAgIHJldHVybiBQQi5hZGRQdWZmVG9TeXN0ZW0ocHVmZikgLy8gVEhJTks6IHRoaXMgZmFpbHMgc2lsZW50bHkgaWYgdGhlIHNpZyBleGlzdHMgYWxyZWFkeVxuICAgIH1cbn1cblxuLy8vIGdyYXBoIHJlbGF0aW9uc2hpcHMgLy8vXG5cblBCLk0uRm9ydW0uYWRkRmFtaWxpYWxFZGdlcyA9IGZ1bmN0aW9uKHNoZWxscykge1xuICAgIHNoZWxscy5mb3JFYWNoKFBCLk0uRm9ydW0uYWRkRmFtaWxpYWxFZGdlc0ZvclNoZWxsKVxufVxuXG5QQi5NLkZvcnVtLmFkZEZhbWlsaWFsRWRnZXNGb3JTaGVsbCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgdmFyIGFkZFBhcmVudEVkZ2VzID0gUEIuTS5Gb3J1bS5hZGRGYW1pbGlhbEVkZ2VzRm9yUGFyZW50KGNoaWxkKTtcbiAgICAoY2hpbGQucGF5bG9hZC5wYXJlbnRzfHxbXSkuZm9yRWFjaChhZGRQYXJlbnRFZGdlcyk7XG59XG5cblBCLk0uRm9ydW0uYWRkRmFtaWxpYWxFZGdlc0ZvclBhcmVudCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgdmFyIGV4aXN0aW5nUGFyZW50cyA9IFBCLkRhdGEuZ3JhcGgudihjaGlsZC5zaWcpLm91dCgncGFyZW50JykucHJvcGVydHkoJ3NoZWxsJykucnVuKCkubWFwKFBCLnByb3AoJ3NpZycpKVxuICAgIFxuICAgIHJldHVybiBmdW5jdGlvbihwYXJlbnRTaWcpIHtcbiAgICAgICAgaWYofmV4aXN0aW5nUGFyZW50cy5pbmRleE9mKHBhcmVudFNpZykpIHJldHVybiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uZT9cbiAgICAgICAgUEIuRGF0YS5hZGRTaWdBc1ZlcnRleChwYXJlbnRTaWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWRlbXBvdGVudFxuICAgICAgICBQQi5EYXRhLmdyYXBoLmFkZEVkZ2Uoe19sYWJlbDogJ3BhcmVudCcsIF9pbjogcGFyZW50U2lnLCBfb3V0OiBjaGlsZC5zaWd9KSAvLyBub3QgaWRlbXBvdGVudFxuICAgICAgICBQQi5EYXRhLmdyYXBoLmFkZEVkZ2Uoe19sYWJlbDogJ2NoaWxkJywgX291dDogcGFyZW50U2lnLCAgX2luOiBjaGlsZC5zaWd9KVxuICAgIH1cbn1cblxuLy8vIGVuZCBncmFwaCByZWxhdGlvbnNoaXBzIC8vL1xuXG5cbi8qKlxuICogdG8gcHJvY2VzcyB0aGUgY29udGVudFxuICogQHBhcmFtICB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSAge3B1ZmZ9IHB1ZmZcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuUEIuTS5Gb3J1bS5wcm9jZXNzQ29udGVudCA9IGZ1bmN0aW9uKHR5cGUsIGNvbnRlbnQsIHB1ZmYpIHtcbiAgICB2YXIgdHlwZU9iaiA9IFBCLk0uRm9ydW0uY29udGVudFR5cGVzW3R5cGVdXG4gICAgXG4gICAgaWYoIXR5cGVPYmopXG4gICAgICAgIHR5cGVPYmogPSBQQi5NLkZvcnVtLmNvbnRlbnRUeXBlc1sndGV4dCddXG5cbiAgICByZXR1cm4gdHlwZU9iai50b0h0bWwoY29udGVudCwgcHVmZilcbn1cblxuXG4vLyBUT0RPOiB0aGlzIG1pZ2h0IGdldCBiaWcsIG5lZWQgc29tZSBHQyBoZXJlXG5QQi5NLkZvcnVtLnB1ZmZDb250ZW50U3Rhc2ggPSB7fVxuXG5QQi5NLkZvcnVtLmNsZWFyUHVmZkNvbnRlbnRTdGFzaCA9IGZ1bmN0aW9uKCkge1xuICAgIFBCLk0uRm9ydW0ucHVmZkNvbnRlbnRTdGFzaCA9IHt9XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb250ZW50IG9mIGEgcHVmZlxuICogQHBhcmFtICB7cHVmZn0gcHVmZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5QQi5NLkZvcnVtLmdldFByb2Nlc3NlZFB1ZmZDb250ZW50ID0gZnVuY3Rpb24ocHVmZikge1xuICAgIC8vIFRISU5LOiB3ZSd2ZSBhbHJlYWR5IGVuc3VyZWQgdGhlc2UgYXJlIHByb3BlciBwdWZmcywgc28gd2UgZG9uJ3QgaGF2ZSB0byBjaGVjayBmb3IgcGF5bG9hZC4uLiByaWdodD9cbiAgICBpZihQQi5NLkZvcnVtLnB1ZmZDb250ZW50U3Rhc2hbcHVmZi5zaWddKVxuICAgICAgICByZXR1cm4gUEIuTS5Gb3J1bS5wdWZmQ29udGVudFN0YXNoW3B1ZmYuc2lnXVxuICAgIFxuICAgIHZhciBjb250ZW50ID0gUEIuTS5Gb3J1bS5wcm9jZXNzQ29udGVudChwdWZmLnBheWxvYWQudHlwZSwgcHVmZi5wYXlsb2FkLmNvbnRlbnQsIHB1ZmYpXG4gICAgUEIuTS5Gb3J1bS5wdWZmQ29udGVudFN0YXNoW3B1ZmYuc2lnXSA9IGNvbnRlbnRcbiAgICBcbiAgICByZXR1cm4gY29udGVudFxufVxuXG4vKipcbiAqIEFkZCBzdXBwb3J0IGZvciB0eXBlcyBvZiBjb250ZW50IHRvIHRoZSBzeXN0ZW1cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICovXG5QQi5NLkZvcnVtLmFkZENvbnRlbnRUeXBlID0gZnVuY3Rpb24obmFtZSwgdHlwZSkge1xuICAgIC8vIFRISU5LOiBtb3ZlIHRoaXMgZG93biBpbnRvIFBCP1xuICAgIFxuICAgIGlmKCFuYW1lKSBcbiAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ0ludmFsaWQgY29udGVudCB0eXBlIG5hbWUnKVxuICAgIGlmKFBCLkNPTkZJRy5zdXBwb3J0ZWRDb250ZW50VHlwZXMgJiYgUEIuQ09ORklHLnN1cHBvcnRlZENvbnRlbnRUeXBlcy5pbmRleE9mKG5hbWUpID09IC0xKVxuICAgICAgICByZXR1cm4gUEIub25FcnJvcignVW5zdXBwb3J0ZWQgY29udGVudCB0eXBlOiAnICsgbmFtZSlcbiAgICBpZighdHlwZS50b0h0bWwpIFxuICAgICAgICByZXR1cm4gUEIub25FcnJvcignSW52YWxpZCBjb250ZW50IHR5cGU6IG9iamVjdCBpcyBtaXNzaW5nIHRvSHRtbCBtZXRob2QnLCBuYW1lKVxuICAgIFxuICAgIFBCLk0uRm9ydW0uY29udGVudFR5cGVzW25hbWVdID0gdHlwZVxufVxuXG5cbi8vIERFRkFVTFQgQ09OVEVOVCBUWVBFU1xuXG5QQi5NLkZvcnVtLmFkZENvbnRlbnRUeXBlKCd0ZXh0Jywge1xuICAgIHRvSHRtbDogZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICB2YXIgc2FmZV9jb250ZW50ID0gWEJCQ09ERS5wcm9jZXNzKHsgdGV4dDogY29udGVudCB9KSAgIC8vIG5vdCBpZGVhbCwgYnV0IGl0IGRvZXMgc2VlbSB0byBzdHJpcCBvdXQgcmF3IGh0bWxcbiAgICAgICAgc2FmZV9jb250ZW50Lmh0bWwgPSBzYWZlX2NvbnRlbnQuaHRtbC5yZXBsYWNlKC9cXG4vZywgJzwvYnI+Jyk7ICAvLyBTZXQgbGluZSBicmVha3NcbiAgICAgICAgcmV0dXJuICc8c3Bhbj4nICsgc2FmZV9jb250ZW50Lmh0bWwgKyAnPC9zcGFuPidcbiAgICB9XG59KVxuXG5QQi5NLkZvcnVtLmFkZENvbnRlbnRUeXBlKCdiYmNvZGUnLCB7XG4gICAgdG9IdG1sOiBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgIHZhciBiYmNvZGVQYXJzZSA9IFhCQkNPREUucHJvY2Vzcyh7IHRleHQ6IGNvbnRlbnQgfSk7XG4gICAgICAgIHZhciBwYXJzZWRUZXh0ICA9IGJiY29kZVBhcnNlLmh0bWwucmVwbGFjZSgvXFxuL2csICc8YnIgLz4nKTsgXG4gICAgICAgIHJldHVybiBwYXJzZWRUZXh0O1xuICAgIH1cbn0pXG5cblBCLk0uRm9ydW0uYWRkQ29udGVudFR5cGUoJ2ltYWdlJywge1xuICAgIHRvSHRtbDogZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICBpZihwdWZmd29ybGRwcm9wcy52aWV3Lm1vZGUgPT0gXCJ0YWJsZVZpZXdcIilcbiAgICAgICAgICAgIHJldHVybiAnPGltZyBzcmM9JyArIGNvbnRlbnQgKyAnIC8+JztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuICc8aW1nIGNsYXNzPVwiaW1nSW5Cb3hcIiBzcmM9JyArIGNvbnRlbnQgKyAnIC8+JztcbiAgICB9XG59KVxuXG5QQi5NLkZvcnVtLmFkZENvbnRlbnRUeXBlKCdtYXJrZG93bicsIHtcbiAgICB0b0h0bWw6IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIGNvbnZlcnRlciA9IG5ldyBNYXJrZG93bi5Db252ZXJ0ZXIoKTtcbiAgICAgICAgcmV0dXJuICc8c3Bhbj4nK2NvbnZlcnRlci5tYWtlSHRtbChjb250ZW50KSsnPC9zcGFuPic7XG4gICAgfVxufSlcblxuLy8gVXNlZCB0byBkaXNwbGF5IGNoZXNzIGJvYXJkc1xuUEIuTS5Gb3J1bS5hZGRDb250ZW50VHlwZSgnUEdOJywge1xuICAgIHRvSHRtbDogZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICByZXR1cm4gY2hlc3NCb2FyZChjb250ZW50KTtcbiAgICB9XG59KVxuXG5QQi5NLkZvcnVtLmFkZENvbnRlbnRUeXBlKCdpZGVudGl0eScsIHtcbiAgICB0b0h0bWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJydcbiAgICB9XG59KVxuXG5QQi5NLkZvcnVtLmFkZENvbnRlbnRUeXBlKCdwcm9maWxlJywge1xuICAgIHRvSHRtbDogZnVuY3Rpb24oY29udGVudCwgcHVmZikge1xuICAgICAgICBpZihwdWZmd29ybGRwcm9wcy52aWV3Lm1vZGUgPT0gXCJ0YWJsZVZpZXdcIilcbiAgICAgICAgICAgIHJldHVybiAnPGltZyBzcmM9JyArIGNvbnRlbnQgKyAnIC8+JztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuICc8aW1nIGNsYXNzPVwiaW1nSW5Cb3hcIiBzcmM9JyArIGNvbnRlbnQgKyAnIC8+JztcbiAgICAgICAgLyp2YXIga2V5c05vdFNob3cgPSBbJ2NvbnRlbnQnLCAndHlwZSddO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHVmZi5wYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwdWZmLnBheWxvYWRba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXlzTm90U2hvdy5pbmRleE9mKGtleSk9PS0xICYmIHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRvUmV0ICs9ICc8ZGl2PjxzcGFuIGNsYXNzPVwicHJvZmlsZUtleVwiPicgKyBrZXkgKyAnOiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJwcm9maWxlVmFsdWVcIj4nICsgdmFsdWUgKyAnPC9zcGFuPjwvZGl2Pic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0qL1xuICAgIH1cbn0pXG5cblBCLk0uRm9ydW0uYWRkQ29udGVudFR5cGUoJ2ZpbGUnLCB7XG4gICAgdG9IdG1sOiBmdW5jdGlvbihjb250ZW50LCBwdWZmKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwdWZmLnBheWxvYWQuZmlsZW5hbWVcbiAgICAgICAgICAgIClcbiAgICB9XG5cbn0pXG5cbi8vIFRPRE86IEFkZCBzdXBwb3J0IGZvciBMYVRleFxuLypQQi5NLkZvcnVtLmFkZENvbnRlbnRUeXBlKCdMYVRleCcsIHtcbiAgICB0b0h0bWw6IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIHNhZmVfY29udGVudCA9IFhCQkNPREUucHJvY2Vzcyh7IHRleHQ6IGNvbnRlbnQgfSkgXG4gICAgICAgIHJldHVybiAnPHA+JyArIHNhZmVfY29udGVudC5odG1sICsgJzwvcD4nXG4gICAgfVxufSkgKi9cblxuXG4vLyBGbGFnIGEgcHVmZlxuUEIuTS5Gb3J1bS5mbGFnUHVmZiA9IGZ1bmN0aW9uIChzaWcpIHtcblxuICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgdmFyIHJvdXRlcyA9IFtdO1xuICAgIHZhciB0eXBlID0gJ2ZsYWdQdWZmJztcbiAgICB2YXIgY29udGVudCA9IHNpZztcbiAgICB2YXIgcHVmZjsgLy8gdmFyaWFibGUgZm9yIGxlYWtpbmcgdGhlIHNpZ25lZCBwdWZmIG91dCBvZiB0aGUgc2VjdXJlIHpvbmVcbiAgICBcbiAgICBwYXlsb2FkLnRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgUEIudXNlU2VjdXJlSW5mbyhmdW5jdGlvbihpZGVudGl0aWVzLCBjdXJyZW50VXNlcm5hbWUsIHByaXZhdGVSb290S2V5LCBwcml2YXRlQWRtaW5LZXksIHByaXZhdGVEZWZhdWx0S2V5KSB7ICAgIFxuXG4gICAgICAgIGlmKCFjdXJyZW50VXNlcm5hbWUpIHtcbiAgICAgICAgICAgIGFsZXJ0KFwiWW91IG11c3QgZmlyc3Qgc2V0IHlvdXIgdXNlcm5hbWUgYmVmb3JlIHlvdSBjYW4gZmxhZyBjb250ZW50XCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qaWYoIWN1cnJlbnRVc2VybmFtZSA9PSBQQi5nZXRQdWZmQnlTaWcoc2lnKS51c2VybmFtZSkge1xuICAgICAgICAgICAgYWxlcnQoXCJZb3UgbXVzdCBzZXQgeW91ciBpZGVudGl0eSB0byB0aGUgYXV0aG9yIG9mIHRoZSBwdWZmIHlvdSB3YW50IHRvIGZsYWdcIik7XG4gICAgICAgIH0qL1xuICAgICAgICBpZighcHJpdmF0ZUFkbWluS2V5KSB7XG4gICAgICAgICAgICBhbGVydChcIllvdSBtdXN0IGZpcnN0IHNldCB5b3VyIHByaXZhdGUgYWRtaW4ga2V5IGJlZm9yZSB5b3UgY2FuIGZsYWcgY29udGVudFwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBwdWZmID0gUEIuYnVpbGRQdWZmKGN1cnJlbnRVc2VybmFtZSwgcHJpdmF0ZUFkbWluS2V5LCByb3V0ZXMsIHR5cGUsIGNvbnRlbnQsIHBheWxvYWQpO1xuICAgIH0pXG5cbiAgICB2YXIgZGF0YSA9IHsgdHlwZTogJ2ZsYWdQdWZmJ1xuICAgICAgICAgICAgICAgLCBwdWZmOiBwdWZmXG4gICAgICAgICAgICAgICB9O1xuXG4gICAgdmFyIHByb20gPSBQQi5OZXQuUEJwb3N0KFBCLkNPTkZJRy5wdWZmQXBpLCBkYXRhKTtcbiAgICBcbiAgICBwcm9tID0gcHJvbS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAgIC8vIHZhciBzdG9yZWRTaGVsbHMgPSBQQi5QZXJzaXN0LmdldCgnc2hlbGxzJyk7XG4gICAgICAgIC8vIHZhciBmaWx0ZXJlZFNoZWxscyA9IHN0b3JlZFNoZWxscy5maWx0ZXIoZnVuY3Rpb24ocyl7cmV0dXJuIHMuc2lnICE9IGNvbnRlbnQgJiYgcy5jb250ZW50ICE9IGNvbnRlbnR9KTtcbiAgICAgICAgdmFyIGZsYWdnZWRTaWcgPSBQQi5QZXJzaXN0LmdldCgnZmxhZ2dlZCcpIHx8IFtdO1xuICAgICAgICBmbGFnZ2VkU2lnLnB1c2goY29udGVudCk7XG5cbiAgICAgICAgLy8gUEIuUGVyc2lzdC5zYXZlKCdzaGVsbHMnLCBmaWx0ZXJlZFNoZWxscyk7XG4gICAgICAgIFBCLlBlcnNpc3Quc2F2ZSgnZmxhZ2dlZCcsIGZsYWdnZWRTaWcpO1xuICAgICAgICAvLyByZWxvYWQ/XG4gICAgICAgIC8vIGRvY3VtZW50LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICBFdmVudHMucHViKCd1aS9mbGFnJywge30pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pXG4gICAgcmV0dXJuIHByb207XG59XG5cblxuLy8gQWRkaW5nIGRlZmF1bHQgbWV0YWZpZWxkcyB0byBpbmNsdWRlZCBpbiBhIHB1ZmZcblBCLk0uRm9ydW0ubWV0YUZpZWxkcyA9IFtdXG5QQi5NLkZvcnVtLmNvbnRleHQgPSB7fTtcblBCLk0uRm9ydW0uYWRkTWV0YUZpZWxkcyA9IGZ1bmN0aW9uKGZpZWxkSW5mbywgY29udGV4dCwgZXhjbHVkZUNvbnRleHQpIHtcbiAgICAvLyBOT1RFOiB0aGlzIGlzbid0IHVzZWQgb3V0c2lkZSBvZiBwdWJsaXNoRW1iZWQuanMsIGJ1dCBpdCBtaWdodCBwcm92aWRlIGEgZ29vZCBiYXNpcyBmb3IgZ2VuZXJpYy9yZXF1aXJlZCBtZXRhZGF0YVxuICAgIFxuICAgIGlmICghZmllbGRJbmZvLm5hbWUpIHJldHVybiBjb25zb2xlLmxvZygnSW52YWxpZCBtZXRhIGZpZWxkIG5hbWUuJyk7XG5cbiAgICAvLyBzdXBwb3J0ZWQgdHlwZTogdGV4dCwgdGV4dGFyZWEsIHB1bGxkb3duLCBhcnJheVxuICAgIGlmICghZmllbGRJbmZvLnR5cGUpIHJldHVybiBjb25zb2xlLmxvZygnSW52YWxpZCBtZXRhIGZpZWxkIHR5cGUuJyk7XG5cbiAgICBpZiAoIWZpZWxkSW5mby52YWxpZGF0b3IgfHwgdHlwZW9mIGZpZWxkSW5mby52YWxpZGF0b3IgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmaWVsZEluZm8udmFsaWRhdG9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwgT2JqZWN0LmtleXMoUEIuTS5Gb3J1bS5jb250ZW50VHlwZXMpO1xuICAgIGlmICh0eXBlb2YgY29udGV4dCA9PSAnc3RyaW5nJykge1xuICAgICAgICBjb250ZXh0ID0gW2NvbnRleHRdO1xuICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoY29udGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ0ludmFsaWQgY29udGV4dC4nKVxuICAgIH1cblxuICAgIGV4Y2x1ZGVDb250ZXh0ID0gZXhjbHVkZUNvbnRleHQgfHwgW107XG4gICAgaWYgKHR5cGVvZiBleGNsdWRlQ29udGV4dCA9PSAnc3RyaW5nJykge1xuICAgICAgICBleGNsdWRlQ29udGV4dCA9IFtleGNsdWRlQ29udGV4dF07XG4gICAgfWVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGV4Y2x1ZGVDb250ZXh0KSkge1xuICAgICAgICByZXR1cm4gUEIub25FcnJvcignSW52YWxpZCBjb250ZXh0LicpXG4gICAgfVxuXG4gICAgUEIuTS5Gb3J1bS5tZXRhRmllbGRzLnB1c2goZmllbGRJbmZvKTtcbiAgICBmb3IgKHZhciBpPTA7IGk8Y29udGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZXhjbHVkZUNvbnRleHQuaW5kZXhPZihjb250ZXh0W2ldKSAhPSAtMSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB2YXIgY29udGV4dEZpZWxkcyA9IFBCLk0uRm9ydW0uY29udGV4dFtjb250ZXh0W2ldXSB8fCBbXTtcbiAgICAgICAgY29udGV4dEZpZWxkcy5wdXNoKGZpZWxkSW5mby5uYW1lKTtcbiAgICAgICAgUEIuTS5Gb3J1bS5jb250ZXh0W2NvbnRleHRbaV1dID0gY29udGV4dEZpZWxkcztcbiAgICB9XG59XG5cblBCLk0uRm9ydW0uYWRkTWV0YUZpZWxkcyhcbiAgICB7bmFtZTogJ3JlcGx5IHByaXZhY3knLFxuICAgICB0eXBlOiAncHVsbGRvd24nLFxuICAgICBlbnVtOiBbJycsICdwdWJsaWMnLCAncHJpdmF0ZScsICdhbm9ueW1vdXMnLCAnaW52aXNpYmxlJ10sXG4gICAgIGRlZmF1bHRWYWx1ZTogJyd9KTtcblxuUEIuTS5Gb3J1bS5hZGRNZXRhRmllbGRzKFxuICAgIHtuYW1lOiAnY29udGVudCBsaWNlbnNlJyxcbiAgICAgdHlwZTogJ3B1bGxkb3duJyxcbiAgICAgZW51bTogWycnLCAnQ3JlYXRpdmVDb21tb25zQXR0cmlidXRpb24nLCAnR05VUHVibGljTGljZW5zZScsICdQdWJsaWNkb21haW4nLCAnUmlnaHRzLW1hbmFnZWQnLCAnUm95YWx0eS1mcmVlJ10sXG4gICAgIGRlZmF1bHRWYWx1ZTogJyd9KTtcblxuUEIuTS5Gb3J1bS5hZGRNZXRhRmllbGRzKFxuICAgIHtuYW1lOiAndGFncycsXG4gICAgIHR5cGU6ICdhcnJheScsXG4gICAgIHZhbGlkYXRvcjogZnVuY3Rpb24odil7cmV0dXJuIC9eW2EtejAtOV0rJC9pLnRlc3Qodil9XG4gICAgIH0sXG4gICAgZmFsc2UsICdwcm9maWxlJyk7XG5cblBCLk0uRm9ydW0uYWRkTWV0YUZpZWxkcyhcbiAgICB7bmFtZTogJ2xhbmd1YWdlJyxcbiAgICAgdHlwZTogJ3RleHQnLFxuICAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uKCl7cmV0dXJuIHB1ZmZ3b3JsZHByb3BzLnZpZXcubGFuZ3VhZ2V9fSk7XG5cblBCLk0uRm9ydW0uYWRkTWV0YUZpZWxkcyhcbiAgICB7bmFtZTogJ25hbWUnLFxuICAgICB0eXBlOiAndGV4dCd9LFxuICAgICdwcm9maWxlJyk7IiwiLyogXG4gICAgICAgICAgICAgICAgICAgX19fX18gIF9fX19fICAgICAgICAgICAgICAgICAgICAgICAgICAuX19fICAgICAgICAgICAgX19fLiAgICAgICAgICAgXG4gICAgX19fX19fICBfXyBfX18vIF9fX19cXC8gX19fX1xcXyAgXyAgX19fX19fXyBfX19fX19fICBfX3wgXy9fX19fX18gIF9fX19cXF8gfF9fICAgX19fXyAgXG4gICAgXFxfX19fIFxcfCAgfCAgXFwgICBfX1xcXFwgICBfX1xcXFwgXFwvIFxcLyAvXFxfXyAgXFxcXF8gIF9fIFxcLyBfXyB8XFxfICBfXyBcXC8gIF8gXFx8IF9fIFxcXy8gX18gXFwgXG4gICAgfCAgfF8+ID4gIHwgIC98ICB8ICAgfCAgfCAgIFxcICAgICAvICAvIF9fIFxcfCAgfCBcXC8gL18vIHwgfCAgfCBcXCggIDxfPiApIFxcX1xcIFxcICBfX18vIFxuICAgIHwgICBfXy98X19fXy8gfF9ffCAgIHxfX3wgICAgXFwvXFxfLyAgKF9fX18gIC9fX3wgIFxcX19fXyB8IHxfX3wgICBcXF9fX18vfF9fXyAgL1xcX19fICA+XG4gICAgfF9ffCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXC8gICAgICAgICAgIFxcLyAgICAgICAgICAgICAgICAgIFxcLyAgICAgXFwvIFxuICBcbiAgQSBQdWZmYmFsbCBtb2R1bGUgZm9yIG1hbmFnaW5nIGlkZW50aXRpZXMgYW5kIHByaXZhdGUgZGF0YSBsb2NhbGx5LlxuICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIFRoZSBXYXJkcm9iZSBtYW5hZ2VzIGlkZW50aXRpZXMsIGFsaWFzZXMsIGFuZCBwcml2YXRlIGRhdGEuXG5cbiAgQW4gaWRlbnRpdHkgaXMgYSB1c2VybmFtZSBhbmQgYSBsaXN0IG9mIGFsbCBrbm93biBhbGlhc2VzLiBUaGUgaWRlbnRpdHkgYWxzbyBsaXN0cyB0aGUgbGFzdCBrbm93biBwcmltYXJ5IGFsaWFzLCBpZiB0aGVyZSBpcyBvbmUsIGFuZCB0aGUgaWRlbnRpdHkncyBwcml2YXRlIHByZWZlcmVuY2VzLiBcblxuICBBbiBhbGlhcyBpcyBhIHVzZXJuYW1lLCBhICdjYXBhJywgYW5kIGEgc2V0IG9mIHByaXZhdGUga2V5cy4gQWRkaXRpb25hbCBwcml2YXRlIGluZm9ybWF0aW9uIChsaWtlIGEgcGFzc3BocmFzZSkgbWF5IGJlIHN0b3JlZCBpbiB0aGUgYWxpYXMncyAnc2VjcmV0cycgZmllbGQuXG5cbiAgQWxpYXNlcyBnZW5lcmFsbHkgY29ycmVzcG9uZCBlaXRoZXIgdG8gcHJldmlvdXMgdmVyc2lvbnMgb2YgdGhlIGlkZW50aXR5J3MgdXNlcm5hbWUgKHByZXZpb3VzIHByaW1hcmllcyksIG9yIHRvIGFub255bW91cyB1c2VybmFtZXMgY3JlYXRlZCBmb3Igb25lLXRpbWUgZW5jcnlwdGVkIHRyYW5zZmVyLiBcblxuICBVc2VybmFtZSBhbmQgY2FwYSBkZWZpbmUgYSB1bmlxdWUgYWxpYXMuIFRoZSBjYXBhIGZpZWxkIHJlZmVyZW5jZXMgYSBzcGVjaWZpYyBtb21lbnQgaW4gdGhlIHVzZXJuYW1lJ3MgbGlmZWN5Y2xlLCBhbmQgY29ycmVsYXRlcyB0byB0aGUgdXNlclJlY29yZCB3aXRoIHRoZSBzYW1lIHVzZXJuYW1lIGFuZCBjYXBhIHdob3NlIHB1YmxpYyBrZXlzIG1hdGNoIHRoZSBhbGlhcydzIHByaXZhdGUga2V5cy4gSW4gb3RoZXIgd29yZHMsIGNhcGEgPT0gdmVyc2lvbi5cblxuICBDdXJyZW50bHkgY2FwYSBjb3VudHMgYnkgY29uc2VjdXRpdmUgaW50ZWdlcnMuIFRoaXMgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlLiBBbnkgc2V0IGRlcml2aW5nIEVxIGFuZCBPcmQgd2lsbCB3b3JrLlxuXG4gIEFuIGlkZW50aXR5IGZpbGUgY2FuIGJlIGV4cG9ydGVkIHRvIHRoZSBsb2NhbCBmaWxlc3lzdGVtIGFuZCBpbXBvcnRlZCBiYWNrIGluIHRvIHRoZSBzeXN0ZW0uXG5cbiAgUHJpdmF0ZSBkYXRhIGlzIGEgYmxhY2sgYm94IGZvciBcblxuICBVc2FnZSBleGFtcGxlczpcbiAgICAgIFBCLnN3aXRjaElkZW50aXR5VG8odXNlcm5hbWUpXG5cbiovXG5cbi8qXG4gIFRISU5LOlxuICAgIC0gcmVnaXN0ZXIgY2FsbGJhY2sgaGFuZGxlcnMgZm9yIHVzZXIgcmVjb3JkIGNyZWF0aW9uIGFuZCBtb2RpZmljYXRpb25cbiAgICAtIFBCLk0uV2FyZHJvYmUuaW5pdCByZWdpc3RlcnMgdGhvc2Ugd2l0aCBQQi5vblVzZXJDcmVhdGlvbiBhbmQgUEIub25Vc2VyTW9kaWZpY2F0aW9uXG4gICAgLSBpZGVudGl0eSBmaWxlIGVuY3J5cHRpb24gdXNpbmcgYSBwYXNzcGhyYXNlXG4qL1xuXG5cblBCLk0uV2FyZHJvYmUgPSB7fVxuXG5+ZnVuY3Rpb24oKSB7IC8vIGJlZ2luIHRoZSBjbG9zdXJlXG5cbiAgICB2YXIgaWRlbnRpdGllcyA9IHt9XG4gICAgdmFyIGFsaWFzZXMgPSB7fVxuICAgIC8vIHthc2RmOiB7IHVzZXJuYW1lOiAnYXNkZicsIHByaW1hcnk6IGFzZGYtMTIsIGFsaWFzZXM6IFthc2RmLTExLCBhc2RmLTEwXSwgcHJlZmVyZW5jZXM6IHt9IH0gfVxuXG4gICAgLy8gYW4gYWxpYXM6IHsgdXNlcm5hbWU6ICdhc2RmJywgY2FwYTogMTIsIHByaXZhdGVSb290S2V5OiAnMTIzJywgcHJpdmF0ZUFkbWluS2V5OiAnMzMzJywgcHJpdmF0ZURlZmF1bHRLZXk6ICc0NDQnLCBzZWNyZXRzOiB7fSB9XG5cbiAgICB2YXIgY3VycmVudFVzZXJuYW1lID0gZmFsc2VcblxuXG4gICAgLy8gVE9ETzogaW50ZWdyYXRlIGNhcGEgd2l0aCB1c2VyUmVjb3JkcyBhbmQgcHVmZnMgZXZlcnl3aGVyZVxuICAgIC8vIFRPRE86IHVzZSBjYXBhIHJldHVybmVkIGZyb20gc2VydmVyIG9uIHVwZGF0ZSBwYXNzcGhyYXNlXG4gICAgLy8gVE9ETzogZ2V0IGFub24gY3JlYXRpb24gd29ya2luZ1xuXG5cbiAgICBQQi5NLldhcmRyb2JlLmluaXQgPSBpbml0XG4gICAgXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgUEIuaW1wbGVtZW50U2VjdXJlSW50ZXJmYWNlKHVzZVNlY3VyZUluZm8sIGFkZElkZW50aXR5LCBhZGRBbGlhcywgc2V0UHJpbWFyeUFsaWFzLCBzZXRQcmVmZXJlbmNlLCBzd2l0Y2hJZGVudGl0eVRvLCByZW1vdmVJZGVudGl0eSlcbiAgICAgICAgXG4gICAgICAgIFBCLmFkZElkZW50aXR5VXBkYXRlSGFuZGxlcihmdW5jdGlvbigpIHsgLy8gVEhJTks6IHdoZXJlIHNob3VsZCB0aGlzIGxpdmU/XG4gICAgICAgICAgICBpZighUEIuQ09ORklHLmRpc2FibGVDbG91ZElkZW50aXR5KVxuICAgICAgICAgICAgICAgIFBCLnN0b3JlSWRlbnRpdHlGaWxlSW5DbG91ZCgpXG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIHdheSB0byBkbyB0aGlzXG4gICAgICAgIHZhciBvbGRDb25maWdWYWx1ZSA9IFBCLkNPTkZJRy5kaXNhYmxlQ2xvdWRJZGVudGl0eVxuICAgICAgICBQQi5DT05GSUcuZGlzYWJsZUNsb3VkSWRlbnRpdHkgPSB0cnVlXG4gICAgICAgIFxuICAgICAgICB2YXIgc3RvcmVkSWRlbnRpdGllcyA9IFBCLlBlcnNpc3QuZ2V0KCdpZGVudGl0aWVzJykgfHwge31cbiAgICBcbiAgICAgICAgT2JqZWN0LmtleXMoc3RvcmVkSWRlbnRpdGllcykuZm9yRWFjaChmdW5jdGlvbih1c2VybmFtZSkge1xuICAgICAgICAgICAgdmFyIGlkZW50aXR5ID0gc3RvcmVkSWRlbnRpdGllc1t1c2VybmFtZV1cbiAgICAgICAgICAgIGFkZElkZW50aXR5KHVzZXJuYW1lLCBpZGVudGl0eS5hbGlhc2VzLCBpZGVudGl0eS5wcmVmZXJlbmNlcywgdHJ1ZSlcbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIFBCLkNPTkZJRy5kaXNhYmxlQ2xvdWRJZGVudGl0eSA9IG9sZENvbmZpZ1ZhbHVlXG4gICAgICAgIFxuICAgICAgICB2YXIgbGFzdFVzZXJuYW1lID0gUEIuUGVyc2lzdC5nZXQoJ2N1cnJlbnRVc2VybmFtZScpXG4gICAgICAgIFxuICAgICAgICBpZiAobGFzdFVzZXJuYW1lKVxuICAgICAgICAgICAgUEIuc3dpdGNoSWRlbnRpdHlUbyhsYXN0VXNlcm5hbWUpIC8vIE5PVEU6IGNhbGwgd3JhcHBlZCB2ZXJzaW9uIHRvIGdldCBoYW5kbGVyc1xuICAgIH1cbiAgICBcbiAgICBcbiAgICAvLy8vIGV4cG9ydGVkIHZpYSBpbXBsZW1lbnRTZWN1cmVJbnRlcmZhY2VcblxuICAgIHZhciB1c2VTZWN1cmVJbmZvID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGlkZW50aXR5ID0gZ2V0Q3VycmVudElkZW50aXR5KCkgfHwge31cbiAgICAgICAgdmFyIHByaW1hcnkgPSBpZGVudGl0eS5wcmltYXJ5IHx8IHt9XG5cbiAgICAgICAgLy8gd2UgaGF2ZSB0byByZXR1cm4gYWxsIHRoZSBpZGVudGl0aWVzIGJlY2F1c2UgdGhlIHVzZXIgbWlnaHQgYmUgdHJ5aW5nIHRvIGxpc3QgdGhlbVxuICAgICAgICBjYWxsYmFjayhpZGVudGl0aWVzLCBjdXJyZW50VXNlcm5hbWUsIHByaW1hcnkucHJpdmF0ZVJvb3RLZXksIHByaW1hcnkucHJpdmF0ZUFkbWluS2V5LCBwcmltYXJ5LnByaXZhdGVEZWZhdWx0S2V5KVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICB2YXIgYWRkSWRlbnRpdHkgPSBmdW5jdGlvbih1c2VybmFtZSwgYWxpYXNlcywgcHJlZmVyZW5jZXMsIG5vc2F2ZSkgeyAvLyBUT0RPOiBjaGVjayBpZiBub3NhdmUgaXMgbmVlZGVkXG4gICAgICAgIC8vIFRPRE86IHZhbGlkYXRpb24gb24gYWxsIGF2YWlsYWJsZSB2YWx1ZXNcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgZm9yIGV4aXN0aW5nIGlkZW50aXR5XG4gICAgICAgIC8vIFRPRE86IGFkZCBhbnkgdW5rbm93biBhbGlhc2VzXG4gICAgICAgIC8vIFRISU5LOiB3aGF0IGFib3V0IGFsaWFzZXMgdGhhdCBiZWxvbmcgdG8gb3RoZXIgaWRlbnRpdGllcz9cbiAgICAgICAgLy8gVEhJTks6IGVuc3VyZSBwcmltYXJ5IGFsaWFzIGV4aXN0cz9cbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHByaW1hcnkgKHVzZSB1c2VybmFtZSttYXhjYXBhIGluc3RlYWQpXG5cbiAgICAgICAgdmFyIGlkZW50aXR5ID0geyB1c2VybmFtZTogdXNlcm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgLCBwcmltYXJ5OiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAsIGFsaWFzZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICwgcHJlZmVyZW5jZXM6IHByZWZlcmVuY2VzIHx8IHt9XG4gICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICBpZGVudGl0aWVzW3VzZXJuYW1lXSA9IGlkZW50aXR5XG4gICAgICAgIFxuICAgICAgICBpZighQXJyYXkuaXNBcnJheShhbGlhc2VzKSlcbiAgICAgICAgICAgIGFsaWFzZXMgPSBhbGlhc2VzID8gW2FsaWFzZXNdIDogW11cbiAgICAgICAgXG4gICAgICAgIGFsaWFzZXMuZm9yRWFjaChcbiAgICAgICAgICAgIGZ1bmN0aW9uKGFsaWFzKSB7XG4gICAgICAgICAgICAgICAgYWRkQWxpYXModXNlcm5hbWUsIGFsaWFzLnVzZXJuYW1lLCBhbGlhcy5jYXBhLCBhbGlhcy5wcml2YXRlUm9vdEtleSwgYWxpYXMucHJpdmF0ZUFkbWluS2V5LCBhbGlhcy5wcml2YXRlRGVmYXVsdEtleSwgYWxpYXMuc2VjcmV0cyl9KVxuICAgICAgICBcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIHByZWZzXG4gICAgICAgIFxuICAgICAgICBpZighbm9zYXZlKSAvLyBUT0RPOiBjaGFuZ2UgcHJvY2Vzc1VwZGF0ZXMgc28gaXQgb25seSBzYXZlcyBpZiB3ZSdyZSBub3QgYnVzeSBvcGVuaW5nIGFsbCBpZGVudGl0aWVzPyBvciBqdXN0IGxldCB0aGUgMTAwbXMgdGhyb3R0bGUgaGFuZGxlIGl0Li4uXG4gICAgICAgICAgICBwcm9jZXNzVXBkYXRlcygpXG4gICAgICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICB2YXIgYWRkQWxpYXMgPSBmdW5jdGlvbihpZGVudGl0eVVzZXJuYW1lLCBhbGlhc1VzZXJuYW1lLCBjYXBhLCBwcml2YXRlUm9vdEtleSwgcHJpdmF0ZUFkbWluS2V5LCBwcml2YXRlRGVmYXVsdEtleSwgc2VjcmV0cykge1xuICAgICAgICAvLyBUT0RPOiB2YWxpZGF0aW9uIG9uIGFsbCBhdmFpbGFibGUgdmFsdWVzXG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGZvciBleGlzdGluZyB1c2VybmFtZS9jYXBhXG4gICAgICAgIC8vIFRISU5LOiBoaXQgbmV0d29yayBmb3IgY29uZmlybWF0aW9uP1xuICAgICAgICAvLyBUSElOSzogbWF5YmUgb25seSBpbmNsdWRlIHZpYWJsZSB2YWx1ZXM/XG5cbiAgICAgICAgdmFyIGFsaWFzID0geyB1c2VybmFtZTogYWxpYXNVc2VybmFtZVxuICAgICAgICAgICAgICAgICAgICAsIGNhcGE6IGNhcGEgfHwgMSAvLyBOT1RFOiBkZWZhdWx0IGNhcGFcbiAgICAgICAgICAgICAgICAgICAgLCBwcml2YXRlUm9vdEtleTogcHJpdmF0ZVJvb3RLZXkgfHwgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgLCBwcml2YXRlQWRtaW5LZXk6IHByaXZhdGVBZG1pbktleSB8fCBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAsIHByaXZhdGVEZWZhdWx0S2V5OiBwcml2YXRlRGVmYXVsdEtleSB8fCBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAsIHNlY3JldHM6IHNlY3JldHMgfHwge31cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZGVudGl0eSA9IGdldElkZW50aXR5KGlkZW50aXR5VXNlcm5hbWUpXG4gICAgICAgIFxuICAgICAgICBpZighaWRlbnRpdHkpIHtcbiAgICAgICAgICAgIGFkZElkZW50aXR5KGlkZW50aXR5VXNlcm5hbWUpICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZXMgYW4gZW1wdHkgaWRlbnRpdHlcbiAgICAgICAgICAgIGlkZW50aXR5ID0gZ2V0SWRlbnRpdHkoaWRlbnRpdHlVc2VybmFtZSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gbWVyZ2UgYWxpYXNcbiAgICAgICAgdmFyIG9sZF9hbGlhcyA9IGdldE9sZEFsaWFzKGlkZW50aXR5LCBhbGlhcylcbiAgICAgICAgaWYob2xkX2FsaWFzKSB7XG4gICAgICAgICAgICBhbGlhcy5zZWNyZXRzID0gQm9yb24uZXh0ZW5kKG9sZF9hbGlhcy5zZWNyZXRzLCBhbGlhcy5zZWNyZXRzKVxuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gYWxpYXMpIFxuICAgICAgICAgICAgICAgIGlmKGFsaWFzW2tleV0pXG4gICAgICAgICAgICAgICAgICAgIG9sZF9hbGlhc1trZXldID0gYWxpYXNba2V5XVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWRlbnRpdHkuYWxpYXNlcy5wdXNoKGFsaWFzKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihhbGlhc1VzZXJuYW1lID09IGlkZW50aXR5VXNlcm5hbWUgJiYgYWxpYXMuY2FwYSA+PSAoaWRlbnRpdHkuY2FwYXx8MCkpIHtcbiAgICAgICAgICAgIGlkZW50aXR5LnByaW1hcnkgPSBhbGlhcyAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBwcmltYXJ5IGZvciBpZGVudGl0eSAod2hpY2ggbWF5IGhhdmUgYmVlbiBlbXB0eSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgYWxpYXNlc1thbGlhc1VzZXJuYW1lXSA9IGlkZW50aXR5ICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGlzIHRvIHRoZSBhbGlhcy1pZGVudGl0eSBtYXBwaW5nXG5cbiAgICAgICAgcHJvY2Vzc1VwZGF0ZXMoKVxuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgdmFyIHNldFByaW1hcnlBbGlhcyA9IGZ1bmN0aW9uKGlkZW50aXR5VXNlcm5hbWUsIGFsaWFzVXNlcm5hbWUpIHtcbiAgICAgICAgdmFyIGlkZW50aXR5ID0gZ2V0SWRlbnRpdHkoaWRlbnRpdHlVc2VybmFtZSlcbiAgICAgICAgXG4gICAgICAgIGlmKCFpZGVudGl0eSlcbiAgICAgICAgICAgIHJldHVybiBQQi5vbkVycm9yKCdQcmltYXJ5IGFsaWFzIGNhbiBvbmx5IGJlIHNldCBmb3Iga25vd24gaWRlbnRpdGllcycpXG4gICAgICAgICAgICBcbiAgICAgICAgdmFyIGFsaWFzID0gZ2V0TGF0ZXN0QWxpYXMoaWRlbnRpdHksIGFsaWFzVXNlcm5hbWUpXG4gICAgICAgIFxuICAgICAgICBpZighYWxpYXMpXG4gICAgICAgICAgICByZXR1cm4gUEIub25FcnJvcignVGhhdCBhbGlhcyBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIHRoYXQgaWRlbnRpdHknKVxuICAgIFxuICAgICAgICAvLyBhbGwgY2xlYXIhXG4gICAgICAgIFxuICAgICAgICBpZGVudGl0eS51c2VybmFtZSA9IGFsaWFzVXNlcm5hbWVcbiAgICAgICAgaWRlbnRpdHkucHJpbWFyeSA9IGFsaWFzXG5cbiAgICAgICAgZGVsZXRlIGlkZW50aXRpZXNbaWRlbnRpdHlVc2VybmFtZV1cbiAgICAgICAgaWRlbnRpdGllc1thbGlhc1VzZXJuYW1lXSA9IGlkZW50aXR5XG4gICAgICAgIFxuICAgICAgICBpZihpZGVudGl0eVVzZXJuYW1lID09IGN1cnJlbnRVc2VybmFtZSlcbiAgICAgICAgICAgIHN3aXRjaElkZW50aXR5VG8oYWxpYXNVc2VybmFtZSlcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgICBcbiAgICB2YXIgc2V0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgLy8gTk9URTogdGhpcyBvbmx5IHdvcmtzIGZvciB0aGUgY3VycmVudCBpZGVudGl0eVxuICAgICAgICB2YXIgaWRlbnRpdHkgPSBnZXRDdXJyZW50SWRlbnRpdHkoKVxuICAgIFxuICAgICAgICBpZighaWRlbnRpdHkpXG4gICAgICAgICAgICByZXR1cm4gUEIub25FcnJvcignUHJlZmVyZW5jZXMgY2FuIG9ubHkgYmUgc2V0IGZvciBhbiBhY3RpdmUgaWRlbnRpdHknKVxuICAgIFxuICAgICAgICBpZGVudGl0eS5wcmVmZXJlbmNlc1trZXldID0gdmFsdWVcblxuICAgICAgICBwcm9jZXNzVXBkYXRlcygpXG4gICAgfVxuICAgIFxuICAgIHZhciBzd2l0Y2hJZGVudGl0eVRvID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAgICAgaWYodXNlcm5hbWUpIHtcbiAgICAgICAgICAgIHZhciBpZGVudGl0eSA9IGdldElkZW50aXR5KHVzZXJuYW1lKVxuXG4gICAgICAgICAgICBpZighaWRlbnRpdHkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ05vIGlkZW50aXR5IGZvdW5kIHdpdGggdXNlcm5hbWUgXCInICsgdXNlcm5hbWUgKyAnXCInKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjdXJyZW50VXNlcm5hbWUgPSB1c2VybmFtZSB8fCBmYWxzZVxuXG4gICAgICAgIGlmKCFQQi5jdXJyZW50SWRlbnRpdHlIYXNoKSAvLyBUSElOSzogd2hhdCBhcmUgdGhlIGNhc2VzP1xuICAgICAgICAgICAgUEIuY3VycmVudElkZW50aXR5SGFzaCA9IFBCLkNyeXB0by5jcmVhdGVNZXNzYWdlSGFzaChKU09OLnN0cmluZ2lmeShQQi5mb3JtYXRJZGVudGl0eUZpbGUoKSkpXG4gICAgICAgIFxuICAgICAgICBwcm9jZXNzVXBkYXRlcygpXG4gICAgICAgIFxuICAgICAgICBpZih1c2VybmFtZSAmJiBpZGVudGl0eSAmJiBpZGVudGl0eS5wcmltYXJ5KVxuICAgICAgICAgICAgUEIuVXNlcnMuZ2V0VXNlclJlY29yZFByb21pc2UodXNlcm5hbWUsIGlkZW50aXR5LnByaW1hcnkuY2FwYSkgLy8gZmV0Y2ggb3VyIHVzZXJSZWNvcmQgXG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgXG4gICAgdmFyIHJlbW92ZUlkZW50aXR5ID0gZnVuY3Rpb24odXNlcm5hbWUpIHtcbiAgICAgICAgdmFyIGlkZW50aXR5ID0gZ2V0SWRlbnRpdHkodXNlcm5hbWUpXG5cbiAgICAgICAgaWYoIWlkZW50aXR5KVxuICAgICAgICAgICAgcmV0dXJuIFBCLm9uRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHRoYXQgaWRlbnRpdHkgZm9yIHJlbW92YWwnKVxuXG4gICAgICAgIGRlbGV0ZSBpZGVudGl0aWVzW3VzZXJuYW1lXVxuXG4gICAgICAgIGlmKGN1cnJlbnRVc2VybmFtZSA9PSB1c2VybmFtZSlcbiAgICAgICAgICAgIGN1cnJlbnRVc2VybmFtZSA9IGZhbHNlXG5cbiAgICAgICAgcHJvY2Vzc1VwZGF0ZXMoKVxuICAgIH1cblxuICAgIC8vLy9cbiAgICAvLy8vIGludGVybmFsIGhlbHBlciBmdW5jdGlvbnMuIG5vdCBleHBvcnRlZC5cbiAgICAvLy8vXG5cbiAgICBmdW5jdGlvbiBnZXRMYXRlc3RBbGlhcyhpZGVudGl0eSwgYWxpYXNVc2VybmFtZSkge1xuICAgICAgICB2YXIgbWF4Y2FwYSA9IDBcbiAgICAgICAgdmFyIGFsaWFzID0gZmFsc2VcbiAgICAgICAgXG4gICAgICAgIGZvcih2YXIgaT0wLCBsPWlkZW50aXR5LmFsaWFzZXMubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRlc3QgPSBpZGVudGl0eS5hbGlhc2VzW2ldXG4gICAgICAgICAgICBpZih0ZXN0LnVzZXJuYW1lID09IGFsaWFzVXNlcm5hbWUgJiYgdGVzdC5jYXBhID4gbWF4Y2FwYSkge1xuICAgICAgICAgICAgICAgIGFsaWFzID0gdGVzdFxuICAgICAgICAgICAgICAgIG1heGNhcGEgPSB0ZXN0LmNhcGFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGFsaWFzXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0T2xkQWxpYXMoaWRlbnRpdHksIGFsaWFzKSB7XG4gICAgICAgIGZvcih2YXIgaT0wLCBsPWlkZW50aXR5LmFsaWFzZXMubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRlc3QgPSBpZGVudGl0eS5hbGlhc2VzW2ldXG4gICAgICAgICAgICBpZihhbGlhcy51c2VybmFtZSA9PSB0ZXN0LnVzZXJuYW1lICYmIGFsaWFzLmNhcGEgPT0gdGVzdC5jYXBhKVxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXN0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByaXZhdGVLZXlzKHVzZXJuYW1lLCBjYXBhLCBwcml2YXRlUm9vdEtleSwgcHJpdmF0ZUFkbWluS2V5LCBwcml2YXRlRGVmYXVsdEtleSkge1xuICAgICAgICAvLyBDVVJSRU5UTFkgVU5VU0VEXG4gICAgICAgIC8vLy8gRW5zdXJlIGtleXMgbWF0Y2ggdGhlIHVzZXJSZWNvcmRcbiAgICBcbiAgICAgICAgdmFyIHByb20gPSBQQi5Vc2Vycy5nZXRVc2VyUmVjb3JkUHJvbWlzZSh1c2VybmFtZSwgY2FwYSlcbiAgICBcbiAgICAgICAgcmV0dXJuIHByb21cbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHVzZXJSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAvLyB2YWxpZGF0ZSBhbnkgcHJvdmlkZWQgcHJpdmF0ZSBrZXlzIGFnYWluc3QgdGhlIHVzZXJSZWNvcmQncyBwdWJsaWMga2V5c1xuICAgICAgICAgICAgICAgIGlmKCAgIHByaXZhdGVSb290S2V5ICYmIFBCLkNyeXB0by5wcml2YXRlVG9QdWJsaWMocHJpdmF0ZVJvb3RLZXkpICE9IHVzZXJSZWNvcmQucm9vdEtleSlcbiAgICAgICAgICAgICAgICAgICAgUEIudGhyb3dFcnJvcignVGhhdCBwcml2YXRlIHJvb3Qga2V5IGRvZXMgbm90IG1hdGNoIHRoZSBwdWJsaWMgcm9vdCBrZXkgb24gcmVjb3JkJylcbiAgICAgICAgICAgICAgICBpZiggIHByaXZhdGVBZG1pbktleSAmJiBQQi5DcnlwdG8ucHJpdmF0ZVRvUHVibGljKHByaXZhdGVBZG1pbktleSkgIT0gdXNlclJlY29yZC5hZG1pbktleSlcbiAgICAgICAgICAgICAgICAgICAgUEIudGhyb3dFcnJvcignVGhhdCBwcml2YXRlIGFkbWluIGtleSBkb2VzIG5vdCBtYXRjaCB0aGUgcHVibGljIGFkbWluIGtleSBvbiByZWNvcmQnKVxuICAgICAgICAgICAgICAgIGlmKHByaXZhdGVEZWZhdWx0S2V5ICYmIFBCLkNyeXB0by5wcml2YXRlVG9QdWJsaWMocHJpdmF0ZURlZmF1bHRLZXkpICE9IHVzZXJSZWNvcmQuZGVmYXVsdEtleSlcbiAgICAgICAgICAgICAgICAgICAgUEIudGhyb3dFcnJvcignVGhhdCBwcml2YXRlIGRlZmF1bHQga2V5IGRvZXMgbm90IG1hdGNoIHRoZSBwdWJsaWMgZGVmYXVsdCBrZXkgb24gcmVjb3JkJylcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJSZWNvcmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICwgUEIuY2F0Y2hFcnJvcignQ291bGQgbm90IHN0b3JlIHByaXZhdGUga2V5cyBkdWUgdG8gZmF1bHR5IHVzZXIgcmVjb3JkJykpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZXMoKSB7XG4gICAgICAgIGlmKCFQQi5DT05GSUcuZXBoZW1lcmFsS2V5Y2hhaW4pXG4gICAgICAgICAgICBQQi5QZXJzaXN0LnNhdmUoJ2lkZW50aXRpZXMnLCBpZGVudGl0aWVzKVxuXG4gICAgICAgIC8vIFRISU5LOiBjb25zaWRlciB6aXBwaW5nIGlkZW50aXRpZXMgaW4gbG9jYWxTdG9yYWdlIHRvIHByZXZlbnQgc2hvdWxkZXItc3VyZmluZyBhbmQgc2F2ZSBzcGFjZSAoc2FtZSBmb3IgcHVmZnMpXG4gICAgICAgIC8vIFRISU5LOiBjb25zaWRlciBwYXNzcGhyYXNlIHByb3RlY3RpbmcgaWRlbnRpdGllcyBhbmQgcHJpdmF0ZSBwdWZmcyBpbiBsb2NhbFN0b3JhZ2VcbiAgICAgICAgLy8gVE9ETzogZG9uJ3QgcGVyc2lzdCBwcmltYXJ5IC0tIHJlZ2VuZXJhdGUgaXQgYXQgbG9hZCB0aW1lLCBzbyB3ZSBkb24ndCBkdXBsaWNhdGUgdGhlIGFsaWFzXG4gICAgICAgIFBCLlBlcnNpc3Quc2F2ZSgnY3VycmVudFVzZXJuYW1lJywgY3VycmVudFVzZXJuYW1lKVxuXG4gICAgICAgIFBCLnJ1bkhhbmRsZXJzKCdpZGVudGl0eVVwZGF0ZScpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudElkZW50aXR5KCkge1xuICAgICAgICByZXR1cm4gZ2V0SWRlbnRpdHkoY3VycmVudFVzZXJuYW1lKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElkZW50aXR5KHVzZXJuYW1lKSB7XG4gICAgICAgIGlmKCF1c2VybmFtZSkgXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICB2YXIgaWRlbnRpdHkgPSBpZGVudGl0aWVzW3VzZXJuYW1lXVxuXG4gICAgICAgIC8vIFRISU5LOiB3ZSBjb3VsZCBjaGVjayB0aGUgYWxpYXNlcyBtYXAgaGVyZSBpbiBjYXNlIHRoZSB1c2VybmFtZSBpc24ndCBwcmltYXJ5XG5cbiAgICAgICAgaWYoIWlkZW50aXR5KSBcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgICAgIHJldHVybiBpZGVudGl0eVxuICAgIH1cblxufSgpIC8vIGVuZCB0aGUgY2xvc3VyZSJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==